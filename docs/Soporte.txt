======================================================================
     DOCUMENTACIÓN TÉCNICA Y LÓGICA DE MÓDULOS CLAVE
======================================================================
Este archivo sirve como un backup conceptual de la lógica para los módulos
de Soporte Técnico, Gestor de Proyectos y Gestión de Licencias.

--- ÍNDICE ---
1. Módulo de Soporte Técnico (Tickets)
   1.1. Estructura de la Base de Datos (tickets.db)
   1.2. Lógica del Servidor (db.ts)
   1.3. Lógica del Cliente (hooks/useTickets.ts)
   1.4. Interfaz de Usuario (page.tsx)

2. Módulo Gestor de Proyectos (Planner)
   2.1. Estructura de la Base de Datos (planner.db)
   2.2. Lógica del Servidor (db.ts)
   2.3. Lógica del Cliente (hooks/usePlanner.ts)
   2.4. Interfaz de Usuario (page.tsx)

3. Módulo de Gestión de Licencias (Simplificado)
   3.1. Concepto Simplificado
   3.2. Estructura de la Base de Datos (licenses.db)
   3.3. Lógica del Servidor (db.ts - Simplificada)
   3.4. Lógica del Cliente (hooks/useLicenses.ts - Simplificada)
   3.5. Interfaz de Usuario (page.tsx)

======================================================================
 1. MÓDULO DE SOPORTE TÉCNICO (TICKETS)
======================================================================

----------------------------------------------------------------------
 1.1. Estructura de la Base de Datos (tickets.db)
----------------------------------------------------------------------
-- Archivo: src/modules/tickets/lib/db.ts (Función initializeTicketsDb)

-- Propósito: Almacena toda la información relacionada con el sistema de tickets.
-- Es una base de datos independiente para garantizar la modularidad.

CREATE TABLE IF NOT EXISTS client_companies (
    -- Almacena empresas clientes que no están en el ERP.
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    taxId TEXT UNIQUE NOT NULL,
    address TEXT,
    phone TEXT,
    email TEXT,
    createdAt TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS help_topics (
    -- Define categorías de problemas para automatizar la asignación.
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT UNIQUE NOT NULL,
    defaultPriority TEXT,
    defaultAssigneeId INTEGER, -- ID del usuario técnico
    defaultServiceId TEXT -- ID del servicio del catálogo principal
);

CREATE TABLE IF NOT EXISTS tickets (
    -- Tabla principal que contiene cada ticket.
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    consecutive TEXT UNIQUE NOT NULL,
    subject TEXT NOT NULL,
    status TEXT NOT NULL, -- open, in_progress, on_hold, closed
    priority TEXT NOT NULL, -- low, medium, high, urgent
    createdAt TEXT NOT NULL,
    updatedAt TEXT NOT NULL,
    dueDate TEXT,
    
    companyId INTEGER, -- ID de la empresa cliente (de client_companies)
    
    -- Datos desnormalizados para acceso rápido
    customerName TEXT, 
    companyName TEXT, 

    assigneeId INTEGER, -- ID del usuario técnico asignado
    helpTopicId INTEGER,
    serviceId TEXT,

    FOREIGN KEY (companyId) REFERENCES client_companies(id) ON DELETE SET NULL,
    FOREIGN KEY (helpTopicId) REFERENCES help_topics(id)
);

CREATE TABLE IF NOT EXISTS ticket_threads (
    -- Almacena la conversación (hilo) de cada ticket.
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    ticketId INTEGER NOT NULL,
    userId INTEGER, -- ID del técnico que responde
    userName TEXT, -- Nombre del técnico o cliente
    type TEXT NOT NULL, -- message, note, status_change
    content TEXT,
    createdAt TEXT NOT NULL,
    FOREIGN KEY (ticketId) REFERENCES tickets(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS ticket_settings (
    -- Configuraciones específicas del módulo de tickets.
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL
);


----------------------------------------------------------------------
 1.2. Lógica del Servidor (src/modules/tickets/lib/db.ts)
----------------------------------------------------------------------
-- Propósito: Funciones que se ejecutan en el servidor para interactuar
-- de forma segura con la base de datos de tickets.

/**
 * Añade un nuevo ticket a la base de datos.
 */
export async function addTicket(payload: NewTicketPayload, user: User): Promise<Ticket> {
    const db = await connectDb(TICKETS_DB_FILE);
    
    // Lógica para obtener el siguiente número consecutivo
    const { prefix, number } = await getNextTicketNumber(db);

    const transaction = db.transaction(() => {
        const consecutive = `${prefix}${number.toString().padStart(6, '0')}`;
        const now = new Date().toISOString();
        
        let priority = payload.priority;
        let assigneeId = payload.assigneeId;

        // Asignación automática basada en el tema de ayuda
        if (payload.helpTopicId) {
            const topic = db.prepare('SELECT * FROM help_topics WHERE id = ?').get(payload.helpTopicId) as HelpTopic | undefined;
            if (topic) {
                if (topic.defaultPriority && !payload.priority) priority = topic.defaultPriority;
                if (topic.defaultAssigneeId !== undefined && payload.assigneeId === undefined) assigneeId = topic.defaultAssigneeId;
            }
        }
        
        const ticketInsertInfo = db.prepare(/*...SQL INSERT...*/).run(/*...payload...*/);
        const newTicketId = ticketInsertInfo.lastInsertRowid;

        // Crear la primera entrada en el hilo del ticket
        db.prepare(/*...SQL INSERT into ticket_threads...*/).run(newTicketId, user.id, user.name, 'message', payload.content, now);

        // Actualizar el contador de tickets
        db.prepare('UPDATE ticket_settings SET value = ? WHERE key = ?').run(String(number + 1), 'nextTicketNumber');

        const newTicket = db.prepare('SELECT * FROM tickets WHERE id = ?').get(newTicketId) as Ticket;
        return newTicket;
    });

    const result = transaction();
    return JSON.parse(JSON.stringify(result));
}

/**
 * Actualiza los detalles de un ticket (estado, prioridad, asignado).
 */
export async function updateTicketDetails(ticketId: number, updates: Partial<Pick<Ticket, 'status' | 'priority' | 'assigneeId'>>, user: User): Promise<Ticket> {
    const db = await connectDb(TICKETS_DB_FILE);
    const currentTicket = db.prepare('SELECT * FROM tickets WHERE id = ?').get(ticketId) as Ticket;
    // ...
    // Lógica para construir la consulta UPDATE dinámicamente
    // ...
    // Crear una entrada en el historial (ticket_threads) con el cambio de estado
    // ...
    const result = db.prepare('SELECT * FROM tickets WHERE id = ?').get(ticketId) as Ticket;
    return JSON.parse(JSON.stringify(result));
}

----------------------------------------------------------------------
 1.3. Lógica del Cliente (src/modules/tickets/hooks/useTickets.ts)
----------------------------------------------------------------------
-- Propósito: Hook de React que encapsula toda la lógica de estado y
-- las interacciones del usuario para la interfaz de tickets.

export const useTickets = () => {
    // ... Estados para isLoading, tickets, filtros, diálogos, etc. ...
    const [state, setState] = useState(initialState);
    
    // Carga los datos iniciales (tickets, temas de ayuda) desde el servidor
    const loadInitialData = useCallback(async () => {
        // ...
    }, []);

    // Acciones que el usuario puede realizar
    const actions = {
        // Maneja la creación de un nuevo ticket
        handleCreateTicket: async () => {
            // ... validaciones ...
            const createdTicket = await saveTicket(state.newTicket, user);
            // ... actualizar estado local ...
        },

        // Obtiene un ticket específico y su conversación
        getTicketById: async (id: number) => {
            // ...
        },

        // Añade una respuesta al hilo de un ticket
        addThreadEntry: async (payload) => {
            // ...
        },

        // Actualiza los detalles de un ticket
        updateTicketDetails: async (ticketId, updates, user) => {
            // ...
        },
        
        // Etc...
    };

    // Selectores y datos memoizados para optimizar el renderizado
    const selectors = {
        // ... Lógica para filtrar tickets basado en el estado de los filtros ...
        filteredTickets: useMemo(() => {
            // ...
        }, [state.tickets, debouncedSearchTerm, state.statusFilter, state.priorityFilter])
    };

    return { state, actions, selectors };
};


======================================================================
 2. MÓDULO GESTOR DE PROYECTOS (PLANNER)
======================================================================

----------------------------------------------------------------------
 2.1. Estructura de la Base de Datos (planner.db)
----------------------------------------------------------------------
-- Archivo: src/modules/planner/lib/db.ts (Función initializePlannerDb)

CREATE TABLE IF NOT EXISTS planner_settings (
    -- Configuraciones del módulo
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS production_orders (
    -- Tabla principal de proyectos
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    consecutive TEXT UNIQUE NOT NULL,
    purchaseOrder TEXT, -- OC del cliente
    requestDate TEXT NOT NULL,
    deliveryDate TEXT NOT NULL, -- Fecha de entrega al cliente
    scheduledStartDate TEXT, -- Fecha de inicio programada
    scheduledEndDate TEXT, -- Fecha de fin programada
    customerId TEXT NOT NULL,
    productId TEXT NOT NULL,
    quantity REAL NOT NULL,
    priority TEXT NOT NULL, -- low, medium, high, urgent
    status TEXT NOT NULL, -- pending, approved, in-progress, etc.
    notes TEXT,
    requestedBy TEXT NOT NULL,
    approvedBy TEXT,
    hasBeenModified BOOLEAN DEFAULT FALSE, -- Bandera si se edita después de aprobado
    assignmentId TEXT -- A quién está asignado (técnico, máquina, etc.)
);

CREATE TABLE IF NOT EXISTS production_order_history (
    -- Historial de cambios de estado para cada proyecto
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    orderId INTEGER NOT NULL,
    timestamp TEXT NOT NULL,
    status TEXT NOT NULL,
    notes TEXT,
    updatedBy TEXT NOT NULL,
    FOREIGN KEY (orderId) REFERENCES production_orders(id)
);

----------------------------------------------------------------------
 2.2. Lógica del Servidor (src/modules/planner/lib/db.ts)
----------------------------------------------------------------------
-- Propósito: Funciones del servidor para manejar la base de datos del planificador.

/**
 * Añade un nuevo proyecto a la base de datos.
 */
export async function addOrder(order: Omit<ProductionOrder, ...>, requestedBy: string): Promise<ProductionOrder> {
    const db = await connectDb(PLANNER_DB_FILE);
    // ... Obtener consecutivo y configuraciones ...
    const stmt = db.prepare(/*... SQL INSERT ...*/);
    const info = stmt.run(/*... order data ...*/);
    const newOrderId = info.lastInsertRowid as number;
    // ... Actualizar consecutivo y registrar en historial ...
    const createdOrder = db.prepare('SELECT * FROM production_orders WHERE id = ?').get(newOrderId) as ProductionOrder;
    return JSON.parse(JSON.stringify(createdOrder));
}

/**
 * Actualiza el estado de un proyecto (ej: de 'pendiente' a 'aprobado').
 */
export async function updateStatus(payload: UpdateStatusPayload): Promise<ProductionOrder> {
    const db = await connectDb(PLANNER_DB_FILE);
    // ...
    // Lógica de transacción para actualizar el estado y registrar en el historial
    // ...
    const updatedOrder = db.prepare('SELECT * FROM production_orders WHERE id = ?').get(orderId) as ProductionOrder;
    return JSON.parse(JSON.stringify(updatedOrder));
}

/**
 * Actualiza detalles menores de un proyecto (prioridad, asignación, fechas).
 */
export async function updateDetails(payload: UpdateOrderDetailsPayload): Promise<ProductionOrder> {
    const db = await connectDb(PLANNER_DB_FILE);
    // ...
    // Lógica para construir la consulta UPDATE dinámicamente y registrar en historial
    // ...
    const updatedOrder = db.prepare('SELECT * FROM production_orders WHERE id = ?').get(orderId) as ProductionOrder;
    return JSON.parse(JSON.stringify(updatedOrder));
}


----------------------------------------------------------------------
 2.3. Lógica del Cliente (src/modules/planner/hooks/usePlanner.ts)
----------------------------------------------------------------------
-- Propósito: Hook de React que encapsula la lógica y estado del Gestor de Proyectos.

export const usePlanner = () => {
    // ... Estados para órdenes, filtros, diálogos, etc. ...
    const [state, setState] = useState(initialState);
    
    // Carga los datos iniciales del servidor
    const loadInitialData = useCallback(async () => {
        // ...
    }, []);

    // Acciones del usuario
    const actions = {
        // Crear un nuevo proyecto
        handleCreateOrder: async () => {
            // ...
        },
        // Editar un proyecto existente
        handleEditOrder: async (e: React.FormEvent) => {
            // ...
        },
        // Abrir el diálogo para cambiar de estado
        openStatusDialog: (order: ProductionOrder, status: ProductionOrderStatus) => {
            // ...
        },
        // Manejar la actualización de estado
        handleStatusUpdate: async () => {
            // ...
        },
        // Manejar la actualización de detalles (prioridad, etc.)
        handleDetailUpdate: async (orderId, details) => {
            // ...
        },
        // Etc...
    };

    // Selectores para memoizar cálculos y filtros
    const selectors = {
        // ...
        filteredOrders: useMemo(() => {
            // Lógica para filtrar las órdenes según los filtros activos
        }, [/* dependencias */]),
    };

    return { state, actions, selectors, isAuthorized };
};


======================================================================
 3. MÓDULO DE GESTIÓN DE LICENCIAS (SIMPLIFICADO)
======================================================================

----------------------------------------------------------------------
 3.1. Concepto Simplificado
----------------------------------------------------------------------
-- Propósito: Este módulo, en su forma simplificada, permite registrar
-- y dar seguimiento a licencias de software de forma manual. El objetivo
-- es asociar una clave de licencia (un texto cualquiera) y una fecha de
-- vencimiento a un cliente y un ID de equipo (Hardware ID). No utiliza
-- criptografía ni generación de archivos; es un registro informativo.

----------------------------------------------------------------------
 3.2. Estructura de la Base de Datos (licenses.db)
----------------------------------------------------------------------
-- Archivo: src/modules/licenses/lib/db.ts (Función initializeLicensesDb)

CREATE TABLE IF NOT EXISTS software_products (
    -- Catálogo de los productos de software que se licencian.
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE,
    isInternal BOOLEAN NOT NULL DEFAULT FALSE
);

CREATE TABLE IF NOT EXISTS licenses (
    -- Tabla principal que almacena cada licencia asignada.
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    licenseKey TEXT NOT NULL, -- Aquí se guarda la clave manual ingresada.
    softwareId INTEGER NOT NULL,
    clientCompanyId INTEGER,
    hardwareId TEXT, -- ID del equipo al que se liga la licencia.
    isPerpetual BOOLEAN NOT NULL DEFAULT FALSE,
    expirationDate TEXT,
    status TEXT NOT NULL DEFAULT 'active',
    createdAt TEXT NOT NULL,
    FOREIGN KEY (softwareId) REFERENCES software_products(id)
);

----------------------------------------------------------------------
 3.3. Lógica del Servidor (src/modules/licenses/lib/db.ts - Simplificada)
----------------------------------------------------------------------

/**
 * Añade una nueva licencia manual a la base de datos.
 */
export async function addLicense(licenseData: Omit<License, 'id' | 'createdAt'>): Promise<License> {
    const db = await connectDb(LICENSES_DB_FILE);
    
    // Se eliminó la lógica de firma criptográfica.
    // La clave se guarda directamente como texto.
    
    const info = db.prepare(`
        INSERT INTO licenses (licenseKey, softwareId, clientCompanyId, hardwareId, isPerpetual, expirationDate, status, createdAt)
        VALUES (@licenseKey, @softwareId, @clientCompanyId, @hardwareId, @isPerpetual, @expirationDate, @status, @createdAt)
    `).run({
        licenseKey: licenseData.licenseKey, // Clave de licencia manual
        softwareId: licenseData.softwareId,
        clientCompanyId: licenseData.clientCompanyId,
        hardwareId: licenseData.hardwareId,
        isPerpetual: licenseData.isPerpetual ? 1 : 0,
        expirationDate: licenseData.expirationDate,
        status: 'active',
        createdAt: new Date().toISOString()
    });

    const result = db.prepare('SELECT * FROM licenses WHERE id = ?').get(info.lastInsertRowid) as License;
    return JSON.parse(JSON.stringify(result));
}

/**
 * Actualiza una licencia existente.
 */
export async function updateLicense(license: License): Promise<License> {
    const db = await connectDb(LICENSES_DB_FILE);
    
    // La clave también se actualiza directamente como texto.
    db.prepare(`
        UPDATE licenses SET
            licenseKey = @licenseKey,
            softwareId = @softwareId,
            clientCompanyId = @clientCompanyId,
            hardwareId = @hardwareId,
            isPerpetual = @isPerpetual,
            expirationDate = @expirationDate,
            status = @status
        WHERE id = @id
    `).run({
        ...license,
        isPerpetual: license.isPerpetual ? 1 : 0,
    });
    const result = db.prepare('SELECT * FROM licenses WHERE id = ?').get(license.id) as License;
    return JSON.parse(JSON.stringify(result));
}

----------------------------------------------------------------------
 3.4. Lógica del Cliente (src/modules/licenses/hooks/useLicenses.ts - Simplificada)
----------------------------------------------------------------------

export const useLicenses = () => {
    // ... Estados para licencias, productos, clientes, etc. ...
    
    // Carga los datos iniciales
    const loadInitialData = useCallback(async () => { /* ... */ }, []);

    // Acción para guardar la licencia (nueva o editada)
    const handleSaveLicense = async () => {
        if (!state.currentLicense.softwareId || !state.currentLicense.clientCompanyId || !state.currentLicense.licenseKey) {
            toast({ title: "Datos incompletos", description: "Cliente, producto y clave son requeridos.", variant: "destructive" });
            return;
        }
        
        // ... Lógica para llamar a addLicense o updateLicense del servidor ...
    };
    
    // Se elimina la acción `downloadLicenseFile` ya que no se genera un archivo.
    // El resto de acciones (editar, eliminar, gestionar software) permanecen similares.

    return { state, actions, selectors };
};

----------------------------------------------------------------------
 3.5. Interfaz de Usuario (src/app/dashboard/licenses/page.tsx - Simplificada)
----------------------------------------------------------------------
-- Propósito: El formulario para crear/editar una licencia ahora incluye
-- un campo de texto para ingresar la clave de licencia manualmente.

// Dentro del DialogContent del formulario:
<div className="space-y-2">
    <Label htmlFor="license-key">Clave de Licencia</Label>
    <Input 
        id="license-key" 
        value={state.currentLicense.licenseKey || ''} 
        onChange={(e) => actions.handleCurrentLicenseChange('licenseKey', e.target.value)}
        placeholder="Pega aquí la clave de licencia manual"
        required
    />
</div>
<div className="space-y-2">
    <Label htmlFor="hardware-id">Hardware ID (ID del Equipo)</Label>
    <Input 
        id="hardware-id" 
        value={state.currentLicense.hardwareId || ''} 
        onChange={(e) => actions.handleCurrentLicenseChange('hardwareId', e.target.value)} 
        placeholder="ID único del equipo del cliente"
    />
</div>
// ... resto de los campos (cliente, software, fecha de vencimiento) ...
