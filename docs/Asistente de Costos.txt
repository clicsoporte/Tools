en /docs
======================================================================
  Lógica y Código del Módulo "Asistente de Costos"
======================================================================

Este documento describe la arquitectura completa y el flujo de trabajo del módulo "Asistente de Costos". El objetivo es proporcionar una guía técnica detallada de cómo funciona cada parte, desde la interfaz de usuario hasta la base de datos.

---
### 1. Arquitectura y Flujo de Datos
---

El módulo sigue una arquitectura moderna de Next.js con una clara separación de responsabilidades, lo que lo hace mantenible y seguro.

1.  **Componente de UI (`page.tsx`):** Es la capa de presentación. Se encarga de renderizar la interfaz (botones, tablas, campos de entrada) y de conectar las acciones del usuario (como hacer clic en un botón) con la lógica del hook. Es un componente "tonto" que solo muestra datos y delega la lógica.

2.  **Hook Personalizado (`useCostAssistant.ts`):** Este es el **cerebro** del módulo en el lado del cliente. Gestiona todo el estado (lista de artículos, costos adicionales, etc.), los cálculos (prorrateo, márgenes, totales) y la lógica de interacción. Cuando se necesita una operación de servidor (como guardar un borrador), este hook llama a una "Server Action".

3.  **Server Actions (`actions.ts`):** Este archivo actúa como un **puente seguro** entre el cliente y el servidor. Contiene funciones marcadas con `'use server'` que pueden ser llamadas directamente desde el código del cliente, pero se ejecutan exclusivamente en el servidor. Su única responsabilidad es recibir datos del cliente y pasarlos a la capa de base de datos.

4.  **Capa de Base de Datos (`db.ts`):** Este archivo contiene la lógica para interactuar directamente con la base de datos de Firestore. Se encarga de guardar, leer y eliminar documentos, asegurando que toda la manipulación de datos se realice de forma segura en el servidor.

**Flujo Visual:**

```
[UI: page.tsx] ---> [Lógica del Cliente: useCostAssistant.ts] ---> [Server Actions: actions.ts] ---> [Base de Datos: db.ts]
     (Botones,        (Maneja el estado, llama a las             (Funciones 'use server' que       (Interactúa con
      Tablas)          acciones del servidor)                      llaman a la lógica de DB)         Firestore)
```

---
### 2. Lógica Clave: Procesamiento de XML
---

El corazón del asistente es su capacidad para procesar facturas XML.

1.  **Carga de Archivos:** La UI utiliza la librería `react-dropzone` para permitir al usuario arrastrar o seleccionar archivos XML.
2.  **Lectura en el Cliente:** El hook `useCostAssistant.ts` lee el contenido de los archivos como texto.
3.  **Envío al Servidor:** El contenido de los XML se envía a la `server action` `processInvoiceXmls` en `actions.ts`.
4.  **Parseo en el Servidor:** La función `processInvoiceXmls` utiliza la librería `fast-xml-parser` para convertir el texto XML en un objeto JavaScript.
5.  **Extracción de Datos:** La lógica recorre el objeto JSON, extrayendo datos clave como el nombre del proveedor, el número de factura y, lo más importante, cada "LineaDetalle".
6.  **Cálculo y Normalización:** Para cada línea, calcula los costos unitarios, normaliza las monedas (convirtiendo USD a CRC si es necesario) y empaqueta la información en un formato estandarizado (`CostAssistantLine`).
7.  **Devolución al Cliente:** La `server action` devuelve un array de objetos `CostAssistantLine` al hook, que actualiza el estado y la tabla en la interfaz.

---
### 3. Lógica Clave: Cálculo de Precios
---

Los cálculos se realizan en tiempo real en el lado del cliente dentro del hook `useCostAssistant.ts` usando `useMemo` para optimizar el rendimiento.

1.  **Costo Total de Artículos:** Se calcula la suma de `(cantidad * costo unitario sin impuestos)` para todos los artículos.
2.  **Costos Adicionales Totales:** Se suman el transporte y otros costos ingresados por el usuario.
3.  **Prorrateo:** El costo adicional total se divide por el número total de unidades de todos los artículos. Este "costo adicional por unidad" se suma al costo unitario de cada artículo para obtener el **costo final real**.
4.  **Cálculo del Precio de Venta:** Para cada línea, se aplica la fórmula: `Precio de Venta (sin IVA) = Costo Final Real / (1 - Margen de Ganancia)`.
5.  **Precio Final:** Al precio de venta sin IVA se le suma el impuesto correspondiente (`Precio de Venta * Tasa de Impuesto`).
6.  **Totales Generales:** Se calculan el ingreso total estimado y la ganancia bruta restando el costo total final del ingreso total.

---
### 4. Código Completo del Módulo
---

A continuación se muestra el código fuente completo de cada archivo que compone el módulo.

#### **Archivo 1: `src/app/dashboard/cost-assistant/page.tsx` (La Interfaz de Usuario)**

```tsx
/**
 * @fileoverview Page for the Cost Assistant module.
 * Allows users to upload purchase invoice XMLs and calculate selling prices.
 */
'use client';

import { useCostAssistant } from '@/modules/cost-assistant/hooks/useCostAssistant';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle, CardFooter } from '@/components/ui/card';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { useDropzone } from 'react-dropzone';
import { FileScan, UploadCloud, Loader2, Percent, Calculator, Trash2, Settings2, FilePlus, Save, Briefcase, CheckCircle, XCircle, FolderClock, FileDown, Download } from 'lucide-react';
import { cn } from '@/lib/utils';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { Checkbox } from '@/components/ui/checkbox';
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, AlertDialogTrigger } from '@/components/ui/alert-dialog';
import { Sheet, SheetContent, SheetDescription, SheetHeader, SheetTitle, SheetTrigger, SheetClose } from '@/components/ui/sheet';
import { format, parseISO, isValid } from 'date-fns';
import { ScrollArea } from '@/components/ui/scroll-area';
import type { CostAnalysisDraft } from '@/modules/core/types';

export default function CostAssistantPage() {
    const {
        state,
        actions,
    } = useCostAssistant();

    const { getRootProps, getInputProps, isDragActive } = useDropzone({
        onDrop: actions.handleFilesDrop,
        accept: { 'text/xml': ['.xml'] },
        multiple: true,
    });
    
    const columns = [
        { id: 'cabysCode', label: 'Cabys', defaultVisible: true, className: 'min-w-[150px]' },
        { id: 'supplierCode', label: 'Cód. Artículo', defaultVisible: true, className: 'min-w-[150px]' },
        { id: 'description', label: 'Descripción', defaultVisible: true, className: 'min-w-[400px]' },
        { id: 'quantity', label: 'Cant.', defaultVisible: true, className: 'w-[120px] min-w-[120px] text-right' },
        { id: 'unitCostWithoutTax', label: 'Costo Unit. (s/IVA)', defaultVisible: true, className: 'min-w-[180px] text-right', tooltip: 'Costo por unidad sin impuestos después de prorratear costos adicionales.' },
        { id: 'unitCostWithTax', label: 'Costo Unit. (c/IVA)', defaultVisible: false, className: 'min-w-[180px] text-right' },
        { id: 'taxRate', label: 'Imp. %', defaultVisible: true, className: 'min-w-[80px] text-center' },
        { id: 'margin', label: 'Margen', defaultVisible: true, className: 'w-[120px] min-w-[120px] text-right' },
        { id: 'sellPriceWithoutTax', label: 'P.V.P Unitario (s/IVA)', defaultVisible: true, className: 'min-w-[180px] text-right', tooltip: 'Precio de Venta al Público por unidad, sin impuestos.' },
        { id: 'finalSellPrice', label: 'P.V.P Unitario Sugerido', defaultVisible: true, className: 'min-w-[180px] text-right', tooltip: 'Precio de Venta al Público final por unidad (con IVA incluido).' },
        { id: 'profitPerLine', label: 'Ganancia por Línea', defaultVisible: true, className: 'min-w-[180px] text-right', tooltip: 'Ganancia total para esta línea de productos (Cantidad x Ganancia por unidad).' },
    ];

    return (
        <TooltipProvider>
            <main className="flex-1 p-4 md:p-6 lg:p-8 space-y-6">
                <Card>
                    <CardHeader className="flex flex-col md:flex-row items-start md:items-center justify-between gap-4">
                        <div>
                            <CardTitle>Asistente de Costos y Precios</CardTitle>
                            <CardDescription>Carga facturas XML para extraer artículos, añadir costos y calcular precios de venta.</CardDescription>
                        </div>
                         <div className="flex items-center gap-2 flex-wrap">
                             <AlertDialog>
                                <AlertDialogTrigger asChild>
                                    <Button variant="outline"><FilePlus className="mr-2 h-4 w-4"/>Nueva Operación</Button>
                                </AlertDialogTrigger>
                                <AlertDialogContent>
                                    <AlertDialogHeader>
                                        <AlertDialogTitle>¿Iniciar una nueva operación?</AlertDialogTitle>
                                        <AlertDialogDescription>
                                            Esta acción limpiará todos los artículos, costos y facturas cargadas. ¿Deseas continuar?
                                        </AlertDialogDescription>
                                    </AlertDialogHeader>
                                    <AlertDialogFooter>
                                        <AlertDialogCancel>Cancelar</AlertDialogCancel>
                                        <AlertDialogAction onClick={actions.handleClear}>Sí, limpiar todo</AlertDialogAction>
                                    </AlertDialogFooter>
                                </AlertDialogContent>
                            </AlertDialog>
                            <Sheet onOpenChange={(open) => open && actions.loadDrafts()}>
                                <SheetTrigger asChild>
                                    <Button variant="outline"><FolderClock className="mr-2 h-4 w-4"/>Cargar Borradores</Button>
                                </SheetTrigger>
                                <SheetContent className="sm:max-w-2xl">
                                    <SheetHeader>
                                        <SheetTitle>Borradores Guardados</SheetTitle>
                                        <SheetDescription>Selecciona un análisis guardado para continuar trabajando en él.</SheetDescription>
                                    </SheetHeader>
                                    <div className="py-4">
                                        <ScrollArea className="h-[80vh]">
                                            {state.drafts && state.drafts.length > 0 ? (
                                                <div className="space-y-3 pr-4">
                                                    {state.drafts.map((draft) => (
                                                        <Card key={draft.id}>
                                                            <CardHeader>
                                                                <CardTitle className="text-lg">{draft.name}</CardTitle>
                                                                <CardDescription>Guardado el {format(parseISO(draft.createdAt), 'dd/MM/yyyy HH:mm')}</CardDescription>
                                                            </CardHeader>
                                                            <CardFooter className="flex justify-end gap-2">
                                                                <AlertDialog>
                                                                    <AlertDialogTrigger asChild><Button variant="destructive" size="sm">Eliminar</Button></AlertDialogTrigger>
                                                                    <AlertDialogContent>
                                                                        <AlertDialogHeader>
                                                                            <AlertDialogTitle>¿Eliminar Borrador?</AlertDialogTitle>
                                                                            <AlertDialogDescription>Esta acción no se puede deshacer.</AlertDialogDescription>
                                                                        </AlertDialogHeader>
                                                                        <AlertDialogFooter>
                                                                            <AlertDialogCancel>Cancelar</AlertDialogCancel>
                                                                            <AlertDialogAction onClick={() => actions.deleteDraft(draft.id)}>Sí, eliminar</AlertDialogAction>
                                                                        </AlertDialogFooter>
                                                                    </AlertDialogContent>
                                                                </AlertDialog>
                                                                <SheetClose asChild>
                                                                    <Button size="sm" onClick={() => actions.loadDraft(draft)}>Cargar</Button>
                                                                </SheetClose>
                                                            </CardFooter>
                                                        </Card>
                                                    ))}
                                                </div>
                                            ) : (
                                                <p className="text-center text-muted-foreground py-8">No hay borradores guardados.</p>
                                            )}
                                        </ScrollArea>
                                    </div>
                                </SheetContent>
                            </Sheet>
                            <Button onClick={() => actions.saveDraft(prompt("Asigna un nombre a este borrador:") || `Borrador ${new Date().toLocaleString()}`)}><Save className="mr-2 h-4 w-4"/>Guardar Borrador</Button>
                        </div>
                    </CardHeader>
                    <CardContent>
                         <div className="grid grid-cols-1 lg:grid-cols-3 gap-6 items-start">
                             <div className="lg:col-span-1 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-1 gap-6">
                                <Card>
                                    <CardHeader>
                                        <CardTitle>Costos Adicionales</CardTitle>
                                    </CardHeader>
                                    <CardContent className="space-y-4">
                                        <div className="space-y-2">
                                            <Label htmlFor="transport-cost">Costo de Transporte (Total)</Label>
                                            <Input 
                                                id="transport-cost" 
                                                type="number" 
                                                value={state.transportCost || ''}
                                                onChange={(e) => actions.setTransportCost(Number(e.target.value))}
                                                placeholder="Ej: 5000"
                                            />
                                        </div>
                                        <div className="space-y-2">
                                            <Label htmlFor="other-costs">Otros Costos (Total)</Label>
                                            <Input 
                                                id="other-costs" 
                                                type="number" 
                                                value={state.otherCosts || ''}
                                                onChange={(e) => actions.setOtherCosts(Number(e.target.value))}
                                                placeholder="Ej: 10000"
                                            />
                                        </div>
                                    </CardContent>
                                </Card>
                                <Card>
                                    <CardHeader>
                                        <CardTitle className="flex items-center gap-2"><Calculator className="h-5 w-5"/>Resumen General</CardTitle>
                                    </CardHeader>
                                    <CardContent className="space-y-2 text-sm">
                                        <div className="flex justify-between">
                                            <span className="text-muted-foreground">Costo Total de Compra:</span>
                                            <span className="font-medium">{actions.formatCurrency(state.totals.totalPurchaseCost)}</span>
                                        </div>
                                        <div className="flex justify-between">
                                            <span className="text-muted-foreground">Costos Adicionales Totales:</span>
                                            <span className="font-medium">{actions.formatCurrency(state.totals.totalAdditionalCosts)}</span>
                                        </div>
                                        <div className="flex justify-between font-bold border-t pt-2">
                                            <span>Costo Total Final:</span>
                                            <span>{actions.formatCurrency(state.totals.totalFinalCost)}</span>
                                        </div>
                                        <div className="flex justify-between text-green-600 font-bold">
                                            <span>Ingreso Total Estimado (Venta):</span>
                                            <span>{actions.formatCurrency(state.totals.totalSellValue)}</span>
                                        </div>
                                        <div className="flex justify-between text-blue-700 font-bold text-lg border-t pt-2">
                                            <span>Ganancia Bruta Estimada:</span>
                                            <span>{actions.formatCurrency(state.totals.estimatedGrossProfit)}</span>
                                        </div>
                                    </CardContent>
                                </Card>
                            </div>
                            <div className="lg:col-span-2 space-y-4">
                               <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                     <Card>
                                        <CardHeader>
                                            <CardTitle className="flex items-center gap-2"><Briefcase className="h-5 w-5" />Facturas Procesadas</CardTitle>
                                        </CardHeader>
                                        <CardContent>
                                            <ScrollArea className="h-40">
                                                {state.processedInvoices.length > 0 ? (
                                                    <ul className="space-y-3 text-sm">
                                                        {state.processedInvoices.map((invoice, index) => (
                                                            <li key={index} className="border-b pb-2">
                                                                <div className="flex justify-between items-start">
                                                                    <div className="flex-1 pr-2">
                                                                        <p className="font-semibold text-muted-foreground">{invoice.invoiceNumber}</p>
                                                                        <p>{invoice.supplierName}</p>
                                                                        <p className="text-xs text-muted-foreground">{isValid(parseISO(invoice.invoiceDate)) ? format(parseISO(invoice.invoiceDate), 'dd/MM/yyyy') : 'Fecha Inválida'}</p>
                                                                    </div>
                                                                    <div className={cn("flex items-center gap-1 text-xs font-medium", invoice.status === 'success' ? 'text-green-600' : 'text-red-600')}>
                                                                        {invoice.status === 'success' ? <CheckCircle className="h-4 w-4" /> : <XCircle className="h-4 w-4" />}
                                                                        <span>{invoice.status === 'success' ? 'Éxito' : 'Error'}</span>
                                                                    </div>
                                                                </div>
                                                                {invoice.status === 'error' && <p className="text-xs text-red-500 mt-1">{invoice.errorMessage}</p>}
                                                            </li>
                                                        ))}
                                                    </ul>
                                                ) : (
                                                    <p className="text-sm text-center text-muted-foreground h-full flex items-center justify-center">Aún no se han cargado facturas.</p>
                                                )}
                                            </ScrollArea>
                                        </CardContent>
                                    </Card>
                                    <div {...getRootProps()} className={cn("flex flex-col items-center justify-center p-4 border-2 border-dashed rounded-lg cursor-pointer transition-colors h-full min-h-[140px]", isDragActive ? 'border-primary bg-primary/10' : 'border-border hover:border-primary/50', state.isProcessing && 'cursor-not-allowed opacity-50')}>
                                        <input {...getInputProps()} disabled={state.isProcessing}/>
                                        {state.isProcessing ? (
                                            <>
                                                <Loader2 className="h-8 w-8 text-primary animate-spin" />
                                                <p className="mt-2 text-center text-primary text-sm">Procesando...</p>
                                            </>
                                        ) : (
                                            <>
                                                <UploadCloud className="w-8 h-8 text-muted-foreground" />
                                                <p className="mt-2 text-center text-muted-foreground text-sm">
                                                    {isDragActive ? "Suelta los XML aquí..." : "Arrastra o haz clic para seleccionar los XML"}
                                                </p>
                                            </>
                                        )}
                                    </div>
                               </div>
                            </div>
                        </div>
                    </CardContent>
                </Card>
                
                <Card>
                    <CardHeader>
                        <div className="flex flex-col sm:flex-row justify-between items-start gap-2">
                             <div>
                                <CardTitle>Artículos Extraídos</CardTitle>
                                <CardDescription>Ajusta los datos y márgenes de ganancia para calcular el precio de venta final.</CardDescription>
                             </div>
                             <div>
                                {state.exportStatus === 'idle' && (
                                    <Button onClick={actions.handleExportToERP} disabled={state.lines.length === 0}>
                                        <FileDown className="mr-2 h-4 w-4" />
                                        Exportar para ERP (Excel)
                                    </Button>
                                )}
                                {state.exportStatus === 'generating' && (
                                    <Button disabled>
                                        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                                        Generando...
                                    </Button>
                                )}
                                {state.exportStatus === 'ready' && state.exportFileName && (
                                    <div className="flex gap-2">
                                        <a href={`/api/temp-exports?file=${state.exportFileName}`} download={state.exportFileName}>
                                            <Button>
                                                <Download className="mr-2 h-4 w-4" />
                                                Descargar Archivo
                                            </Button>
                                        </a>
                                        <Button variant="outline" onClick={actions.handleFinalizeExport}>Finalizar</Button>
                                    </div>
                                )}
                             </div>
                        </div>
                    </CardHeader>
                    <CardContent>
                        <div className="border rounded-md p-4 mb-4">
                             <div className="flex items-center justify-between">
                                <h4 className="font-semibold text-sm flex items-center gap-2"><Settings2 className="h-4 w-4"/> Opciones de Visualización</h4>
                                <Button variant="ghost" size="icon" className="h-8 w-8" onClick={actions.handleSaveColumnVisibility}>
                                    <Save className="h-4 w-4" />
                                </Button>
                            </div>
                            <div className="flex flex-wrap gap-x-4 gap-y-2 mt-2">
                                {columns.map(col => (
                                    <div key={col.id} className="flex items-center space-x-2">
                                        <Checkbox
                                            id={`vis-${col.id}`}
                                            checked={state.columnVisibility[col.id as keyof typeof state.columnVisibility]}
                                            onCheckedChange={(checked) => actions.setColumnVisibility(col.id as keyof typeof state.columnVisibility, !!checked)}
                                        />
                                        <Label htmlFor={`vis-${col.id}`} className="font-normal text-sm">{col.label}</Label>
                                    </div>
                                ))}
                            </div>
                        </div>

                        <div className="w-full overflow-x-auto">
                            <Table>
                                <TableHeader>
                                    <TableRow>
                                        {columns.map(col => state.columnVisibility[col.id as keyof typeof state.columnVisibility] && (
                                            <TableHead key={col.id} className={cn(col.className)}>
                                                {col.tooltip ? (
                                                    <Tooltip>
                                                        <TooltipTrigger className="cursor-help underline decoration-dotted">{col.label}</TooltipTrigger>
                                                        <TooltipContent><p>{col.tooltip}</p></TooltipContent>
                                                    </Tooltip>
                                                ) : col.label}
                                            </TableHead>
                                        ))}
                                        <TableHead className="w-[50px]"></TableHead>
                                    </TableRow>
                                </TableHeader>
                                <TableBody>
                                    {state.lines.length > 0 ? state.lines.map((line) => (
                                        <TableRow key={line.id}>
                                            {state.columnVisibility.cabysCode && <TableCell className={columns.find(c=>c.id === 'cabysCode')?.className}><Input value={line.cabysCode} onChange={e => actions.updateLine(line.id, { cabysCode: e.target.value })} className="h-auto p-1 border-0 font-mono text-xs"/></TableCell>}
                                            {state.columnVisibility.supplierCode && <TableCell className={columns.find(c=>c.id === 'supplierCode')?.className}><Input value={line.supplierCode} onChange={e => actions.updateLine(line.id, { supplierCode: e.target.value })} className="h-auto p-1 border-0 font-mono text-xs"/></TableCell>}
                                            {state.columnVisibility.description && <TableCell className={columns.find(c=>c.id === 'description')?.className}><Input value={line.description} onChange={e => actions.updateLine(line.id, { description: e.target.value })} className="h-auto p-1 border-0"/></TableCell>}
                                            {state.columnVisibility.quantity && <TableCell className={columns.find(c=>c.id === 'quantity')?.className}><Input type="number" value={line.quantity} onChange={e => actions.updateLine(line.id, { quantity: Number(e.target.value) })} className="h-auto p-1 border-0 text-right" /></TableCell>}
                                            {state.columnVisibility.unitCostWithoutTax && <TableCell className={cn(columns.find(c=>c.id === 'unitCostWithoutTax')?.className, "font-mono")}>{actions.formatCurrency(line.unitCostWithoutTax)}</TableCell>}
                                            {state.columnVisibility.unitCostWithTax && <TableCell className={cn(columns.find(c=>c.id === 'unitCostWithTax')?.className, "font-mono")}>{actions.formatCurrency(line.unitCostWithTax)}</TableCell>}
                                            {state.columnVisibility.taxRate && <TableCell className={cn(columns.find(c=>c.id === 'taxRate')?.className, "font-mono text-xs")}>{`${(line.taxRate * 100).toFixed(0)}%`}</TableCell>}
                                            {state.columnVisibility.margin && 
                                                <TableCell className={columns.find(c=>c.id === 'margin')?.className}>
                                                    <div className="relative">
                                                        <Input 
                                                            type="text" 
                                                            value={line.displayMargin}
                                                            onChange={(e) => actions.updateLine(line.id, { displayMargin: e.target.value })}
                                                            onBlur={(e) => actions.handleMarginBlur(line.id, e.target.value)}
                                                            className="h-auto p-1 border-0 text-right pr-6" 
                                                        />
                                                        <Percent className="absolute right-1.5 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground"/>
                                                    </div>
                                                </TableCell>
                                            }
                                            {state.columnVisibility.sellPriceWithoutTax && <TableCell className={cn(columns.find(c=>c.id === 'sellPriceWithoutTax')?.className, "font-mono")}>{actions.formatCurrency(line.sellPriceWithoutTax || 0)}</TableCell>}
                                            {state.columnVisibility.finalSellPrice && <TableCell className={cn(columns.find(c=>c.id === 'finalSellPrice')?.className, "font-bold text-base text-primary")}>{actions.formatCurrency(line.finalSellPrice)}</TableCell>}
                                            {state.columnVisibility.profitPerLine && <TableCell className={cn(columns.find(c=>c.id === 'profitPerLine')?.className, "font-bold text-base text-blue-600")}>{actions.formatCurrency(line.profitPerLine || 0)}</TableCell>}
                                            <TableCell>
                                                <Button variant="ghost" size="icon" onClick={() => actions.removeLine(line.id)}>
                                                    <Trash2 className="h-4 w-4 text-destructive" />
                                                </Button>
                                            </TableCell>
                                        </TableRow>
                                    )) : (
                                        <TableRow>
                                            <TableCell colSpan={columns.length + 1} className="h-24 text-center">
                                                Carga un archivo XML para ver los artículos.
                                            </TableCell>
                                        </TableRow>
                                    )}
                                </TableBody>
                            </Table>
                        </div>
                    </CardContent>
                </Card>
            </main>
        </TooltipProvider>
    );
}
```

#### **Archivo 2: `src/modules/cost-assistant/hooks/useCostAssistant.ts` (El Cerebro del Cliente)**

```ts
/**
 * @fileoverview Custom hook for managing the state and logic of the CostAssistantPage component.
 */
'use client';

import { useState, useMemo, useCallback, useEffect } from 'react';
import { useToast } from '@/modules/core/hooks/use-toast';
import { usePageTitle } from '@/modules/core/hooks/usePageTitle';
import { useAuthorization } from '@/modules/core/hooks/useAuthorization';
import type { CostAssistantLine, ProcessedInvoiceInfo, CostAnalysisDraft } from '@/modules/core/types';
import { processInvoiceXmls, getCostAssistantSettings, saveCostAssistantSettings, getAllDrafts, saveDraft, deleteDraft, exportForERP, cleanupExportFile } from '../lib/actions';
import { logError } from '@/modules/core/lib/logger';
import { useAuth } from '@/modules/core/hooks/useAuth';

const parseDecimal = (str: any): number => {
    if (str === null || str === undefined || str === '') return 0;
    const s = String(str).trim();
    
    // If a comma exists, it is the decimal separator. Remove dots, replace comma.
    if (s.includes(',')) {
        return parseFloat(s.replace(/\./g, '').replace(',', '.'));
    }
    
    // If no comma exists, treat as a standard float, respecting the dot as decimal separator
    return parseFloat(s);
};


const initialColumnVisibility = {
    cabysCode: true,
    supplierCode: true,
    description: true,
    quantity: true,
    unitCostWithoutTax: true,
    unitCostWithTax: false,
    taxRate: true,
    margin: true,
    sellPriceWithoutTax: true,
    finalSellPrice: true,
    profitPerLine: true,
};

type ColumnVisibility = typeof initialColumnVisibility;

type ExportStatus = 'idle' | 'generating' | 'ready';

const initialState = {
    isProcessing: false,
    lines: [] as CostAssistantLine[],
    processedInvoices: [] as ProcessedInvoiceInfo[],
    drafts: [] as CostAnalysisDraft[],
    transportCost: 0,
    otherCosts: 0,
    columnVisibility: initialColumnVisibility as ColumnVisibility,
    exportStatus: 'idle' as ExportStatus,
    exportFileName: null as string | null,
};

export const useCostAssistant = () => {
    useAuthorization(['dashboard:access']); // Basic access permission
    const { setTitle } = usePageTitle();
    const { toast } = useToast();
    const { user } = useAuth();

    const [state, setState] = useState(initialState);

    useEffect(() => {
        setTitle("Asistente de Costos");
        const loadSettings = async () => {
            const settings = await getCostAssistantSettings();
            // Ensure all keys from initialVisibility are present
            const completeVisibility = { ...initialColumnVisibility, ...settings.columnVisibility };
            setState(prevState => ({ ...prevState, columnVisibility: completeVisibility }));
        };
        loadSettings();
    }, [setTitle]);

    const updateLine = (id: string, updatedFields: Partial<CostAssistantLine>) => {
        setState(prevState => ({
            ...prevState,
            lines: prevState.lines.map(line => 
                line.id === id ? { ...line, ...updatedFields } : line
            ),
        }));
    };
    
    const handleFilesDrop = useCallback(async (acceptedFiles: File[]) => {
        if (acceptedFiles.length === 0) return;
        
        setState(prevState => ({ ...prevState, isProcessing: true }));
        
        try {
            const fileContents = await Promise.all(
                acceptedFiles.map(file => 
                    new Promise<string>((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result as string);
                        reader.onerror = reject;
                        reader.readAsText(file);
                    })
                )
            );
            
            const { lines: processedLines, processedInvoices } = await processInvoiceXmls(fileContents);

            const newLines = processedLines.map((line) => ({
                ...line,
                displayMargin: "20",
                margin: 0.20,
                finalSellPrice: 0, // Will be calculated by useMemo
                profitPerLine: 0, // Will be calculated by useMemo
                sellPriceWithoutTax: 0,
            }));
            
            setState(prevState => ({ 
                ...prevState, 
                lines: [...prevState.lines, ...newLines],
                processedInvoices: [...prevState.processedInvoices, ...processedInvoices]
            }));
            const successCount = processedInvoices.filter(p => p.status === 'success').length;
            toast({ title: "Facturas Procesadas", description: `Se agregaron ${newLines.length} artículos de ${successCount} factura(s).` });

        } catch (error: any) {
            logError("Error processing invoice XMLs", { error: error.message });
            toast({ title: "Error al Procesar Archivos", description: error.message, variant: "destructive" });
        } finally {
            setState(prevState => ({ ...prevState, isProcessing: false }));
        }
    }, [toast]);
    
    const removeLine = (id: string) => {
        setState(prevState => ({
            ...prevState,
            lines: prevState.lines.filter(line => line.id !== id)
        }));
    };

    const handleMarginBlur = (lineId: string, displayValue: string) => {
        const numericValue = parseDecimal(displayValue);
        updateLine(lineId, {
            margin: numericValue / 100,
            displayMargin: String(numericValue)
        });
    };

    const formatCurrency = (amount: number) => {
        return `¢${amount.toLocaleString("es-CR", {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2,
        })}`;
    };

    const setColumnVisibility = (column: keyof ColumnVisibility, isVisible: boolean) => {
        setState(prevState => ({
            ...prevState,
            columnVisibility: {
                ...prevState.columnVisibility,
                [column]: isVisible,
            }
        }));
    };

    const handleSaveColumnVisibility = async () => {
        try {
            await saveCostAssistantSettings({ columnVisibility: state.columnVisibility });
            toast({ title: "Preferencia Guardada", description: "La visibilidad de las columnas ha sido guardada." });
        } catch (error: any) {
            logError("Failed to save column visibility", { error: error.message });
            toast({ title: "Error", description: "No se pudo guardar la configuración de las columnas.", variant: "destructive" });
        }
    };

    const handleClear = () => {
        setState(prevState => ({
            ...initialState, 
            columnVisibility: prevState.columnVisibility,
            drafts: prevState.drafts, // Keep drafts loaded
        }));
        toast({ title: "Operación Limpiada", description: "Se han borrado todos los datos para iniciar un nuevo análisis." });
    };

    const handleExportToERP = async () => {
        if (state.lines.length === 0) {
            toast({ title: 'No hay datos', description: 'No hay artículos para exportar.', variant: 'destructive' });
            return;
        }
        setState(prevState => ({ ...prevState, exportStatus: 'generating' }));
        try {
            const fileName = await exportForERP(state.lines);
            setState(prevState => ({ ...prevState, exportStatus: 'ready', exportFileName: fileName }));
            toast({ title: 'Exportación Lista', description: 'Tu archivo está listo para ser descargado.' });
        } catch (error: any) {
            logError("Failed to export for ERP", { error: error.message });
            setState(prevState => ({ ...prevState, exportStatus: 'idle' }));
            toast({ title: "Error de Exportación", description: error.message, variant: "destructive" });
        }
    };

     const handleFinalizeExport = async () => {
        if (!state.exportFileName) return;
        try {
            await cleanupExportFile(state.exportFileName);
            setState(prevState => ({ ...prevState, exportStatus: 'idle', exportFileName: null }));
            toast({ title: 'Exportación Finalizada', description: 'El archivo temporal ha sido eliminado del servidor.' });
        } catch (error: any) {
            logError("Failed to cleanup export file", { error: error.message });
            // Even if cleanup fails, reset UI state
            setState(prevState => ({ ...prevState, exportStatus: 'idle', exportFileName: null }));
            toast({ title: "Error de Limpieza", description: `No se pudo eliminar el archivo del servidor. ${error.message}`, variant: "destructive" });
        }
    };
    
    // --- Drafts ---
    const loadDrafts = async () => {
        if (!user) return;
        try {
            const draftsFromDb = await getAllDrafts(user.id);
            setState(prevState => ({ ...prevState, drafts: draftsFromDb }));
        } catch (error: any) {
            logError("Failed to load drafts", { error: error.message });
            toast({ title: "Error", description: "No se pudieron cargar los borradores.", variant: "destructive" });
        }
    };

    const saveDraftAction = async (draftName: string) => {
        if (!user || !draftName) return;

        const newDraft: Omit<CostAnalysisDraft, 'id' | 'createdAt'> = {
            userId: user.id,
            name: draftName,
            lines: state.lines,
            globalCosts: {
                transportCost: state.transportCost,
                otherCosts: state.otherCosts,
            },
            processedInvoices: state.processedInvoices
        };

        try {
            await saveDraft(newDraft);
            toast({ title: "Borrador Guardado", description: `El análisis "${draftName}" ha sido guardado.` });
        } catch (error: any) {
            logError("Failed to save draft", { error: error.message });
            toast({ title: "Error", description: "No se pudo guardar el borrador.", variant: "destructive" });
        }
    };
    
    const loadDraft = (draftToLoad: CostAnalysisDraft) => {
        setState(prevState => ({
            ...prevState,
            lines: draftToLoad.lines,
            transportCost: draftToLoad.globalCosts.transportCost,
            otherCosts: draftToLoad.globalCosts.otherCosts,
            processedInvoices: draftToLoad.processedInvoices
        }));
        toast({ title: "Borrador Cargado", description: `Se ha cargado el análisis "${draftToLoad.name}".` });
    };

    const deleteDraftAction = async (draftId: string) => {
        try {
            await deleteDraft(draftId);
            setState(prevState => ({
                ...prevState,
                drafts: prevState.drafts.filter(d => d.id !== draftId)
            }));
            toast({ title: "Borrador Eliminado", variant: "destructive" });
        } catch (error: any) {
            logError("Failed to delete draft", { error: error.message });
            toast({ title: "Error", description: "No se pudo eliminar el borrador.", variant: "destructive" });
        }
    };

    const linesWithCalculatedCosts = useMemo(() => {
        const totalItems = state.lines.reduce((sum, line) => sum + line.quantity, 0);
        const totalAdditionalCosts = state.transportCost + state.otherCosts;

        return state.lines.map(line => {
            const proportionalAdditionalCostPerUnit = totalItems > 0 && line.quantity > 0 ? (totalAdditionalCosts / totalItems) : 0;
            const finalUnitCost = line.unitCostWithoutTax + proportionalAdditionalCostPerUnit;
            const sellPriceWithoutTax = finalUnitCost / (1 - line.margin);
            const finalSellPrice = sellPriceWithoutTax * (1 + line.taxRate);
            const profitPerLine = (sellPriceWithoutTax - finalUnitCost) * line.quantity;

            return { ...line, finalSellPrice, sellPriceWithoutTax, profitPerLine, unitCostWithoutTax: finalUnitCost };
        });
    }, [state.lines, state.transportCost, state.otherCosts]);
    
    // This effect synchronizes the calculated costs back into the main state.
    useEffect(() => {
        // We compare to avoid an infinite loop. Only update if there's a difference in calculated values.
        if (JSON.stringify(state.lines) !== JSON.stringify(linesWithCalculatedCosts)) {
             setState(prevState => ({...prevState, lines: linesWithCalculatedCosts }));
        }
    }, [linesWithCalculatedCosts, state.lines]);

    const totals = useMemo(() => {
        const totalPurchaseCost = state.lines.reduce((sum, line) => sum + (line.unitCostWithTax * line.quantity), 0);
        const totalAdditionalCosts = state.transportCost + state.otherCosts;
        const totalFinalCost = state.lines.reduce((sum, line) => sum + (line.unitCostWithoutTax * line.quantity), 0);
        const totalSellValue = state.lines.reduce((sum, line) => sum + (line.finalSellPrice * line.quantity), 0);
        const estimatedGrossProfit = totalSellValue - totalFinalCost;

        return { totalPurchaseCost, totalAdditionalCosts, totalFinalCost, totalSellValue, estimatedGrossProfit };
    }, [state.lines, state.transportCost, state.otherCosts]);


    const actions = {
        handleFilesDrop,
        removeLine,
        updateLine,
        handleMarginBlur,
        formatCurrency,
        handleClear,
        setTransportCost: (cost: number) => setState(prevState => ({ ...prevState, transportCost: cost })),
        setOtherCosts: (cost: number) => setState(prevState => ({ ...prevState, otherCosts: cost })),
        setColumnVisibility,
        handleSaveColumnVisibility,
        handleExportToERP,
        loadDrafts,
        saveDraft: saveDraftAction,
        loadDraft,
        deleteDraft: deleteDraftAction,
        handleFinalizeExport,
    };

    return {
        state: { ...state, totals },
        actions,
    };
};
```

#### **Archivo 3: `src/modules/cost-assistant/lib/actions.ts` (El Puente Cliente-Servidor)**

```ts
/**
 * @fileoverview Client-side functions for the Cost Assistant module.
 */
'use server';

import { XMLParser } from 'fast-xml-parser';
import type { CostAssistantLine, ProcessedInvoiceInfo, CostAnalysisDraft } from '@/modules/core/types';
import { getCostAssistantSettings as getCostAssistantSettingsServer, saveCostAssistantSettings as saveCostAssistantSettingsServer, type CostAssistantSettings, getAllDrafts as getAllDraftsServer, saveDraft as saveDraftServer, deleteDraft as deleteDraftServer } from './db';
import { logError, logInfo } from '@/modules/core/lib/logger';
import * as XLSX from 'xlsx';
import path from 'path';
import fs from 'fs';

// Helper to get a value from a potentially nested object
const getValue = (obj: any, path: string[], defaultValue: any = '') => {
    return path.reduce((acc, key) => (acc && acc[key] !== undefined) ? acc[key] : defaultValue, obj);
};

const parseDecimal = (str: any): number => {
    if (str === null || str === undefined || str === '') return 0;
    const s = String(str).trim();
    
    // If a comma exists, it is the decimal separator. Remove dots, replace comma.
    if (s.includes(',')) {
        return parseFloat(s.replace(/\./g, '').replace(',', '.'));
    }
    
    // If no comma exists, treat as a standard float, respecting the dot as decimal separator
    return parseFloat(s);
};


interface InvoiceParseResult {
    lines: CostAssistantLine[];
    invoiceInfo: Omit<ProcessedInvoiceInfo, 'status' | 'errorMessage'>;
}

async function parseInvoice(xmlContent: string, fileIndex: number): Promise<InvoiceParseResult | { error: string, details: Partial<ProcessedInvoiceInfo> }> {
    
    if (xmlContent.includes('MensajeHacienda')) {
        return { error: 'El archivo es una respuesta de Hacienda, no una factura.', details: {} };
    }

    const parser = new XMLParser({
        ignoreAttributes: true,
        removeNSPrefix: true, 
        parseTagValue: false, 
        isArray: (tagName) => {
            const alwaysArray = ['LineaDetalle', 'CodigoComercial'];
            return alwaysArray.includes(tagName);
        },
    });

    let json;
    try {
        json = parser.parse(xmlContent);
    } catch (e: any) {
        logError('XML parsing failed', { error: e.message, content: xmlContent.substring(0, 500) });
        return { error: 'XML malformado o ilegible.', details: {} };
    }
    
    const rootNode = json.FacturaElectronica || json.TiqueteElectronico;
    
    if (!rootNode) {
        const detectedRoot = Object.keys(json)[0] || 'N/A';
        logError('Invalid XML structure for invoice', { detectedRoot });
        if (detectedRoot === 'html' || detectedRoot.startsWith('?xml')) {
            return { error: 'El archivo es un documento HTML o XML inválido, no una factura.', details: {} };
        }
        return { error: `No es un archivo de factura válido. Nodo raíz no encontrado: ${detectedRoot}`, details: {} };
    }
    
    const clave = getValue(rootNode, ['Clave'], `unknown-key-${fileIndex}`);
    const numeroConsecutivo = getValue(rootNode, ['NumeroConsecutivo'], clave.substring(21, 41));
    const fechaEmision = getValue(rootNode, ['FechaEmision'], new Date().toISOString());
    const emisorNombre = getValue(rootNode, ['Emisor', 'Nombre'], 'Desconocido');

    const invoiceInfo = {
        supplierName: emisorNombre,
        invoiceNumber: numeroConsecutivo,
        invoiceDate: fechaEmision,
    };

    const detalleServicio = getValue(rootNode, ['DetalleServicio']);
    if (!detalleServicio || !detalleServicio.LineaDetalle) {
        return { lines: [], invoiceInfo };
    }

    const lineasDetalle = Array.isArray(detalleServicio.LineaDetalle) ? detalleServicio.LineaDetalle : [detalleServicio.LineaDetalle];

    const moneda = getValue(rootNode, ['ResumenFactura', 'CodigoTipoMoneda', 'CodigoMoneda'], 'CRC');
    const tipoCambioStr = getValue(rootNode, ['ResumenFactura', 'CodigoTipoMoneda', 'TipoCambio'], '1');
    const tipoCambio = parseDecimal(tipoCambioStr) || 1.0;


    const lines: CostAssistantLine[] = [];
    for (const [index, linea] of lineasDetalle.entries()) {
        const cantidad = parseDecimal(getValue(linea, ['Cantidad'], '0'));
        if (cantidad === 0) continue;
        
        let supplierCode = 'N/A';
        let supplierCodeType = '04'; // Default to 'Uso Interno'
        const codigosComercialesRaw = linea.CodigoComercial || [];
        const codigosComerciales = Array.isArray(codigosComercialesRaw) ? codigosComercialesRaw : [codigosComercialesRaw];
        
        if (codigosComerciales.length > 0) {
            const preferredCodeNode = codigosComerciales.find((c: any) => c.Tipo === '01');
            if (preferredCodeNode && preferredCodeNode.Codigo) {
                supplierCode = preferredCodeNode.Codigo;
                supplierCodeType = preferredCodeNode.Tipo;
            } else if (codigosComerciales.length > 0 && codigosComerciales[0].Codigo) {
                supplierCode = codigosComerciales[0].Codigo;
                supplierCodeType = codigosComerciales[0].Tipo;
            }
        }
        
        const cabysV43 = getValue(linea, ['Codigo']);
        const cabysV44 = getValue(linea, ['CodigoCABYS']);
        const cabysCode = cabysV44 || cabysV43 || 'N/A';
        
        const montoTotalLinea = parseDecimal(getValue(linea, ['MontoTotalLinea'], '0'));
        
        const descuentoNode = getValue(linea, ['Descuento']);
        const descuentoTotal = descuentoNode ? parseDecimal(getValue(descuentoNode, ['MontoDescuento'], '0')) : 0;
        
        const subTotal = parseDecimal(getValue(linea, ['SubTotal'], '0'));
        
        const subTotalWithDiscount = subTotal - descuentoTotal;
        
        const unitCostWithTax = cantidad > 0 ? montoTotalLinea / cantidad : 0;
        const unitCostWithoutTax = cantidad > 0 ? subTotalWithDiscount / cantidad : 0;

        const impuestoNode = getValue(linea, ['Impuesto']);
        let taxRate = 0.13; // Default
        let taxCode = '08'; // Default
        if (impuestoNode) {
            taxRate = parseDecimal(getValue(impuestoNode, ['Tarifa'], '13')) / 100;
            taxCode = getValue(impuestoNode, ['CodigoTarifaIVA'], '08');
        }
        
        const unitCostWithTaxInColones = moneda === 'USD' ? unitCostWithTax * tipoCambio : unitCostWithTax;
        const unitCostWithoutTaxInColones = moneda === 'USD' ? unitCostWithoutTax * tipoCambio : unitCostWithoutTax;
        
        const numeroLinea = getValue(linea, ['NumeroLinea'], index + 1);

        lines.push({
            id: `${numeroConsecutivo}-${numeroLinea}-${supplierCode}-${index}`,
            invoiceKey: numeroConsecutivo,
            lineNumber: numeroLinea,
            cabysCode: cabysCode,
            supplierCode: supplierCode,
            supplierCodeType: supplierCodeType,
            description: getValue(linea, ['Detalle']),
            quantity: cantidad,
            unitCostWithTax: unitCostWithTaxInColones,
            unitCostWithoutTax: unitCostWithoutTaxInColones,
            taxRate: taxRate,
            taxCode: taxCode,
            displayMargin: "20",
            margin: 0.20,
            finalSellPrice: 0, // Calculated in the frontend
            profitPerLine: 0, // Calculated in the frontend
            sellPriceWithoutTax: 0, // Calculated in the frontend
            supplierName: emisorNombre,
        });
    }

    return { lines, invoiceInfo };
}

export async function processInvoiceXmls(xmlContents: string[]): Promise<{ lines: CostAssistantLine[], processedInvoices: ProcessedInvoiceInfo[] }> {
    let allLines: CostAssistantLine[] = [];
    const processedInvoices: ProcessedInvoiceInfo[] = [];

    for (const [index, xmlContent] of xmlContents.entries()) {
        try {
            const result = await parseInvoice(xmlContent, index);
            if (result && 'lines' in result) {
                allLines = [...allLines, ...result.lines];
                if (result.invoiceInfo.supplierName) { // Only add if it's a valid invoice
                    processedInvoices.push({
                        ...result.invoiceInfo,
                        status: 'success'
                    });
                }
            } else if (result && 'error' in result) {
                 processedInvoices.push({
                    supplierName: result.details.supplierName || 'Desconocido',
                    invoiceNumber: result.details.invoiceNumber || `Archivo ${index + 1}`,
                    invoiceDate: result.details.invoiceDate || new Date().toISOString(),
                    status: 'error',
                    errorMessage: result.error
                });
            }
        } catch (error: any) {
            console.error("Error parsing one of the XMLs:", error.message);
            processedInvoices.push({
                supplierName: 'Desconocido',
                invoiceNumber: `Archivo ${index + 1}`,
                invoiceDate: new Date().toISOString(),
                status: 'error',
                errorMessage: 'XML malformado o ilegible'
            });
        }
    }
    
    return JSON.parse(JSON.stringify({ lines: allLines, processedInvoices }));
}

export async function getCostAssistantSettings(): Promise<CostAssistantSettings> {
    const settings = await getCostAssistantSettingsServer();
    return JSON.parse(JSON.stringify(settings));
}

export async function saveCostAssistantSettings(settings: CostAssistantSettings): Promise<void> {
    return saveCostAssistantSettingsServer(settings);
}

export async function getAllDrafts(userId: string): Promise<CostAnalysisDraft[]> {
    const drafts = await getAllDraftsServer(userId);
    return JSON.parse(JSON.stringify(drafts));
}

export async function saveDraft(draft: Omit<CostAnalysisDraft, 'id' | 'createdAt'>): Promise<void> {
    await logInfo('Cost analysis draft saved', { name: draft.name, userId: draft.userId });
    await saveDraftServer(draft);
}

export async function deleteDraft(id: string): Promise<void> {
    await logInfo('Cost analysis draft deleted', { draftId: id });
    return deleteDraftServer(id);
}

export async function exportForERP(lines: CostAssistantLine[]): Promise<string> {
    // This function now generates an Excel file that matches the user's ERP template.
    
    const headerRow1 = [
        "CODIGOS (Requerido)", "NOMBRE (Requerido)", "UNIDAD DE MEDIDA (Requerido)", 
        "PRECIO (Sin impuestos) (Requerido)", "MONEDA", "ACTIVIDAD ECONOMICA", 
        "IMPUESTOS (Opcional)", "CÓDIGO CABYS", "ESTADO"
    ];
    const headerRow2 = [
        "04", null, null, null, null, null, "IMP.01"
    ];
    
    // Create the AoA (Array of Arrays) for the worksheet
    const ws_data: (string|number|null)[][] = [headerRow1, headerRow2];
    
    // Map data to the correct structure for the ERP template
    lines.forEach(line => {
        const row: (string | number | null)[] = new Array(headerRow1.length).fill(null);

        row[0] = line.supplierCode; // CODIGOS 04
        row[1] = line.description; // NOMBRE
        row[2] = '78-Unid-Unidad'; // UNIDAD DE MEDIDA
        row[3] = Number(line.sellPriceWithoutTax.toFixed(5)); // PRECIO
        row[4] = 'CRC'; // MONEDA
        row[5] = '4651.0'; // ACTIVIDAD ECONOMICA
        row[6] = line.taxCode; // IMP.01
        row[7] = line.cabysCode; // CÓDIGO CABYS
        row[8] = 'A'; // ESTADO
        
        ws_data.push(row);
    });

    const worksheet = XLSX.utils.aoa_to_sheet(ws_data);
    
    // Define column widths for better readability
    worksheet['!cols'] = [
        { wch: 15 }, // CODIGOS 04
        { wch: 60 }, // NOMBRE
        { wch: 20 }, // UNIDAD DE MEDIDA
        { wch: 20 }, // PRECIO
        { wch: 10 }, // MONEDA
        { wch: 20 }, // ACTIVIDAD ECONOMICA
        { wch: 10 }, // IMP.01
        { wch: 20 }, // CÓDIGO CABYS
        { wch: 10 }, // ESTADO
    ];

    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Articulos');
    
    const exportDir = path.join(process.cwd(), 'temp_files', 'exports');
    if (!fs.existsSync(exportDir)) {
        fs.mkdirSync(exportDir, { recursive: true });
    }
    
    const fileName = `export_erp_${Date.now()}.xlsx`;
    const filePath = path.join(exportDir, fileName);

    try {
        const buffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'buffer' });
        fs.writeFileSync(filePath, buffer);
    } catch (error: any) {
        logError("Failed to save Excel file to disk", { error: error.message, path: filePath });
        throw new Error(`No se pudo guardar el archivo en la ruta del servidor: ${filePath}`);
    }
    
    return fileName;
}


export async function cleanupExportFile(fileName: string): Promise<void> {
    if (!fileName) {
        throw new Error("Filename is required");
    }
    const exportDir = path.join(process.cwd(), 'temp_files', 'exports');
    const filePath = path.join(exportDir, fileName);

    if (fs.existsSync(filePath)) {
        try {
            fs.unlinkSync(filePath);
        } catch (error: any) {
            logError("Failed to delete temporary export file", { error: error.message, file: fileName });
            throw new Error("Error del servidor al limpiar el archivo temporal.");
        }
    }
}
```

#### **Archivo 4: `src/modules/cost-assistant/lib/db.ts` (La Lógica de Base de Datos)**

```ts
/**
 * @fileoverview Server-side functions for the cost assistant database, now using Firestore.
 */
"use server";

import { adminDb } from '../../core/lib/firebase/firebase-admin';
import type { CostAnalysisDraft } from '@/modules/core/types';

const firestore = adminDb;
const settingsCollection = firestore ? firestore.collection('settings') : null;
const draftsCollection = firestore ? firestore.collection('cost_analysis_drafts') : null;

export type CostAssistantSettings = {
    columnVisibility: {
        cabysCode: boolean;
        supplierCode: boolean;
        description: boolean;
        quantity: boolean;
        unitCostWithoutTax: boolean;
        unitCostWithTax: boolean;
        taxRate: boolean;
        margin: boolean;
        sellPriceWithoutTax: boolean;
        finalSellPrice: boolean;
        profitPerLine: boolean;
    }
};

const defaultSettings: CostAssistantSettings = {
    columnVisibility: {
        cabysCode: true, supplierCode: true, description: true, quantity: true,
        unitCostWithoutTax: true, unitCostWithTax: false, taxRate: true,
        margin: true, sellPriceWithoutTax: true, finalSellPrice: true, profitPerLine: true
    }
};

export async function getCostAssistantSettings(): Promise<CostAssistantSettings> {
    if (!settingsCollection) return defaultSettings;
    const docRef = settingsCollection.doc('cost_assistant');
    const docSnap = await docRef.get();

    if (docSnap.exists) {
        return docSnap.data() as CostAssistantSettings;
    } else {
        await docRef.set(defaultSettings);
        return defaultSettings;
    }
}

export async function saveCostAssistantSettings(settings: CostAssistantSettings): Promise<void> {
    if (!settingsCollection) return;
    await settingsCollection.doc('cost_assistant').set(settings);
}

export async function getAllDrafts(userId: string): Promise<CostAnalysisDraft[]> {
    if (!draftsCollection) return [];
    const snapshot = await draftsCollection.where('userId', '==', userId).orderBy('createdAt', 'desc').get();
    return snapshot.docs.map(doc => doc.data() as CostAnalysisDraft);
}

export async function saveDraft(draft: Omit<CostAnalysisDraft, 'id' | 'createdAt'>): Promise<CostAnalysisDraft> {
    if (!draftsCollection) throw new Error("Firestore not initialized for drafts.");
    const docRef = draftsCollection.doc();
    const newDraft: CostAnalysisDraft = {
        ...draft,
        id: docRef.id,
        createdAt: new Date().toISOString(),
    };
    await docRef.set(newDraft);
    return newDraft;
}

export async function deleteDraft(id: string): Promise<void> {
    if (!draftsCollection) return;
    await draftsCollection.doc(id).delete();
}
```
