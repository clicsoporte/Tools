
// BACKUP DE PERMISOS - NO MODIFICAR MANUALMENTE

// --- FILE: src/modules/core/hooks/useAuthorization.tsx ---

/**
 * @fileoverview Custom hook to handle authorization for specific pages or components.
 * It checks if the current user's role includes at least one of the required permissions.
 * If not, it denies access and can optionally redirect the user.
 */
'use client';

import { useEffect, useMemo, useCallback } from 'react';
import { useRouter } from 'next/navigation';
import { useAuth } from '@/modules/core/hooks/useAuth';
import { logInfo } from '../lib/logger';

type UseAuthorizationReturn = {
  isAuthorized: boolean | null;
  hasPermission: (permission: string) => boolean;
  userPermissions: string[];
};

export function useAuthorization(requiredPermissions: string[] = []): UseAuthorizationReturn {
    const router = useRouter();
    const { user, userRole, isAuthReady } = useAuth(); // Use isAuthReady from the central auth context

    const userPermissions = useMemo(() => userRole?.permissions || [], [userRole]);

    const hasPermission = useCallback((permission: string): boolean => {
        if (!isAuthReady || !userRole) return false;
        if (userRole.id === 'admin') return true; // Admins have all permissions
        // Check for wildcard access (e.g., 'requests:read' implies 'requests:read:all')
        const permissionBase = permission.split(':')[0];
        const hasBaseAccess = userPermissions.includes(`${permissionBase}:access`);
        if (hasBaseAccess) return true;
        
        return userPermissions.includes(permission);
    }, [isAuthReady, userRole, userPermissions]);

    const isAuthorized = useMemo(() => {
        if (!isAuthReady) return null; // Wait until all auth data is ready before making a decision.
        if (!user || !userRole) return false; // No user or role, not authorized.
        
        // If no specific permissions are required, being logged in and ready is enough.
        if (requiredPermissions.length === 0) return true;
        
        // Use the memoized hasPermission function for checking.
        return requiredPermissions.some(p => hasPermission(p));
    }, [isAuthReady, user, userRole, requiredPermissions, hasPermission]);

    useEffect(() => {
        // This effect is now simplified. The main redirect logic is in DashboardLayout.
        // It's kept in case specific pages need to react to authorization changes in the future,
        // but it no longer handles the primary redirection responsibility.
        if (isAuthReady && isAuthorized && user) {
            // This is a good place to log module access if needed.
        }
    }, [isAuthorized, isAuthReady, user]);

    return { isAuthorized, hasPermission, userPermissions };
}


// --- FILE: src/modules/core/lib/auth.ts ---

/**
 * @fileoverview Server-side authentication and user management functions.
 * These functions interact directly with the database to handle user data.
 * This file implements secure password handling using bcryptjs.
 * All functions in this file are server-only.
 */
"use server";

import { connectDb, getAllRoles, getCompanySettings, getAllCustomers, getAllProducts, getAllStock, getAllExemptions, getExemptionLaws, getUnreadSuggestions, getDbModules, getStockSettings } from './db';
import { sendEmail, getEmailSettings as getEmailSettingsFromDb } from './email-service';
import type { User, ExchangeRateApiResponse, EmailSettings, Role } from '@/modules/core/types';
import bcrypt from 'bcryptjs';
import { logInfo, logWarn, logError } from './logger';
import { headers, cookies } from 'next/headers';
import { getExchangeRate, getEmailSettings } from './api-actions';
import { NewUserSchema, UserSchema } from './auth-schemas';
import { confirmModification as confirmPlannerModificationServer } from '../../planner/lib/db';
import { initializePlannerDb, runPlannerMigrations } from '../../planner/lib/db';
import { initializeRequestsDb, runRequestMigrations } from '../../requests/lib/db';
import { initializeWarehouseDb, runWarehouseMigrations, getLocations as getWarehouseLocationsDb, getInventory as getWarehouseInventoryDb, getAllItemLocations as getAllItemLocationsDb } from '../../warehouse/lib/db';
import { initializeCostAssistantDb, runCostAssistantMigrations } from '../../cost-assistant/lib/db';
import { getWarehouseData } from '../../warehouse/lib/db';
import { revalidatePath } from 'next/cache';

const SALT_ROUNDS = 10;
const SESSION_COOKIE_NAME = 'clic-tools-session';
const SESSION_DURATION = 8 * 60 * 60 * 1000; // 8 hours in milliseconds

/**
 * Checks if a user has a specific permission.
 * Admins are always granted permission.
 * @param userId - The ID of the user to check.
 * @param permission - The permission string to validate.
 * @returns A promise that resolves to true if the user has permission, false otherwise.
 */
export async function hasPermission(userId: number, permission: string): Promise<boolean> {
    const db = await connectDb();
    const userRoleInfo = db.prepare('SELECT role FROM users WHERE id = ?').get(userId) as { role: string } | undefined;

    if (!userRoleInfo) return false;
    if (userRoleInfo.role === 'admin') return true; // Admins have all permissions

    const role = db.prepare('SELECT permissions FROM roles WHERE id = ?').get(userRoleInfo.role) as { permissions: string } | undefined;
    if (!role) return false;

    const permissions: string[] = JSON.parse(role.permissions);
    return permissions.includes(permission);
}


/**
 * Attempts to log in a user with the given credentials.
 * It securely compares the provided password with the stored hash.
 * @param {string} email - The user's email.
 * @param {string} passwordProvided - The password provided by the user.
 * @returns {Promise<{ user: User | null, forcePasswordChange: boolean }>} The user object and a flag indicating if a password change is required.
 */
export async function login(email: string, passwordProvided: string, clientInfo: { ip: string; host: string; }): Promise<{ user: User | null, forcePasswordChange: boolean }> {
  const db = await connectDb();
  const logMeta = { email, ...clientInfo };
  try {
    const stmt = db.prepare('SELECT * FROM users WHERE email = ?');
    const user: User | undefined = stmt.get(email) as User | undefined;

    if (user && user.password) {
      const isMatch = await bcrypt.compare(passwordProvided, user.password);
      if (isMatch) {
        // Correctly exclude the password from the returned object.
        const { password: _, ...userWithoutPassword } = user;
        
        // Use an environment variable to control the 'secure' flag. Default to false for LAN.
        const useSecureCookie = process.env.CLIC_TOOLS_COOKIE_SECURE === 'true';

        // Create session cookie
        cookies().set(SESSION_COOKIE_NAME, String(user.id), {
            httpOnly: true,
            secure: useSecureCookie,
            maxAge: SESSION_DURATION / 1000, // seconds
            path: '/',
        });

        await logInfo(`User '${user.name}' logged in successfully.`, logMeta);
        return { user: userWithoutPassword as User, forcePasswordChange: !!user.forcePasswordChange };
      }
    }
    await logWarn(`Failed login attempt for email: ${email}`, logMeta);
    return { user: null, forcePasswordChange: false };
  } catch (error: any) {
    console.error("Login error:", error);
    await logError(`Login process failed for email: ${email}`, { error: error.message, ...logMeta});
    return { user: null, forcePasswordChange: false };
  }
}


export async function logout(): Promise<void> {
    const cookieStore = cookies();
    const sessionCookie = cookieStore.get(SESSION_COOKIE_NAME);
    
    if (sessionCookie && sessionCookie.value) {
        const userId = Number(sessionCookie.value);
        const db = await connectDb();
        const user = db.prepare('SELECT name FROM users WHERE id = ?').get(userId) as { name: string } | undefined;
        if (user) {
            await logInfo(`User '${user.name}' logged out.`, { userId });
        }
    }
    
    const useSecureCookie = process.env.CLIC_TOOLS_COOKIE_SECURE === 'true';
    
    // Invalidate the cookie
    cookieStore.set(SESSION_COOKIE_NAME, '', {
        httpOnly: true,
        secure: useSecureCookie,
        maxAge: 0,
        path: '/',
    });
}

/**
 * Retrieves all users from the database, intended for server-side use where passwords might be needed.
 * This is an internal function and should not be confused with the client-safe `getAllUsers`.
 * @returns {Promise<User[]>} A promise that resolves to an array of all users, including password hashes.
 */
async function getAllUsersWithPasswords(): Promise<User[]> {
    const db = await connectDb();
    try {
        const stmt = db.prepare('SELECT * FROM users ORDER BY name');
        return stmt.all() as User[];
    } catch (error) {
        console.error("Failed to get all users:", error);
        return [];
    }
}

/**
 * Retrieves all users from the database for client-side consumption.
 * Passwords are removed before sending the data.
 * @returns {Promise<User[]>} A promise that resolves to an array of all users without passwords.
 */
export async function getAllUsers(): Promise<User[]> {
    const users = await getAllUsersWithPasswords();
    return users.map(u => {
        const { password: _, ...userWithoutPassword } = u;
        return userWithoutPassword;
    }) as User[];
}

/**
 * Retrieves all users from the database for reporting purposes.
 * Passwords are removed.
 * @returns {Promise<User[]>} A promise that resolves to an array of all users without passwords.
 */
export async function getAllUsersForReport(): Promise<User[]> {
    const db = await connectDb();
    try {
        const stmt = db.prepare('SELECT * FROM users ORDER BY name');
        const users = stmt.all() as User[];
        // Ensure passwords are never sent to the client.
        return users.map(u => {
            const { password: _, ...userWithoutPassword } = u;
            return userWithoutPassword;
        }) as User[];
    } catch (error: any) {
        await logError("getAllUsersForReport", { error: error.message });
        return [];
    }
}

/**
 * Adds a new user to the database.
 * @param userData - The data for the new user, including a plaintext password.
 * @returns The newly created user object, without the password hash.
 */
export async function addUser(userData: Omit<User, 'id' | 'avatar' | 'recentActivity' | 'securityQuestion' | 'securityAnswer'> & { password: string, forcePasswordChange: boolean }): Promise<User> {
  const db = await connectDb();

  // Validate data against the schema first
  const validationResult = NewUserSchema.safeParse(userData);
  if (!validationResult.success) {
      throw new Error(`Validation failed: ${validationResult.error.errors.map(e => e.message).join(', ')}`);
  }
  
  const hashedPassword = bcrypt.hashSync(validationResult.data.password, SALT_ROUNDS);

  const highestIdResult = db.prepare('SELECT MAX(id) as maxId FROM users').get() as { maxId: number | null };
  const nextId = (highestIdResult.maxId || 0) + 1;

  const userToCreate: User = {
    id: nextId,
    name: validationResult.data.name,
    email: validationResult.data.email,
    password: hashedPassword,
    role: validationResult.data.role,
    avatar: "",
    recentActivity: "Usuario recién creado.",
    phone: validationResult.data.phone || "",
    whatsapp: validationResult.data.whatsapp || "",
    erpAlias: validationResult.data.erpAlias || "",
    forcePasswordChange: validationResult.data.forcePasswordChange,
  };
  
  const stmt = db.prepare(
    `INSERT INTO users (id, name, email, password, phone, whatsapp, erpAlias, avatar, role, recentActivity, securityQuestion, securityAnswer, forcePasswordChange) 
     VALUES (@id, @name, @email, @password, @phone, @whatsapp, @erpAlias, @avatar, @role, @recentActivity, @securityQuestion, @securityAnswer, @forcePasswordChange)`
  );
  
  stmt.run({
    ...userToCreate,
    phone: userToCreate.phone || null,
    whatsapp: userToCreate.whatsapp || null,
    erpAlias: userToCreate.erpAlias || null,
    securityQuestion: userToCreate.securityQuestion || null,
    securityAnswer: userToCreate.securityAnswer || null,
    forcePasswordChange: userToCreate.forcePasswordChange ? 1 : 0,
  });

  const { password: _, ...userWithoutPassword } = userToCreate;
  await logInfo(`Admin added a new user: ${userToCreate.name}`, { role: userToCreate.role });
  return userWithoutPassword as User;
}

/**
 * Saves the entire list of users to the database.
 * This is an "all-or-nothing" operation that replaces all existing users.
 * It handles password hashing for new or changed passwords.
 * @param {User[]} users - The full array of users to save.
 * @returns {Promise<void>}
 */
export async function saveAllUsers(users: User[]): Promise<void> {
   const db = await connectDb();
   const upsert = db.prepare(`
    INSERT INTO users (id, name, email, password, phone, whatsapp, erpAlias, avatar, role, recentActivity, securityQuestion, securityAnswer, forcePasswordChange) 
    VALUES (@id, @name, @email, @password, @phone, @whatsapp, @erpAlias, @avatar, @role, @recentActivity, @securityQuestion, @securityAnswer, @forcePasswordChange)
    ON CONFLICT(id) DO UPDATE SET
        name = excluded.name,
        email = excluded.email,
        password = excluded.password,
        phone = excluded.phone,
        whatsapp = excluded.whatsapp,
        erpAlias = excluded.erpAlias,
        avatar = excluded.avatar,
        role = excluded.role,
        recentActivity = excluded.recentActivity,
        securityQuestion = excluded.securityQuestion,
        securityAnswer = excluded.securityAnswer,
        forcePasswordChange = excluded.forcePasswordChange
   `);

    const transaction = db.transaction((usersToSave: User[]) => {
        const existingUsersMap = new Map<number, { pass: string | undefined; force: boolean | number | undefined }>(
            (db.prepare('SELECT id, password, forcePasswordChange FROM users').all() as User[]).map(u => [u.id, { pass: u.password, force: u.forcePasswordChange }])
        );

        for (const user of usersToSave) {
          // Validate each user object before processing
          const validationResult = UserSchema.safeParse(user);
          if (!validationResult.success) {
              logError(`Skipping user save due to validation error for user ID ${user.id}`, { errors: validationResult.error.flatten() });
              continue; // Skip this invalid user and continue with the next
          }

          const validatedUser = validationResult.data;
          let passwordToSave = validatedUser.password;
          const existingUserData = existingUsersMap.get(validatedUser.id);
          
          if (passwordToSave && passwordToSave !== existingUserData?.pass) {
              if (!passwordToSave.startsWith('$2a$')) { // Basic check if it's not already a hash
                  passwordToSave = bcrypt.hashSync(passwordToSave, SALT_ROUNDS);
              }
          } else {
             passwordToSave = existingUserData?.pass;
          }

          const userToInsert = {
            ...validatedUser,
            password: passwordToSave,
            phone: validatedUser.phone || null,
            whatsapp: validatedUser.whatsapp || null,
            erpAlias: validatedUser.erpAlias || null,
            securityQuestion: validatedUser.securityQuestion || null,
            securityAnswer: validatedUser.securityAnswer || null,
            forcePasswordChange: validatedUser.forcePasswordChange ? 1 : 0,
          };
          upsert.run(userToInsert);
        }
    });

    try {
        transaction(users);
        await logInfo(`${users.length} user records were processed for saving.`);
    } catch (error) {
        await logError("Failed to save all users (saveAllUsers)", { error: (error as Error).message });
        throw new Error("Database transaction failed to save users.");
    }
}

/**
 * Securely compares a plaintext password with a user's stored bcrypt hash.
 * @param {number} userId - The ID of the user whose password should be checked.
 * @param {string} password - The plaintext password to check.
 * @param {object} [clientInfo] - Optional client IP and host for logging.
 * @returns {Promise<boolean>} True if the password matches the hash.
 */
export async function comparePasswords(userId: number, password: string, clientInfo?: { ip: string, host: string }): Promise<boolean> {
    const db = await connectDb();
    const user = db.prepare('SELECT password FROM users WHERE id = ?').get(userId) as User | undefined;

    if (!user || !user.password) {
        return false;
    }
    
    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      await logWarn('Password comparison failed during settings update/recovery.', clientInfo);
    }
    return isMatch;
}

/**
 * Retrieves the currently authenticated user based on the session cookie.
 * This is a server-only function.
 * It's marked as dynamic to prevent caching issues when the user logs in/out.
 * @returns {Promise<User | null>} The user object or null if not authenticated.
 */
export async function getCurrentUser(): Promise<User | null> {
    // This line tells Next.js that this function's output depends on cookies
    // and should not be cached across requests. This solves the stale session problem.
    cookies();

    const cookieStore = cookies();
    const sessionCookie = cookieStore.get(SESSION_COOKIE_NAME);

    if (!sessionCookie || !sessionCookie.value) {
        return null;
    }

    const userId = Number(sessionCookie.value);
    if (isNaN(userId)) {
        return null;
    }

    const db = await connectDb();
    const user = db.prepare('SELECT * FROM users WHERE id = ?').get(userId) as User | undefined;

    if (!user) {
        return null;
    }

    const { password: _, ...userWithoutPassword } = user;
    return userWithoutPassword as User;
}

/**
 * Fetches all the initial data required for the application's authentication context.
 * This is a server action that aggregates data from various database functions.
 */
export async function getInitialAuthData() {
    const db = await connectDb();
    // Ensure all databases are initialized on first authenticated load
    const dbModules = await getDbModules();
    for (const dbModule of dbModules) {
        await connectDb(dbModule.dbFile);
    }
    
    const [
        roles,
        companySettings,
        customers,
        products,
        stock,
        exemptions,
        exemptionLaws,
        exchangeRate,
        unreadSuggestions,
        warehouseData
    ] = await Promise.all([
        getAllRoles(),
        getCompanySettings(),
        getAllCustomers(),
        getAllProducts(),
        getAllStock(),
        getAllExemptions(),
        getExemptionLaws(),
        getExchangeRate(),
        getUnreadSuggestions(),
        getWarehouseData()
    ]);
    
    let rateData: { rate: number | null; date: string | null } = { rate: null, date: null };
    const exchangeRateResponse = exchangeRate as ExchangeRateApiResponse;
    if (exchangeRateResponse?.venta?.valor) {
        rateData.rate = exchangeRateResponse.venta.valor;
        rateData.date = new Date(exchangeRateResponse.venta.fecha).toLocaleDateString('es-CR', { day: '2-digit', month: '2-digit', year: '2-digit' });
    }

    return {
        roles,
        companySettings,
        customers,
        products,
        stock,
        exemptions,
        exemptionLaws,
        exchangeRate: rateData,
        unreadSuggestions,
        allLocations: warehouseData.locations,
        allInventory: warehouseData.inventory,
        allItemLocations: warehouseData.itemLocations,
        stockSettings: warehouseData.stockSettings,
    };
}


/**
 * Handles the password recovery process.
 * Generates a temporary password, updates the user's record, and sends an email.
 * @param email - The email of the user requesting recovery.
 * @param clientInfo - Information about the client making the request.
 */
export async function sendPasswordRecoveryEmail(email: string, clientInfo: { ip: string; host: string; }): Promise<void> {
    const db = await connectDb();
    const logMeta = { email, ...clientInfo };

    const user = db.prepare('SELECT * FROM users WHERE email = ?').get(email) as User | undefined;
    if (!user) {
        await logWarn('Password recovery requested for non-existent email.', logMeta);
        // We don't throw an error to prevent email enumeration attacks. The UI will show a generic message.
        return;
    }

    const tempPassword = Math.random().toString(36).slice(-8);
    const hashedPassword = await bcrypt.hash(tempPassword, SALT_ROUNDS);

    db.prepare('UPDATE users SET password = ?, forcePasswordChange = 1 WHERE id = ?')
      .run(hashedPassword, user.id);

    try {
        const emailSettings = await getEmailSettingsFromDb();
        if (!emailSettings.smtpHost) {
            throw new Error("La configuración de SMTP no está establecida. No se puede enviar el correo.");
        }
        
        const emailBody = (emailSettings.recoveryEmailBody || '')
            .replace('[NOMBRE_USUARIO]', user.name)
            .replace('[CLAVE_TEMPORAL]', tempPassword);
            
        await sendEmail({
            to: user.email,
            subject: emailSettings.recoveryEmailSubject || 'Recuperación de Contraseña',
            html: emailBody
        });

        await logInfo(`Password recovery email sent successfully to ${user.name}.`, logMeta);
    } catch (error: any) {
        await logError('Failed to send password recovery email.', { ...logMeta, error: error.message });
        throw new Error("No se pudo enviar el correo de recuperación. Revisa la configuración de SMTP.");
    }
}

// --- FILE: src/modules/core/lib/permissions.ts ---

/**
 * @fileoverview This file centralizes all permission-related constants and logic.
 * Separating this from data.ts breaks a problematic dependency cycle.
 */

export const allAdminPermissions = [
    "admin:access",
    "dashboard:access", "quotes:create", "quotes:generate", "quotes:drafts:create", "quotes:drafts:read", "quotes:drafts:delete",
    "requests:read", "requests:read:all", "requests:create", "requests:create:duplicate", "requests:edit:pending", "requests:edit:approved", "requests:reopen", "requests:notes:add",
    "requests:view:sale-price", "requests:view:cost", "requests:view:margin",
    "requests:status:review", "requests:status:pending-approval", "requests:status:approve", "requests:status:ordered", "requests:status:received-in-warehouse", "requests:status:entered-erp", "requests:status:cancel", "requests:status:unapproval-request", "requests:status:unapproval-request:approve", "requests:status:revert-to-approved",
    "planner:read", "planner:read:all", "planner:create", "planner:edit:pending", "planner:edit:approved", "planner:reopen", "planner:receive", "planner:status:review", "planner:status:approve", "planner:status:in-progress", "planner:status:on-hold", 
    "planner:status:completed", "planner:status:cancel", "planner:status:cancel-approved", "planner:status:unapprove-request", "planner:status:unapprove-request:approve",
    "planner:priority:update", "planner:machine:assign", "planner:schedule",
    "cost-assistant:access", "cost-assistant:drafts:read-write",
    "warehouse:access", "warehouse:search:full", "warehouse:search:simple", 
    "warehouse:receiving-wizard:use", "warehouse:population-wizard:use", "warehouse:inventory-count:create",
    "warehouse:item-assignment:create", "warehouse:item-assignment:delete",
    "warehouse:locations:create", "warehouse:locations:update", "warehouse:locations:delete",
    "warehouse:units:create", "warehouse:units:delete", "warehouse:locks:manage",
    "warehouse:correction:execute", "warehouse:correction:apply", "warehouse:labels:generate",
    "hacienda:query",
    "operations:access", "operations:create", "operations:read:all", "operations:approve", "operations:sign",
    "it-tools:access", "it-tools:notes:read", "it-tools:notes:create", "it-tools:notes:update", "it-tools:notes:delete",
    "analytics:read", "analytics:purchase-suggestions:read", "analytics:purchase-report:read", "analytics:production-report:read", "analytics:transits-report:read", "analytics:user-permissions:read", "analytics:physical-inventory-report:read", "analytics:receiving-report:read", "analytics:item-assignments-report:read", "analytics:occupancy-report:read",
    "users:create", "users:read", "users:update", "users:delete",
    "roles:create", "roles:read", "roles:update", "roles:delete", "admin:settings:general", "admin:settings:api", "admin:settings:planner", "admin:settings:requests", "admin:settings:warehouse", "admin:settings:stock", "admin:settings:cost-assistant", "admin:settings:analytics",
    "admin:suggestions:read",
    "admin:import:run", "admin:import:files", "admin:import:sql", "admin:import:sql-config",
    "admin:logs:read", "admin:logs:clear",
    "admin:maintenance:backup", "admin:maintenance:restore", "admin:maintenance:reset"
];

export const permissionGroups = {
    "Acceso General": ["dashboard:access"],
    "Cotizador": ["quotes:create", "quotes:generate", "quotes:drafts:create", "quotes:drafts:read", "quotes:drafts:delete"],
    "Solicitud de Compra (Lectura y Creación)": ["requests:read", "requests:read:all", "requests:create", "requests:create:duplicate", "requests:notes:add"],
    "Solicitud de Compra (Edición y Flujo)": ["requests:edit:pending", "requests:edit:approved", "requests:status:review", "requests:status:pending-approval"],
    "Solicitud de Compra (Acciones de Aprobador)": ["requests:reopen", "requests:status:approve", "requests:status:ordered", "requests:status:received-in-warehouse", "requests:status:entered-erp", "requests:status:cancel", "requests:status:revert-to-approved", "requests:status:unapproval-request", "requests:status:unapproval-request:approve"],
    "Solicitud de Compra (Finanzas)": ["requests:view:sale-price", "requests:view:cost", "requests:view:margin"],
    "Planificador de Producción (Lectura y Creación)": ["planner:read", "planner:read:all", "planner:create"],
    "Planificador de Producción (Edición y Acciones)": ["planner:edit:pending", "planner:edit:approved", "planner:reopen", "planner:receive", "planner:status:review", "planner:status:approve", "planner:status:in-progress", "planner:status:on-hold", 
    "planner:status:completed", "planner:status:cancel", "planner:status:cancel-approved", "planner:status:unapprove-request", "planner:status:unapprove-request:approve", "planner:priority:update", "planner:machine:assign", "planner:schedule"],
    "Asistente de Costos": ["cost-assistant:access", "cost-assistant:drafts:read-write"],
    "Centro de Operaciones y Trazabilidad (Nuevo)": ["operations:access", "operations:create", "operations:read:all", "operations:approve", "operations:sign"],
    "Herramientas de TI (Nuevo)": ["it-tools:access", "it-tools:notes:read", "it-tools:notes:create", "it-tools:notes:update", "it-tools:notes:delete"],
    "Gestión de Almacenes": [
        "warehouse:access", "warehouse:search:full", "warehouse:search:simple",
        "warehouse:receiving-wizard:use", "warehouse:population-wizard:use", "warehouse:inventory-count:create",
        "warehouse:item-assignment:create", "warehouse:item-assignment:delete",
        "warehouse:locations:create", "warehouse:locations:update", "warehouse:locations:delete",
        "warehouse:units:create", "warehouse:units:delete", "warehouse:locks:manage",
        "warehouse:correction:execute", "warehouse:correction:apply", "warehouse:labels:generate"
    ],
    "Consultas Hacienda": ["hacienda:query"],
    "Analíticas y Reportes": ["analytics:read", "analytics:purchase-suggestions:read", "analytics:purchase-report:read", "analytics:production-report:read", "analytics:transits-report:read", "analytics:user-permissions:read", "analytics:physical-inventory-report:read", "analytics:receiving-report:read", "analytics:item-assignments-report:read", "analytics:occupancy-report:read"],
    "Gestión de Usuarios": ["users:create", "users:read", "users:update", "users:delete"],
    "Gestión de Roles": ["roles:create", "roles:read", "roles:update", "roles:delete"],
    "Administración del Sistema": [
        "admin:access",
        "admin:settings:general", "admin:settings:api", "admin:settings:planner", "admin:settings:requests", "admin:settings:warehouse", "admin:settings:stock", "admin:settings:cost-assistant", "admin:settings:analytics",
        "admin:suggestions:read",
        "admin:import:run", "admin:import:files", "admin:import:sql", "admin:import:sql-config",
        "admin:logs:read", "admin:logs:clear",
        "admin:maintenance:backup", "admin:maintenance:restore", "admin:maintenance:reset"
    ],
};

export const analyticsPermissions = permissionGroups["Analíticas y Reportes"];

export const permissionTranslations: { [key: string]: string } = {
    "admin:access": "Acceso a Configuración",
    "dashboard:access": "Acceso al Panel", "quotes:create": "Cotizador: Crear", "quotes:generate": "Cotizador: Generar PDF", "quotes:drafts:create": "Borradores: Crear", "quotes:drafts:read": "Borradores: Cargar", "quotes:drafts:delete": "Borradores: Eliminar",
    "requests:read": "Compras: Leer", "requests:read:all": "Compras: Leer Todo", "requests:create": "Compras: Crear", "requests:create:duplicate": "Compras: Crear Duplicados", "requests:notes:add": "Compras: Añadir Notas",
    "requests:edit:pending": "Compras: Editar (Pendientes)", "requests:edit:approved": "Compras: Editar (Aprobadas)", "requests:status:review": "Compras: Enviar a Revisión", "requests:status:pending-approval": "Compras: Enviar a Aprobación", "requests:reopen": "Compras: Reabrir", "requests:status:approve": "Compras: Aprobar", "requests:status:ordered": "Compras: Marcar como Ordenada", "requests:status:received-in-warehouse": "Compras: Recibir en Bodega", "requests:status:entered-erp": "Compras: Ingresar a ERP", "requests:status:cancel": "Compras: Cancelar", "requests:status:revert-to-approved": "Compras: Revertir a Aprobada", "requests:status:unapproval-request": "Compras: Solicitar Desaprobación", "requests:status:unapproval-request:approve": "Compras: Aprobar Desaprobación",
    "requests:view:sale-price": "Compras: Ver Precio Venta", "requests:view:cost": "Compras: Ver Costo", "requests:view:margin": "Compras: Ver Margen",
    "planner:read": "Plan.: Leer Órdenes", "planner:read:all": "Plan.: Leer Todas las Órdenes", "planner:create": "Plan.: Crear Órdenes",
    "planner:edit:pending": "Plan.: Editar (Pendientes)", "planner:edit:approved": "Plan.: Editar (Aprobadas)", "planner:reopen": "Plan.: Reabrir Órdenes", "planner:receive": "Plan.: Recibir en Bodega", "planner:status:review": "Plan.: Enviar a Revisión", "planner:status:approve": "Plan.: Cambiar a Aprobada", "planner:status:in-progress": "Plan.: Cambiar a En Progreso", "planner:status:on-hold": "Plan.: Cambiar a En Espera", 
    "planner:status:completed": "Plan.: Cambiar a Completada", "planner:status:cancel": "Plan.: Cancelar (Pendientes)", "planner:status:cancel-approved": "Plan.: Cancelar (Aprobadas)", "planner:priority:update": "Plan.: Cambiar Prioridad", "planner:machine:assign": "Plan.: Asignar Máquina", "planner:status:unapprove-request": "Plan.: Solicitar Desaprobación", "planner:status:unapprove-request:approve": "Plan.: Aprobar Desaprobación", "planner:schedule": "Plan.: Programar Fechas",
    "cost-assistant:access": "Asist. Costos: Acceso", "cost-assistant:drafts:read-write": "Asist. Costos: Guardar Borradores",
    "operations:access": "Operaciones: Acceso General", "operations:create": "Operaciones: Crear Documentos", "operations:read:all": "Operaciones: Ver Todos", "operations:approve": "Operaciones: Aprobar Documentos", "operations:sign": "Operaciones: Firmar Entregas/Recibos",
    "it-tools:access": "TI: Acceso General", "it-tools:notes:read": "TI: Ver Notas", "it-tools:notes:create": "TI: Crear Notas", "it-tools:notes:update": "TI: Editar Notas", "it-tools:notes:delete": "TI: Eliminar Notas",
    "warehouse:access": "Almacén: Acceso General", "warehouse:search:full": "Almacén: Consulta Completa", "warehouse:search:simple": "Almacén: Búsqueda Rápida", 
    "warehouse:receiving-wizard:use": "Almacén: Usar Asist. Recepción", "warehouse:population-wizard:use": "Almacén: Usar Asist. Poblado", "warehouse:inventory-count:create": "Almacén: Registrar Conteo",
    "warehouse:item-assignment:create": "Almacén: Asignar Ubic./Prod.", "warehouse:item-assignment:delete": "Almacén: Eliminar Asignación",
    "warehouse:locations:create": "Almacén: Crear Ubicaciones", "warehouse:locations:update": "Almacén: Editar Ubicaciones", "warehouse:locations:delete": "Almacén: Eliminar Ubicaciones",
    "warehouse:units:create": "Almacén: Crear Lotes/QR", "warehouse:units:delete": "Almacén: Eliminar Lotes/QR", "warehouse:locks:manage": "Almacén: Gestionar Bloqueos",
    "warehouse:correction:execute": "Almacén: Corregir Ingreso", "warehouse:correction:apply": "Almacén: Aplicar Ingreso", "warehouse:labels:generate": "Almacén: Generar Etiquetas",
    "hacienda:query": "Hacienda: Realizar Consultas",
    "analytics:read": "Analíticas: Acceso", "analytics:purchase-suggestions:read": "Analíticas: Sugerencias Compra", "analytics:purchase-report:read": "Analíticas: Reporte Compras", "analytics:production-report:read": "Analíticas: Reporte Producción", "analytics:transits-report:read": "Analíticas: Reporte Tránsitos", "analytics:user-permissions:read": "Analíticas: Reporte Permisos", "analytics:physical-inventory-report:read": "Analíticas: Reporte Inv. Físico", "analytics:receiving-report:read": "Analíticas: Reporte Recepciones", "analytics:item-assignments-report:read": "Analíticas: Reporte Catálogo", "analytics:occupancy-report:read": "Analíticas: Reporte Ocupación",
    "users:create": "Usuarios: Crear", "users:read": "Usuarios: Leer", "users:update": "Usuarios: Actualizar", "users:delete": "Usuarios: Eliminar",
    "roles:create": "Roles: Crear", "roles:read": "Roles: Leer", "roles:update": "Roles: Actualizar", "roles:delete": "Roles: Eliminar",
    "admin:settings:general": "Admin: Config. General", "admin:settings:api": "Admin: Config. de API", "admin:settings:planner": "Admin: Config. Planificador", "admin:settings:requests": "Admin: Config. Compras", "admin:settings:warehouse": "Admin: Config. Almacenes", "admin:settings:stock": "Admin: Config. Inventario", "admin:settings:cost-assistant": "Admin: Config. Asist. Costos", "admin:settings:analytics": "Admin: Config. Analíticas",
    "admin:suggestions:read": "Admin: Leer Sugerencias",
    "admin:import:run": "Admin: Ejecutar Sincronización ERP", "admin:import:files": "Admin: Importar (Archivos)", "admin:import:sql": "Admin: Importar (SQL)", "admin:import:sql-config": "Admin: Configurar SQL",
    "admin:logs:read": "Admin: Ver Registros (Logs)", "admin:logs:clear": "Admin: Limpiar Registros (Logs)",
    "admin:maintenance:backup": "Admin: Mantenimiento (Backup)", "admin:maintenance:restore": "Admin: Mantenimiento (Restaurar)", "admin:maintenance:reset": "Admin: Mantenimiento (Resetear)",
};

export const permissionTree: Record<string, string[]> = {
    // Top-level Access
    "admin:access": ["users:read", "roles:read", "admin:settings:general", "admin:settings:api", "admin:settings:planner", "admin:settings:requests", "admin:settings:warehouse", "admin:settings:stock", "admin:settings:cost-assistant", "admin:settings:analytics", "admin:suggestions:read", "admin:import:run", "admin:logs:read", "admin:maintenance:backup"],
    "analytics:read": ["analytics:purchase-suggestions:read", "analytics:purchase-report:read", "analytics:production-report:read", "analytics:transits-report:read", "analytics:user-permissions:read", "analytics:physical-inventory-report:read", "analytics:receiving-report:read", "analytics:item-assignments-report:read", "analytics:occupancy-report:read"],
    "warehouse:access": ["warehouse:search:full", "warehouse:search:simple", "warehouse:receiving-wizard:use", "warehouse:population-wizard:use", "warehouse:inventory-count:create", "warehouse:item-assignment:create", "warehouse:locations:create", "warehouse:units:create", "warehouse:locks:manage", "warehouse:correction:execute", "warehouse:correction:apply", "warehouse:labels:generate"],
    "requests:read": ["requests:read:all", "requests:create"],
    "planner:read": ["planner:read:all", "planner:create"],
    "operations:access": ["operations:create", "operations:read:all", "operations:approve", "operations:sign"],
    "it-tools:access": ["it-tools:notes:read"],

    // Second-level dependencies
    "users:read": ["users:create", "users:update", "users:delete"],
    "roles:read": ["roles:create", "roles:update", "roles:delete"],
    "admin:import:run": ["admin:import:files", "admin:import:sql", "admin:import:sql-config"],
    "admin:logs:read": ["admin:logs:clear"],
    "admin:maintenance:backup": ["admin:maintenance:restore", "admin:maintenance:reset"],
    "it-tools:notes:read": ["it-tools:notes:create"],
    "it-tools:notes:create": ["it-tools:notes:update"],
    "it-tools:notes:update": ["it-tools:notes:delete"],


    "requests:create": ["requests:notes:add", "requests:edit:pending", "requests:create:duplicate"],
    "requests:edit:pending": ["requests:status:review"],
    "requests:status:review": ["requests:status:pending-approval"],
    "requests:status:pending-approval": ["requests:status:approve"],
    "requests:status:approve": ["requests:edit:approved", "requests:status:ordered", "requests:status:cancel", "requests:status:unapproval-request"],
    "requests:status:ordered": ["requests:status:received-in-warehouse", "requests:status:revert-to-approved"],
    "requests:status:received-in-warehouse": ["requests:status:entered-erp"],
    "requests:status:unapproval-request": ["requests:status:unapproval-request:approve"],

    // New granular financial permissions
    "requests:view:margin": ["requests:view:cost"],
    "requests:view:cost": ["requests:view:sale-price"],
    
    "planner:create": ["planner:edit:pending", "planner:status:review"],
    "planner:status:review": ["planner:status:approve"],
    "planner:status:approve": ["planner:edit:approved", "planner:status:in-progress", "planner:status:on-hold", "planner:status:completed", "planner:status:cancel-approved", "planner:status:unapprove-request", "planner:priority:update", "planner:machine:assign", "planner:schedule"],
    "planner:status:on-hold": ["planner:status:in-progress"], // Can resume
    "planner:status:completed": ["planner:receive", "planner:reopen"],
    "planner:status:cancel-approved": ["planner:reopen"],
    "planner:status:unapprove-request": ["planner:status:unapprove-request:approve"],


    "warehouse:locations:create": ["warehouse:locations:update", "warehouse:locations:delete"],
    "warehouse:item-assignment:create": ["warehouse:item-assignment:delete"],
    "warehouse:units:create": ["warehouse:units:delete"],
};


// --- FILE: src/modules/requests/lib/actions.ts ---

/**
 * @fileoverview Client-side functions for interacting with the request module's server-side DB functions.
 * This abstraction layer ensures components only call client-safe functions.
 */
'use client';

import type { PurchaseRequest, UpdateRequestStatusPayload, PurchaseRequestHistoryEntry, RequestSettings, UpdatePurchaseRequestPayload, RejectCancellationPayload, DateRange, AdministrativeAction, AdministrativeActionPayload, StockInfo, ErpOrderHeader, ErpOrderLine, User, RequestNotePayload, UserPreferences, PurchaseSuggestion, PurchaseRequestPriority, ErpPurchaseOrderHeader as ErpPOHeader, ErpPurchaseOrderLine } from '../../core/types';
import { logInfo, logError } from '@/modules/core/lib/logger';
import { createNotificationForPermission, createNotification } from '@/modules/core/lib/notifications-actions';
import { 
    getRequests, 
    addRequest,
    updateRequest,
    updateStatus, 
    getRequestHistory as getRequestHistoryServer,
    getSettings,
    saveSettings,
    updatePendingAction as updatePendingActionServer,
    getErpOrderData as getErpOrderDataServer,
    getUserByName,
    getRolesWithPermission,
    addNote as addNoteServer,
    updateRequestDetails as updateRequestDetailsServer,
    saveCostAnalysis as saveCostAnalysisServer,
} from './db';
import {
    saveUserPreferences as saveUserPreferencesServer,
    getUserPreferences as getUserPreferencesServer,
    getAllProducts, 
    getAllStock, 
    getAllCustomers,
    getAllErpPurchaseOrderHeaders as getAllErpPurchaseOrderHeadersDb,
    getAllErpPurchaseOrderLines as getAllErpPurchaseOrderLinesDb,
} from '@/modules/core/lib/db';
import { useRouter } from 'next/navigation';


/**
 * Fetches purchase requests from the server.
 * @param options - Pagination and filtering options.
 * @returns A promise that resolves to the requests and total counts.
 */
export async function getPurchaseRequests(options: { 
    page: number; 
    pageSize: number;
    isArchived: boolean;
    filters: {
        searchTerm?: string;
        status?: string[];
        classification?: string;
        showOnlyMy?: string;
        dateRange?: DateRange;
    };
}): Promise<{ requests: PurchaseRequest[], totalActive: number, totalArchived: number }> {
    return getRequests(options);
}


/**
 * Saves a new purchase request.
 * @param request - The request data to save.
 * @param requestedBy - The name of the user creating the request.
 * @returns The newly created purchase request.
 */
export async function savePurchaseRequest(request: Omit<PurchaseRequest, 'id' | 'consecutive' | 'requestDate' | 'status' | 'reopened' | 'requestedBy' | 'deliveredQuantity' | 'receivedInWarehouseBy' | 'receivedDate' | 'previousStatus' | 'lastModifiedAt' | 'lastModifiedBy' | 'hasBeenModified' | 'approvedBy' | 'lastStatusUpdateBy' | 'lastStatusUpdateNotes'>, requestedBy: string): Promise<PurchaseRequest> {
    const createdRequest = await addRequest(request, requestedBy);
    await logInfo(`Purchase request ${createdRequest.consecutive} created by ${requestedBy}`, { item: createdRequest.itemDescription, quantity: createdRequest.quantity });
    
    await createNotificationForPermission(
        'requests:status:review',
        `Nueva solicitud ${createdRequest.consecutive} para "${createdRequest.clientName}" requiere revisión.`,
        `/dashboard/requests?search=${createdRequest.consecutive}`,
        createdRequest.id,
        'purchase-request',
        'review'
    );
    
    return createdRequest;
}

/**
 * Updates the main details of an existing purchase request.
 * @param payload - The data to update.
 * @returns The updated purchase request.
 */
export async function updatePurchaseRequest(payload: UpdatePurchaseRequestPayload): Promise<PurchaseRequest> {
    const updatedRequest = await updateRequest(payload);
    await logInfo(`Purchase request ${updatedRequest.consecutive} edited by ${payload.updatedBy}`, { requestId: payload.requestId });
    return updatedRequest;
}

/**
 * Updates the status of a purchase request.
 * @param payload - The status update information.
 * @returns The updated purchase request.
 */
export async function updatePurchaseRequestStatus(payload: UpdateRequestStatusPayload): Promise<PurchaseRequest> {
    const updatedRequest = await updateStatus(payload);
    await logInfo(`Status of request ${updatedRequest.consecutive} updated to '${payload.status}' by ${payload.updatedBy}`, { notes: payload.notes, requestId: payload.requestId });
    
    if (updatedRequest.requestedBy !== payload.updatedBy) {
        const targetUser = await getUserByName(updatedRequest.requestedBy);
        if (targetUser) {
             const settings = await getSettings();
             const statusConfig = {
                'pending': 'Pendiente',
                'purchasing-review': 'Revisión Compras',
                'pending-approval': 'Pendiente Aprobación',
                'approved': 'Aprobada',
                'ordered': 'Ordenada',
                'received-in-warehouse': 'Recibido en Bodega',
                'entered-erp': 'Ingresado ERP',
                'canceled': 'Cancelada'
             };
             const statusLabel = (statusConfig as any)[payload.status] || payload.status;
            await createNotification({
                userId: targetUser.id,
                message: `La solicitud ${updatedRequest.consecutive} ha sido actualizada a: ${statusLabel}.`,
                href: `/dashboard/requests?search=${updatedRequest.consecutive}`,
                entityId: updatedRequest.id,
                entityType: 'purchase-request',
                entityStatus: payload.status,
            });
        }
    }
    
    return updatedRequest;
}

/**
 * Updates specific details of a purchase request like priority.
 * @param payload - The details to update.
 * @returns The updated purchase request.
 */
export async function updateRequestDetails(payload: { requestId: number; priority: PurchaseRequestPriority, updatedBy: string }): Promise<PurchaseRequest> {
    const updatedRequest = await updateRequestDetailsServer(payload);
    await logInfo(`Details for request ${updatedRequest.consecutive} updated by ${payload.updatedBy}`, { details: payload });
    return updatedRequest;
}


/**
 * Fetches the history for a specific request.
 * @param requestId - The ID of the request.
 * @returns A promise that resolves to an array of history entries.
 */
export async function getRequestHistory(requestId: number): Promise<PurchaseRequestHistoryEntry[]> {
    return getRequestHistoryServer(requestId);
}

/**
 * Fetches request settings from the server.
 * @returns The current request settings.
 */
export async function getRequestSettings(): Promise<RequestSettings> {
    return getSettings();
}

/**
 * Saves request settings.
 * @param settings - The settings object to save.
 */
export async function saveRequestSettings(settings: RequestSettings): Promise<void> {
    await logInfo('Purchase requests settings updated.');
    return saveSettings(settings);
}

/**
 * Updates the pending administrative action for a request.
 * @param payload - The action details.
 * @returns The updated purchase request.
 */
export async function updatePendingAction(payload: AdministrativeActionPayload): Promise<PurchaseRequest> {
    const updatedRequest = await updatePendingActionServer(payload);
    await logInfo(`Administrative action '${payload.action}' initiated for request ${updatedRequest.consecutive} by ${payload.updatedBy}.`);
    
    if (payload.action.includes('request')) {
        await createNotificationForPermission(
            'requests:status:approve', // A suitable admin-level permission
            `El usuario ${payload.updatedBy} solicita cancelar la solicitud ${updatedRequest.consecutive}.`,
            `/dashboard/requests?search=${updatedRequest.consecutive}`,
            updatedRequest.id,
            'purchase-request',
            'cancellation-request'
        );
    }
    
    return updatedRequest;
}

/**
 * Fetches the header and line items for a given ERP order number.
 * @param orderNumber The ERP order number to fetch.
 * @returns An object containing the order headers, an array of lines, and the real-time inventory for those lines.
 */
export async function getErpOrderData(identifier: string | DateRange): Promise<{headers: ErpOrderHeader[], lines: ErpOrderLine[], inventory: StockInfo[]}> {
    return getErpOrderDataServer(identifier);
}

/**
 * Analyzes ERP orders within a date range and suggests purchases for items with stock shortages.
 * @param dateRange - The date range for ERP orders to analyze.
 * @returns A promise that resolves to an array of purchase suggestions.
 */
export async function getRequestSuggestions(dateRange: DateRange): Promise<PurchaseSuggestion[]> {
    const { headers, lines } = await getErpOrderDataServer(dateRange);
    const [allStock, allProducts, allCustomers, erpPoHeaders, erpPoLines] = await Promise.all([
        getAllStock(),
        getAllProducts(),
        getAllCustomers(),
        getAllErpPurchaseOrderHeadersDb(),
        getAllErpPurchaseOrderLinesDb(),
    ]);
    const allActiveRequests = await getRequests({ page: 0, pageSize: 99999, isArchived: false, filters: {} }).then(res => res.requests.filter(r => ['pending', 'approved', 'ordered', 'purchasing-review', 'pending-approval'].includes(r.status)));

    const activePoNumbers = new Set(erpPoHeaders.filter((h: any) => h.ESTADO === 'A').map((h: any) => h.ORDEN_COMPRA));

    const requiredItems = new Map<string, { totalRequired: number; sourceOrders: Set<string>; clientIds: Set<string>; erpUsers: Set<string>; earliestCreationDate: Date | null, earliestDueDate: Date | null; }>();

    for (const line of lines) {
        const header = headers.find(h => h.PEDIDO === line.PEDIDO);
        if (!header) continue;

        if (!requiredItems.has(line.ARTICULO)) {
            requiredItems.set(line.ARTICULO, { totalRequired: 0, sourceOrders: new Set(), clientIds: new Set(), erpUsers: new Set(), earliestCreationDate: null, earliestDueDate: null });
        }
        
        const item = requiredItems.get(line.ARTICULO)!;
        item.totalRequired += line.CANTIDAD_PEDIDA;
        item.sourceOrders.add(header.PEDIDO);
        item.clientIds.add(header.CLIENTE);
        if (header.USUARIO) {
            item.erpUsers.add(header.USUARIO);
        }
        
        const creationDate = new Date(header.FECHA_PEDIDO);
        if (!item.earliestCreationDate || creationDate < item.earliestCreationDate) {
            item.earliestCreationDate = creationDate;
        }

        const dueDate = new Date(header.FECHA_PROMETIDA);
        if (!item.earliestDueDate || dueDate < item.earliestDueDate) {
            item.earliestDueDate = dueDate;
        }
    }

    const suggestions: PurchaseSuggestion[] = [];

    for (const [itemId, data] of requiredItems.entries()) {
        const stockInfo: StockInfo | undefined = allStock.find((s: StockInfo) => s.itemId === itemId);
        const currentStock = stockInfo?.totalStock ?? 0;
        
        const inTransitStock = erpPoLines
            .filter((line: any) => line.ARTICULO === itemId && activePoNumbers.has(line.ORDEN_COMPRA))
            .reduce((sum: any, line: any) => sum + line.CANTIDAD_ORDENADA, 0);

        const existingActiveRequests = allActiveRequests.filter(r => r.itemId === itemId);
        
        const shortage = data.totalRequired - currentStock - inTransitStock;

        if (shortage > 0) {
            const productInfo = allProducts.find((p: any) => p.id === itemId);
            const involvedClients = Array.from(data.clientIds).map(id => {
                const customer = allCustomers.find((c: any) => c.id === id);
                return { id, name: customer?.name || 'Desconocido' };
            });
            
            suggestions.push({
                itemId,
                itemDescription: productInfo?.description || 'Artículo no encontrado',
                itemClassification: productInfo?.classification || 'N/A',
                totalRequired: data.totalRequired,
                currentStock,
                inTransitStock,
                shortage,
                sourceOrders: Array.from(data.sourceOrders),
                involvedClients,
                erpUsers: Array.from(data.erpUsers),
                earliestCreationDate: data.earliestCreationDate ? data.earliestCreationDate.toISOString() : null,
                earliestDueDate: data.earliestDueDate ? data.earliestDueDate.toISOString() : null,
                existingActiveRequests: existingActiveRequests.map(r => ({
                    id: r.id,
                    consecutive: r.consecutive,
                    status: r.status,
                    quantity: r.quantity,
                    purchaseOrder: r.purchaseOrder,
                    erpOrderNumber: r.erpOrderNumber,
                    requestedBy: r.requestedBy,
                })),
            });
        }
    }

    return suggestions;
}


/**
 * Adds a note to a purchase request without changing its status.
 * @param payload - The note details including requestId and notes.
 * @returns The updated purchase request.
 */
export async function addNoteToRequest(payload: { requestId: number; notes: string; updatedBy: string; }): Promise<PurchaseRequest> {
    const updatedRequest = await addNoteServer(payload);
    await logInfo(`Note added to request ${updatedRequest.consecutive} by ${payload.updatedBy}.`);
    return updatedRequest;
}

/**
 * Gets the saved preferences for the purchase suggestions page for a specific user.
 * @param userId The ID of the user.
 * @returns A promise that resolves to the saved preferences or null.
 */
export async function getPurchaseSuggestionsPreferences(userId: number): Promise<Partial<UserPreferences> | null> {
    return getUserPreferencesServer(userId, 'purchaseSuggestionsPrefs');
}

/**
 * Saves the preferences for the purchase suggestions page for a specific user.
 * @param userId The ID of the user.
 * @param preferences The preferences object to save.
 */
export async function savePurchaseSuggestionsPreferences(userId: number, preferences: Partial<UserPreferences>): Promise<void> {
    return saveUserPreferencesServer(userId, 'purchaseSuggestionsPrefs', preferences);
}

export async function saveCostAnalysis(requestId: number, cost: number, salePrice: number): Promise<PurchaseRequest> {
    const updatedRequest = await saveCostAnalysisServer(requestId, cost, salePrice);
    await logInfo(`Cost analysis saved for request ${updatedRequest.consecutive}`, { requestId, cost, salePrice });
    return updatedRequest;
}


// --- FILE: src/app/dashboard/warehouse/locations/page.tsx ---

/**
 * @fileoverview Page for managing warehouse structure (hierarchy and locations).
 * This page is intended for warehouse supervisors to define the layout of their warehouse.
 */
'use client';

import { useState, useEffect, useCallback, useMemo } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { useToast } from '@/modules/core/hooks/use-toast';
import { logError, logInfo, logWarn } from '@/modules/core/lib/logger';
import { usePageTitle } from '@/modules/core/hooks/usePageTitle';
import { useAuthorization } from '@/modules/core/hooks/useAuthorization';
import { getWarehouseSettings, saveWarehouseSettings, getLocations, addLocation, deleteLocation, updateLocation, addBulkLocations } from '@/modules/warehouse/lib/actions';
import { PlusCircle, Trash2, Edit2, Save, ChevronDown, ChevronRight, Info, Wand2, Copy, List } from 'lucide-react';
import { Skeleton } from '@/components/ui/skeleton';
import { WarehouseSettings, WarehouseLocation } from '@/modules/core/types';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion";
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle } from "@/components/ui/alert-dialog";
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle, DialogFooter, DialogClose } from '@/components/ui/dialog';
import { Separator } from '@/components/ui/separator';
import { useAuth } from '@/modules/core/hooks/useAuth';
import { SearchInput } from '@/components/ui/search-input';
import { useDebounce } from 'use-debounce';

const emptyLocation: Omit<WarehouseLocation, 'id'> = { name: '', code: '', type: 'building', parentId: null };
const initialWizardState = { name: '', prefix: '', levels: '', positions: '', depth: '', parentId: null as number | null };
const initialCloneState = { sourceRackId: '', newName: '', newPrefix: '' };

const renderLocationPathAsString = (locationId: number, locations: WarehouseLocation[]): string => {
    if (!locationId) return '';
    const path: WarehouseLocation[] = [];
    let current: WarehouseLocation | undefined = locations.find(l => l.id === locationId);
    
    while (current) {
        path.unshift(current);
        const parentId = current.parentId;
        if (!parentId) break;
        current = locations.find(l => l.id === parentId);
    }
    return path.map(l => l.name).join(' > ');
};


interface LocationFormProps {
    initialLocation: Partial<WarehouseLocation>;
    allLocations: WarehouseLocation[];
    settings: WarehouseSettings;
    onSave: (location: Partial<WarehouseLocation>) => void;
    onCancel: () => void;
    isEditing: boolean;
}

function LocationForm({ initialLocation, allLocations, settings, onSave, onCancel, isEditing }: LocationFormProps) {
    const { companyData } = useAuth();
    const [formData, setFormData] = useState(initialLocation);
    const [parentSearchTerm, setParentSearchTerm] = useState('');
    const [isParentSearchOpen, setIsParentSearchOpen] = useState(false);
    const [debouncedParentSearch] = useDebounce(parentSearchTerm, companyData?.searchDebounceTime ?? 500);

    useEffect(() => {
        setFormData(initialLocation);
        const parentLocation = allLocations.find(l => l.id === initialLocation.parentId);
        if (parentLocation) {
            setParentSearchTerm(renderLocationPathAsString(parentLocation.id, allLocations));
        } else {
            setParentSearchTerm('');
        }
    }, [initialLocation, allLocations]);

    const handleChange = (field: keyof WarehouseLocation, value: any) => {
        setFormData(prev => ({ ...prev, [field]: value }));
    };

    const handleSelectParent = (value: string) => {
        const parentId = Number(value);
        handleChange('parentId', parentId);
        const parentLocation = allLocations.find(l => l.id === parentId);
        if (parentLocation) {
            setParentSearchTerm(renderLocationPathAsString(parentLocation.id, allLocations));
        }
        setIsParentSearchOpen(false);
    };

    const parentLocationOptions = useMemo(() => {
        const searchLower = debouncedParentSearch.trim().toLowerCase();
        
        // Find the types that CANNOT be parents (the last level in the hierarchy)
        const hierarchyLevels = settings.locationLevels || [];
        const leafNodeTypes = new Set<string>();
        if (hierarchyLevels.length > 0) {
            const lastLevel = hierarchyLevels[hierarchyLevels.length - 1];
            leafNodeTypes.add(lastLevel.type);
        }

        const filtered = allLocations.filter(l => 
            l.id !== formData?.id && // Can't be its own parent
            !leafNodeTypes.has(l.type) && // Exclude leaf node types
            renderLocationPathAsString(l.id, allLocations).toLowerCase().includes(searchLower)
        );

        return filtered.map(l => ({
            value: String(l.id),
            label: renderLocationPathAsString(l.id, allLocations)
        }));
    }, [allLocations, debouncedParentSearch, formData?.id, settings.locationLevels]);


    return (
        <form onSubmit={(e) => { e.preventDefault(); onSave(formData); }}>
            <div className="space-y-4 py-4">
                <div className="grid grid-cols-2 gap-4">
                    <div className="space-y-2">
                        <Label htmlFor="loc-name">Nombre</Label>
                        <Input id="loc-name" value={formData.name || ''} onChange={e => handleChange('name', e.target.value)} required />
                    </div>
                    <div className="space-y-2">
                        <Label htmlFor="loc-code">Código Único</Label>
                        <Input id="loc-code" value={formData.code || ''} onChange={e => handleChange('code', e.target.value)} required />
                    </div>
                </div>
                <div className="space-y-2">
                    <Label htmlFor="loc-type">Tipo de Ubicación (Nivel)</Label>
                    <Select value={formData.type || ''} onValueChange={(val) => handleChange('type', val)}>
                        <SelectTrigger><SelectValue/></SelectTrigger>
                        <SelectContent>
                            {settings.locationLevels?.map((level, index) => (
                                <SelectItem key={level.type} value={level.type}>Nivel {index+1}: {level.name}</SelectItem>
                            ))}
                        </SelectContent>
                    </Select>
                </div>
                <div className="space-y-2">
                    <Label htmlFor="loc-parent">Ubicación Padre (Opcional)</Label>
                    <div className="flex items-center gap-2">
                        <SearchInput 
                            options={parentLocationOptions}
                            onSelect={handleSelectParent}
                            value={parentSearchTerm}
                            onValueChange={setParentSearchTerm}
                            placeholder="Buscar ubicación padre..."
                            open={isParentSearchOpen}
                            onOpenChange={setIsParentSearchOpen}
                        />
                         <Button type="button" variant="outline" size="icon" onClick={() => {setParentSearchTerm(''); handleChange('parentId', null);}}>
                            <Trash2 className="h-4 w-4" />
                        </Button>
                    </div>
                </div>
            </div>
            <DialogFooter>
                <Button variant="ghost" type="button" onClick={onCancel}>Cancelar</Button>
                <Button type="submit"><Save className="mr-2"/> Guardar</Button>
            </DialogFooter>
        </form>
    );
}

function LocationTree({ locations, onEdit, onDelete }: { locations: WarehouseLocation[], onEdit: (loc: WarehouseLocation) => void, onDelete: (loc: WarehouseLocation) => void }) {
    const [openNodes, setOpenNodes] = useState<Set<number>>(() => {
        const rootIds = locations.filter(l => !l.parentId).map(l => l.id);
        const secondLevelIds = locations.filter(l => l.parentId && rootIds.includes(l.parentId)).map(l => l.id);
        return new Set([...rootIds, ...secondLevelIds]);
    });

    const toggleNode = (id: number) => {
        setOpenNodes(prev => {
            const newSet = new Set(prev);
            if (newSet.has(id)) {
                newSet.delete(id);
            } else {
                newSet.add(id);
            }
            return newSet;
        });
    };

    const renderNode = (location: WarehouseLocation, level = 0) => {
        const children = locations.filter(l => l.parentId === location.id);
        const hasChildren = children.length > 0;
        const isOpen = openNodes.has(location.id);

        return (
            <div key={location.id} className="relative">
                 {level > 0 && <span className="absolute -left-2 top-1/2 w-4 h-px bg-muted-foreground/30"></span>}
                <div className={`flex items-center justify-between p-2 rounded-md hover:bg-muted/50`}>
                    <div className="flex items-center gap-2">
                        <div style={{ paddingLeft: `${level * 24}px` }} className="flex items-center gap-2">
                            {hasChildren ? (
                                <Button variant="ghost" size="icon" className="h-6 w-6 shrink-0" onClick={() => toggleNode(location.id)}>
                                    {isOpen ? <ChevronDown className="h-4 w-4" /> : <ChevronRight className="h-4 w-4" />}
                                </Button>
                            ) : (
                                <span className="w-6 shrink-0"></span> // Placeholder to align items
                            )}
                            <span className="font-medium">{location.name}</span>
                            <span className="text-xs text-muted-foreground font-mono">({location.code})</span>
                        </div>
                    </div>
                    <div className="flex items-center gap-1">
                        <Button variant="ghost" size="icon" className="h-7 w-7" onClick={() => onEdit(location)}><Edit2 className="h-4 w-4" /></Button>
                        <Button variant="ghost" size="icon" className="h-7 w-7" onClick={() => onDelete(location)}>
                            <Trash2 className="h-4 w-4 text-destructive" />
                        </Button>
                    </div>
                </div>
                {isOpen && hasChildren && (
                    <div className="relative pl-6 border-l-2 border-muted-foreground/10 ml-5">{children.map(child => renderNode(child, level + 1))}</div>
                )}
            </div>
        );
    };

    const rootLocations = locations.filter(l => !l.parentId);
    return (
        <div className="space-y-1">
            {rootLocations.map(loc => renderNode(loc))}
        </div>
    );
}

export default function ManageLocationsPage() {
    const { isAuthorized } = useAuthorization(['warehouse:locations:manage']);
    const { setTitle } = usePageTitle();
    const { toast } = useToast();
    const { user } = useAuth();
    
    const [settings, setSettings] = useState<WarehouseSettings | null>(null);
    const [locations, setLocations] = useState<WarehouseLocation[]>([]);
    const [isLoading, setIsLoading] = useState(true);

    const [newLevelName, setNewLevelName] = useState('');
    
    const [isLocationFormOpen, setLocationFormOpen] = useState(false);
    const [currentLocation, setCurrentLocation] = useState<Partial<WarehouseLocation>>(emptyLocation);
    const [isEditingLocation, setIsEditingLocation] = useState(false);
    const [locationToDelete, setLocationToDelete] = useState<WarehouseLocation | null>(null);

    const [isWizardOpen, setWizardOpen] = useState(false);
    const [wizardData, setWizardData] = useState(initialWizardState);
    const [cloneData, setCloneData] = useState(initialCloneState);

    const fetchAllData = useCallback(async () => {
        setIsLoading(true);
        try {
            const [settingsData, locationsData] = await Promise.all([
                getWarehouseSettings(),
                getLocations(),
            ]);
            setSettings(settingsData);
            setLocations(locationsData);
        } catch (error) {
            logError('Failed to fetch warehouse config data', { error });
            toast({ title: "Error", description: "No se pudieron cargar los datos de configuración del almacén.", variant: "destructive" });
        } finally {
            setIsLoading(false);
        }
    }, [toast]);
    
    useEffect(() => {
        setTitle("Gestión de Ubicaciones de Almacén");
        if(isAuthorized){
            fetchAllData();
        }
    }, [setTitle, fetchAllData, isAuthorized]);

    const handleAddLevel = () => {
        if (!settings || !newLevelName.trim()) return;
        const newLevels = [...(settings.locationLevels || []), { type: `level${(settings.locationLevels?.length || 0) + 1}`, name: newLevelName.trim() }];
        setSettings({ ...settings, locationLevels: newLevels });
        setNewLevelName('');
    };
    
    const handleDeleteLevel = useCallback((index: number) => {
        if (!settings) return;
        const newLevels = settings.locationLevels?.filter((_, i) => i !== index);
        setSettings({ ...settings, locationLevels: newLevels });
    }, [settings]);

    const handleSaveHierarchy = async () => {
        if (!settings) return;
        try {
            await saveWarehouseSettings(settings);
            toast({ title: "Jerarquía Guardada", description: "Los niveles del almacén han sido guardados." });
            logInfo("Warehouse hierarchy settings updated", { settings });
        } catch (error: any) {
            logError("Failed to save warehouse settings", { error: error.message });
            toast({ title: "Error", description: "No se pudieron guardar los ajustes de jerarquía.", variant: "destructive" });
        }
    };

    const handleSaveLocation = async (locationData: Partial<WarehouseLocation>) => {
        if (!locationData.name || !locationData.code || !locationData.type) {
            toast({ title: "Datos incompletos", variant: "destructive" });
            return;
        }

        try {
            if (isEditingLocation && locationData.id) {
                const updatedLoc = await updateLocation(locationData as WarehouseLocation);
                setLocations(prev => prev.map(l => l.id === updatedLoc.id ? updatedLoc : l));
                toast({ title: "Ubicación Actualizada" });
            } else {
                const newLoc = await addLocation(locationData as Omit<WarehouseLocation, 'id'>);
                setLocations(prev => [...prev, newLoc]);
                toast({ title: "Ubicación Creada" });
            }
            setLocationFormOpen(false);
        } catch (error: any) {
            logError("Failed to save location", { error: error.message });
            toast({ title: "Error", description: error.message, variant: "destructive" });
        }
    };
    
    const handleDeleteLocationAction = useCallback(async () => {
        if (!locationToDelete || !user) return;
        try {
            await deleteLocation(locationToDelete.id, user.name);
            const locationsData = await getLocations();
            setLocations(locationsData);
            toast({ title: "Ubicación Eliminada" });
            setLocationToDelete(null);
        } catch (error: any) {
             logError("Failed to delete location", { error: error.message });
            toast({ title: "Error", description: error.message, variant: "destructive" });
        }
    }, [locationToDelete, toast, user]);
    
    const openLocationForm = (loc?: WarehouseLocation) => {
        if (loc) {
            setCurrentLocation(loc);
            setIsEditingLocation(true);
        } else {
            setCurrentLocation(emptyLocation);
            setIsEditingLocation(false);
        }
        setLocationFormOpen(true);
    };

    const handleGenerateFromWizard = async () => {
        if (!wizardData.name || !wizardData.prefix || !wizardData.levels || !wizardData.positions || !wizardData.depth) {
            toast({ title: 'Datos Incompletos', description: 'Todos los campos del asistente son requeridos.', variant: 'destructive' });
            return;
        }
        try {
            const params = {
                name: wizardData.name,
                prefix: wizardData.prefix,
                levels: Number(wizardData.levels),
                positions: Number(wizardData.positions),
                depth: Number(wizardData.depth),
                parentId: wizardData.parentId
            };
            await addBulkLocations({ type: 'rack', params });
            toast({ title: '¡Rack Creado!', description: `Se generaron las ubicaciones para ${wizardData.name}.` });
            setWizardOpen(false);
            setWizardData(initialWizardState);
            await fetchAllData(); // Refresh the location list
        } catch (error: any) {
            logError('Failed to generate from wizard', { error: error.message });
            toast({ title: 'Error al Generar', description: error.message, variant: 'destructive' });
        }
    };

    const handleCloneRack = async () => {
        if (!cloneData.sourceRackId || !cloneData.newName || !cloneData.newPrefix) {
            toast({ title: 'Datos Incompletos', description: 'Debes seleccionar un rack de origen y proporcionar un nuevo nombre y prefijo.', variant: 'destructive' });
            return;
        }
        try {
            await addBulkLocations({ type: 'clone', params: cloneData });
            toast({ title: '¡Rack Clonado!', description: `La estructura de ${cloneData.newName} ha sido creada.` });
            setWizardOpen(false);
            setCloneData(initialCloneState);
            await fetchAllData(); // Refresh the location list
        } catch (error: any) {
            logError('Failed to clone rack', { error: error.message });
            toast({ title: 'Error al Clonar', description: error.message, variant: 'destructive' });
        }
    };
    
    const rackOptions = locations
        .filter(l => l.type === 'rack')
        .map(l => ({ value: String(l.id), label: `${l.name} (${l.code})` }));

    if (isLoading || !settings) {
        return (
            <main className="flex-1 p-4 md:p-6 lg:p-8">
                <div className="mx-auto max-w-4xl space-y-6">
                    <Skeleton className="h-64 w-full" />
                </div>
            </main>
        );
    }
    
    if (!isAuthorized) {
        return null;
    }

    return (
        <main className="flex-1 p-4 md:p-6 lg:p-8">
            <div className="mx-auto max-w-4xl space-y-6">
                 <Accordion type="multiple" defaultValue={['item-1', 'item-2']} className="w-full space-y-6">
                    <Card>
                        <AccordionItem value="item-1">
                            <AccordionTrigger className="p-6">
                                <CardTitle>Paso 1: Definir Jerarquía del Almacén (El Molde)</CardTitle>
                            </AccordionTrigger>
                            <AccordionContent className="p-6 pt-0">
                                <CardDescription className="mb-4">
                                    Define los <strong>nombres</strong> para cada nivel de tu organización. Esto crea la plantilla para construir tu almacén. Por ejemplo: <code>Bodega</code>, <code>Pasillo</code>, <code>Rack</code>, <code>Estante</code>, <code>Casilla</code>.
                                </CardDescription>
                                <div className="space-y-4">
                                    {settings.locationLevels?.map((level, index) => (
                                        <div key={index} className="flex items-center justify-between rounded-lg border p-3">
                                            <p className="font-medium">Nivel {index + 1}: {level.name}</p>
                                            <Button variant="ghost" size="icon" className="h-8 w-8" onClick={() => handleDeleteLevel(index)}>
                                                <Trash2 className="h-4 w-4 text-destructive" />
                                            </Button>
                                        </div>
                                    ))}
                                    <Separator />
                                    <div className="flex items-end gap-2 pt-2">
                                        <div className="grid flex-1 gap-2">
                                            <Label htmlFor="new-level-name">Nombre del Nuevo Nivel</Label>
                                            <Input id="new-level-name" value={newLevelName} onChange={(e) => setNewLevelName(e.target.value)} placeholder="Ej: Tarima" />
                                        </div>
                                        <Button size="icon" onClick={handleAddLevel}>
                                            <PlusCircle className="h-4 w-4" />
                                        </Button>
                                    </div>
                                </div>
                                <div className="mt-6">
                                    <Button onClick={handleSaveHierarchy}><Save className="mr-2"/> Guardar Niveles</Button>
                                </div>
                            </AccordionContent>
                        </AccordionItem>
                    </Card>
                    <Card>
                        <AccordionItem value="item-2">
                            <AccordionTrigger className="p-6">
                            <CardTitle>Paso 2: Crear Ubicaciones Reales (El Árbol)</CardTitle>
                            </AccordionTrigger>
                            <AccordionContent className="p-6 pt-0">
                                <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between mb-4 gap-4">
                                    <CardDescription>
                                        Usa los niveles que definiste para construir la estructura de tu almacén.
                                    </CardDescription>
                                    <div className="flex items-center gap-2 flex-shrink-0 w-full sm:w-auto">
                                        <Button onClick={() => openLocationForm()} className="flex-1 sm:flex-grow-0">
                                            <PlusCircle className="mr-2"/> Añadir Manual
                                        </Button>
                                        <Button variant="secondary" onClick={() => setWizardOpen(true)} className="flex-1 sm:flex-grow-0">
                                            <Wand2 className="mr-2"/> Asistente
                                        </Button>
                                    </div>
                                </div>
                                <div>
                                    <LocationTree locations={locations} onEdit={openLocationForm} onDelete={setLocationToDelete} />
                                </div>
                            </AccordionContent>
                        </AccordionItem>
                    </Card>
                </Accordion>

                 <Dialog open={isLocationFormOpen} onOpenChange={setLocationFormOpen}>
                    <DialogContent>
                        <DialogHeader>
                            <DialogTitle>{isEditingLocation ? "Editar" : "Añadir"} Ubicación</DialogTitle>
                            <DialogDescription>
                                {isEditingLocation ? "Modifica los detalles de esta ubicación." : "Crea una nueva ubicación en tu almacén."}
                            </DialogDescription>
                        </DialogHeader>
                         <LocationForm 
                            initialLocation={currentLocation}
                            allLocations={locations}
                            settings={settings}
                            onSave={handleSaveLocation}
                            onCancel={() => setLocationFormOpen(false)}
                            isEditing={isEditingLocation}
                         />
                    </DialogContent>
                 </Dialog>

                 <Dialog open={isWizardOpen} onOpenChange={setWizardOpen}>
                    <DialogContent className="sm:max-w-2xl">
                        <DialogHeader>
                            <DialogTitle>Asistente de Creación de Racks</DialogTitle>
                            <DialogDescription>Genera o clona rápidamente la estructura completa de un rack.</DialogDescription>
                        </DialogHeader>
                        <Accordion type="single" collapsible className="w-full">
                            <AccordionItem value="item-1">
                                <AccordionTrigger>Crear Nuevo Rack desde Cero</AccordionTrigger>
                                <AccordionContent className="pt-4 space-y-4">
                                     <div className="space-y-2">
                                        <Label htmlFor="wiz-parent">Ubicación Padre (Bodega/Zona)</Label>
                                        <Select value={wizardData.parentId ? String(wizardData.parentId) : 'none'} onValueChange={val => setWizardData(p => ({...p, parentId: val === 'none' ? null : Number(val)}))}>
                                            <SelectTrigger><SelectValue placeholder="Seleccionar (opcional, si es raíz)"/></SelectTrigger>
                                            <SelectContent>
                                                <SelectItem value="none">(Ninguno - Nivel Raíz)</SelectItem>
                                                {locations.filter(l => l.type !== 'shelf' && l.type !== 'bin').map(opt => (
                                                    <SelectItem key={opt.id} value={String(opt.id)}>{opt.name} ({opt.code})</SelectItem>
                                                ))}
                                            </SelectContent>
                                        </Select>
                                    </div>
                                    <div className="grid grid-cols-2 gap-4">
                                        <div className="space-y-2">
                                            <Label htmlFor="wiz-name">Nombre Base del Rack</Label>
                                            <Input id="wiz-name" value={wizardData.name} onChange={e => setWizardData(p => ({...p, name: e.target.value}))} placeholder="Ej: Rack 01" />
                                        </div>
                                        <div className="space-y-2">
                                            <Label htmlFor="wiz-prefix">Prefijo de Código</Label>
                                            <Input id="wiz-prefix" value={wizardData.prefix} onChange={e => setWizardData(p => ({...p, prefix: e.target.value}))} placeholder="Ej: R01" />
                                        </div>
                                    </div>
                                    <div className="grid grid-cols-3 gap-4">
                                        <div className="space-y-2">
                                            <Label htmlFor="wiz-levels">Nº de Niveles (Alto)</Label>
                                            <Input id="wiz-levels" type="number" value={wizardData.levels} onChange={e => setWizardData(p => ({...p, levels: e.target.value}))} placeholder="ej: 4" />
                                        </div>
                                        <div className="space-y-2">
                                            <Label htmlFor="wiz-positions">Nº de Posiciones (Ancho)</Label>
                                            <Input id="wiz-positions" type="number" value={wizardData.positions} onChange={e => setWizardData(p => ({...p, positions: e.target.value}))} placeholder="ej: 10" />
                                        </div>
                                        <div className="space-y-2">
                                            <Label htmlFor="wiz-depth">Nº de Fondos</Label>
                                            <Input id="wiz-depth" type="number" value={wizardData.depth} onChange={e => setWizardData(p => ({...p, depth: e.target.value}))} placeholder="1 o 2" />
                                        </div>
                                    </div>
                                    <p className="text-xs text-muted-foreground">Ejemplo de código generado: {wizardData.prefix || 'R01'}-A-01-F</p>
                                    <Button onClick={handleGenerateFromWizard}>
                                        <Wand2 className="mr-2"/> Generar Estructura
                                    </Button>
                                </AccordionContent>
                            </AccordionItem>
                             <AccordionItem value="item-2">
                                <AccordionTrigger>Clonar Estructura de Rack Existente</AccordionTrigger>
                                <AccordionContent className="pt-4 space-y-4">
                                     <div className="space-y-2">
                                        <Label htmlFor="clone-source">Rack de Origen a Clonar</Label>
                                        <Select value={cloneData.sourceRackId} onValueChange={val => setCloneData(p => ({...p, sourceRackId: val}))}>
                                            <SelectTrigger><SelectValue placeholder="Busca un rack de origen para clonar (ej: 'Rack 01')"/></SelectTrigger>
                                            <SelectContent>
                                                {rackOptions.map(opt => <SelectItem key={opt.value} value={opt.value}>{opt.label}</SelectItem>)}
                                            </SelectContent>
                                        </Select>
                                    </div>
                                    <div className="grid grid-cols-2 gap-4">
                                        <div className="space-y-2">
                                            <Label htmlFor="clone-name">Nuevo Nombre Base</Label>
                                            <Input id="clone-name" value={cloneData.newName} onChange={e => setCloneData(p => ({...p, newName: e.target.value}))} placeholder="Ej: Rack 02"/>
                                        </div>
                                        <div className="space-y-2">
                                            <Label htmlFor="clone-prefix">Nuevo Prefijo de Código</Label>
                                            <Input id="clone-prefix" value={cloneData.newPrefix} onChange={e => setCloneData(p => ({...p, newPrefix: e.target.value}))} placeholder="Ej: R02"/>
                                        </div>
                                    </div>
                                     <Button onClick={handleCloneRack}>
                                        <Copy className="mr-2"/> Clonar Rack
                                    </Button>
                                </AccordionContent>
                            </AccordionItem>
                        </Accordion>
                    </DialogContent>
                 </Dialog>

                  <AlertDialog open={!!locationToDelete} onOpenChange={(open) => !open && setLocationToDelete(null)}>
                    <AlertDialogContent>
                        <AlertDialogHeader>
                            <AlertDialogTitle>{`¿Eliminar "${locationToDelete?.name}"?`}</AlertDialogTitle>
                            <AlertDialogDescription>
                                Esta acción no se puede deshacer. Se eliminará la ubicación y TODAS las ubicaciones hijas que contenga. 
                                El inventario asociado no se eliminará, pero quedará sin ubicación.
                            </AlertDialogDescription>
                        </AlertDialogHeader>
                        <AlertDialogFooter>
                            <AlertDialogCancel onClick={() => setLocationToDelete(null)}>Cancelar</AlertDialogCancel>
                            <AlertDialogAction onClick={handleDeleteLocationAction}>Sí, Eliminar</AlertDialogAction>
                        </AlertDialogFooter>
                    </AlertDialogContent>
                  </AlertDialog>
            </div>
        </main>
    );
}

