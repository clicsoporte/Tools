# Plan de Acción y Lluvia de Ideas: Sistema de Notificaciones Unificado
# Versión 2.0 - 2024-10-27

Este documento es nuestra guía maestra para el diseño e implementación del nuevo centro de notificaciones de Clic-Tools, enriquecida con conceptos de la industria observados en el proyecto de ejemplo "Novu".

---

## 1. Visión General y Objetivos (Nuestra Meta)

El objetivo es crear un sistema de notificaciones unificado y proactivo dentro de la aplicación para mejorar la comunicación y la eficiencia del equipo. En lugar de que los usuarios tengan que revisar constantemente los módulos, el sistema les informará activamente cuando se requiera su atención.

### Funcionalidades Clave:
- **Notificaciones en la Interfaz:** Un icono de campana en la cabecera principal mostrará las alertas no leídas.
- **Alertas Relevantes:** Las notificaciones se generarán a partir de acciones importantes en el sistema (ej: aprobación de una orden, una solicitud que requiere atención, etc.).
- **Redirección Inteligente:** Cada notificación será un enlace directo a la entidad correspondiente (la orden, la solicitud, etc.).
- **Gestión por Roles:** El sistema podrá notificar a usuarios específicos o a todos los miembros de un rol (ej: notificar a todos los "admin").
- **Notificaciones Accionables:** Las notificaciones podrán incluir botones para realizar acciones rápidas (ej: "Aprobar", "Marcar como leído") directamente desde el menú, convirtiéndolo en una bandeja de tareas.

---

## 2. Análisis Conceptual (Inspirado en "Novu")

La revisión de los archivos de ejemplo del proyecto "Novu" valida nuestro enfoque y nos da ideas sobre cómo estructurar un sistema robusto a gran escala.

- **Separación de Servicios:** La idea de separar `api`, `worker` (tareas en segundo plano) y `dashboard` es una práctica sólida que, aunque no implementaremos como microservicios separados por ahora, sí mantendremos lógicamente en nuestra arquitectura de carpetas.
- **Capa de Acceso a Datos (DAL):** Nuestro enfoque de tener archivos `db.ts` por módulo se alinea con la idea de una DAL, aislando la lógica de la base de datos.
- **Entidades Clave:** El análisis de la especificación de la API de Novu (`5.txt`) confirma que nuestro modelo de entidades es correcto. Conceptos como `Subscribers` (nuestros `Users`), `Events` (los disparadores) y `Workflows` (nuestros flujos de estado) son el estándar de la industria.
- **Concepto de "Topics":** La idea de Novu de usar "Topics" para agrupar suscriptores es una versión más avanzada de nuestra idea de "notificar a un rol". Lo incorporaremos como una posible mejora futura.
- **Concepto de "Layouts" (Plantillas Maestras):** El análisis de `3.5.txt` revela el uso de "Layouts" reutilizables. Esta es una idea clave que adoptaremos: tendremos una plantilla de correo maestra y el contenido dinámico de cada notificación se inyectará en ella. Esto asegura consistencia y facilita el mantenimiento.
- **Gestión del Ciclo de Vida:** El análisis de `3.6.txt` muestra funcionalidades avanzadas como "posponer" (snooze) y **acciones dentro de la notificación**. Adoptaremos la idea de las acciones para hacer el sistema más interactivo.
- **Robustez y Escalabilidad (Rate Limiting, Idempotencia):** El análisis de `4.txt` revela que "Novu" utiliza sistemas avanzados de `Rate Limiting` e `Idempotencia` para garantizar que su API sea robusta y escalable. Para nuestra aplicación interna en una red LAN, esta complejidad no es necesaria en la primera versión, pero es una excelente referencia de buenas prácticas si alguna vez la aplicación necesita escalar.

**Conclusión:** Seguiremos con nuestro plan adaptado a Next.js y `better-sqlite3`, pero usando los conceptos de Novu como una referencia de arquitectura de alta calidad, incorporando las "notificaciones accionables" desde el inicio.

---

## 3. Plan de Implementación Técnico

### Fase 1: La Base de Datos (El Almacén)

- **Archivo a Modificar:** `src/modules/core/lib/db.ts`
- **Acción:**
  1.  Añadir una nueva tabla `notifications` a la función `initializeMainDatabase`.
  2.  Añadir la creación de esta tabla a la función de migración `checkAndApplyMigrations` para asegurar la compatibilidad con instalaciones existentes.
- **Esquema de la Tabla `notifications`:**
    ```sql
    CREATE TABLE notifications (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        userId INTEGER NOT NULL,
        message TEXT NOT NULL,
        href TEXT,
        isRead INTEGER DEFAULT 0,
        timestamp TEXT NOT NULL,
        entityId INTEGER,      -- ID de la orden, solicitud, etc.
        entityType TEXT,       -- 'production-order', 'purchase-request'
        taskType TEXT,         -- 'approve', 'review', 'cancellation-request'
        FOREIGN KEY (userId) REFERENCES users(id) ON DELETE CASCADE
    );
    ```

### Fase 2: El Backend (La Lógica)

- **Nuevo Archivo:** `src/modules/core/lib/notifications-actions.ts`
- **Acciones a Crear (Funciones Server-Side):**
  - **`createNotification(userId, message, href, entityId, entityType, taskType)`**: Crea una notificación para un usuario específico. El `taskType` definirá qué acciones (botones) mostrar.
  - **`createNotificationForRole(roleId, message, href, ...)`**: Busca todos los usuarios que pertenecen a un rol y les crea una notificación individual. Esta será nuestra implementación inicial de "topics".
  - **`getNotificationsForUser(userId)`**: Obtiene las últimas 50 notificaciones (leídas y no leídas) para un usuario, ordenadas por fecha.
  - **`markNotificationAsRead(notificationId, userId)`**: Marca una notificación específica como leída. Deberá validar que la notificación pertenezca al usuario.
  - **`markAllNotificationsAsRead(userId)`**: Marca todas las notificaciones de un usuario como leídas.
  - **`executeNotificationAction(notificationId, actionType)`**: Una nueva función que ejecutará una acción asociada a un botón (ej: llamar a `updateProductionOrderStatus` con el estado 'approved').

### Fase 3: La Interfaz (Lo que el Usuario Ve)

- **Nuevo Componente:** `src/components/layout/notification-bell.tsx`
  - Usará un `Popover` de ShadCN para mostrar la lista de notificaciones.
  - Mostrará un `Badge` con el contador de notificaciones no leídas.
  - Cada notificación será un `Link` que al hacer clic llamará a `markNotificationAsRead` y navegará al `href`.
  - **(Nuevo)** Si una notificación tiene un `taskType` (ej: 'approve'), mostrará botones de acción. Al hacer clic en un botón, se llamará a `executeNotificationAction`.
- **Modificar `useAuth`:** El hook `useAuth` se encargará de obtener periódicamente (ej. cada 30 segundos) las notificaciones del usuario y el contador de no leídas para que estén disponibles globalmente.
- **Modificar `header.tsx`:** Se añadirá el componente `NotificationBell` a la cabecera.

### Fase 4: La Integración (Los Disparadores)

Aquí es donde el sistema cobra vida.

- **Archivos a Modificar:** Principalmente en los archivos `actions.ts` de los módulos `planner` y `requests`.
- **Lógica de Ejemplo:**
  - En `updateProductionOrderStatus`, si el estado cambia a `approved`, se llamará a `createNotification` para notificar al `requestedBy`.
  - En `updatePendingAction` (planner y requests), si se solicita una cancelación (`cancellation-request`), se llamará a `createNotificationForRole` para notificar a todos los `'admin'` con el `taskType: 'approve-cancellation'`.

### Fase 5 (Futura): Evolución a "Topics"

- Inspirado en Novu, podríamos reemplazar la lógica de `createNotificationForRole` con un sistema más flexible de "Topics" o "Grupos de Notificación".
- Esto permitiría crear grupos personalizados (ej: "Equipo de Ventas Zona Norte") y suscribir usuarios a ellos, sin depender rígidamente de los roles del sistema.

---

## 4. Limitaciones Actuales

- **No habrá notificaciones push** del navegador o del sistema operativo.
- **No habrá notificaciones por correo electrónico en tiempo real** para cada evento, para evitar el spam. El sistema se centrará en las notificaciones *dentro* de la aplicación.
- La primera versión no incluirá la función de "posponer" (snooze).