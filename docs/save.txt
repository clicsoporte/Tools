
======================================================================
Lógica y Código: Guardar la Visibilidad de Columnas
======================================================================

Este documento explica el flujo de datos y el código involucrado cuando un usuario hace clic en el botón "Guardar" para personalizar las columnas visibles en una tabla, usando el "Asistente de Costos" como ejemplo.

El proceso sigue una arquitectura segura de "Cliente -> Acción del Servidor -> Base de Datos".

----------------------------------------------------------------------
Paso 1: El Hook del Cliente (`useCostAssistant.ts`)
----------------------------------------------------------------------

Todo comienza en el hook que maneja el estado de la página del Asistente de Costos.

1.  **Estado:** Se define un estado para mantener la configuración de visibilidad actual.
    ```typescript
    const [state, setState] = useState({
        // ... otros estados
        columnVisibility: initialColumnVisibility,
    });
    ```

2.  **Función de Guardado:** Se crea una función `async` que será llamada por el botón "Guardar" en la interfaz.
    ```typescript
    const handleSaveColumnVisibility = async () => {
        try {
            // Llama a la acción del servidor, pasando el estado actual de la visibilidad.
            await saveCostAssistantSettings({ columnVisibility: state.columnVisibility });
            
            // Muestra una notificación de éxito al usuario.
            toast({ title: "Preferencia Guardada", description: "La visibilidad de las columnas ha sido guardada." });
        } catch (error: any) {
            // En caso de error, lo registra y notifica al usuario.
            logError("Failed to save column visibility", { error: error.message });
            toast({ title: "Error", description: "No se pudo guardar la configuración.", variant: "destructive" });
        }
    };
    ```

----------------------------------------------------------------------
Paso 2: La Acción del Servidor - El Puente (`actions.ts`)
----------------------------------------------------------------------

Para mantener el código del cliente separado de la lógica del servidor, se utiliza un archivo de "acciones" que actúa como un puente. Este archivo importa la función del servidor y la re-exporta para que el cliente pueda llamarla de forma segura.

El archivo `src/modules/cost-assistant/lib/actions.ts` contiene:

```typescript
'use server'; // Directiva que marca estas funciones como ejecutables en el servidor.

import { 
    saveCostAssistantSettings as saveCostAssistantSettingsServer, 
    type CostAssistantSettings 
} from './db';

// Esta es la función que el hook del cliente realmente importa y llama.
export async function saveCostAssistantSettings(settings: CostAssistantSettings): Promise<void> {
    // Simplemente pasa la llamada a la función de base de datos real.
    return saveCostAssistantSettingsServer(settings);
}
```

----------------------------------------------------------------------
Paso 3: La Lógica de la Base de Datos (`db.ts`)
----------------------------------------------------------------------

Este es el archivo final donde ocurre la interacción con la base de datos de Firestore. Solo puede ser ejecutado en el servidor.

El archivo `src/modules/cost-assistant/lib/db.ts` contiene la lógica real:

```typescript
'use server'; // También es una función de servidor.

import { adminDb } from '../../core/lib/firebase/firebase-admin';

// Definición de tipos y colección de Firestore
const firestore = adminDb;
const settingsCollection = firestore ? firestore.collection('settings') : null;

export type CostAssistantSettings = {
    columnVisibility: { /* ...definición de columnas... */ }
};

// La función que finalmente escribe en la base de datos.
export async function saveCostAssistantSettings(settings: CostAssistantSettings): Promise<void> {
    // Si la conexión a la DB no existe, no hace nada.
    if (!settingsCollection) return;
    
    // Apunta al documento 'cost_assistant' dentro de la colección 'settings'
    // y guarda el objeto de configuración. Si el documento no existe, lo crea.
    await settingsCollection.doc('cost_assistant').set(settings);
}
```

### Resumen del Flujo:

1.  **UI (Botón Guardar)** -> `onClick={actions.handleSaveColumnVisibility}`
2.  **`useCostAssistant.ts`** -> `handleSaveColumnVisibility()`
3.  **Llama a la acción** -> `saveCostAssistantSettings(state.columnVisibility)`
4.  **`actions.ts`** -> `saveCostAssistantSettingsServer(settings)`
5.  **`db.ts`** -> `settingsCollection.doc('cost_assistant').set(settings)` -> **Firestore**

Este patrón asegura que la lógica de la base de datos permanezca segura en el servidor, mientras que el cliente tiene una API clara y segura para interactuar con ella.
