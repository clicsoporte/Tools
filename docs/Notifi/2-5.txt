
### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  LayoutControlsDto,
  LayoutControlsDto$inboundSchema,
  LayoutControlsDto$Outbound,
  LayoutControlsDto$outboundSchema,
} from './layoutcontrolsdto.js';
import {
  ResourceOriginEnum,
  ResourceOriginEnum$inboundSchema,
  ResourceOriginEnum$outboundSchema,
} from './resourceoriginenum.js';
import {
  ResourceTypeEnum,
  ResourceTypeEnum$inboundSchema,
  ResourceTypeEnum$outboundSchema,
} from './resourcetypeenum.js';

/**
 * User who last updated the layout
 */
export type UpdatedBy = {
  /**
   * User ID
   */
  id: string;
  /**
   * User first name
   */
  firstName?: string | null | undefined;
  /**
   * User last name
   */
  lastName?: string | null | undefined;
  /**
   * User external ID
   */
  externalId?: string | null | undefined;
};

export type LayoutResponseDto = {
  /**
   * Unique internal identifier of the layout
   */
  id: string;
  /**
   * Unique identifier for the layout
   */
  layoutId: string;
  /**
   * Slug of the layout
   */
  slug: string;
  /**
   * Name of the layout
   */
  name: string;
  /**
   * Whether the layout is the default layout
   */
  isDefault: boolean;
  /**
   * Whether the layout translations are enabled
   */
  isTranslationEnabled: boolean;
  /**
   * Last updated timestamp
   */
  updatedAt: string;
  /**
   * User who last updated the layout
   */
  updatedBy?: UpdatedBy | null | undefined;
  /**
   * Creation timestamp
   */
  createdAt: string;
  /**
   * Origin of the layout
   */
  origin: ResourceOriginEnum;
  /**
   * Type of the layout
   */
  type: ResourceTypeEnum;
  /**
   * The variables JSON Schema for the layout
   */
  variables?: { [k: string]: any } | null | undefined;
  /**
   * Controls metadata for the layout
   */
  controls: LayoutControlsDto;
};

/** @internal */
export const UpdatedBy$inboundSchema: z.ZodType<UpdatedBy, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    externalId: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type UpdatedBy$Outbound = {
  _id: string;
  firstName?: string | null | undefined;
  lastName?: string | null | undefined;
  externalId?: string | null | undefined;
};

/** @internal */
export const UpdatedBy$outboundSchema: z.ZodType<UpdatedBy$Outbound, z.ZodTypeDef, UpdatedBy> = z
  .object({
    id: z.string(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    externalId: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatedBy$ {
  /** @deprecated use `UpdatedBy$inboundSchema` instead. */
  export const inboundSchema = UpdatedBy$inboundSchema;
  /** @deprecated use `UpdatedBy$outboundSchema` instead. */
  export const outboundSchema = UpdatedBy$outboundSchema;
  /** @deprecated use `UpdatedBy$Outbound` instead. */
  export type Outbound = UpdatedBy$Outbound;
}

export function updatedByToJSON(updatedBy: UpdatedBy): string {
  return JSON.stringify(UpdatedBy$outboundSchema.parse(updatedBy));
}

export function updatedByFromJSON(jsonString: string): SafeParseResult<UpdatedBy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatedBy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatedBy' from JSON`
  );
}

/** @internal */
export const LayoutResponseDto$inboundSchema: z.ZodType<LayoutResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string(),
    layoutId: z.string(),
    slug: z.string(),
    name: z.string(),
    isDefault: z.boolean(),
    isTranslationEnabled: z.boolean(),
    updatedAt: z.string(),
    updatedBy: z.nullable(z.lazy(() => UpdatedBy$inboundSchema)).optional(),
    createdAt: z.string(),
    origin: ResourceOriginEnum$inboundSchema,
    type: ResourceTypeEnum$inboundSchema,
    variables: z.nullable(z.record(z.any())).optional(),
    controls: LayoutControlsDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type LayoutResponseDto$Outbound = {
  _id: string;
  layoutId: string;
  slug: string;
  name: string;
  isDefault: boolean;
  isTranslationEnabled: boolean;
  updatedAt: string;
  updatedBy?: UpdatedBy$Outbound | null | undefined;
  createdAt: string;
  origin: string;
  type: string;
  variables?: { [k: string]: any } | null | undefined;
  controls: LayoutControlsDto$Outbound;
};

/** @internal */
export const LayoutResponseDto$outboundSchema: z.ZodType<LayoutResponseDto$Outbound, z.ZodTypeDef, LayoutResponseDto> =
  z
    .object({
      id: z.string(),
      layoutId: z.string(),
      slug: z.string(),
      name: z.string(),
      isDefault: z.boolean(),
      isTranslationEnabled: z.boolean(),
      updatedAt: z.string(),
      updatedBy: z.nullable(z.lazy(() => UpdatedBy$outboundSchema)).optional(),
      createdAt: z.string(),
      origin: ResourceOriginEnum$outboundSchema,
      type: ResourceTypeEnum$outboundSchema,
      variables: z.nullable(z.record(z.any())).optional(),
      controls: LayoutControlsDto$outboundSchema,
    })
    .transform((v) => {
      return remap$(v, {
        id: '_id',
      });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutResponseDto$ {
  /** @deprecated use `LayoutResponseDto$inboundSchema` instead. */
  export const inboundSchema = LayoutResponseDto$inboundSchema;
  /** @deprecated use `LayoutResponseDto$outboundSchema` instead. */
  export const outboundSchema = LayoutResponseDto$outboundSchema;
  /** @deprecated use `LayoutResponseDto$Outbound` instead. */
  export type Outbound = LayoutResponseDto$Outbound;
}

export function layoutResponseDtoToJSON(layoutResponseDto: LayoutResponseDto): string {
  return JSON.stringify(LayoutResponseDto$outboundSchema.parse(layoutResponseDto));
}

export function layoutResponseDtoFromJSON(jsonString: string): SafeParseResult<LayoutResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - updatedByToJSON(updatedBy: UpdatedBy)
 - updatedByFromJSON(jsonString: string)
 - layoutResponseDtoToJSON(layoutResponseDto: LayoutResponseDto)
 - layoutResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(UpdatedBy$Outbound;
}

export function updatedByToJSON(updatedBy: UpdatedBy): string {
  return JSON...)
 - Outbound(LayoutResponseDto$Outbound;
}

export function layoutResponseDtoToJSON(layoutResponseDto: LayoutResp...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function updatedByToJSON
- export function updatedByFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutResponseDtoToJSON
- export function layoutResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/layoutresponsedtosortfield.ts
Tamaño: 1218 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

export const LayoutResponseDtoSortField = {
  CreatedAt: 'createdAt',
  UpdatedAt: 'updatedAt',
  Name: 'name',
} as const;
export type LayoutResponseDtoSortField = ClosedEnum<typeof LayoutResponseDtoSortField>;

/** @internal */
export const LayoutResponseDtoSortField$inboundSchema: z.ZodNativeEnum<typeof LayoutResponseDtoSortField> =
  z.nativeEnum(LayoutResponseDtoSortField);

/** @internal */
export const LayoutResponseDtoSortField$outboundSchema: z.ZodNativeEnum<typeof LayoutResponseDtoSortField> =
  LayoutResponseDtoSortField$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutResponseDtoSortField$ {
  /** @deprecated use `LayoutResponseDtoSortField$inboundSchema` instead. */
  export const inboundSchema = LayoutResponseDtoSortField$inboundSchema;
  /** @deprecated use `LayoutResponseDtoSortField$outboundSchema` instead. */
  export const outboundSchema = LayoutResponseDtoSortField$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/listcontextsresponsedto.ts
Tamaño: 3070 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  GetContextResponseDto,
  GetContextResponseDto$inboundSchema,
  GetContextResponseDto$Outbound,
  GetContextResponseDto$outboundSchema,
} from './getcontextresponsedto.js';

export type ListContextsResponseDto = {
  /**
   * List of returned Contexts
   */
  data: Array<GetContextResponseDto>;
  /**
   * The cursor for the next page of results, or null if there are no more pages.
   */
  next: string | null;
  /**
   * The cursor for the previous page of results, or null if this is the first page.
   */
  previous: string | null;
  /**
   * The total count of items (up to 50,000)
   */
  totalCount: number;
  /**
   * Whether there are more than 50,000 results available
   */
  totalCountCapped: boolean;
};

/** @internal */
export const ListContextsResponseDto$inboundSchema: z.ZodType<ListContextsResponseDto, z.ZodTypeDef, unknown> =
  z.object({
    data: z.array(GetContextResponseDto$inboundSchema),
    next: z.nullable(z.string()),
    previous: z.nullable(z.string()),
    totalCount: z.number(),
    totalCountCapped: z.boolean(),
  });

/** @internal */
export type ListContextsResponseDto$Outbound = {
  data: Array<GetContextResponseDto$Outbound>;
  next: string | null;
  previous: string | null;
  totalCount: number;
  totalCountCapped: boolean;
};

/** @internal */
export const ListContextsResponseDto$outboundSchema: z.ZodType<
  ListContextsResponseDto$Outbound,
  z.ZodTypeDef,
  ListContextsResponseDto
> = z.object({
  data: z.array(GetContextResponseDto$outboundSchema),
  next: z.nullable(z.string()),
  previous: z.nullable(z.string()),
  totalCount: z.number(),
  totalCountCapped: z.boolean(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListContextsResponseDto$ {
  /** @deprecated use `ListContextsResponseDto$inboundSchema` instead. */
  export const inboundSchema = ListContextsResponseDto$inboundSchema;
  /** @deprecated use `ListContextsResponseDto$outboundSchema` instead. */
  export const outboundSchema = ListContextsResponseDto$outboundSchema;
  /** @deprecated use `ListContextsResponseDto$Outbound` instead. */
  export type Outbound = ListContextsResponseDto$Outbound;
}

export function listContextsResponseDtoToJSON(listContextsResponseDto: ListContextsResponseDto): string {
  return JSON.stringify(ListContextsResponseDto$outboundSchema.parse(listContextsResponseDto));
}

export function listContextsResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<ListContextsResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListContextsResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListContextsResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - listContextsResponseDtoToJSON(listContextsResponseDto: ListContextsResponseDto)
 - listContextsResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ListContextsResponseDto$Outbound;
}

export function listContextsResponseDtoToJSON(listContextsRespo...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function listContextsResponseDtoToJSON
- export function listContextsResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/listlayoutresponsedto.ts
Tamaño: 2339 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  LayoutResponseDto,
  LayoutResponseDto$inboundSchema,
  LayoutResponseDto$Outbound,
  LayoutResponseDto$outboundSchema,
} from './layoutresponsedto.js';

export type ListLayoutResponseDto = {
  /**
   * List of layouts
   */
  layouts: Array<LayoutResponseDto>;
  /**
   * Total number of layouts
   */
  totalCount: number;
};

/** @internal */
export const ListLayoutResponseDto$inboundSchema: z.ZodType<ListLayoutResponseDto, z.ZodTypeDef, unknown> = z.object({
  layouts: z.array(LayoutResponseDto$inboundSchema),
  totalCount: z.number(),
});

/** @internal */
export type ListLayoutResponseDto$Outbound = {
  layouts: Array<LayoutResponseDto$Outbound>;
  totalCount: number;
};

/** @internal */
export const ListLayoutResponseDto$outboundSchema: z.ZodType<
  ListLayoutResponseDto$Outbound,
  z.ZodTypeDef,
  ListLayoutResponseDto
> = z.object({
  layouts: z.array(LayoutResponseDto$outboundSchema),
  totalCount: z.number(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListLayoutResponseDto$ {
  /** @deprecated use `ListLayoutResponseDto$inboundSchema` instead. */
  export const inboundSchema = ListLayoutResponseDto$inboundSchema;
  /** @deprecated use `ListLayoutResponseDto$outboundSchema` instead. */
  export const outboundSchema = ListLayoutResponseDto$outboundSchema;
  /** @deprecated use `ListLayoutResponseDto$Outbound` instead. */
  export type Outbound = ListLayoutResponseDto$Outbound;
}

export function listLayoutResponseDtoToJSON(listLayoutResponseDto: ListLayoutResponseDto): string {
  return JSON.stringify(ListLayoutResponseDto$outboundSchema.parse(listLayoutResponseDto));
}

export function listLayoutResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<ListLayoutResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListLayoutResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListLayoutResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - listLayoutResponseDtoToJSON(listLayoutResponseDto: ListLayoutResponseDto)
 - listLayoutResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ListLayoutResponseDto$Outbound;
}

export function listLayoutResponseDtoToJSON(listLayoutResponseDto...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function listLayoutResponseDtoToJSON
- export function listLayoutResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/listsubscribersresponsedto.ts
Tamaño: 3142 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  SubscriberResponseDto,
  SubscriberResponseDto$inboundSchema,
  SubscriberResponseDto$Outbound,
  SubscriberResponseDto$outboundSchema,
} from './subscriberresponsedto.js';

export type ListSubscribersResponseDto = {
  /**
   * List of returned Subscribers
   */
  data: Array<SubscriberResponseDto>;
  /**
   * The cursor for the next page of results, or null if there are no more pages.
   */
  next: string | null;
  /**
   * The cursor for the previous page of results, or null if this is the first page.
   */
  previous: string | null;
  /**
   * The total count of items (up to 50,000)
   */
  totalCount: number;
  /**
   * Whether there are more than 50,000 results available
   */
  totalCountCapped: boolean;
};

/** @internal */
export const ListSubscribersResponseDto$inboundSchema: z.ZodType<ListSubscribersResponseDto, z.ZodTypeDef, unknown> =
  z.object({
    data: z.array(SubscriberResponseDto$inboundSchema),
    next: z.nullable(z.string()),
    previous: z.nullable(z.string()),
    totalCount: z.number(),
    totalCountCapped: z.boolean(),
  });

/** @internal */
export type ListSubscribersResponseDto$Outbound = {
  data: Array<SubscriberResponseDto$Outbound>;
  next: string | null;
  previous: string | null;
  totalCount: number;
  totalCountCapped: boolean;
};

/** @internal */
export const ListSubscribersResponseDto$outboundSchema: z.ZodType<
  ListSubscribersResponseDto$Outbound,
  z.ZodTypeDef,
  ListSubscribersResponseDto
> = z.object({
  data: z.array(SubscriberResponseDto$outboundSchema),
  next: z.nullable(z.string()),
  previous: z.nullable(z.string()),
  totalCount: z.number(),
  totalCountCapped: z.boolean(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListSubscribersResponseDto$ {
  /** @deprecated use `ListSubscribersResponseDto$inboundSchema` instead. */
  export const inboundSchema = ListSubscribersResponseDto$inboundSchema;
  /** @deprecated use `ListSubscribersResponseDto$outboundSchema` instead. */
  export const outboundSchema = ListSubscribersResponseDto$outboundSchema;
  /** @deprecated use `ListSubscribersResponseDto$Outbound` instead. */
  export type Outbound = ListSubscribersResponseDto$Outbound;
}

export function listSubscribersResponseDtoToJSON(listSubscribersResponseDto: ListSubscribersResponseDto): string {
  return JSON.stringify(ListSubscribersResponseDto$outboundSchema.parse(listSubscribersResponseDto));
}

export function listSubscribersResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<ListSubscribersResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListSubscribersResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListSubscribersResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - listSubscribersResponseDtoToJSON(listSubscribersResponseDto: ListSubscribersResponseDto)
 - listSubscribersResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ListSubscribersResponseDto$Outbound;
}

export function listSubscribersResponseDtoToJSON(listSubscri...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function listSubscribersResponseDtoToJSON
- export function listSubscribersResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/listtopicsresponsedto.ts
Tamaño: 2963 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  TopicResponseDto,
  TopicResponseDto$inboundSchema,
  TopicResponseDto$Outbound,
  TopicResponseDto$outboundSchema,
} from './topicresponsedto.js';

export type ListTopicsResponseDto = {
  /**
   * List of returned Topics
   */
  data: Array<TopicResponseDto>;
  /**
   * The cursor for the next page of results, or null if there are no more pages.
   */
  next: string | null;
  /**
   * The cursor for the previous page of results, or null if this is the first page.
   */
  previous: string | null;
  /**
   * The total count of items (up to 50,000)
   */
  totalCount: number;
  /**
   * Whether there are more than 50,000 results available
   */
  totalCountCapped: boolean;
};

/** @internal */
export const ListTopicsResponseDto$inboundSchema: z.ZodType<ListTopicsResponseDto, z.ZodTypeDef, unknown> = z.object({
  data: z.array(TopicResponseDto$inboundSchema),
  next: z.nullable(z.string()),
  previous: z.nullable(z.string()),
  totalCount: z.number(),
  totalCountCapped: z.boolean(),
});

/** @internal */
export type ListTopicsResponseDto$Outbound = {
  data: Array<TopicResponseDto$Outbound>;
  next: string | null;
  previous: string | null;
  totalCount: number;
  totalCountCapped: boolean;
};

/** @internal */
export const ListTopicsResponseDto$outboundSchema: z.ZodType<
  ListTopicsResponseDto$Outbound,
  z.ZodTypeDef,
  ListTopicsResponseDto
> = z.object({
  data: z.array(TopicResponseDto$outboundSchema),
  next: z.nullable(z.string()),
  previous: z.nullable(z.string()),
  totalCount: z.number(),
  totalCountCapped: z.boolean(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListTopicsResponseDto$ {
  /** @deprecated use `ListTopicsResponseDto$inboundSchema` instead. */
  export const inboundSchema = ListTopicsResponseDto$inboundSchema;
  /** @deprecated use `ListTopicsResponseDto$outboundSchema` instead. */
  export const outboundSchema = ListTopicsResponseDto$outboundSchema;
  /** @deprecated use `ListTopicsResponseDto$Outbound` instead. */
  export type Outbound = ListTopicsResponseDto$Outbound;
}

export function listTopicsResponseDtoToJSON(listTopicsResponseDto: ListTopicsResponseDto): string {
  return JSON.stringify(ListTopicsResponseDto$outboundSchema.parse(listTopicsResponseDto));
}

export function listTopicsResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<ListTopicsResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListTopicsResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListTopicsResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - listTopicsResponseDtoToJSON(listTopicsResponseDto: ListTopicsResponseDto)
 - listTopicsResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ListTopicsResponseDto$Outbound;
}

export function listTopicsResponseDtoToJSON(listTopicsResponseDto...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function listTopicsResponseDtoToJSON
- export function listTopicsResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/listtopicsubscriptionsresponsedto.ts
Tamaño: 3372 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  TopicSubscriptionResponseDto,
  TopicSubscriptionResponseDto$inboundSchema,
  TopicSubscriptionResponseDto$Outbound,
  TopicSubscriptionResponseDto$outboundSchema,
} from './topicsubscriptionresponsedto.js';

export type ListTopicSubscriptionsResponseDto = {
  /**
   * List of returned Topic Subscriptions
   */
  data: Array<TopicSubscriptionResponseDto>;
  /**
   * The cursor for the next page of results, or null if there are no more pages.
   */
  next: string | null;
  /**
   * The cursor for the previous page of results, or null if this is the first page.
   */
  previous: string | null;
  /**
   * The total count of items (up to 50,000)
   */
  totalCount: number;
  /**
   * Whether there are more than 50,000 results available
   */
  totalCountCapped: boolean;
};

/** @internal */
export const ListTopicSubscriptionsResponseDto$inboundSchema: z.ZodType<
  ListTopicSubscriptionsResponseDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  data: z.array(TopicSubscriptionResponseDto$inboundSchema),
  next: z.nullable(z.string()),
  previous: z.nullable(z.string()),
  totalCount: z.number(),
  totalCountCapped: z.boolean(),
});

/** @internal */
export type ListTopicSubscriptionsResponseDto$Outbound = {
  data: Array<TopicSubscriptionResponseDto$Outbound>;
  next: string | null;
  previous: string | null;
  totalCount: number;
  totalCountCapped: boolean;
};

/** @internal */
export const ListTopicSubscriptionsResponseDto$outboundSchema: z.ZodType<
  ListTopicSubscriptionsResponseDto$Outbound,
  z.ZodTypeDef,
  ListTopicSubscriptionsResponseDto
> = z.object({
  data: z.array(TopicSubscriptionResponseDto$outboundSchema),
  next: z.nullable(z.string()),
  previous: z.nullable(z.string()),
  totalCount: z.number(),
  totalCountCapped: z.boolean(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListTopicSubscriptionsResponseDto$ {
  /** @deprecated use `ListTopicSubscriptionsResponseDto$inboundSchema` instead. */
  export const inboundSchema = ListTopicSubscriptionsResponseDto$inboundSchema;
  /** @deprecated use `ListTopicSubscriptionsResponseDto$outboundSchema` instead. */
  export const outboundSchema = ListTopicSubscriptionsResponseDto$outboundSchema;
  /** @deprecated use `ListTopicSubscriptionsResponseDto$Outbound` instead. */
  export type Outbound = ListTopicSubscriptionsResponseDto$Outbound;
}

export function listTopicSubscriptionsResponseDtoToJSON(
  listTopicSubscriptionsResponseDto: ListTopicSubscriptionsResponseDto
): string {
  return JSON.stringify(ListTopicSubscriptionsResponseDto$outboundSchema.parse(listTopicSubscriptionsResponseDto));
}

export function listTopicSubscriptionsResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<ListTopicSubscriptionsResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListTopicSubscriptionsResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListTopicSubscriptionsResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - listTopicSubscriptionsResponseDtoToJSON(listTopicSubscriptionsResponseDto: ListTopicSubscriptionsResponseDto)
 - listTopicSubscriptionsResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ListTopicSubscriptionsResponseDto$Outbound;
}

export function listTopicSubscriptionsResponseDtoToJS...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function listTopicSubscriptionsResponseDtoToJSON
- export function listTopicSubscriptionsResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/listworkflowresponse.ts
Tamaño: 2382 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  WorkflowListResponseDto,
  WorkflowListResponseDto$inboundSchema,
  WorkflowListResponseDto$Outbound,
  WorkflowListResponseDto$outboundSchema,
} from './workflowlistresponsedto.js';

export type ListWorkflowResponse = {
  /**
   * List of workflows
   */
  workflows: Array<WorkflowListResponseDto>;
  /**
   * Total number of workflows
   */
  totalCount: number;
};

/** @internal */
export const ListWorkflowResponse$inboundSchema: z.ZodType<ListWorkflowResponse, z.ZodTypeDef, unknown> = z.object({
  workflows: z.array(WorkflowListResponseDto$inboundSchema),
  totalCount: z.number(),
});

/** @internal */
export type ListWorkflowResponse$Outbound = {
  workflows: Array<WorkflowListResponseDto$Outbound>;
  totalCount: number;
};

/** @internal */
export const ListWorkflowResponse$outboundSchema: z.ZodType<
  ListWorkflowResponse$Outbound,
  z.ZodTypeDef,
  ListWorkflowResponse
> = z.object({
  workflows: z.array(WorkflowListResponseDto$outboundSchema),
  totalCount: z.number(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ListWorkflowResponse$ {
  /** @deprecated use `ListWorkflowResponse$inboundSchema` instead. */
  export const inboundSchema = ListWorkflowResponse$inboundSchema;
  /** @deprecated use `ListWorkflowResponse$outboundSchema` instead. */
  export const outboundSchema = ListWorkflowResponse$outboundSchema;
  /** @deprecated use `ListWorkflowResponse$Outbound` instead. */
  export type Outbound = ListWorkflowResponse$Outbound;
}

export function listWorkflowResponseToJSON(listWorkflowResponse: ListWorkflowResponse): string {
  return JSON.stringify(ListWorkflowResponse$outboundSchema.parse(listWorkflowResponse));
}

export function listWorkflowResponseFromJSON(
  jsonString: string
): SafeParseResult<ListWorkflowResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListWorkflowResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListWorkflowResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - listWorkflowResponseToJSON(listWorkflowResponse: ListWorkflowResponse)
 - listWorkflowResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ListWorkflowResponse$Outbound;
}

export function listWorkflowResponseToJSON(listWorkflowResponse: L...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function listWorkflowResponseToJSON
- export function listWorkflowResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/lookbackwindowdto.ts
Tamaño: 3241 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Unit of time for the look-back window.
 */
export const LookBackWindowDtoUnit = {
  Seconds: 'seconds',
  Minutes: 'minutes',
  Hours: 'hours',
  Days: 'days',
  Weeks: 'weeks',
  Months: 'months',
} as const;
/**
 * Unit of time for the look-back window.
 */
export type LookBackWindowDtoUnit = ClosedEnum<typeof LookBackWindowDtoUnit>;

export type LookBackWindowDto = {
  /**
   * Amount of time for the look-back window.
   */
  amount: number;
  /**
   * Unit of time for the look-back window.
   */
  unit: LookBackWindowDtoUnit;
};

/** @internal */
export const LookBackWindowDtoUnit$inboundSchema: z.ZodNativeEnum<typeof LookBackWindowDtoUnit> =
  z.nativeEnum(LookBackWindowDtoUnit);

/** @internal */
export const LookBackWindowDtoUnit$outboundSchema: z.ZodNativeEnum<typeof LookBackWindowDtoUnit> =
  LookBackWindowDtoUnit$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LookBackWindowDtoUnit$ {
  /** @deprecated use `LookBackWindowDtoUnit$inboundSchema` instead. */
  export const inboundSchema = LookBackWindowDtoUnit$inboundSchema;
  /** @deprecated use `LookBackWindowDtoUnit$outboundSchema` instead. */
  export const outboundSchema = LookBackWindowDtoUnit$outboundSchema;
}

/** @internal */
export const LookBackWindowDto$inboundSchema: z.ZodType<LookBackWindowDto, z.ZodTypeDef, unknown> = z.object({
  amount: z.number(),
  unit: LookBackWindowDtoUnit$inboundSchema,
});

/** @internal */
export type LookBackWindowDto$Outbound = {
  amount: number;
  unit: string;
};

/** @internal */
export const LookBackWindowDto$outboundSchema: z.ZodType<LookBackWindowDto$Outbound, z.ZodTypeDef, LookBackWindowDto> =
  z.object({
    amount: z.number(),
    unit: LookBackWindowDtoUnit$outboundSchema,
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LookBackWindowDto$ {
  /** @deprecated use `LookBackWindowDto$inboundSchema` instead. */
  export const inboundSchema = LookBackWindowDto$inboundSchema;
  /** @deprecated use `LookBackWindowDto$outboundSchema` instead. */
  export const outboundSchema = LookBackWindowDto$outboundSchema;
  /** @deprecated use `LookBackWindowDto$Outbound` instead. */
  export type Outbound = LookBackWindowDto$Outbound;
}

export function lookBackWindowDtoToJSON(lookBackWindowDto: LookBackWindowDto): string {
  return JSON.stringify(LookBackWindowDto$outboundSchema.parse(lookBackWindowDto));
}

export function lookBackWindowDtoFromJSON(jsonString: string): SafeParseResult<LookBackWindowDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LookBackWindowDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LookBackWindowDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - lookBackWindowDtoToJSON(lookBackWindowDto: LookBackWindowDto)
 - lookBackWindowDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(LookBackWindowDto$Outbound;
}

export function lookBackWindowDtoToJSON(lookBackWindowDto: LookBackWi...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function lookBackWindowDtoToJSON
- export function lookBackWindowDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/markallmessageasrequestdto.ts
Tamaño: 4948 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Optional feed identifier or array of feed identifiers
 */
export type FeedIdentifier = string | Array<string>;

/**
 * Mark all subscriber messages as read, unread, seen or unseen
 */
export const MarkAs = {
  Read: 'read',
  Seen: 'seen',
  Unread: 'unread',
  Unseen: 'unseen',
} as const;
/**
 * Mark all subscriber messages as read, unread, seen or unseen
 */
export type MarkAs = ClosedEnum<typeof MarkAs>;

export type MarkAllMessageAsRequestDto = {
  /**
   * Optional feed identifier or array of feed identifiers
   */
  feedIdentifier?: string | Array<string> | undefined;
  /**
   * Mark all subscriber messages as read, unread, seen or unseen
   */
  markAs: MarkAs;
};

/** @internal */
export const FeedIdentifier$inboundSchema: z.ZodType<FeedIdentifier, z.ZodTypeDef, unknown> = z.union([
  z.string(),
  z.array(z.string()),
]);

/** @internal */
export type FeedIdentifier$Outbound = string | Array<string>;

/** @internal */
export const FeedIdentifier$outboundSchema: z.ZodType<FeedIdentifier$Outbound, z.ZodTypeDef, FeedIdentifier> = z.union([
  z.string(),
  z.array(z.string()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FeedIdentifier$ {
  /** @deprecated use `FeedIdentifier$inboundSchema` instead. */
  export const inboundSchema = FeedIdentifier$inboundSchema;
  /** @deprecated use `FeedIdentifier$outboundSchema` instead. */
  export const outboundSchema = FeedIdentifier$outboundSchema;
  /** @deprecated use `FeedIdentifier$Outbound` instead. */
  export type Outbound = FeedIdentifier$Outbound;
}

export function feedIdentifierToJSON(feedIdentifier: FeedIdentifier): string {
  return JSON.stringify(FeedIdentifier$outboundSchema.parse(feedIdentifier));
}

export function feedIdentifierFromJSON(jsonString: string): SafeParseResult<FeedIdentifier, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FeedIdentifier$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FeedIdentifier' from JSON`
  );
}

/** @internal */
export const MarkAs$inboundSchema: z.ZodNativeEnum<typeof MarkAs> = z.nativeEnum(MarkAs);

/** @internal */
export const MarkAs$outboundSchema: z.ZodNativeEnum<typeof MarkAs> = MarkAs$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MarkAs$ {
  /** @deprecated use `MarkAs$inboundSchema` instead. */
  export const inboundSchema = MarkAs$inboundSchema;
  /** @deprecated use `MarkAs$outboundSchema` instead. */
  export const outboundSchema = MarkAs$outboundSchema;
}

/** @internal */
export const MarkAllMessageAsRequestDto$inboundSchema: z.ZodType<MarkAllMessageAsRequestDto, z.ZodTypeDef, unknown> =
  z.object({
    feedIdentifier: z.union([z.string(), z.array(z.string())]).optional(),
    markAs: MarkAs$inboundSchema,
  });

/** @internal */
export type MarkAllMessageAsRequestDto$Outbound = {
  feedIdentifier?: string | Array<string> | undefined;
  markAs: string;
};

/** @internal */
export const MarkAllMessageAsRequestDto$outboundSchema: z.ZodType<
  MarkAllMessageAsRequestDto$Outbound,
  z.ZodTypeDef,
  MarkAllMessageAsRequestDto
> = z.object({
  feedIdentifier: z.union([z.string(), z.array(z.string())]).optional(),
  markAs: MarkAs$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MarkAllMessageAsRequestDto$ {
  /** @deprecated use `MarkAllMessageAsRequestDto$inboundSchema` instead. */
  export const inboundSchema = MarkAllMessageAsRequestDto$inboundSchema;
  /** @deprecated use `MarkAllMessageAsRequestDto$outboundSchema` instead. */
  export const outboundSchema = MarkAllMessageAsRequestDto$outboundSchema;
  /** @deprecated use `MarkAllMessageAsRequestDto$Outbound` instead. */
  export type Outbound = MarkAllMessageAsRequestDto$Outbound;
}

export function markAllMessageAsRequestDtoToJSON(markAllMessageAsRequestDto: MarkAllMessageAsRequestDto): string {
  return JSON.stringify(MarkAllMessageAsRequestDto$outboundSchema.parse(markAllMessageAsRequestDto));
}

export function markAllMessageAsRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<MarkAllMessageAsRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MarkAllMessageAsRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MarkAllMessageAsRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - feedIdentifierToJSON(feedIdentifier: FeedIdentifier)
 - feedIdentifierFromJSON(jsonString: string)
 - markAllMessageAsRequestDtoToJSON(markAllMessageAsRequestDto: MarkAllMessageAsRequestDto)
 - markAllMessageAsRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(FeedIdentifier$Outbound;
}

export function feedIdentifierToJSON(feedIdentifier: FeedIdentifier): st...)
 - Outbound(MarkAllMessageAsRequestDto$Outbound;
}

export function markAllMessageAsRequestDtoToJSON(markAllMess...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function feedIdentifierToJSON
- export function feedIdentifierFromJSON
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function markAllMessageAsRequestDtoToJSON
- export function markAllMessageAsRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/markmessageactionasseendto.ts
Tamaño: 5570 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Message action status
 */
export const MarkMessageActionAsSeenDtoStatus = {
  Pending: 'pending',
  Done: 'done',
} as const;
/**
 * Message action status
 */
export type MarkMessageActionAsSeenDtoStatus = ClosedEnum<typeof MarkMessageActionAsSeenDtoStatus>;

/**
 * Message action payload
 */
export type MarkMessageActionAsSeenDtoPayload = {};

export type MarkMessageActionAsSeenDto = {
  /**
   * Message action status
   */
  status: MarkMessageActionAsSeenDtoStatus;
  /**
   * Message action payload
   */
  payload?: MarkMessageActionAsSeenDtoPayload | undefined;
};

/** @internal */
export const MarkMessageActionAsSeenDtoStatus$inboundSchema: z.ZodNativeEnum<typeof MarkMessageActionAsSeenDtoStatus> =
  z.nativeEnum(MarkMessageActionAsSeenDtoStatus);

/** @internal */
export const MarkMessageActionAsSeenDtoStatus$outboundSchema: z.ZodNativeEnum<typeof MarkMessageActionAsSeenDtoStatus> =
  MarkMessageActionAsSeenDtoStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MarkMessageActionAsSeenDtoStatus$ {
  /** @deprecated use `MarkMessageActionAsSeenDtoStatus$inboundSchema` instead. */
  export const inboundSchema = MarkMessageActionAsSeenDtoStatus$inboundSchema;
  /** @deprecated use `MarkMessageActionAsSeenDtoStatus$outboundSchema` instead. */
  export const outboundSchema = MarkMessageActionAsSeenDtoStatus$outboundSchema;
}

/** @internal */
export const MarkMessageActionAsSeenDtoPayload$inboundSchema: z.ZodType<
  MarkMessageActionAsSeenDtoPayload,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type MarkMessageActionAsSeenDtoPayload$Outbound = {};

/** @internal */
export const MarkMessageActionAsSeenDtoPayload$outboundSchema: z.ZodType<
  MarkMessageActionAsSeenDtoPayload$Outbound,
  z.ZodTypeDef,
  MarkMessageActionAsSeenDtoPayload
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MarkMessageActionAsSeenDtoPayload$ {
  /** @deprecated use `MarkMessageActionAsSeenDtoPayload$inboundSchema` instead. */
  export const inboundSchema = MarkMessageActionAsSeenDtoPayload$inboundSchema;
  /** @deprecated use `MarkMessageActionAsSeenDtoPayload$outboundSchema` instead. */
  export const outboundSchema = MarkMessageActionAsSeenDtoPayload$outboundSchema;
  /** @deprecated use `MarkMessageActionAsSeenDtoPayload$Outbound` instead. */
  export type Outbound = MarkMessageActionAsSeenDtoPayload$Outbound;
}

export function markMessageActionAsSeenDtoPayloadToJSON(
  markMessageActionAsSeenDtoPayload: MarkMessageActionAsSeenDtoPayload
): string {
  return JSON.stringify(MarkMessageActionAsSeenDtoPayload$outboundSchema.parse(markMessageActionAsSeenDtoPayload));
}

export function markMessageActionAsSeenDtoPayloadFromJSON(
  jsonString: string
): SafeParseResult<MarkMessageActionAsSeenDtoPayload, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MarkMessageActionAsSeenDtoPayload$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MarkMessageActionAsSeenDtoPayload' from JSON`
  );
}

/** @internal */
export const MarkMessageActionAsSeenDto$inboundSchema: z.ZodType<MarkMessageActionAsSeenDto, z.ZodTypeDef, unknown> =
  z.object({
    status: MarkMessageActionAsSeenDtoStatus$inboundSchema,
    payload: z.lazy(() => MarkMessageActionAsSeenDtoPayload$inboundSchema).optional(),
  });

/** @internal */
export type MarkMessageActionAsSeenDto$Outbound = {
  status: string;
  payload?: MarkMessageActionAsSeenDtoPayload$Outbound | undefined;
};

/** @internal */
export const MarkMessageActionAsSeenDto$outboundSchema: z.ZodType<
  MarkMessageActionAsSeenDto$Outbound,
  z.ZodTypeDef,
  MarkMessageActionAsSeenDto
> = z.object({
  status: MarkMessageActionAsSeenDtoStatus$outboundSchema,
  payload: z.lazy(() => MarkMessageActionAsSeenDtoPayload$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MarkMessageActionAsSeenDto$ {
  /** @deprecated use `MarkMessageActionAsSeenDto$inboundSchema` instead. */
  export const inboundSchema = MarkMessageActionAsSeenDto$inboundSchema;
  /** @deprecated use `MarkMessageActionAsSeenDto$outboundSchema` instead. */
  export const outboundSchema = MarkMessageActionAsSeenDto$outboundSchema;
  /** @deprecated use `MarkMessageActionAsSeenDto$Outbound` instead. */
  export type Outbound = MarkMessageActionAsSeenDto$Outbound;
}

export function markMessageActionAsSeenDtoToJSON(markMessageActionAsSeenDto: MarkMessageActionAsSeenDto): string {
  return JSON.stringify(MarkMessageActionAsSeenDto$outboundSchema.parse(markMessageActionAsSeenDto));
}

export function markMessageActionAsSeenDtoFromJSON(
  jsonString: string
): SafeParseResult<MarkMessageActionAsSeenDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MarkMessageActionAsSeenDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MarkMessageActionAsSeenDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - markMessageActionAsSeenDtoPayloadToJSON(markMessageActionAsSeenDtoPayload: MarkMessageActionAsSeenDtoPayload)
 - markMessageActionAsSeenDtoPayloadFromJSON(jsonString: string)
 - markMessageActionAsSeenDtoToJSON(markMessageActionAsSeenDto: MarkMessageActionAsSeenDto)
 - markMessageActionAsSeenDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MarkMessageActionAsSeenDtoPayload$Outbound;
}

export function markMessageActionAsSeenDtoPayloadToJS...)
 - Outbound(MarkMessageActionAsSeenDto$Outbound;
}

export function markMessageActionAsSeenDtoToJSON(markMessage...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function markMessageActionAsSeenDtoPayloadToJSON
- export function markMessageActionAsSeenDtoPayloadFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function markMessageActionAsSeenDtoToJSON
- export function markMessageActionAsSeenDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/messageaction.ts
Tamaño: 2887 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  MessageActionResult,
  MessageActionResult$inboundSchema,
  MessageActionResult$Outbound,
  MessageActionResult$outboundSchema,
} from './messageactionresult.js';
import {
  MessageActionStatusEnum,
  MessageActionStatusEnum$inboundSchema,
  MessageActionStatusEnum$outboundSchema,
} from './messageactionstatusenum.js';
import {
  MessageButton,
  MessageButton$inboundSchema,
  MessageButton$Outbound,
  MessageButton$outboundSchema,
} from './messagebutton.js';

export type MessageAction = {
  /**
   * Status of the message action
   */
  status?: MessageActionStatusEnum | undefined;
  /**
   * List of buttons associated with the message action
   */
  buttons?: Array<MessageButton> | undefined;
  /**
   * Result of the message action
   */
  result?: MessageActionResult | undefined;
};

/** @internal */
export const MessageAction$inboundSchema: z.ZodType<MessageAction, z.ZodTypeDef, unknown> = z.object({
  status: MessageActionStatusEnum$inboundSchema.optional(),
  buttons: z.array(MessageButton$inboundSchema).optional(),
  result: MessageActionResult$inboundSchema.optional(),
});

/** @internal */
export type MessageAction$Outbound = {
  status?: string | undefined;
  buttons?: Array<MessageButton$Outbound> | undefined;
  result?: MessageActionResult$Outbound | undefined;
};

/** @internal */
export const MessageAction$outboundSchema: z.ZodType<MessageAction$Outbound, z.ZodTypeDef, MessageAction> = z.object({
  status: MessageActionStatusEnum$outboundSchema.optional(),
  buttons: z.array(MessageButton$outboundSchema).optional(),
  result: MessageActionResult$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageAction$ {
  /** @deprecated use `MessageAction$inboundSchema` instead. */
  export const inboundSchema = MessageAction$inboundSchema;
  /** @deprecated use `MessageAction$outboundSchema` instead. */
  export const outboundSchema = MessageAction$outboundSchema;
  /** @deprecated use `MessageAction$Outbound` instead. */
  export type Outbound = MessageAction$Outbound;
}

export function messageActionToJSON(messageAction: MessageAction): string {
  return JSON.stringify(MessageAction$outboundSchema.parse(messageAction));
}

export function messageActionFromJSON(jsonString: string): SafeParseResult<MessageAction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageAction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageAction' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messageActionToJSON(messageAction: MessageAction)
 - messageActionFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MessageAction$Outbound;
}

export function messageActionToJSON(messageAction: MessageAction): string...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messageActionToJSON
- export function messageActionFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/messageactionresult.ts
Tamaño: 4098 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import { ButtonTypeEnum, ButtonTypeEnum$inboundSchema, ButtonTypeEnum$outboundSchema } from './buttontypeenum.js';

/**
 * Payload of the action result
 */
export type MessageActionResultPayload = {};

export type MessageActionResult = {
  /**
   * Payload of the action result
   */
  payload?: MessageActionResultPayload | undefined;
  /**
   * Type of button for the action result
   */
  type?: ButtonTypeEnum | undefined;
};

/** @internal */
export const MessageActionResultPayload$inboundSchema: z.ZodType<MessageActionResultPayload, z.ZodTypeDef, unknown> =
  z.object({});

/** @internal */
export type MessageActionResultPayload$Outbound = {};

/** @internal */
export const MessageActionResultPayload$outboundSchema: z.ZodType<
  MessageActionResultPayload$Outbound,
  z.ZodTypeDef,
  MessageActionResultPayload
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageActionResultPayload$ {
  /** @deprecated use `MessageActionResultPayload$inboundSchema` instead. */
  export const inboundSchema = MessageActionResultPayload$inboundSchema;
  /** @deprecated use `MessageActionResultPayload$outboundSchema` instead. */
  export const outboundSchema = MessageActionResultPayload$outboundSchema;
  /** @deprecated use `MessageActionResultPayload$Outbound` instead. */
  export type Outbound = MessageActionResultPayload$Outbound;
}

export function messageActionResultPayloadToJSON(messageActionResultPayload: MessageActionResultPayload): string {
  return JSON.stringify(MessageActionResultPayload$outboundSchema.parse(messageActionResultPayload));
}

export function messageActionResultPayloadFromJSON(
  jsonString: string
): SafeParseResult<MessageActionResultPayload, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageActionResultPayload$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageActionResultPayload' from JSON`
  );
}

/** @internal */
export const MessageActionResult$inboundSchema: z.ZodType<MessageActionResult, z.ZodTypeDef, unknown> = z.object({
  payload: z.lazy(() => MessageActionResultPayload$inboundSchema).optional(),
  type: ButtonTypeEnum$inboundSchema.optional(),
});

/** @internal */
export type MessageActionResult$Outbound = {
  payload?: MessageActionResultPayload$Outbound | undefined;
  type?: string | undefined;
};

/** @internal */
export const MessageActionResult$outboundSchema: z.ZodType<
  MessageActionResult$Outbound,
  z.ZodTypeDef,
  MessageActionResult
> = z.object({
  payload: z.lazy(() => MessageActionResultPayload$outboundSchema).optional(),
  type: ButtonTypeEnum$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageActionResult$ {
  /** @deprecated use `MessageActionResult$inboundSchema` instead. */
  export const inboundSchema = MessageActionResult$inboundSchema;
  /** @deprecated use `MessageActionResult$outboundSchema` instead. */
  export const outboundSchema = MessageActionResult$outboundSchema;
  /** @deprecated use `MessageActionResult$Outbound` instead. */
  export type Outbound = MessageActionResult$Outbound;
}

export function messageActionResultToJSON(messageActionResult: MessageActionResult): string {
  return JSON.stringify(MessageActionResult$outboundSchema.parse(messageActionResult));
}

export function messageActionResultFromJSON(
  jsonString: string
): SafeParseResult<MessageActionResult, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageActionResult$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageActionResult' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messageActionResultPayloadToJSON(messageActionResultPayload: MessageActionResultPayload)
 - messageActionResultPayloadFromJSON(jsonString: string)
 - messageActionResultToJSON(messageActionResult: MessageActionResult)
 - messageActionResultFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MessageActionResultPayload$Outbound;
}

export function messageActionResultPayloadToJSON(messageActi...)
 - Outbound(MessageActionResult$Outbound;
}

export function messageActionResultToJSON(messageActionResult: Mess...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messageActionResultPayloadToJSON
- export function messageActionResultPayloadFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messageActionResultToJSON
- export function messageActionResultFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/messageactionstatusenum.ts
Tamaño: 1226 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Status of the message action
 */
export const MessageActionStatusEnum = {
  Pending: 'pending',
  Done: 'done',
} as const;
/**
 * Status of the message action
 */
export type MessageActionStatusEnum = ClosedEnum<typeof MessageActionStatusEnum>;

/** @internal */
export const MessageActionStatusEnum$inboundSchema: z.ZodNativeEnum<typeof MessageActionStatusEnum> =
  z.nativeEnum(MessageActionStatusEnum);

/** @internal */
export const MessageActionStatusEnum$outboundSchema: z.ZodNativeEnum<typeof MessageActionStatusEnum> =
  MessageActionStatusEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageActionStatusEnum$ {
  /** @deprecated use `MessageActionStatusEnum$inboundSchema` instead. */
  export const inboundSchema = MessageActionStatusEnum$inboundSchema;
  /** @deprecated use `MessageActionStatusEnum$outboundSchema` instead. */
  export const outboundSchema = MessageActionStatusEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/messagebutton.ts
Tamaño: 2250 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import { ButtonTypeEnum, ButtonTypeEnum$inboundSchema, ButtonTypeEnum$outboundSchema } from './buttontypeenum.js';

export type MessageButton = {
  /**
   * Type of button for the action result
   */
  type: ButtonTypeEnum;
  /**
   * Content of the button
   */
  content: string;
  /**
   * Content of the result when the button is clicked
   */
  resultContent?: string | undefined;
};

/** @internal */
export const MessageButton$inboundSchema: z.ZodType<MessageButton, z.ZodTypeDef, unknown> = z.object({
  type: ButtonTypeEnum$inboundSchema,
  content: z.string(),
  resultContent: z.string().optional(),
});

/** @internal */
export type MessageButton$Outbound = {
  type: string;
  content: string;
  resultContent?: string | undefined;
};

/** @internal */
export const MessageButton$outboundSchema: z.ZodType<MessageButton$Outbound, z.ZodTypeDef, MessageButton> = z.object({
  type: ButtonTypeEnum$outboundSchema,
  content: z.string(),
  resultContent: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageButton$ {
  /** @deprecated use `MessageButton$inboundSchema` instead. */
  export const inboundSchema = MessageButton$inboundSchema;
  /** @deprecated use `MessageButton$outboundSchema` instead. */
  export const outboundSchema = MessageButton$outboundSchema;
  /** @deprecated use `MessageButton$Outbound` instead. */
  export type Outbound = MessageButton$Outbound;
}

export function messageButtonToJSON(messageButton: MessageButton): string {
  return JSON.stringify(MessageButton$outboundSchema.parse(messageButton));
}

export function messageButtonFromJSON(jsonString: string): SafeParseResult<MessageButton, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageButton$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageButton' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messageButtonToJSON(messageButton: MessageButton)
 - messageButtonFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MessageButton$Outbound;
}

export function messageButtonToJSON(messageButton: MessageButton): string...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messageButtonToJSON
- export function messageButtonFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/messagecta.ts
Tamaño: 2682 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ChannelCTATypeEnum,
  ChannelCTATypeEnum$inboundSchema,
  ChannelCTATypeEnum$outboundSchema,
} from './channelctatypeenum.js';
import {
  MessageAction,
  MessageAction$inboundSchema,
  MessageAction$Outbound,
  MessageAction$outboundSchema,
} from './messageaction.js';
import {
  MessageCTAData,
  MessageCTAData$inboundSchema,
  MessageCTAData$Outbound,
  MessageCTAData$outboundSchema,
} from './messagectadata.js';

export type MessageCTA = {
  /**
   * Type of call to action
   */
  type?: ChannelCTATypeEnum | undefined;
  /**
   * Data associated with the call to action
   */
  data?: MessageCTAData | undefined;
  /**
   * Action associated with the call to action
   */
  action?: MessageAction | undefined;
};

/** @internal */
export const MessageCTA$inboundSchema: z.ZodType<MessageCTA, z.ZodTypeDef, unknown> = z.object({
  type: ChannelCTATypeEnum$inboundSchema.optional(),
  data: MessageCTAData$inboundSchema.optional(),
  action: MessageAction$inboundSchema.optional(),
});

/** @internal */
export type MessageCTA$Outbound = {
  type?: string | undefined;
  data?: MessageCTAData$Outbound | undefined;
  action?: MessageAction$Outbound | undefined;
};

/** @internal */
export const MessageCTA$outboundSchema: z.ZodType<MessageCTA$Outbound, z.ZodTypeDef, MessageCTA> = z.object({
  type: ChannelCTATypeEnum$outboundSchema.optional(),
  data: MessageCTAData$outboundSchema.optional(),
  action: MessageAction$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageCTA$ {
  /** @deprecated use `MessageCTA$inboundSchema` instead. */
  export const inboundSchema = MessageCTA$inboundSchema;
  /** @deprecated use `MessageCTA$outboundSchema` instead. */
  export const outboundSchema = MessageCTA$outboundSchema;
  /** @deprecated use `MessageCTA$Outbound` instead. */
  export type Outbound = MessageCTA$Outbound;
}

export function messageCTAToJSON(messageCTA: MessageCTA): string {
  return JSON.stringify(MessageCTA$outboundSchema.parse(messageCTA));
}

export function messageCTAFromJSON(jsonString: string): SafeParseResult<MessageCTA, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageCTA$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageCTA' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messageCTAToJSON(messageCTA: MessageCTA)
 - messageCTAFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MessageCTA$Outbound;
}

export function messageCTAToJSON(messageCTA: MessageCTA): string {
  return ...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messageCTAToJSON
- export function messageCTAFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/messagectadata.ts
Tamaño: 1810 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type MessageCTAData = {
  /**
   * URL for the call to action
   */
  url?: string | undefined;
};

/** @internal */
export const MessageCTAData$inboundSchema: z.ZodType<MessageCTAData, z.ZodTypeDef, unknown> = z.object({
  url: z.string().optional(),
});

/** @internal */
export type MessageCTAData$Outbound = {
  url?: string | undefined;
};

/** @internal */
export const MessageCTAData$outboundSchema: z.ZodType<MessageCTAData$Outbound, z.ZodTypeDef, MessageCTAData> = z.object(
  {
    url: z.string().optional(),
  }
);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageCTAData$ {
  /** @deprecated use `MessageCTAData$inboundSchema` instead. */
  export const inboundSchema = MessageCTAData$inboundSchema;
  /** @deprecated use `MessageCTAData$outboundSchema` instead. */
  export const outboundSchema = MessageCTAData$outboundSchema;
  /** @deprecated use `MessageCTAData$Outbound` instead. */
  export type Outbound = MessageCTAData$Outbound;
}

export function messageCTADataToJSON(messageCTAData: MessageCTAData): string {
  return JSON.stringify(MessageCTAData$outboundSchema.parse(messageCTAData));
}

export function messageCTADataFromJSON(jsonString: string): SafeParseResult<MessageCTAData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageCTAData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageCTAData' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messageCTADataToJSON(messageCTAData: MessageCTAData)
 - messageCTADataFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MessageCTAData$Outbound;
}

export function messageCTADataToJSON(messageCTAData: MessageCTAData): st...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messageCTADataToJSON
- export function messageCTADataFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/messagemarkasrequestdto.ts
Tamaño: 4733 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type MessageId = string | Array<string>;

export const MessageMarkAsRequestDtoMarkAs = {
  Read: 'read',
  Seen: 'seen',
  Unread: 'unread',
  Unseen: 'unseen',
} as const;
export type MessageMarkAsRequestDtoMarkAs = ClosedEnum<typeof MessageMarkAsRequestDtoMarkAs>;

export type MessageMarkAsRequestDto = {
  messageId: string | Array<string>;
  markAs: MessageMarkAsRequestDtoMarkAs;
};

/** @internal */
export const MessageId$inboundSchema: z.ZodType<MessageId, z.ZodTypeDef, unknown> = z.union([
  z.string(),
  z.array(z.string()),
]);

/** @internal */
export type MessageId$Outbound = string | Array<string>;

/** @internal */
export const MessageId$outboundSchema: z.ZodType<MessageId$Outbound, z.ZodTypeDef, MessageId> = z.union([
  z.string(),
  z.array(z.string()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageId$ {
  /** @deprecated use `MessageId$inboundSchema` instead. */
  export const inboundSchema = MessageId$inboundSchema;
  /** @deprecated use `MessageId$outboundSchema` instead. */
  export const outboundSchema = MessageId$outboundSchema;
  /** @deprecated use `MessageId$Outbound` instead. */
  export type Outbound = MessageId$Outbound;
}

export function messageIdToJSON(messageId: MessageId): string {
  return JSON.stringify(MessageId$outboundSchema.parse(messageId));
}

export function messageIdFromJSON(jsonString: string): SafeParseResult<MessageId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageId' from JSON`
  );
}

/** @internal */
export const MessageMarkAsRequestDtoMarkAs$inboundSchema: z.ZodNativeEnum<typeof MessageMarkAsRequestDtoMarkAs> =
  z.nativeEnum(MessageMarkAsRequestDtoMarkAs);

/** @internal */
export const MessageMarkAsRequestDtoMarkAs$outboundSchema: z.ZodNativeEnum<typeof MessageMarkAsRequestDtoMarkAs> =
  MessageMarkAsRequestDtoMarkAs$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageMarkAsRequestDtoMarkAs$ {
  /** @deprecated use `MessageMarkAsRequestDtoMarkAs$inboundSchema` instead. */
  export const inboundSchema = MessageMarkAsRequestDtoMarkAs$inboundSchema;
  /** @deprecated use `MessageMarkAsRequestDtoMarkAs$outboundSchema` instead. */
  export const outboundSchema = MessageMarkAsRequestDtoMarkAs$outboundSchema;
}

/** @internal */
export const MessageMarkAsRequestDto$inboundSchema: z.ZodType<MessageMarkAsRequestDto, z.ZodTypeDef, unknown> =
  z.object({
    messageId: z.union([z.string(), z.array(z.string())]),
    markAs: MessageMarkAsRequestDtoMarkAs$inboundSchema,
  });

/** @internal */
export type MessageMarkAsRequestDto$Outbound = {
  messageId: string | Array<string>;
  markAs: string;
};

/** @internal */
export const MessageMarkAsRequestDto$outboundSchema: z.ZodType<
  MessageMarkAsRequestDto$Outbound,
  z.ZodTypeDef,
  MessageMarkAsRequestDto
> = z.object({
  messageId: z.union([z.string(), z.array(z.string())]),
  markAs: MessageMarkAsRequestDtoMarkAs$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageMarkAsRequestDto$ {
  /** @deprecated use `MessageMarkAsRequestDto$inboundSchema` instead. */
  export const inboundSchema = MessageMarkAsRequestDto$inboundSchema;
  /** @deprecated use `MessageMarkAsRequestDto$outboundSchema` instead. */
  export const outboundSchema = MessageMarkAsRequestDto$outboundSchema;
  /** @deprecated use `MessageMarkAsRequestDto$Outbound` instead. */
  export type Outbound = MessageMarkAsRequestDto$Outbound;
}

export function messageMarkAsRequestDtoToJSON(messageMarkAsRequestDto: MessageMarkAsRequestDto): string {
  return JSON.stringify(MessageMarkAsRequestDto$outboundSchema.parse(messageMarkAsRequestDto));
}

export function messageMarkAsRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<MessageMarkAsRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageMarkAsRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageMarkAsRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messageIdToJSON(messageId: MessageId)
 - messageIdFromJSON(jsonString: string)
 - messageMarkAsRequestDtoToJSON(messageMarkAsRequestDto: MessageMarkAsRequestDto)
 - messageMarkAsRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MessageId$Outbound;
}

export function messageIdToJSON(messageId: MessageId): string {
  return JSON...)
 - Outbound(MessageMarkAsRequestDto$Outbound;
}

export function messageMarkAsRequestDtoToJSON(messageMarkAsRequ...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messageIdToJSON
- export function messageIdFromJSON
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messageMarkAsRequestDtoToJSON
- export function messageMarkAsRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/messageresponsedto.ts
Tamaño: 16343 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import { ChannelTypeEnum, ChannelTypeEnum$inboundSchema, ChannelTypeEnum$outboundSchema } from './channeltypeenum.js';
import { EmailBlock, EmailBlock$inboundSchema, EmailBlock$Outbound, EmailBlock$outboundSchema } from './emailblock.js';
import { MessageCTA, MessageCTA$inboundSchema, MessageCTA$Outbound, MessageCTA$outboundSchema } from './messagecta.js';
import {
  MessageStatusEnum,
  MessageStatusEnum$inboundSchema,
  MessageStatusEnum$outboundSchema,
} from './messagestatusenum.js';
import {
  SubscriberResponseDto,
  SubscriberResponseDto$inboundSchema,
  SubscriberResponseDto$Outbound,
  SubscriberResponseDto$outboundSchema,
} from './subscriberresponsedto.js';
import {
  WorkflowResponse,
  WorkflowResponse$inboundSchema,
  WorkflowResponse$Outbound,
  WorkflowResponse$outboundSchema,
} from './workflowresponse.js';

/**
 * Content of the message, can be an email block or a string
 */
export type MessageResponseDtoContent = Array<EmailBlock> | string;

/**
 * The payload that was used to send the notification trigger
 */
export type MessageResponseDtoPayload = {};

/**
 * Provider specific overrides used when triggering the notification
 */
export type MessageResponseDtoOverrides = {};

export type MessageResponseDto = {
  /**
   * Unique identifier for the message
   */
  id?: string | undefined;
  /**
   * Template ID associated with the message
   */
  templateId?: string | null | undefined;
  /**
   * Environment ID where the message is sent
   */
  environmentId: string;
  /**
   * Message template ID
   */
  messageTemplateId?: string | null | undefined;
  /**
   * Organization ID associated with the message
   */
  organizationId: string;
  /**
   * Notification ID associated with the message
   */
  notificationId: string;
  /**
   * Subscriber ID associated with the message
   */
  subscriberId: string;
  /**
   * Subscriber details, if available
   */
  subscriber?: SubscriberResponseDto | undefined;
  /**
   * Workflow template associated with the message
   */
  template?: WorkflowResponse | undefined;
  /**
   * Identifier for the message template
   */
  templateIdentifier?: string | undefined;
  /**
   * Creation date of the message
   */
  createdAt: string;
  /**
   * Array of delivery dates for the message, if the message has multiple delivery dates, for example after being snoozed
   */
  deliveredAt?: Array<string> | undefined;
  /**
   * Last seen date of the message, if available
   */
  lastSeenDate?: string | undefined;
  /**
   * Last read date of the message, if available
   */
  lastReadDate?: string | undefined;
  /**
   * Content of the message, can be an email block or a string
   */
  content?: Array<EmailBlock> | string | null | undefined;
  /**
   * Transaction ID associated with the message
   */
  transactionId: string;
  /**
   * Subject of the message, if applicable
   */
  subject?: string | undefined;
  /**
   * Channel type through which the message is sent
   */
  channel: ChannelTypeEnum;
  /**
   * Indicates if the message has been read
   */
  read: boolean;
  /**
   * Indicates if the message has been seen
   */
  seen: boolean;
  /**
   * Date when the message will be unsnoozed
   */
  snoozedUntil?: string | undefined;
  /**
   * Email address associated with the message, if applicable
   */
  email?: string | undefined;
  /**
   * Phone number associated with the message, if applicable
   */
  phone?: string | undefined;
  /**
   * Direct webhook URL for the message, if applicable
   */
  directWebhookUrl?: string | undefined;
  /**
   * Provider ID associated with the message, if applicable
   */
  providerId?: string | undefined;
  /**
   * Device tokens associated with the message, if applicable
   */
  deviceTokens?: Array<string> | undefined;
  /**
   * Title of the message, if applicable
   */
  title?: string | undefined;
  /**
   * Call to action associated with the message
   */
  cta: MessageCTA;
  /**
   * Feed ID associated with the message, if applicable
   */
  feedId?: string | null | undefined;
  /**
   * Status of the message
   */
  status: MessageStatusEnum;
  /**
   * Error ID if the message has an error
   */
  errorId?: string | undefined;
  /**
   * Error text if the message has an error
   */
  errorText?: string | undefined;
  /**
   * The payload that was used to send the notification trigger
   */
  payload?: MessageResponseDtoPayload | undefined;
  /**
   * Provider specific overrides used when triggering the notification
   */
  overrides?: MessageResponseDtoOverrides | undefined;
  /**
   * Context keys associated with the message (format: "type:id")
   */
  contextKeys?: Array<string> | undefined;
};

/** @internal */
export const MessageResponseDtoContent$inboundSchema: z.ZodType<MessageResponseDtoContent, z.ZodTypeDef, unknown> =
  z.union([z.array(EmailBlock$inboundSchema), z.string()]);

/** @internal */
export type MessageResponseDtoContent$Outbound = Array<EmailBlock$Outbound> | string;

/** @internal */
export const MessageResponseDtoContent$outboundSchema: z.ZodType<
  MessageResponseDtoContent$Outbound,
  z.ZodTypeDef,
  MessageResponseDtoContent
> = z.union([z.array(EmailBlock$outboundSchema), z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageResponseDtoContent$ {
  /** @deprecated use `MessageResponseDtoContent$inboundSchema` instead. */
  export const inboundSchema = MessageResponseDtoContent$inboundSchema;
  /** @deprecated use `MessageResponseDtoContent$outboundSchema` instead. */
  export const outboundSchema = MessageResponseDtoContent$outboundSchema;
  /** @deprecated use `MessageResponseDtoContent$Outbound` instead. */
  export type Outbound = MessageResponseDtoContent$Outbound;
}

export function messageResponseDtoContentToJSON(messageResponseDtoContent: MessageResponseDtoContent): string {
  return JSON.stringify(MessageResponseDtoContent$outboundSchema.parse(messageResponseDtoContent));
}

export function messageResponseDtoContentFromJSON(
  jsonString: string
): SafeParseResult<MessageResponseDtoContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageResponseDtoContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageResponseDtoContent' from JSON`
  );
}

/** @internal */
export const MessageResponseDtoPayload$inboundSchema: z.ZodType<MessageResponseDtoPayload, z.ZodTypeDef, unknown> =
  z.object({});

/** @internal */
export type MessageResponseDtoPayload$Outbound = {};

/** @internal */
export const MessageResponseDtoPayload$outboundSchema: z.ZodType<
  MessageResponseDtoPayload$Outbound,
  z.ZodTypeDef,
  MessageResponseDtoPayload
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageResponseDtoPayload$ {
  /** @deprecated use `MessageResponseDtoPayload$inboundSchema` instead. */
  export const inboundSchema = MessageResponseDtoPayload$inboundSchema;
  /** @deprecated use `MessageResponseDtoPayload$outboundSchema` instead. */
  export const outboundSchema = MessageResponseDtoPayload$outboundSchema;
  /** @deprecated use `MessageResponseDtoPayload$Outbound` instead. */
  export type Outbound = MessageResponseDtoPayload$Outbound;
}

export function messageResponseDtoPayloadToJSON(messageResponseDtoPayload: MessageResponseDtoPayload): string {
  return JSON.stringify(MessageResponseDtoPayload$outboundSchema.parse(messageResponseDtoPayload));
}

export function messageResponseDtoPayloadFromJSON(
  jsonString: string
): SafeParseResult<MessageResponseDtoPayload, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageResponseDtoPayload$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageResponseDtoPayload' from JSON`
  );
}

/** @internal */
export const MessageResponseDtoOverrides$inboundSchema: z.ZodType<MessageResponseDtoOverrides, z.ZodTypeDef, unknown> =
  z.object({});

/** @internal */
export type MessageResponseDtoOverrides$Outbound = {};

/** @internal */
export const MessageResponseDtoOverrides$outboundSchema: z.ZodType<
  MessageResponseDtoOverrides$Outbound,
  z.ZodTypeDef,
  MessageResponseDtoOverrides
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageResponseDtoOverrides$ {
  /** @deprecated use `MessageResponseDtoOverrides$inboundSchema` instead. */
  export const inboundSchema = MessageResponseDtoOverrides$inboundSchema;
  /** @deprecated use `MessageResponseDtoOverrides$outboundSchema` instead. */
  export const outboundSchema = MessageResponseDtoOverrides$outboundSchema;
  /** @deprecated use `MessageResponseDtoOverrides$Outbound` instead. */
  export type Outbound = MessageResponseDtoOverrides$Outbound;
}

export function messageResponseDtoOverridesToJSON(messageResponseDtoOverrides: MessageResponseDtoOverrides): string {
  return JSON.stringify(MessageResponseDtoOverrides$outboundSchema.parse(messageResponseDtoOverrides));
}

export function messageResponseDtoOverridesFromJSON(
  jsonString: string
): SafeParseResult<MessageResponseDtoOverrides, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageResponseDtoOverrides$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageResponseDtoOverrides' from JSON`
  );
}

/** @internal */
export const MessageResponseDto$inboundSchema: z.ZodType<MessageResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().optional(),
    _templateId: z.nullable(z.string()).optional(),
    _environmentId: z.string(),
    _messageTemplateId: z.nullable(z.string()).optional(),
    _organizationId: z.string(),
    _notificationId: z.string(),
    _subscriberId: z.string(),
    subscriber: SubscriberResponseDto$inboundSchema.optional(),
    template: WorkflowResponse$inboundSchema.optional(),
    templateIdentifier: z.string().optional(),
    createdAt: z.string(),
    deliveredAt: z.array(z.string()).optional(),
    lastSeenDate: z.string().optional(),
    lastReadDate: z.string().optional(),
    content: z.nullable(z.union([z.array(EmailBlock$inboundSchema), z.string()])).optional(),
    transactionId: z.string(),
    subject: z.string().optional(),
    channel: ChannelTypeEnum$inboundSchema,
    read: z.boolean(),
    seen: z.boolean(),
    snoozedUntil: z.string().optional(),
    email: z.string().optional(),
    phone: z.string().optional(),
    directWebhookUrl: z.string().optional(),
    providerId: z.string().optional(),
    deviceTokens: z.array(z.string()).optional(),
    title: z.string().optional(),
    cta: MessageCTA$inboundSchema,
    _feedId: z.nullable(z.string()).optional(),
    status: MessageStatusEnum$inboundSchema,
    errorId: z.string().optional(),
    errorText: z.string().optional(),
    payload: z.lazy(() => MessageResponseDtoPayload$inboundSchema).optional(),
    overrides: z.lazy(() => MessageResponseDtoOverrides$inboundSchema).optional(),
    contextKeys: z.array(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
      _templateId: 'templateId',
      _environmentId: 'environmentId',
      _messageTemplateId: 'messageTemplateId',
      _organizationId: 'organizationId',
      _notificationId: 'notificationId',
      _subscriberId: 'subscriberId',
      _feedId: 'feedId',
    });
  });

/** @internal */
export type MessageResponseDto$Outbound = {
  _id?: string | undefined;
  _templateId?: string | null | undefined;
  _environmentId: string;
  _messageTemplateId?: string | null | undefined;
  _organizationId: string;
  _notificationId: string;
  _subscriberId: string;
  subscriber?: SubscriberResponseDto$Outbound | undefined;
  template?: WorkflowResponse$Outbound | undefined;
  templateIdentifier?: string | undefined;
  createdAt: string;
  deliveredAt?: Array<string> | undefined;
  lastSeenDate?: string | undefined;
  lastReadDate?: string | undefined;
  content?: Array<EmailBlock$Outbound> | string | null | undefined;
  transactionId: string;
  subject?: string | undefined;
  channel: string;
  read: boolean;
  seen: boolean;
  snoozedUntil?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  directWebhookUrl?: string | undefined;
  providerId?: string | undefined;
  deviceTokens?: Array<string> | undefined;
  title?: string | undefined;
  cta: MessageCTA$Outbound;
  _feedId?: string | null | undefined;
  status: string;
  errorId?: string | undefined;
  errorText?: string | undefined;
  payload?: MessageResponseDtoPayload$Outbound | undefined;
  overrides?: MessageResponseDtoOverrides$Outbound | undefined;
  contextKeys?: Array<string> | undefined;
};

/** @internal */
export const MessageResponseDto$outboundSchema: z.ZodType<
  MessageResponseDto$Outbound,
  z.ZodTypeDef,
  MessageResponseDto
> = z
  .object({
    id: z.string().optional(),
    templateId: z.nullable(z.string()).optional(),
    environmentId: z.string(),
    messageTemplateId: z.nullable(z.string()).optional(),
    organizationId: z.string(),
    notificationId: z.string(),
    subscriberId: z.string(),
    subscriber: SubscriberResponseDto$outboundSchema.optional(),
    template: WorkflowResponse$outboundSchema.optional(),
    templateIdentifier: z.string().optional(),
    createdAt: z.string(),
    deliveredAt: z.array(z.string()).optional(),
    lastSeenDate: z.string().optional(),
    lastReadDate: z.string().optional(),
    content: z.nullable(z.union([z.array(EmailBlock$outboundSchema), z.string()])).optional(),
    transactionId: z.string(),
    subject: z.string().optional(),
    channel: ChannelTypeEnum$outboundSchema,
    read: z.boolean(),
    seen: z.boolean(),
    snoozedUntil: z.string().optional(),
    email: z.string().optional(),
    phone: z.string().optional(),
    directWebhookUrl: z.string().optional(),
    providerId: z.string().optional(),
    deviceTokens: z.array(z.string()).optional(),
    title: z.string().optional(),
    cta: MessageCTA$outboundSchema,
    feedId: z.nullable(z.string()).optional(),
    status: MessageStatusEnum$outboundSchema,
    errorId: z.string().optional(),
    errorText: z.string().optional(),
    payload: z.lazy(() => MessageResponseDtoPayload$outboundSchema).optional(),
    overrides: z.lazy(() => MessageResponseDtoOverrides$outboundSchema).optional(),
    contextKeys: z.array(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
      templateId: '_templateId',
      environmentId: '_environmentId',
      messageTemplateId: '_messageTemplateId',
      organizationId: '_organizationId',
      notificationId: '_notificationId',
      subscriberId: '_subscriberId',
      feedId: '_feedId',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageResponseDto$ {
  /** @deprecated use `MessageResponseDto$inboundSchema` instead. */
  export const inboundSchema = MessageResponseDto$inboundSchema;
  /** @deprecated use `MessageResponseDto$outboundSchema` instead. */
  export const outboundSchema = MessageResponseDto$outboundSchema;
  /** @deprecated use `MessageResponseDto$Outbound` instead. */
  export type Outbound = MessageResponseDto$Outbound;
}

export function messageResponseDtoToJSON(messageResponseDto: MessageResponseDto): string {
  return JSON.stringify(MessageResponseDto$outboundSchema.parse(messageResponseDto));
}

export function messageResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<MessageResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messageResponseDtoContentToJSON(messageResponseDtoContent: MessageResponseDtoContent)
 - messageResponseDtoContentFromJSON(jsonString: string)
 - messageResponseDtoPayloadToJSON(messageResponseDtoPayload: MessageResponseDtoPayload)
 - messageResponseDtoPayloadFromJSON(jsonString: string)
 - messageResponseDtoOverridesToJSON(messageResponseDtoOverrides: MessageResponseDtoOverrides)
 - messageResponseDtoOverridesFromJSON(jsonString: string)
 - messageResponseDtoToJSON(messageResponseDto: MessageResponseDto)
 - messageResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MessageResponseDtoContent$Outbound;
}

export function messageResponseDtoContentToJSON(messageRespon...)
 - Outbound(MessageResponseDtoPayload$Outbound;
}

export function messageResponseDtoPayloadToJSON(messageRespon...)
 - Outbound(MessageResponseDtoOverrides$Outbound;
}

export function messageResponseDtoOverridesToJSON(messageRe...)
 - Outbound(MessageResponseDto$Outbound;
}

export function messageResponseDtoToJSON(messageResponseDto: Message...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messageResponseDtoContentToJSON
- export function messageResponseDtoContentFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messageResponseDtoPayloadToJSON
- export function messageResponseDtoPayloadFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messageResponseDtoOverridesToJSON
- export function messageResponseDtoOverridesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messageResponseDtoToJSON
- export function messageResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/messagesresponsedto.ts
Tamaño: 2744 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  MessageResponseDto,
  MessageResponseDto$inboundSchema,
  MessageResponseDto$Outbound,
  MessageResponseDto$outboundSchema,
} from './messageresponsedto.js';

export type MessagesResponseDto = {
  /**
   * Total number of messages available
   */
  totalCount?: number | undefined;
  /**
   * Indicates if there are more messages available
   */
  hasMore: boolean;
  /**
   * List of messages
   */
  data: Array<MessageResponseDto>;
  /**
   * Number of messages per page
   */
  pageSize: number;
  /**
   * Current page number
   */
  page: number;
};

/** @internal */
export const MessagesResponseDto$inboundSchema: z.ZodType<MessagesResponseDto, z.ZodTypeDef, unknown> = z.object({
  totalCount: z.number().optional(),
  hasMore: z.boolean(),
  data: z.array(MessageResponseDto$inboundSchema),
  pageSize: z.number(),
  page: z.number(),
});

/** @internal */
export type MessagesResponseDto$Outbound = {
  totalCount?: number | undefined;
  hasMore: boolean;
  data: Array<MessageResponseDto$Outbound>;
  pageSize: number;
  page: number;
};

/** @internal */
export const MessagesResponseDto$outboundSchema: z.ZodType<
  MessagesResponseDto$Outbound,
  z.ZodTypeDef,
  MessagesResponseDto
> = z.object({
  totalCount: z.number().optional(),
  hasMore: z.boolean(),
  data: z.array(MessageResponseDto$outboundSchema),
  pageSize: z.number(),
  page: z.number(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessagesResponseDto$ {
  /** @deprecated use `MessagesResponseDto$inboundSchema` instead. */
  export const inboundSchema = MessagesResponseDto$inboundSchema;
  /** @deprecated use `MessagesResponseDto$outboundSchema` instead. */
  export const outboundSchema = MessagesResponseDto$outboundSchema;
  /** @deprecated use `MessagesResponseDto$Outbound` instead. */
  export type Outbound = MessagesResponseDto$Outbound;
}

export function messagesResponseDtoToJSON(messagesResponseDto: MessagesResponseDto): string {
  return JSON.stringify(MessagesResponseDto$outboundSchema.parse(messagesResponseDto));
}

export function messagesResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<MessagesResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messagesResponseDtoToJSON(messagesResponseDto: MessagesResponseDto)
 - messagesResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MessagesResponseDto$Outbound;
}

export function messagesResponseDtoToJSON(messagesResponseDto: Mess...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messagesResponseDtoToJSON
- export function messagesResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/messagestatusenum.ts
Tamaño: 1146 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Status of the message
 */
export const MessageStatusEnum = {
  Sent: 'sent',
  Error: 'error',
  Warning: 'warning',
} as const;
/**
 * Status of the message
 */
export type MessageStatusEnum = ClosedEnum<typeof MessageStatusEnum>;

/** @internal */
export const MessageStatusEnum$inboundSchema: z.ZodNativeEnum<typeof MessageStatusEnum> =
  z.nativeEnum(MessageStatusEnum);

/** @internal */
export const MessageStatusEnum$outboundSchema: z.ZodNativeEnum<typeof MessageStatusEnum> =
  MessageStatusEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageStatusEnum$ {
  /** @deprecated use `MessageStatusEnum$inboundSchema` instead. */
  export const inboundSchema = MessageStatusEnum$inboundSchema;
  /** @deprecated use `MessageStatusEnum$outboundSchema` instead. */
  export const outboundSchema = MessageStatusEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/messagetemplate.ts
Tamaño: 1663 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type MessageTemplate = {};

/** @internal */
export const MessageTemplate$inboundSchema: z.ZodType<MessageTemplate, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type MessageTemplate$Outbound = {};

/** @internal */
export const MessageTemplate$outboundSchema: z.ZodType<MessageTemplate$Outbound, z.ZodTypeDef, MessageTemplate> =
  z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageTemplate$ {
  /** @deprecated use `MessageTemplate$inboundSchema` instead. */
  export const inboundSchema = MessageTemplate$inboundSchema;
  /** @deprecated use `MessageTemplate$outboundSchema` instead. */
  export const outboundSchema = MessageTemplate$outboundSchema;
  /** @deprecated use `MessageTemplate$Outbound` instead. */
  export type Outbound = MessageTemplate$Outbound;
}

export function messageTemplateToJSON(messageTemplate: MessageTemplate): string {
  return JSON.stringify(MessageTemplate$outboundSchema.parse(messageTemplate));
}

export function messageTemplateFromJSON(jsonString: string): SafeParseResult<MessageTemplate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageTemplate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageTemplate' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messageTemplateToJSON(messageTemplate: MessageTemplate)
 - messageTemplateFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MessageTemplate$Outbound;
}

export function messageTemplateToJSON(messageTemplate: MessageTemplate)...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messageTemplateToJSON
- export function messageTemplateFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/messagetemplatedto.ts
Tamaño: 1742 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type MessageTemplateDto = {};

/** @internal */
export const MessageTemplateDto$inboundSchema: z.ZodType<MessageTemplateDto, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type MessageTemplateDto$Outbound = {};

/** @internal */
export const MessageTemplateDto$outboundSchema: z.ZodType<
  MessageTemplateDto$Outbound,
  z.ZodTypeDef,
  MessageTemplateDto
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessageTemplateDto$ {
  /** @deprecated use `MessageTemplateDto$inboundSchema` instead. */
  export const inboundSchema = MessageTemplateDto$inboundSchema;
  /** @deprecated use `MessageTemplateDto$outboundSchema` instead. */
  export const outboundSchema = MessageTemplateDto$outboundSchema;
  /** @deprecated use `MessageTemplateDto$Outbound` instead. */
  export type Outbound = MessageTemplateDto$Outbound;
}

export function messageTemplateDtoToJSON(messageTemplateDto: MessageTemplateDto): string {
  return JSON.stringify(MessageTemplateDto$outboundSchema.parse(messageTemplateDto));
}

export function messageTemplateDtoFromJSON(
  jsonString: string
): SafeParseResult<MessageTemplateDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageTemplateDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageTemplateDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messageTemplateDtoToJSON(messageTemplateDto: MessageTemplateDto)
 - messageTemplateDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MessageTemplateDto$Outbound;
}

export function messageTemplateDtoToJSON(messageTemplateDto: Message...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messageTemplateDtoToJSON
- export function messageTemplateDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/metadto.ts
Tamaño: 1937 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type MetaDto = {
  /**
   * The total count of subscriber IDs provided
   */
  totalCount: number;
  /**
   * The count of successfully created subscriptions
   */
  successful: number;
  /**
   * The count of failed subscription attempts
   */
  failed: number;
};

/** @internal */
export const MetaDto$inboundSchema: z.ZodType<MetaDto, z.ZodTypeDef, unknown> = z.object({
  totalCount: z.number(),
  successful: z.number(),
  failed: z.number(),
});

/** @internal */
export type MetaDto$Outbound = {
  totalCount: number;
  successful: number;
  failed: number;
};

/** @internal */
export const MetaDto$outboundSchema: z.ZodType<MetaDto$Outbound, z.ZodTypeDef, MetaDto> = z.object({
  totalCount: z.number(),
  successful: z.number(),
  failed: z.number(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetaDto$ {
  /** @deprecated use `MetaDto$inboundSchema` instead. */
  export const inboundSchema = MetaDto$inboundSchema;
  /** @deprecated use `MetaDto$outboundSchema` instead. */
  export const outboundSchema = MetaDto$outboundSchema;
  /** @deprecated use `MetaDto$Outbound` instead. */
  export type Outbound = MetaDto$Outbound;
}

export function metaDtoToJSON(metaDto: MetaDto): string {
  return JSON.stringify(MetaDto$outboundSchema.parse(metaDto));
}

export function metaDtoFromJSON(jsonString: string): SafeParseResult<MetaDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MetaDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MetaDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - metaDtoToJSON(metaDto: MetaDto)
 - metaDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MetaDto$Outbound;
}

export function metaDtoToJSON(metaDto: MetaDto): string {
  return JSON.stringi...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function metaDtoToJSON
- export function metaDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/monthlytypeenum.ts
Tamaño: 1092 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Type of monthly schedule
 */
export const MonthlyTypeEnum = {
  Each: 'each',
  On: 'on',
} as const;
/**
 * Type of monthly schedule
 */
export type MonthlyTypeEnum = ClosedEnum<typeof MonthlyTypeEnum>;

/** @internal */
export const MonthlyTypeEnum$inboundSchema: z.ZodNativeEnum<typeof MonthlyTypeEnum> = z.nativeEnum(MonthlyTypeEnum);

/** @internal */
export const MonthlyTypeEnum$outboundSchema: z.ZodNativeEnum<typeof MonthlyTypeEnum> = MonthlyTypeEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MonthlyTypeEnum$ {
  /** @deprecated use `MonthlyTypeEnum$inboundSchema` instead. */
  export const inboundSchema = MonthlyTypeEnum$inboundSchema;
  /** @deprecated use `MonthlyTypeEnum$outboundSchema` instead. */
  export const outboundSchema = MonthlyTypeEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/notificationfeeditemdto.ts
Tamaño: 11060 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ActorFeedItemDto,
  ActorFeedItemDto$inboundSchema,
  ActorFeedItemDto$Outbound,
  ActorFeedItemDto$outboundSchema,
} from './actorfeeditemdto.js';
import { ChannelTypeEnum, ChannelTypeEnum$inboundSchema, ChannelTypeEnum$outboundSchema } from './channeltypeenum.js';
import { MessageCTA, MessageCTA$inboundSchema, MessageCTA$Outbound, MessageCTA$outboundSchema } from './messagecta.js';
import {
  SubscriberFeedResponseDto,
  SubscriberFeedResponseDto$inboundSchema,
  SubscriberFeedResponseDto$Outbound,
  SubscriberFeedResponseDto$outboundSchema,
} from './subscriberfeedresponsedto.js';

/**
 * Current status of the notification.
 */
export const NotificationFeedItemDtoStatus = {
  Sent: 'sent',
  Error: 'error',
  Warning: 'warning',
} as const;
/**
 * Current status of the notification.
 */
export type NotificationFeedItemDtoStatus = ClosedEnum<typeof NotificationFeedItemDtoStatus>;

export type NotificationFeedItemDto = {
  /**
   * Unique identifier for the notification.
   */
  id: string;
  /**
   * Identifier for the template used to generate the notification.
   */
  templateId: string;
  /**
   * Identifier for the environment where the notification is sent.
   */
  environmentId: string;
  /**
   * Identifier for the message template used.
   */
  messageTemplateId?: string | undefined;
  /**
   * Identifier for the organization sending the notification.
   */
  organizationId: string;
  /**
   * Unique identifier for the notification instance.
   */
  notificationId: string;
  /**
   * Unique identifier for the subscriber receiving the notification.
   */
  subscriberId: string;
  /**
   * Identifier for the feed associated with the notification.
   */
  feedId?: string | null | undefined;
  /**
   * Identifier for the job that triggered the notification.
   */
  jobId: string;
  /**
   * Timestamp indicating when the notification was created.
   */
  createdAt?: Date | null | undefined;
  /**
   * Timestamp indicating when the notification was last updated.
   */
  updatedAt?: Date | null | undefined;
  /**
   * Actor details related to the notification, if applicable.
   */
  actor?: ActorFeedItemDto | undefined;
  /**
   * Subscriber details associated with this notification.
   */
  subscriber?: SubscriberFeedResponseDto | undefined;
  /**
   * Unique identifier for the transaction associated with the notification.
   */
  transactionId: string;
  /**
   * Identifier for the template used, if applicable.
   */
  templateIdentifier?: string | null | undefined;
  /**
   * Identifier for the provider that sends the notification.
   */
  providerId?: string | null | undefined;
  /**
   * The main content of the notification.
   */
  content: string;
  /**
   * The subject line for email notifications, if applicable.
   */
  subject?: string | null | undefined;
  /**
   * Channel type through which the message is sent
   */
  channel: ChannelTypeEnum;
  /**
   * Indicates whether the notification has been read by the subscriber.
   */
  read: boolean;
  /**
   * Indicates whether the notification has been seen by the subscriber.
   */
  seen: boolean;
  /**
   * Device tokens for push notifications, if applicable.
   */
  deviceTokens?: Array<string> | null | undefined;
  /**
   * Call-to-action information associated with the notification.
   */
  cta: MessageCTA;
  /**
   * Current status of the notification.
   */
  status: NotificationFeedItemDtoStatus;
  /**
   * The payload that was used to send the notification trigger.
   */
  payload?: { [k: string]: any } | undefined;
  /**
   * The data sent with the notification.
   */
  data?: { [k: string]: any } | null | undefined;
  /**
   * Provider-specific overrides used when triggering the notification.
   */
  overrides?: { [k: string]: any } | undefined;
  /**
   * Tags associated with the workflow that triggered the notification.
   */
  tags?: Array<string> | null | undefined;
};

/** @internal */
export const NotificationFeedItemDtoStatus$inboundSchema: z.ZodNativeEnum<typeof NotificationFeedItemDtoStatus> =
  z.nativeEnum(NotificationFeedItemDtoStatus);

/** @internal */
export const NotificationFeedItemDtoStatus$outboundSchema: z.ZodNativeEnum<typeof NotificationFeedItemDtoStatus> =
  NotificationFeedItemDtoStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotificationFeedItemDtoStatus$ {
  /** @deprecated use `NotificationFeedItemDtoStatus$inboundSchema` instead. */
  export const inboundSchema = NotificationFeedItemDtoStatus$inboundSchema;
  /** @deprecated use `NotificationFeedItemDtoStatus$outboundSchema` instead. */
  export const outboundSchema = NotificationFeedItemDtoStatus$outboundSchema;
}

/** @internal */
export const NotificationFeedItemDto$inboundSchema: z.ZodType<NotificationFeedItemDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string(),
    _templateId: z.string(),
    _environmentId: z.string(),
    _messageTemplateId: z.string().optional(),
    _organizationId: z.string(),
    _notificationId: z.string(),
    _subscriberId: z.string(),
    _feedId: z.nullable(z.string()).optional(),
    _jobId: z.string(),
    createdAt: z
      .nullable(
        z
          .string()
          .datetime({ offset: true })
          .transform((v) => new Date(v))
      )
      .optional(),
    updatedAt: z
      .nullable(
        z
          .string()
          .datetime({ offset: true })
          .transform((v) => new Date(v))
      )
      .optional(),
    actor: ActorFeedItemDto$inboundSchema.optional(),
    subscriber: SubscriberFeedResponseDto$inboundSchema.optional(),
    transactionId: z.string(),
    templateIdentifier: z.nullable(z.string()).optional(),
    providerId: z.nullable(z.string()).optional(),
    content: z.string(),
    subject: z.nullable(z.string()).optional(),
    channel: ChannelTypeEnum$inboundSchema,
    read: z.boolean(),
    seen: z.boolean(),
    deviceTokens: z.nullable(z.array(z.string())).optional(),
    cta: MessageCTA$inboundSchema,
    status: NotificationFeedItemDtoStatus$inboundSchema,
    payload: z.record(z.any()).optional(),
    data: z.nullable(z.record(z.any())).optional(),
    overrides: z.record(z.any()).optional(),
    tags: z.nullable(z.array(z.string())).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
      _templateId: 'templateId',
      _environmentId: 'environmentId',
      _messageTemplateId: 'messageTemplateId',
      _organizationId: 'organizationId',
      _notificationId: 'notificationId',
      _subscriberId: 'subscriberId',
      _feedId: 'feedId',
      _jobId: 'jobId',
    });
  });

/** @internal */
export type NotificationFeedItemDto$Outbound = {
  _id: string;
  _templateId: string;
  _environmentId: string;
  _messageTemplateId?: string | undefined;
  _organizationId: string;
  _notificationId: string;
  _subscriberId: string;
  _feedId?: string | null | undefined;
  _jobId: string;
  createdAt?: string | null | undefined;
  updatedAt?: string | null | undefined;
  actor?: ActorFeedItemDto$Outbound | undefined;
  subscriber?: SubscriberFeedResponseDto$Outbound | undefined;
  transactionId: string;
  templateIdentifier?: string | null | undefined;
  providerId?: string | null | undefined;
  content: string;
  subject?: string | null | undefined;
  channel: string;
  read: boolean;
  seen: boolean;
  deviceTokens?: Array<string> | null | undefined;
  cta: MessageCTA$Outbound;
  status: string;
  payload?: { [k: string]: any } | undefined;
  data?: { [k: string]: any } | null | undefined;
  overrides?: { [k: string]: any } | undefined;
  tags?: Array<string> | null | undefined;
};

/** @internal */
export const NotificationFeedItemDto$outboundSchema: z.ZodType<
  NotificationFeedItemDto$Outbound,
  z.ZodTypeDef,
  NotificationFeedItemDto
> = z
  .object({
    id: z.string(),
    templateId: z.string(),
    environmentId: z.string(),
    messageTemplateId: z.string().optional(),
    organizationId: z.string(),
    notificationId: z.string(),
    subscriberId: z.string(),
    feedId: z.nullable(z.string()).optional(),
    jobId: z.string(),
    createdAt: z.nullable(z.date().transform((v) => v.toISOString())).optional(),
    updatedAt: z.nullable(z.date().transform((v) => v.toISOString())).optional(),
    actor: ActorFeedItemDto$outboundSchema.optional(),
    subscriber: SubscriberFeedResponseDto$outboundSchema.optional(),
    transactionId: z.string(),
    templateIdentifier: z.nullable(z.string()).optional(),
    providerId: z.nullable(z.string()).optional(),
    content: z.string(),
    subject: z.nullable(z.string()).optional(),
    channel: ChannelTypeEnum$outboundSchema,
    read: z.boolean(),
    seen: z.boolean(),
    deviceTokens: z.nullable(z.array(z.string())).optional(),
    cta: MessageCTA$outboundSchema,
    status: NotificationFeedItemDtoStatus$outboundSchema,
    payload: z.record(z.any()).optional(),
    data: z.nullable(z.record(z.any())).optional(),
    overrides: z.record(z.any()).optional(),
    tags: z.nullable(z.array(z.string())).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
      templateId: '_templateId',
      environmentId: '_environmentId',
      messageTemplateId: '_messageTemplateId',
      organizationId: '_organizationId',
      notificationId: '_notificationId',
      subscriberId: '_subscriberId',
      feedId: '_feedId',
      jobId: '_jobId',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotificationFeedItemDto$ {
  /** @deprecated use `NotificationFeedItemDto$inboundSchema` instead. */
  export const inboundSchema = NotificationFeedItemDto$inboundSchema;
  /** @deprecated use `NotificationFeedItemDto$outboundSchema` instead. */
  export const outboundSchema = NotificationFeedItemDto$outboundSchema;
  /** @deprecated use `NotificationFeedItemDto$Outbound` instead. */
  export type Outbound = NotificationFeedItemDto$Outbound;
}

export function notificationFeedItemDtoToJSON(notificationFeedItemDto: NotificationFeedItemDto): string {
  return JSON.stringify(NotificationFeedItemDto$outboundSchema.parse(notificationFeedItemDto));
}

export function notificationFeedItemDtoFromJSON(
  jsonString: string
): SafeParseResult<NotificationFeedItemDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotificationFeedItemDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotificationFeedItemDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - notificationFeedItemDtoToJSON(notificationFeedItemDto: NotificationFeedItemDto)
 - notificationFeedItemDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(NotificationFeedItemDto$Outbound;
}

export function notificationFeedItemDtoToJSON(notificationFeedI...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function notificationFeedItemDtoToJSON
- export function notificationFeedItemDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/notificationgroup.ts
Tamaño: 2748 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type NotificationGroup = {
  id?: string | undefined;
  name: string;
  environmentId: string;
  organizationId: string;
  parentId?: string | undefined;
};

/** @internal */
export const NotificationGroup$inboundSchema: z.ZodType<NotificationGroup, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().optional(),
    name: z.string(),
    _environmentId: z.string(),
    _organizationId: z.string(),
    _parentId: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
      _environmentId: 'environmentId',
      _organizationId: 'organizationId',
      _parentId: 'parentId',
    });
  });

/** @internal */
export type NotificationGroup$Outbound = {
  _id?: string | undefined;
  name: string;
  _environmentId: string;
  _organizationId: string;
  _parentId?: string | undefined;
};

/** @internal */
export const NotificationGroup$outboundSchema: z.ZodType<NotificationGroup$Outbound, z.ZodTypeDef, NotificationGroup> =
  z
    .object({
      id: z.string().optional(),
      name: z.string(),
      environmentId: z.string(),
      organizationId: z.string(),
      parentId: z.string().optional(),
    })
    .transform((v) => {
      return remap$(v, {
        id: '_id',
        environmentId: '_environmentId',
        organizationId: '_organizationId',
        parentId: '_parentId',
      });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotificationGroup$ {
  /** @deprecated use `NotificationGroup$inboundSchema` instead. */
  export const inboundSchema = NotificationGroup$inboundSchema;
  /** @deprecated use `NotificationGroup$outboundSchema` instead. */
  export const outboundSchema = NotificationGroup$outboundSchema;
  /** @deprecated use `NotificationGroup$Outbound` instead. */
  export type Outbound = NotificationGroup$Outbound;
}

export function notificationGroupToJSON(notificationGroup: NotificationGroup): string {
  return JSON.stringify(NotificationGroup$outboundSchema.parse(notificationGroup));
}

export function notificationGroupFromJSON(jsonString: string): SafeParseResult<NotificationGroup, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotificationGroup$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotificationGroup' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - notificationGroupToJSON(notificationGroup: NotificationGroup)
 - notificationGroupFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(NotificationGroup$Outbound;
}

export function notificationGroupToJSON(notificationGroup: Notificati...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function notificationGroupToJSON
- export function notificationGroupFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/notificationstepdata.ts
Tamaño: 8813 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  DelayRegularMetadata,
  DelayRegularMetadata$inboundSchema,
  DelayRegularMetadata$Outbound,
  DelayRegularMetadata$outboundSchema,
} from './delayregularmetadata.js';
import {
  DelayScheduledMetadata,
  DelayScheduledMetadata$inboundSchema,
  DelayScheduledMetadata$Outbound,
  DelayScheduledMetadata$outboundSchema,
} from './delayscheduledmetadata.js';
import {
  DigestRegularMetadata,
  DigestRegularMetadata$inboundSchema,
  DigestRegularMetadata$Outbound,
  DigestRegularMetadata$outboundSchema,
} from './digestregularmetadata.js';
import {
  DigestTimedMetadata,
  DigestTimedMetadata$inboundSchema,
  DigestTimedMetadata$Outbound,
  DigestTimedMetadata$outboundSchema,
} from './digesttimedmetadata.js';
import {
  MessageTemplate,
  MessageTemplate$inboundSchema,
  MessageTemplate$Outbound,
  MessageTemplate$outboundSchema,
} from './messagetemplate.js';
import {
  ReplyCallback,
  ReplyCallback$inboundSchema,
  ReplyCallback$Outbound,
  ReplyCallback$outboundSchema,
} from './replycallback.js';
import {
  StepFilterDto,
  StepFilterDto$inboundSchema,
  StepFilterDto$Outbound,
  StepFilterDto$outboundSchema,
} from './stepfilterdto.js';

/**
 * Metadata associated with the workflow step. Can vary based on the type of step.
 */
export type NotificationStepDataMetadata =
  | DelayScheduledMetadata
  | DigestRegularMetadata
  | DigestTimedMetadata
  | DelayRegularMetadata;

export type NotificationStepData = {
  /**
   * Unique identifier for the notification step.
   */
  id?: string | undefined;
  /**
   * Universally unique identifier for the notification step.
   */
  uuid?: string | undefined;
  /**
   * Name of the notification step.
   */
  name?: string | undefined;
  /**
   * ID of the template associated with this notification step.
   */
  templateId?: string | undefined;
  /**
   * Indicates whether the notification step is active.
   */
  active?: boolean | undefined;
  /**
   * Determines if the process should stop on failure.
   */
  shouldStopOnFail?: boolean | undefined;
  /**
   * Message template used in this notification step.
   */
  template?: MessageTemplate | undefined;
  /**
   * Filters applied to this notification step.
   */
  filters?: Array<StepFilterDto> | undefined;
  /**
   * ID of the parent notification step, if applicable.
   */
  parentId?: string | undefined;
  /**
   * Metadata associated with the workflow step. Can vary based on the type of step.
   */
  metadata?: DelayScheduledMetadata | DigestRegularMetadata | DigestTimedMetadata | DelayRegularMetadata | undefined;
  /**
   * Callback information for replies, including whether it is active and the callback URL.
   */
  replyCallback?: ReplyCallback | undefined;
};

/** @internal */
export const NotificationStepDataMetadata$inboundSchema: z.ZodType<
  NotificationStepDataMetadata,
  z.ZodTypeDef,
  unknown
> = z.union([
  DelayScheduledMetadata$inboundSchema,
  DigestRegularMetadata$inboundSchema,
  DigestTimedMetadata$inboundSchema,
  DelayRegularMetadata$inboundSchema,
]);

/** @internal */
export type NotificationStepDataMetadata$Outbound =
  | DelayScheduledMetadata$Outbound
  | DigestRegularMetadata$Outbound
  | DigestTimedMetadata$Outbound
  | DelayRegularMetadata$Outbound;

/** @internal */
export const NotificationStepDataMetadata$outboundSchema: z.ZodType<
  NotificationStepDataMetadata$Outbound,
  z.ZodTypeDef,
  NotificationStepDataMetadata
> = z.union([
  DelayScheduledMetadata$outboundSchema,
  DigestRegularMetadata$outboundSchema,
  DigestTimedMetadata$outboundSchema,
  DelayRegularMetadata$outboundSchema,
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotificationStepDataMetadata$ {
  /** @deprecated use `NotificationStepDataMetadata$inboundSchema` instead. */
  export const inboundSchema = NotificationStepDataMetadata$inboundSchema;
  /** @deprecated use `NotificationStepDataMetadata$outboundSchema` instead. */
  export const outboundSchema = NotificationStepDataMetadata$outboundSchema;
  /** @deprecated use `NotificationStepDataMetadata$Outbound` instead. */
  export type Outbound = NotificationStepDataMetadata$Outbound;
}

export function notificationStepDataMetadataToJSON(notificationStepDataMetadata: NotificationStepDataMetadata): string {
  return JSON.stringify(NotificationStepDataMetadata$outboundSchema.parse(notificationStepDataMetadata));
}

export function notificationStepDataMetadataFromJSON(
  jsonString: string
): SafeParseResult<NotificationStepDataMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotificationStepDataMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotificationStepDataMetadata' from JSON`
  );
}

/** @internal */
export const NotificationStepData$inboundSchema: z.ZodType<NotificationStepData, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().optional(),
    uuid: z.string().optional(),
    name: z.string().optional(),
    _templateId: z.string().optional(),
    active: z.boolean().optional(),
    shouldStopOnFail: z.boolean().optional(),
    template: MessageTemplate$inboundSchema.optional(),
    filters: z.array(StepFilterDto$inboundSchema).optional(),
    _parentId: z.string().optional(),
    metadata: z
      .union([
        DelayScheduledMetadata$inboundSchema,
        DigestRegularMetadata$inboundSchema,
        DigestTimedMetadata$inboundSchema,
        DelayRegularMetadata$inboundSchema,
      ])
      .optional(),
    replyCallback: ReplyCallback$inboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
      _templateId: 'templateId',
      _parentId: 'parentId',
    });
  });

/** @internal */
export type NotificationStepData$Outbound = {
  _id?: string | undefined;
  uuid?: string | undefined;
  name?: string | undefined;
  _templateId?: string | undefined;
  active?: boolean | undefined;
  shouldStopOnFail?: boolean | undefined;
  template?: MessageTemplate$Outbound | undefined;
  filters?: Array<StepFilterDto$Outbound> | undefined;
  _parentId?: string | undefined;
  metadata?:
    | DelayScheduledMetadata$Outbound
    | DigestRegularMetadata$Outbound
    | DigestTimedMetadata$Outbound
    | DelayRegularMetadata$Outbound
    | undefined;
  replyCallback?: ReplyCallback$Outbound | undefined;
};

/** @internal */
export const NotificationStepData$outboundSchema: z.ZodType<
  NotificationStepData$Outbound,
  z.ZodTypeDef,
  NotificationStepData
> = z
  .object({
    id: z.string().optional(),
    uuid: z.string().optional(),
    name: z.string().optional(),
    templateId: z.string().optional(),
    active: z.boolean().optional(),
    shouldStopOnFail: z.boolean().optional(),
    template: MessageTemplate$outboundSchema.optional(),
    filters: z.array(StepFilterDto$outboundSchema).optional(),
    parentId: z.string().optional(),
    metadata: z
      .union([
        DelayScheduledMetadata$outboundSchema,
        DigestRegularMetadata$outboundSchema,
        DigestTimedMetadata$outboundSchema,
        DelayRegularMetadata$outboundSchema,
      ])
      .optional(),
    replyCallback: ReplyCallback$outboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
      templateId: '_templateId',
      parentId: '_parentId',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotificationStepData$ {
  /** @deprecated use `NotificationStepData$inboundSchema` instead. */
  export const inboundSchema = NotificationStepData$inboundSchema;
  /** @deprecated use `NotificationStepData$outboundSchema` instead. */
  export const outboundSchema = NotificationStepData$outboundSchema;
  /** @deprecated use `NotificationStepData$Outbound` instead. */
  export type Outbound = NotificationStepData$Outbound;
}

export function notificationStepDataToJSON(notificationStepData: NotificationStepData): string {
  return JSON.stringify(NotificationStepData$outboundSchema.parse(notificationStepData));
}

export function notificationStepDataFromJSON(
  jsonString: string
): SafeParseResult<NotificationStepData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotificationStepData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotificationStepData' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - notificationStepDataMetadataToJSON(notificationStepDataMetadata: NotificationStepDataMetadata)
 - notificationStepDataMetadataFromJSON(jsonString: string)
 - notificationStepDataToJSON(notificationStepData: NotificationStepData)
 - notificationStepDataFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(NotificationStepDataMetadata$Outbound;
}

export function notificationStepDataMetadataToJSON(notific...)
 - Outbound(NotificationStepData$Outbound;
}

export function notificationStepDataToJSON(notificationStepData: N...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function notificationStepDataMetadataToJSON
- export function notificationStepDataMetadataFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function notificationStepDataToJSON
- export function notificationStepDataFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/notificationstepdto.ts
Tamaño: 8737 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  DelayRegularMetadata,
  DelayRegularMetadata$inboundSchema,
  DelayRegularMetadata$Outbound,
  DelayRegularMetadata$outboundSchema,
} from './delayregularmetadata.js';
import {
  DelayScheduledMetadata,
  DelayScheduledMetadata$inboundSchema,
  DelayScheduledMetadata$Outbound,
  DelayScheduledMetadata$outboundSchema,
} from './delayscheduledmetadata.js';
import {
  DigestRegularMetadata,
  DigestRegularMetadata$inboundSchema,
  DigestRegularMetadata$Outbound,
  DigestRegularMetadata$outboundSchema,
} from './digestregularmetadata.js';
import {
  DigestTimedMetadata,
  DigestTimedMetadata$inboundSchema,
  DigestTimedMetadata$Outbound,
  DigestTimedMetadata$outboundSchema,
} from './digesttimedmetadata.js';
import {
  MessageTemplate,
  MessageTemplate$inboundSchema,
  MessageTemplate$Outbound,
  MessageTemplate$outboundSchema,
} from './messagetemplate.js';
import {
  NotificationStepData,
  NotificationStepData$inboundSchema,
  NotificationStepData$Outbound,
  NotificationStepData$outboundSchema,
} from './notificationstepdata.js';
import {
  ReplyCallback,
  ReplyCallback$inboundSchema,
  ReplyCallback$Outbound,
  ReplyCallback$outboundSchema,
} from './replycallback.js';
import {
  StepFilterDto,
  StepFilterDto$inboundSchema,
  StepFilterDto$Outbound,
  StepFilterDto$outboundSchema,
} from './stepfilterdto.js';

/**
 * Metadata associated with the workflow step. Can vary based on the type of step.
 */
export type Metadata = DelayScheduledMetadata | DigestRegularMetadata | DigestTimedMetadata | DelayRegularMetadata;

export type NotificationStepDto = {
  /**
   * Unique identifier for the notification step.
   */
  id?: string | undefined;
  /**
   * Universally unique identifier for the notification step.
   */
  uuid?: string | undefined;
  /**
   * Name of the notification step.
   */
  name?: string | undefined;
  /**
   * ID of the template associated with this notification step.
   */
  templateId?: string | undefined;
  /**
   * Indicates whether the notification step is active.
   */
  active?: boolean | undefined;
  /**
   * Determines if the process should stop on failure.
   */
  shouldStopOnFail?: boolean | undefined;
  /**
   * Message template used in this notification step.
   */
  template?: MessageTemplate | undefined;
  /**
   * Filters applied to this notification step.
   */
  filters?: Array<StepFilterDto> | undefined;
  /**
   * ID of the parent notification step, if applicable.
   */
  parentId?: string | undefined;
  /**
   * Metadata associated with the workflow step. Can vary based on the type of step.
   */
  metadata?: DelayScheduledMetadata | DigestRegularMetadata | DigestTimedMetadata | DelayRegularMetadata | undefined;
  /**
   * Callback information for replies, including whether it is active and the callback URL.
   */
  replyCallback?: ReplyCallback | undefined;
  variants?: Array<NotificationStepData> | undefined;
};

/** @internal */
export const Metadata$inboundSchema: z.ZodType<Metadata, z.ZodTypeDef, unknown> = z.union([
  DelayScheduledMetadata$inboundSchema,
  DigestRegularMetadata$inboundSchema,
  DigestTimedMetadata$inboundSchema,
  DelayRegularMetadata$inboundSchema,
]);

/** @internal */
export type Metadata$Outbound =
  | DelayScheduledMetadata$Outbound
  | DigestRegularMetadata$Outbound
  | DigestTimedMetadata$Outbound
  | DelayRegularMetadata$Outbound;

/** @internal */
export const Metadata$outboundSchema: z.ZodType<Metadata$Outbound, z.ZodTypeDef, Metadata> = z.union([
  DelayScheduledMetadata$outboundSchema,
  DigestRegularMetadata$outboundSchema,
  DigestTimedMetadata$outboundSchema,
  DelayRegularMetadata$outboundSchema,
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Metadata$ {
  /** @deprecated use `Metadata$inboundSchema` instead. */
  export const inboundSchema = Metadata$inboundSchema;
  /** @deprecated use `Metadata$outboundSchema` instead. */
  export const outboundSchema = Metadata$outboundSchema;
  /** @deprecated use `Metadata$Outbound` instead. */
  export type Outbound = Metadata$Outbound;
}

export function metadataToJSON(metadata: Metadata): string {
  return JSON.stringify(Metadata$outboundSchema.parse(metadata));
}

export function metadataFromJSON(jsonString: string): SafeParseResult<Metadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Metadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Metadata' from JSON`
  );
}

/** @internal */
export const NotificationStepDto$inboundSchema: z.ZodType<NotificationStepDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().optional(),
    uuid: z.string().optional(),
    name: z.string().optional(),
    _templateId: z.string().optional(),
    active: z.boolean().optional(),
    shouldStopOnFail: z.boolean().optional(),
    template: MessageTemplate$inboundSchema.optional(),
    filters: z.array(StepFilterDto$inboundSchema).optional(),
    _parentId: z.string().optional(),
    metadata: z
      .union([
        DelayScheduledMetadata$inboundSchema,
        DigestRegularMetadata$inboundSchema,
        DigestTimedMetadata$inboundSchema,
        DelayRegularMetadata$inboundSchema,
      ])
      .optional(),
    replyCallback: ReplyCallback$inboundSchema.optional(),
    variants: z.array(NotificationStepData$inboundSchema).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
      _templateId: 'templateId',
      _parentId: 'parentId',
    });
  });

/** @internal */
export type NotificationStepDto$Outbound = {
  _id?: string | undefined;
  uuid?: string | undefined;
  name?: string | undefined;
  _templateId?: string | undefined;
  active?: boolean | undefined;
  shouldStopOnFail?: boolean | undefined;
  template?: MessageTemplate$Outbound | undefined;
  filters?: Array<StepFilterDto$Outbound> | undefined;
  _parentId?: string | undefined;
  metadata?:
    | DelayScheduledMetadata$Outbound
    | DigestRegularMetadata$Outbound
    | DigestTimedMetadata$Outbound
    | DelayRegularMetadata$Outbound
    | undefined;
  replyCallback?: ReplyCallback$Outbound | undefined;
  variants?: Array<NotificationStepData$Outbound> | undefined;
};

/** @internal */
export const NotificationStepDto$outboundSchema: z.ZodType<
  NotificationStepDto$Outbound,
  z.ZodTypeDef,
  NotificationStepDto
> = z
  .object({
    id: z.string().optional(),
    uuid: z.string().optional(),
    name: z.string().optional(),
    templateId: z.string().optional(),
    active: z.boolean().optional(),
    shouldStopOnFail: z.boolean().optional(),
    template: MessageTemplate$outboundSchema.optional(),
    filters: z.array(StepFilterDto$outboundSchema).optional(),
    parentId: z.string().optional(),
    metadata: z
      .union([
        DelayScheduledMetadata$outboundSchema,
        DigestRegularMetadata$outboundSchema,
        DigestTimedMetadata$outboundSchema,
        DelayRegularMetadata$outboundSchema,
      ])
      .optional(),
    replyCallback: ReplyCallback$outboundSchema.optional(),
    variants: z.array(NotificationStepData$outboundSchema).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
      templateId: '_templateId',
      parentId: '_parentId',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotificationStepDto$ {
  /** @deprecated use `NotificationStepDto$inboundSchema` instead. */
  export const inboundSchema = NotificationStepDto$inboundSchema;
  /** @deprecated use `NotificationStepDto$outboundSchema` instead. */
  export const outboundSchema = NotificationStepDto$outboundSchema;
  /** @deprecated use `NotificationStepDto$Outbound` instead. */
  export type Outbound = NotificationStepDto$Outbound;
}

export function notificationStepDtoToJSON(notificationStepDto: NotificationStepDto): string {
  return JSON.stringify(NotificationStepDto$outboundSchema.parse(notificationStepDto));
}

export function notificationStepDtoFromJSON(
  jsonString: string
): SafeParseResult<NotificationStepDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotificationStepDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotificationStepDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - metadataToJSON(metadata: Metadata)
 - metadataFromJSON(jsonString: string)
 - notificationStepDtoToJSON(notificationStepDto: NotificationStepDto)
 - notificationStepDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Metadata$Outbound;
}

export function metadataToJSON(metadata: Metadata): string {
  return JSON.str...)
 - Outbound(NotificationStepDto$Outbound;
}

export function notificationStepDtoToJSON(notificationStepDto: Noti...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function metadataToJSON
- export function metadataFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function notificationStepDtoToJSON
- export function notificationStepDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/notificationtrigger.ts
Tamaño: 3807 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  NotificationTriggerVariable,
  NotificationTriggerVariable$inboundSchema,
  NotificationTriggerVariable$Outbound,
  NotificationTriggerVariable$outboundSchema,
} from './notificationtriggervariable.js';

export const NotificationTriggerType = {
  Event: 'event',
} as const;
export type NotificationTriggerType = ClosedEnum<typeof NotificationTriggerType>;

export type NotificationTrigger = {
  type: NotificationTriggerType;
  identifier: string;
  variables: Array<NotificationTriggerVariable>;
  subscriberVariables?: Array<NotificationTriggerVariable> | undefined;
};

/** @internal */
export const NotificationTriggerType$inboundSchema: z.ZodNativeEnum<typeof NotificationTriggerType> =
  z.nativeEnum(NotificationTriggerType);

/** @internal */
export const NotificationTriggerType$outboundSchema: z.ZodNativeEnum<typeof NotificationTriggerType> =
  NotificationTriggerType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotificationTriggerType$ {
  /** @deprecated use `NotificationTriggerType$inboundSchema` instead. */
  export const inboundSchema = NotificationTriggerType$inboundSchema;
  /** @deprecated use `NotificationTriggerType$outboundSchema` instead. */
  export const outboundSchema = NotificationTriggerType$outboundSchema;
}

/** @internal */
export const NotificationTrigger$inboundSchema: z.ZodType<NotificationTrigger, z.ZodTypeDef, unknown> = z.object({
  type: NotificationTriggerType$inboundSchema,
  identifier: z.string(),
  variables: z.array(NotificationTriggerVariable$inboundSchema),
  subscriberVariables: z.array(NotificationTriggerVariable$inboundSchema).optional(),
});

/** @internal */
export type NotificationTrigger$Outbound = {
  type: string;
  identifier: string;
  variables: Array<NotificationTriggerVariable$Outbound>;
  subscriberVariables?: Array<NotificationTriggerVariable$Outbound> | undefined;
};

/** @internal */
export const NotificationTrigger$outboundSchema: z.ZodType<
  NotificationTrigger$Outbound,
  z.ZodTypeDef,
  NotificationTrigger
> = z.object({
  type: NotificationTriggerType$outboundSchema,
  identifier: z.string(),
  variables: z.array(NotificationTriggerVariable$outboundSchema),
  subscriberVariables: z.array(NotificationTriggerVariable$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotificationTrigger$ {
  /** @deprecated use `NotificationTrigger$inboundSchema` instead. */
  export const inboundSchema = NotificationTrigger$inboundSchema;
  /** @deprecated use `NotificationTrigger$outboundSchema` instead. */
  export const outboundSchema = NotificationTrigger$outboundSchema;
  /** @deprecated use `NotificationTrigger$Outbound` instead. */
  export type Outbound = NotificationTrigger$Outbound;
}

export function notificationTriggerToJSON(notificationTrigger: NotificationTrigger): string {
  return JSON.stringify(NotificationTrigger$outboundSchema.parse(notificationTrigger));
}

export function notificationTriggerFromJSON(
  jsonString: string
): SafeParseResult<NotificationTrigger, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotificationTrigger$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotificationTrigger' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - notificationTriggerToJSON(notificationTrigger: NotificationTrigger)
 - notificationTriggerFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(NotificationTrigger$Outbound;
}

export function notificationTriggerToJSON(notificationTrigger: Noti...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function notificationTriggerToJSON
- export function notificationTriggerFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/notificationtriggerdto.ts
Tamaño: 4164 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  NotificationTriggerVariable,
  NotificationTriggerVariable$inboundSchema,
  NotificationTriggerVariable$Outbound,
  NotificationTriggerVariable$outboundSchema,
} from './notificationtriggervariable.js';

/**
 * Type of the trigger
 */
export const NotificationTriggerDtoType = {
  Event: 'event',
} as const;
/**
 * Type of the trigger
 */
export type NotificationTriggerDtoType = ClosedEnum<typeof NotificationTriggerDtoType>;

export type NotificationTriggerDto = {
  /**
   * Type of the trigger
   */
  type: NotificationTriggerDtoType;
  /**
   * Identifier of the trigger
   */
  identifier: string;
  /**
   * Variables of the trigger
   */
  variables: Array<NotificationTriggerVariable>;
  /**
   * Subscriber variables of the trigger
   */
  subscriberVariables?: Array<NotificationTriggerVariable> | undefined;
};

/** @internal */
export const NotificationTriggerDtoType$inboundSchema: z.ZodNativeEnum<typeof NotificationTriggerDtoType> =
  z.nativeEnum(NotificationTriggerDtoType);

/** @internal */
export const NotificationTriggerDtoType$outboundSchema: z.ZodNativeEnum<typeof NotificationTriggerDtoType> =
  NotificationTriggerDtoType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotificationTriggerDtoType$ {
  /** @deprecated use `NotificationTriggerDtoType$inboundSchema` instead. */
  export const inboundSchema = NotificationTriggerDtoType$inboundSchema;
  /** @deprecated use `NotificationTriggerDtoType$outboundSchema` instead. */
  export const outboundSchema = NotificationTriggerDtoType$outboundSchema;
}

/** @internal */
export const NotificationTriggerDto$inboundSchema: z.ZodType<NotificationTriggerDto, z.ZodTypeDef, unknown> = z.object({
  type: NotificationTriggerDtoType$inboundSchema,
  identifier: z.string(),
  variables: z.array(NotificationTriggerVariable$inboundSchema),
  subscriberVariables: z.array(NotificationTriggerVariable$inboundSchema).optional(),
});

/** @internal */
export type NotificationTriggerDto$Outbound = {
  type: string;
  identifier: string;
  variables: Array<NotificationTriggerVariable$Outbound>;
  subscriberVariables?: Array<NotificationTriggerVariable$Outbound> | undefined;
};

/** @internal */
export const NotificationTriggerDto$outboundSchema: z.ZodType<
  NotificationTriggerDto$Outbound,
  z.ZodTypeDef,
  NotificationTriggerDto
> = z.object({
  type: NotificationTriggerDtoType$outboundSchema,
  identifier: z.string(),
  variables: z.array(NotificationTriggerVariable$outboundSchema),
  subscriberVariables: z.array(NotificationTriggerVariable$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotificationTriggerDto$ {
  /** @deprecated use `NotificationTriggerDto$inboundSchema` instead. */
  export const inboundSchema = NotificationTriggerDto$inboundSchema;
  /** @deprecated use `NotificationTriggerDto$outboundSchema` instead. */
  export const outboundSchema = NotificationTriggerDto$outboundSchema;
  /** @deprecated use `NotificationTriggerDto$Outbound` instead. */
  export type Outbound = NotificationTriggerDto$Outbound;
}

export function notificationTriggerDtoToJSON(notificationTriggerDto: NotificationTriggerDto): string {
  return JSON.stringify(NotificationTriggerDto$outboundSchema.parse(notificationTriggerDto));
}

export function notificationTriggerDtoFromJSON(
  jsonString: string
): SafeParseResult<NotificationTriggerDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotificationTriggerDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotificationTriggerDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - notificationTriggerDtoToJSON(notificationTriggerDto: NotificationTriggerDto)
 - notificationTriggerDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(NotificationTriggerDto$Outbound;
}

export function notificationTriggerDtoToJSON(notificationTrigger...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function notificationTriggerDtoToJSON
- export function notificationTriggerDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/notificationtriggervariable.ts
Tamaño: 2069 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type NotificationTriggerVariable = {
  /**
   * Name of the variable
   */
  name: string;
};

/** @internal */
export const NotificationTriggerVariable$inboundSchema: z.ZodType<NotificationTriggerVariable, z.ZodTypeDef, unknown> =
  z.object({
    name: z.string(),
  });

/** @internal */
export type NotificationTriggerVariable$Outbound = {
  name: string;
};

/** @internal */
export const NotificationTriggerVariable$outboundSchema: z.ZodType<
  NotificationTriggerVariable$Outbound,
  z.ZodTypeDef,
  NotificationTriggerVariable
> = z.object({
  name: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotificationTriggerVariable$ {
  /** @deprecated use `NotificationTriggerVariable$inboundSchema` instead. */
  export const inboundSchema = NotificationTriggerVariable$inboundSchema;
  /** @deprecated use `NotificationTriggerVariable$outboundSchema` instead. */
  export const outboundSchema = NotificationTriggerVariable$outboundSchema;
  /** @deprecated use `NotificationTriggerVariable$Outbound` instead. */
  export type Outbound = NotificationTriggerVariable$Outbound;
}

export function notificationTriggerVariableToJSON(notificationTriggerVariable: NotificationTriggerVariable): string {
  return JSON.stringify(NotificationTriggerVariable$outboundSchema.parse(notificationTriggerVariable));
}

export function notificationTriggerVariableFromJSON(
  jsonString: string
): SafeParseResult<NotificationTriggerVariable, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotificationTriggerVariable$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotificationTriggerVariable' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - notificationTriggerVariableToJSON(notificationTriggerVariable: NotificationTriggerVariable)
 - notificationTriggerVariableFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(NotificationTriggerVariable$Outbound;
}

export function notificationTriggerVariableToJSON(notificat...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function notificationTriggerVariableToJSON
- export function notificationTriggerVariableFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/ordinalenum.ts
Tamaño: 1102 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Ordinal position for the digest
 */
export const OrdinalEnum = {
  One: '1',
  Two: '2',
  Three: '3',
  Four: '4',
  Five: '5',
  Last: 'last',
} as const;
/**
 * Ordinal position for the digest
 */
export type OrdinalEnum = ClosedEnum<typeof OrdinalEnum>;

/** @internal */
export const OrdinalEnum$inboundSchema: z.ZodNativeEnum<typeof OrdinalEnum> = z.nativeEnum(OrdinalEnum);

/** @internal */
export const OrdinalEnum$outboundSchema: z.ZodNativeEnum<typeof OrdinalEnum> = OrdinalEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OrdinalEnum$ {
  /** @deprecated use `OrdinalEnum$inboundSchema` instead. */
  export const inboundSchema = OrdinalEnum$inboundSchema;
  /** @deprecated use `OrdinalEnum$outboundSchema` instead. */
  export const outboundSchema = OrdinalEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/ordinalvalueenum.ts
Tamaño: 1284 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Value of the ordinal
 */
export const OrdinalValueEnum = {
  Day: 'day',
  Weekday: 'weekday',
  Weekend: 'weekend',
  Sunday: 'sunday',
  Monday: 'monday',
  Tuesday: 'tuesday',
  Wednesday: 'wednesday',
  Thursday: 'thursday',
  Friday: 'friday',
  Saturday: 'saturday',
} as const;
/**
 * Value of the ordinal
 */
export type OrdinalValueEnum = ClosedEnum<typeof OrdinalValueEnum>;

/** @internal */
export const OrdinalValueEnum$inboundSchema: z.ZodNativeEnum<typeof OrdinalValueEnum> = z.nativeEnum(OrdinalValueEnum);

/** @internal */
export const OrdinalValueEnum$outboundSchema: z.ZodNativeEnum<typeof OrdinalValueEnum> = OrdinalValueEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OrdinalValueEnum$ {
  /** @deprecated use `OrdinalValueEnum$inboundSchema` instead. */
  export const inboundSchema = OrdinalValueEnum$inboundSchema;
  /** @deprecated use `OrdinalValueEnum$outboundSchema` instead. */
  export const outboundSchema = OrdinalValueEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/patchpreferencechannelsdto.ts
Tamaño: 3014 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type PatchPreferenceChannelsDto = {
  /**
   * Email channel preference
   */
  email?: boolean | undefined;
  /**
   * SMS channel preference
   */
  sms?: boolean | undefined;
  /**
   * In-app channel preference
   */
  inApp?: boolean | undefined;
  /**
   * Push channel preference
   */
  push?: boolean | undefined;
  /**
   * Chat channel preference
   */
  chat?: boolean | undefined;
};

/** @internal */
export const PatchPreferenceChannelsDto$inboundSchema: z.ZodType<PatchPreferenceChannelsDto, z.ZodTypeDef, unknown> = z
  .object({
    email: z.boolean().optional(),
    sms: z.boolean().optional(),
    in_app: z.boolean().optional(),
    push: z.boolean().optional(),
    chat: z.boolean().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      in_app: 'inApp',
    });
  });

/** @internal */
export type PatchPreferenceChannelsDto$Outbound = {
  email?: boolean | undefined;
  sms?: boolean | undefined;
  in_app?: boolean | undefined;
  push?: boolean | undefined;
  chat?: boolean | undefined;
};

/** @internal */
export const PatchPreferenceChannelsDto$outboundSchema: z.ZodType<
  PatchPreferenceChannelsDto$Outbound,
  z.ZodTypeDef,
  PatchPreferenceChannelsDto
> = z
  .object({
    email: z.boolean().optional(),
    sms: z.boolean().optional(),
    inApp: z.boolean().optional(),
    push: z.boolean().optional(),
    chat: z.boolean().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      inApp: 'in_app',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PatchPreferenceChannelsDto$ {
  /** @deprecated use `PatchPreferenceChannelsDto$inboundSchema` instead. */
  export const inboundSchema = PatchPreferenceChannelsDto$inboundSchema;
  /** @deprecated use `PatchPreferenceChannelsDto$outboundSchema` instead. */
  export const outboundSchema = PatchPreferenceChannelsDto$outboundSchema;
  /** @deprecated use `PatchPreferenceChannelsDto$Outbound` instead. */
  export type Outbound = PatchPreferenceChannelsDto$Outbound;
}

export function patchPreferenceChannelsDtoToJSON(patchPreferenceChannelsDto: PatchPreferenceChannelsDto): string {
  return JSON.stringify(PatchPreferenceChannelsDto$outboundSchema.parse(patchPreferenceChannelsDto));
}

export function patchPreferenceChannelsDtoFromJSON(
  jsonString: string
): SafeParseResult<PatchPreferenceChannelsDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PatchPreferenceChannelsDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PatchPreferenceChannelsDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - patchPreferenceChannelsDtoToJSON(patchPreferenceChannelsDto: PatchPreferenceChannelsDto)
 - patchPreferenceChannelsDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(PatchPreferenceChannelsDto$Outbound;
}

export function patchPreferenceChannelsDtoToJSON(patchPrefer...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function patchPreferenceChannelsDtoToJSON
- export function patchPreferenceChannelsDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/patchsubscriberpreferencesdto.ts
Tamaño: 3168 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  PatchPreferenceChannelsDto,
  PatchPreferenceChannelsDto$inboundSchema,
  PatchPreferenceChannelsDto$Outbound,
  PatchPreferenceChannelsDto$outboundSchema,
} from './patchpreferencechannelsdto.js';
import {
  ScheduleDto,
  ScheduleDto$inboundSchema,
  ScheduleDto$Outbound,
  ScheduleDto$outboundSchema,
} from './scheduledto.js';

export type PatchSubscriberPreferencesDto = {
  /**
   * Channel-specific preference settings
   */
  channels?: PatchPreferenceChannelsDto | undefined;
  /**
   * Workflow internal _id, identifier or slug. If provided, update workflow specific preferences, otherwise update global preferences
   */
  workflowId?: string | undefined;
  /**
   * Subscriber schedule
   */
  schedule?: ScheduleDto | undefined;
};

/** @internal */
export const PatchSubscriberPreferencesDto$inboundSchema: z.ZodType<
  PatchSubscriberPreferencesDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  channels: PatchPreferenceChannelsDto$inboundSchema.optional(),
  workflowId: z.string().optional(),
  schedule: ScheduleDto$inboundSchema.optional(),
});

/** @internal */
export type PatchSubscriberPreferencesDto$Outbound = {
  channels?: PatchPreferenceChannelsDto$Outbound | undefined;
  workflowId?: string | undefined;
  schedule?: ScheduleDto$Outbound | undefined;
};

/** @internal */
export const PatchSubscriberPreferencesDto$outboundSchema: z.ZodType<
  PatchSubscriberPreferencesDto$Outbound,
  z.ZodTypeDef,
  PatchSubscriberPreferencesDto
> = z.object({
  channels: PatchPreferenceChannelsDto$outboundSchema.optional(),
  workflowId: z.string().optional(),
  schedule: ScheduleDto$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PatchSubscriberPreferencesDto$ {
  /** @deprecated use `PatchSubscriberPreferencesDto$inboundSchema` instead. */
  export const inboundSchema = PatchSubscriberPreferencesDto$inboundSchema;
  /** @deprecated use `PatchSubscriberPreferencesDto$outboundSchema` instead. */
  export const outboundSchema = PatchSubscriberPreferencesDto$outboundSchema;
  /** @deprecated use `PatchSubscriberPreferencesDto$Outbound` instead. */
  export type Outbound = PatchSubscriberPreferencesDto$Outbound;
}

export function patchSubscriberPreferencesDtoToJSON(
  patchSubscriberPreferencesDto: PatchSubscriberPreferencesDto
): string {
  return JSON.stringify(PatchSubscriberPreferencesDto$outboundSchema.parse(patchSubscriberPreferencesDto));
}

export function patchSubscriberPreferencesDtoFromJSON(
  jsonString: string
): SafeParseResult<PatchSubscriberPreferencesDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PatchSubscriberPreferencesDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PatchSubscriberPreferencesDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - patchSubscriberPreferencesDtoToJSON(patchSubscriberPreferencesDto: PatchSubscriberPreferencesDto)
 - patchSubscriberPreferencesDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(PatchSubscriberPreferencesDto$Outbound;
}

export function patchSubscriberPreferencesDtoToJSON(
  pa...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function patchSubscriberPreferencesDtoToJSON
- export function patchSubscriberPreferencesDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/patchsubscriberrequestdto.ts
Tamaño: 3684 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type PatchSubscriberRequestDto = {
  /**
   * First name of the subscriber
   */
  firstName?: string | null | undefined;
  /**
   * Last name of the subscriber
   */
  lastName?: string | null | undefined;
  /**
   * Email address of the subscriber
   */
  email?: string | null | undefined;
  /**
   * Phone number of the subscriber
   */
  phone?: string | null | undefined;
  /**
   * Avatar URL or identifier
   */
  avatar?: string | null | undefined;
  /**
   * Timezone of the subscriber
   */
  timezone?: string | null | undefined;
  /**
   * Locale of the subscriber
   */
  locale?: string | null | undefined;
  /**
   * Additional custom data for the subscriber
   */
  data?: { [k: string]: any } | null | undefined;
};

/** @internal */
export const PatchSubscriberRequestDto$inboundSchema: z.ZodType<PatchSubscriberRequestDto, z.ZodTypeDef, unknown> =
  z.object({
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    email: z.nullable(z.string()).optional(),
    phone: z.nullable(z.string()).optional(),
    avatar: z.nullable(z.string()).optional(),
    timezone: z.nullable(z.string()).optional(),
    locale: z.nullable(z.string()).optional(),
    data: z.nullable(z.record(z.any())).optional(),
  });

/** @internal */
export type PatchSubscriberRequestDto$Outbound = {
  firstName?: string | null | undefined;
  lastName?: string | null | undefined;
  email?: string | null | undefined;
  phone?: string | null | undefined;
  avatar?: string | null | undefined;
  timezone?: string | null | undefined;
  locale?: string | null | undefined;
  data?: { [k: string]: any } | null | undefined;
};

/** @internal */
export const PatchSubscriberRequestDto$outboundSchema: z.ZodType<
  PatchSubscriberRequestDto$Outbound,
  z.ZodTypeDef,
  PatchSubscriberRequestDto
> = z.object({
  firstName: z.nullable(z.string()).optional(),
  lastName: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()).optional(),
  phone: z.nullable(z.string()).optional(),
  avatar: z.nullable(z.string()).optional(),
  timezone: z.nullable(z.string()).optional(),
  locale: z.nullable(z.string()).optional(),
  data: z.nullable(z.record(z.any())).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PatchSubscriberRequestDto$ {
  /** @deprecated use `PatchSubscriberRequestDto$inboundSchema` instead. */
  export const inboundSchema = PatchSubscriberRequestDto$inboundSchema;
  /** @deprecated use `PatchSubscriberRequestDto$outboundSchema` instead. */
  export const outboundSchema = PatchSubscriberRequestDto$outboundSchema;
  /** @deprecated use `PatchSubscriberRequestDto$Outbound` instead. */
  export type Outbound = PatchSubscriberRequestDto$Outbound;
}

export function patchSubscriberRequestDtoToJSON(patchSubscriberRequestDto: PatchSubscriberRequestDto): string {
  return JSON.stringify(PatchSubscriberRequestDto$outboundSchema.parse(patchSubscriberRequestDto));
}

export function patchSubscriberRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<PatchSubscriberRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PatchSubscriberRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PatchSubscriberRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - patchSubscriberRequestDtoToJSON(patchSubscriberRequestDto: PatchSubscriberRequestDto)
 - patchSubscriberRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(PatchSubscriberRequestDto$Outbound;
}

export function patchSubscriberRequestDtoToJSON(patchSubscrib...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function patchSubscriberRequestDtoToJSON
- export function patchSubscriberRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/patchworkflowdto.ts
Tamaño: 3235 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type PatchWorkflowDto = {
  /**
   * Activate or deactivate the workflow
   */
  active?: boolean | undefined;
  /**
   * New name for the workflow
   */
  name?: string | undefined;
  /**
   * Updated description of the workflow
   */
  description?: string | undefined;
  /**
   * Tags associated with the workflow
   */
  tags?: Array<string> | undefined;
  /**
   * The payload JSON Schema for the workflow
   */
  payloadSchema?: { [k: string]: any } | null | undefined;
  /**
   * Enable or disable payload schema validation
   */
  validatePayload?: boolean | undefined;
  /**
   * Enable or disable translations for this workflow
   */
  isTranslationEnabled?: boolean | undefined;
};

/** @internal */
export const PatchWorkflowDto$inboundSchema: z.ZodType<PatchWorkflowDto, z.ZodTypeDef, unknown> = z.object({
  active: z.boolean().optional(),
  name: z.string().optional(),
  description: z.string().optional(),
  tags: z.array(z.string()).optional(),
  payloadSchema: z.nullable(z.record(z.any())).optional(),
  validatePayload: z.boolean().optional(),
  isTranslationEnabled: z.boolean().optional(),
});

/** @internal */
export type PatchWorkflowDto$Outbound = {
  active?: boolean | undefined;
  name?: string | undefined;
  description?: string | undefined;
  tags?: Array<string> | undefined;
  payloadSchema?: { [k: string]: any } | null | undefined;
  validatePayload?: boolean | undefined;
  isTranslationEnabled?: boolean | undefined;
};

/** @internal */
export const PatchWorkflowDto$outboundSchema: z.ZodType<PatchWorkflowDto$Outbound, z.ZodTypeDef, PatchWorkflowDto> =
  z.object({
    active: z.boolean().optional(),
    name: z.string().optional(),
    description: z.string().optional(),
    tags: z.array(z.string()).optional(),
    payloadSchema: z.nullable(z.record(z.any())).optional(),
    validatePayload: z.boolean().optional(),
    isTranslationEnabled: z.boolean().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PatchWorkflowDto$ {
  /** @deprecated use `PatchWorkflowDto$inboundSchema` instead. */
  export const inboundSchema = PatchWorkflowDto$inboundSchema;
  /** @deprecated use `PatchWorkflowDto$outboundSchema` instead. */
  export const outboundSchema = PatchWorkflowDto$outboundSchema;
  /** @deprecated use `PatchWorkflowDto$Outbound` instead. */
  export type Outbound = PatchWorkflowDto$Outbound;
}

export function patchWorkflowDtoToJSON(patchWorkflowDto: PatchWorkflowDto): string {
  return JSON.stringify(PatchWorkflowDto$outboundSchema.parse(patchWorkflowDto));
}

export function patchWorkflowDtoFromJSON(jsonString: string): SafeParseResult<PatchWorkflowDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PatchWorkflowDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PatchWorkflowDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - patchWorkflowDtoToJSON(patchWorkflowDto: PatchWorkflowDto)
 - patchWorkflowDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(PatchWorkflowDto$Outbound;
}

export function patchWorkflowDtoToJSON(patchWorkflowDto: PatchWorkflow...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function patchWorkflowDtoToJSON
- export function patchWorkflowDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/payloadvalidationerrordto.ts
Tamaño: 8215 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type Value5 = string | number | boolean | { [k: string]: any };

export type Value4 = {};

/**
 * The actual value that failed validation
 */
export type PayloadValidationErrorDtoValue =
  | string
  | number
  | boolean
  | Value4
  | Array<string | number | boolean | { [k: string]: any } | null>;

export type PayloadValidationErrorDto = {
  /**
   * Field path that failed validation
   */
  field: string;
  /**
   * Validation error message
   */
  message: string;
  /**
   * The actual value that failed validation
   */
  value?:
    | string
    | number
    | boolean
    | Value4
    | Array<string | number | boolean | { [k: string]: any } | null>
    | null
    | undefined;
  /**
   * JSON Schema path where the validation failed
   */
  schemaPath?: string | undefined;
};

/** @internal */
export const Value5$inboundSchema: z.ZodType<Value5, z.ZodTypeDef, unknown> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.record(z.any()),
]);

/** @internal */
export type Value5$Outbound = string | number | boolean | { [k: string]: any };

/** @internal */
export const Value5$outboundSchema: z.ZodType<Value5$Outbound, z.ZodTypeDef, Value5> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.record(z.any()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Value5$ {
  /** @deprecated use `Value5$inboundSchema` instead. */
  export const inboundSchema = Value5$inboundSchema;
  /** @deprecated use `Value5$outboundSchema` instead. */
  export const outboundSchema = Value5$outboundSchema;
  /** @deprecated use `Value5$Outbound` instead. */
  export type Outbound = Value5$Outbound;
}

export function value5ToJSON(value5: Value5): string {
  return JSON.stringify(Value5$outboundSchema.parse(value5));
}

export function value5FromJSON(jsonString: string): SafeParseResult<Value5, SDKValidationError> {
  return safeParse(jsonString, (x) => Value5$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Value5' from JSON`);
}

/** @internal */
export const Value4$inboundSchema: z.ZodType<Value4, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type Value4$Outbound = {};

/** @internal */
export const Value4$outboundSchema: z.ZodType<Value4$Outbound, z.ZodTypeDef, Value4> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Value4$ {
  /** @deprecated use `Value4$inboundSchema` instead. */
  export const inboundSchema = Value4$inboundSchema;
  /** @deprecated use `Value4$outboundSchema` instead. */
  export const outboundSchema = Value4$outboundSchema;
  /** @deprecated use `Value4$Outbound` instead. */
  export type Outbound = Value4$Outbound;
}

export function value4ToJSON(value4: Value4): string {
  return JSON.stringify(Value4$outboundSchema.parse(value4));
}

export function value4FromJSON(jsonString: string): SafeParseResult<Value4, SDKValidationError> {
  return safeParse(jsonString, (x) => Value4$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Value4' from JSON`);
}

/** @internal */
export const PayloadValidationErrorDtoValue$inboundSchema: z.ZodType<
  PayloadValidationErrorDtoValue,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.lazy(() => Value4$inboundSchema),
  z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
]);

/** @internal */
export type PayloadValidationErrorDtoValue$Outbound =
  | string
  | number
  | boolean
  | Value4$Outbound
  | Array<string | number | boolean | { [k: string]: any } | null>;

/** @internal */
export const PayloadValidationErrorDtoValue$outboundSchema: z.ZodType<
  PayloadValidationErrorDtoValue$Outbound,
  z.ZodTypeDef,
  PayloadValidationErrorDtoValue
> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.lazy(() => Value4$outboundSchema),
  z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PayloadValidationErrorDtoValue$ {
  /** @deprecated use `PayloadValidationErrorDtoValue$inboundSchema` instead. */
  export const inboundSchema = PayloadValidationErrorDtoValue$inboundSchema;
  /** @deprecated use `PayloadValidationErrorDtoValue$outboundSchema` instead. */
  export const outboundSchema = PayloadValidationErrorDtoValue$outboundSchema;
  /** @deprecated use `PayloadValidationErrorDtoValue$Outbound` instead. */
  export type Outbound = PayloadValidationErrorDtoValue$Outbound;
}

export function payloadValidationErrorDtoValueToJSON(
  payloadValidationErrorDtoValue: PayloadValidationErrorDtoValue
): string {
  return JSON.stringify(PayloadValidationErrorDtoValue$outboundSchema.parse(payloadValidationErrorDtoValue));
}

export function payloadValidationErrorDtoValueFromJSON(
  jsonString: string
): SafeParseResult<PayloadValidationErrorDtoValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PayloadValidationErrorDtoValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PayloadValidationErrorDtoValue' from JSON`
  );
}

/** @internal */
export const PayloadValidationErrorDto$inboundSchema: z.ZodType<PayloadValidationErrorDto, z.ZodTypeDef, unknown> =
  z.object({
    field: z.string(),
    message: z.string(),
    value: z
      .nullable(
        z.union([
          z.string(),
          z.number(),
          z.boolean(),
          z.lazy(() => Value4$inboundSchema),
          z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
        ])
      )
      .optional(),
    schemaPath: z.string().optional(),
  });

/** @internal */
export type PayloadValidationErrorDto$Outbound = {
  field: string;
  message: string;
  value?:
    | string
    | number
    | boolean
    | Value4$Outbound
    | Array<string | number | boolean | { [k: string]: any } | null>
    | null
    | undefined;
  schemaPath?: string | undefined;
};

/** @internal */
export const PayloadValidationErrorDto$outboundSchema: z.ZodType<
  PayloadValidationErrorDto$Outbound,
  z.ZodTypeDef,
  PayloadValidationErrorDto
> = z.object({
  field: z.string(),
  message: z.string(),
  value: z
    .nullable(
      z.union([
        z.string(),
        z.number(),
        z.boolean(),
        z.lazy(() => Value4$outboundSchema),
        z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
      ])
    )
    .optional(),
  schemaPath: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PayloadValidationErrorDto$ {
  /** @deprecated use `PayloadValidationErrorDto$inboundSchema` instead. */
  export const inboundSchema = PayloadValidationErrorDto$inboundSchema;
  /** @deprecated use `PayloadValidationErrorDto$outboundSchema` instead. */
  export const outboundSchema = PayloadValidationErrorDto$outboundSchema;
  /** @deprecated use `PayloadValidationErrorDto$Outbound` instead. */
  export type Outbound = PayloadValidationErrorDto$Outbound;
}

export function payloadValidationErrorDtoToJSON(payloadValidationErrorDto: PayloadValidationErrorDto): string {
  return JSON.stringify(PayloadValidationErrorDto$outboundSchema.parse(payloadValidationErrorDto));
}

export function payloadValidationErrorDtoFromJSON(
  jsonString: string
): SafeParseResult<PayloadValidationErrorDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PayloadValidationErrorDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PayloadValidationErrorDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - value5ToJSON(value5: Value5)
 - value5FromJSON(jsonString: string)
 - value4ToJSON(value4: Value4)
 - value4FromJSON(jsonString: string)
 - payloadValidationErrorDtoValueToJSON(payloadValidationErrorDtoValue: PayloadValidationErrorDtoValue)
 - payloadValidationErrorDtoValueFromJSON(jsonString: string)
 - payloadValidationErrorDtoToJSON(payloadValidationErrorDto: PayloadValidationErrorDto)
 - payloadValidationErrorDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Value5$Outbound;
}

export function value5ToJSON(value5: Value5): string {
  return JSON.stringify(V...)
 - Outbound(Value4$Outbound;
}

export function value4ToJSON(value4: Value4): string {
  return JSON.stringify(V...)
 - Outbound(PayloadValidationErrorDtoValue$Outbound;
}

export function payloadValidationErrorDtoValueToJSON(
  ...)
 - Outbound(PayloadValidationErrorDto$Outbound;
}

export function payloadValidationErrorDtoToJSON(payloadValida...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function value5ToJSON
- export function value5FromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function value4ToJSON
- export function value4FromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function payloadValidationErrorDtoValueToJSON
- export function payloadValidationErrorDtoValueFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function payloadValidationErrorDtoToJSON
- export function payloadValidationErrorDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/preferencelevelenum.ts
Tamaño: 1216 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * The level of the preference (global or template)
 */
export const PreferenceLevelEnum = {
  Global: 'global',
  Template: 'template',
} as const;
/**
 * The level of the preference (global or template)
 */
export type PreferenceLevelEnum = ClosedEnum<typeof PreferenceLevelEnum>;

/** @internal */
export const PreferenceLevelEnum$inboundSchema: z.ZodNativeEnum<typeof PreferenceLevelEnum> =
  z.nativeEnum(PreferenceLevelEnum);

/** @internal */
export const PreferenceLevelEnum$outboundSchema: z.ZodNativeEnum<typeof PreferenceLevelEnum> =
  PreferenceLevelEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PreferenceLevelEnum$ {
  /** @deprecated use `PreferenceLevelEnum$inboundSchema` instead. */
  export const inboundSchema = PreferenceLevelEnum$inboundSchema;
  /** @deprecated use `PreferenceLevelEnum$outboundSchema` instead. */
  export const outboundSchema = PreferenceLevelEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/preferenceoverridesourceenum.ts
Tamaño: 1340 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * The source of overrides
 */
export const PreferenceOverrideSourceEnum = {
  Subscriber: 'subscriber',
  Template: 'template',
  WorkflowOverride: 'workflowOverride',
} as const;
/**
 * The source of overrides
 */
export type PreferenceOverrideSourceEnum = ClosedEnum<typeof PreferenceOverrideSourceEnum>;

/** @internal */
export const PreferenceOverrideSourceEnum$inboundSchema: z.ZodNativeEnum<typeof PreferenceOverrideSourceEnum> =
  z.nativeEnum(PreferenceOverrideSourceEnum);

/** @internal */
export const PreferenceOverrideSourceEnum$outboundSchema: z.ZodNativeEnum<typeof PreferenceOverrideSourceEnum> =
  PreferenceOverrideSourceEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PreferenceOverrideSourceEnum$ {
  /** @deprecated use `PreferenceOverrideSourceEnum$inboundSchema` instead. */
  export const inboundSchema = PreferenceOverrideSourceEnum$inboundSchema;
  /** @deprecated use `PreferenceOverrideSourceEnum$outboundSchema` instead. */
  export const outboundSchema = PreferenceOverrideSourceEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/preferencesrequestdto.ts
Tamaño: 11981 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ChannelPreferenceDto,
  ChannelPreferenceDto$inboundSchema,
  ChannelPreferenceDto$Outbound,
  ChannelPreferenceDto$outboundSchema,
} from './channelpreferencedto.js';
import {
  WorkflowPreferenceDto,
  WorkflowPreferenceDto$inboundSchema,
  WorkflowPreferenceDto$Outbound,
  WorkflowPreferenceDto$outboundSchema,
} from './workflowpreferencedto.js';

/**
 * A preference for the workflow. The values specified here will be used if no preference is specified for a channel.
 */
export type UserAll = WorkflowPreferenceDto;

export type UserWorkflowPreferencesDto = {
  /**
   * A preference for the workflow. The values specified here will be used if no preference is specified for a channel.
   */
  all: WorkflowPreferenceDto;
  /**
   * Preferences for different communication channels
   */
  channels: { [k: string]: ChannelPreferenceDto };
};

/**
 * User workflow preferences
 */
export type User = UserWorkflowPreferencesDto;

/**
 * A preference for the workflow. The values specified here will be used if no preference is specified for a channel.
 */
export type PreferencesRequestDtoAll = WorkflowPreferenceDto;

/**
 * Workflow-specific preferences
 */
export type PreferencesRequestDtoWorkflow = {
  /**
   * A preference for the workflow. The values specified here will be used if no preference is specified for a channel.
   */
  all: WorkflowPreferenceDto;
  /**
   * Preferences for different communication channels
   */
  channels: { [k: string]: ChannelPreferenceDto };
};

export type PreferencesRequestDto = {
  /**
   * User workflow preferences
   */
  user?: UserWorkflowPreferencesDto | null | undefined;
  /**
   * Workflow-specific preferences
   */
  workflow?: PreferencesRequestDtoWorkflow | null | undefined;
};

/** @internal */
export const UserAll$inboundSchema: z.ZodType<UserAll, z.ZodTypeDef, unknown> = WorkflowPreferenceDto$inboundSchema;

/** @internal */
export type UserAll$Outbound = WorkflowPreferenceDto$Outbound;

/** @internal */
export const UserAll$outboundSchema: z.ZodType<UserAll$Outbound, z.ZodTypeDef, UserAll> =
  WorkflowPreferenceDto$outboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UserAll$ {
  /** @deprecated use `UserAll$inboundSchema` instead. */
  export const inboundSchema = UserAll$inboundSchema;
  /** @deprecated use `UserAll$outboundSchema` instead. */
  export const outboundSchema = UserAll$outboundSchema;
  /** @deprecated use `UserAll$Outbound` instead. */
  export type Outbound = UserAll$Outbound;
}

export function userAllToJSON(userAll: UserAll): string {
  return JSON.stringify(UserAll$outboundSchema.parse(userAll));
}

export function userAllFromJSON(jsonString: string): SafeParseResult<UserAll, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserAll$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserAll' from JSON`
  );
}

/** @internal */
export const UserWorkflowPreferencesDto$inboundSchema: z.ZodType<UserWorkflowPreferencesDto, z.ZodTypeDef, unknown> =
  z.object({
    all: WorkflowPreferenceDto$inboundSchema,
    channels: z.record(ChannelPreferenceDto$inboundSchema),
  });

/** @internal */
export type UserWorkflowPreferencesDto$Outbound = {
  all: WorkflowPreferenceDto$Outbound;
  channels: { [k: string]: ChannelPreferenceDto$Outbound };
};

/** @internal */
export const UserWorkflowPreferencesDto$outboundSchema: z.ZodType<
  UserWorkflowPreferencesDto$Outbound,
  z.ZodTypeDef,
  UserWorkflowPreferencesDto
> = z.object({
  all: WorkflowPreferenceDto$outboundSchema,
  channels: z.record(ChannelPreferenceDto$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UserWorkflowPreferencesDto$ {
  /** @deprecated use `UserWorkflowPreferencesDto$inboundSchema` instead. */
  export const inboundSchema = UserWorkflowPreferencesDto$inboundSchema;
  /** @deprecated use `UserWorkflowPreferencesDto$outboundSchema` instead. */
  export const outboundSchema = UserWorkflowPreferencesDto$outboundSchema;
  /** @deprecated use `UserWorkflowPreferencesDto$Outbound` instead. */
  export type Outbound = UserWorkflowPreferencesDto$Outbound;
}

export function userWorkflowPreferencesDtoToJSON(userWorkflowPreferencesDto: UserWorkflowPreferencesDto): string {
  return JSON.stringify(UserWorkflowPreferencesDto$outboundSchema.parse(userWorkflowPreferencesDto));
}

export function userWorkflowPreferencesDtoFromJSON(
  jsonString: string
): SafeParseResult<UserWorkflowPreferencesDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserWorkflowPreferencesDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserWorkflowPreferencesDto' from JSON`
  );
}

/** @internal */
export const User$inboundSchema: z.ZodType<User, z.ZodTypeDef, unknown> = z.lazy(
  () => UserWorkflowPreferencesDto$inboundSchema
);

/** @internal */
export type User$Outbound = UserWorkflowPreferencesDto$Outbound;

/** @internal */
export const User$outboundSchema: z.ZodType<User$Outbound, z.ZodTypeDef, User> = z.lazy(
  () => UserWorkflowPreferencesDto$outboundSchema
);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace User$ {
  /** @deprecated use `User$inboundSchema` instead. */
  export const inboundSchema = User$inboundSchema;
  /** @deprecated use `User$outboundSchema` instead. */
  export const outboundSchema = User$outboundSchema;
  /** @deprecated use `User$Outbound` instead. */
  export type Outbound = User$Outbound;
}

export function userToJSON(user: User): string {
  return JSON.stringify(User$outboundSchema.parse(user));
}

export function userFromJSON(jsonString: string): SafeParseResult<User, SDKValidationError> {
  return safeParse(jsonString, (x) => User$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'User' from JSON`);
}

/** @internal */
export const PreferencesRequestDtoAll$inboundSchema: z.ZodType<PreferencesRequestDtoAll, z.ZodTypeDef, unknown> =
  WorkflowPreferenceDto$inboundSchema;

/** @internal */
export type PreferencesRequestDtoAll$Outbound = WorkflowPreferenceDto$Outbound;

/** @internal */
export const PreferencesRequestDtoAll$outboundSchema: z.ZodType<
  PreferencesRequestDtoAll$Outbound,
  z.ZodTypeDef,
  PreferencesRequestDtoAll
> = WorkflowPreferenceDto$outboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PreferencesRequestDtoAll$ {
  /** @deprecated use `PreferencesRequestDtoAll$inboundSchema` instead. */
  export const inboundSchema = PreferencesRequestDtoAll$inboundSchema;
  /** @deprecated use `PreferencesRequestDtoAll$outboundSchema` instead. */
  export const outboundSchema = PreferencesRequestDtoAll$outboundSchema;
  /** @deprecated use `PreferencesRequestDtoAll$Outbound` instead. */
  export type Outbound = PreferencesRequestDtoAll$Outbound;
}

export function preferencesRequestDtoAllToJSON(preferencesRequestDtoAll: PreferencesRequestDtoAll): string {
  return JSON.stringify(PreferencesRequestDtoAll$outboundSchema.parse(preferencesRequestDtoAll));
}

export function preferencesRequestDtoAllFromJSON(
  jsonString: string
): SafeParseResult<PreferencesRequestDtoAll, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PreferencesRequestDtoAll$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PreferencesRequestDtoAll' from JSON`
  );
}

/** @internal */
export const PreferencesRequestDtoWorkflow$inboundSchema: z.ZodType<
  PreferencesRequestDtoWorkflow,
  z.ZodTypeDef,
  unknown
> = z.object({
  all: WorkflowPreferenceDto$inboundSchema,
  channels: z.record(ChannelPreferenceDto$inboundSchema),
});

/** @internal */
export type PreferencesRequestDtoWorkflow$Outbound = {
  all: WorkflowPreferenceDto$Outbound;
  channels: { [k: string]: ChannelPreferenceDto$Outbound };
};

/** @internal */
export const PreferencesRequestDtoWorkflow$outboundSchema: z.ZodType<
  PreferencesRequestDtoWorkflow$Outbound,
  z.ZodTypeDef,
  PreferencesRequestDtoWorkflow
> = z.object({
  all: WorkflowPreferenceDto$outboundSchema,
  channels: z.record(ChannelPreferenceDto$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PreferencesRequestDtoWorkflow$ {
  /** @deprecated use `PreferencesRequestDtoWorkflow$inboundSchema` instead. */
  export const inboundSchema = PreferencesRequestDtoWorkflow$inboundSchema;
  /** @deprecated use `PreferencesRequestDtoWorkflow$outboundSchema` instead. */
  export const outboundSchema = PreferencesRequestDtoWorkflow$outboundSchema;
  /** @deprecated use `PreferencesRequestDtoWorkflow$Outbound` instead. */
  export type Outbound = PreferencesRequestDtoWorkflow$Outbound;
}

export function preferencesRequestDtoWorkflowToJSON(
  preferencesRequestDtoWorkflow: PreferencesRequestDtoWorkflow
): string {
  return JSON.stringify(PreferencesRequestDtoWorkflow$outboundSchema.parse(preferencesRequestDtoWorkflow));
}

export function preferencesRequestDtoWorkflowFromJSON(
  jsonString: string
): SafeParseResult<PreferencesRequestDtoWorkflow, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PreferencesRequestDtoWorkflow$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PreferencesRequestDtoWorkflow' from JSON`
  );
}

/** @internal */
export const PreferencesRequestDto$inboundSchema: z.ZodType<PreferencesRequestDto, z.ZodTypeDef, unknown> = z.object({
  user: z.nullable(z.lazy(() => UserWorkflowPreferencesDto$inboundSchema)).optional(),
  workflow: z.nullable(z.lazy(() => PreferencesRequestDtoWorkflow$inboundSchema)).optional(),
});

/** @internal */
export type PreferencesRequestDto$Outbound = {
  user?: UserWorkflowPreferencesDto$Outbound | null | undefined;
  workflow?: PreferencesRequestDtoWorkflow$Outbound | null | undefined;
};

/** @internal */
export const PreferencesRequestDto$outboundSchema: z.ZodType<
  PreferencesRequestDto$Outbound,
  z.ZodTypeDef,
  PreferencesRequestDto
> = z.object({
  user: z.nullable(z.lazy(() => UserWorkflowPreferencesDto$outboundSchema)).optional(),
  workflow: z.nullable(z.lazy(() => PreferencesRequestDtoWorkflow$outboundSchema)).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PreferencesRequestDto$ {
  /** @deprecated use `PreferencesRequestDto$inboundSchema` instead. */
  export const inboundSchema = PreferencesRequestDto$inboundSchema;
  /** @deprecated use `PreferencesRequestDto$outboundSchema` instead. */
  export const outboundSchema = PreferencesRequestDto$outboundSchema;
  /** @deprecated use `PreferencesRequestDto$Outbound` instead. */
  export type Outbound = PreferencesRequestDto$Outbound;
}

export function preferencesRequestDtoToJSON(preferencesRequestDto: PreferencesRequestDto): string {
  return JSON.stringify(PreferencesRequestDto$outboundSchema.parse(preferencesRequestDto));
}

export function preferencesRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<PreferencesRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PreferencesRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PreferencesRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - userAllToJSON(userAll: UserAll)
 - userAllFromJSON(jsonString: string)
 - userWorkflowPreferencesDtoToJSON(userWorkflowPreferencesDto: UserWorkflowPreferencesDto)
 - userWorkflowPreferencesDtoFromJSON(jsonString: string)
 - userToJSON(user: User)
 - userFromJSON(jsonString: string)
 - preferencesRequestDtoAllToJSON(preferencesRequestDtoAll: PreferencesRequestDtoAll)
 - preferencesRequestDtoAllFromJSON(jsonString: string)
 - preferencesRequestDtoWorkflowToJSON(preferencesRequestDtoWorkflow: PreferencesRequestDtoWorkflow)
 - preferencesRequestDtoWorkflowFromJSON(jsonString: string)
 - preferencesRequestDtoToJSON(preferencesRequestDto: PreferencesRequestDto)
 - preferencesRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(UserAll$Outbound;
}

export function userAllToJSON(userAll: UserAll): string {
  return JSON.stringi...)
 - Outbound(UserWorkflowPreferencesDto$Outbound;
}

export function userWorkflowPreferencesDtoToJSON(userWorkflo...)
 - Outbound(User$Outbound;
}

export function userToJSON(user: User): string {
  return JSON.stringify(User$outb...)
 - Outbound(PreferencesRequestDtoAll$Outbound;
}

export function preferencesRequestDtoAllToJSON(preferencesRequ...)
 - Outbound(PreferencesRequestDtoWorkflow$Outbound;
}

export function preferencesRequestDtoWorkflowToJSON(
  pr...)
 - Outbound(PreferencesRequestDto$Outbound;
}

export function preferencesRequestDtoToJSON(preferencesRequestDto...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function userAllToJSON
- export function userAllFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function userWorkflowPreferencesDtoToJSON
- export function userWorkflowPreferencesDtoFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function userToJSON
- export function userFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function preferencesRequestDtoAllToJSON
- export function preferencesRequestDtoAllFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function preferencesRequestDtoWorkflowToJSON
- export function preferencesRequestDtoWorkflowFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function preferencesRequestDtoToJSON
- export function preferencesRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/previewpayloaddto.ts
Tamaño: 5688 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  SubscriberResponseDtoOptional,
  SubscriberResponseDtoOptional$inboundSchema,
  SubscriberResponseDtoOptional$Outbound,
  SubscriberResponseDtoOptional$outboundSchema,
} from './subscriberresponsedtooptional.js';

/**
 * Rich context object with id and optional data
 */
export type Two = {
  id: string;
  /**
   * Optional additional context data
   */
  data?: { [k: string]: any } | undefined;
};

export type Context = Two | string;

export type PreviewPayloadDto = {
  /**
   * Partial subscriber information
   */
  subscriber?: SubscriberResponseDtoOptional | undefined;
  /**
   * Payload data
   */
  payload?: { [k: string]: any } | undefined;
  /**
   * Steps data
   */
  steps?: { [k: string]: any } | undefined;
  context?: { [k: string]: Two | string } | undefined;
};

/** @internal */
export const Two$inboundSchema: z.ZodType<Two, z.ZodTypeDef, unknown> = z.object({
  id: z.string(),
  data: z.record(z.any()).optional(),
});

/** @internal */
export type Two$Outbound = {
  id: string;
  data?: { [k: string]: any } | undefined;
};

/** @internal */
export const Two$outboundSchema: z.ZodType<Two$Outbound, z.ZodTypeDef, Two> = z.object({
  id: z.string(),
  data: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Two$ {
  /** @deprecated use `Two$inboundSchema` instead. */
  export const inboundSchema = Two$inboundSchema;
  /** @deprecated use `Two$outboundSchema` instead. */
  export const outboundSchema = Two$outboundSchema;
  /** @deprecated use `Two$Outbound` instead. */
  export type Outbound = Two$Outbound;
}

export function twoToJSON(two: Two): string {
  return JSON.stringify(Two$outboundSchema.parse(two));
}

export function twoFromJSON(jsonString: string): SafeParseResult<Two, SDKValidationError> {
  return safeParse(jsonString, (x) => Two$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Two' from JSON`);
}

/** @internal */
export const Context$inboundSchema: z.ZodType<Context, z.ZodTypeDef, unknown> = z.union([
  z.lazy(() => Two$inboundSchema),
  z.string(),
]);

/** @internal */
export type Context$Outbound = Two$Outbound | string;

/** @internal */
export const Context$outboundSchema: z.ZodType<Context$Outbound, z.ZodTypeDef, Context> = z.union([
  z.lazy(() => Two$outboundSchema),
  z.string(),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Context$ {
  /** @deprecated use `Context$inboundSchema` instead. */
  export const inboundSchema = Context$inboundSchema;
  /** @deprecated use `Context$outboundSchema` instead. */
  export const outboundSchema = Context$outboundSchema;
  /** @deprecated use `Context$Outbound` instead. */
  export type Outbound = Context$Outbound;
}

export function contextToJSON(context: Context): string {
  return JSON.stringify(Context$outboundSchema.parse(context));
}

export function contextFromJSON(jsonString: string): SafeParseResult<Context, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Context$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Context' from JSON`
  );
}

/** @internal */
export const PreviewPayloadDto$inboundSchema: z.ZodType<PreviewPayloadDto, z.ZodTypeDef, unknown> = z.object({
  subscriber: SubscriberResponseDtoOptional$inboundSchema.optional(),
  payload: z.record(z.any()).optional(),
  steps: z.record(z.any()).optional(),
  context: z.record(z.union([z.lazy(() => Two$inboundSchema), z.string()])).optional(),
});

/** @internal */
export type PreviewPayloadDto$Outbound = {
  subscriber?: SubscriberResponseDtoOptional$Outbound | undefined;
  payload?: { [k: string]: any } | undefined;
  steps?: { [k: string]: any } | undefined;
  context?: { [k: string]: Two$Outbound | string } | undefined;
};

/** @internal */
export const PreviewPayloadDto$outboundSchema: z.ZodType<PreviewPayloadDto$Outbound, z.ZodTypeDef, PreviewPayloadDto> =
  z.object({
    subscriber: SubscriberResponseDtoOptional$outboundSchema.optional(),
    payload: z.record(z.any()).optional(),
    steps: z.record(z.any()).optional(),
    context: z.record(z.union([z.lazy(() => Two$outboundSchema), z.string()])).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PreviewPayloadDto$ {
  /** @deprecated use `PreviewPayloadDto$inboundSchema` instead. */
  export const inboundSchema = PreviewPayloadDto$inboundSchema;
  /** @deprecated use `PreviewPayloadDto$outboundSchema` instead. */
  export const outboundSchema = PreviewPayloadDto$outboundSchema;
  /** @deprecated use `PreviewPayloadDto$Outbound` instead. */
  export type Outbound = PreviewPayloadDto$Outbound;
}

export function previewPayloadDtoToJSON(previewPayloadDto: PreviewPayloadDto): string {
  return JSON.stringify(PreviewPayloadDto$outboundSchema.parse(previewPayloadDto));
}

export function previewPayloadDtoFromJSON(jsonString: string): SafeParseResult<PreviewPayloadDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PreviewPayloadDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PreviewPayloadDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - twoToJSON(two: Two)
 - twoFromJSON(jsonString: string)
 - contextToJSON(context: Context)
 - contextFromJSON(jsonString: string)
 - previewPayloadDtoToJSON(previewPayloadDto: PreviewPayloadDto)
 - previewPayloadDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Two$Outbound;
}

export function twoToJSON(two: Two): string {
  return JSON.stringify(Two$outboundS...)
 - Outbound(Context$Outbound;
}

export function contextToJSON(context: Context): string {
  return JSON.stringi...)
 - Outbound(PreviewPayloadDto$Outbound;
}

export function previewPayloadDtoToJSON(previewPayloadDto: PreviewPay...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function twoToJSON
- export function twoFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function contextToJSON
- export function contextFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function previewPayloadDtoToJSON
- export function previewPayloadDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/providersidenum.ts
Tamaño: 2921 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Provider ID of the job
 */
export const ProvidersIdEnum = {
  Emailjs: 'emailjs',
  Mailgun: 'mailgun',
  Mailjet: 'mailjet',
  Mandrill: 'mandrill',
  Nodemailer: 'nodemailer',
  Postmark: 'postmark',
  Sendgrid: 'sendgrid',
  Sendinblue: 'sendinblue',
  Ses: 'ses',
  Netcore: 'netcore',
  InfobipEmail: 'infobip-email',
  Resend: 'resend',
  Plunk: 'plunk',
  Mailersend: 'mailersend',
  Mailtrap: 'mailtrap',
  Clickatell: 'clickatell',
  Outlook365: 'outlook365',
  NovuEmail: 'novu-email',
  Sparkpost: 'sparkpost',
  EmailWebhook: 'email-webhook',
  Braze: 'braze',
  Nexmo: 'nexmo',
  Plivo: 'plivo',
  Sms77: 'sms77',
  SmsCentral: 'sms-central',
  Sns: 'sns',
  Telnyx: 'telnyx',
  Twilio: 'twilio',
  Gupshup: 'gupshup',
  Firetext: 'firetext',
  InfobipSms: 'infobip-sms',
  BurstSms: 'burst-sms',
  BulkSms: 'bulk-sms',
  IsendSms: 'isend-sms',
  FortySixElks: 'forty-six-elks',
  Kannel: 'kannel',
  Maqsam: 'maqsam',
  Termii: 'termii',
  AfricasTalking: 'africas-talking',
  NovuSms: 'novu-sms',
  Sendchamp: 'sendchamp',
  GenericSms: 'generic-sms',
  Clicksend: 'clicksend',
  Bandwidth: 'bandwidth',
  Messagebird: 'messagebird',
  Simpletexting: 'simpletexting',
  AzureSms: 'azure-sms',
  RingCentral: 'ring-central',
  BrevoSms: 'brevo-sms',
  EazySms: 'eazy-sms',
  Mobishastra: 'mobishastra',
  AfroMessage: 'afro-message',
  Unifonic: 'unifonic',
  Smsmode: 'smsmode',
  Imedia: 'imedia',
  Sinch: 'sinch',
  Fcm: 'fcm',
  Apns: 'apns',
  Expo: 'expo',
  OneSignal: 'one-signal',
  Pushpad: 'pushpad',
  PushWebhook: 'push-webhook',
  PusherBeams: 'pusher-beams',
  Novu: 'novu',
  Slack: 'slack',
  Discord: 'discord',
  Msteams: 'msteams',
  Mattermost: 'mattermost',
  Ryver: 'ryver',
  Zulip: 'zulip',
  GrafanaOnCall: 'grafana-on-call',
  Getstream: 'getstream',
  RocketChat: 'rocket-chat',
  WhatsappBusiness: 'whatsapp-business',
  ChatWebhook: 'chat-webhook',
  NovuSlack: 'novu-slack',
} as const;
/**
 * Provider ID of the job
 */
export type ProvidersIdEnum = ClosedEnum<typeof ProvidersIdEnum>;

/** @internal */
export const ProvidersIdEnum$inboundSchema: z.ZodNativeEnum<typeof ProvidersIdEnum> = z.nativeEnum(ProvidersIdEnum);

/** @internal */
export const ProvidersIdEnum$outboundSchema: z.ZodNativeEnum<typeof ProvidersIdEnum> = ProvidersIdEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ProvidersIdEnum$ {
  /** @deprecated use `ProvidersIdEnum$inboundSchema` instead. */
  export const inboundSchema = ProvidersIdEnum$inboundSchema;
  /** @deprecated use `ProvidersIdEnum$outboundSchema` instead. */
  export const outboundSchema = ProvidersIdEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/pushcontroldto.ts
Tamaño: 2403 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type PushControlDto = {
  /**
   * JSONLogic filter conditions for conditionally skipping the step execution. Supports complex logical operations with AND, OR, and comparison operators. See https://jsonlogic.com/ for full typing reference.
   */
  skip?: { [k: string]: any } | undefined;
  /**
   * Subject/title of the push notification.
   */
  subject?: string | undefined;
  /**
   * Body content of the push notification.
   */
  body?: string | undefined;
};

/** @internal */
export const PushControlDto$inboundSchema: z.ZodType<PushControlDto, z.ZodTypeDef, unknown> = z.object({
  skip: z.record(z.any()).optional(),
  subject: z.string().optional(),
  body: z.string().optional(),
});

/** @internal */
export type PushControlDto$Outbound = {
  skip?: { [k: string]: any } | undefined;
  subject?: string | undefined;
  body?: string | undefined;
};

/** @internal */
export const PushControlDto$outboundSchema: z.ZodType<PushControlDto$Outbound, z.ZodTypeDef, PushControlDto> = z.object(
  {
    skip: z.record(z.any()).optional(),
    subject: z.string().optional(),
    body: z.string().optional(),
  }
);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PushControlDto$ {
  /** @deprecated use `PushControlDto$inboundSchema` instead. */
  export const inboundSchema = PushControlDto$inboundSchema;
  /** @deprecated use `PushControlDto$outboundSchema` instead. */
  export const outboundSchema = PushControlDto$outboundSchema;
  /** @deprecated use `PushControlDto$Outbound` instead. */
  export type Outbound = PushControlDto$Outbound;
}

export function pushControlDtoToJSON(pushControlDto: PushControlDto): string {
  return JSON.stringify(PushControlDto$outboundSchema.parse(pushControlDto));
}

export function pushControlDtoFromJSON(jsonString: string): SafeParseResult<PushControlDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PushControlDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PushControlDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - pushControlDtoToJSON(pushControlDto: PushControlDto)
 - pushControlDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(PushControlDto$Outbound;
}

export function pushControlDtoToJSON(pushControlDto: PushControlDto): st...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function pushControlDtoToJSON
- export function pushControlDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/pushcontrolsmetadataresponsedto.ts
Tamaño: 2946 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  PushControlDto,
  PushControlDto$inboundSchema,
  PushControlDto$Outbound,
  PushControlDto$outboundSchema,
} from './pushcontroldto.js';
import { UiSchema, UiSchema$inboundSchema, UiSchema$Outbound, UiSchema$outboundSchema } from './uischema.js';

export type PushControlsMetadataResponseDto = {
  /**
   * JSON Schema for data
   */
  dataSchema?: { [k: string]: any } | undefined;
  /**
   * UI Schema for rendering
   */
  uiSchema?: UiSchema | undefined;
  /**
   * Control values specific to Push
   */
  values: PushControlDto;
};

/** @internal */
export const PushControlsMetadataResponseDto$inboundSchema: z.ZodType<
  PushControlsMetadataResponseDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  dataSchema: z.record(z.any()).optional(),
  uiSchema: UiSchema$inboundSchema.optional(),
  values: PushControlDto$inboundSchema,
});

/** @internal */
export type PushControlsMetadataResponseDto$Outbound = {
  dataSchema?: { [k: string]: any } | undefined;
  uiSchema?: UiSchema$Outbound | undefined;
  values: PushControlDto$Outbound;
};

/** @internal */
export const PushControlsMetadataResponseDto$outboundSchema: z.ZodType<
  PushControlsMetadataResponseDto$Outbound,
  z.ZodTypeDef,
  PushControlsMetadataResponseDto
> = z.object({
  dataSchema: z.record(z.any()).optional(),
  uiSchema: UiSchema$outboundSchema.optional(),
  values: PushControlDto$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PushControlsMetadataResponseDto$ {
  /** @deprecated use `PushControlsMetadataResponseDto$inboundSchema` instead. */
  export const inboundSchema = PushControlsMetadataResponseDto$inboundSchema;
  /** @deprecated use `PushControlsMetadataResponseDto$outboundSchema` instead. */
  export const outboundSchema = PushControlsMetadataResponseDto$outboundSchema;
  /** @deprecated use `PushControlsMetadataResponseDto$Outbound` instead. */
  export type Outbound = PushControlsMetadataResponseDto$Outbound;
}

export function pushControlsMetadataResponseDtoToJSON(
  pushControlsMetadataResponseDto: PushControlsMetadataResponseDto
): string {
  return JSON.stringify(PushControlsMetadataResponseDto$outboundSchema.parse(pushControlsMetadataResponseDto));
}

export function pushControlsMetadataResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<PushControlsMetadataResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PushControlsMetadataResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PushControlsMetadataResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - pushControlsMetadataResponseDtoToJSON(pushControlsMetadataResponseDto: PushControlsMetadataResponseDto)
 - pushControlsMetadataResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(PushControlsMetadataResponseDto$Outbound;
}

export function pushControlsMetadataResponseDtoToJSON(
...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function pushControlsMetadataResponseDtoToJSON
- export function pushControlsMetadataResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/pushrenderoutput.ts
Tamaño: 1949 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type PushRenderOutput = {
  /**
   * Subject of the push notification
   */
  subject: string;
  /**
   * Body of the push notification
   */
  body: string;
};

/** @internal */
export const PushRenderOutput$inboundSchema: z.ZodType<PushRenderOutput, z.ZodTypeDef, unknown> = z.object({
  subject: z.string(),
  body: z.string(),
});

/** @internal */
export type PushRenderOutput$Outbound = {
  subject: string;
  body: string;
};

/** @internal */
export const PushRenderOutput$outboundSchema: z.ZodType<PushRenderOutput$Outbound, z.ZodTypeDef, PushRenderOutput> =
  z.object({
    subject: z.string(),
    body: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PushRenderOutput$ {
  /** @deprecated use `PushRenderOutput$inboundSchema` instead. */
  export const inboundSchema = PushRenderOutput$inboundSchema;
  /** @deprecated use `PushRenderOutput$outboundSchema` instead. */
  export const outboundSchema = PushRenderOutput$outboundSchema;
  /** @deprecated use `PushRenderOutput$Outbound` instead. */
  export type Outbound = PushRenderOutput$Outbound;
}

export function pushRenderOutputToJSON(pushRenderOutput: PushRenderOutput): string {
  return JSON.stringify(PushRenderOutput$outboundSchema.parse(pushRenderOutput));
}

export function pushRenderOutputFromJSON(jsonString: string): SafeParseResult<PushRenderOutput, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PushRenderOutput$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PushRenderOutput' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - pushRenderOutputToJSON(pushRenderOutput: PushRenderOutput)
 - pushRenderOutputFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(PushRenderOutput$Outbound;
}

export function pushRenderOutputToJSON(pushRenderOutput: PushRenderOut...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function pushRenderOutputToJSON
- export function pushRenderOutputFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/pushstepresponsedto.ts
Tamaño: 7865 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { collectExtraKeys as collectExtraKeys$, safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  PushControlsMetadataResponseDto,
  PushControlsMetadataResponseDto$inboundSchema,
  PushControlsMetadataResponseDto$Outbound,
  PushControlsMetadataResponseDto$outboundSchema,
} from './pushcontrolsmetadataresponsedto.js';
import {
  ResourceOriginEnum,
  ResourceOriginEnum$inboundSchema,
  ResourceOriginEnum$outboundSchema,
} from './resourceoriginenum.js';
import {
  StepIssuesDto,
  StepIssuesDto$inboundSchema,
  StepIssuesDto$Outbound,
  StepIssuesDto$outboundSchema,
} from './stepissuesdto.js';
import { StepTypeEnum, StepTypeEnum$inboundSchema, StepTypeEnum$outboundSchema } from './steptypeenum.js';

/**
 * Control values for the push step
 */
export type PushStepResponseDtoControlValues = {
  /**
   * JSONLogic filter conditions for conditionally skipping the step execution. Supports complex logical operations with AND, OR, and comparison operators. See https://jsonlogic.com/ for full typing reference.
   */
  skip?: { [k: string]: any } | undefined;
  /**
   * Subject/title of the push notification.
   */
  subject?: string | undefined;
  /**
   * Body content of the push notification.
   */
  body?: string | undefined;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type PushStepResponseDto = {
  /**
   * Controls metadata for the push step
   */
  controls: PushControlsMetadataResponseDto;
  /**
   * Control values for the push step
   */
  controlValues?: PushStepResponseDtoControlValues | undefined;
  /**
   * JSON Schema for variables, follows the JSON Schema standard
   */
  variables: { [k: string]: any };
  /**
   * Unique identifier of the step
   */
  stepId: string;
  /**
   * Database identifier of the step
   */
  id: string;
  /**
   * Name of the step
   */
  name: string;
  /**
   * Slug of the step
   */
  slug: string;
  /**
   * Type of the step
   */
  type: StepTypeEnum;
  /**
   * Origin of the layout
   */
  origin: ResourceOriginEnum;
  /**
   * Workflow identifier
   */
  workflowId: string;
  /**
   * Workflow database identifier
   */
  workflowDatabaseId: string;
  /**
   * Issues associated with the step
   */
  issues?: StepIssuesDto | undefined;
};

/** @internal */
export const PushStepResponseDtoControlValues$inboundSchema: z.ZodType<
  PushStepResponseDtoControlValues,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z
    .object({
      skip: z.record(z.any()).optional(),
      subject: z.string().optional(),
      body: z.string().optional(),
    })
    .catchall(z.any()),
  'additionalProperties',
  true
);

/** @internal */
export type PushStepResponseDtoControlValues$Outbound = {
  skip?: { [k: string]: any } | undefined;
  subject?: string | undefined;
  body?: string | undefined;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const PushStepResponseDtoControlValues$outboundSchema: z.ZodType<
  PushStepResponseDtoControlValues$Outbound,
  z.ZodTypeDef,
  PushStepResponseDtoControlValues
> = z
  .object({
    skip: z.record(z.any()).optional(),
    subject: z.string().optional(),
    body: z.string().optional(),
    additionalProperties: z.record(z.any()).optional(),
  })
  .transform((v) => {
    return {
      ...v.additionalProperties,
      ...remap$(v, {
        additionalProperties: null,
      }),
    };
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PushStepResponseDtoControlValues$ {
  /** @deprecated use `PushStepResponseDtoControlValues$inboundSchema` instead. */
  export const inboundSchema = PushStepResponseDtoControlValues$inboundSchema;
  /** @deprecated use `PushStepResponseDtoControlValues$outboundSchema` instead. */
  export const outboundSchema = PushStepResponseDtoControlValues$outboundSchema;
  /** @deprecated use `PushStepResponseDtoControlValues$Outbound` instead. */
  export type Outbound = PushStepResponseDtoControlValues$Outbound;
}

export function pushStepResponseDtoControlValuesToJSON(
  pushStepResponseDtoControlValues: PushStepResponseDtoControlValues
): string {
  return JSON.stringify(PushStepResponseDtoControlValues$outboundSchema.parse(pushStepResponseDtoControlValues));
}

export function pushStepResponseDtoControlValuesFromJSON(
  jsonString: string
): SafeParseResult<PushStepResponseDtoControlValues, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PushStepResponseDtoControlValues$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PushStepResponseDtoControlValues' from JSON`
  );
}

/** @internal */
export const PushStepResponseDto$inboundSchema: z.ZodType<PushStepResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    controls: PushControlsMetadataResponseDto$inboundSchema,
    controlValues: z.lazy(() => PushStepResponseDtoControlValues$inboundSchema).optional(),
    variables: z.record(z.any()),
    stepId: z.string(),
    _id: z.string(),
    name: z.string(),
    slug: z.string(),
    type: StepTypeEnum$inboundSchema,
    origin: ResourceOriginEnum$inboundSchema,
    workflowId: z.string(),
    workflowDatabaseId: z.string(),
    issues: StepIssuesDto$inboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type PushStepResponseDto$Outbound = {
  controls: PushControlsMetadataResponseDto$Outbound;
  controlValues?: PushStepResponseDtoControlValues$Outbound | undefined;
  variables: { [k: string]: any };
  stepId: string;
  _id: string;
  name: string;
  slug: string;
  type: string;
  origin: string;
  workflowId: string;
  workflowDatabaseId: string;
  issues?: StepIssuesDto$Outbound | undefined;
};

/** @internal */
export const PushStepResponseDto$outboundSchema: z.ZodType<
  PushStepResponseDto$Outbound,
  z.ZodTypeDef,
  PushStepResponseDto
> = z
  .object({
    controls: PushControlsMetadataResponseDto$outboundSchema,
    controlValues: z.lazy(() => PushStepResponseDtoControlValues$outboundSchema).optional(),
    variables: z.record(z.any()),
    stepId: z.string(),
    id: z.string(),
    name: z.string(),
    slug: z.string(),
    type: StepTypeEnum$outboundSchema,
    origin: ResourceOriginEnum$outboundSchema,
    workflowId: z.string(),
    workflowDatabaseId: z.string(),
    issues: StepIssuesDto$outboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PushStepResponseDto$ {
  /** @deprecated use `PushStepResponseDto$inboundSchema` instead. */
  export const inboundSchema = PushStepResponseDto$inboundSchema;
  /** @deprecated use `PushStepResponseDto$outboundSchema` instead. */
  export const outboundSchema = PushStepResponseDto$outboundSchema;
  /** @deprecated use `PushStepResponseDto$Outbound` instead. */
  export type Outbound = PushStepResponseDto$Outbound;
}

export function pushStepResponseDtoToJSON(pushStepResponseDto: PushStepResponseDto): string {
  return JSON.stringify(PushStepResponseDto$outboundSchema.parse(pushStepResponseDto));
}

export function pushStepResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<PushStepResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PushStepResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PushStepResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - pushStepResponseDtoControlValuesToJSON(pushStepResponseDtoControlValues: PushStepResponseDtoControlValues)
 - pushStepResponseDtoControlValuesFromJSON(jsonString: string)
 - pushStepResponseDtoToJSON(pushStepResponseDto: PushStepResponseDto)
 - pushStepResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(PushStepResponseDtoControlValues$Outbound;
}

export function pushStepResponseDtoControlValuesToJSON...)
 - Outbound(PushStepResponseDto$Outbound;
}

export function pushStepResponseDtoToJSON(pushStepResponseDto: Push...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function pushStepResponseDtoControlValuesToJSON
- export function pushStepResponseDtoControlValuesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function pushStepResponseDtoToJSON
- export function pushStepResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/pushstepupsertdto.ts
Tamaño: 5201 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  PushControlDto,
  PushControlDto$inboundSchema,
  PushControlDto$Outbound,
  PushControlDto$outboundSchema,
} from './pushcontroldto.js';
import { StepTypeEnum, StepTypeEnum$inboundSchema, StepTypeEnum$outboundSchema } from './steptypeenum.js';

/**
 * Control values for the Push step.
 */
export type PushStepUpsertDtoControlValues =
  | PushControlDto
  | {
      [k: string]: any;
    };

export type PushStepUpsertDto = {
  /**
   * Database identifier of the step. Used for updating the step.
   */
  id?: string | undefined;
  /**
   * Unique identifier for the step
   */
  stepId?: string | undefined;
  /**
   * Name of the step
   */
  name: string;
  /**
   * Type of the step
   */
  type: StepTypeEnum;
  /**
   * Control values for the Push step.
   */
  controlValues?: PushControlDto | { [k: string]: any } | undefined;
};

/** @internal */
export const PushStepUpsertDtoControlValues$inboundSchema: z.ZodType<
  PushStepUpsertDtoControlValues,
  z.ZodTypeDef,
  unknown
> = z.union([PushControlDto$inboundSchema, z.record(z.any())]);

/** @internal */
export type PushStepUpsertDtoControlValues$Outbound = PushControlDto$Outbound | { [k: string]: any };

/** @internal */
export const PushStepUpsertDtoControlValues$outboundSchema: z.ZodType<
  PushStepUpsertDtoControlValues$Outbound,
  z.ZodTypeDef,
  PushStepUpsertDtoControlValues
> = z.union([PushControlDto$outboundSchema, z.record(z.any())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PushStepUpsertDtoControlValues$ {
  /** @deprecated use `PushStepUpsertDtoControlValues$inboundSchema` instead. */
  export const inboundSchema = PushStepUpsertDtoControlValues$inboundSchema;
  /** @deprecated use `PushStepUpsertDtoControlValues$outboundSchema` instead. */
  export const outboundSchema = PushStepUpsertDtoControlValues$outboundSchema;
  /** @deprecated use `PushStepUpsertDtoControlValues$Outbound` instead. */
  export type Outbound = PushStepUpsertDtoControlValues$Outbound;
}

export function pushStepUpsertDtoControlValuesToJSON(
  pushStepUpsertDtoControlValues: PushStepUpsertDtoControlValues
): string {
  return JSON.stringify(PushStepUpsertDtoControlValues$outboundSchema.parse(pushStepUpsertDtoControlValues));
}

export function pushStepUpsertDtoControlValuesFromJSON(
  jsonString: string
): SafeParseResult<PushStepUpsertDtoControlValues, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PushStepUpsertDtoControlValues$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PushStepUpsertDtoControlValues' from JSON`
  );
}

/** @internal */
export const PushStepUpsertDto$inboundSchema: z.ZodType<PushStepUpsertDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().optional(),
    stepId: z.string().optional(),
    name: z.string(),
    type: StepTypeEnum$inboundSchema,
    controlValues: z.union([PushControlDto$inboundSchema, z.record(z.any())]).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type PushStepUpsertDto$Outbound = {
  _id?: string | undefined;
  stepId?: string | undefined;
  name: string;
  type: string;
  controlValues?: PushControlDto$Outbound | { [k: string]: any } | undefined;
};

/** @internal */
export const PushStepUpsertDto$outboundSchema: z.ZodType<PushStepUpsertDto$Outbound, z.ZodTypeDef, PushStepUpsertDto> =
  z
    .object({
      id: z.string().optional(),
      stepId: z.string().optional(),
      name: z.string(),
      type: StepTypeEnum$outboundSchema,
      controlValues: z.union([PushControlDto$outboundSchema, z.record(z.any())]).optional(),
    })
    .transform((v) => {
      return remap$(v, {
        id: '_id',
      });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PushStepUpsertDto$ {
  /** @deprecated use `PushStepUpsertDto$inboundSchema` instead. */
  export const inboundSchema = PushStepUpsertDto$inboundSchema;
  /** @deprecated use `PushStepUpsertDto$outboundSchema` instead. */
  export const outboundSchema = PushStepUpsertDto$outboundSchema;
  /** @deprecated use `PushStepUpsertDto$Outbound` instead. */
  export type Outbound = PushStepUpsertDto$Outbound;
}

export function pushStepUpsertDtoToJSON(pushStepUpsertDto: PushStepUpsertDto): string {
  return JSON.stringify(PushStepUpsertDto$outboundSchema.parse(pushStepUpsertDto));
}

export function pushStepUpsertDtoFromJSON(jsonString: string): SafeParseResult<PushStepUpsertDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PushStepUpsertDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PushStepUpsertDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - pushStepUpsertDtoControlValuesToJSON(pushStepUpsertDtoControlValues: PushStepUpsertDtoControlValues)
 - pushStepUpsertDtoControlValuesFromJSON(jsonString: string)
 - pushStepUpsertDtoToJSON(pushStepUpsertDto: PushStepUpsertDto)
 - pushStepUpsertDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(PushStepUpsertDtoControlValues$Outbound;
}

export function pushStepUpsertDtoControlValuesToJSON(
  ...)
 - Outbound(PushStepUpsertDto$Outbound;
}

export function pushStepUpsertDtoToJSON(pushStepUpsertDto: PushStepUp...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function pushStepUpsertDtoControlValuesToJSON
- export function pushStepUpsertDtoControlValuesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function pushStepUpsertDtoToJSON
- export function pushStepUpsertDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/redirectdto.ts
Tamaño: 2943 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Target window for the redirection.
 */
export const Target = {
  Self: '_self',
  Blank: '_blank',
  Parent: '_parent',
  Top: '_top',
  UnfencedTop: '_unfencedTop',
} as const;
/**
 * Target window for the redirection.
 */
export type Target = ClosedEnum<typeof Target>;

export type RedirectDto = {
  /**
   * URL for redirection. Must be a valid URL or start with / or {{"{{"}} variable }}.
   */
  url?: string | undefined;
  /**
   * Target window for the redirection.
   */
  target?: Target | undefined;
};

/** @internal */
export const Target$inboundSchema: z.ZodNativeEnum<typeof Target> = z.nativeEnum(Target);

/** @internal */
export const Target$outboundSchema: z.ZodNativeEnum<typeof Target> = Target$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Target$ {
  /** @deprecated use `Target$inboundSchema` instead. */
  export const inboundSchema = Target$inboundSchema;
  /** @deprecated use `Target$outboundSchema` instead. */
  export const outboundSchema = Target$outboundSchema;
}

/** @internal */
export const RedirectDto$inboundSchema: z.ZodType<RedirectDto, z.ZodTypeDef, unknown> = z.object({
  url: z.string().optional(),
  target: Target$inboundSchema.default('_self'),
});

/** @internal */
export type RedirectDto$Outbound = {
  url?: string | undefined;
  target: string;
};

/** @internal */
export const RedirectDto$outboundSchema: z.ZodType<RedirectDto$Outbound, z.ZodTypeDef, RedirectDto> = z.object({
  url: z.string().optional(),
  target: Target$outboundSchema.default('_self'),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RedirectDto$ {
  /** @deprecated use `RedirectDto$inboundSchema` instead. */
  export const inboundSchema = RedirectDto$inboundSchema;
  /** @deprecated use `RedirectDto$outboundSchema` instead. */
  export const outboundSchema = RedirectDto$outboundSchema;
  /** @deprecated use `RedirectDto$Outbound` instead. */
  export type Outbound = RedirectDto$Outbound;
}

export function redirectDtoToJSON(redirectDto: RedirectDto): string {
  return JSON.stringify(RedirectDto$outboundSchema.parse(redirectDto));
}

export function redirectDtoFromJSON(jsonString: string): SafeParseResult<RedirectDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RedirectDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RedirectDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - redirectDtoToJSON(redirectDto: RedirectDto)
 - redirectDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(RedirectDto$Outbound;
}

export function redirectDtoToJSON(redirectDto: RedirectDto): string {
  ret...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function redirectDtoToJSON
- export function redirectDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/removesubscriberresponsedto.ts
Tamaño: 2289 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type RemoveSubscriberResponseDto = {
  /**
   * Indicates whether the operation was acknowledged by the server
   */
  acknowledged: boolean;
  /**
   * Status of the subscriber removal operation
   */
  status: string;
};

/** @internal */
export const RemoveSubscriberResponseDto$inboundSchema: z.ZodType<RemoveSubscriberResponseDto, z.ZodTypeDef, unknown> =
  z.object({
    acknowledged: z.boolean(),
    status: z.string(),
  });

/** @internal */
export type RemoveSubscriberResponseDto$Outbound = {
  acknowledged: boolean;
  status: string;
};

/** @internal */
export const RemoveSubscriberResponseDto$outboundSchema: z.ZodType<
  RemoveSubscriberResponseDto$Outbound,
  z.ZodTypeDef,
  RemoveSubscriberResponseDto
> = z.object({
  acknowledged: z.boolean(),
  status: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RemoveSubscriberResponseDto$ {
  /** @deprecated use `RemoveSubscriberResponseDto$inboundSchema` instead. */
  export const inboundSchema = RemoveSubscriberResponseDto$inboundSchema;
  /** @deprecated use `RemoveSubscriberResponseDto$outboundSchema` instead. */
  export const outboundSchema = RemoveSubscriberResponseDto$outboundSchema;
  /** @deprecated use `RemoveSubscriberResponseDto$Outbound` instead. */
  export type Outbound = RemoveSubscriberResponseDto$Outbound;
}

export function removeSubscriberResponseDtoToJSON(removeSubscriberResponseDto: RemoveSubscriberResponseDto): string {
  return JSON.stringify(RemoveSubscriberResponseDto$outboundSchema.parse(removeSubscriberResponseDto));
}

export function removeSubscriberResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<RemoveSubscriberResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RemoveSubscriberResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RemoveSubscriberResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - removeSubscriberResponseDtoToJSON(removeSubscriberResponseDto: RemoveSubscriberResponseDto)
 - removeSubscriberResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(RemoveSubscriberResponseDto$Outbound;
}

export function removeSubscriberResponseDtoToJSON(removeSub...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function removeSubscriberResponseDtoToJSON
- export function removeSubscriberResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/replycallback.ts
Tamaño: 1990 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type ReplyCallback = {
  /**
   * Indicates whether the reply callback is active.
   */
  active?: boolean | undefined;
  /**
   * The URL to which replies should be sent.
   */
  url?: string | undefined;
};

/** @internal */
export const ReplyCallback$inboundSchema: z.ZodType<ReplyCallback, z.ZodTypeDef, unknown> = z.object({
  active: z.boolean().optional(),
  url: z.string().optional(),
});

/** @internal */
export type ReplyCallback$Outbound = {
  active?: boolean | undefined;
  url?: string | undefined;
};

/** @internal */
export const ReplyCallback$outboundSchema: z.ZodType<ReplyCallback$Outbound, z.ZodTypeDef, ReplyCallback> = z.object({
  active: z.boolean().optional(),
  url: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ReplyCallback$ {
  /** @deprecated use `ReplyCallback$inboundSchema` instead. */
  export const inboundSchema = ReplyCallback$inboundSchema;
  /** @deprecated use `ReplyCallback$outboundSchema` instead. */
  export const outboundSchema = ReplyCallback$outboundSchema;
  /** @deprecated use `ReplyCallback$Outbound` instead. */
  export type Outbound = ReplyCallback$Outbound;
}

export function replyCallbackToJSON(replyCallback: ReplyCallback): string {
  return JSON.stringify(ReplyCallback$outboundSchema.parse(replyCallback));
}

export function replyCallbackFromJSON(jsonString: string): SafeParseResult<ReplyCallback, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ReplyCallback$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ReplyCallback' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - replyCallbackToJSON(replyCallback: ReplyCallback)
 - replyCallbackFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ReplyCallback$Outbound;
}

export function replyCallbackToJSON(replyCallback: ReplyCallback): string...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function replyCallbackToJSON
- export function replyCallbackFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/requestlogresponsedto.ts
Tamaño: 5592 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Transaction identifier
 */
export type TransactionId = {};

export type RequestLogResponseDto = {
  /**
   * Request log identifier
   */
  id: string;
  /**
   * Creation timestamp
   */
  createdAt: string;
  /**
   * Request URL
   */
  url: string;
  /**
   * URL pattern
   */
  urlPattern: string;
  /**
   * HTTP method
   */
  method: string;
  /**
   * HTTP status code
   */
  statusCode: number;
  /**
   * Request path
   */
  path: string;
  /**
   * Request hostname
   */
  hostname: string;
  /**
   * Transaction identifier
   */
  transactionId?: TransactionId | null | undefined;
  /**
   * Client IP address
   */
  ip: string;
  /**
   * User agent string
   */
  userAgent: string;
  /**
   * Request body
   */
  requestBody: string;
  /**
   * Response body
   */
  responseBody: string;
  /**
   * User identifier
   */
  userId: string;
  /**
   * Organization identifier
   */
  organizationId: string;
  /**
   * Environment identifier
   */
  environmentId: string;
  /**
   * Authentication type
   */
  authType: string;
  /**
   * Request duration in milliseconds
   */
  durationMs: number;
};

/** @internal */
export const TransactionId$inboundSchema: z.ZodType<TransactionId, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type TransactionId$Outbound = {};

/** @internal */
export const TransactionId$outboundSchema: z.ZodType<TransactionId$Outbound, z.ZodTypeDef, TransactionId> = z.object(
  {}
);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TransactionId$ {
  /** @deprecated use `TransactionId$inboundSchema` instead. */
  export const inboundSchema = TransactionId$inboundSchema;
  /** @deprecated use `TransactionId$outboundSchema` instead. */
  export const outboundSchema = TransactionId$outboundSchema;
  /** @deprecated use `TransactionId$Outbound` instead. */
  export type Outbound = TransactionId$Outbound;
}

export function transactionIdToJSON(transactionId: TransactionId): string {
  return JSON.stringify(TransactionId$outboundSchema.parse(transactionId));
}

export function transactionIdFromJSON(jsonString: string): SafeParseResult<TransactionId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TransactionId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TransactionId' from JSON`
  );
}

/** @internal */
export const RequestLogResponseDto$inboundSchema: z.ZodType<RequestLogResponseDto, z.ZodTypeDef, unknown> = z.object({
  id: z.string(),
  createdAt: z.string(),
  url: z.string(),
  urlPattern: z.string(),
  method: z.string(),
  statusCode: z.number(),
  path: z.string(),
  hostname: z.string(),
  transactionId: z.nullable(z.lazy(() => TransactionId$inboundSchema)).optional(),
  ip: z.string(),
  userAgent: z.string(),
  requestBody: z.string(),
  responseBody: z.string(),
  userId: z.string(),
  organizationId: z.string(),
  environmentId: z.string(),
  authType: z.string(),
  durationMs: z.number(),
});

/** @internal */
export type RequestLogResponseDto$Outbound = {
  id: string;
  createdAt: string;
  url: string;
  urlPattern: string;
  method: string;
  statusCode: number;
  path: string;
  hostname: string;
  transactionId?: TransactionId$Outbound | null | undefined;
  ip: string;
  userAgent: string;
  requestBody: string;
  responseBody: string;
  userId: string;
  organizationId: string;
  environmentId: string;
  authType: string;
  durationMs: number;
};

/** @internal */
export const RequestLogResponseDto$outboundSchema: z.ZodType<
  RequestLogResponseDto$Outbound,
  z.ZodTypeDef,
  RequestLogResponseDto
> = z.object({
  id: z.string(),
  createdAt: z.string(),
  url: z.string(),
  urlPattern: z.string(),
  method: z.string(),
  statusCode: z.number(),
  path: z.string(),
  hostname: z.string(),
  transactionId: z.nullable(z.lazy(() => TransactionId$outboundSchema)).optional(),
  ip: z.string(),
  userAgent: z.string(),
  requestBody: z.string(),
  responseBody: z.string(),
  userId: z.string(),
  organizationId: z.string(),
  environmentId: z.string(),
  authType: z.string(),
  durationMs: z.number(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequestLogResponseDto$ {
  /** @deprecated use `RequestLogResponseDto$inboundSchema` instead. */
  export const inboundSchema = RequestLogResponseDto$inboundSchema;
  /** @deprecated use `RequestLogResponseDto$outboundSchema` instead. */
  export const outboundSchema = RequestLogResponseDto$outboundSchema;
  /** @deprecated use `RequestLogResponseDto$Outbound` instead. */
  export type Outbound = RequestLogResponseDto$Outbound;
}

export function requestLogResponseDtoToJSON(requestLogResponseDto: RequestLogResponseDto): string {
  return JSON.stringify(RequestLogResponseDto$outboundSchema.parse(requestLogResponseDto));
}

export function requestLogResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<RequestLogResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestLogResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestLogResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - transactionIdToJSON(transactionId: TransactionId)
 - transactionIdFromJSON(jsonString: string)
 - requestLogResponseDtoToJSON(requestLogResponseDto: RequestLogResponseDto)
 - requestLogResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TransactionId$Outbound;
}

export function transactionIdToJSON(transactionId: TransactionId): string...)
 - Outbound(RequestLogResponseDto$Outbound;
}

export function requestLogResponseDtoToJSON(requestLogResponseDto...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function transactionIdToJSON
- export function transactionIdFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function requestLogResponseDtoToJSON
- export function requestLogResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/resourceoriginenum.ts
Tamaño: 1185 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Origin of the layout
 */
export const ResourceOriginEnum = {
  NovuCloud: 'novu-cloud',
  NovuCloudV1: 'novu-cloud-v1',
  External: 'external',
} as const;
/**
 * Origin of the layout
 */
export type ResourceOriginEnum = ClosedEnum<typeof ResourceOriginEnum>;

/** @internal */
export const ResourceOriginEnum$inboundSchema: z.ZodNativeEnum<typeof ResourceOriginEnum> =
  z.nativeEnum(ResourceOriginEnum);

/** @internal */
export const ResourceOriginEnum$outboundSchema: z.ZodNativeEnum<typeof ResourceOriginEnum> =
  ResourceOriginEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResourceOriginEnum$ {
  /** @deprecated use `ResourceOriginEnum$inboundSchema` instead. */
  export const inboundSchema = ResourceOriginEnum$inboundSchema;
  /** @deprecated use `ResourceOriginEnum$outboundSchema` instead. */
  export const outboundSchema = ResourceOriginEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/resourcetypeenum.ts
Tamaño: 1124 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Type of the layout
 */
export const ResourceTypeEnum = {
  Regular: 'REGULAR',
  Echo: 'ECHO',
  Bridge: 'BRIDGE',
} as const;
/**
 * Type of the layout
 */
export type ResourceTypeEnum = ClosedEnum<typeof ResourceTypeEnum>;

/** @internal */
export const ResourceTypeEnum$inboundSchema: z.ZodNativeEnum<typeof ResourceTypeEnum> = z.nativeEnum(ResourceTypeEnum);

/** @internal */
export const ResourceTypeEnum$outboundSchema: z.ZodNativeEnum<typeof ResourceTypeEnum> = ResourceTypeEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResourceTypeEnum$ {
  /** @deprecated use `ResourceTypeEnum$inboundSchema` instead. */
  export const inboundSchema = ResourceTypeEnum$inboundSchema;
  /** @deprecated use `ResourceTypeEnum$outboundSchema` instead. */
  export const outboundSchema = ResourceTypeEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/runtimeissuedto.ts
Tamaño: 3041 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export const IssueType = {
  MissingValue: 'MISSING_VALUE',
  MaxLengthAccessed: 'MAX_LENGTH_ACCESSED',
  WorkflowIdAlreadyExists: 'WORKFLOW_ID_ALREADY_EXISTS',
  DuplicatedValue: 'DUPLICATED_VALUE',
  LimitReached: 'LIMIT_REACHED',
} as const;
export type IssueType = ClosedEnum<typeof IssueType>;

export type RuntimeIssueDto = {
  issueType: IssueType;
  variableName?: string | undefined;
  message: string;
};

/** @internal */
export const IssueType$inboundSchema: z.ZodNativeEnum<typeof IssueType> = z.nativeEnum(IssueType);

/** @internal */
export const IssueType$outboundSchema: z.ZodNativeEnum<typeof IssueType> = IssueType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IssueType$ {
  /** @deprecated use `IssueType$inboundSchema` instead. */
  export const inboundSchema = IssueType$inboundSchema;
  /** @deprecated use `IssueType$outboundSchema` instead. */
  export const outboundSchema = IssueType$outboundSchema;
}

/** @internal */
export const RuntimeIssueDto$inboundSchema: z.ZodType<RuntimeIssueDto, z.ZodTypeDef, unknown> = z.object({
  issueType: IssueType$inboundSchema,
  variableName: z.string().optional(),
  message: z.string(),
});

/** @internal */
export type RuntimeIssueDto$Outbound = {
  issueType: string;
  variableName?: string | undefined;
  message: string;
};

/** @internal */
export const RuntimeIssueDto$outboundSchema: z.ZodType<RuntimeIssueDto$Outbound, z.ZodTypeDef, RuntimeIssueDto> =
  z.object({
    issueType: IssueType$outboundSchema,
    variableName: z.string().optional(),
    message: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RuntimeIssueDto$ {
  /** @deprecated use `RuntimeIssueDto$inboundSchema` instead. */
  export const inboundSchema = RuntimeIssueDto$inboundSchema;
  /** @deprecated use `RuntimeIssueDto$outboundSchema` instead. */
  export const outboundSchema = RuntimeIssueDto$outboundSchema;
  /** @deprecated use `RuntimeIssueDto$Outbound` instead. */
  export type Outbound = RuntimeIssueDto$Outbound;
}

export function runtimeIssueDtoToJSON(runtimeIssueDto: RuntimeIssueDto): string {
  return JSON.stringify(RuntimeIssueDto$outboundSchema.parse(runtimeIssueDto));
}

export function runtimeIssueDtoFromJSON(jsonString: string): SafeParseResult<RuntimeIssueDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RuntimeIssueDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RuntimeIssueDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - runtimeIssueDtoToJSON(runtimeIssueDto: RuntimeIssueDto)
 - runtimeIssueDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(RuntimeIssueDto$Outbound;
}

export function runtimeIssueDtoToJSON(runtimeIssueDto: RuntimeIssueDto)...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function runtimeIssueDtoToJSON
- export function runtimeIssueDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/scheduledto.ts
Tamaño: 16215 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  TimeRangeDto,
  TimeRangeDto$inboundSchema,
  TimeRangeDto$Outbound,
  TimeRangeDto$outboundSchema,
} from './timerangedto.js';

/**
 * Monday schedule
 */
export type Monday = {
  /**
   * Day schedule enabled
   */
  isEnabled: boolean;
  /**
   * Hours
   */
  hours?: Array<TimeRangeDto> | undefined;
};

/**
 * Tuesday schedule
 */
export type Tuesday = {
  /**
   * Day schedule enabled
   */
  isEnabled: boolean;
  /**
   * Hours
   */
  hours?: Array<TimeRangeDto> | undefined;
};

/**
 * Wednesday schedule
 */
export type Wednesday = {
  /**
   * Day schedule enabled
   */
  isEnabled: boolean;
  /**
   * Hours
   */
  hours?: Array<TimeRangeDto> | undefined;
};

/**
 * Thursday schedule
 */
export type Thursday = {
  /**
   * Day schedule enabled
   */
  isEnabled: boolean;
  /**
   * Hours
   */
  hours?: Array<TimeRangeDto> | undefined;
};

/**
 * Friday schedule
 */
export type Friday = {
  /**
   * Day schedule enabled
   */
  isEnabled: boolean;
  /**
   * Hours
   */
  hours?: Array<TimeRangeDto> | undefined;
};

/**
 * Saturday schedule
 */
export type Saturday = {
  /**
   * Day schedule enabled
   */
  isEnabled: boolean;
  /**
   * Hours
   */
  hours?: Array<TimeRangeDto> | undefined;
};

/**
 * Sunday schedule
 */
export type Sunday = {
  /**
   * Day schedule enabled
   */
  isEnabled: boolean;
  /**
   * Hours
   */
  hours?: Array<TimeRangeDto> | undefined;
};

/**
 * Weekly schedule
 */
export type WeeklySchedule = {
  /**
   * Monday schedule
   */
  monday?: Monday | undefined;
  /**
   * Tuesday schedule
   */
  tuesday?: Tuesday | undefined;
  /**
   * Wednesday schedule
   */
  wednesday?: Wednesday | undefined;
  /**
   * Thursday schedule
   */
  thursday?: Thursday | undefined;
  /**
   * Friday schedule
   */
  friday?: Friday | undefined;
  /**
   * Saturday schedule
   */
  saturday?: Saturday | undefined;
  /**
   * Sunday schedule
   */
  sunday?: Sunday | undefined;
};

export type ScheduleDto = {
  /**
   * Schedule enabled
   */
  isEnabled: boolean;
  /**
   * Weekly schedule
   */
  weeklySchedule?: WeeklySchedule | undefined;
};

/** @internal */
export const Monday$inboundSchema: z.ZodType<Monday, z.ZodTypeDef, unknown> = z.object({
  isEnabled: z.boolean(),
  hours: z.array(TimeRangeDto$inboundSchema).optional(),
});

/** @internal */
export type Monday$Outbound = {
  isEnabled: boolean;
  hours?: Array<TimeRangeDto$Outbound> | undefined;
};

/** @internal */
export const Monday$outboundSchema: z.ZodType<Monday$Outbound, z.ZodTypeDef, Monday> = z.object({
  isEnabled: z.boolean(),
  hours: z.array(TimeRangeDto$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Monday$ {
  /** @deprecated use `Monday$inboundSchema` instead. */
  export const inboundSchema = Monday$inboundSchema;
  /** @deprecated use `Monday$outboundSchema` instead. */
  export const outboundSchema = Monday$outboundSchema;
  /** @deprecated use `Monday$Outbound` instead. */
  export type Outbound = Monday$Outbound;
}

export function mondayToJSON(monday: Monday): string {
  return JSON.stringify(Monday$outboundSchema.parse(monday));
}

export function mondayFromJSON(jsonString: string): SafeParseResult<Monday, SDKValidationError> {
  return safeParse(jsonString, (x) => Monday$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Monday' from JSON`);
}

/** @internal */
export const Tuesday$inboundSchema: z.ZodType<Tuesday, z.ZodTypeDef, unknown> = z.object({
  isEnabled: z.boolean(),
  hours: z.array(TimeRangeDto$inboundSchema).optional(),
});

/** @internal */
export type Tuesday$Outbound = {
  isEnabled: boolean;
  hours?: Array<TimeRangeDto$Outbound> | undefined;
};

/** @internal */
export const Tuesday$outboundSchema: z.ZodType<Tuesday$Outbound, z.ZodTypeDef, Tuesday> = z.object({
  isEnabled: z.boolean(),
  hours: z.array(TimeRangeDto$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Tuesday$ {
  /** @deprecated use `Tuesday$inboundSchema` instead. */
  export const inboundSchema = Tuesday$inboundSchema;
  /** @deprecated use `Tuesday$outboundSchema` instead. */
  export const outboundSchema = Tuesday$outboundSchema;
  /** @deprecated use `Tuesday$Outbound` instead. */
  export type Outbound = Tuesday$Outbound;
}

export function tuesdayToJSON(tuesday: Tuesday): string {
  return JSON.stringify(Tuesday$outboundSchema.parse(tuesday));
}

export function tuesdayFromJSON(jsonString: string): SafeParseResult<Tuesday, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Tuesday$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Tuesday' from JSON`
  );
}

/** @internal */
export const Wednesday$inboundSchema: z.ZodType<Wednesday, z.ZodTypeDef, unknown> = z.object({
  isEnabled: z.boolean(),
  hours: z.array(TimeRangeDto$inboundSchema).optional(),
});

/** @internal */
export type Wednesday$Outbound = {
  isEnabled: boolean;
  hours?: Array<TimeRangeDto$Outbound> | undefined;
};

/** @internal */
export const Wednesday$outboundSchema: z.ZodType<Wednesday$Outbound, z.ZodTypeDef, Wednesday> = z.object({
  isEnabled: z.boolean(),
  hours: z.array(TimeRangeDto$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Wednesday$ {
  /** @deprecated use `Wednesday$inboundSchema` instead. */
  export const inboundSchema = Wednesday$inboundSchema;
  /** @deprecated use `Wednesday$outboundSchema` instead. */
  export const outboundSchema = Wednesday$outboundSchema;
  /** @deprecated use `Wednesday$Outbound` instead. */
  export type Outbound = Wednesday$Outbound;
}

export function wednesdayToJSON(wednesday: Wednesday): string {
  return JSON.stringify(Wednesday$outboundSchema.parse(wednesday));
}

export function wednesdayFromJSON(jsonString: string): SafeParseResult<Wednesday, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Wednesday$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Wednesday' from JSON`
  );
}

/** @internal */
export const Thursday$inboundSchema: z.ZodType<Thursday, z.ZodTypeDef, unknown> = z.object({
  isEnabled: z.boolean(),
  hours: z.array(TimeRangeDto$inboundSchema).optional(),
});

/** @internal */
export type Thursday$Outbound = {
  isEnabled: boolean;
  hours?: Array<TimeRangeDto$Outbound> | undefined;
};

/** @internal */
export const Thursday$outboundSchema: z.ZodType<Thursday$Outbound, z.ZodTypeDef, Thursday> = z.object({
  isEnabled: z.boolean(),
  hours: z.array(TimeRangeDto$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Thursday$ {
  /** @deprecated use `Thursday$inboundSchema` instead. */
  export const inboundSchema = Thursday$inboundSchema;
  /** @deprecated use `Thursday$outboundSchema` instead. */
  export const outboundSchema = Thursday$outboundSchema;
  /** @deprecated use `Thursday$Outbound` instead. */
  export type Outbound = Thursday$Outbound;
}

export function thursdayToJSON(thursday: Thursday): string {
  return JSON.stringify(Thursday$outboundSchema.parse(thursday));
}

export function thursdayFromJSON(jsonString: string): SafeParseResult<Thursday, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Thursday$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Thursday' from JSON`
  );
}

/** @internal */
export const Friday$inboundSchema: z.ZodType<Friday, z.ZodTypeDef, unknown> = z.object({
  isEnabled: z.boolean(),
  hours: z.array(TimeRangeDto$inboundSchema).optional(),
});

/** @internal */
export type Friday$Outbound = {
  isEnabled: boolean;
  hours?: Array<TimeRangeDto$Outbound> | undefined;
};

/** @internal */
export const Friday$outboundSchema: z.ZodType<Friday$Outbound, z.ZodTypeDef, Friday> = z.object({
  isEnabled: z.boolean(),
  hours: z.array(TimeRangeDto$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Friday$ {
  /** @deprecated use `Friday$inboundSchema` instead. */
  export const inboundSchema = Friday$inboundSchema;
  /** @deprecated use `Friday$outboundSchema` instead. */
  export const outboundSchema = Friday$outboundSchema;
  /** @deprecated use `Friday$Outbound` instead. */
  export type Outbound = Friday$Outbound;
}

export function fridayToJSON(friday: Friday): string {
  return JSON.stringify(Friday$outboundSchema.parse(friday));
}

export function fridayFromJSON(jsonString: string): SafeParseResult<Friday, SDKValidationError> {
  return safeParse(jsonString, (x) => Friday$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Friday' from JSON`);
}

/** @internal */
export const Saturday$inboundSchema: z.ZodType<Saturday, z.ZodTypeDef, unknown> = z.object({
  isEnabled: z.boolean(),
  hours: z.array(TimeRangeDto$inboundSchema).optional(),
});

/** @internal */
export type Saturday$Outbound = {
  isEnabled: boolean;
  hours?: Array<TimeRangeDto$Outbound> | undefined;
};

/** @internal */
export const Saturday$outboundSchema: z.ZodType<Saturday$Outbound, z.ZodTypeDef, Saturday> = z.object({
  isEnabled: z.boolean(),
  hours: z.array(TimeRangeDto$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Saturday$ {
  /** @deprecated use `Saturday$inboundSchema` instead. */
  export const inboundSchema = Saturday$inboundSchema;
  /** @deprecated use `Saturday$outboundSchema` instead. */
  export const outboundSchema = Saturday$outboundSchema;
  /** @deprecated use `Saturday$Outbound` instead. */
  export type Outbound = Saturday$Outbound;
}

export function saturdayToJSON(saturday: Saturday): string {
  return JSON.stringify(Saturday$outboundSchema.parse(saturday));
}

export function saturdayFromJSON(jsonString: string): SafeParseResult<Saturday, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Saturday$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Saturday' from JSON`
  );
}

/** @internal */
export const Sunday$inboundSchema: z.ZodType<Sunday, z.ZodTypeDef, unknown> = z.object({
  isEnabled: z.boolean(),
  hours: z.array(TimeRangeDto$inboundSchema).optional(),
});

/** @internal */
export type Sunday$Outbound = {
  isEnabled: boolean;
  hours?: Array<TimeRangeDto$Outbound> | undefined;
};

/** @internal */
export const Sunday$outboundSchema: z.ZodType<Sunday$Outbound, z.ZodTypeDef, Sunday> = z.object({
  isEnabled: z.boolean(),
  hours: z.array(TimeRangeDto$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Sunday$ {
  /** @deprecated use `Sunday$inboundSchema` instead. */
  export const inboundSchema = Sunday$inboundSchema;
  /** @deprecated use `Sunday$outboundSchema` instead. */
  export const outboundSchema = Sunday$outboundSchema;
  /** @deprecated use `Sunday$Outbound` instead. */
  export type Outbound = Sunday$Outbound;
}

export function sundayToJSON(sunday: Sunday): string {
  return JSON.stringify(Sunday$outboundSchema.parse(sunday));
}

export function sundayFromJSON(jsonString: string): SafeParseResult<Sunday, SDKValidationError> {
  return safeParse(jsonString, (x) => Sunday$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Sunday' from JSON`);
}

/** @internal */
export const WeeklySchedule$inboundSchema: z.ZodType<WeeklySchedule, z.ZodTypeDef, unknown> = z.object({
  monday: z.lazy(() => Monday$inboundSchema).optional(),
  tuesday: z.lazy(() => Tuesday$inboundSchema).optional(),
  wednesday: z.lazy(() => Wednesday$inboundSchema).optional(),
  thursday: z.lazy(() => Thursday$inboundSchema).optional(),
  friday: z.lazy(() => Friday$inboundSchema).optional(),
  saturday: z.lazy(() => Saturday$inboundSchema).optional(),
  sunday: z.lazy(() => Sunday$inboundSchema).optional(),
});

/** @internal */
export type WeeklySchedule$Outbound = {
  monday?: Monday$Outbound | undefined;
  tuesday?: Tuesday$Outbound | undefined;
  wednesday?: Wednesday$Outbound | undefined;
  thursday?: Thursday$Outbound | undefined;
  friday?: Friday$Outbound | undefined;
  saturday?: Saturday$Outbound | undefined;
  sunday?: Sunday$Outbound | undefined;
};

/** @internal */
export const WeeklySchedule$outboundSchema: z.ZodType<WeeklySchedule$Outbound, z.ZodTypeDef, WeeklySchedule> = z.object(
  {
    monday: z.lazy(() => Monday$outboundSchema).optional(),
    tuesday: z.lazy(() => Tuesday$outboundSchema).optional(),
    wednesday: z.lazy(() => Wednesday$outboundSchema).optional(),
    thursday: z.lazy(() => Thursday$outboundSchema).optional(),
    friday: z.lazy(() => Friday$outboundSchema).optional(),
    saturday: z.lazy(() => Saturday$outboundSchema).optional(),
    sunday: z.lazy(() => Sunday$outboundSchema).optional(),
  }
);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WeeklySchedule$ {
  /** @deprecated use `WeeklySchedule$inboundSchema` instead. */
  export const inboundSchema = WeeklySchedule$inboundSchema;
  /** @deprecated use `WeeklySchedule$outboundSchema` instead. */
  export const outboundSchema = WeeklySchedule$outboundSchema;
  /** @deprecated use `WeeklySchedule$Outbound` instead. */
  export type Outbound = WeeklySchedule$Outbound;
}

export function weeklyScheduleToJSON(weeklySchedule: WeeklySchedule): string {
  return JSON.stringify(WeeklySchedule$outboundSchema.parse(weeklySchedule));
}

export function weeklyScheduleFromJSON(jsonString: string): SafeParseResult<WeeklySchedule, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WeeklySchedule$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WeeklySchedule' from JSON`
  );
}

/** @internal */
export const ScheduleDto$inboundSchema: z.ZodType<ScheduleDto, z.ZodTypeDef, unknown> = z.object({
  isEnabled: z.boolean(),
  weeklySchedule: z.lazy(() => WeeklySchedule$inboundSchema).optional(),
});

/** @internal */
export type ScheduleDto$Outbound = {
  isEnabled: boolean;
  weeklySchedule?: WeeklySchedule$Outbound | undefined;
};

/** @internal */
export const ScheduleDto$outboundSchema: z.ZodType<ScheduleDto$Outbound, z.ZodTypeDef, ScheduleDto> = z.object({
  isEnabled: z.boolean(),
  weeklySchedule: z.lazy(() => WeeklySchedule$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ScheduleDto$ {
  /** @deprecated use `ScheduleDto$inboundSchema` instead. */
  export const inboundSchema = ScheduleDto$inboundSchema;
  /** @deprecated use `ScheduleDto$outboundSchema` instead. */
  export const outboundSchema = ScheduleDto$outboundSchema;
  /** @deprecated use `ScheduleDto$Outbound` instead. */
  export type Outbound = ScheduleDto$Outbound;
}

export function scheduleDtoToJSON(scheduleDto: ScheduleDto): string {
  return JSON.stringify(ScheduleDto$outboundSchema.parse(scheduleDto));
}

export function scheduleDtoFromJSON(jsonString: string): SafeParseResult<ScheduleDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ScheduleDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ScheduleDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - mondayToJSON(monday: Monday)
 - mondayFromJSON(jsonString: string)
 - tuesdayToJSON(tuesday: Tuesday)
 - tuesdayFromJSON(jsonString: string)
 - wednesdayToJSON(wednesday: Wednesday)
 - wednesdayFromJSON(jsonString: string)
 - thursdayToJSON(thursday: Thursday)
 - thursdayFromJSON(jsonString: string)
 - fridayToJSON(friday: Friday)
 - fridayFromJSON(jsonString: string)
 - saturdayToJSON(saturday: Saturday)
 - saturdayFromJSON(jsonString: string)
 - sundayToJSON(sunday: Sunday)
 - sundayFromJSON(jsonString: string)
 - weeklyScheduleToJSON(weeklySchedule: WeeklySchedule)
 - weeklyScheduleFromJSON(jsonString: string)
 - scheduleDtoToJSON(scheduleDto: ScheduleDto)
 - scheduleDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Monday$Outbound;
}

export function mondayToJSON(monday: Monday): string {
  return JSON.stringify(M...)
 - Outbound(Tuesday$Outbound;
}

export function tuesdayToJSON(tuesday: Tuesday): string {
  return JSON.stringi...)
 - Outbound(Wednesday$Outbound;
}

export function wednesdayToJSON(wednesday: Wednesday): string {
  return JSON...)
 - Outbound(Thursday$Outbound;
}

export function thursdayToJSON(thursday: Thursday): string {
  return JSON.str...)
 - Outbound(Friday$Outbound;
}

export function fridayToJSON(friday: Friday): string {
  return JSON.stringify(F...)
 - Outbound(Saturday$Outbound;
}

export function saturdayToJSON(saturday: Saturday): string {
  return JSON.str...)
 - Outbound(Sunday$Outbound;
}

export function sundayToJSON(sunday: Sunday): string {
  return JSON.stringify(S...)
 - Outbound(WeeklySchedule$Outbound;
}

export function weeklyScheduleToJSON(weeklySchedule: WeeklySchedule): st...)
 - Outbound(ScheduleDto$Outbound;
}

export function scheduleDtoToJSON(scheduleDto: ScheduleDto): string {
  ret...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function mondayToJSON
- export function mondayFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function tuesdayToJSON
- export function tuesdayFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function wednesdayToJSON
- export function wednesdayFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function thursdayToJSON
- export function thursdayFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function fridayToJSON
- export function fridayFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function saturdayToJSON
- export function saturdayFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function sundayToJSON
- export function sundayFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function weeklyScheduleToJSON
- export function weeklyScheduleFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function scheduleDtoToJSON
- export function scheduleDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/security.ts
Tamaño: 1788 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type Security = {
  secretKey?: string | undefined;
  bearerAuth?: string | undefined;
};

/** @internal */
export const Security$inboundSchema: z.ZodType<Security, z.ZodTypeDef, unknown> = z.object({
  secretKey: z.string().optional(),
  bearerAuth: z.string().optional(),
});

/** @internal */
export type Security$Outbound = {
  secretKey?: string | undefined;
  bearerAuth?: string | undefined;
};

/** @internal */
export const Security$outboundSchema: z.ZodType<Security$Outbound, z.ZodTypeDef, Security> = z.object({
  secretKey: z.string().optional(),
  bearerAuth: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Security$ {
  /** @deprecated use `Security$inboundSchema` instead. */
  export const inboundSchema = Security$inboundSchema;
  /** @deprecated use `Security$outboundSchema` instead. */
  export const outboundSchema = Security$outboundSchema;
  /** @deprecated use `Security$Outbound` instead. */
  export type Outbound = Security$Outbound;
}

export function securityToJSON(security: Security): string {
  return JSON.stringify(Security$outboundSchema.parse(security));
}

export function securityFromJSON(jsonString: string): SafeParseResult<Security, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Security$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Security' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - securityToJSON(security: Security)
 - securityFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Security$Outbound;
}

export function securityToJSON(security: Security): string {
  return JSON.str...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function securityToJSON
- export function securityFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/severitylevelenum.ts
Tamaño: 1162 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Severity of the workflow
 */
export const SeverityLevelEnum = {
  High: 'high',
  Medium: 'medium',
  Low: 'low',
  None: 'none',
} as const;
/**
 * Severity of the workflow
 */
export type SeverityLevelEnum = ClosedEnum<typeof SeverityLevelEnum>;

/** @internal */
export const SeverityLevelEnum$inboundSchema: z.ZodNativeEnum<typeof SeverityLevelEnum> =
  z.nativeEnum(SeverityLevelEnum);

/** @internal */
export const SeverityLevelEnum$outboundSchema: z.ZodNativeEnum<typeof SeverityLevelEnum> =
  SeverityLevelEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SeverityLevelEnum$ {
  /** @deprecated use `SeverityLevelEnum$inboundSchema` instead. */
  export const inboundSchema = SeverityLevelEnum$inboundSchema;
  /** @deprecated use `SeverityLevelEnum$outboundSchema` instead. */
  export const outboundSchema = SeverityLevelEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/smscontroldto.ts
Tamaño: 2168 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SmsControlDto = {
  /**
   * JSONLogic filter conditions for conditionally skipping the step execution. Supports complex logical operations with AND, OR, and comparison operators. See https://jsonlogic.com/ for full typing reference.
   */
  skip?: { [k: string]: any } | undefined;
  /**
   * Content of the SMS message.
   */
  body?: string | undefined;
};

/** @internal */
export const SmsControlDto$inboundSchema: z.ZodType<SmsControlDto, z.ZodTypeDef, unknown> = z.object({
  skip: z.record(z.any()).optional(),
  body: z.string().optional(),
});

/** @internal */
export type SmsControlDto$Outbound = {
  skip?: { [k: string]: any } | undefined;
  body?: string | undefined;
};

/** @internal */
export const SmsControlDto$outboundSchema: z.ZodType<SmsControlDto$Outbound, z.ZodTypeDef, SmsControlDto> = z.object({
  skip: z.record(z.any()).optional(),
  body: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SmsControlDto$ {
  /** @deprecated use `SmsControlDto$inboundSchema` instead. */
  export const inboundSchema = SmsControlDto$inboundSchema;
  /** @deprecated use `SmsControlDto$outboundSchema` instead. */
  export const outboundSchema = SmsControlDto$outboundSchema;
  /** @deprecated use `SmsControlDto$Outbound` instead. */
  export type Outbound = SmsControlDto$Outbound;
}

export function smsControlDtoToJSON(smsControlDto: SmsControlDto): string {
  return JSON.stringify(SmsControlDto$outboundSchema.parse(smsControlDto));
}

export function smsControlDtoFromJSON(jsonString: string): SafeParseResult<SmsControlDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SmsControlDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SmsControlDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - smsControlDtoToJSON(smsControlDto: SmsControlDto)
 - smsControlDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SmsControlDto$Outbound;
}

export function smsControlDtoToJSON(smsControlDto: SmsControlDto): string...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function smsControlDtoToJSON
- export function smsControlDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/smscontrolsmetadataresponsedto.ts
Tamaño: 2913 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  SmsControlDto,
  SmsControlDto$inboundSchema,
  SmsControlDto$Outbound,
  SmsControlDto$outboundSchema,
} from './smscontroldto.js';
import { UiSchema, UiSchema$inboundSchema, UiSchema$Outbound, UiSchema$outboundSchema } from './uischema.js';

export type SmsControlsMetadataResponseDto = {
  /**
   * JSON Schema for data
   */
  dataSchema?: { [k: string]: any } | undefined;
  /**
   * UI Schema for rendering
   */
  uiSchema?: UiSchema | undefined;
  /**
   * Control values specific to SMS
   */
  values: SmsControlDto;
};

/** @internal */
export const SmsControlsMetadataResponseDto$inboundSchema: z.ZodType<
  SmsControlsMetadataResponseDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  dataSchema: z.record(z.any()).optional(),
  uiSchema: UiSchema$inboundSchema.optional(),
  values: SmsControlDto$inboundSchema,
});

/** @internal */
export type SmsControlsMetadataResponseDto$Outbound = {
  dataSchema?: { [k: string]: any } | undefined;
  uiSchema?: UiSchema$Outbound | undefined;
  values: SmsControlDto$Outbound;
};

/** @internal */
export const SmsControlsMetadataResponseDto$outboundSchema: z.ZodType<
  SmsControlsMetadataResponseDto$Outbound,
  z.ZodTypeDef,
  SmsControlsMetadataResponseDto
> = z.object({
  dataSchema: z.record(z.any()).optional(),
  uiSchema: UiSchema$outboundSchema.optional(),
  values: SmsControlDto$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SmsControlsMetadataResponseDto$ {
  /** @deprecated use `SmsControlsMetadataResponseDto$inboundSchema` instead. */
  export const inboundSchema = SmsControlsMetadataResponseDto$inboundSchema;
  /** @deprecated use `SmsControlsMetadataResponseDto$outboundSchema` instead. */
  export const outboundSchema = SmsControlsMetadataResponseDto$outboundSchema;
  /** @deprecated use `SmsControlsMetadataResponseDto$Outbound` instead. */
  export type Outbound = SmsControlsMetadataResponseDto$Outbound;
}

export function smsControlsMetadataResponseDtoToJSON(
  smsControlsMetadataResponseDto: SmsControlsMetadataResponseDto
): string {
  return JSON.stringify(SmsControlsMetadataResponseDto$outboundSchema.parse(smsControlsMetadataResponseDto));
}

export function smsControlsMetadataResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<SmsControlsMetadataResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SmsControlsMetadataResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SmsControlsMetadataResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - smsControlsMetadataResponseDtoToJSON(smsControlsMetadataResponseDto: SmsControlsMetadataResponseDto)
 - smsControlsMetadataResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SmsControlsMetadataResponseDto$Outbound;
}

export function smsControlsMetadataResponseDtoToJSON(
  ...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function smsControlsMetadataResponseDtoToJSON
- export function smsControlsMetadataResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/smsrenderoutput.ts
Tamaño: 1784 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SmsRenderOutput = {
  /**
   * Body of the SMS message
   */
  body: string;
};

/** @internal */
export const SmsRenderOutput$inboundSchema: z.ZodType<SmsRenderOutput, z.ZodTypeDef, unknown> = z.object({
  body: z.string(),
});

/** @internal */
export type SmsRenderOutput$Outbound = {
  body: string;
};

/** @internal */
export const SmsRenderOutput$outboundSchema: z.ZodType<SmsRenderOutput$Outbound, z.ZodTypeDef, SmsRenderOutput> =
  z.object({
    body: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SmsRenderOutput$ {
  /** @deprecated use `SmsRenderOutput$inboundSchema` instead. */
  export const inboundSchema = SmsRenderOutput$inboundSchema;
  /** @deprecated use `SmsRenderOutput$outboundSchema` instead. */
  export const outboundSchema = SmsRenderOutput$outboundSchema;
  /** @deprecated use `SmsRenderOutput$Outbound` instead. */
  export type Outbound = SmsRenderOutput$Outbound;
}

export function smsRenderOutputToJSON(smsRenderOutput: SmsRenderOutput): string {
  return JSON.stringify(SmsRenderOutput$outboundSchema.parse(smsRenderOutput));
}

export function smsRenderOutputFromJSON(jsonString: string): SafeParseResult<SmsRenderOutput, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SmsRenderOutput$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SmsRenderOutput' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - smsRenderOutputToJSON(smsRenderOutput: SmsRenderOutput)
 - smsRenderOutputFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SmsRenderOutput$Outbound;
}

export function smsRenderOutputToJSON(smsRenderOutput: SmsRenderOutput)...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function smsRenderOutputToJSON
- export function smsRenderOutputFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/smsstepresponsedto.ts
Tamaño: 7597 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { collectExtraKeys as collectExtraKeys$, safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ResourceOriginEnum,
  ResourceOriginEnum$inboundSchema,
  ResourceOriginEnum$outboundSchema,
} from './resourceoriginenum.js';
import {
  SmsControlsMetadataResponseDto,
  SmsControlsMetadataResponseDto$inboundSchema,
  SmsControlsMetadataResponseDto$Outbound,
  SmsControlsMetadataResponseDto$outboundSchema,
} from './smscontrolsmetadataresponsedto.js';
import {
  StepIssuesDto,
  StepIssuesDto$inboundSchema,
  StepIssuesDto$Outbound,
  StepIssuesDto$outboundSchema,
} from './stepissuesdto.js';
import { StepTypeEnum, StepTypeEnum$inboundSchema, StepTypeEnum$outboundSchema } from './steptypeenum.js';

/**
 * Control values for the SMS step
 */
export type SmsStepResponseDtoControlValues = {
  /**
   * JSONLogic filter conditions for conditionally skipping the step execution. Supports complex logical operations with AND, OR, and comparison operators. See https://jsonlogic.com/ for full typing reference.
   */
  skip?: { [k: string]: any } | undefined;
  /**
   * Content of the SMS message.
   */
  body?: string | undefined;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type SmsStepResponseDto = {
  /**
   * Controls metadata for the SMS step
   */
  controls: SmsControlsMetadataResponseDto;
  /**
   * Control values for the SMS step
   */
  controlValues?: SmsStepResponseDtoControlValues | undefined;
  /**
   * JSON Schema for variables, follows the JSON Schema standard
   */
  variables: { [k: string]: any };
  /**
   * Unique identifier of the step
   */
  stepId: string;
  /**
   * Database identifier of the step
   */
  id: string;
  /**
   * Name of the step
   */
  name: string;
  /**
   * Slug of the step
   */
  slug: string;
  /**
   * Type of the step
   */
  type: StepTypeEnum;
  /**
   * Origin of the layout
   */
  origin: ResourceOriginEnum;
  /**
   * Workflow identifier
   */
  workflowId: string;
  /**
   * Workflow database identifier
   */
  workflowDatabaseId: string;
  /**
   * Issues associated with the step
   */
  issues?: StepIssuesDto | undefined;
};

/** @internal */
export const SmsStepResponseDtoControlValues$inboundSchema: z.ZodType<
  SmsStepResponseDtoControlValues,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z
    .object({
      skip: z.record(z.any()).optional(),
      body: z.string().optional(),
    })
    .catchall(z.any()),
  'additionalProperties',
  true
);

/** @internal */
export type SmsStepResponseDtoControlValues$Outbound = {
  skip?: { [k: string]: any } | undefined;
  body?: string | undefined;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const SmsStepResponseDtoControlValues$outboundSchema: z.ZodType<
  SmsStepResponseDtoControlValues$Outbound,
  z.ZodTypeDef,
  SmsStepResponseDtoControlValues
> = z
  .object({
    skip: z.record(z.any()).optional(),
    body: z.string().optional(),
    additionalProperties: z.record(z.any()).optional(),
  })
  .transform((v) => {
    return {
      ...v.additionalProperties,
      ...remap$(v, {
        additionalProperties: null,
      }),
    };
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SmsStepResponseDtoControlValues$ {
  /** @deprecated use `SmsStepResponseDtoControlValues$inboundSchema` instead. */
  export const inboundSchema = SmsStepResponseDtoControlValues$inboundSchema;
  /** @deprecated use `SmsStepResponseDtoControlValues$outboundSchema` instead. */
  export const outboundSchema = SmsStepResponseDtoControlValues$outboundSchema;
  /** @deprecated use `SmsStepResponseDtoControlValues$Outbound` instead. */
  export type Outbound = SmsStepResponseDtoControlValues$Outbound;
}

export function smsStepResponseDtoControlValuesToJSON(
  smsStepResponseDtoControlValues: SmsStepResponseDtoControlValues
): string {
  return JSON.stringify(SmsStepResponseDtoControlValues$outboundSchema.parse(smsStepResponseDtoControlValues));
}

export function smsStepResponseDtoControlValuesFromJSON(
  jsonString: string
): SafeParseResult<SmsStepResponseDtoControlValues, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SmsStepResponseDtoControlValues$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SmsStepResponseDtoControlValues' from JSON`
  );
}

/** @internal */
export const SmsStepResponseDto$inboundSchema: z.ZodType<SmsStepResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    controls: SmsControlsMetadataResponseDto$inboundSchema,
    controlValues: z.lazy(() => SmsStepResponseDtoControlValues$inboundSchema).optional(),
    variables: z.record(z.any()),
    stepId: z.string(),
    _id: z.string(),
    name: z.string(),
    slug: z.string(),
    type: StepTypeEnum$inboundSchema,
    origin: ResourceOriginEnum$inboundSchema,
    workflowId: z.string(),
    workflowDatabaseId: z.string(),
    issues: StepIssuesDto$inboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type SmsStepResponseDto$Outbound = {
  controls: SmsControlsMetadataResponseDto$Outbound;
  controlValues?: SmsStepResponseDtoControlValues$Outbound | undefined;
  variables: { [k: string]: any };
  stepId: string;
  _id: string;
  name: string;
  slug: string;
  type: string;
  origin: string;
  workflowId: string;
  workflowDatabaseId: string;
  issues?: StepIssuesDto$Outbound | undefined;
};

/** @internal */
export const SmsStepResponseDto$outboundSchema: z.ZodType<
  SmsStepResponseDto$Outbound,
  z.ZodTypeDef,
  SmsStepResponseDto
> = z
  .object({
    controls: SmsControlsMetadataResponseDto$outboundSchema,
    controlValues: z.lazy(() => SmsStepResponseDtoControlValues$outboundSchema).optional(),
    variables: z.record(z.any()),
    stepId: z.string(),
    id: z.string(),
    name: z.string(),
    slug: z.string(),
    type: StepTypeEnum$outboundSchema,
    origin: ResourceOriginEnum$outboundSchema,
    workflowId: z.string(),
    workflowDatabaseId: z.string(),
    issues: StepIssuesDto$outboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SmsStepResponseDto$ {
  /** @deprecated use `SmsStepResponseDto$inboundSchema` instead. */
  export const inboundSchema = SmsStepResponseDto$inboundSchema;
  /** @deprecated use `SmsStepResponseDto$outboundSchema` instead. */
  export const outboundSchema = SmsStepResponseDto$outboundSchema;
  /** @deprecated use `SmsStepResponseDto$Outbound` instead. */
  export type Outbound = SmsStepResponseDto$Outbound;
}

export function smsStepResponseDtoToJSON(smsStepResponseDto: SmsStepResponseDto): string {
  return JSON.stringify(SmsStepResponseDto$outboundSchema.parse(smsStepResponseDto));
}

export function smsStepResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<SmsStepResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SmsStepResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SmsStepResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - smsStepResponseDtoControlValuesToJSON(smsStepResponseDtoControlValues: SmsStepResponseDtoControlValues)
 - smsStepResponseDtoControlValuesFromJSON(jsonString: string)
 - smsStepResponseDtoToJSON(smsStepResponseDto: SmsStepResponseDto)
 - smsStepResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SmsStepResponseDtoControlValues$Outbound;
}

export function smsStepResponseDtoControlValuesToJSON(
...)
 - Outbound(SmsStepResponseDto$Outbound;
}

export function smsStepResponseDtoToJSON(smsStepResponseDto: SmsStep...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function smsStepResponseDtoControlValuesToJSON
- export function smsStepResponseDtoControlValuesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function smsStepResponseDtoToJSON
- export function smsStepResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/smsstepupsertdto.ts
Tamaño: 5131 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  SmsControlDto,
  SmsControlDto$inboundSchema,
  SmsControlDto$Outbound,
  SmsControlDto$outboundSchema,
} from './smscontroldto.js';
import { StepTypeEnum, StepTypeEnum$inboundSchema, StepTypeEnum$outboundSchema } from './steptypeenum.js';

/**
 * Control values for the SMS step.
 */
export type SmsStepUpsertDtoControlValues =
  | SmsControlDto
  | {
      [k: string]: any;
    };

export type SmsStepUpsertDto = {
  /**
   * Database identifier of the step. Used for updating the step.
   */
  id?: string | undefined;
  /**
   * Unique identifier for the step
   */
  stepId?: string | undefined;
  /**
   * Name of the step
   */
  name: string;
  /**
   * Type of the step
   */
  type: StepTypeEnum;
  /**
   * Control values for the SMS step.
   */
  controlValues?: SmsControlDto | { [k: string]: any } | undefined;
};

/** @internal */
export const SmsStepUpsertDtoControlValues$inboundSchema: z.ZodType<
  SmsStepUpsertDtoControlValues,
  z.ZodTypeDef,
  unknown
> = z.union([SmsControlDto$inboundSchema, z.record(z.any())]);

/** @internal */
export type SmsStepUpsertDtoControlValues$Outbound =
  | SmsControlDto$Outbound
  | {
      [k: string]: any;
    };

/** @internal */
export const SmsStepUpsertDtoControlValues$outboundSchema: z.ZodType<
  SmsStepUpsertDtoControlValues$Outbound,
  z.ZodTypeDef,
  SmsStepUpsertDtoControlValues
> = z.union([SmsControlDto$outboundSchema, z.record(z.any())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SmsStepUpsertDtoControlValues$ {
  /** @deprecated use `SmsStepUpsertDtoControlValues$inboundSchema` instead. */
  export const inboundSchema = SmsStepUpsertDtoControlValues$inboundSchema;
  /** @deprecated use `SmsStepUpsertDtoControlValues$outboundSchema` instead. */
  export const outboundSchema = SmsStepUpsertDtoControlValues$outboundSchema;
  /** @deprecated use `SmsStepUpsertDtoControlValues$Outbound` instead. */
  export type Outbound = SmsStepUpsertDtoControlValues$Outbound;
}

export function smsStepUpsertDtoControlValuesToJSON(
  smsStepUpsertDtoControlValues: SmsStepUpsertDtoControlValues
): string {
  return JSON.stringify(SmsStepUpsertDtoControlValues$outboundSchema.parse(smsStepUpsertDtoControlValues));
}

export function smsStepUpsertDtoControlValuesFromJSON(
  jsonString: string
): SafeParseResult<SmsStepUpsertDtoControlValues, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SmsStepUpsertDtoControlValues$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SmsStepUpsertDtoControlValues' from JSON`
  );
}

/** @internal */
export const SmsStepUpsertDto$inboundSchema: z.ZodType<SmsStepUpsertDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().optional(),
    stepId: z.string().optional(),
    name: z.string(),
    type: StepTypeEnum$inboundSchema,
    controlValues: z.union([SmsControlDto$inboundSchema, z.record(z.any())]).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type SmsStepUpsertDto$Outbound = {
  _id?: string | undefined;
  stepId?: string | undefined;
  name: string;
  type: string;
  controlValues?: SmsControlDto$Outbound | { [k: string]: any } | undefined;
};

/** @internal */
export const SmsStepUpsertDto$outboundSchema: z.ZodType<SmsStepUpsertDto$Outbound, z.ZodTypeDef, SmsStepUpsertDto> = z
  .object({
    id: z.string().optional(),
    stepId: z.string().optional(),
    name: z.string(),
    type: StepTypeEnum$outboundSchema,
    controlValues: z.union([SmsControlDto$outboundSchema, z.record(z.any())]).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SmsStepUpsertDto$ {
  /** @deprecated use `SmsStepUpsertDto$inboundSchema` instead. */
  export const inboundSchema = SmsStepUpsertDto$inboundSchema;
  /** @deprecated use `SmsStepUpsertDto$outboundSchema` instead. */
  export const outboundSchema = SmsStepUpsertDto$outboundSchema;
  /** @deprecated use `SmsStepUpsertDto$Outbound` instead. */
  export type Outbound = SmsStepUpsertDto$Outbound;
}

export function smsStepUpsertDtoToJSON(smsStepUpsertDto: SmsStepUpsertDto): string {
  return JSON.stringify(SmsStepUpsertDto$outboundSchema.parse(smsStepUpsertDto));
}

export function smsStepUpsertDtoFromJSON(jsonString: string): SafeParseResult<SmsStepUpsertDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SmsStepUpsertDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SmsStepUpsertDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - smsStepUpsertDtoControlValuesToJSON(smsStepUpsertDtoControlValues: SmsStepUpsertDtoControlValues)
 - smsStepUpsertDtoControlValuesFromJSON(jsonString: string)
 - smsStepUpsertDtoToJSON(smsStepUpsertDto: SmsStepUpsertDto)
 - smsStepUpsertDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SmsStepUpsertDtoControlValues$Outbound;
}

export function smsStepUpsertDtoControlValuesToJSON(
  sm...)
 - Outbound(SmsStepUpsertDto$Outbound;
}

export function smsStepUpsertDtoToJSON(smsStepUpsertDto: SmsStepUpsert...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function smsStepUpsertDtoControlValuesToJSON
- export function smsStepUpsertDtoControlValuesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function smsStepUpsertDtoToJSON
- export function smsStepUpsertDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/stepcontentissuedto.ts
Tamaño: 2436 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ContentIssueEnum,
  ContentIssueEnum$inboundSchema,
  ContentIssueEnum$outboundSchema,
} from './contentissueenum.js';

export type StepContentIssueDto = {
  /**
   * Type of step content issue
   */
  issueType: ContentIssueEnum;
  /**
   * Name of the variable related to the issue
   */
  variableName?: string | undefined;
  /**
   * Detailed message describing the issue
   */
  message: string;
};

/** @internal */
export const StepContentIssueDto$inboundSchema: z.ZodType<StepContentIssueDto, z.ZodTypeDef, unknown> = z.object({
  issueType: ContentIssueEnum$inboundSchema,
  variableName: z.string().optional(),
  message: z.string(),
});

/** @internal */
export type StepContentIssueDto$Outbound = {
  issueType: string;
  variableName?: string | undefined;
  message: string;
};

/** @internal */
export const StepContentIssueDto$outboundSchema: z.ZodType<
  StepContentIssueDto$Outbound,
  z.ZodTypeDef,
  StepContentIssueDto
> = z.object({
  issueType: ContentIssueEnum$outboundSchema,
  variableName: z.string().optional(),
  message: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StepContentIssueDto$ {
  /** @deprecated use `StepContentIssueDto$inboundSchema` instead. */
  export const inboundSchema = StepContentIssueDto$inboundSchema;
  /** @deprecated use `StepContentIssueDto$outboundSchema` instead. */
  export const outboundSchema = StepContentIssueDto$outboundSchema;
  /** @deprecated use `StepContentIssueDto$Outbound` instead. */
  export type Outbound = StepContentIssueDto$Outbound;
}

export function stepContentIssueDtoToJSON(stepContentIssueDto: StepContentIssueDto): string {
  return JSON.stringify(StepContentIssueDto$outboundSchema.parse(stepContentIssueDto));
}

export function stepContentIssueDtoFromJSON(
  jsonString: string
): SafeParseResult<StepContentIssueDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StepContentIssueDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StepContentIssueDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - stepContentIssueDtoToJSON(stepContentIssueDto: StepContentIssueDto)
 - stepContentIssueDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(StepContentIssueDto$Outbound;
}

export function stepContentIssueDtoToJSON(stepContentIssueDto: Step...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function stepContentIssueDtoToJSON
- export function stepContentIssueDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/stepexecutiondetaildto.ts
Tamaño: 4459 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ExecutionDetailsStatusEnum,
  ExecutionDetailsStatusEnum$inboundSchema,
  ExecutionDetailsStatusEnum$outboundSchema,
} from './executiondetailsstatusenum.js';

/**
 * Raw data of the execution
 */
export type Raw = {};

export type StepExecutionDetailDto = {
  /**
   * Unique identifier of the execution detail
   */
  id: string;
  /**
   * Creation time of the execution detail
   */
  createdAt?: string | undefined;
  /**
   * Status of the execution detail
   */
  status: ExecutionDetailsStatusEnum;
  /**
   * Detailed information about the execution
   */
  detail: string;
  /**
   * Provider identifier
   */
  providerId?: string | undefined;
  /**
   * Raw data of the execution
   */
  raw?: Raw | null | undefined;
};

/** @internal */
export const Raw$inboundSchema: z.ZodType<Raw, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type Raw$Outbound = {};

/** @internal */
export const Raw$outboundSchema: z.ZodType<Raw$Outbound, z.ZodTypeDef, Raw> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Raw$ {
  /** @deprecated use `Raw$inboundSchema` instead. */
  export const inboundSchema = Raw$inboundSchema;
  /** @deprecated use `Raw$outboundSchema` instead. */
  export const outboundSchema = Raw$outboundSchema;
  /** @deprecated use `Raw$Outbound` instead. */
  export type Outbound = Raw$Outbound;
}

export function rawToJSON(raw: Raw): string {
  return JSON.stringify(Raw$outboundSchema.parse(raw));
}

export function rawFromJSON(jsonString: string): SafeParseResult<Raw, SDKValidationError> {
  return safeParse(jsonString, (x) => Raw$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Raw' from JSON`);
}

/** @internal */
export const StepExecutionDetailDto$inboundSchema: z.ZodType<StepExecutionDetailDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string(),
    createdAt: z.string().optional(),
    status: ExecutionDetailsStatusEnum$inboundSchema,
    detail: z.string(),
    providerId: z.string().optional(),
    raw: z.nullable(z.lazy(() => Raw$inboundSchema)).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type StepExecutionDetailDto$Outbound = {
  _id: string;
  createdAt?: string | undefined;
  status: string;
  detail: string;
  providerId?: string | undefined;
  raw?: Raw$Outbound | null | undefined;
};

/** @internal */
export const StepExecutionDetailDto$outboundSchema: z.ZodType<
  StepExecutionDetailDto$Outbound,
  z.ZodTypeDef,
  StepExecutionDetailDto
> = z
  .object({
    id: z.string(),
    createdAt: z.string().optional(),
    status: ExecutionDetailsStatusEnum$outboundSchema,
    detail: z.string(),
    providerId: z.string().optional(),
    raw: z.nullable(z.lazy(() => Raw$outboundSchema)).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StepExecutionDetailDto$ {
  /** @deprecated use `StepExecutionDetailDto$inboundSchema` instead. */
  export const inboundSchema = StepExecutionDetailDto$inboundSchema;
  /** @deprecated use `StepExecutionDetailDto$outboundSchema` instead. */
  export const outboundSchema = StepExecutionDetailDto$outboundSchema;
  /** @deprecated use `StepExecutionDetailDto$Outbound` instead. */
  export type Outbound = StepExecutionDetailDto$Outbound;
}

export function stepExecutionDetailDtoToJSON(stepExecutionDetailDto: StepExecutionDetailDto): string {
  return JSON.stringify(StepExecutionDetailDto$outboundSchema.parse(stepExecutionDetailDto));
}

export function stepExecutionDetailDtoFromJSON(
  jsonString: string
): SafeParseResult<StepExecutionDetailDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StepExecutionDetailDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StepExecutionDetailDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - rawToJSON(raw: Raw)
 - rawFromJSON(jsonString: string)
 - stepExecutionDetailDtoToJSON(stepExecutionDetailDto: StepExecutionDetailDto)
 - stepExecutionDetailDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Raw$Outbound;
}

export function rawToJSON(raw: Raw): string {
  return JSON.stringify(Raw$outboundS...)
 - Outbound(StepExecutionDetailDto$Outbound;
}

export function stepExecutionDetailDtoToJSON(stepExecutionDetail...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function rawToJSON
- export function rawFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function stepExecutionDetailDtoToJSON
- export function stepExecutionDetailDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/stepfilterdto.ts
Tamaño: 3454 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  BuilderFieldTypeEnum,
  BuilderFieldTypeEnum$inboundSchema,
  BuilderFieldTypeEnum$outboundSchema,
} from './builderfieldtypeenum.js';
import {
  FieldFilterPartDto,
  FieldFilterPartDto$inboundSchema,
  FieldFilterPartDto$Outbound,
  FieldFilterPartDto$outboundSchema,
} from './fieldfilterpartdto.js';

export const StepFilterDtoValue = {
  And: 'AND',
  Or: 'OR',
} as const;
export type StepFilterDtoValue = ClosedEnum<typeof StepFilterDtoValue>;

export type StepFilterDto = {
  isNegated: boolean;
  type: BuilderFieldTypeEnum;
  value: StepFilterDtoValue;
  children: Array<FieldFilterPartDto>;
};

/** @internal */
export const StepFilterDtoValue$inboundSchema: z.ZodNativeEnum<typeof StepFilterDtoValue> =
  z.nativeEnum(StepFilterDtoValue);

/** @internal */
export const StepFilterDtoValue$outboundSchema: z.ZodNativeEnum<typeof StepFilterDtoValue> =
  StepFilterDtoValue$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StepFilterDtoValue$ {
  /** @deprecated use `StepFilterDtoValue$inboundSchema` instead. */
  export const inboundSchema = StepFilterDtoValue$inboundSchema;
  /** @deprecated use `StepFilterDtoValue$outboundSchema` instead. */
  export const outboundSchema = StepFilterDtoValue$outboundSchema;
}

/** @internal */
export const StepFilterDto$inboundSchema: z.ZodType<StepFilterDto, z.ZodTypeDef, unknown> = z.object({
  isNegated: z.boolean(),
  type: BuilderFieldTypeEnum$inboundSchema,
  value: StepFilterDtoValue$inboundSchema,
  children: z.array(FieldFilterPartDto$inboundSchema),
});

/** @internal */
export type StepFilterDto$Outbound = {
  isNegated: boolean;
  type: string;
  value: string;
  children: Array<FieldFilterPartDto$Outbound>;
};

/** @internal */
export const StepFilterDto$outboundSchema: z.ZodType<StepFilterDto$Outbound, z.ZodTypeDef, StepFilterDto> = z.object({
  isNegated: z.boolean(),
  type: BuilderFieldTypeEnum$outboundSchema,
  value: StepFilterDtoValue$outboundSchema,
  children: z.array(FieldFilterPartDto$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StepFilterDto$ {
  /** @deprecated use `StepFilterDto$inboundSchema` instead. */
  export const inboundSchema = StepFilterDto$inboundSchema;
  /** @deprecated use `StepFilterDto$outboundSchema` instead. */
  export const outboundSchema = StepFilterDto$outboundSchema;
  /** @deprecated use `StepFilterDto$Outbound` instead. */
  export type Outbound = StepFilterDto$Outbound;
}

export function stepFilterDtoToJSON(stepFilterDto: StepFilterDto): string {
  return JSON.stringify(StepFilterDto$outboundSchema.parse(stepFilterDto));
}

export function stepFilterDtoFromJSON(jsonString: string): SafeParseResult<StepFilterDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StepFilterDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StepFilterDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - stepFilterDtoToJSON(stepFilterDto: StepFilterDto)
 - stepFilterDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(StepFilterDto$Outbound;
}

export function stepFilterDtoToJSON(stepFilterDto: StepFilterDto): string...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function stepFilterDtoToJSON
- export function stepFilterDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/stepintegrationissue.ts
Tamaño: 2486 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  IntegrationIssueEnum,
  IntegrationIssueEnum$inboundSchema,
  IntegrationIssueEnum$outboundSchema,
} from './integrationissueenum.js';

export type StepIntegrationIssue = {
  /**
   * Type of integration issue
   */
  issueType: IntegrationIssueEnum;
  /**
   * Name of the variable related to the issue
   */
  variableName?: string | undefined;
  /**
   * Detailed message describing the issue
   */
  message: string;
};

/** @internal */
export const StepIntegrationIssue$inboundSchema: z.ZodType<StepIntegrationIssue, z.ZodTypeDef, unknown> = z.object({
  issueType: IntegrationIssueEnum$inboundSchema,
  variableName: z.string().optional(),
  message: z.string(),
});

/** @internal */
export type StepIntegrationIssue$Outbound = {
  issueType: string;
  variableName?: string | undefined;
  message: string;
};

/** @internal */
export const StepIntegrationIssue$outboundSchema: z.ZodType<
  StepIntegrationIssue$Outbound,
  z.ZodTypeDef,
  StepIntegrationIssue
> = z.object({
  issueType: IntegrationIssueEnum$outboundSchema,
  variableName: z.string().optional(),
  message: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StepIntegrationIssue$ {
  /** @deprecated use `StepIntegrationIssue$inboundSchema` instead. */
  export const inboundSchema = StepIntegrationIssue$inboundSchema;
  /** @deprecated use `StepIntegrationIssue$outboundSchema` instead. */
  export const outboundSchema = StepIntegrationIssue$outboundSchema;
  /** @deprecated use `StepIntegrationIssue$Outbound` instead. */
  export type Outbound = StepIntegrationIssue$Outbound;
}

export function stepIntegrationIssueToJSON(stepIntegrationIssue: StepIntegrationIssue): string {
  return JSON.stringify(StepIntegrationIssue$outboundSchema.parse(stepIntegrationIssue));
}

export function stepIntegrationIssueFromJSON(
  jsonString: string
): SafeParseResult<StepIntegrationIssue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StepIntegrationIssue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StepIntegrationIssue' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - stepIntegrationIssueToJSON(stepIntegrationIssue: StepIntegrationIssue)
 - stepIntegrationIssueFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(StepIntegrationIssue$Outbound;
}

export function stepIntegrationIssueToJSON(stepIntegrationIssue: S...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function stepIntegrationIssueToJSON
- export function stepIntegrationIssueFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/stepissuesdto.ts
Tamaño: 2681 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  StepContentIssueDto,
  StepContentIssueDto$inboundSchema,
  StepContentIssueDto$Outbound,
  StepContentIssueDto$outboundSchema,
} from './stepcontentissuedto.js';
import {
  StepIntegrationIssue,
  StepIntegrationIssue$inboundSchema,
  StepIntegrationIssue$Outbound,
  StepIntegrationIssue$outboundSchema,
} from './stepintegrationissue.js';

export type StepIssuesDto = {
  /**
   * Controls-related issues
   */
  controls?: { [k: string]: Array<StepContentIssueDto> } | undefined;
  /**
   * Integration-related issues
   */
  integration?: { [k: string]: Array<StepIntegrationIssue> } | undefined;
};

/** @internal */
export const StepIssuesDto$inboundSchema: z.ZodType<StepIssuesDto, z.ZodTypeDef, unknown> = z.object({
  controls: z.record(z.array(StepContentIssueDto$inboundSchema)).optional(),
  integration: z.record(z.array(StepIntegrationIssue$inboundSchema)).optional(),
});

/** @internal */
export type StepIssuesDto$Outbound = {
  controls?: { [k: string]: Array<StepContentIssueDto$Outbound> } | undefined;
  integration?: { [k: string]: Array<StepIntegrationIssue$Outbound> } | undefined;
};

/** @internal */
export const StepIssuesDto$outboundSchema: z.ZodType<StepIssuesDto$Outbound, z.ZodTypeDef, StepIssuesDto> = z.object({
  controls: z.record(z.array(StepContentIssueDto$outboundSchema)).optional(),
  integration: z.record(z.array(StepIntegrationIssue$outboundSchema)).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StepIssuesDto$ {
  /** @deprecated use `StepIssuesDto$inboundSchema` instead. */
  export const inboundSchema = StepIssuesDto$inboundSchema;
  /** @deprecated use `StepIssuesDto$outboundSchema` instead. */
  export const outboundSchema = StepIssuesDto$outboundSchema;
  /** @deprecated use `StepIssuesDto$Outbound` instead. */
  export type Outbound = StepIssuesDto$Outbound;
}

export function stepIssuesDtoToJSON(stepIssuesDto: StepIssuesDto): string {
  return JSON.stringify(StepIssuesDto$outboundSchema.parse(stepIssuesDto));
}

export function stepIssuesDtoFromJSON(jsonString: string): SafeParseResult<StepIssuesDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StepIssuesDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StepIssuesDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - stepIssuesDtoToJSON(stepIssuesDto: StepIssuesDto)
 - stepIssuesDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(StepIssuesDto$Outbound;
}

export function stepIssuesDtoToJSON(stepIssuesDto: StepIssuesDto): string...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function stepIssuesDtoToJSON
- export function stepIssuesDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/steplistresponsedto.ts
Tamaño: 2506 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  StepIssuesDto,
  StepIssuesDto$inboundSchema,
  StepIssuesDto$Outbound,
  StepIssuesDto$outboundSchema,
} from './stepissuesdto.js';
import { StepTypeEnum, StepTypeEnum$inboundSchema, StepTypeEnum$outboundSchema } from './steptypeenum.js';

export type StepListResponseDto = {
  /**
   * Slug of the step
   */
  slug: string;
  /**
   * Type of the step
   */
  type: StepTypeEnum;
  /**
   * Issues associated with the step
   */
  issues?: StepIssuesDto | undefined;
};

/** @internal */
export const StepListResponseDto$inboundSchema: z.ZodType<StepListResponseDto, z.ZodTypeDef, unknown> = z.object({
  slug: z.string(),
  type: StepTypeEnum$inboundSchema,
  issues: StepIssuesDto$inboundSchema.optional(),
});

/** @internal */
export type StepListResponseDto$Outbound = {
  slug: string;
  type: string;
  issues?: StepIssuesDto$Outbound | undefined;
};

/** @internal */
export const StepListResponseDto$outboundSchema: z.ZodType<
  StepListResponseDto$Outbound,
  z.ZodTypeDef,
  StepListResponseDto
> = z.object({
  slug: z.string(),
  type: StepTypeEnum$outboundSchema,
  issues: StepIssuesDto$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StepListResponseDto$ {
  /** @deprecated use `StepListResponseDto$inboundSchema` instead. */
  export const inboundSchema = StepListResponseDto$inboundSchema;
  /** @deprecated use `StepListResponseDto$outboundSchema` instead. */
  export const outboundSchema = StepListResponseDto$outboundSchema;
  /** @deprecated use `StepListResponseDto$Outbound` instead. */
  export type Outbound = StepListResponseDto$Outbound;
}

export function stepListResponseDtoToJSON(stepListResponseDto: StepListResponseDto): string {
  return JSON.stringify(StepListResponseDto$outboundSchema.parse(stepListResponseDto));
}

export function stepListResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<StepListResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StepListResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StepListResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - stepListResponseDtoToJSON(stepListResponseDto: StepListResponseDto)
 - stepListResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(StepListResponseDto$Outbound;
}

export function stepListResponseDtoToJSON(stepListResponseDto: Step...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function stepListResponseDtoToJSON
- export function stepListResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/stepresponsedto.ts
Tamaño: 4511 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ControlsMetadataDto,
  ControlsMetadataDto$inboundSchema,
  ControlsMetadataDto$Outbound,
  ControlsMetadataDto$outboundSchema,
} from './controlsmetadatadto.js';
import {
  ResourceOriginEnum,
  ResourceOriginEnum$inboundSchema,
  ResourceOriginEnum$outboundSchema,
} from './resourceoriginenum.js';
import {
  StepIssuesDto,
  StepIssuesDto$inboundSchema,
  StepIssuesDto$Outbound,
  StepIssuesDto$outboundSchema,
} from './stepissuesdto.js';
import { StepTypeEnum, StepTypeEnum$inboundSchema, StepTypeEnum$outboundSchema } from './steptypeenum.js';

export type StepResponseDto = {
  /**
   * Controls metadata for the step
   */
  controls: ControlsMetadataDto;
  /**
   * Control values for the step (alias for controls.values)
   */
  controlValues?: { [k: string]: any } | undefined;
  /**
   * JSON Schema for variables, follows the JSON Schema standard
   */
  variables: { [k: string]: any };
  /**
   * Unique identifier of the step
   */
  stepId: string;
  /**
   * Database identifier of the step
   */
  id: string;
  /**
   * Name of the step
   */
  name: string;
  /**
   * Slug of the step
   */
  slug: string;
  /**
   * Type of the step
   */
  type: StepTypeEnum;
  /**
   * Origin of the layout
   */
  origin: ResourceOriginEnum;
  /**
   * Workflow identifier
   */
  workflowId: string;
  /**
   * Workflow database identifier
   */
  workflowDatabaseId: string;
  /**
   * Issues associated with the step
   */
  issues?: StepIssuesDto | undefined;
};

/** @internal */
export const StepResponseDto$inboundSchema: z.ZodType<StepResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    controls: ControlsMetadataDto$inboundSchema,
    controlValues: z.record(z.any()).optional(),
    variables: z.record(z.any()),
    stepId: z.string(),
    _id: z.string(),
    name: z.string(),
    slug: z.string(),
    type: StepTypeEnum$inboundSchema,
    origin: ResourceOriginEnum$inboundSchema,
    workflowId: z.string(),
    workflowDatabaseId: z.string(),
    issues: StepIssuesDto$inboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type StepResponseDto$Outbound = {
  controls: ControlsMetadataDto$Outbound;
  controlValues?: { [k: string]: any } | undefined;
  variables: { [k: string]: any };
  stepId: string;
  _id: string;
  name: string;
  slug: string;
  type: string;
  origin: string;
  workflowId: string;
  workflowDatabaseId: string;
  issues?: StepIssuesDto$Outbound | undefined;
};

/** @internal */
export const StepResponseDto$outboundSchema: z.ZodType<StepResponseDto$Outbound, z.ZodTypeDef, StepResponseDto> = z
  .object({
    controls: ControlsMetadataDto$outboundSchema,
    controlValues: z.record(z.any()).optional(),
    variables: z.record(z.any()),
    stepId: z.string(),
    id: z.string(),
    name: z.string(),
    slug: z.string(),
    type: StepTypeEnum$outboundSchema,
    origin: ResourceOriginEnum$outboundSchema,
    workflowId: z.string(),
    workflowDatabaseId: z.string(),
    issues: StepIssuesDto$outboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StepResponseDto$ {
  /** @deprecated use `StepResponseDto$inboundSchema` instead. */
  export const inboundSchema = StepResponseDto$inboundSchema;
  /** @deprecated use `StepResponseDto$outboundSchema` instead. */
  export const outboundSchema = StepResponseDto$outboundSchema;
  /** @deprecated use `StepResponseDto$Outbound` instead. */
  export type Outbound = StepResponseDto$Outbound;
}

export function stepResponseDtoToJSON(stepResponseDto: StepResponseDto): string {
  return JSON.stringify(StepResponseDto$outboundSchema.parse(stepResponseDto));
}

export function stepResponseDtoFromJSON(jsonString: string): SafeParseResult<StepResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StepResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StepResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - stepResponseDtoToJSON(stepResponseDto: StepResponseDto)
 - stepResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(StepResponseDto$Outbound;
}

export function stepResponseDtoToJSON(stepResponseDto: StepResponseDto)...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function stepResponseDtoToJSON
- export function stepResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/steprundto.ts
Tamaño: 5073 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  DigestMetadataDto,
  DigestMetadataDto$inboundSchema,
  DigestMetadataDto$Outbound,
  DigestMetadataDto$outboundSchema,
} from './digestmetadatadto.js';
import {
  StepExecutionDetailDto,
  StepExecutionDetailDto$inboundSchema,
  StepExecutionDetailDto$Outbound,
  StepExecutionDetailDto$outboundSchema,
} from './stepexecutiondetaildto.js';

/**
 * Step status
 */
export const StepRunDtoStatus = {
  Pending: 'pending',
  Queued: 'queued',
  Running: 'running',
  Completed: 'completed',
  Failed: 'failed',
  Delayed: 'delayed',
  Canceled: 'canceled',
  Merged: 'merged',
  Skipped: 'skipped',
} as const;
/**
 * Step status
 */
export type StepRunDtoStatus = ClosedEnum<typeof StepRunDtoStatus>;

export type StepRunDto = {
  /**
   * Step run identifier
   */
  stepRunId: string;
  /**
   * Step identifier
   */
  stepId: string;
  /**
   * Step type
   */
  stepType: string;
  /**
   * Provider identifier
   */
  providerId?: string | undefined;
  /**
   * Step status
   */
  status: StepRunDtoStatus;
  /**
   * Creation timestamp
   */
  createdAt: Date;
  /**
   * Update timestamp
   */
  updatedAt: Date;
  /**
   * Execution details
   */
  executionDetails: Array<StepExecutionDetailDto>;
  /**
   * Optional digest for the job, including metadata and events
   */
  digest?: DigestMetadataDto | undefined;
  /**
   * The number of times the digest/delay job has been extended to align with the subscribers schedule
   */
  scheduleExtensionsCount?: number | undefined;
};

/** @internal */
export const StepRunDtoStatus$inboundSchema: z.ZodNativeEnum<typeof StepRunDtoStatus> = z.nativeEnum(StepRunDtoStatus);

/** @internal */
export const StepRunDtoStatus$outboundSchema: z.ZodNativeEnum<typeof StepRunDtoStatus> = StepRunDtoStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StepRunDtoStatus$ {
  /** @deprecated use `StepRunDtoStatus$inboundSchema` instead. */
  export const inboundSchema = StepRunDtoStatus$inboundSchema;
  /** @deprecated use `StepRunDtoStatus$outboundSchema` instead. */
  export const outboundSchema = StepRunDtoStatus$outboundSchema;
}

/** @internal */
export const StepRunDto$inboundSchema: z.ZodType<StepRunDto, z.ZodTypeDef, unknown> = z.object({
  stepRunId: z.string(),
  stepId: z.string(),
  stepType: z.string(),
  providerId: z.string().optional(),
  status: StepRunDtoStatus$inboundSchema,
  createdAt: z
    .string()
    .datetime({ offset: true })
    .transform((v) => new Date(v)),
  updatedAt: z
    .string()
    .datetime({ offset: true })
    .transform((v) => new Date(v)),
  executionDetails: z.array(StepExecutionDetailDto$inboundSchema),
  digest: DigestMetadataDto$inboundSchema.optional(),
  scheduleExtensionsCount: z.number().optional(),
});

/** @internal */
export type StepRunDto$Outbound = {
  stepRunId: string;
  stepId: string;
  stepType: string;
  providerId?: string | undefined;
  status: string;
  createdAt: string;
  updatedAt: string;
  executionDetails: Array<StepExecutionDetailDto$Outbound>;
  digest?: DigestMetadataDto$Outbound | undefined;
  scheduleExtensionsCount?: number | undefined;
};

/** @internal */
export const StepRunDto$outboundSchema: z.ZodType<StepRunDto$Outbound, z.ZodTypeDef, StepRunDto> = z.object({
  stepRunId: z.string(),
  stepId: z.string(),
  stepType: z.string(),
  providerId: z.string().optional(),
  status: StepRunDtoStatus$outboundSchema,
  createdAt: z.date().transform((v) => v.toISOString()),
  updatedAt: z.date().transform((v) => v.toISOString()),
  executionDetails: z.array(StepExecutionDetailDto$outboundSchema),
  digest: DigestMetadataDto$outboundSchema.optional(),
  scheduleExtensionsCount: z.number().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StepRunDto$ {
  /** @deprecated use `StepRunDto$inboundSchema` instead. */
  export const inboundSchema = StepRunDto$inboundSchema;
  /** @deprecated use `StepRunDto$outboundSchema` instead. */
  export const outboundSchema = StepRunDto$outboundSchema;
  /** @deprecated use `StepRunDto$Outbound` instead. */
  export type Outbound = StepRunDto$Outbound;
}

export function stepRunDtoToJSON(stepRunDto: StepRunDto): string {
  return JSON.stringify(StepRunDto$outboundSchema.parse(stepRunDto));
}

export function stepRunDtoFromJSON(jsonString: string): SafeParseResult<StepRunDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StepRunDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StepRunDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - stepRunDtoToJSON(stepRunDto: StepRunDto)
 - stepRunDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(StepRunDto$Outbound;
}

export function stepRunDtoToJSON(stepRunDto: StepRunDto): string {
  return ...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function stepRunDtoToJSON
- export function stepRunDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/stepsoverrides.ts
Tamaño: 2218 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type StepsOverrides = {
  /**
   * Passing the provider id and the provider specific configurations
   */
  providers?: { [k: string]: { [k: string]: any } } | undefined;
  /**
   * Override the or remove the layout for this specific step
   */
  layoutId?: string | null | undefined;
};

/** @internal */
export const StepsOverrides$inboundSchema: z.ZodType<StepsOverrides, z.ZodTypeDef, unknown> = z.object({
  providers: z.record(z.record(z.any())).optional(),
  layoutId: z.nullable(z.string()).optional(),
});

/** @internal */
export type StepsOverrides$Outbound = {
  providers?: { [k: string]: { [k: string]: any } } | undefined;
  layoutId?: string | null | undefined;
};

/** @internal */
export const StepsOverrides$outboundSchema: z.ZodType<StepsOverrides$Outbound, z.ZodTypeDef, StepsOverrides> = z.object(
  {
    providers: z.record(z.record(z.any())).optional(),
    layoutId: z.nullable(z.string()).optional(),
  }
);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StepsOverrides$ {
  /** @deprecated use `StepsOverrides$inboundSchema` instead. */
  export const inboundSchema = StepsOverrides$inboundSchema;
  /** @deprecated use `StepsOverrides$outboundSchema` instead. */
  export const outboundSchema = StepsOverrides$outboundSchema;
  /** @deprecated use `StepsOverrides$Outbound` instead. */
  export type Outbound = StepsOverrides$Outbound;
}

export function stepsOverridesToJSON(stepsOverrides: StepsOverrides): string {
  return JSON.stringify(StepsOverrides$outboundSchema.parse(stepsOverrides));
}

export function stepsOverridesFromJSON(jsonString: string): SafeParseResult<StepsOverrides, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StepsOverrides$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StepsOverrides' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - stepsOverridesToJSON(stepsOverrides: StepsOverrides)
 - stepsOverridesFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(StepsOverrides$Outbound;
}

export function stepsOverridesToJSON(stepsOverrides: StepsOverrides): st...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function stepsOverridesToJSON
- export function stepsOverridesFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/steptypeenum.ts
Tamaño: 1193 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Type of the step
 */
export const StepTypeEnum = {
  InApp: 'in_app',
  Email: 'email',
  Sms: 'sms',
  Chat: 'chat',
  Push: 'push',
  Digest: 'digest',
  Trigger: 'trigger',
  Delay: 'delay',
  Throttle: 'throttle',
  Custom: 'custom',
} as const;
/**
 * Type of the step
 */
export type StepTypeEnum = ClosedEnum<typeof StepTypeEnum>;

/** @internal */
export const StepTypeEnum$inboundSchema: z.ZodNativeEnum<typeof StepTypeEnum> = z.nativeEnum(StepTypeEnum);

/** @internal */
export const StepTypeEnum$outboundSchema: z.ZodNativeEnum<typeof StepTypeEnum> = StepTypeEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StepTypeEnum$ {
  /** @deprecated use `StepTypeEnum$inboundSchema` instead. */
  export const inboundSchema = StepTypeEnum$inboundSchema;
  /** @deprecated use `StepTypeEnum$outboundSchema` instead. */
  export const outboundSchema = StepTypeEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/subscriberchanneldto.ts
Tamaño: 4029 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ChannelCredentialsDto,
  ChannelCredentialsDto$inboundSchema,
  ChannelCredentialsDto$Outbound,
  ChannelCredentialsDto$outboundSchema,
} from './channelcredentialsdto.js';

/**
 * The ID of the chat or push provider.
 */
export const ProviderId = {
  Slack: 'slack',
  Discord: 'discord',
  Msteams: 'msteams',
  Mattermost: 'mattermost',
  Ryver: 'ryver',
  Zulip: 'zulip',
  GrafanaOnCall: 'grafana-on-call',
  Getstream: 'getstream',
  RocketChat: 'rocket-chat',
  WhatsappBusiness: 'whatsapp-business',
  ChatWebhook: 'chat-webhook',
  NovuSlack: 'novu-slack',
  Fcm: 'fcm',
  Apns: 'apns',
  Expo: 'expo',
  OneSignal: 'one-signal',
  Pushpad: 'pushpad',
  PushWebhook: 'push-webhook',
  PusherBeams: 'pusher-beams',
} as const;
/**
 * The ID of the chat or push provider.
 */
export type ProviderId = ClosedEnum<typeof ProviderId>;

export type SubscriberChannelDto = {
  /**
   * The ID of the chat or push provider.
   */
  providerId: ProviderId;
  /**
   * An optional identifier for the integration.
   */
  integrationIdentifier?: string | undefined;
  /**
   * Credentials for the channel.
   */
  credentials: ChannelCredentialsDto;
};

/** @internal */
export const ProviderId$inboundSchema: z.ZodNativeEnum<typeof ProviderId> = z.nativeEnum(ProviderId);

/** @internal */
export const ProviderId$outboundSchema: z.ZodNativeEnum<typeof ProviderId> = ProviderId$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ProviderId$ {
  /** @deprecated use `ProviderId$inboundSchema` instead. */
  export const inboundSchema = ProviderId$inboundSchema;
  /** @deprecated use `ProviderId$outboundSchema` instead. */
  export const outboundSchema = ProviderId$outboundSchema;
}

/** @internal */
export const SubscriberChannelDto$inboundSchema: z.ZodType<SubscriberChannelDto, z.ZodTypeDef, unknown> = z.object({
  providerId: ProviderId$inboundSchema,
  integrationIdentifier: z.string().optional(),
  credentials: ChannelCredentialsDto$inboundSchema,
});

/** @internal */
export type SubscriberChannelDto$Outbound = {
  providerId: string;
  integrationIdentifier?: string | undefined;
  credentials: ChannelCredentialsDto$Outbound;
};

/** @internal */
export const SubscriberChannelDto$outboundSchema: z.ZodType<
  SubscriberChannelDto$Outbound,
  z.ZodTypeDef,
  SubscriberChannelDto
> = z.object({
  providerId: ProviderId$outboundSchema,
  integrationIdentifier: z.string().optional(),
  credentials: ChannelCredentialsDto$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriberChannelDto$ {
  /** @deprecated use `SubscriberChannelDto$inboundSchema` instead. */
  export const inboundSchema = SubscriberChannelDto$inboundSchema;
  /** @deprecated use `SubscriberChannelDto$outboundSchema` instead. */
  export const outboundSchema = SubscriberChannelDto$outboundSchema;
  /** @deprecated use `SubscriberChannelDto$Outbound` instead. */
  export type Outbound = SubscriberChannelDto$Outbound;
}

export function subscriberChannelDtoToJSON(subscriberChannelDto: SubscriberChannelDto): string {
  return JSON.stringify(SubscriberChannelDto$outboundSchema.parse(subscriberChannelDto));
}

export function subscriberChannelDtoFromJSON(
  jsonString: string
): SafeParseResult<SubscriberChannelDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriberChannelDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriberChannelDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscriberChannelDtoToJSON(subscriberChannelDto: SubscriberChannelDto)
 - subscriberChannelDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscriberChannelDto$Outbound;
}

export function subscriberChannelDtoToJSON(subscriberChannelDto: S...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriberChannelDtoToJSON
- export function subscriberChannelDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/subscriberdto.ts
Tamaño: 3015 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscriberDto = {
  /**
   * The identifier of the subscriber
   */
  id: string;
  /**
   * The external identifier of the subscriber
   */
  subscriberId: string;
  /**
   * The avatar URL of the subscriber
   */
  avatar?: string | null | undefined;
  /**
   * The first name of the subscriber
   */
  firstName?: string | null | undefined;
  /**
   * The last name of the subscriber
   */
  lastName?: string | null | undefined;
  /**
   * The email of the subscriber
   */
  email?: string | null | undefined;
};

/** @internal */
export const SubscriberDto$inboundSchema: z.ZodType<SubscriberDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string(),
    subscriberId: z.string(),
    avatar: z.nullable(z.string()).optional(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    email: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type SubscriberDto$Outbound = {
  _id: string;
  subscriberId: string;
  avatar?: string | null | undefined;
  firstName?: string | null | undefined;
  lastName?: string | null | undefined;
  email?: string | null | undefined;
};

/** @internal */
export const SubscriberDto$outboundSchema: z.ZodType<SubscriberDto$Outbound, z.ZodTypeDef, SubscriberDto> = z
  .object({
    id: z.string(),
    subscriberId: z.string(),
    avatar: z.nullable(z.string()).optional(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    email: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriberDto$ {
  /** @deprecated use `SubscriberDto$inboundSchema` instead. */
  export const inboundSchema = SubscriberDto$inboundSchema;
  /** @deprecated use `SubscriberDto$outboundSchema` instead. */
  export const outboundSchema = SubscriberDto$outboundSchema;
  /** @deprecated use `SubscriberDto$Outbound` instead. */
  export type Outbound = SubscriberDto$Outbound;
}

export function subscriberDtoToJSON(subscriberDto: SubscriberDto): string {
  return JSON.stringify(SubscriberDto$outboundSchema.parse(subscriberDto));
}

export function subscriberDtoFromJSON(jsonString: string): SafeParseResult<SubscriberDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriberDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriberDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscriberDtoToJSON(subscriberDto: SubscriberDto)
 - subscriberDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscriberDto$Outbound;
}

export function subscriberDtoToJSON(subscriberDto: SubscriberDto): string...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriberDtoToJSON
- export function subscriberDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/subscriberfeedresponsedto.ts
Tamaño: 3232 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscriberFeedResponseDto = {
  /**
   * The internal ID generated by Novu for your subscriber. This ID does not match the `subscriberId` used in your queries. Refer to `subscriberId` for that identifier.
   */
  id?: string | undefined;
  /**
   * The first name of the subscriber.
   */
  firstName?: string | undefined;
  /**
   * The last name of the subscriber.
   */
  lastName?: string | undefined;
  /**
   * The URL of the subscriber's avatar image.
   */
  avatar?: string | undefined;
  /**
   * The identifier used to create this subscriber, which typically corresponds to the user ID in your system.
   */
  subscriberId: string;
};

/** @internal */
export const SubscriberFeedResponseDto$inboundSchema: z.ZodType<SubscriberFeedResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().optional(),
    firstName: z.string().optional(),
    lastName: z.string().optional(),
    avatar: z.string().optional(),
    subscriberId: z.string(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type SubscriberFeedResponseDto$Outbound = {
  _id?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  avatar?: string | undefined;
  subscriberId: string;
};

/** @internal */
export const SubscriberFeedResponseDto$outboundSchema: z.ZodType<
  SubscriberFeedResponseDto$Outbound,
  z.ZodTypeDef,
  SubscriberFeedResponseDto
> = z
  .object({
    id: z.string().optional(),
    firstName: z.string().optional(),
    lastName: z.string().optional(),
    avatar: z.string().optional(),
    subscriberId: z.string(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriberFeedResponseDto$ {
  /** @deprecated use `SubscriberFeedResponseDto$inboundSchema` instead. */
  export const inboundSchema = SubscriberFeedResponseDto$inboundSchema;
  /** @deprecated use `SubscriberFeedResponseDto$outboundSchema` instead. */
  export const outboundSchema = SubscriberFeedResponseDto$outboundSchema;
  /** @deprecated use `SubscriberFeedResponseDto$Outbound` instead. */
  export type Outbound = SubscriberFeedResponseDto$Outbound;
}

export function subscriberFeedResponseDtoToJSON(subscriberFeedResponseDto: SubscriberFeedResponseDto): string {
  return JSON.stringify(SubscriberFeedResponseDto$outboundSchema.parse(subscriberFeedResponseDto));
}

export function subscriberFeedResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<SubscriberFeedResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriberFeedResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriberFeedResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscriberFeedResponseDtoToJSON(subscriberFeedResponseDto: SubscriberFeedResponseDto)
 - subscriberFeedResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscriberFeedResponseDto$Outbound;
}

export function subscriberFeedResponseDtoToJSON(subscriberFee...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriberFeedResponseDtoToJSON
- export function subscriberFeedResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/subscriberglobalpreferencedto.ts
Tamaño: 2995 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ScheduleDto,
  ScheduleDto$inboundSchema,
  ScheduleDto$Outbound,
  ScheduleDto$outboundSchema,
} from './scheduledto.js';
import {
  SubscriberPreferenceChannels,
  SubscriberPreferenceChannels$inboundSchema,
  SubscriberPreferenceChannels$Outbound,
  SubscriberPreferenceChannels$outboundSchema,
} from './subscriberpreferencechannels.js';

export type SubscriberGlobalPreferenceDto = {
  /**
   * Whether notifications are enabled globally
   */
  enabled: boolean;
  /**
   * Channel-specific preference settings
   */
  channels: SubscriberPreferenceChannels;
  /**
   * Subscriber schedule
   */
  schedule?: ScheduleDto | undefined;
};

/** @internal */
export const SubscriberGlobalPreferenceDto$inboundSchema: z.ZodType<
  SubscriberGlobalPreferenceDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean(),
  channels: SubscriberPreferenceChannels$inboundSchema,
  schedule: ScheduleDto$inboundSchema.optional(),
});

/** @internal */
export type SubscriberGlobalPreferenceDto$Outbound = {
  enabled: boolean;
  channels: SubscriberPreferenceChannels$Outbound;
  schedule?: ScheduleDto$Outbound | undefined;
};

/** @internal */
export const SubscriberGlobalPreferenceDto$outboundSchema: z.ZodType<
  SubscriberGlobalPreferenceDto$Outbound,
  z.ZodTypeDef,
  SubscriberGlobalPreferenceDto
> = z.object({
  enabled: z.boolean(),
  channels: SubscriberPreferenceChannels$outboundSchema,
  schedule: ScheduleDto$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriberGlobalPreferenceDto$ {
  /** @deprecated use `SubscriberGlobalPreferenceDto$inboundSchema` instead. */
  export const inboundSchema = SubscriberGlobalPreferenceDto$inboundSchema;
  /** @deprecated use `SubscriberGlobalPreferenceDto$outboundSchema` instead. */
  export const outboundSchema = SubscriberGlobalPreferenceDto$outboundSchema;
  /** @deprecated use `SubscriberGlobalPreferenceDto$Outbound` instead. */
  export type Outbound = SubscriberGlobalPreferenceDto$Outbound;
}

export function subscriberGlobalPreferenceDtoToJSON(
  subscriberGlobalPreferenceDto: SubscriberGlobalPreferenceDto
): string {
  return JSON.stringify(SubscriberGlobalPreferenceDto$outboundSchema.parse(subscriberGlobalPreferenceDto));
}

export function subscriberGlobalPreferenceDtoFromJSON(
  jsonString: string
): SafeParseResult<SubscriberGlobalPreferenceDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriberGlobalPreferenceDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriberGlobalPreferenceDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscriberGlobalPreferenceDtoToJSON(subscriberGlobalPreferenceDto: SubscriberGlobalPreferenceDto)
 - subscriberGlobalPreferenceDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscriberGlobalPreferenceDto$Outbound;
}

export function subscriberGlobalPreferenceDtoToJSON(
  su...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriberGlobalPreferenceDtoToJSON
- export function subscriberGlobalPreferenceDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/subscriberpayloaddto.ts
Tamaño: 6025 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  SubscriberChannelDto,
  SubscriberChannelDto$inboundSchema,
  SubscriberChannelDto$Outbound,
  SubscriberChannelDto$outboundSchema,
} from './subscriberchanneldto.js';

export type SubscriberPayloadDtoData = string | Array<string> | boolean | number;

export type SubscriberPayloadDto = {
  /**
   * The internal identifier you used to create this subscriber, usually correlates to the id the user in your systems
   */
  subscriberId: string;
  /**
   * The email address of the subscriber.
   */
  email?: string | undefined;
  /**
   * The first name of the subscriber.
   */
  firstName?: string | undefined;
  /**
   * The last name of the subscriber.
   */
  lastName?: string | undefined;
  /**
   * The phone number of the subscriber.
   */
  phone?: string | undefined;
  /**
   * An HTTP URL to the profile image of your subscriber.
   */
  avatar?: string | undefined;
  /**
   * The locale of the subscriber.
   */
  locale?: string | undefined;
  /**
   * An optional payload object that can contain any properties.
   */
  data?: { [k: string]: string | Array<string> | boolean | number } | undefined;
  /**
   * An optional array of subscriber channels.
   */
  channels?: Array<SubscriberChannelDto> | undefined;
  /**
   * The timezone of the subscriber.
   */
  timezone?: string | undefined;
};

/** @internal */
export const SubscriberPayloadDtoData$inboundSchema: z.ZodType<SubscriberPayloadDtoData, z.ZodTypeDef, unknown> =
  z.union([z.string(), z.array(z.string()), z.boolean(), z.number()]);

/** @internal */
export type SubscriberPayloadDtoData$Outbound = string | Array<string> | boolean | number;

/** @internal */
export const SubscriberPayloadDtoData$outboundSchema: z.ZodType<
  SubscriberPayloadDtoData$Outbound,
  z.ZodTypeDef,
  SubscriberPayloadDtoData
> = z.union([z.string(), z.array(z.string()), z.boolean(), z.number()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriberPayloadDtoData$ {
  /** @deprecated use `SubscriberPayloadDtoData$inboundSchema` instead. */
  export const inboundSchema = SubscriberPayloadDtoData$inboundSchema;
  /** @deprecated use `SubscriberPayloadDtoData$outboundSchema` instead. */
  export const outboundSchema = SubscriberPayloadDtoData$outboundSchema;
  /** @deprecated use `SubscriberPayloadDtoData$Outbound` instead. */
  export type Outbound = SubscriberPayloadDtoData$Outbound;
}

export function subscriberPayloadDtoDataToJSON(subscriberPayloadDtoData: SubscriberPayloadDtoData): string {
  return JSON.stringify(SubscriberPayloadDtoData$outboundSchema.parse(subscriberPayloadDtoData));
}

export function subscriberPayloadDtoDataFromJSON(
  jsonString: string
): SafeParseResult<SubscriberPayloadDtoData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriberPayloadDtoData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriberPayloadDtoData' from JSON`
  );
}

/** @internal */
export const SubscriberPayloadDto$inboundSchema: z.ZodType<SubscriberPayloadDto, z.ZodTypeDef, unknown> = z.object({
  subscriberId: z.string(),
  email: z.string().optional(),
  firstName: z.string().optional(),
  lastName: z.string().optional(),
  phone: z.string().optional(),
  avatar: z.string().optional(),
  locale: z.string().optional(),
  data: z.record(z.union([z.string(), z.array(z.string()), z.boolean(), z.number()])).optional(),
  channels: z.array(SubscriberChannelDto$inboundSchema).optional(),
  timezone: z.string().optional(),
});

/** @internal */
export type SubscriberPayloadDto$Outbound = {
  subscriberId: string;
  email?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phone?: string | undefined;
  avatar?: string | undefined;
  locale?: string | undefined;
  data?: { [k: string]: string | Array<string> | boolean | number } | undefined;
  channels?: Array<SubscriberChannelDto$Outbound> | undefined;
  timezone?: string | undefined;
};

/** @internal */
export const SubscriberPayloadDto$outboundSchema: z.ZodType<
  SubscriberPayloadDto$Outbound,
  z.ZodTypeDef,
  SubscriberPayloadDto
> = z.object({
  subscriberId: z.string(),
  email: z.string().optional(),
  firstName: z.string().optional(),
  lastName: z.string().optional(),
  phone: z.string().optional(),
  avatar: z.string().optional(),
  locale: z.string().optional(),
  data: z.record(z.union([z.string(), z.array(z.string()), z.boolean(), z.number()])).optional(),
  channels: z.array(SubscriberChannelDto$outboundSchema).optional(),
  timezone: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriberPayloadDto$ {
  /** @deprecated use `SubscriberPayloadDto$inboundSchema` instead. */
  export const inboundSchema = SubscriberPayloadDto$inboundSchema;
  /** @deprecated use `SubscriberPayloadDto$outboundSchema` instead. */
  export const outboundSchema = SubscriberPayloadDto$outboundSchema;
  /** @deprecated use `SubscriberPayloadDto$Outbound` instead. */
  export type Outbound = SubscriberPayloadDto$Outbound;
}

export function subscriberPayloadDtoToJSON(subscriberPayloadDto: SubscriberPayloadDto): string {
  return JSON.stringify(SubscriberPayloadDto$outboundSchema.parse(subscriberPayloadDto));
}

export function subscriberPayloadDtoFromJSON(
  jsonString: string
): SafeParseResult<SubscriberPayloadDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriberPayloadDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriberPayloadDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscriberPayloadDtoDataToJSON(subscriberPayloadDtoData: SubscriberPayloadDtoData)
 - subscriberPayloadDtoDataFromJSON(jsonString: string)
 - subscriberPayloadDtoToJSON(subscriberPayloadDto: SubscriberPayloadDto)
 - subscriberPayloadDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscriberPayloadDtoData$Outbound;
}

export function subscriberPayloadDtoDataToJSON(subscriberPaylo...)
 - Outbound(SubscriberPayloadDto$Outbound;
}

export function subscriberPayloadDtoToJSON(subscriberPayloadDto: S...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriberPayloadDtoDataToJSON
- export function subscriberPayloadDtoDataFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriberPayloadDtoToJSON
- export function subscriberPayloadDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/subscriberpreferencechannels.ts
Tamaño: 3081 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscriberPreferenceChannels = {
  /**
   * Email channel preference
   */
  email?: boolean | undefined;
  /**
   * SMS channel preference
   */
  sms?: boolean | undefined;
  /**
   * In-app channel preference
   */
  inApp?: boolean | undefined;
  /**
   * Chat channel preference
   */
  chat?: boolean | undefined;
  /**
   * Push notification channel preference
   */
  push?: boolean | undefined;
};

/** @internal */
export const SubscriberPreferenceChannels$inboundSchema: z.ZodType<
  SubscriberPreferenceChannels,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    email: z.boolean().optional(),
    sms: z.boolean().optional(),
    in_app: z.boolean().optional(),
    chat: z.boolean().optional(),
    push: z.boolean().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      in_app: 'inApp',
    });
  });

/** @internal */
export type SubscriberPreferenceChannels$Outbound = {
  email?: boolean | undefined;
  sms?: boolean | undefined;
  in_app?: boolean | undefined;
  chat?: boolean | undefined;
  push?: boolean | undefined;
};

/** @internal */
export const SubscriberPreferenceChannels$outboundSchema: z.ZodType<
  SubscriberPreferenceChannels$Outbound,
  z.ZodTypeDef,
  SubscriberPreferenceChannels
> = z
  .object({
    email: z.boolean().optional(),
    sms: z.boolean().optional(),
    inApp: z.boolean().optional(),
    chat: z.boolean().optional(),
    push: z.boolean().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      inApp: 'in_app',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriberPreferenceChannels$ {
  /** @deprecated use `SubscriberPreferenceChannels$inboundSchema` instead. */
  export const inboundSchema = SubscriberPreferenceChannels$inboundSchema;
  /** @deprecated use `SubscriberPreferenceChannels$outboundSchema` instead. */
  export const outboundSchema = SubscriberPreferenceChannels$outboundSchema;
  /** @deprecated use `SubscriberPreferenceChannels$Outbound` instead. */
  export type Outbound = SubscriberPreferenceChannels$Outbound;
}

export function subscriberPreferenceChannelsToJSON(subscriberPreferenceChannels: SubscriberPreferenceChannels): string {
  return JSON.stringify(SubscriberPreferenceChannels$outboundSchema.parse(subscriberPreferenceChannels));
}

export function subscriberPreferenceChannelsFromJSON(
  jsonString: string
): SafeParseResult<SubscriberPreferenceChannels, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriberPreferenceChannels$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriberPreferenceChannels' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscriberPreferenceChannelsToJSON(subscriberPreferenceChannels: SubscriberPreferenceChannels)
 - subscriberPreferenceChannelsFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscriberPreferenceChannels$Outbound;
}

export function subscriberPreferenceChannelsToJSON(subscri...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriberPreferenceChannelsToJSON
- export function subscriberPreferenceChannelsFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/subscriberpreferenceoverridedto.ts
Tamaño: 2758 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import { ChannelTypeEnum, ChannelTypeEnum$inboundSchema, ChannelTypeEnum$outboundSchema } from './channeltypeenum.js';
import {
  PreferenceOverrideSourceEnum,
  PreferenceOverrideSourceEnum$inboundSchema,
  PreferenceOverrideSourceEnum$outboundSchema,
} from './preferenceoverridesourceenum.js';

export type SubscriberPreferenceOverrideDto = {
  /**
   * Channel type through which the message is sent
   */
  channel: ChannelTypeEnum;
  /**
   * The source of overrides
   */
  source: PreferenceOverrideSourceEnum;
};

/** @internal */
export const SubscriberPreferenceOverrideDto$inboundSchema: z.ZodType<
  SubscriberPreferenceOverrideDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  channel: ChannelTypeEnum$inboundSchema,
  source: PreferenceOverrideSourceEnum$inboundSchema,
});

/** @internal */
export type SubscriberPreferenceOverrideDto$Outbound = {
  channel: string;
  source: string;
};

/** @internal */
export const SubscriberPreferenceOverrideDto$outboundSchema: z.ZodType<
  SubscriberPreferenceOverrideDto$Outbound,
  z.ZodTypeDef,
  SubscriberPreferenceOverrideDto
> = z.object({
  channel: ChannelTypeEnum$outboundSchema,
  source: PreferenceOverrideSourceEnum$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriberPreferenceOverrideDto$ {
  /** @deprecated use `SubscriberPreferenceOverrideDto$inboundSchema` instead. */
  export const inboundSchema = SubscriberPreferenceOverrideDto$inboundSchema;
  /** @deprecated use `SubscriberPreferenceOverrideDto$outboundSchema` instead. */
  export const outboundSchema = SubscriberPreferenceOverrideDto$outboundSchema;
  /** @deprecated use `SubscriberPreferenceOverrideDto$Outbound` instead. */
  export type Outbound = SubscriberPreferenceOverrideDto$Outbound;
}

export function subscriberPreferenceOverrideDtoToJSON(
  subscriberPreferenceOverrideDto: SubscriberPreferenceOverrideDto
): string {
  return JSON.stringify(SubscriberPreferenceOverrideDto$outboundSchema.parse(subscriberPreferenceOverrideDto));
}

export function subscriberPreferenceOverrideDtoFromJSON(
  jsonString: string
): SafeParseResult<SubscriberPreferenceOverrideDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriberPreferenceOverrideDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriberPreferenceOverrideDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscriberPreferenceOverrideDtoToJSON(subscriberPreferenceOverrideDto: SubscriberPreferenceOverrideDto)
 - subscriberPreferenceOverrideDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscriberPreferenceOverrideDto$Outbound;
}

export function subscriberPreferenceOverrideDtoToJSON(
...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriberPreferenceOverrideDtoToJSON
- export function subscriberPreferenceOverrideDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/subscriberpreferencesworkflowinfodto.ts
Tamaño: 2723 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscriberPreferencesWorkflowInfoDto = {
  /**
   * Workflow slug
   */
  slug: string;
  /**
   * Unique identifier of the workflow
   */
  identifier: string;
  /**
   * Display name of the workflow
   */
  name: string;
  /**
   * last updated date
   */
  updatedAt?: string | undefined;
};

/** @internal */
export const SubscriberPreferencesWorkflowInfoDto$inboundSchema: z.ZodType<
  SubscriberPreferencesWorkflowInfoDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  slug: z.string(),
  identifier: z.string(),
  name: z.string(),
  updatedAt: z.string().optional(),
});

/** @internal */
export type SubscriberPreferencesWorkflowInfoDto$Outbound = {
  slug: string;
  identifier: string;
  name: string;
  updatedAt?: string | undefined;
};

/** @internal */
export const SubscriberPreferencesWorkflowInfoDto$outboundSchema: z.ZodType<
  SubscriberPreferencesWorkflowInfoDto$Outbound,
  z.ZodTypeDef,
  SubscriberPreferencesWorkflowInfoDto
> = z.object({
  slug: z.string(),
  identifier: z.string(),
  name: z.string(),
  updatedAt: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriberPreferencesWorkflowInfoDto$ {
  /** @deprecated use `SubscriberPreferencesWorkflowInfoDto$inboundSchema` instead. */
  export const inboundSchema = SubscriberPreferencesWorkflowInfoDto$inboundSchema;
  /** @deprecated use `SubscriberPreferencesWorkflowInfoDto$outboundSchema` instead. */
  export const outboundSchema = SubscriberPreferencesWorkflowInfoDto$outboundSchema;
  /** @deprecated use `SubscriberPreferencesWorkflowInfoDto$Outbound` instead. */
  export type Outbound = SubscriberPreferencesWorkflowInfoDto$Outbound;
}

export function subscriberPreferencesWorkflowInfoDtoToJSON(
  subscriberPreferencesWorkflowInfoDto: SubscriberPreferencesWorkflowInfoDto
): string {
  return JSON.stringify(
    SubscriberPreferencesWorkflowInfoDto$outboundSchema.parse(subscriberPreferencesWorkflowInfoDto)
  );
}

export function subscriberPreferencesWorkflowInfoDtoFromJSON(
  jsonString: string
): SafeParseResult<SubscriberPreferencesWorkflowInfoDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriberPreferencesWorkflowInfoDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriberPreferencesWorkflowInfoDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscriberPreferencesWorkflowInfoDtoToJSON(subscriberPreferencesWorkflowInfoDto: SubscriberPreferencesWorkflowInfoDto)
 - subscriberPreferencesWorkflowInfoDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscriberPreferencesWorkflowInfoDto$Outbound;
}

export function subscriberPreferencesWorkflowInfoD...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriberPreferencesWorkflowInfoDtoToJSON
- export function subscriberPreferencesWorkflowInfoDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/subscriberresponsedto.ts
Tamaño: 7178 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ChannelSettingsDto,
  ChannelSettingsDto$inboundSchema,
  ChannelSettingsDto$Outbound,
  ChannelSettingsDto$outboundSchema,
} from './channelsettingsdto.js';

export type SubscriberResponseDto = {
  /**
   * The internal ID generated by Novu for your subscriber. This ID does not match the `subscriberId` used in your queries. Refer to `subscriberId` for that identifier.
   */
  id?: string | undefined;
  /**
   * The first name of the subscriber.
   */
  firstName?: string | null | undefined;
  /**
   * The last name of the subscriber.
   */
  lastName?: string | null | undefined;
  /**
   * The email address of the subscriber.
   */
  email?: string | null | undefined;
  /**
   * The phone number of the subscriber.
   */
  phone?: string | null | undefined;
  /**
   * The URL of the subscriber's avatar image.
   */
  avatar?: string | null | undefined;
  /**
   * The locale setting of the subscriber, indicating their preferred language or region.
   */
  locale?: string | null | undefined;
  /**
   * An array of channel settings associated with the subscriber.
   */
  channels?: Array<ChannelSettingsDto> | undefined;
  /**
   * An array of topics that the subscriber is subscribed to.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  topics?: Array<string> | undefined;
  /**
   * Indicates whether the subscriber is currently online.
   */
  isOnline?: boolean | null | undefined;
  /**
   * The timestamp indicating when the subscriber was last online, in ISO 8601 format.
   */
  lastOnlineAt?: string | null | undefined;
  /**
   * The version of the subscriber document.
   */
  v?: number | undefined;
  /**
   * Additional custom data for the subscriber
   */
  data?: { [k: string]: any } | null | undefined;
  /**
   * Timezone of the subscriber
   */
  timezone?: string | null | undefined;
  /**
   * The identifier used to create this subscriber, which typically corresponds to the user ID in your system.
   */
  subscriberId: string;
  /**
   * The unique identifier of the organization to which the subscriber belongs.
   */
  organizationId: string;
  /**
   * The unique identifier of the environment associated with this subscriber.
   */
  environmentId: string;
  /**
   * Indicates whether the subscriber has been deleted.
   */
  deleted: boolean;
  /**
   * The timestamp indicating when the subscriber was created, in ISO 8601 format.
   */
  createdAt: string;
  /**
   * The timestamp indicating when the subscriber was last updated, in ISO 8601 format.
   */
  updatedAt: string;
};

/** @internal */
export const SubscriberResponseDto$inboundSchema: z.ZodType<SubscriberResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().optional(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    email: z.nullable(z.string()).optional(),
    phone: z.nullable(z.string()).optional(),
    avatar: z.nullable(z.string()).optional(),
    locale: z.nullable(z.string()).optional(),
    channels: z.array(ChannelSettingsDto$inboundSchema).optional(),
    topics: z.array(z.string()).optional(),
    isOnline: z.nullable(z.boolean()).optional(),
    lastOnlineAt: z.nullable(z.string()).optional(),
    __v: z.number().optional(),
    data: z.nullable(z.record(z.any())).optional(),
    timezone: z.nullable(z.string()).optional(),
    subscriberId: z.string(),
    _organizationId: z.string(),
    _environmentId: z.string(),
    deleted: z.boolean(),
    createdAt: z.string(),
    updatedAt: z.string(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
      __v: 'v',
      _organizationId: 'organizationId',
      _environmentId: 'environmentId',
    });
  });

/** @internal */
export type SubscriberResponseDto$Outbound = {
  _id?: string | undefined;
  firstName?: string | null | undefined;
  lastName?: string | null | undefined;
  email?: string | null | undefined;
  phone?: string | null | undefined;
  avatar?: string | null | undefined;
  locale?: string | null | undefined;
  channels?: Array<ChannelSettingsDto$Outbound> | undefined;
  topics?: Array<string> | undefined;
  isOnline?: boolean | null | undefined;
  lastOnlineAt?: string | null | undefined;
  __v?: number | undefined;
  data?: { [k: string]: any } | null | undefined;
  timezone?: string | null | undefined;
  subscriberId: string;
  _organizationId: string;
  _environmentId: string;
  deleted: boolean;
  createdAt: string;
  updatedAt: string;
};

/** @internal */
export const SubscriberResponseDto$outboundSchema: z.ZodType<
  SubscriberResponseDto$Outbound,
  z.ZodTypeDef,
  SubscriberResponseDto
> = z
  .object({
    id: z.string().optional(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    email: z.nullable(z.string()).optional(),
    phone: z.nullable(z.string()).optional(),
    avatar: z.nullable(z.string()).optional(),
    locale: z.nullable(z.string()).optional(),
    channels: z.array(ChannelSettingsDto$outboundSchema).optional(),
    topics: z.array(z.string()).optional(),
    isOnline: z.nullable(z.boolean()).optional(),
    lastOnlineAt: z.nullable(z.string()).optional(),
    v: z.number().optional(),
    data: z.nullable(z.record(z.any())).optional(),
    timezone: z.nullable(z.string()).optional(),
    subscriberId: z.string(),
    organizationId: z.string(),
    environmentId: z.string(),
    deleted: z.boolean(),
    createdAt: z.string(),
    updatedAt: z.string(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
      v: '__v',
      organizationId: '_organizationId',
      environmentId: '_environmentId',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriberResponseDto$ {
  /** @deprecated use `SubscriberResponseDto$inboundSchema` instead. */
  export const inboundSchema = SubscriberResponseDto$inboundSchema;
  /** @deprecated use `SubscriberResponseDto$outboundSchema` instead. */
  export const outboundSchema = SubscriberResponseDto$outboundSchema;
  /** @deprecated use `SubscriberResponseDto$Outbound` instead. */
  export type Outbound = SubscriberResponseDto$Outbound;
}

export function subscriberResponseDtoToJSON(subscriberResponseDto: SubscriberResponseDto): string {
  return JSON.stringify(SubscriberResponseDto$outboundSchema.parse(subscriberResponseDto));
}

export function subscriberResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<SubscriberResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriberResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriberResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscriberResponseDtoToJSON(subscriberResponseDto: SubscriberResponseDto)
 - subscriberResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscriberResponseDto$Outbound;
}

export function subscriberResponseDtoToJSON(subscriberResponseDto...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriberResponseDtoToJSON
- export function subscriberResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/subscriberresponsedtooptional.ts
Tamaño: 6021 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ChannelSettingsDto,
  ChannelSettingsDto$inboundSchema,
  ChannelSettingsDto$Outbound,
  ChannelSettingsDto$outboundSchema,
} from './channelsettingsdto.js';

export type SubscriberResponseDtoOptional = {
  /**
   * The internal ID generated by Novu for your subscriber. This ID does not match the `subscriberId` used in your queries. Refer to `subscriberId` for that identifier.
   */
  id?: string | undefined;
  /**
   * The first name of the subscriber.
   */
  firstName?: string | null | undefined;
  /**
   * The last name of the subscriber.
   */
  lastName?: string | null | undefined;
  /**
   * The email address of the subscriber.
   */
  email?: string | null | undefined;
  /**
   * The phone number of the subscriber.
   */
  phone?: string | null | undefined;
  /**
   * The URL of the subscriber's avatar image.
   */
  avatar?: string | null | undefined;
  /**
   * The locale setting of the subscriber, indicating their preferred language or region.
   */
  locale?: string | null | undefined;
  /**
   * An array of channel settings associated with the subscriber.
   */
  channels?: Array<ChannelSettingsDto> | undefined;
  /**
   * An array of topics that the subscriber is subscribed to.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  topics?: Array<string> | undefined;
  /**
   * Indicates whether the subscriber is currently online.
   */
  isOnline?: boolean | null | undefined;
  /**
   * The timestamp indicating when the subscriber was last online, in ISO 8601 format.
   */
  lastOnlineAt?: string | null | undefined;
  /**
   * The version of the subscriber document.
   */
  v?: number | undefined;
  /**
   * Additional custom data for the subscriber
   */
  data?: { [k: string]: any } | null | undefined;
  /**
   * Timezone of the subscriber
   */
  timezone?: string | null | undefined;
};

/** @internal */
export const SubscriberResponseDtoOptional$inboundSchema: z.ZodType<
  SubscriberResponseDtoOptional,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    _id: z.string().optional(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    email: z.nullable(z.string()).optional(),
    phone: z.nullable(z.string()).optional(),
    avatar: z.nullable(z.string()).optional(),
    locale: z.nullable(z.string()).optional(),
    channels: z.array(ChannelSettingsDto$inboundSchema).optional(),
    topics: z.array(z.string()).optional(),
    isOnline: z.nullable(z.boolean()).optional(),
    lastOnlineAt: z.nullable(z.string()).optional(),
    __v: z.number().optional(),
    data: z.nullable(z.record(z.any())).optional(),
    timezone: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
      __v: 'v',
    });
  });

/** @internal */
export type SubscriberResponseDtoOptional$Outbound = {
  _id?: string | undefined;
  firstName?: string | null | undefined;
  lastName?: string | null | undefined;
  email?: string | null | undefined;
  phone?: string | null | undefined;
  avatar?: string | null | undefined;
  locale?: string | null | undefined;
  channels?: Array<ChannelSettingsDto$Outbound> | undefined;
  topics?: Array<string> | undefined;
  isOnline?: boolean | null | undefined;
  lastOnlineAt?: string | null | undefined;
  __v?: number | undefined;
  data?: { [k: string]: any } | null | undefined;
  timezone?: string | null | undefined;
};

/** @internal */
export const SubscriberResponseDtoOptional$outboundSchema: z.ZodType<
  SubscriberResponseDtoOptional$Outbound,
  z.ZodTypeDef,
  SubscriberResponseDtoOptional
> = z
  .object({
    id: z.string().optional(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    email: z.nullable(z.string()).optional(),
    phone: z.nullable(z.string()).optional(),
    avatar: z.nullable(z.string()).optional(),
    locale: z.nullable(z.string()).optional(),
    channels: z.array(ChannelSettingsDto$outboundSchema).optional(),
    topics: z.array(z.string()).optional(),
    isOnline: z.nullable(z.boolean()).optional(),
    lastOnlineAt: z.nullable(z.string()).optional(),
    v: z.number().optional(),
    data: z.nullable(z.record(z.any())).optional(),
    timezone: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
      v: '__v',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriberResponseDtoOptional$ {
  /** @deprecated use `SubscriberResponseDtoOptional$inboundSchema` instead. */
  export const inboundSchema = SubscriberResponseDtoOptional$inboundSchema;
  /** @deprecated use `SubscriberResponseDtoOptional$outboundSchema` instead. */
  export const outboundSchema = SubscriberResponseDtoOptional$outboundSchema;
  /** @deprecated use `SubscriberResponseDtoOptional$Outbound` instead. */
  export type Outbound = SubscriberResponseDtoOptional$Outbound;
}

export function subscriberResponseDtoOptionalToJSON(
  subscriberResponseDtoOptional: SubscriberResponseDtoOptional
): string {
  return JSON.stringify(SubscriberResponseDtoOptional$outboundSchema.parse(subscriberResponseDtoOptional));
}

export function subscriberResponseDtoOptionalFromJSON(
  jsonString: string
): SafeParseResult<SubscriberResponseDtoOptional, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriberResponseDtoOptional$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriberResponseDtoOptional' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscriberResponseDtoOptionalToJSON(subscriberResponseDtoOptional: SubscriberResponseDtoOptional)
 - subscriberResponseDtoOptionalFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscriberResponseDtoOptional$Outbound;
}

export function subscriberResponseDtoOptionalToJSON(
  su...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriberResponseDtoOptionalToJSON
- export function subscriberResponseDtoOptionalFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/subscriberworkflowpreferencedto.ts
Tamaño: 3780 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  SubscriberPreferenceChannels,
  SubscriberPreferenceChannels$inboundSchema,
  SubscriberPreferenceChannels$Outbound,
  SubscriberPreferenceChannels$outboundSchema,
} from './subscriberpreferencechannels.js';
import {
  SubscriberPreferenceOverrideDto,
  SubscriberPreferenceOverrideDto$inboundSchema,
  SubscriberPreferenceOverrideDto$Outbound,
  SubscriberPreferenceOverrideDto$outboundSchema,
} from './subscriberpreferenceoverridedto.js';
import {
  SubscriberPreferencesWorkflowInfoDto,
  SubscriberPreferencesWorkflowInfoDto$inboundSchema,
  SubscriberPreferencesWorkflowInfoDto$Outbound,
  SubscriberPreferencesWorkflowInfoDto$outboundSchema,
} from './subscriberpreferencesworkflowinfodto.js';

export type SubscriberWorkflowPreferenceDto = {
  /**
   * Whether notifications are enabled for this workflow
   */
  enabled: boolean;
  /**
   * Channel-specific preference settings for this workflow
   */
  channels: SubscriberPreferenceChannels;
  /**
   * List of preference overrides
   */
  overrides: Array<SubscriberPreferenceOverrideDto>;
  /**
   * Workflow information
   */
  workflow: SubscriberPreferencesWorkflowInfoDto;
};

/** @internal */
export const SubscriberWorkflowPreferenceDto$inboundSchema: z.ZodType<
  SubscriberWorkflowPreferenceDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean(),
  channels: SubscriberPreferenceChannels$inboundSchema,
  overrides: z.array(SubscriberPreferenceOverrideDto$inboundSchema),
  workflow: SubscriberPreferencesWorkflowInfoDto$inboundSchema,
});

/** @internal */
export type SubscriberWorkflowPreferenceDto$Outbound = {
  enabled: boolean;
  channels: SubscriberPreferenceChannels$Outbound;
  overrides: Array<SubscriberPreferenceOverrideDto$Outbound>;
  workflow: SubscriberPreferencesWorkflowInfoDto$Outbound;
};

/** @internal */
export const SubscriberWorkflowPreferenceDto$outboundSchema: z.ZodType<
  SubscriberWorkflowPreferenceDto$Outbound,
  z.ZodTypeDef,
  SubscriberWorkflowPreferenceDto
> = z.object({
  enabled: z.boolean(),
  channels: SubscriberPreferenceChannels$outboundSchema,
  overrides: z.array(SubscriberPreferenceOverrideDto$outboundSchema),
  workflow: SubscriberPreferencesWorkflowInfoDto$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriberWorkflowPreferenceDto$ {
  /** @deprecated use `SubscriberWorkflowPreferenceDto$inboundSchema` instead. */
  export const inboundSchema = SubscriberWorkflowPreferenceDto$inboundSchema;
  /** @deprecated use `SubscriberWorkflowPreferenceDto$outboundSchema` instead. */
  export const outboundSchema = SubscriberWorkflowPreferenceDto$outboundSchema;
  /** @deprecated use `SubscriberWorkflowPreferenceDto$Outbound` instead. */
  export type Outbound = SubscriberWorkflowPreferenceDto$Outbound;
}

export function subscriberWorkflowPreferenceDtoToJSON(
  subscriberWorkflowPreferenceDto: SubscriberWorkflowPreferenceDto
): string {
  return JSON.stringify(SubscriberWorkflowPreferenceDto$outboundSchema.parse(subscriberWorkflowPreferenceDto));
}

export function subscriberWorkflowPreferenceDtoFromJSON(
  jsonString: string
): SafeParseResult<SubscriberWorkflowPreferenceDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriberWorkflowPreferenceDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriberWorkflowPreferenceDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscriberWorkflowPreferenceDtoToJSON(subscriberWorkflowPreferenceDto: SubscriberWorkflowPreferenceDto)
 - subscriberWorkflowPreferenceDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscriberWorkflowPreferenceDto$Outbound;
}

export function subscriberWorkflowPreferenceDtoToJSON(
...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriberWorkflowPreferenceDtoToJSON
- export function subscriberWorkflowPreferenceDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/subscriptiondto.ts
Tamaño: 5477 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import { TopicDto, TopicDto$inboundSchema, TopicDto$Outbound, TopicDto$outboundSchema } from './topicdto.js';

/**
 * The subscriber information
 */
export type Subscriber = {
  /**
   * The identifier of the subscriber
   */
  id: string;
  /**
   * The external identifier of the subscriber
   */
  subscriberId: string;
  /**
   * The avatar URL of the subscriber
   */
  avatar?: string | null | undefined;
  /**
   * The first name of the subscriber
   */
  firstName?: string | null | undefined;
  /**
   * The last name of the subscriber
   */
  lastName?: string | null | undefined;
  /**
   * The email of the subscriber
   */
  email?: string | null | undefined;
};

export type SubscriptionDto = {
  /**
   * The unique identifier of the subscription
   */
  id: string;
  /**
   * The topic information
   */
  topic: TopicDto;
  /**
   * The subscriber information
   */
  subscriber: Subscriber | null;
  /**
   * The creation date of the subscription
   */
  createdAt: string;
  /**
   * The last update date of the subscription
   */
  updatedAt: string;
};

/** @internal */
export const Subscriber$inboundSchema: z.ZodType<Subscriber, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string(),
    subscriberId: z.string(),
    avatar: z.nullable(z.string()).optional(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    email: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type Subscriber$Outbound = {
  _id: string;
  subscriberId: string;
  avatar?: string | null | undefined;
  firstName?: string | null | undefined;
  lastName?: string | null | undefined;
  email?: string | null | undefined;
};

/** @internal */
export const Subscriber$outboundSchema: z.ZodType<Subscriber$Outbound, z.ZodTypeDef, Subscriber> = z
  .object({
    id: z.string(),
    subscriberId: z.string(),
    avatar: z.nullable(z.string()).optional(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    email: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Subscriber$ {
  /** @deprecated use `Subscriber$inboundSchema` instead. */
  export const inboundSchema = Subscriber$inboundSchema;
  /** @deprecated use `Subscriber$outboundSchema` instead. */
  export const outboundSchema = Subscriber$outboundSchema;
  /** @deprecated use `Subscriber$Outbound` instead. */
  export type Outbound = Subscriber$Outbound;
}

export function subscriberToJSON(subscriber: Subscriber): string {
  return JSON.stringify(Subscriber$outboundSchema.parse(subscriber));
}

export function subscriberFromJSON(jsonString: string): SafeParseResult<Subscriber, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Subscriber$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Subscriber' from JSON`
  );
}

/** @internal */
export const SubscriptionDto$inboundSchema: z.ZodType<SubscriptionDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string(),
    topic: TopicDto$inboundSchema,
    subscriber: z.nullable(z.lazy(() => Subscriber$inboundSchema)),
    createdAt: z.string(),
    updatedAt: z.string(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type SubscriptionDto$Outbound = {
  _id: string;
  topic: TopicDto$Outbound;
  subscriber: Subscriber$Outbound | null;
  createdAt: string;
  updatedAt: string;
};

/** @internal */
export const SubscriptionDto$outboundSchema: z.ZodType<SubscriptionDto$Outbound, z.ZodTypeDef, SubscriptionDto> = z
  .object({
    id: z.string(),
    topic: TopicDto$outboundSchema,
    subscriber: z.nullable(z.lazy(() => Subscriber$outboundSchema)),
    createdAt: z.string(),
    updatedAt: z.string(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriptionDto$ {
  /** @deprecated use `SubscriptionDto$inboundSchema` instead. */
  export const inboundSchema = SubscriptionDto$inboundSchema;
  /** @deprecated use `SubscriptionDto$outboundSchema` instead. */
  export const outboundSchema = SubscriptionDto$outboundSchema;
  /** @deprecated use `SubscriptionDto$Outbound` instead. */
  export type Outbound = SubscriptionDto$Outbound;
}

export function subscriptionDtoToJSON(subscriptionDto: SubscriptionDto): string {
  return JSON.stringify(SubscriptionDto$outboundSchema.parse(subscriptionDto));
}

export function subscriptionDtoFromJSON(jsonString: string): SafeParseResult<SubscriptionDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriptionDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriptionDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscriberToJSON(subscriber: Subscriber)
 - subscriberFromJSON(jsonString: string)
 - subscriptionDtoToJSON(subscriptionDto: SubscriptionDto)
 - subscriptionDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Subscriber$Outbound;
}

export function subscriberToJSON(subscriber: Subscriber): string {
  return ...)
 - Outbound(SubscriptionDto$Outbound;
}

export function subscriptionDtoToJSON(subscriptionDto: SubscriptionDto)...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriberToJSON
- export function subscriberFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriptionDtoToJSON
- export function subscriptionDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/subscriptionerrordto.ts
Tamaño: 2166 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscriptionErrorDto = {
  /**
   * The subscriber ID that failed
   */
  subscriberId: string;
  /**
   * The error code
   */
  code: string;
  /**
   * The error message
   */
  message: string;
};

/** @internal */
export const SubscriptionErrorDto$inboundSchema: z.ZodType<SubscriptionErrorDto, z.ZodTypeDef, unknown> = z.object({
  subscriberId: z.string(),
  code: z.string(),
  message: z.string(),
});

/** @internal */
export type SubscriptionErrorDto$Outbound = {
  subscriberId: string;
  code: string;
  message: string;
};

/** @internal */
export const SubscriptionErrorDto$outboundSchema: z.ZodType<
  SubscriptionErrorDto$Outbound,
  z.ZodTypeDef,
  SubscriptionErrorDto
> = z.object({
  subscriberId: z.string(),
  code: z.string(),
  message: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriptionErrorDto$ {
  /** @deprecated use `SubscriptionErrorDto$inboundSchema` instead. */
  export const inboundSchema = SubscriptionErrorDto$inboundSchema;
  /** @deprecated use `SubscriptionErrorDto$outboundSchema` instead. */
  export const outboundSchema = SubscriptionErrorDto$outboundSchema;
  /** @deprecated use `SubscriptionErrorDto$Outbound` instead. */
  export type Outbound = SubscriptionErrorDto$Outbound;
}

export function subscriptionErrorDtoToJSON(subscriptionErrorDto: SubscriptionErrorDto): string {
  return JSON.stringify(SubscriptionErrorDto$outboundSchema.parse(subscriptionErrorDto));
}

export function subscriptionErrorDtoFromJSON(
  jsonString: string
): SafeParseResult<SubscriptionErrorDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriptionErrorDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriptionErrorDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscriptionErrorDtoToJSON(subscriptionErrorDto: SubscriptionErrorDto)
 - subscriptionErrorDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscriptionErrorDto$Outbound;
}

export function subscriptionErrorDtoToJSON(subscriptionErrorDto: S...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriptionErrorDtoToJSON
- export function subscriptionErrorDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/subscriptionsdeleteerrordto.ts
Tamaño: 2337 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscriptionsDeleteErrorDto = {
  /**
   * The subscriber ID that failed
   */
  subscriberId: string;
  /**
   * The error code
   */
  code: string;
  /**
   * The error message
   */
  message: string;
};

/** @internal */
export const SubscriptionsDeleteErrorDto$inboundSchema: z.ZodType<SubscriptionsDeleteErrorDto, z.ZodTypeDef, unknown> =
  z.object({
    subscriberId: z.string(),
    code: z.string(),
    message: z.string(),
  });

/** @internal */
export type SubscriptionsDeleteErrorDto$Outbound = {
  subscriberId: string;
  code: string;
  message: string;
};

/** @internal */
export const SubscriptionsDeleteErrorDto$outboundSchema: z.ZodType<
  SubscriptionsDeleteErrorDto$Outbound,
  z.ZodTypeDef,
  SubscriptionsDeleteErrorDto
> = z.object({
  subscriberId: z.string(),
  code: z.string(),
  message: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriptionsDeleteErrorDto$ {
  /** @deprecated use `SubscriptionsDeleteErrorDto$inboundSchema` instead. */
  export const inboundSchema = SubscriptionsDeleteErrorDto$inboundSchema;
  /** @deprecated use `SubscriptionsDeleteErrorDto$outboundSchema` instead. */
  export const outboundSchema = SubscriptionsDeleteErrorDto$outboundSchema;
  /** @deprecated use `SubscriptionsDeleteErrorDto$Outbound` instead. */
  export type Outbound = SubscriptionsDeleteErrorDto$Outbound;
}

export function subscriptionsDeleteErrorDtoToJSON(subscriptionsDeleteErrorDto: SubscriptionsDeleteErrorDto): string {
  return JSON.stringify(SubscriptionsDeleteErrorDto$outboundSchema.parse(subscriptionsDeleteErrorDto));
}

export function subscriptionsDeleteErrorDtoFromJSON(
  jsonString: string
): SafeParseResult<SubscriptionsDeleteErrorDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriptionsDeleteErrorDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriptionsDeleteErrorDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscriptionsDeleteErrorDtoToJSON(subscriptionsDeleteErrorDto: SubscriptionsDeleteErrorDto)
 - subscriptionsDeleteErrorDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscriptionsDeleteErrorDto$Outbound;
}

export function subscriptionsDeleteErrorDtoToJSON(subscript...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriptionsDeleteErrorDtoToJSON
- export function subscriptionsDeleteErrorDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/syncworkflowdto.ts
Tamaño: 1874 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SyncWorkflowDto = {
  /**
   * Target environment identifier to sync the workflow to
   */
  targetEnvironmentId: string;
};

/** @internal */
export const SyncWorkflowDto$inboundSchema: z.ZodType<SyncWorkflowDto, z.ZodTypeDef, unknown> = z.object({
  targetEnvironmentId: z.string(),
});

/** @internal */
export type SyncWorkflowDto$Outbound = {
  targetEnvironmentId: string;
};

/** @internal */
export const SyncWorkflowDto$outboundSchema: z.ZodType<SyncWorkflowDto$Outbound, z.ZodTypeDef, SyncWorkflowDto> =
  z.object({
    targetEnvironmentId: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SyncWorkflowDto$ {
  /** @deprecated use `SyncWorkflowDto$inboundSchema` instead. */
  export const inboundSchema = SyncWorkflowDto$inboundSchema;
  /** @deprecated use `SyncWorkflowDto$outboundSchema` instead. */
  export const outboundSchema = SyncWorkflowDto$outboundSchema;
  /** @deprecated use `SyncWorkflowDto$Outbound` instead. */
  export type Outbound = SyncWorkflowDto$Outbound;
}

export function syncWorkflowDtoToJSON(syncWorkflowDto: SyncWorkflowDto): string {
  return JSON.stringify(SyncWorkflowDto$outboundSchema.parse(syncWorkflowDto));
}

export function syncWorkflowDtoFromJSON(jsonString: string): SafeParseResult<SyncWorkflowDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SyncWorkflowDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SyncWorkflowDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - syncWorkflowDtoToJSON(syncWorkflowDto: SyncWorkflowDto)
 - syncWorkflowDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SyncWorkflowDto$Outbound;
}

export function syncWorkflowDtoToJSON(syncWorkflowDto: SyncWorkflowDto)...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function syncWorkflowDtoToJSON
- export function syncWorkflowDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/tenantpayloaddto.ts
Tamaño: 3695 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TenantPayloadDtoData = {};

export type TenantPayloadDto = {
  identifier?: string | undefined;
  name?: string | undefined;
  data?: TenantPayloadDtoData | undefined;
};

/** @internal */
export const TenantPayloadDtoData$inboundSchema: z.ZodType<TenantPayloadDtoData, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type TenantPayloadDtoData$Outbound = {};

/** @internal */
export const TenantPayloadDtoData$outboundSchema: z.ZodType<
  TenantPayloadDtoData$Outbound,
  z.ZodTypeDef,
  TenantPayloadDtoData
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TenantPayloadDtoData$ {
  /** @deprecated use `TenantPayloadDtoData$inboundSchema` instead. */
  export const inboundSchema = TenantPayloadDtoData$inboundSchema;
  /** @deprecated use `TenantPayloadDtoData$outboundSchema` instead. */
  export const outboundSchema = TenantPayloadDtoData$outboundSchema;
  /** @deprecated use `TenantPayloadDtoData$Outbound` instead. */
  export type Outbound = TenantPayloadDtoData$Outbound;
}

export function tenantPayloadDtoDataToJSON(tenantPayloadDtoData: TenantPayloadDtoData): string {
  return JSON.stringify(TenantPayloadDtoData$outboundSchema.parse(tenantPayloadDtoData));
}

export function tenantPayloadDtoDataFromJSON(
  jsonString: string
): SafeParseResult<TenantPayloadDtoData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TenantPayloadDtoData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TenantPayloadDtoData' from JSON`
  );
}

/** @internal */
export const TenantPayloadDto$inboundSchema: z.ZodType<TenantPayloadDto, z.ZodTypeDef, unknown> = z.object({
  identifier: z.string().optional(),
  name: z.string().optional(),
  data: z.lazy(() => TenantPayloadDtoData$inboundSchema).optional(),
});

/** @internal */
export type TenantPayloadDto$Outbound = {
  identifier?: string | undefined;
  name?: string | undefined;
  data?: TenantPayloadDtoData$Outbound | undefined;
};

/** @internal */
export const TenantPayloadDto$outboundSchema: z.ZodType<TenantPayloadDto$Outbound, z.ZodTypeDef, TenantPayloadDto> =
  z.object({
    identifier: z.string().optional(),
    name: z.string().optional(),
    data: z.lazy(() => TenantPayloadDtoData$outboundSchema).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TenantPayloadDto$ {
  /** @deprecated use `TenantPayloadDto$inboundSchema` instead. */
  export const inboundSchema = TenantPayloadDto$inboundSchema;
  /** @deprecated use `TenantPayloadDto$outboundSchema` instead. */
  export const outboundSchema = TenantPayloadDto$outboundSchema;
  /** @deprecated use `TenantPayloadDto$Outbound` instead. */
  export type Outbound = TenantPayloadDto$Outbound;
}

export function tenantPayloadDtoToJSON(tenantPayloadDto: TenantPayloadDto): string {
  return JSON.stringify(TenantPayloadDto$outboundSchema.parse(tenantPayloadDto));
}

export function tenantPayloadDtoFromJSON(jsonString: string): SafeParseResult<TenantPayloadDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TenantPayloadDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TenantPayloadDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - tenantPayloadDtoDataToJSON(tenantPayloadDtoData: TenantPayloadDtoData)
 - tenantPayloadDtoDataFromJSON(jsonString: string)
 - tenantPayloadDtoToJSON(tenantPayloadDto: TenantPayloadDto)
 - tenantPayloadDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TenantPayloadDtoData$Outbound;
}

export function tenantPayloadDtoDataToJSON(tenantPayloadDtoData: T...)
 - Outbound(TenantPayloadDto$Outbound;
}

export function tenantPayloadDtoToJSON(tenantPayloadDto: TenantPayload...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function tenantPayloadDtoDataToJSON
- export function tenantPayloadDtoDataFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function tenantPayloadDtoToJSON
- export function tenantPayloadDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/textalignenum.ts
Tamaño: 1110 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Text alignment for the email block
 */
export const TextAlignEnum = {
  Center: 'center',
  Left: 'left',
  Right: 'right',
} as const;
/**
 * Text alignment for the email block
 */
export type TextAlignEnum = ClosedEnum<typeof TextAlignEnum>;

/** @internal */
export const TextAlignEnum$inboundSchema: z.ZodNativeEnum<typeof TextAlignEnum> = z.nativeEnum(TextAlignEnum);

/** @internal */
export const TextAlignEnum$outboundSchema: z.ZodNativeEnum<typeof TextAlignEnum> = TextAlignEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TextAlignEnum$ {
  /** @deprecated use `TextAlignEnum$inboundSchema` instead. */
  export const inboundSchema = TextAlignEnum$inboundSchema;
  /** @deprecated use `TextAlignEnum$outboundSchema` instead. */
  export const outboundSchema = TextAlignEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/throttlecontroldto.ts
Tamaño: 5836 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * The type of throttle window.
 */
export const ThrottleControlDtoType = {
  Fixed: 'fixed',
  Dynamic: 'dynamic',
} as const;
/**
 * The type of throttle window.
 */
export type ThrottleControlDtoType = ClosedEnum<typeof ThrottleControlDtoType>;

/**
 * The unit of time for the throttle window (required for fixed type).
 */
export const ThrottleControlDtoUnit = {
  Minutes: 'minutes',
  Hours: 'hours',
  Days: 'days',
} as const;
/**
 * The unit of time for the throttle window (required for fixed type).
 */
export type ThrottleControlDtoUnit = ClosedEnum<typeof ThrottleControlDtoUnit>;

export type ThrottleControlDto = {
  /**
   * JSONLogic filter conditions for conditionally skipping the step execution. Supports complex logical operations with AND, OR, and comparison operators. See https://jsonlogic.com/ for full typing reference.
   */
  skip?: { [k: string]: any } | undefined;
  /**
   * The type of throttle window.
   */
  type?: ThrottleControlDtoType | undefined;
  /**
   * The amount of time for the throttle window (required for fixed type).
   */
  amount?: number | undefined;
  /**
   * The unit of time for the throttle window (required for fixed type).
   */
  unit?: ThrottleControlDtoUnit | undefined;
  /**
   * Key path to retrieve dynamic window value (required for dynamic type).
   */
  dynamicKey?: string | undefined;
  /**
   * The maximum number of executions allowed within the window. Defaults to 1.
   */
  threshold?: number | undefined;
  /**
   * Optional key for grouping throttle rules. If not provided, defaults to workflow and subscriber combination.
   */
  throttleKey?: string | undefined;
};

/** @internal */
export const ThrottleControlDtoType$inboundSchema: z.ZodNativeEnum<typeof ThrottleControlDtoType> =
  z.nativeEnum(ThrottleControlDtoType);

/** @internal */
export const ThrottleControlDtoType$outboundSchema: z.ZodNativeEnum<typeof ThrottleControlDtoType> =
  ThrottleControlDtoType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ThrottleControlDtoType$ {
  /** @deprecated use `ThrottleControlDtoType$inboundSchema` instead. */
  export const inboundSchema = ThrottleControlDtoType$inboundSchema;
  /** @deprecated use `ThrottleControlDtoType$outboundSchema` instead. */
  export const outboundSchema = ThrottleControlDtoType$outboundSchema;
}

/** @internal */
export const ThrottleControlDtoUnit$inboundSchema: z.ZodNativeEnum<typeof ThrottleControlDtoUnit> =
  z.nativeEnum(ThrottleControlDtoUnit);

/** @internal */
export const ThrottleControlDtoUnit$outboundSchema: z.ZodNativeEnum<typeof ThrottleControlDtoUnit> =
  ThrottleControlDtoUnit$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ThrottleControlDtoUnit$ {
  /** @deprecated use `ThrottleControlDtoUnit$inboundSchema` instead. */
  export const inboundSchema = ThrottleControlDtoUnit$inboundSchema;
  /** @deprecated use `ThrottleControlDtoUnit$outboundSchema` instead. */
  export const outboundSchema = ThrottleControlDtoUnit$outboundSchema;
}

/** @internal */
export const ThrottleControlDto$inboundSchema: z.ZodType<ThrottleControlDto, z.ZodTypeDef, unknown> = z.object({
  skip: z.record(z.any()).optional(),
  type: ThrottleControlDtoType$inboundSchema.default('fixed'),
  amount: z.number().optional(),
  unit: ThrottleControlDtoUnit$inboundSchema.optional(),
  dynamicKey: z.string().optional(),
  threshold: z.number().default(1),
  throttleKey: z.string().optional(),
});

/** @internal */
export type ThrottleControlDto$Outbound = {
  skip?: { [k: string]: any } | undefined;
  type: string;
  amount?: number | undefined;
  unit?: string | undefined;
  dynamicKey?: string | undefined;
  threshold: number;
  throttleKey?: string | undefined;
};

/** @internal */
export const ThrottleControlDto$outboundSchema: z.ZodType<
  ThrottleControlDto$Outbound,
  z.ZodTypeDef,
  ThrottleControlDto
> = z.object({
  skip: z.record(z.any()).optional(),
  type: ThrottleControlDtoType$outboundSchema.default('fixed'),
  amount: z.number().optional(),
  unit: ThrottleControlDtoUnit$outboundSchema.optional(),
  dynamicKey: z.string().optional(),
  threshold: z.number().default(1),
  throttleKey: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ThrottleControlDto$ {
  /** @deprecated use `ThrottleControlDto$inboundSchema` instead. */
  export const inboundSchema = ThrottleControlDto$inboundSchema;
  /** @deprecated use `ThrottleControlDto$outboundSchema` instead. */
  export const outboundSchema = ThrottleControlDto$outboundSchema;
  /** @deprecated use `ThrottleControlDto$Outbound` instead. */
  export type Outbound = ThrottleControlDto$Outbound;
}

export function throttleControlDtoToJSON(throttleControlDto: ThrottleControlDto): string {
  return JSON.stringify(ThrottleControlDto$outboundSchema.parse(throttleControlDto));
}

export function throttleControlDtoFromJSON(
  jsonString: string
): SafeParseResult<ThrottleControlDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ThrottleControlDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ThrottleControlDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - throttleControlDtoToJSON(throttleControlDto: ThrottleControlDto)
 - throttleControlDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ThrottleControlDto$Outbound;
}

export function throttleControlDtoToJSON(throttleControlDto: Throttl...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function throttleControlDtoToJSON
- export function throttleControlDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/throttlecontrolsmetadataresponsedto.ts
Tamaño: 3078 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ThrottleControlDto,
  ThrottleControlDto$inboundSchema,
  ThrottleControlDto$Outbound,
  ThrottleControlDto$outboundSchema,
} from './throttlecontroldto.js';
import { UiSchema, UiSchema$inboundSchema, UiSchema$Outbound, UiSchema$outboundSchema } from './uischema.js';

export type ThrottleControlsMetadataResponseDto = {
  /**
   * JSON Schema for data
   */
  dataSchema?: { [k: string]: any } | undefined;
  /**
   * UI Schema for rendering
   */
  uiSchema?: UiSchema | undefined;
  /**
   * Control values specific to Throttle
   */
  values: ThrottleControlDto;
};

/** @internal */
export const ThrottleControlsMetadataResponseDto$inboundSchema: z.ZodType<
  ThrottleControlsMetadataResponseDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  dataSchema: z.record(z.any()).optional(),
  uiSchema: UiSchema$inboundSchema.optional(),
  values: ThrottleControlDto$inboundSchema,
});

/** @internal */
export type ThrottleControlsMetadataResponseDto$Outbound = {
  dataSchema?: { [k: string]: any } | undefined;
  uiSchema?: UiSchema$Outbound | undefined;
  values: ThrottleControlDto$Outbound;
};

/** @internal */
export const ThrottleControlsMetadataResponseDto$outboundSchema: z.ZodType<
  ThrottleControlsMetadataResponseDto$Outbound,
  z.ZodTypeDef,
  ThrottleControlsMetadataResponseDto
> = z.object({
  dataSchema: z.record(z.any()).optional(),
  uiSchema: UiSchema$outboundSchema.optional(),
  values: ThrottleControlDto$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ThrottleControlsMetadataResponseDto$ {
  /** @deprecated use `ThrottleControlsMetadataResponseDto$inboundSchema` instead. */
  export const inboundSchema = ThrottleControlsMetadataResponseDto$inboundSchema;
  /** @deprecated use `ThrottleControlsMetadataResponseDto$outboundSchema` instead. */
  export const outboundSchema = ThrottleControlsMetadataResponseDto$outboundSchema;
  /** @deprecated use `ThrottleControlsMetadataResponseDto$Outbound` instead. */
  export type Outbound = ThrottleControlsMetadataResponseDto$Outbound;
}

export function throttleControlsMetadataResponseDtoToJSON(
  throttleControlsMetadataResponseDto: ThrottleControlsMetadataResponseDto
): string {
  return JSON.stringify(ThrottleControlsMetadataResponseDto$outboundSchema.parse(throttleControlsMetadataResponseDto));
}

export function throttleControlsMetadataResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<ThrottleControlsMetadataResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ThrottleControlsMetadataResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ThrottleControlsMetadataResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - throttleControlsMetadataResponseDtoToJSON(throttleControlsMetadataResponseDto: ThrottleControlsMetadataResponseDto)
 - throttleControlsMetadataResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ThrottleControlsMetadataResponseDto$Outbound;
}

export function throttleControlsMetadataResponseDto...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function throttleControlsMetadataResponseDtoToJSON
- export function throttleControlsMetadataResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/throttlestepresponsedto.ts
Tamaño: 11656 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { collectExtraKeys as collectExtraKeys$, safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ResourceOriginEnum,
  ResourceOriginEnum$inboundSchema,
  ResourceOriginEnum$outboundSchema,
} from './resourceoriginenum.js';
import {
  StepIssuesDto,
  StepIssuesDto$inboundSchema,
  StepIssuesDto$Outbound,
  StepIssuesDto$outboundSchema,
} from './stepissuesdto.js';
import { StepTypeEnum, StepTypeEnum$inboundSchema, StepTypeEnum$outboundSchema } from './steptypeenum.js';
import {
  ThrottleControlsMetadataResponseDto,
  ThrottleControlsMetadataResponseDto$inboundSchema,
  ThrottleControlsMetadataResponseDto$Outbound,
  ThrottleControlsMetadataResponseDto$outboundSchema,
} from './throttlecontrolsmetadataresponsedto.js';

/**
 * The type of throttle window.
 */
export const ThrottleStepResponseDtoType = {
  Fixed: 'fixed',
  Dynamic: 'dynamic',
} as const;
/**
 * The type of throttle window.
 */
export type ThrottleStepResponseDtoType = ClosedEnum<typeof ThrottleStepResponseDtoType>;

/**
 * The unit of time for the throttle window (required for fixed type).
 */
export const ThrottleStepResponseDtoUnit = {
  Minutes: 'minutes',
  Hours: 'hours',
  Days: 'days',
} as const;
/**
 * The unit of time for the throttle window (required for fixed type).
 */
export type ThrottleStepResponseDtoUnit = ClosedEnum<typeof ThrottleStepResponseDtoUnit>;

/**
 * Control values for the throttle step
 */
export type ThrottleStepResponseDtoControlValues = {
  /**
   * JSONLogic filter conditions for conditionally skipping the step execution. Supports complex logical operations with AND, OR, and comparison operators. See https://jsonlogic.com/ for full typing reference.
   */
  skip?: { [k: string]: any } | undefined;
  /**
   * The type of throttle window.
   */
  type?: ThrottleStepResponseDtoType | undefined;
  /**
   * The amount of time for the throttle window (required for fixed type).
   */
  amount?: number | undefined;
  /**
   * The unit of time for the throttle window (required for fixed type).
   */
  unit?: ThrottleStepResponseDtoUnit | undefined;
  /**
   * Key path to retrieve dynamic window value (required for dynamic type).
   */
  dynamicKey?: string | undefined;
  /**
   * The maximum number of executions allowed within the window. Defaults to 1.
   */
  threshold?: number | undefined;
  /**
   * Optional key for grouping throttle rules. If not provided, defaults to workflow and subscriber combination.
   */
  throttleKey?: string | undefined;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type ThrottleStepResponseDto = {
  /**
   * Controls metadata for the throttle step
   */
  controls: ThrottleControlsMetadataResponseDto;
  /**
   * Control values for the throttle step
   */
  controlValues?: ThrottleStepResponseDtoControlValues | undefined;
  /**
   * JSON Schema for variables, follows the JSON Schema standard
   */
  variables: { [k: string]: any };
  /**
   * Unique identifier of the step
   */
  stepId: string;
  /**
   * Database identifier of the step
   */
  id: string;
  /**
   * Name of the step
   */
  name: string;
  /**
   * Slug of the step
   */
  slug: string;
  /**
   * Type of the step
   */
  type: StepTypeEnum;
  /**
   * Origin of the layout
   */
  origin: ResourceOriginEnum;
  /**
   * Workflow identifier
   */
  workflowId: string;
  /**
   * Workflow database identifier
   */
  workflowDatabaseId: string;
  /**
   * Issues associated with the step
   */
  issues?: StepIssuesDto | undefined;
};

/** @internal */
export const ThrottleStepResponseDtoType$inboundSchema: z.ZodNativeEnum<typeof ThrottleStepResponseDtoType> =
  z.nativeEnum(ThrottleStepResponseDtoType);

/** @internal */
export const ThrottleStepResponseDtoType$outboundSchema: z.ZodNativeEnum<typeof ThrottleStepResponseDtoType> =
  ThrottleStepResponseDtoType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ThrottleStepResponseDtoType$ {
  /** @deprecated use `ThrottleStepResponseDtoType$inboundSchema` instead. */
  export const inboundSchema = ThrottleStepResponseDtoType$inboundSchema;
  /** @deprecated use `ThrottleStepResponseDtoType$outboundSchema` instead. */
  export const outboundSchema = ThrottleStepResponseDtoType$outboundSchema;
}

/** @internal */
export const ThrottleStepResponseDtoUnit$inboundSchema: z.ZodNativeEnum<typeof ThrottleStepResponseDtoUnit> =
  z.nativeEnum(ThrottleStepResponseDtoUnit);

/** @internal */
export const ThrottleStepResponseDtoUnit$outboundSchema: z.ZodNativeEnum<typeof ThrottleStepResponseDtoUnit> =
  ThrottleStepResponseDtoUnit$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ThrottleStepResponseDtoUnit$ {
  /** @deprecated use `ThrottleStepResponseDtoUnit$inboundSchema` instead. */
  export const inboundSchema = ThrottleStepResponseDtoUnit$inboundSchema;
  /** @deprecated use `ThrottleStepResponseDtoUnit$outboundSchema` instead. */
  export const outboundSchema = ThrottleStepResponseDtoUnit$outboundSchema;
}

/** @internal */
export const ThrottleStepResponseDtoControlValues$inboundSchema: z.ZodType<
  ThrottleStepResponseDtoControlValues,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z
    .object({
      skip: z.record(z.any()).optional(),
      type: ThrottleStepResponseDtoType$inboundSchema.default('fixed'),
      amount: z.number().optional(),
      unit: ThrottleStepResponseDtoUnit$inboundSchema.optional(),
      dynamicKey: z.string().optional(),
      threshold: z.number().default(1),
      throttleKey: z.string().optional(),
    })
    .catchall(z.any()),
  'additionalProperties',
  true
);

/** @internal */
export type ThrottleStepResponseDtoControlValues$Outbound = {
  skip?: { [k: string]: any } | undefined;
  type: string;
  amount?: number | undefined;
  unit?: string | undefined;
  dynamicKey?: string | undefined;
  threshold: number;
  throttleKey?: string | undefined;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const ThrottleStepResponseDtoControlValues$outboundSchema: z.ZodType<
  ThrottleStepResponseDtoControlValues$Outbound,
  z.ZodTypeDef,
  ThrottleStepResponseDtoControlValues
> = z
  .object({
    skip: z.record(z.any()).optional(),
    type: ThrottleStepResponseDtoType$outboundSchema.default('fixed'),
    amount: z.number().optional(),
    unit: ThrottleStepResponseDtoUnit$outboundSchema.optional(),
    dynamicKey: z.string().optional(),
    threshold: z.number().default(1),
    throttleKey: z.string().optional(),
    additionalProperties: z.record(z.any()).optional(),
  })
  .transform((v) => {
    return {
      ...v.additionalProperties,
      ...remap$(v, {
        additionalProperties: null,
      }),
    };
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ThrottleStepResponseDtoControlValues$ {
  /** @deprecated use `ThrottleStepResponseDtoControlValues$inboundSchema` instead. */
  export const inboundSchema = ThrottleStepResponseDtoControlValues$inboundSchema;
  /** @deprecated use `ThrottleStepResponseDtoControlValues$outboundSchema` instead. */
  export const outboundSchema = ThrottleStepResponseDtoControlValues$outboundSchema;
  /** @deprecated use `ThrottleStepResponseDtoControlValues$Outbound` instead. */
  export type Outbound = ThrottleStepResponseDtoControlValues$Outbound;
}

export function throttleStepResponseDtoControlValuesToJSON(
  throttleStepResponseDtoControlValues: ThrottleStepResponseDtoControlValues
): string {
  return JSON.stringify(
    ThrottleStepResponseDtoControlValues$outboundSchema.parse(throttleStepResponseDtoControlValues)
  );
}

export function throttleStepResponseDtoControlValuesFromJSON(
  jsonString: string
): SafeParseResult<ThrottleStepResponseDtoControlValues, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ThrottleStepResponseDtoControlValues$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ThrottleStepResponseDtoControlValues' from JSON`
  );
}

/** @internal */
export const ThrottleStepResponseDto$inboundSchema: z.ZodType<ThrottleStepResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    controls: ThrottleControlsMetadataResponseDto$inboundSchema,
    controlValues: z.lazy(() => ThrottleStepResponseDtoControlValues$inboundSchema).optional(),
    variables: z.record(z.any()),
    stepId: z.string(),
    _id: z.string(),
    name: z.string(),
    slug: z.string(),
    type: StepTypeEnum$inboundSchema,
    origin: ResourceOriginEnum$inboundSchema,
    workflowId: z.string(),
    workflowDatabaseId: z.string(),
    issues: StepIssuesDto$inboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type ThrottleStepResponseDto$Outbound = {
  controls: ThrottleControlsMetadataResponseDto$Outbound;
  controlValues?: ThrottleStepResponseDtoControlValues$Outbound | undefined;
  variables: { [k: string]: any };
  stepId: string;
  _id: string;
  name: string;
  slug: string;
  type: string;
  origin: string;
  workflowId: string;
  workflowDatabaseId: string;
  issues?: StepIssuesDto$Outbound | undefined;
};

/** @internal */
export const ThrottleStepResponseDto$outboundSchema: z.ZodType<
  ThrottleStepResponseDto$Outbound,
  z.ZodTypeDef,
  ThrottleStepResponseDto
> = z
  .object({
    controls: ThrottleControlsMetadataResponseDto$outboundSchema,
    controlValues: z.lazy(() => ThrottleStepResponseDtoControlValues$outboundSchema).optional(),
    variables: z.record(z.any()),
    stepId: z.string(),
    id: z.string(),
    name: z.string(),
    slug: z.string(),
    type: StepTypeEnum$outboundSchema,
    origin: ResourceOriginEnum$outboundSchema,
    workflowId: z.string(),
    workflowDatabaseId: z.string(),
    issues: StepIssuesDto$outboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ThrottleStepResponseDto$ {
  /** @deprecated use `ThrottleStepResponseDto$inboundSchema` instead. */
  export const inboundSchema = ThrottleStepResponseDto$inboundSchema;
  /** @deprecated use `ThrottleStepResponseDto$outboundSchema` instead. */
  export const outboundSchema = ThrottleStepResponseDto$outboundSchema;
  /** @deprecated use `ThrottleStepResponseDto$Outbound` instead. */
  export type Outbound = ThrottleStepResponseDto$Outbound;
}

export function throttleStepResponseDtoToJSON(throttleStepResponseDto: ThrottleStepResponseDto): string {
  return JSON.stringify(ThrottleStepResponseDto$outboundSchema.parse(throttleStepResponseDto));
}

export function throttleStepResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<ThrottleStepResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ThrottleStepResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ThrottleStepResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - throttleStepResponseDtoControlValuesToJSON(throttleStepResponseDtoControlValues: ThrottleStepResponseDtoControlValues)
 - throttleStepResponseDtoControlValuesFromJSON(jsonString: string)
 - throttleStepResponseDtoToJSON(throttleStepResponseDto: ThrottleStepResponseDto)
 - throttleStepResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ThrottleStepResponseDtoControlValues$Outbound;
}

export function throttleStepResponseDtoControlValu...)
 - Outbound(ThrottleStepResponseDto$Outbound;
}

export function throttleStepResponseDtoToJSON(throttleStepRespo...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  type
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function throttleStepResponseDtoControlValuesToJSON
- export function throttleStepResponseDtoControlValuesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function throttleStepResponseDtoToJSON
- export function throttleStepResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/throttlestepupsertdto.ts
Tamaño: 5431 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import { StepTypeEnum, StepTypeEnum$inboundSchema, StepTypeEnum$outboundSchema } from './steptypeenum.js';
import {
  ThrottleControlDto,
  ThrottleControlDto$inboundSchema,
  ThrottleControlDto$Outbound,
  ThrottleControlDto$outboundSchema,
} from './throttlecontroldto.js';

/**
 * Control values for the Throttle step.
 */
export type ThrottleStepUpsertDtoControlValues =
  | ThrottleControlDto
  | {
      [k: string]: any;
    };

export type ThrottleStepUpsertDto = {
  /**
   * Database identifier of the step. Used for updating the step.
   */
  id?: string | undefined;
  /**
   * Unique identifier for the step
   */
  stepId?: string | undefined;
  /**
   * Name of the step
   */
  name: string;
  /**
   * Type of the step
   */
  type: StepTypeEnum;
  /**
   * Control values for the Throttle step.
   */
  controlValues?: ThrottleControlDto | { [k: string]: any } | undefined;
};

/** @internal */
export const ThrottleStepUpsertDtoControlValues$inboundSchema: z.ZodType<
  ThrottleStepUpsertDtoControlValues,
  z.ZodTypeDef,
  unknown
> = z.union([ThrottleControlDto$inboundSchema, z.record(z.any())]);

/** @internal */
export type ThrottleStepUpsertDtoControlValues$Outbound = ThrottleControlDto$Outbound | { [k: string]: any };

/** @internal */
export const ThrottleStepUpsertDtoControlValues$outboundSchema: z.ZodType<
  ThrottleStepUpsertDtoControlValues$Outbound,
  z.ZodTypeDef,
  ThrottleStepUpsertDtoControlValues
> = z.union([ThrottleControlDto$outboundSchema, z.record(z.any())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ThrottleStepUpsertDtoControlValues$ {
  /** @deprecated use `ThrottleStepUpsertDtoControlValues$inboundSchema` instead. */
  export const inboundSchema = ThrottleStepUpsertDtoControlValues$inboundSchema;
  /** @deprecated use `ThrottleStepUpsertDtoControlValues$outboundSchema` instead. */
  export const outboundSchema = ThrottleStepUpsertDtoControlValues$outboundSchema;
  /** @deprecated use `ThrottleStepUpsertDtoControlValues$Outbound` instead. */
  export type Outbound = ThrottleStepUpsertDtoControlValues$Outbound;
}

export function throttleStepUpsertDtoControlValuesToJSON(
  throttleStepUpsertDtoControlValues: ThrottleStepUpsertDtoControlValues
): string {
  return JSON.stringify(ThrottleStepUpsertDtoControlValues$outboundSchema.parse(throttleStepUpsertDtoControlValues));
}

export function throttleStepUpsertDtoControlValuesFromJSON(
  jsonString: string
): SafeParseResult<ThrottleStepUpsertDtoControlValues, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ThrottleStepUpsertDtoControlValues$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ThrottleStepUpsertDtoControlValues' from JSON`
  );
}

/** @internal */
export const ThrottleStepUpsertDto$inboundSchema: z.ZodType<ThrottleStepUpsertDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().optional(),
    stepId: z.string().optional(),
    name: z.string(),
    type: StepTypeEnum$inboundSchema,
    controlValues: z.union([ThrottleControlDto$inboundSchema, z.record(z.any())]).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type ThrottleStepUpsertDto$Outbound = {
  _id?: string | undefined;
  stepId?: string | undefined;
  name: string;
  type: string;
  controlValues?: ThrottleControlDto$Outbound | { [k: string]: any } | undefined;
};

/** @internal */
export const ThrottleStepUpsertDto$outboundSchema: z.ZodType<
  ThrottleStepUpsertDto$Outbound,
  z.ZodTypeDef,
  ThrottleStepUpsertDto
> = z
  .object({
    id: z.string().optional(),
    stepId: z.string().optional(),
    name: z.string(),
    type: StepTypeEnum$outboundSchema,
    controlValues: z.union([ThrottleControlDto$outboundSchema, z.record(z.any())]).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ThrottleStepUpsertDto$ {
  /** @deprecated use `ThrottleStepUpsertDto$inboundSchema` instead. */
  export const inboundSchema = ThrottleStepUpsertDto$inboundSchema;
  /** @deprecated use `ThrottleStepUpsertDto$outboundSchema` instead. */
  export const outboundSchema = ThrottleStepUpsertDto$outboundSchema;
  /** @deprecated use `ThrottleStepUpsertDto$Outbound` instead. */
  export type Outbound = ThrottleStepUpsertDto$Outbound;
}

export function throttleStepUpsertDtoToJSON(throttleStepUpsertDto: ThrottleStepUpsertDto): string {
  return JSON.stringify(ThrottleStepUpsertDto$outboundSchema.parse(throttleStepUpsertDto));
}

export function throttleStepUpsertDtoFromJSON(
  jsonString: string
): SafeParseResult<ThrottleStepUpsertDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ThrottleStepUpsertDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ThrottleStepUpsertDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - throttleStepUpsertDtoControlValuesToJSON(throttleStepUpsertDtoControlValues: ThrottleStepUpsertDtoControlValues)
 - throttleStepUpsertDtoControlValuesFromJSON(jsonString: string)
 - throttleStepUpsertDtoToJSON(throttleStepUpsertDto: ThrottleStepUpsertDto)
 - throttleStepUpsertDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ThrottleStepUpsertDtoControlValues$Outbound;
}

export function throttleStepUpsertDtoControlValuesTo...)
 - Outbound(ThrottleStepUpsertDto$Outbound;
}

export function throttleStepUpsertDtoToJSON(throttleStepUpsertDto...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function throttleStepUpsertDtoControlValuesToJSON
- export function throttleStepUpsertDtoControlValuesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function throttleStepUpsertDtoToJSON
- export function throttleStepUpsertDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/timedconfig.ts
Tamaño: 6351 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export const TimedConfigWeekDays = {
  Monday: 'monday',
  Tuesday: 'tuesday',
  Wednesday: 'wednesday',
  Thursday: 'thursday',
  Friday: 'friday',
  Saturday: 'saturday',
  Sunday: 'sunday',
} as const;
export type TimedConfigWeekDays = ClosedEnum<typeof TimedConfigWeekDays>;

export const Ordinal = {
  One: '1',
  Two: '2',
  Three: '3',
  Four: '4',
  Five: '5',
  Last: 'last',
} as const;
export type Ordinal = ClosedEnum<typeof Ordinal>;

export const OrdinalValue = {
  Day: 'day',
  Weekday: 'weekday',
  Weekend: 'weekend',
  Sunday: 'sunday',
  Monday: 'monday',
  Tuesday: 'tuesday',
  Wednesday: 'wednesday',
  Thursday: 'thursday',
  Friday: 'friday',
  Saturday: 'saturday',
} as const;
export type OrdinalValue = ClosedEnum<typeof OrdinalValue>;

export const MonthlyType = {
  Each: 'each',
  On: 'on',
} as const;
export type MonthlyType = ClosedEnum<typeof MonthlyType>;

export type TimedConfig = {
  atTime?: string | undefined;
  weekDays?: Array<TimedConfigWeekDays> | undefined;
  monthDays?: Array<string> | undefined;
  ordinal?: Ordinal | undefined;
  ordinalValue?: OrdinalValue | undefined;
  monthlyType?: MonthlyType | undefined;
};

/** @internal */
export const TimedConfigWeekDays$inboundSchema: z.ZodNativeEnum<typeof TimedConfigWeekDays> =
  z.nativeEnum(TimedConfigWeekDays);

/** @internal */
export const TimedConfigWeekDays$outboundSchema: z.ZodNativeEnum<typeof TimedConfigWeekDays> =
  TimedConfigWeekDays$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimedConfigWeekDays$ {
  /** @deprecated use `TimedConfigWeekDays$inboundSchema` instead. */
  export const inboundSchema = TimedConfigWeekDays$inboundSchema;
  /** @deprecated use `TimedConfigWeekDays$outboundSchema` instead. */
  export const outboundSchema = TimedConfigWeekDays$outboundSchema;
}

/** @internal */
export const Ordinal$inboundSchema: z.ZodNativeEnum<typeof Ordinal> = z.nativeEnum(Ordinal);

/** @internal */
export const Ordinal$outboundSchema: z.ZodNativeEnum<typeof Ordinal> = Ordinal$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Ordinal$ {
  /** @deprecated use `Ordinal$inboundSchema` instead. */
  export const inboundSchema = Ordinal$inboundSchema;
  /** @deprecated use `Ordinal$outboundSchema` instead. */
  export const outboundSchema = Ordinal$outboundSchema;
}

/** @internal */
export const OrdinalValue$inboundSchema: z.ZodNativeEnum<typeof OrdinalValue> = z.nativeEnum(OrdinalValue);

/** @internal */
export const OrdinalValue$outboundSchema: z.ZodNativeEnum<typeof OrdinalValue> = OrdinalValue$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OrdinalValue$ {
  /** @deprecated use `OrdinalValue$inboundSchema` instead. */
  export const inboundSchema = OrdinalValue$inboundSchema;
  /** @deprecated use `OrdinalValue$outboundSchema` instead. */
  export const outboundSchema = OrdinalValue$outboundSchema;
}

/** @internal */
export const MonthlyType$inboundSchema: z.ZodNativeEnum<typeof MonthlyType> = z.nativeEnum(MonthlyType);

/** @internal */
export const MonthlyType$outboundSchema: z.ZodNativeEnum<typeof MonthlyType> = MonthlyType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MonthlyType$ {
  /** @deprecated use `MonthlyType$inboundSchema` instead. */
  export const inboundSchema = MonthlyType$inboundSchema;
  /** @deprecated use `MonthlyType$outboundSchema` instead. */
  export const outboundSchema = MonthlyType$outboundSchema;
}

/** @internal */
export const TimedConfig$inboundSchema: z.ZodType<TimedConfig, z.ZodTypeDef, unknown> = z.object({
  atTime: z.string().optional(),
  weekDays: z.array(TimedConfigWeekDays$inboundSchema).optional(),
  monthDays: z.array(z.string()).optional(),
  ordinal: Ordinal$inboundSchema.optional(),
  ordinalValue: OrdinalValue$inboundSchema.optional(),
  monthlyType: MonthlyType$inboundSchema.optional(),
});

/** @internal */
export type TimedConfig$Outbound = {
  atTime?: string | undefined;
  weekDays?: Array<string> | undefined;
  monthDays?: Array<string> | undefined;
  ordinal?: string | undefined;
  ordinalValue?: string | undefined;
  monthlyType?: string | undefined;
};

/** @internal */
export const TimedConfig$outboundSchema: z.ZodType<TimedConfig$Outbound, z.ZodTypeDef, TimedConfig> = z.object({
  atTime: z.string().optional(),
  weekDays: z.array(TimedConfigWeekDays$outboundSchema).optional(),
  monthDays: z.array(z.string()).optional(),
  ordinal: Ordinal$outboundSchema.optional(),
  ordinalValue: OrdinalValue$outboundSchema.optional(),
  monthlyType: MonthlyType$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimedConfig$ {
  /** @deprecated use `TimedConfig$inboundSchema` instead. */
  export const inboundSchema = TimedConfig$inboundSchema;
  /** @deprecated use `TimedConfig$outboundSchema` instead. */
  export const outboundSchema = TimedConfig$outboundSchema;
  /** @deprecated use `TimedConfig$Outbound` instead. */
  export type Outbound = TimedConfig$Outbound;
}

export function timedConfigToJSON(timedConfig: TimedConfig): string {
  return JSON.stringify(TimedConfig$outboundSchema.parse(timedConfig));
}

export function timedConfigFromJSON(jsonString: string): SafeParseResult<TimedConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimedConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimedConfig' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - timedConfigToJSON(timedConfig: TimedConfig)
 - timedConfigFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TimedConfig$Outbound;
}

export function timedConfigToJSON(timedConfig: TimedConfig): string {
  ret...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  type
- export  const
- export  type
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function timedConfigToJSON
- export function timedConfigFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/timerangedto.ts
Tamaño: 1794 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TimeRangeDto = {
  /**
   * Start time
   */
  start: string;
  /**
   * End time
   */
  end: string;
};

/** @internal */
export const TimeRangeDto$inboundSchema: z.ZodType<TimeRangeDto, z.ZodTypeDef, unknown> = z.object({
  start: z.string(),
  end: z.string(),
});

/** @internal */
export type TimeRangeDto$Outbound = {
  start: string;
  end: string;
};

/** @internal */
export const TimeRangeDto$outboundSchema: z.ZodType<TimeRangeDto$Outbound, z.ZodTypeDef, TimeRangeDto> = z.object({
  start: z.string(),
  end: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimeRangeDto$ {
  /** @deprecated use `TimeRangeDto$inboundSchema` instead. */
  export const inboundSchema = TimeRangeDto$inboundSchema;
  /** @deprecated use `TimeRangeDto$outboundSchema` instead. */
  export const outboundSchema = TimeRangeDto$outboundSchema;
  /** @deprecated use `TimeRangeDto$Outbound` instead. */
  export type Outbound = TimeRangeDto$Outbound;
}

export function timeRangeDtoToJSON(timeRangeDto: TimeRangeDto): string {
  return JSON.stringify(TimeRangeDto$outboundSchema.parse(timeRangeDto));
}

export function timeRangeDtoFromJSON(jsonString: string): SafeParseResult<TimeRangeDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimeRangeDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeRangeDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - timeRangeDtoToJSON(timeRangeDto: TimeRangeDto)
 - timeRangeDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TimeRangeDto$Outbound;
}

export function timeRangeDtoToJSON(timeRangeDto: TimeRangeDto): string {
 ...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function timeRangeDtoToJSON
- export function timeRangeDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/timeunitenum.ts
Tamaño: 1108 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Time unit
 */
export const TimeUnitEnum = {
  Seconds: 'seconds',
  Minutes: 'minutes',
  Hours: 'hours',
  Days: 'days',
  Weeks: 'weeks',
  Months: 'months',
} as const;
/**
 * Time unit
 */
export type TimeUnitEnum = ClosedEnum<typeof TimeUnitEnum>;

/** @internal */
export const TimeUnitEnum$inboundSchema: z.ZodNativeEnum<typeof TimeUnitEnum> = z.nativeEnum(TimeUnitEnum);

/** @internal */
export const TimeUnitEnum$outboundSchema: z.ZodNativeEnum<typeof TimeUnitEnum> = TimeUnitEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimeUnitEnum$ {
  /** @deprecated use `TimeUnitEnum$inboundSchema` instead. */
  export const inboundSchema = TimeUnitEnum$inboundSchema;
  /** @deprecated use `TimeUnitEnum$outboundSchema` instead. */
  export const outboundSchema = TimeUnitEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/topicdto.ts
Tamaño: 2207 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TopicDto = {
  /**
   * The internal unique identifier of the topic
   */
  id: string;
  /**
   * The key identifier of the topic used in your application. Should be unique on the environment level.
   */
  key: string;
  /**
   * The name of the topic
   */
  name?: string | undefined;
};

/** @internal */
export const TopicDto$inboundSchema: z.ZodType<TopicDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string(),
    key: z.string(),
    name: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type TopicDto$Outbound = {
  _id: string;
  key: string;
  name?: string | undefined;
};

/** @internal */
export const TopicDto$outboundSchema: z.ZodType<TopicDto$Outbound, z.ZodTypeDef, TopicDto> = z
  .object({
    id: z.string(),
    key: z.string(),
    name: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicDto$ {
  /** @deprecated use `TopicDto$inboundSchema` instead. */
  export const inboundSchema = TopicDto$inboundSchema;
  /** @deprecated use `TopicDto$outboundSchema` instead. */
  export const outboundSchema = TopicDto$outboundSchema;
  /** @deprecated use `TopicDto$Outbound` instead. */
  export type Outbound = TopicDto$Outbound;
}

export function topicDtoToJSON(topicDto: TopicDto): string {
  return JSON.stringify(TopicDto$outboundSchema.parse(topicDto));
}

export function topicDtoFromJSON(jsonString: string): SafeParseResult<TopicDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicDtoToJSON(topicDto: TopicDto)
 - topicDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TopicDto$Outbound;
}

export function topicDtoToJSON(topicDto: TopicDto): string {
  return JSON.str...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicDtoToJSON
- export function topicDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/topicpayloaddto.ts
Tamaño: 2327 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  TriggerRecipientsTypeEnum,
  TriggerRecipientsTypeEnum$inboundSchema,
  TriggerRecipientsTypeEnum$outboundSchema,
} from './triggerrecipientstypeenum.js';

export type TopicPayloadDto = {
  topicKey: string;
  type: TriggerRecipientsTypeEnum;
  /**
   * Optional array of subscriber IDs to exclude from the topic trigger
   */
  exclude?: Array<string> | undefined;
};

/** @internal */
export const TopicPayloadDto$inboundSchema: z.ZodType<TopicPayloadDto, z.ZodTypeDef, unknown> = z.object({
  topicKey: z.string(),
  type: TriggerRecipientsTypeEnum$inboundSchema,
  exclude: z.array(z.string()).optional(),
});

/** @internal */
export type TopicPayloadDto$Outbound = {
  topicKey: string;
  type: string;
  exclude?: Array<string> | undefined;
};

/** @internal */
export const TopicPayloadDto$outboundSchema: z.ZodType<TopicPayloadDto$Outbound, z.ZodTypeDef, TopicPayloadDto> =
  z.object({
    topicKey: z.string(),
    type: TriggerRecipientsTypeEnum$outboundSchema,
    exclude: z.array(z.string()).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicPayloadDto$ {
  /** @deprecated use `TopicPayloadDto$inboundSchema` instead. */
  export const inboundSchema = TopicPayloadDto$inboundSchema;
  /** @deprecated use `TopicPayloadDto$outboundSchema` instead. */
  export const outboundSchema = TopicPayloadDto$outboundSchema;
  /** @deprecated use `TopicPayloadDto$Outbound` instead. */
  export type Outbound = TopicPayloadDto$Outbound;
}

export function topicPayloadDtoToJSON(topicPayloadDto: TopicPayloadDto): string {
  return JSON.stringify(TopicPayloadDto$outboundSchema.parse(topicPayloadDto));
}

export function topicPayloadDtoFromJSON(jsonString: string): SafeParseResult<TopicPayloadDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicPayloadDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicPayloadDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicPayloadDtoToJSON(topicPayloadDto: TopicPayloadDto)
 - topicPayloadDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TopicPayloadDto$Outbound;
}

export function topicPayloadDtoToJSON(topicPayloadDto: TopicPayloadDto)...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicPayloadDtoToJSON
- export function topicPayloadDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/topicresponsedto.ts
Tamaño: 2691 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TopicResponseDto = {
  /**
   * The identifier of the topic
   */
  id: string;
  /**
   * The unique key of the topic
   */
  key: string;
  /**
   * The name of the topic
   */
  name?: string | undefined;
  /**
   * The date the topic was created
   */
  createdAt?: string | undefined;
  /**
   * The date the topic was last updated
   */
  updatedAt?: string | undefined;
};

/** @internal */
export const TopicResponseDto$inboundSchema: z.ZodType<TopicResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string(),
    key: z.string(),
    name: z.string().optional(),
    createdAt: z.string().optional(),
    updatedAt: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type TopicResponseDto$Outbound = {
  _id: string;
  key: string;
  name?: string | undefined;
  createdAt?: string | undefined;
  updatedAt?: string | undefined;
};

/** @internal */
export const TopicResponseDto$outboundSchema: z.ZodType<TopicResponseDto$Outbound, z.ZodTypeDef, TopicResponseDto> = z
  .object({
    id: z.string(),
    key: z.string(),
    name: z.string().optional(),
    createdAt: z.string().optional(),
    updatedAt: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicResponseDto$ {
  /** @deprecated use `TopicResponseDto$inboundSchema` instead. */
  export const inboundSchema = TopicResponseDto$inboundSchema;
  /** @deprecated use `TopicResponseDto$outboundSchema` instead. */
  export const outboundSchema = TopicResponseDto$outboundSchema;
  /** @deprecated use `TopicResponseDto$Outbound` instead. */
  export type Outbound = TopicResponseDto$Outbound;
}

export function topicResponseDtoToJSON(topicResponseDto: TopicResponseDto): string {
  return JSON.stringify(TopicResponseDto$outboundSchema.parse(topicResponseDto));
}

export function topicResponseDtoFromJSON(jsonString: string): SafeParseResult<TopicResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicResponseDtoToJSON(topicResponseDto: TopicResponseDto)
 - topicResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TopicResponseDto$Outbound;
}

export function topicResponseDtoToJSON(topicResponseDto: TopicResponse...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicResponseDtoToJSON
- export function topicResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/topicsubscriberdto.ts
Tamaño: 3200 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TopicSubscriberDto = {
  /**
   * Unique identifier for the organization
   */
  organizationId: string;
  /**
   * Unique identifier for the environment
   */
  environmentId: string;
  /**
   * Unique identifier for the subscriber
   */
  subscriberId: string;
  /**
   * Unique identifier for the topic
   */
  topicId: string;
  /**
   * Key associated with the topic
   */
  topicKey: string;
  /**
   * External identifier for the subscriber
   */
  externalSubscriberId: string;
};

/** @internal */
export const TopicSubscriberDto$inboundSchema: z.ZodType<TopicSubscriberDto, z.ZodTypeDef, unknown> = z
  .object({
    _organizationId: z.string(),
    _environmentId: z.string(),
    _subscriberId: z.string(),
    _topicId: z.string(),
    topicKey: z.string(),
    externalSubscriberId: z.string(),
  })
  .transform((v) => {
    return remap$(v, {
      _organizationId: 'organizationId',
      _environmentId: 'environmentId',
      _subscriberId: 'subscriberId',
      _topicId: 'topicId',
    });
  });

/** @internal */
export type TopicSubscriberDto$Outbound = {
  _organizationId: string;
  _environmentId: string;
  _subscriberId: string;
  _topicId: string;
  topicKey: string;
  externalSubscriberId: string;
};

/** @internal */
export const TopicSubscriberDto$outboundSchema: z.ZodType<
  TopicSubscriberDto$Outbound,
  z.ZodTypeDef,
  TopicSubscriberDto
> = z
  .object({
    organizationId: z.string(),
    environmentId: z.string(),
    subscriberId: z.string(),
    topicId: z.string(),
    topicKey: z.string(),
    externalSubscriberId: z.string(),
  })
  .transform((v) => {
    return remap$(v, {
      organizationId: '_organizationId',
      environmentId: '_environmentId',
      subscriberId: '_subscriberId',
      topicId: '_topicId',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicSubscriberDto$ {
  /** @deprecated use `TopicSubscriberDto$inboundSchema` instead. */
  export const inboundSchema = TopicSubscriberDto$inboundSchema;
  /** @deprecated use `TopicSubscriberDto$outboundSchema` instead. */
  export const outboundSchema = TopicSubscriberDto$outboundSchema;
  /** @deprecated use `TopicSubscriberDto$Outbound` instead. */
  export type Outbound = TopicSubscriberDto$Outbound;
}

export function topicSubscriberDtoToJSON(topicSubscriberDto: TopicSubscriberDto): string {
  return JSON.stringify(TopicSubscriberDto$outboundSchema.parse(topicSubscriberDto));
}

export function topicSubscriberDtoFromJSON(
  jsonString: string
): SafeParseResult<TopicSubscriberDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicSubscriberDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicSubscriberDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicSubscriberDtoToJSON(topicSubscriberDto: TopicSubscriberDto)
 - topicSubscriberDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TopicSubscriberDto$Outbound;
}

export function topicSubscriberDtoToJSON(topicSubscriberDto: TopicSu...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicSubscriberDtoToJSON
- export function topicSubscriberDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/topicsubscriptionresponsedto.ts
Tamaño: 3171 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  SubscriberDto,
  SubscriberDto$inboundSchema,
  SubscriberDto$Outbound,
  SubscriberDto$outboundSchema,
} from './subscriberdto.js';
import {
  TopicResponseDto,
  TopicResponseDto$inboundSchema,
  TopicResponseDto$Outbound,
  TopicResponseDto$outboundSchema,
} from './topicresponsedto.js';

export type TopicSubscriptionResponseDto = {
  /**
   * The identifier of the subscription
   */
  id: string;
  /**
   * The date and time the subscription was created
   */
  createdAt: string;
  /**
   * Topic information
   */
  topic: TopicResponseDto;
  /**
   * Subscriber information
   */
  subscriber: SubscriberDto;
};

/** @internal */
export const TopicSubscriptionResponseDto$inboundSchema: z.ZodType<
  TopicSubscriptionResponseDto,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    _id: z.string(),
    createdAt: z.string(),
    topic: TopicResponseDto$inboundSchema,
    subscriber: SubscriberDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type TopicSubscriptionResponseDto$Outbound = {
  _id: string;
  createdAt: string;
  topic: TopicResponseDto$Outbound;
  subscriber: SubscriberDto$Outbound;
};

/** @internal */
export const TopicSubscriptionResponseDto$outboundSchema: z.ZodType<
  TopicSubscriptionResponseDto$Outbound,
  z.ZodTypeDef,
  TopicSubscriptionResponseDto
> = z
  .object({
    id: z.string(),
    createdAt: z.string(),
    topic: TopicResponseDto$outboundSchema,
    subscriber: SubscriberDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicSubscriptionResponseDto$ {
  /** @deprecated use `TopicSubscriptionResponseDto$inboundSchema` instead. */
  export const inboundSchema = TopicSubscriptionResponseDto$inboundSchema;
  /** @deprecated use `TopicSubscriptionResponseDto$outboundSchema` instead. */
  export const outboundSchema = TopicSubscriptionResponseDto$outboundSchema;
  /** @deprecated use `TopicSubscriptionResponseDto$Outbound` instead. */
  export type Outbound = TopicSubscriptionResponseDto$Outbound;
}

export function topicSubscriptionResponseDtoToJSON(topicSubscriptionResponseDto: TopicSubscriptionResponseDto): string {
  return JSON.stringify(TopicSubscriptionResponseDto$outboundSchema.parse(topicSubscriptionResponseDto));
}

export function topicSubscriptionResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<TopicSubscriptionResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicSubscriptionResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicSubscriptionResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicSubscriptionResponseDtoToJSON(topicSubscriptionResponseDto: TopicSubscriptionResponseDto)
 - topicSubscriptionResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TopicSubscriptionResponseDto$Outbound;
}

export function topicSubscriptionResponseDtoToJSON(topicSu...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicSubscriptionResponseDtoToJSON
- export function topicSubscriptionResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/traceresponsedto.ts
Tamaño: 10966 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Detailed message
 */
export type Message = {};

/**
 * Raw data associated with trace
 */
export type RawData = {};

/**
 * User identifier
 */
export type UserId = {};

/**
 * External subscriber identifier
 */
export type ExternalSubscriberId = {};

/**
 * Subscriber identifier
 */
export type SubscriberId = {};

export type TraceResponseDto = {
  /**
   * Trace identifier
   */
  id: string;
  /**
   * Creation timestamp
   */
  createdAt: string;
  /**
   * Event type (e.g., request_received, workflow_execution_started)
   */
  eventType: string;
  /**
   * Human readable title/message
   */
  title: string;
  /**
   * Detailed message
   */
  message?: Message | null | undefined;
  /**
   * Raw data associated with trace
   */
  rawData?: RawData | null | undefined;
  /**
   * Trace status (success, error, warning, pending)
   */
  status: string;
  /**
   * Entity type (request, workflow_run, step_run)
   */
  entityType: string;
  /**
   * Entity identifier
   */
  entityId: string;
  /**
   * Organization identifier
   */
  organizationId: string;
  /**
   * Environment identifier
   */
  environmentId: string;
  /**
   * User identifier
   */
  userId?: UserId | null | undefined;
  /**
   * External subscriber identifier
   */
  externalSubscriberId?: ExternalSubscriberId | null | undefined;
  /**
   * Subscriber identifier
   */
  subscriberId?: SubscriberId | null | undefined;
};

/** @internal */
export const Message$inboundSchema: z.ZodType<Message, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type Message$Outbound = {};

/** @internal */
export const Message$outboundSchema: z.ZodType<Message$Outbound, z.ZodTypeDef, Message> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Message$ {
  /** @deprecated use `Message$inboundSchema` instead. */
  export const inboundSchema = Message$inboundSchema;
  /** @deprecated use `Message$outboundSchema` instead. */
  export const outboundSchema = Message$outboundSchema;
  /** @deprecated use `Message$Outbound` instead. */
  export type Outbound = Message$Outbound;
}

export function messageToJSON(message: Message): string {
  return JSON.stringify(Message$outboundSchema.parse(message));
}

export function messageFromJSON(jsonString: string): SafeParseResult<Message, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Message$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Message' from JSON`
  );
}

/** @internal */
export const RawData$inboundSchema: z.ZodType<RawData, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type RawData$Outbound = {};

/** @internal */
export const RawData$outboundSchema: z.ZodType<RawData$Outbound, z.ZodTypeDef, RawData> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RawData$ {
  /** @deprecated use `RawData$inboundSchema` instead. */
  export const inboundSchema = RawData$inboundSchema;
  /** @deprecated use `RawData$outboundSchema` instead. */
  export const outboundSchema = RawData$outboundSchema;
  /** @deprecated use `RawData$Outbound` instead. */
  export type Outbound = RawData$Outbound;
}

export function rawDataToJSON(rawData: RawData): string {
  return JSON.stringify(RawData$outboundSchema.parse(rawData));
}

export function rawDataFromJSON(jsonString: string): SafeParseResult<RawData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RawData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RawData' from JSON`
  );
}

/** @internal */
export const UserId$inboundSchema: z.ZodType<UserId, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type UserId$Outbound = {};

/** @internal */
export const UserId$outboundSchema: z.ZodType<UserId$Outbound, z.ZodTypeDef, UserId> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UserId$ {
  /** @deprecated use `UserId$inboundSchema` instead. */
  export const inboundSchema = UserId$inboundSchema;
  /** @deprecated use `UserId$outboundSchema` instead. */
  export const outboundSchema = UserId$outboundSchema;
  /** @deprecated use `UserId$Outbound` instead. */
  export type Outbound = UserId$Outbound;
}

export function userIdToJSON(userId: UserId): string {
  return JSON.stringify(UserId$outboundSchema.parse(userId));
}

export function userIdFromJSON(jsonString: string): SafeParseResult<UserId, SDKValidationError> {
  return safeParse(jsonString, (x) => UserId$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'UserId' from JSON`);
}

/** @internal */
export const ExternalSubscriberId$inboundSchema: z.ZodType<ExternalSubscriberId, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type ExternalSubscriberId$Outbound = {};

/** @internal */
export const ExternalSubscriberId$outboundSchema: z.ZodType<
  ExternalSubscriberId$Outbound,
  z.ZodTypeDef,
  ExternalSubscriberId
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ExternalSubscriberId$ {
  /** @deprecated use `ExternalSubscriberId$inboundSchema` instead. */
  export const inboundSchema = ExternalSubscriberId$inboundSchema;
  /** @deprecated use `ExternalSubscriberId$outboundSchema` instead. */
  export const outboundSchema = ExternalSubscriberId$outboundSchema;
  /** @deprecated use `ExternalSubscriberId$Outbound` instead. */
  export type Outbound = ExternalSubscriberId$Outbound;
}

export function externalSubscriberIdToJSON(externalSubscriberId: ExternalSubscriberId): string {
  return JSON.stringify(ExternalSubscriberId$outboundSchema.parse(externalSubscriberId));
}

export function externalSubscriberIdFromJSON(
  jsonString: string
): SafeParseResult<ExternalSubscriberId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExternalSubscriberId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExternalSubscriberId' from JSON`
  );
}

/** @internal */
export const SubscriberId$inboundSchema: z.ZodType<SubscriberId, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type SubscriberId$Outbound = {};

/** @internal */
export const SubscriberId$outboundSchema: z.ZodType<SubscriberId$Outbound, z.ZodTypeDef, SubscriberId> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriberId$ {
  /** @deprecated use `SubscriberId$inboundSchema` instead. */
  export const inboundSchema = SubscriberId$inboundSchema;
  /** @deprecated use `SubscriberId$outboundSchema` instead. */
  export const outboundSchema = SubscriberId$outboundSchema;
  /** @deprecated use `SubscriberId$Outbound` instead. */
  export type Outbound = SubscriberId$Outbound;
}

export function subscriberIdToJSON(subscriberId: SubscriberId): string {
  return JSON.stringify(SubscriberId$outboundSchema.parse(subscriberId));
}

export function subscriberIdFromJSON(jsonString: string): SafeParseResult<SubscriberId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriberId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriberId' from JSON`
  );
}

/** @internal */
export const TraceResponseDto$inboundSchema: z.ZodType<TraceResponseDto, z.ZodTypeDef, unknown> = z.object({
  id: z.string(),
  createdAt: z.string(),
  eventType: z.string(),
  title: z.string(),
  message: z.nullable(z.lazy(() => Message$inboundSchema)).optional(),
  rawData: z.nullable(z.lazy(() => RawData$inboundSchema)).optional(),
  status: z.string(),
  entityType: z.string(),
  entityId: z.string(),
  organizationId: z.string(),
  environmentId: z.string(),
  userId: z.nullable(z.lazy(() => UserId$inboundSchema)).optional(),
  externalSubscriberId: z.nullable(z.lazy(() => ExternalSubscriberId$inboundSchema)).optional(),
  subscriberId: z.nullable(z.lazy(() => SubscriberId$inboundSchema)).optional(),
});

/** @internal */
export type TraceResponseDto$Outbound = {
  id: string;
  createdAt: string;
  eventType: string;
  title: string;
  message?: Message$Outbound | null | undefined;
  rawData?: RawData$Outbound | null | undefined;
  status: string;
  entityType: string;
  entityId: string;
  organizationId: string;
  environmentId: string;
  userId?: UserId$Outbound | null | undefined;
  externalSubscriberId?: ExternalSubscriberId$Outbound | null | undefined;
  subscriberId?: SubscriberId$Outbound | null | undefined;
};

/** @internal */
export const TraceResponseDto$outboundSchema: z.ZodType<TraceResponseDto$Outbound, z.ZodTypeDef, TraceResponseDto> =
  z.object({
    id: z.string(),
    createdAt: z.string(),
    eventType: z.string(),
    title: z.string(),
    message: z.nullable(z.lazy(() => Message$outboundSchema)).optional(),
    rawData: z.nullable(z.lazy(() => RawData$outboundSchema)).optional(),
    status: z.string(),
    entityType: z.string(),
    entityId: z.string(),
    organizationId: z.string(),
    environmentId: z.string(),
    userId: z.nullable(z.lazy(() => UserId$outboundSchema)).optional(),
    externalSubscriberId: z.nullable(z.lazy(() => ExternalSubscriberId$outboundSchema)).optional(),
    subscriberId: z.nullable(z.lazy(() => SubscriberId$outboundSchema)).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TraceResponseDto$ {
  /** @deprecated use `TraceResponseDto$inboundSchema` instead. */
  export const inboundSchema = TraceResponseDto$inboundSchema;
  /** @deprecated use `TraceResponseDto$outboundSchema` instead. */
  export const outboundSchema = TraceResponseDto$outboundSchema;
  /** @deprecated use `TraceResponseDto$Outbound` instead. */
  export type Outbound = TraceResponseDto$Outbound;
}

export function traceResponseDtoToJSON(traceResponseDto: TraceResponseDto): string {
  return JSON.stringify(TraceResponseDto$outboundSchema.parse(traceResponseDto));
}

export function traceResponseDtoFromJSON(jsonString: string): SafeParseResult<TraceResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TraceResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TraceResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messageToJSON(message: Message)
 - messageFromJSON(jsonString: string)
 - rawDataToJSON(rawData: RawData)
 - rawDataFromJSON(jsonString: string)
 - userIdToJSON(userId: UserId)
 - userIdFromJSON(jsonString: string)
 - externalSubscriberIdToJSON(externalSubscriberId: ExternalSubscriberId)
 - externalSubscriberIdFromJSON(jsonString: string)
 - subscriberIdToJSON(subscriberId: SubscriberId)
 - subscriberIdFromJSON(jsonString: string)
 - traceResponseDtoToJSON(traceResponseDto: TraceResponseDto)
 - traceResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Message$Outbound;
}

export function messageToJSON(message: Message): string {
  return JSON.stringi...)
 - Outbound(RawData$Outbound;
}

export function rawDataToJSON(rawData: RawData): string {
  return JSON.stringi...)
 - Outbound(UserId$Outbound;
}

export function userIdToJSON(userId: UserId): string {
  return JSON.stringify(U...)
 - Outbound(ExternalSubscriberId$Outbound;
}

export function externalSubscriberIdToJSON(externalSubscriberId: E...)
 - Outbound(SubscriberId$Outbound;
}

export function subscriberIdToJSON(subscriberId: SubscriberId): string {
 ...)
 - Outbound(TraceResponseDto$Outbound;
}

export function traceResponseDtoToJSON(traceResponseDto: TraceResponse...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messageToJSON
- export function messageFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function rawDataToJSON
- export function rawDataFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function userIdToJSON
- export function userIdFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function externalSubscriberIdToJSON
- export function externalSubscriberIdFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscriberIdToJSON
- export function subscriberIdFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function traceResponseDtoToJSON
- export function traceResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/translationgroupdto.ts
Tamaño: 4267 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Resource type
 */
export const TranslationGroupDtoResourceType = {
  Workflow: 'workflow',
  Layout: 'layout',
} as const;
/**
 * Resource type
 */
export type TranslationGroupDtoResourceType = ClosedEnum<typeof TranslationGroupDtoResourceType>;

export type TranslationGroupDto = {
  /**
   * Resource identifier (slugified ID)
   */
  resourceId: string;
  /**
   * Resource type
   */
  resourceType: TranslationGroupDtoResourceType;
  /**
   * Resource name (e.g., workflow name)
   */
  resourceName: string;
  /**
   * Array of available locales for this resource
   */
  locales: Array<string>;
  /**
   * Locales that are outdated compared to the default locale (only present when there are outdated locales)
   */
  outdatedLocales?: Array<string> | undefined;
  /**
   * Creation timestamp
   */
  createdAt: string;
  /**
   * Last update timestamp
   */
  updatedAt: string;
};

/** @internal */
export const TranslationGroupDtoResourceType$inboundSchema: z.ZodNativeEnum<typeof TranslationGroupDtoResourceType> =
  z.nativeEnum(TranslationGroupDtoResourceType);

/** @internal */
export const TranslationGroupDtoResourceType$outboundSchema: z.ZodNativeEnum<typeof TranslationGroupDtoResourceType> =
  TranslationGroupDtoResourceType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TranslationGroupDtoResourceType$ {
  /** @deprecated use `TranslationGroupDtoResourceType$inboundSchema` instead. */
  export const inboundSchema = TranslationGroupDtoResourceType$inboundSchema;
  /** @deprecated use `TranslationGroupDtoResourceType$outboundSchema` instead. */
  export const outboundSchema = TranslationGroupDtoResourceType$outboundSchema;
}

/** @internal */
export const TranslationGroupDto$inboundSchema: z.ZodType<TranslationGroupDto, z.ZodTypeDef, unknown> = z.object({
  resourceId: z.string(),
  resourceType: TranslationGroupDtoResourceType$inboundSchema,
  resourceName: z.string(),
  locales: z.array(z.string()),
  outdatedLocales: z.array(z.string()).optional(),
  createdAt: z.string(),
  updatedAt: z.string(),
});

/** @internal */
export type TranslationGroupDto$Outbound = {
  resourceId: string;
  resourceType: string;
  resourceName: string;
  locales: Array<string>;
  outdatedLocales?: Array<string> | undefined;
  createdAt: string;
  updatedAt: string;
};

/** @internal */
export const TranslationGroupDto$outboundSchema: z.ZodType<
  TranslationGroupDto$Outbound,
  z.ZodTypeDef,
  TranslationGroupDto
> = z.object({
  resourceId: z.string(),
  resourceType: TranslationGroupDtoResourceType$outboundSchema,
  resourceName: z.string(),
  locales: z.array(z.string()),
  outdatedLocales: z.array(z.string()).optional(),
  createdAt: z.string(),
  updatedAt: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TranslationGroupDto$ {
  /** @deprecated use `TranslationGroupDto$inboundSchema` instead. */
  export const inboundSchema = TranslationGroupDto$inboundSchema;
  /** @deprecated use `TranslationGroupDto$outboundSchema` instead. */
  export const outboundSchema = TranslationGroupDto$outboundSchema;
  /** @deprecated use `TranslationGroupDto$Outbound` instead. */
  export type Outbound = TranslationGroupDto$Outbound;
}

export function translationGroupDtoToJSON(translationGroupDto: TranslationGroupDto): string {
  return JSON.stringify(TranslationGroupDto$outboundSchema.parse(translationGroupDto));
}

export function translationGroupDtoFromJSON(
  jsonString: string
): SafeParseResult<TranslationGroupDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TranslationGroupDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TranslationGroupDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - translationGroupDtoToJSON(translationGroupDto: TranslationGroupDto)
 - translationGroupDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TranslationGroupDto$Outbound;
}

export function translationGroupDtoToJSON(translationGroupDto: Tran...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function translationGroupDtoToJSON
- export function translationGroupDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/translationresponsedto.ts
Tamaño: 5883 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Resource type
 */
export const TranslationResponseDtoResourceType = {
  Workflow: 'workflow',
  Layout: 'layout',
} as const;
/**
 * Resource type
 */
export type TranslationResponseDtoResourceType = ClosedEnum<typeof TranslationResponseDtoResourceType>;

/**
 * Translation content as JSON object
 */
export type TranslationResponseDtoContent = {};

export type TranslationResponseDto = {
  /**
   * Resource identifier
   */
  resourceId: string;
  /**
   * Resource type
   */
  resourceType: TranslationResponseDtoResourceType;
  /**
   * Locale code
   */
  locale: string;
  /**
   * Translation content as JSON object
   */
  content: TranslationResponseDtoContent;
  /**
   * Creation timestamp
   */
  createdAt: string;
  /**
   * Last update timestamp
   */
  updatedAt: string;
};

/** @internal */
export const TranslationResponseDtoResourceType$inboundSchema: z.ZodNativeEnum<
  typeof TranslationResponseDtoResourceType
> = z.nativeEnum(TranslationResponseDtoResourceType);

/** @internal */
export const TranslationResponseDtoResourceType$outboundSchema: z.ZodNativeEnum<
  typeof TranslationResponseDtoResourceType
> = TranslationResponseDtoResourceType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TranslationResponseDtoResourceType$ {
  /** @deprecated use `TranslationResponseDtoResourceType$inboundSchema` instead. */
  export const inboundSchema = TranslationResponseDtoResourceType$inboundSchema;
  /** @deprecated use `TranslationResponseDtoResourceType$outboundSchema` instead. */
  export const outboundSchema = TranslationResponseDtoResourceType$outboundSchema;
}

/** @internal */
export const TranslationResponseDtoContent$inboundSchema: z.ZodType<
  TranslationResponseDtoContent,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type TranslationResponseDtoContent$Outbound = {};

/** @internal */
export const TranslationResponseDtoContent$outboundSchema: z.ZodType<
  TranslationResponseDtoContent$Outbound,
  z.ZodTypeDef,
  TranslationResponseDtoContent
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TranslationResponseDtoContent$ {
  /** @deprecated use `TranslationResponseDtoContent$inboundSchema` instead. */
  export const inboundSchema = TranslationResponseDtoContent$inboundSchema;
  /** @deprecated use `TranslationResponseDtoContent$outboundSchema` instead. */
  export const outboundSchema = TranslationResponseDtoContent$outboundSchema;
  /** @deprecated use `TranslationResponseDtoContent$Outbound` instead. */
  export type Outbound = TranslationResponseDtoContent$Outbound;
}

export function translationResponseDtoContentToJSON(
  translationResponseDtoContent: TranslationResponseDtoContent
): string {
  return JSON.stringify(TranslationResponseDtoContent$outboundSchema.parse(translationResponseDtoContent));
}

export function translationResponseDtoContentFromJSON(
  jsonString: string
): SafeParseResult<TranslationResponseDtoContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TranslationResponseDtoContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TranslationResponseDtoContent' from JSON`
  );
}

/** @internal */
export const TranslationResponseDto$inboundSchema: z.ZodType<TranslationResponseDto, z.ZodTypeDef, unknown> = z.object({
  resourceId: z.string(),
  resourceType: TranslationResponseDtoResourceType$inboundSchema,
  locale: z.string(),
  content: z.lazy(() => TranslationResponseDtoContent$inboundSchema),
  createdAt: z.string(),
  updatedAt: z.string(),
});

/** @internal */
export type TranslationResponseDto$Outbound = {
  resourceId: string;
  resourceType: string;
  locale: string;
  content: TranslationResponseDtoContent$Outbound;
  createdAt: string;
  updatedAt: string;
};

/** @internal */
export const TranslationResponseDto$outboundSchema: z.ZodType<
  TranslationResponseDto$Outbound,
  z.ZodTypeDef,
  TranslationResponseDto
> = z.object({
  resourceId: z.string(),
  resourceType: TranslationResponseDtoResourceType$outboundSchema,
  locale: z.string(),
  content: z.lazy(() => TranslationResponseDtoContent$outboundSchema),
  createdAt: z.string(),
  updatedAt: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TranslationResponseDto$ {
  /** @deprecated use `TranslationResponseDto$inboundSchema` instead. */
  export const inboundSchema = TranslationResponseDto$inboundSchema;
  /** @deprecated use `TranslationResponseDto$outboundSchema` instead. */
  export const outboundSchema = TranslationResponseDto$outboundSchema;
  /** @deprecated use `TranslationResponseDto$Outbound` instead. */
  export type Outbound = TranslationResponseDto$Outbound;
}

export function translationResponseDtoToJSON(translationResponseDto: TranslationResponseDto): string {
  return JSON.stringify(TranslationResponseDto$outboundSchema.parse(translationResponseDto));
}

export function translationResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<TranslationResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TranslationResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TranslationResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - translationResponseDtoContentToJSON(translationResponseDtoContent: TranslationResponseDtoContent)
 - translationResponseDtoContentFromJSON(jsonString: string)
 - translationResponseDtoToJSON(translationResponseDto: TranslationResponseDto)
 - translationResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TranslationResponseDtoContent$Outbound;
}

export function translationResponseDtoContentToJSON(
  tr...)
 - Outbound(TranslationResponseDto$Outbound;
}

export function translationResponseDtoToJSON(translationResponse...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function translationResponseDtoContentToJSON
- export function translationResponseDtoContentFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function translationResponseDtoToJSON
- export function translationResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/triggereventrequestdto.ts
Tamaño: 22077 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  EmailChannelOverrides,
  EmailChannelOverrides$inboundSchema,
  EmailChannelOverrides$Outbound,
  EmailChannelOverrides$outboundSchema,
} from './emailchanneloverrides.js';
import {
  SeverityLevelEnum,
  SeverityLevelEnum$inboundSchema,
  SeverityLevelEnum$outboundSchema,
} from './severitylevelenum.js';
import {
  StepsOverrides,
  StepsOverrides$inboundSchema,
  StepsOverrides$Outbound,
  StepsOverrides$outboundSchema,
} from './stepsoverrides.js';
import {
  SubscriberPayloadDto,
  SubscriberPayloadDto$inboundSchema,
  SubscriberPayloadDto$Outbound,
  SubscriberPayloadDto$outboundSchema,
} from './subscriberpayloaddto.js';
import {
  TenantPayloadDto,
  TenantPayloadDto$inboundSchema,
  TenantPayloadDto$Outbound,
  TenantPayloadDto$outboundSchema,
} from './tenantpayloaddto.js';
import {
  TopicPayloadDto,
  TopicPayloadDto$inboundSchema,
  TopicPayloadDto$Outbound,
  TopicPayloadDto$outboundSchema,
} from './topicpayloaddto.js';

/**
 * Channel-specific overrides that apply to all steps of a particular channel type. Step-level overrides take precedence over channel-level overrides.
 */
export type Channels = {
  /**
   * Email channel specific overrides
   */
  email?: EmailChannelOverrides | undefined;
};

/**
 * This could be used to override provider specific configurations
 */
export type Overrides = {
  /**
   * This could be used to override provider specific configurations or layout at the step level
   */
  steps?: { [k: string]: StepsOverrides } | undefined;
  /**
   * Channel-specific overrides that apply to all steps of a particular channel type. Step-level overrides take precedence over channel-level overrides.
   */
  channels?: Channels | undefined;
  /**
   * Overrides the provider configuration for the entire workflow and all steps
   */
  providers?: { [k: string]: { [k: string]: any } } | undefined;
  /**
   * Override the email provider specific configurations for the entire workflow
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  email?: { [k: string]: any } | undefined;
  /**
   * Override the push provider specific configurations for the entire workflow
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  push?: { [k: string]: any } | undefined;
  /**
   * Override the sms provider specific configurations for the entire workflow
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  sms?: { [k: string]: any } | undefined;
  /**
   * Override the chat provider specific configurations for the entire workflow
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  chat?: { [k: string]: any } | undefined;
  /**
   * Override the layout identifier for the entire workflow
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  layoutIdentifier?: string | undefined;
  /**
   * Severity of the workflow
   */
  severity?: SeverityLevelEnum | undefined;
};

export type To1 = TopicPayloadDto | SubscriberPayloadDto | string;

/**
 * The recipients list of people who will receive the notification.
 */
export type To =
  | TopicPayloadDto
  | SubscriberPayloadDto
  | Array<TopicPayloadDto | SubscriberPayloadDto | string>
  | string;

/**
 * It is used to display the Avatar of the provided actor's subscriber id or actor object.
 *
 * @remarks
 *     If a new actor object is provided, we will create a new subscriber in our system
 */
export type Actor = SubscriberPayloadDto | string;

/**
 * It is used to specify a tenant context during trigger event.
 *
 * @remarks
 *     Existing tenants will be updated with the provided details.
 */
export type Tenant = string | TenantPayloadDto;

/**
 * Rich context object with id and optional data
 */
export type Context2 = {
  id: string;
  /**
   * Optional additional context data
   */
  data?: { [k: string]: any } | undefined;
};

export type TriggerEventRequestDtoContext = Context2 | string;

export type TriggerEventRequestDto = {
  /**
   * The trigger identifier of the workflow you wish to send. This identifier can be found on the workflow page.
   */
  workflowId: string;
  /**
   * The payload object is used to pass additional custom information that could be
   *
   * @remarks
   *     used to render the workflow, or perform routing rules based on it.
   *       This data will also be available when fetching the notifications feed from the API to display certain parts of the UI.
   */
  payload?: { [k: string]: any } | undefined;
  /**
   * This could be used to override provider specific configurations
   */
  overrides?: Overrides | undefined;
  /**
   * The recipients list of people who will receive the notification.
   */
  to: TopicPayloadDto | SubscriberPayloadDto | Array<TopicPayloadDto | SubscriberPayloadDto | string> | string;
  /**
   * A unique identifier for deduplication. If the same **transactionId** is sent again,
   *
   * @remarks
   *       the trigger is ignored. Useful to prevent duplicate notifications. The retention period depends on your billing tier.
   */
  transactionId?: string | undefined;
  /**
   * It is used to display the Avatar of the provided actor's subscriber id or actor object.
   *
   * @remarks
   *     If a new actor object is provided, we will create a new subscriber in our system
   */
  actor?: SubscriberPayloadDto | string | undefined;
  /**
   * It is used to specify a tenant context during trigger event.
   *
   * @remarks
   *     Existing tenants will be updated with the provided details.
   */
  tenant?: string | TenantPayloadDto | undefined;
  context?: { [k: string]: Context2 | string } | undefined;
};

/** @internal */
export const Channels$inboundSchema: z.ZodType<Channels, z.ZodTypeDef, unknown> = z.object({
  email: EmailChannelOverrides$inboundSchema.optional(),
});

/** @internal */
export type Channels$Outbound = {
  email?: EmailChannelOverrides$Outbound | undefined;
};

/** @internal */
export const Channels$outboundSchema: z.ZodType<Channels$Outbound, z.ZodTypeDef, Channels> = z.object({
  email: EmailChannelOverrides$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Channels$ {
  /** @deprecated use `Channels$inboundSchema` instead. */
  export const inboundSchema = Channels$inboundSchema;
  /** @deprecated use `Channels$outboundSchema` instead. */
  export const outboundSchema = Channels$outboundSchema;
  /** @deprecated use `Channels$Outbound` instead. */
  export type Outbound = Channels$Outbound;
}

export function channelsToJSON(channels: Channels): string {
  return JSON.stringify(Channels$outboundSchema.parse(channels));
}

export function channelsFromJSON(jsonString: string): SafeParseResult<Channels, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Channels$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Channels' from JSON`
  );
}

/** @internal */
export const Overrides$inboundSchema: z.ZodType<Overrides, z.ZodTypeDef, unknown> = z.object({
  steps: z.record(StepsOverrides$inboundSchema).optional(),
  channels: z.lazy(() => Channels$inboundSchema).optional(),
  providers: z.record(z.record(z.any())).optional(),
  email: z.record(z.any()).optional(),
  push: z.record(z.any()).optional(),
  sms: z.record(z.any()).optional(),
  chat: z.record(z.any()).optional(),
  layoutIdentifier: z.string().optional(),
  severity: SeverityLevelEnum$inboundSchema.optional(),
});

/** @internal */
export type Overrides$Outbound = {
  steps?: { [k: string]: StepsOverrides$Outbound } | undefined;
  channels?: Channels$Outbound | undefined;
  providers?: { [k: string]: { [k: string]: any } } | undefined;
  email?: { [k: string]: any } | undefined;
  push?: { [k: string]: any } | undefined;
  sms?: { [k: string]: any } | undefined;
  chat?: { [k: string]: any } | undefined;
  layoutIdentifier?: string | undefined;
  severity?: string | undefined;
};

/** @internal */
export const Overrides$outboundSchema: z.ZodType<Overrides$Outbound, z.ZodTypeDef, Overrides> = z.object({
  steps: z.record(StepsOverrides$outboundSchema).optional(),
  channels: z.lazy(() => Channels$outboundSchema).optional(),
  providers: z.record(z.record(z.any())).optional(),
  email: z.record(z.any()).optional(),
  push: z.record(z.any()).optional(),
  sms: z.record(z.any()).optional(),
  chat: z.record(z.any()).optional(),
  layoutIdentifier: z.string().optional(),
  severity: SeverityLevelEnum$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Overrides$ {
  /** @deprecated use `Overrides$inboundSchema` instead. */
  export const inboundSchema = Overrides$inboundSchema;
  /** @deprecated use `Overrides$outboundSchema` instead. */
  export const outboundSchema = Overrides$outboundSchema;
  /** @deprecated use `Overrides$Outbound` instead. */
  export type Outbound = Overrides$Outbound;
}

export function overridesToJSON(overrides: Overrides): string {
  return JSON.stringify(Overrides$outboundSchema.parse(overrides));
}

export function overridesFromJSON(jsonString: string): SafeParseResult<Overrides, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Overrides$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Overrides' from JSON`
  );
}

/** @internal */
export const To1$inboundSchema: z.ZodType<To1, z.ZodTypeDef, unknown> = z.union([
  TopicPayloadDto$inboundSchema,
  SubscriberPayloadDto$inboundSchema,
  z.string(),
]);

/** @internal */
export type To1$Outbound = TopicPayloadDto$Outbound | SubscriberPayloadDto$Outbound | string;

/** @internal */
export const To1$outboundSchema: z.ZodType<To1$Outbound, z.ZodTypeDef, To1> = z.union([
  TopicPayloadDto$outboundSchema,
  SubscriberPayloadDto$outboundSchema,
  z.string(),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace To1$ {
  /** @deprecated use `To1$inboundSchema` instead. */
  export const inboundSchema = To1$inboundSchema;
  /** @deprecated use `To1$outboundSchema` instead. */
  export const outboundSchema = To1$outboundSchema;
  /** @deprecated use `To1$Outbound` instead. */
  export type Outbound = To1$Outbound;
}

export function to1ToJSON(to1: To1): string {
  return JSON.stringify(To1$outboundSchema.parse(to1));
}

export function to1FromJSON(jsonString: string): SafeParseResult<To1, SDKValidationError> {
  return safeParse(jsonString, (x) => To1$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'To1' from JSON`);
}

/** @internal */
export const To$inboundSchema: z.ZodType<To, z.ZodTypeDef, unknown> = z.union([
  TopicPayloadDto$inboundSchema,
  SubscriberPayloadDto$inboundSchema,
  z.array(z.union([TopicPayloadDto$inboundSchema, SubscriberPayloadDto$inboundSchema, z.string()])),
  z.string(),
]);

/** @internal */
export type To$Outbound =
  | TopicPayloadDto$Outbound
  | SubscriberPayloadDto$Outbound
  | Array<TopicPayloadDto$Outbound | SubscriberPayloadDto$Outbound | string>
  | string;

/** @internal */
export const To$outboundSchema: z.ZodType<To$Outbound, z.ZodTypeDef, To> = z.union([
  TopicPayloadDto$outboundSchema,
  SubscriberPayloadDto$outboundSchema,
  z.array(z.union([TopicPayloadDto$outboundSchema, SubscriberPayloadDto$outboundSchema, z.string()])),
  z.string(),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace To$ {
  /** @deprecated use `To$inboundSchema` instead. */
  export const inboundSchema = To$inboundSchema;
  /** @deprecated use `To$outboundSchema` instead. */
  export const outboundSchema = To$outboundSchema;
  /** @deprecated use `To$Outbound` instead. */
  export type Outbound = To$Outbound;
}

export function toToJSON(to: To): string {
  return JSON.stringify(To$outboundSchema.parse(to));
}

export function toFromJSON(jsonString: string): SafeParseResult<To, SDKValidationError> {
  return safeParse(jsonString, (x) => To$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'To' from JSON`);
}

/** @internal */
export const Actor$inboundSchema: z.ZodType<Actor, z.ZodTypeDef, unknown> = z.union([
  SubscriberPayloadDto$inboundSchema,
  z.string(),
]);

/** @internal */
export type Actor$Outbound = SubscriberPayloadDto$Outbound | string;

/** @internal */
export const Actor$outboundSchema: z.ZodType<Actor$Outbound, z.ZodTypeDef, Actor> = z.union([
  SubscriberPayloadDto$outboundSchema,
  z.string(),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Actor$ {
  /** @deprecated use `Actor$inboundSchema` instead. */
  export const inboundSchema = Actor$inboundSchema;
  /** @deprecated use `Actor$outboundSchema` instead. */
  export const outboundSchema = Actor$outboundSchema;
  /** @deprecated use `Actor$Outbound` instead. */
  export type Outbound = Actor$Outbound;
}

export function actorToJSON(actor: Actor): string {
  return JSON.stringify(Actor$outboundSchema.parse(actor));
}

export function actorFromJSON(jsonString: string): SafeParseResult<Actor, SDKValidationError> {
  return safeParse(jsonString, (x) => Actor$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Actor' from JSON`);
}

/** @internal */
export const Tenant$inboundSchema: z.ZodType<Tenant, z.ZodTypeDef, unknown> = z.union([
  z.string(),
  TenantPayloadDto$inboundSchema,
]);

/** @internal */
export type Tenant$Outbound = string | TenantPayloadDto$Outbound;

/** @internal */
export const Tenant$outboundSchema: z.ZodType<Tenant$Outbound, z.ZodTypeDef, Tenant> = z.union([
  z.string(),
  TenantPayloadDto$outboundSchema,
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Tenant$ {
  /** @deprecated use `Tenant$inboundSchema` instead. */
  export const inboundSchema = Tenant$inboundSchema;
  /** @deprecated use `Tenant$outboundSchema` instead. */
  export const outboundSchema = Tenant$outboundSchema;
  /** @deprecated use `Tenant$Outbound` instead. */
  export type Outbound = Tenant$Outbound;
}

export function tenantToJSON(tenant: Tenant): string {
  return JSON.stringify(Tenant$outboundSchema.parse(tenant));
}

export function tenantFromJSON(jsonString: string): SafeParseResult<Tenant, SDKValidationError> {
  return safeParse(jsonString, (x) => Tenant$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Tenant' from JSON`);
}

/** @internal */
export const Context2$inboundSchema: z.ZodType<Context2, z.ZodTypeDef, unknown> = z.object({
  id: z.string(),
  data: z.record(z.any()).optional(),
});

/** @internal */
export type Context2$Outbound = {
  id: string;
  data?: { [k: string]: any } | undefined;
};

/** @internal */
export const Context2$outboundSchema: z.ZodType<Context2$Outbound, z.ZodTypeDef, Context2> = z.object({
  id: z.string(),
  data: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Context2$ {
  /** @deprecated use `Context2$inboundSchema` instead. */
  export const inboundSchema = Context2$inboundSchema;
  /** @deprecated use `Context2$outboundSchema` instead. */
  export const outboundSchema = Context2$outboundSchema;
  /** @deprecated use `Context2$Outbound` instead. */
  export type Outbound = Context2$Outbound;
}

export function context2ToJSON(context2: Context2): string {
  return JSON.stringify(Context2$outboundSchema.parse(context2));
}

export function context2FromJSON(jsonString: string): SafeParseResult<Context2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Context2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Context2' from JSON`
  );
}

/** @internal */
export const TriggerEventRequestDtoContext$inboundSchema: z.ZodType<
  TriggerEventRequestDtoContext,
  z.ZodTypeDef,
  unknown
> = z.union([z.lazy(() => Context2$inboundSchema), z.string()]);

/** @internal */
export type TriggerEventRequestDtoContext$Outbound = Context2$Outbound | string;

/** @internal */
export const TriggerEventRequestDtoContext$outboundSchema: z.ZodType<
  TriggerEventRequestDtoContext$Outbound,
  z.ZodTypeDef,
  TriggerEventRequestDtoContext
> = z.union([z.lazy(() => Context2$outboundSchema), z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TriggerEventRequestDtoContext$ {
  /** @deprecated use `TriggerEventRequestDtoContext$inboundSchema` instead. */
  export const inboundSchema = TriggerEventRequestDtoContext$inboundSchema;
  /** @deprecated use `TriggerEventRequestDtoContext$outboundSchema` instead. */
  export const outboundSchema = TriggerEventRequestDtoContext$outboundSchema;
  /** @deprecated use `TriggerEventRequestDtoContext$Outbound` instead. */
  export type Outbound = TriggerEventRequestDtoContext$Outbound;
}

export function triggerEventRequestDtoContextToJSON(
  triggerEventRequestDtoContext: TriggerEventRequestDtoContext
): string {
  return JSON.stringify(TriggerEventRequestDtoContext$outboundSchema.parse(triggerEventRequestDtoContext));
}

export function triggerEventRequestDtoContextFromJSON(
  jsonString: string
): SafeParseResult<TriggerEventRequestDtoContext, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TriggerEventRequestDtoContext$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TriggerEventRequestDtoContext' from JSON`
  );
}

/** @internal */
export const TriggerEventRequestDto$inboundSchema: z.ZodType<TriggerEventRequestDto, z.ZodTypeDef, unknown> = z
  .object({
    name: z.string(),
    payload: z.record(z.any()).optional(),
    overrides: z.lazy(() => Overrides$inboundSchema).optional(),
    to: z.union([
      TopicPayloadDto$inboundSchema,
      SubscriberPayloadDto$inboundSchema,
      z.array(z.union([TopicPayloadDto$inboundSchema, SubscriberPayloadDto$inboundSchema, z.string()])),
      z.string(),
    ]),
    transactionId: z.string().optional(),
    actor: z.union([SubscriberPayloadDto$inboundSchema, z.string()]).optional(),
    tenant: z.union([z.string(), TenantPayloadDto$inboundSchema]).optional(),
    context: z.record(z.union([z.lazy(() => Context2$inboundSchema), z.string()])).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      name: 'workflowId',
    });
  });

/** @internal */
export type TriggerEventRequestDto$Outbound = {
  name: string;
  payload?: { [k: string]: any } | undefined;
  overrides?: Overrides$Outbound | undefined;
  to:
    | TopicPayloadDto$Outbound
    | SubscriberPayloadDto$Outbound
    | Array<TopicPayloadDto$Outbound | SubscriberPayloadDto$Outbound | string>
    | string;
  transactionId?: string | undefined;
  actor?: SubscriberPayloadDto$Outbound | string | undefined;
  tenant?: string | TenantPayloadDto$Outbound | undefined;
  context?: { [k: string]: Context2$Outbound | string } | undefined;
};

/** @internal */
export const TriggerEventRequestDto$outboundSchema: z.ZodType<
  TriggerEventRequestDto$Outbound,
  z.ZodTypeDef,
  TriggerEventRequestDto
> = z
  .object({
    workflowId: z.string(),
    payload: z.record(z.any()).optional(),
    overrides: z.lazy(() => Overrides$outboundSchema).optional(),
    to: z.union([
      TopicPayloadDto$outboundSchema,
      SubscriberPayloadDto$outboundSchema,
      z.array(z.union([TopicPayloadDto$outboundSchema, SubscriberPayloadDto$outboundSchema, z.string()])),
      z.string(),
    ]),
    transactionId: z.string().optional(),
    actor: z.union([SubscriberPayloadDto$outboundSchema, z.string()]).optional(),
    tenant: z.union([z.string(), TenantPayloadDto$outboundSchema]).optional(),
    context: z.record(z.union([z.lazy(() => Context2$outboundSchema), z.string()])).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      workflowId: 'name',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TriggerEventRequestDto$ {
  /** @deprecated use `TriggerEventRequestDto$inboundSchema` instead. */
  export const inboundSchema = TriggerEventRequestDto$inboundSchema;
  /** @deprecated use `TriggerEventRequestDto$outboundSchema` instead. */
  export const outboundSchema = TriggerEventRequestDto$outboundSchema;
  /** @deprecated use `TriggerEventRequestDto$Outbound` instead. */
  export type Outbound = TriggerEventRequestDto$Outbound;
}

export function triggerEventRequestDtoToJSON(triggerEventRequestDto: TriggerEventRequestDto): string {
  return JSON.stringify(TriggerEventRequestDto$outboundSchema.parse(triggerEventRequestDto));
}

export function triggerEventRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<TriggerEventRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TriggerEventRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TriggerEventRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - channelsToJSON(channels: Channels)
 - channelsFromJSON(jsonString: string)
 - overridesToJSON(overrides: Overrides)
 - overridesFromJSON(jsonString: string)
 - to1ToJSON(to1: To1)
 - to1FromJSON(jsonString: string)
 - toToJSON(to: To)
 - toFromJSON(jsonString: string)
 - actorToJSON(actor: Actor)
 - actorFromJSON(jsonString: string)
 - tenantToJSON(tenant: Tenant)
 - tenantFromJSON(jsonString: string)
 - context2ToJSON(context2: Context2)
 - context2FromJSON(jsonString: string)
 - triggerEventRequestDtoContextToJSON(triggerEventRequestDtoContext: TriggerEventRequestDtoContext)
 - triggerEventRequestDtoContextFromJSON(jsonString: string)
 - triggerEventRequestDtoToJSON(triggerEventRequestDto: TriggerEventRequestDto)
 - triggerEventRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Channels$Outbound;
}

export function channelsToJSON(channels: Channels): string {
  return JSON.str...)
 - Outbound(Overrides$Outbound;
}

export function overridesToJSON(overrides: Overrides): string {
  return JSON...)
 - Outbound(To1$Outbound;
}

export function to1ToJSON(to1: To1): string {
  return JSON.stringify(To1$outboundS...)
 - Outbound(To$Outbound;
}

export function toToJSON(to: To): string {
  return JSON.stringify(To$outboundSchema...)
 - Outbound(Actor$Outbound;
}

export function actorToJSON(actor: Actor): string {
  return JSON.stringify(Actor...)
 - Outbound(Tenant$Outbound;
}

export function tenantToJSON(tenant: Tenant): string {
  return JSON.stringify(T...)
 - Outbound(Context2$Outbound;
}

export function context2ToJSON(context2: Context2): string {
  return JSON.str...)
 - Outbound(TriggerEventRequestDtoContext$Outbound;
}

export function triggerEventRequestDtoContextToJSON(
  tr...)
 - Outbound(TriggerEventRequestDto$Outbound;
}

export function triggerEventRequestDtoToJSON(triggerEventRequest...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function channelsToJSON
- export function channelsFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function overridesToJSON
- export function overridesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function to1ToJSON
- export function to1FromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function toToJSON
- export function toFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function actorToJSON
- export function actorFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function tenantToJSON
- export function tenantFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function context2ToJSON
- export function context2FromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function triggerEventRequestDtoContextToJSON
- export function triggerEventRequestDtoContextFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function triggerEventRequestDtoToJSON
- export function triggerEventRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/triggereventresponsedto.ts
Tamaño: 4156 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Status of the trigger
 */
export const TriggerEventResponseDtoStatus = {
  Error: 'error',
  TriggerNotActive: 'trigger_not_active',
  NoWorkflowActiveStepsDefined: 'no_workflow_active_steps_defined',
  NoWorkflowStepsDefined: 'no_workflow_steps_defined',
  Processed: 'processed',
  NoTenantFound: 'no_tenant_found',
  InvalidRecipients: 'invalid_recipients',
} as const;
/**
 * Status of the trigger
 */
export type TriggerEventResponseDtoStatus = ClosedEnum<typeof TriggerEventResponseDtoStatus>;

export type TriggerEventResponseDto = {
  /**
   * Indicates whether the trigger was acknowledged or not
   */
  acknowledged: boolean;
  /**
   * Status of the trigger
   */
  status: TriggerEventResponseDtoStatus;
  /**
   * In case of an error, this field will contain the error message(s)
   */
  error?: Array<string> | undefined;
  /**
   * The returned transaction ID of the trigger
   */
  transactionId?: string | undefined;
};

/** @internal */
export const TriggerEventResponseDtoStatus$inboundSchema: z.ZodNativeEnum<typeof TriggerEventResponseDtoStatus> =
  z.nativeEnum(TriggerEventResponseDtoStatus);

/** @internal */
export const TriggerEventResponseDtoStatus$outboundSchema: z.ZodNativeEnum<typeof TriggerEventResponseDtoStatus> =
  TriggerEventResponseDtoStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TriggerEventResponseDtoStatus$ {
  /** @deprecated use `TriggerEventResponseDtoStatus$inboundSchema` instead. */
  export const inboundSchema = TriggerEventResponseDtoStatus$inboundSchema;
  /** @deprecated use `TriggerEventResponseDtoStatus$outboundSchema` instead. */
  export const outboundSchema = TriggerEventResponseDtoStatus$outboundSchema;
}

/** @internal */
export const TriggerEventResponseDto$inboundSchema: z.ZodType<TriggerEventResponseDto, z.ZodTypeDef, unknown> =
  z.object({
    acknowledged: z.boolean(),
    status: TriggerEventResponseDtoStatus$inboundSchema,
    error: z.array(z.string()).optional(),
    transactionId: z.string().optional(),
  });

/** @internal */
export type TriggerEventResponseDto$Outbound = {
  acknowledged: boolean;
  status: string;
  error?: Array<string> | undefined;
  transactionId?: string | undefined;
};

/** @internal */
export const TriggerEventResponseDto$outboundSchema: z.ZodType<
  TriggerEventResponseDto$Outbound,
  z.ZodTypeDef,
  TriggerEventResponseDto
> = z.object({
  acknowledged: z.boolean(),
  status: TriggerEventResponseDtoStatus$outboundSchema,
  error: z.array(z.string()).optional(),
  transactionId: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TriggerEventResponseDto$ {
  /** @deprecated use `TriggerEventResponseDto$inboundSchema` instead. */
  export const inboundSchema = TriggerEventResponseDto$inboundSchema;
  /** @deprecated use `TriggerEventResponseDto$outboundSchema` instead. */
  export const outboundSchema = TriggerEventResponseDto$outboundSchema;
  /** @deprecated use `TriggerEventResponseDto$Outbound` instead. */
  export type Outbound = TriggerEventResponseDto$Outbound;
}

export function triggerEventResponseDtoToJSON(triggerEventResponseDto: TriggerEventResponseDto): string {
  return JSON.stringify(TriggerEventResponseDto$outboundSchema.parse(triggerEventResponseDto));
}

export function triggerEventResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<TriggerEventResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TriggerEventResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TriggerEventResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - triggerEventResponseDtoToJSON(triggerEventResponseDto: TriggerEventResponseDto)
 - triggerEventResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TriggerEventResponseDto$Outbound;
}

export function triggerEventResponseDtoToJSON(triggerEventRespo...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function triggerEventResponseDtoToJSON
- export function triggerEventResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/triggereventtoallrequestdto.ts
Tamaño: 17273 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { collectExtraKeys as collectExtraKeys$, safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  EmailChannelOverrides,
  EmailChannelOverrides$inboundSchema,
  EmailChannelOverrides$Outbound,
  EmailChannelOverrides$outboundSchema,
} from './emailchanneloverrides.js';
import {
  SeverityLevelEnum,
  SeverityLevelEnum$inboundSchema,
  SeverityLevelEnum$outboundSchema,
} from './severitylevelenum.js';
import {
  StepsOverrides,
  StepsOverrides$inboundSchema,
  StepsOverrides$Outbound,
  StepsOverrides$outboundSchema,
} from './stepsoverrides.js';
import {
  SubscriberPayloadDto,
  SubscriberPayloadDto$inboundSchema,
  SubscriberPayloadDto$Outbound,
  SubscriberPayloadDto$outboundSchema,
} from './subscriberpayloaddto.js';
import {
  TenantPayloadDto,
  TenantPayloadDto$inboundSchema,
  TenantPayloadDto$Outbound,
  TenantPayloadDto$outboundSchema,
} from './tenantpayloaddto.js';

/**
 * Channel-specific overrides that apply to all steps of a particular channel type. Step-level overrides take precedence over channel-level overrides.
 */
export type TriggerEventToAllRequestDtoChannels = {
  /**
   * Email channel specific overrides
   */
  email?: EmailChannelOverrides | undefined;
};

/**
 * This could be used to override provider specific configurations
 */
export type TriggerEventToAllRequestDtoOverrides = {
  /**
   * This could be used to override provider specific configurations or layout at the step level
   */
  steps?: { [k: string]: StepsOverrides } | undefined;
  /**
   * Channel-specific overrides that apply to all steps of a particular channel type. Step-level overrides take precedence over channel-level overrides.
   */
  channels?: TriggerEventToAllRequestDtoChannels | undefined;
  /**
   * Overrides the provider configuration for the entire workflow and all steps
   */
  providers?: { [k: string]: { [k: string]: any } } | undefined;
  /**
   * Override the email provider specific configurations for the entire workflow
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  email?: { [k: string]: any } | undefined;
  /**
   * Override the push provider specific configurations for the entire workflow
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  push?: { [k: string]: any } | undefined;
  /**
   * Override the sms provider specific configurations for the entire workflow
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  sms?: { [k: string]: any } | undefined;
  /**
   * Override the chat provider specific configurations for the entire workflow
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  chat?: { [k: string]: any } | undefined;
  /**
   * Override the layout identifier for the entire workflow
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  layoutIdentifier?: string | undefined;
  /**
   * Severity of the workflow
   */
  severity?: SeverityLevelEnum | undefined;
  additionalProperties?: { [k: string]: { [k: string]: any } } | undefined;
};

/**
 * It is used to display the Avatar of the provided actor's subscriber id or actor object.
 *
 * @remarks
 *     If a new actor object is provided, we will create a new subscriber in our system
 */
export type TriggerEventToAllRequestDtoActor = SubscriberPayloadDto | string;

/**
 * It is used to specify a tenant context during trigger event.
 *
 * @remarks
 *     If a new tenant object is provided, we will create a new tenant.
 */
export type TriggerEventToAllRequestDtoTenant = string | TenantPayloadDto;

export type TriggerEventToAllRequestDto = {
  /**
   * The trigger identifier associated for the template you wish to send. This identifier can be found on the template page.
   */
  name: string;
  /**
   * The payload object is used to pass additional information that
   *
   * @remarks
   *     could be used to render the template, or perform routing rules based on it.
   *       For In-App channel, payload data are also available in <Inbox />
   */
  payload: { [k: string]: any };
  /**
   * This could be used to override provider specific configurations
   */
  overrides?: TriggerEventToAllRequestDtoOverrides | undefined;
  /**
   * A unique identifier for this transaction, we will generated a UUID if not provided.
   */
  transactionId?: string | undefined;
  /**
   * It is used to display the Avatar of the provided actor's subscriber id or actor object.
   *
   * @remarks
   *     If a new actor object is provided, we will create a new subscriber in our system
   */
  actor?: SubscriberPayloadDto | string | undefined;
  /**
   * It is used to specify a tenant context during trigger event.
   *
   * @remarks
   *     If a new tenant object is provided, we will create a new tenant.
   */
  tenant?: string | TenantPayloadDto | undefined;
};

/** @internal */
export const TriggerEventToAllRequestDtoChannels$inboundSchema: z.ZodType<
  TriggerEventToAllRequestDtoChannels,
  z.ZodTypeDef,
  unknown
> = z.object({
  email: EmailChannelOverrides$inboundSchema.optional(),
});

/** @internal */
export type TriggerEventToAllRequestDtoChannels$Outbound = {
  email?: EmailChannelOverrides$Outbound | undefined;
};

/** @internal */
export const TriggerEventToAllRequestDtoChannels$outboundSchema: z.ZodType<
  TriggerEventToAllRequestDtoChannels$Outbound,
  z.ZodTypeDef,
  TriggerEventToAllRequestDtoChannels
> = z.object({
  email: EmailChannelOverrides$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TriggerEventToAllRequestDtoChannels$ {
  /** @deprecated use `TriggerEventToAllRequestDtoChannels$inboundSchema` instead. */
  export const inboundSchema = TriggerEventToAllRequestDtoChannels$inboundSchema;
  /** @deprecated use `TriggerEventToAllRequestDtoChannels$outboundSchema` instead. */
  export const outboundSchema = TriggerEventToAllRequestDtoChannels$outboundSchema;
  /** @deprecated use `TriggerEventToAllRequestDtoChannels$Outbound` instead. */
  export type Outbound = TriggerEventToAllRequestDtoChannels$Outbound;
}

export function triggerEventToAllRequestDtoChannelsToJSON(
  triggerEventToAllRequestDtoChannels: TriggerEventToAllRequestDtoChannels
): string {
  return JSON.stringify(TriggerEventToAllRequestDtoChannels$outboundSchema.parse(triggerEventToAllRequestDtoChannels));
}

export function triggerEventToAllRequestDtoChannelsFromJSON(
  jsonString: string
): SafeParseResult<TriggerEventToAllRequestDtoChannels, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TriggerEventToAllRequestDtoChannels$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TriggerEventToAllRequestDtoChannels' from JSON`
  );
}

/** @internal */
export const TriggerEventToAllRequestDtoOverrides$inboundSchema: z.ZodType<
  TriggerEventToAllRequestDtoOverrides,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z
    .object({
      steps: z.record(StepsOverrides$inboundSchema).optional(),
      channels: z.lazy(() => TriggerEventToAllRequestDtoChannels$inboundSchema).optional(),
      providers: z.record(z.record(z.any())).optional(),
      email: z.record(z.any()).optional(),
      push: z.record(z.any()).optional(),
      sms: z.record(z.any()).optional(),
      chat: z.record(z.any()).optional(),
      layoutIdentifier: z.string().optional(),
      severity: SeverityLevelEnum$inboundSchema.optional(),
    })
    .catchall(z.record(z.any())),
  'additionalProperties',
  true
);

/** @internal */
export type TriggerEventToAllRequestDtoOverrides$Outbound = {
  steps?: { [k: string]: StepsOverrides$Outbound } | undefined;
  channels?: TriggerEventToAllRequestDtoChannels$Outbound | undefined;
  providers?: { [k: string]: { [k: string]: any } } | undefined;
  email?: { [k: string]: any } | undefined;
  push?: { [k: string]: any } | undefined;
  sms?: { [k: string]: any } | undefined;
  chat?: { [k: string]: any } | undefined;
  layoutIdentifier?: string | undefined;
  severity?: string | undefined;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const TriggerEventToAllRequestDtoOverrides$outboundSchema: z.ZodType<
  TriggerEventToAllRequestDtoOverrides$Outbound,
  z.ZodTypeDef,
  TriggerEventToAllRequestDtoOverrides
> = z
  .object({
    steps: z.record(StepsOverrides$outboundSchema).optional(),
    channels: z.lazy(() => TriggerEventToAllRequestDtoChannels$outboundSchema).optional(),
    providers: z.record(z.record(z.any())).optional(),
    email: z.record(z.any()).optional(),
    push: z.record(z.any()).optional(),
    sms: z.record(z.any()).optional(),
    chat: z.record(z.any()).optional(),
    layoutIdentifier: z.string().optional(),
    severity: SeverityLevelEnum$outboundSchema.optional(),
    additionalProperties: z.record(z.record(z.any())).optional(),
  })
  .transform((v) => {
    return {
      ...v.additionalProperties,
      ...remap$(v, {
        additionalProperties: null,
      }),
    };
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TriggerEventToAllRequestDtoOverrides$ {
  /** @deprecated use `TriggerEventToAllRequestDtoOverrides$inboundSchema` instead. */
  export const inboundSchema = TriggerEventToAllRequestDtoOverrides$inboundSchema;
  /** @deprecated use `TriggerEventToAllRequestDtoOverrides$outboundSchema` instead. */
  export const outboundSchema = TriggerEventToAllRequestDtoOverrides$outboundSchema;
  /** @deprecated use `TriggerEventToAllRequestDtoOverrides$Outbound` instead. */
  export type Outbound = TriggerEventToAllRequestDtoOverrides$Outbound;
}

export function triggerEventToAllRequestDtoOverridesToJSON(
  triggerEventToAllRequestDtoOverrides: TriggerEventToAllRequestDtoOverrides
): string {
  return JSON.stringify(
    TriggerEventToAllRequestDtoOverrides$outboundSchema.parse(triggerEventToAllRequestDtoOverrides)
  );
}

export function triggerEventToAllRequestDtoOverridesFromJSON(
  jsonString: string
): SafeParseResult<TriggerEventToAllRequestDtoOverrides, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TriggerEventToAllRequestDtoOverrides$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TriggerEventToAllRequestDtoOverrides' from JSON`
  );
}

/** @internal */
export const TriggerEventToAllRequestDtoActor$inboundSchema: z.ZodType<
  TriggerEventToAllRequestDtoActor,
  z.ZodTypeDef,
  unknown
> = z.union([SubscriberPayloadDto$inboundSchema, z.string()]);

/** @internal */
export type TriggerEventToAllRequestDtoActor$Outbound = SubscriberPayloadDto$Outbound | string;

/** @internal */
export const TriggerEventToAllRequestDtoActor$outboundSchema: z.ZodType<
  TriggerEventToAllRequestDtoActor$Outbound,
  z.ZodTypeDef,
  TriggerEventToAllRequestDtoActor
> = z.union([SubscriberPayloadDto$outboundSchema, z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TriggerEventToAllRequestDtoActor$ {
  /** @deprecated use `TriggerEventToAllRequestDtoActor$inboundSchema` instead. */
  export const inboundSchema = TriggerEventToAllRequestDtoActor$inboundSchema;
  /** @deprecated use `TriggerEventToAllRequestDtoActor$outboundSchema` instead. */
  export const outboundSchema = TriggerEventToAllRequestDtoActor$outboundSchema;
  /** @deprecated use `TriggerEventToAllRequestDtoActor$Outbound` instead. */
  export type Outbound = TriggerEventToAllRequestDtoActor$Outbound;
}

export function triggerEventToAllRequestDtoActorToJSON(
  triggerEventToAllRequestDtoActor: TriggerEventToAllRequestDtoActor
): string {
  return JSON.stringify(TriggerEventToAllRequestDtoActor$outboundSchema.parse(triggerEventToAllRequestDtoActor));
}

export function triggerEventToAllRequestDtoActorFromJSON(
  jsonString: string
): SafeParseResult<TriggerEventToAllRequestDtoActor, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TriggerEventToAllRequestDtoActor$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TriggerEventToAllRequestDtoActor' from JSON`
  );
}

/** @internal */
export const TriggerEventToAllRequestDtoTenant$inboundSchema: z.ZodType<
  TriggerEventToAllRequestDtoTenant,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), TenantPayloadDto$inboundSchema]);

/** @internal */
export type TriggerEventToAllRequestDtoTenant$Outbound = string | TenantPayloadDto$Outbound;

/** @internal */
export const TriggerEventToAllRequestDtoTenant$outboundSchema: z.ZodType<
  TriggerEventToAllRequestDtoTenant$Outbound,
  z.ZodTypeDef,
  TriggerEventToAllRequestDtoTenant
> = z.union([z.string(), TenantPayloadDto$outboundSchema]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TriggerEventToAllRequestDtoTenant$ {
  /** @deprecated use `TriggerEventToAllRequestDtoTenant$inboundSchema` instead. */
  export const inboundSchema = TriggerEventToAllRequestDtoTenant$inboundSchema;
  /** @deprecated use `TriggerEventToAllRequestDtoTenant$outboundSchema` instead. */
  export const outboundSchema = TriggerEventToAllRequestDtoTenant$outboundSchema;
  /** @deprecated use `TriggerEventToAllRequestDtoTenant$Outbound` instead. */
  export type Outbound = TriggerEventToAllRequestDtoTenant$Outbound;
}

export function triggerEventToAllRequestDtoTenantToJSON(
  triggerEventToAllRequestDtoTenant: TriggerEventToAllRequestDtoTenant
): string {
  return JSON.stringify(TriggerEventToAllRequestDtoTenant$outboundSchema.parse(triggerEventToAllRequestDtoTenant));
}

export function triggerEventToAllRequestDtoTenantFromJSON(
  jsonString: string
): SafeParseResult<TriggerEventToAllRequestDtoTenant, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TriggerEventToAllRequestDtoTenant$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TriggerEventToAllRequestDtoTenant' from JSON`
  );
}

/** @internal */
export const TriggerEventToAllRequestDto$inboundSchema: z.ZodType<TriggerEventToAllRequestDto, z.ZodTypeDef, unknown> =
  z.object({
    name: z.string(),
    payload: z.record(z.any()),
    overrides: z.lazy(() => TriggerEventToAllRequestDtoOverrides$inboundSchema).optional(),
    transactionId: z.string().optional(),
    actor: z.union([SubscriberPayloadDto$inboundSchema, z.string()]).optional(),
    tenant: z.union([z.string(), TenantPayloadDto$inboundSchema]).optional(),
  });

/** @internal */
export type TriggerEventToAllRequestDto$Outbound = {
  name: string;
  payload: { [k: string]: any };
  overrides?: TriggerEventToAllRequestDtoOverrides$Outbound | undefined;
  transactionId?: string | undefined;
  actor?: SubscriberPayloadDto$Outbound | string | undefined;
  tenant?: string | TenantPayloadDto$Outbound | undefined;
};

/** @internal */
export const TriggerEventToAllRequestDto$outboundSchema: z.ZodType<
  TriggerEventToAllRequestDto$Outbound,
  z.ZodTypeDef,
  TriggerEventToAllRequestDto
> = z.object({
  name: z.string(),
  payload: z.record(z.any()),
  overrides: z.lazy(() => TriggerEventToAllRequestDtoOverrides$outboundSchema).optional(),
  transactionId: z.string().optional(),
  actor: z.union([SubscriberPayloadDto$outboundSchema, z.string()]).optional(),
  tenant: z.union([z.string(), TenantPayloadDto$outboundSchema]).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TriggerEventToAllRequestDto$ {
  /** @deprecated use `TriggerEventToAllRequestDto$inboundSchema` instead. */
  export const inboundSchema = TriggerEventToAllRequestDto$inboundSchema;
  /** @deprecated use `TriggerEventToAllRequestDto$outboundSchema` instead. */
  export const outboundSchema = TriggerEventToAllRequestDto$outboundSchema;
  /** @deprecated use `TriggerEventToAllRequestDto$Outbound` instead. */
  export type Outbound = TriggerEventToAllRequestDto$Outbound;
}

export function triggerEventToAllRequestDtoToJSON(triggerEventToAllRequestDto: TriggerEventToAllRequestDto): string {
  return JSON.stringify(TriggerEventToAllRequestDto$outboundSchema.parse(triggerEventToAllRequestDto));
}

export function triggerEventToAllRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<TriggerEventToAllRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TriggerEventToAllRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TriggerEventToAllRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - triggerEventToAllRequestDtoChannelsToJSON(triggerEventToAllRequestDtoChannels: TriggerEventToAllRequestDtoChannels)
 - triggerEventToAllRequestDtoChannelsFromJSON(jsonString: string)
 - triggerEventToAllRequestDtoOverridesToJSON(triggerEventToAllRequestDtoOverrides: TriggerEventToAllRequestDtoOverrides)
 - triggerEventToAllRequestDtoOverridesFromJSON(jsonString: string)
 - triggerEventToAllRequestDtoActorToJSON(triggerEventToAllRequestDtoActor: TriggerEventToAllRequestDtoActor)
 - triggerEventToAllRequestDtoActorFromJSON(jsonString: string)
 - triggerEventToAllRequestDtoTenantToJSON(triggerEventToAllRequestDtoTenant: TriggerEventToAllRequestDtoTenant)
 - triggerEventToAllRequestDtoTenantFromJSON(jsonString: string)
 - triggerEventToAllRequestDtoToJSON(triggerEventToAllRequestDto: TriggerEventToAllRequestDto)
 - triggerEventToAllRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TriggerEventToAllRequestDtoChannels$Outbound;
}

export function triggerEventToAllRequestDtoChannels...)
 - Outbound(TriggerEventToAllRequestDtoOverrides$Outbound;
}

export function triggerEventToAllRequestDtoOverrid...)
 - Outbound(TriggerEventToAllRequestDtoActor$Outbound;
}

export function triggerEventToAllRequestDtoActorToJSON...)
 - Outbound(TriggerEventToAllRequestDtoTenant$Outbound;
}

export function triggerEventToAllRequestDtoTenantToJS...)
 - Outbound(TriggerEventToAllRequestDto$Outbound;
}

export function triggerEventToAllRequestDtoToJSON(triggerEv...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function triggerEventToAllRequestDtoChannelsToJSON
- export function triggerEventToAllRequestDtoChannelsFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function triggerEventToAllRequestDtoOverridesToJSON
- export function triggerEventToAllRequestDtoOverridesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function triggerEventToAllRequestDtoActorToJSON
- export function triggerEventToAllRequestDtoActorFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function triggerEventToAllRequestDtoTenantToJSON
- export function triggerEventToAllRequestDtoTenantFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function triggerEventToAllRequestDtoToJSON
- export function triggerEventToAllRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/triggerrecipientstypeenum.ts
Tamaño: 1182 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

export const TriggerRecipientsTypeEnum = {
  Subscriber: 'Subscriber',
  Topic: 'Topic',
} as const;
export type TriggerRecipientsTypeEnum = ClosedEnum<typeof TriggerRecipientsTypeEnum>;

/** @internal */
export const TriggerRecipientsTypeEnum$inboundSchema: z.ZodNativeEnum<typeof TriggerRecipientsTypeEnum> =
  z.nativeEnum(TriggerRecipientsTypeEnum);

/** @internal */
export const TriggerRecipientsTypeEnum$outboundSchema: z.ZodNativeEnum<typeof TriggerRecipientsTypeEnum> =
  TriggerRecipientsTypeEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TriggerRecipientsTypeEnum$ {
  /** @deprecated use `TriggerRecipientsTypeEnum$inboundSchema` instead. */
  export const inboundSchema = TriggerRecipientsTypeEnum$inboundSchema;
  /** @deprecated use `TriggerRecipientsTypeEnum$outboundSchema` instead. */
  export const outboundSchema = TriggerRecipientsTypeEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/uicomponentenum.ts
Tamaño: 2373 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Component type for the UI Schema Property
 */
export const UiComponentEnum = {
  EmailEditorSelect: 'EMAIL_EDITOR_SELECT',
  LayoutSelect: 'LAYOUT_SELECT',
  BlockEditor: 'BLOCK_EDITOR',
  EmailBody: 'EMAIL_BODY',
  TextFullLine: 'TEXT_FULL_LINE',
  TextInlineLabel: 'TEXT_INLINE_LABEL',
  InAppBody: 'IN_APP_BODY',
  InAppAvatar: 'IN_APP_AVATAR',
  InAppPrimarySubject: 'IN_APP_PRIMARY_SUBJECT',
  InAppButtonDropdown: 'IN_APP_BUTTON_DROPDOWN',
  InAppDisableSanitizationSwitch: 'IN_APP_DISABLE_SANITIZATION_SWITCH',
  DisableSanitizationSwitch: 'DISABLE_SANITIZATION_SWITCH',
  UrlTextBox: 'URL_TEXT_BOX',
  DigestAmount: 'DIGEST_AMOUNT',
  DigestUnit: 'DIGEST_UNIT',
  DigestType: 'DIGEST_TYPE',
  DigestKey: 'DIGEST_KEY',
  DigestCron: 'DIGEST_CRON',
  DelayAmount: 'DELAY_AMOUNT',
  DelayUnit: 'DELAY_UNIT',
  DelayType: 'DELAY_TYPE',
  DelayCron: 'DELAY_CRON',
  DelayDynamicKey: 'DELAY_DYNAMIC_KEY',
  ThrottleType: 'THROTTLE_TYPE',
  ThrottleWindow: 'THROTTLE_WINDOW',
  ThrottleUnit: 'THROTTLE_UNIT',
  ThrottleDynamicKey: 'THROTTLE_DYNAMIC_KEY',
  ThrottleThreshold: 'THROTTLE_THRESHOLD',
  ThrottleKey: 'THROTTLE_KEY',
  ExtendToSchedule: 'EXTEND_TO_SCHEDULE',
  SmsBody: 'SMS_BODY',
  ChatBody: 'CHAT_BODY',
  PushBody: 'PUSH_BODY',
  PushSubject: 'PUSH_SUBJECT',
  QueryEditor: 'QUERY_EDITOR',
  Data: 'DATA',
  LayoutEmail: 'LAYOUT_EMAIL',
} as const;
/**
 * Component type for the UI Schema Property
 */
export type UiComponentEnum = ClosedEnum<typeof UiComponentEnum>;

/** @internal */
export const UiComponentEnum$inboundSchema: z.ZodNativeEnum<typeof UiComponentEnum> = z.nativeEnum(UiComponentEnum);

/** @internal */
export const UiComponentEnum$outboundSchema: z.ZodNativeEnum<typeof UiComponentEnum> = UiComponentEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UiComponentEnum$ {
  /** @deprecated use `UiComponentEnum$inboundSchema` instead. */
  export const inboundSchema = UiComponentEnum$inboundSchema;
  /** @deprecated use `UiComponentEnum$outboundSchema` instead. */
  export const outboundSchema = UiComponentEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/uischema.ts
Tamaño: 2328 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  UiSchemaGroupEnum,
  UiSchemaGroupEnum$inboundSchema,
  UiSchemaGroupEnum$outboundSchema,
} from './uischemagroupenum.js';
import {
  UiSchemaProperty,
  UiSchemaProperty$inboundSchema,
  UiSchemaProperty$Outbound,
  UiSchemaProperty$outboundSchema,
} from './uischemaproperty.js';

export type UiSchema = {
  /**
   * Group of the UI Schema
   */
  group?: UiSchemaGroupEnum | undefined;
  /**
   * Properties of the UI Schema
   */
  properties?: { [k: string]: UiSchemaProperty } | undefined;
};

/** @internal */
export const UiSchema$inboundSchema: z.ZodType<UiSchema, z.ZodTypeDef, unknown> = z.object({
  group: UiSchemaGroupEnum$inboundSchema.optional(),
  properties: z.record(UiSchemaProperty$inboundSchema).optional(),
});

/** @internal */
export type UiSchema$Outbound = {
  group?: string | undefined;
  properties?: { [k: string]: UiSchemaProperty$Outbound } | undefined;
};

/** @internal */
export const UiSchema$outboundSchema: z.ZodType<UiSchema$Outbound, z.ZodTypeDef, UiSchema> = z.object({
  group: UiSchemaGroupEnum$outboundSchema.optional(),
  properties: z.record(UiSchemaProperty$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UiSchema$ {
  /** @deprecated use `UiSchema$inboundSchema` instead. */
  export const inboundSchema = UiSchema$inboundSchema;
  /** @deprecated use `UiSchema$outboundSchema` instead. */
  export const outboundSchema = UiSchema$outboundSchema;
  /** @deprecated use `UiSchema$Outbound` instead. */
  export type Outbound = UiSchema$Outbound;
}

export function uiSchemaToJSON(uiSchema: UiSchema): string {
  return JSON.stringify(UiSchema$outboundSchema.parse(uiSchema));
}

export function uiSchemaFromJSON(jsonString: string): SafeParseResult<UiSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UiSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UiSchema' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - uiSchemaToJSON(uiSchema: UiSchema)
 - uiSchemaFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(UiSchema$Outbound;
}

export function uiSchemaToJSON(uiSchema: UiSchema): string {
  return JSON.str...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function uiSchemaToJSON
- export function uiSchemaFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/uischemagroupenum.ts
Tamaño: 1273 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Group of the UI Schema
 */
export const UiSchemaGroupEnum = {
  InApp: 'IN_APP',
  Email: 'EMAIL',
  Digest: 'DIGEST',
  Delay: 'DELAY',
  Throttle: 'THROTTLE',
  Sms: 'SMS',
  Chat: 'CHAT',
  Push: 'PUSH',
  Skip: 'SKIP',
  Layout: 'LAYOUT',
} as const;
/**
 * Group of the UI Schema
 */
export type UiSchemaGroupEnum = ClosedEnum<typeof UiSchemaGroupEnum>;

/** @internal */
export const UiSchemaGroupEnum$inboundSchema: z.ZodNativeEnum<typeof UiSchemaGroupEnum> =
  z.nativeEnum(UiSchemaGroupEnum);

/** @internal */
export const UiSchemaGroupEnum$outboundSchema: z.ZodNativeEnum<typeof UiSchemaGroupEnum> =
  UiSchemaGroupEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UiSchemaGroupEnum$ {
  /** @deprecated use `UiSchemaGroupEnum$inboundSchema` instead. */
  export const inboundSchema = UiSchemaGroupEnum$inboundSchema;
  /** @deprecated use `UiSchemaGroupEnum$outboundSchema` instead. */
  export const outboundSchema = UiSchemaGroupEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/uischemaproperty.ts
Tamaño: 6684 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import { UiComponentEnum, UiComponentEnum$inboundSchema, UiComponentEnum$outboundSchema } from './uicomponentenum.js';

export type Placeholder5 = string | number | boolean | { [k: string]: any };

/**
 * Placeholder for the UI Schema Property
 */
export type Placeholder =
  | string
  | number
  | boolean
  | { [k: string]: any }
  | Array<string | number | boolean | { [k: string]: any }>;

export type UiSchemaProperty = {
  /**
   * Placeholder for the UI Schema Property
   */
  placeholder?:
    | string
    | number
    | boolean
    | { [k: string]: any }
    | Array<string | number | boolean | { [k: string]: any }>
    | null
    | undefined;
  /**
   * Component type for the UI Schema Property
   */
  component: UiComponentEnum;
  /**
   * Properties of the UI Schema
   */
  properties?: { [k: string]: UiSchemaProperty } | undefined;
};

/** @internal */
export const Placeholder5$inboundSchema: z.ZodType<Placeholder5, z.ZodTypeDef, unknown> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.record(z.any()),
]);

/** @internal */
export type Placeholder5$Outbound =
  | string
  | number
  | boolean
  | {
      [k: string]: any;
    };

/** @internal */
export const Placeholder5$outboundSchema: z.ZodType<Placeholder5$Outbound, z.ZodTypeDef, Placeholder5> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.record(z.any()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Placeholder5$ {
  /** @deprecated use `Placeholder5$inboundSchema` instead. */
  export const inboundSchema = Placeholder5$inboundSchema;
  /** @deprecated use `Placeholder5$outboundSchema` instead. */
  export const outboundSchema = Placeholder5$outboundSchema;
  /** @deprecated use `Placeholder5$Outbound` instead. */
  export type Outbound = Placeholder5$Outbound;
}

export function placeholder5ToJSON(placeholder5: Placeholder5): string {
  return JSON.stringify(Placeholder5$outboundSchema.parse(placeholder5));
}

export function placeholder5FromJSON(jsonString: string): SafeParseResult<Placeholder5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Placeholder5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Placeholder5' from JSON`
  );
}

/** @internal */
export const Placeholder$inboundSchema: z.ZodType<Placeholder, z.ZodTypeDef, unknown> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.record(z.any()),
  z.array(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())])),
]);

/** @internal */
export type Placeholder$Outbound =
  | string
  | number
  | boolean
  | {
      [k: string]: any;
    }
  | Array<string | number | boolean | { [k: string]: any }>;

/** @internal */
export const Placeholder$outboundSchema: z.ZodType<Placeholder$Outbound, z.ZodTypeDef, Placeholder> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.record(z.any()),
  z.array(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())])),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Placeholder$ {
  /** @deprecated use `Placeholder$inboundSchema` instead. */
  export const inboundSchema = Placeholder$inboundSchema;
  /** @deprecated use `Placeholder$outboundSchema` instead. */
  export const outboundSchema = Placeholder$outboundSchema;
  /** @deprecated use `Placeholder$Outbound` instead. */
  export type Outbound = Placeholder$Outbound;
}

export function placeholderToJSON(placeholder: Placeholder): string {
  return JSON.stringify(Placeholder$outboundSchema.parse(placeholder));
}

export function placeholderFromJSON(jsonString: string): SafeParseResult<Placeholder, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Placeholder$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Placeholder' from JSON`
  );
}

/** @internal */
export const UiSchemaProperty$inboundSchema: z.ZodType<UiSchemaProperty, z.ZodTypeDef, unknown> = z.object({
  placeholder: z
    .nullable(
      z.union([
        z.string(),
        z.number(),
        z.boolean(),
        z.record(z.any()),
        z.array(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())])),
      ])
    )
    .optional(),
  component: UiComponentEnum$inboundSchema,
  properties: z.record(z.lazy(() => UiSchemaProperty$inboundSchema)).optional(),
});

/** @internal */
export type UiSchemaProperty$Outbound = {
  placeholder?:
    | string
    | number
    | boolean
    | { [k: string]: any }
    | Array<string | number | boolean | { [k: string]: any }>
    | null
    | undefined;
  component: string;
  properties?: { [k: string]: UiSchemaProperty$Outbound } | undefined;
};

/** @internal */
export const UiSchemaProperty$outboundSchema: z.ZodType<UiSchemaProperty$Outbound, z.ZodTypeDef, UiSchemaProperty> =
  z.object({
    placeholder: z
      .nullable(
        z.union([
          z.string(),
          z.number(),
          z.boolean(),
          z.record(z.any()),
          z.array(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())])),
        ])
      )
      .optional(),
    component: UiComponentEnum$outboundSchema,
    properties: z.record(z.lazy(() => UiSchemaProperty$outboundSchema)).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UiSchemaProperty$ {
  /** @deprecated use `UiSchemaProperty$inboundSchema` instead. */
  export const inboundSchema = UiSchemaProperty$inboundSchema;
  /** @deprecated use `UiSchemaProperty$outboundSchema` instead. */
  export const outboundSchema = UiSchemaProperty$outboundSchema;
  /** @deprecated use `UiSchemaProperty$Outbound` instead. */
  export type Outbound = UiSchemaProperty$Outbound;
}

export function uiSchemaPropertyToJSON(uiSchemaProperty: UiSchemaProperty): string {
  return JSON.stringify(UiSchemaProperty$outboundSchema.parse(uiSchemaProperty));
}

export function uiSchemaPropertyFromJSON(jsonString: string): SafeParseResult<UiSchemaProperty, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UiSchemaProperty$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UiSchemaProperty' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - placeholder5ToJSON(placeholder5: Placeholder5)
 - placeholder5FromJSON(jsonString: string)
 - placeholderToJSON(placeholder: Placeholder)
 - placeholderFromJSON(jsonString: string)
 - uiSchemaPropertyToJSON(uiSchemaProperty: UiSchemaProperty)
 - uiSchemaPropertyFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Placeholder5$Outbound;
}

export function placeholder5ToJSON(placeholder5: Placeholder5): string {
 ...)
 - Outbound(Placeholder$Outbound;
}

export function placeholderToJSON(placeholder: Placeholder): string {
  ret...)
 - Outbound(UiSchemaProperty$Outbound;
}

export function uiSchemaPropertyToJSON(uiSchemaProperty: UiSchemaPrope...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function placeholder5ToJSON
- export function placeholder5FromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function placeholderToJSON
- export function placeholderFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function uiSchemaPropertyToJSON
- export function uiSchemaPropertyFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/unseencountresponse.ts
Tamaño: 1845 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type UnseenCountResponse = {
  count: number;
};

/** @internal */
export const UnseenCountResponse$inboundSchema: z.ZodType<UnseenCountResponse, z.ZodTypeDef, unknown> = z.object({
  count: z.number(),
});

/** @internal */
export type UnseenCountResponse$Outbound = {
  count: number;
};

/** @internal */
export const UnseenCountResponse$outboundSchema: z.ZodType<
  UnseenCountResponse$Outbound,
  z.ZodTypeDef,
  UnseenCountResponse
> = z.object({
  count: z.number(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UnseenCountResponse$ {
  /** @deprecated use `UnseenCountResponse$inboundSchema` instead. */
  export const inboundSchema = UnseenCountResponse$inboundSchema;
  /** @deprecated use `UnseenCountResponse$outboundSchema` instead. */
  export const outboundSchema = UnseenCountResponse$outboundSchema;
  /** @deprecated use `UnseenCountResponse$Outbound` instead. */
  export type Outbound = UnseenCountResponse$Outbound;
}

export function unseenCountResponseToJSON(unseenCountResponse: UnseenCountResponse): string {
  return JSON.stringify(UnseenCountResponse$outboundSchema.parse(unseenCountResponse));
}

export function unseenCountResponseFromJSON(
  jsonString: string
): SafeParseResult<UnseenCountResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UnseenCountResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UnseenCountResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - unseenCountResponseToJSON(unseenCountResponse: UnseenCountResponse)
 - unseenCountResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(UnseenCountResponse$Outbound;
}

export function unseenCountResponseToJSON(unseenCountResponse: Unse...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function unseenCountResponseToJSON
- export function unseenCountResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/updatecontextrequestdto.ts
Tamaño: 3907 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Custom data to associate with this context. Replaces existing data.
 */
export type UpdateContextRequestDtoData = {};

export type UpdateContextRequestDto = {
  /**
   * Custom data to associate with this context. Replaces existing data.
   */
  data: UpdateContextRequestDtoData;
};

/** @internal */
export const UpdateContextRequestDtoData$inboundSchema: z.ZodType<UpdateContextRequestDtoData, z.ZodTypeDef, unknown> =
  z.object({});

/** @internal */
export type UpdateContextRequestDtoData$Outbound = {};

/** @internal */
export const UpdateContextRequestDtoData$outboundSchema: z.ZodType<
  UpdateContextRequestDtoData$Outbound,
  z.ZodTypeDef,
  UpdateContextRequestDtoData
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateContextRequestDtoData$ {
  /** @deprecated use `UpdateContextRequestDtoData$inboundSchema` instead. */
  export const inboundSchema = UpdateContextRequestDtoData$inboundSchema;
  /** @deprecated use `UpdateContextRequestDtoData$outboundSchema` instead. */
  export const outboundSchema = UpdateContextRequestDtoData$outboundSchema;
  /** @deprecated use `UpdateContextRequestDtoData$Outbound` instead. */
  export type Outbound = UpdateContextRequestDtoData$Outbound;
}

export function updateContextRequestDtoDataToJSON(updateContextRequestDtoData: UpdateContextRequestDtoData): string {
  return JSON.stringify(UpdateContextRequestDtoData$outboundSchema.parse(updateContextRequestDtoData));
}

export function updateContextRequestDtoDataFromJSON(
  jsonString: string
): SafeParseResult<UpdateContextRequestDtoData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateContextRequestDtoData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateContextRequestDtoData' from JSON`
  );
}

/** @internal */
export const UpdateContextRequestDto$inboundSchema: z.ZodType<UpdateContextRequestDto, z.ZodTypeDef, unknown> =
  z.object({
    data: z.lazy(() => UpdateContextRequestDtoData$inboundSchema),
  });

/** @internal */
export type UpdateContextRequestDto$Outbound = {
  data: UpdateContextRequestDtoData$Outbound;
};

/** @internal */
export const UpdateContextRequestDto$outboundSchema: z.ZodType<
  UpdateContextRequestDto$Outbound,
  z.ZodTypeDef,
  UpdateContextRequestDto
> = z.object({
  data: z.lazy(() => UpdateContextRequestDtoData$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateContextRequestDto$ {
  /** @deprecated use `UpdateContextRequestDto$inboundSchema` instead. */
  export const inboundSchema = UpdateContextRequestDto$inboundSchema;
  /** @deprecated use `UpdateContextRequestDto$outboundSchema` instead. */
  export const outboundSchema = UpdateContextRequestDto$outboundSchema;
  /** @deprecated use `UpdateContextRequestDto$Outbound` instead. */
  export type Outbound = UpdateContextRequestDto$Outbound;
}

export function updateContextRequestDtoToJSON(updateContextRequestDto: UpdateContextRequestDto): string {
  return JSON.stringify(UpdateContextRequestDto$outboundSchema.parse(updateContextRequestDto));
}

export function updateContextRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<UpdateContextRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateContextRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateContextRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - updateContextRequestDtoDataToJSON(updateContextRequestDtoData: UpdateContextRequestDtoData)
 - updateContextRequestDtoDataFromJSON(jsonString: string)
 - updateContextRequestDtoToJSON(updateContextRequestDto: UpdateContextRequestDto)
 - updateContextRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(UpdateContextRequestDtoData$Outbound;
}

export function updateContextRequestDtoDataToJSON(updateCon...)
 - Outbound(UpdateContextRequestDto$Outbound;
}

export function updateContextRequestDtoToJSON(updateContextRequ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function updateContextRequestDtoDataToJSON
- export function updateContextRequestDtoDataFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function updateContextRequestDtoToJSON
- export function updateContextRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/updatedsubscriberdto.ts
Tamaño: 1956 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type UpdatedSubscriberDto = {
  /**
   * The ID of the subscriber that was updated.
   */
  subscriberId: string;
};

/** @internal */
export const UpdatedSubscriberDto$inboundSchema: z.ZodType<UpdatedSubscriberDto, z.ZodTypeDef, unknown> = z.object({
  subscriberId: z.string(),
});

/** @internal */
export type UpdatedSubscriberDto$Outbound = {
  subscriberId: string;
};

/** @internal */
export const UpdatedSubscriberDto$outboundSchema: z.ZodType<
  UpdatedSubscriberDto$Outbound,
  z.ZodTypeDef,
  UpdatedSubscriberDto
> = z.object({
  subscriberId: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdatedSubscriberDto$ {
  /** @deprecated use `UpdatedSubscriberDto$inboundSchema` instead. */
  export const inboundSchema = UpdatedSubscriberDto$inboundSchema;
  /** @deprecated use `UpdatedSubscriberDto$outboundSchema` instead. */
  export const outboundSchema = UpdatedSubscriberDto$outboundSchema;
  /** @deprecated use `UpdatedSubscriberDto$Outbound` instead. */
  export type Outbound = UpdatedSubscriberDto$Outbound;
}

export function updatedSubscriberDtoToJSON(updatedSubscriberDto: UpdatedSubscriberDto): string {
  return JSON.stringify(UpdatedSubscriberDto$outboundSchema.parse(updatedSubscriberDto));
}

export function updatedSubscriberDtoFromJSON(
  jsonString: string
): SafeParseResult<UpdatedSubscriberDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatedSubscriberDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatedSubscriberDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - updatedSubscriberDtoToJSON(updatedSubscriberDto: UpdatedSubscriberDto)
 - updatedSubscriberDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(UpdatedSubscriberDto$Outbound;
}

export function updatedSubscriberDtoToJSON(updatedSubscriberDto: U...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function updatedSubscriberDtoToJSON
- export function updatedSubscriberDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/updateenvironmentrequestdto.ts
Tamaño: 3294 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  BridgeConfigurationDto,
  BridgeConfigurationDto$inboundSchema,
  BridgeConfigurationDto$Outbound,
  BridgeConfigurationDto$outboundSchema,
} from './bridgeconfigurationdto.js';
import {
  InBoundParseDomainDto,
  InBoundParseDomainDto$inboundSchema,
  InBoundParseDomainDto$Outbound,
  InBoundParseDomainDto$outboundSchema,
} from './inboundparsedomaindto.js';

export type UpdateEnvironmentRequestDto = {
  name?: string | undefined;
  identifier?: string | undefined;
  parentId?: string | undefined;
  color?: string | undefined;
  dns?: InBoundParseDomainDto | undefined;
  bridge?: BridgeConfigurationDto | undefined;
};

/** @internal */
export const UpdateEnvironmentRequestDto$inboundSchema: z.ZodType<UpdateEnvironmentRequestDto, z.ZodTypeDef, unknown> =
  z.object({
    name: z.string().optional(),
    identifier: z.string().optional(),
    parentId: z.string().optional(),
    color: z.string().optional(),
    dns: InBoundParseDomainDto$inboundSchema.optional(),
    bridge: BridgeConfigurationDto$inboundSchema.optional(),
  });

/** @internal */
export type UpdateEnvironmentRequestDto$Outbound = {
  name?: string | undefined;
  identifier?: string | undefined;
  parentId?: string | undefined;
  color?: string | undefined;
  dns?: InBoundParseDomainDto$Outbound | undefined;
  bridge?: BridgeConfigurationDto$Outbound | undefined;
};

/** @internal */
export const UpdateEnvironmentRequestDto$outboundSchema: z.ZodType<
  UpdateEnvironmentRequestDto$Outbound,
  z.ZodTypeDef,
  UpdateEnvironmentRequestDto
> = z.object({
  name: z.string().optional(),
  identifier: z.string().optional(),
  parentId: z.string().optional(),
  color: z.string().optional(),
  dns: InBoundParseDomainDto$outboundSchema.optional(),
  bridge: BridgeConfigurationDto$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateEnvironmentRequestDto$ {
  /** @deprecated use `UpdateEnvironmentRequestDto$inboundSchema` instead. */
  export const inboundSchema = UpdateEnvironmentRequestDto$inboundSchema;
  /** @deprecated use `UpdateEnvironmentRequestDto$outboundSchema` instead. */
  export const outboundSchema = UpdateEnvironmentRequestDto$outboundSchema;
  /** @deprecated use `UpdateEnvironmentRequestDto$Outbound` instead. */
  export type Outbound = UpdateEnvironmentRequestDto$Outbound;
}

export function updateEnvironmentRequestDtoToJSON(updateEnvironmentRequestDto: UpdateEnvironmentRequestDto): string {
  return JSON.stringify(UpdateEnvironmentRequestDto$outboundSchema.parse(updateEnvironmentRequestDto));
}

export function updateEnvironmentRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<UpdateEnvironmentRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateEnvironmentRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateEnvironmentRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - updateEnvironmentRequestDtoToJSON(updateEnvironmentRequestDto: UpdateEnvironmentRequestDto)
 - updateEnvironmentRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(UpdateEnvironmentRequestDto$Outbound;
}

export function updateEnvironmentRequestDtoToJSON(updateEnv...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function updateEnvironmentRequestDtoToJSON
- export function updateEnvironmentRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/updateintegrationrequestdto.ts
Tamaño: 6252 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  CredentialsDto,
  CredentialsDto$inboundSchema,
  CredentialsDto$Outbound,
  CredentialsDto$outboundSchema,
} from './credentialsdto.js';
import {
  StepFilterDto,
  StepFilterDto$inboundSchema,
  StepFilterDto$Outbound,
  StepFilterDto$outboundSchema,
} from './stepfilterdto.js';

/**
 * Configurations for the integration
 */
export type UpdateIntegrationRequestDtoConfigurations = {};

export type UpdateIntegrationRequestDto = {
  name?: string | undefined;
  identifier?: string | undefined;
  environmentId?: string | undefined;
  /**
   * If the integration is active the validation on the credentials field will run
   */
  active?: boolean | undefined;
  credentials?: CredentialsDto | undefined;
  check?: boolean | undefined;
  conditions?: Array<StepFilterDto> | undefined;
  /**
   * Configurations for the integration
   */
  configurations?: UpdateIntegrationRequestDtoConfigurations | undefined;
};

/** @internal */
export const UpdateIntegrationRequestDtoConfigurations$inboundSchema: z.ZodType<
  UpdateIntegrationRequestDtoConfigurations,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type UpdateIntegrationRequestDtoConfigurations$Outbound = {};

/** @internal */
export const UpdateIntegrationRequestDtoConfigurations$outboundSchema: z.ZodType<
  UpdateIntegrationRequestDtoConfigurations$Outbound,
  z.ZodTypeDef,
  UpdateIntegrationRequestDtoConfigurations
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateIntegrationRequestDtoConfigurations$ {
  /** @deprecated use `UpdateIntegrationRequestDtoConfigurations$inboundSchema` instead. */
  export const inboundSchema = UpdateIntegrationRequestDtoConfigurations$inboundSchema;
  /** @deprecated use `UpdateIntegrationRequestDtoConfigurations$outboundSchema` instead. */
  export const outboundSchema = UpdateIntegrationRequestDtoConfigurations$outboundSchema;
  /** @deprecated use `UpdateIntegrationRequestDtoConfigurations$Outbound` instead. */
  export type Outbound = UpdateIntegrationRequestDtoConfigurations$Outbound;
}

export function updateIntegrationRequestDtoConfigurationsToJSON(
  updateIntegrationRequestDtoConfigurations: UpdateIntegrationRequestDtoConfigurations
): string {
  return JSON.stringify(
    UpdateIntegrationRequestDtoConfigurations$outboundSchema.parse(updateIntegrationRequestDtoConfigurations)
  );
}

export function updateIntegrationRequestDtoConfigurationsFromJSON(
  jsonString: string
): SafeParseResult<UpdateIntegrationRequestDtoConfigurations, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateIntegrationRequestDtoConfigurations$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateIntegrationRequestDtoConfigurations' from JSON`
  );
}

/** @internal */
export const UpdateIntegrationRequestDto$inboundSchema: z.ZodType<UpdateIntegrationRequestDto, z.ZodTypeDef, unknown> =
  z
    .object({
      name: z.string().optional(),
      identifier: z.string().optional(),
      _environmentId: z.string().optional(),
      active: z.boolean().optional(),
      credentials: CredentialsDto$inboundSchema.optional(),
      check: z.boolean().optional(),
      conditions: z.array(StepFilterDto$inboundSchema).optional(),
      configurations: z.lazy(() => UpdateIntegrationRequestDtoConfigurations$inboundSchema).optional(),
    })
    .transform((v) => {
      return remap$(v, {
        _environmentId: 'environmentId',
      });
    });

/** @internal */
export type UpdateIntegrationRequestDto$Outbound = {
  name?: string | undefined;
  identifier?: string | undefined;
  _environmentId?: string | undefined;
  active?: boolean | undefined;
  credentials?: CredentialsDto$Outbound | undefined;
  check?: boolean | undefined;
  conditions?: Array<StepFilterDto$Outbound> | undefined;
  configurations?: UpdateIntegrationRequestDtoConfigurations$Outbound | undefined;
};

/** @internal */
export const UpdateIntegrationRequestDto$outboundSchema: z.ZodType<
  UpdateIntegrationRequestDto$Outbound,
  z.ZodTypeDef,
  UpdateIntegrationRequestDto
> = z
  .object({
    name: z.string().optional(),
    identifier: z.string().optional(),
    environmentId: z.string().optional(),
    active: z.boolean().optional(),
    credentials: CredentialsDto$outboundSchema.optional(),
    check: z.boolean().optional(),
    conditions: z.array(StepFilterDto$outboundSchema).optional(),
    configurations: z.lazy(() => UpdateIntegrationRequestDtoConfigurations$outboundSchema).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      environmentId: '_environmentId',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateIntegrationRequestDto$ {
  /** @deprecated use `UpdateIntegrationRequestDto$inboundSchema` instead. */
  export const inboundSchema = UpdateIntegrationRequestDto$inboundSchema;
  /** @deprecated use `UpdateIntegrationRequestDto$outboundSchema` instead. */
  export const outboundSchema = UpdateIntegrationRequestDto$outboundSchema;
  /** @deprecated use `UpdateIntegrationRequestDto$Outbound` instead. */
  export type Outbound = UpdateIntegrationRequestDto$Outbound;
}

export function updateIntegrationRequestDtoToJSON(updateIntegrationRequestDto: UpdateIntegrationRequestDto): string {
  return JSON.stringify(UpdateIntegrationRequestDto$outboundSchema.parse(updateIntegrationRequestDto));
}

export function updateIntegrationRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<UpdateIntegrationRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateIntegrationRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateIntegrationRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - updateIntegrationRequestDtoConfigurationsToJSON(updateIntegrationRequestDtoConfigurations: UpdateIntegrationRequestDtoConfigurations)
 - updateIntegrationRequestDtoConfigurationsFromJSON(jsonString: string)
 - updateIntegrationRequestDtoToJSON(updateIntegrationRequestDto: UpdateIntegrationRequestDto)
 - updateIntegrationRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(UpdateIntegrationRequestDtoConfigurations$Outbound;
}

export function updateIntegrationRequestDtoCo...)
 - Outbound(UpdateIntegrationRequestDto$Outbound;
}

export function updateIntegrationRequestDtoToJSON(updateInt...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function updateIntegrationRequestDtoConfigurationsToJSON
- export function updateIntegrationRequestDtoConfigurationsFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function updateIntegrationRequestDtoToJSON
- export function updateIntegrationRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/updatelayoutdto.ts
Tamaño: 4120 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  EmailControlsDto,
  EmailControlsDto$inboundSchema,
  EmailControlsDto$Outbound,
  EmailControlsDto$outboundSchema,
} from './emailcontrolsdto.js';

/**
 * Control values for the layout
 */
export type ControlValues = {
  /**
   * Email layout controls
   */
  email?: EmailControlsDto | undefined;
};

export type UpdateLayoutDto = {
  /**
   * Name of the layout
   */
  name: string;
  /**
   * Enable or disable translations for this layout
   */
  isTranslationEnabled?: boolean | undefined;
  /**
   * Control values for the layout
   */
  controlValues?: ControlValues | null | undefined;
};

/** @internal */
export const ControlValues$inboundSchema: z.ZodType<ControlValues, z.ZodTypeDef, unknown> = z.object({
  email: EmailControlsDto$inboundSchema.optional(),
});

/** @internal */
export type ControlValues$Outbound = {
  email?: EmailControlsDto$Outbound | undefined;
};

/** @internal */
export const ControlValues$outboundSchema: z.ZodType<ControlValues$Outbound, z.ZodTypeDef, ControlValues> = z.object({
  email: EmailControlsDto$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ControlValues$ {
  /** @deprecated use `ControlValues$inboundSchema` instead. */
  export const inboundSchema = ControlValues$inboundSchema;
  /** @deprecated use `ControlValues$outboundSchema` instead. */
  export const outboundSchema = ControlValues$outboundSchema;
  /** @deprecated use `ControlValues$Outbound` instead. */
  export type Outbound = ControlValues$Outbound;
}

export function controlValuesToJSON(controlValues: ControlValues): string {
  return JSON.stringify(ControlValues$outboundSchema.parse(controlValues));
}

export function controlValuesFromJSON(jsonString: string): SafeParseResult<ControlValues, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ControlValues$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ControlValues' from JSON`
  );
}

/** @internal */
export const UpdateLayoutDto$inboundSchema: z.ZodType<UpdateLayoutDto, z.ZodTypeDef, unknown> = z.object({
  name: z.string(),
  isTranslationEnabled: z.boolean().default(false),
  controlValues: z.nullable(z.lazy(() => ControlValues$inboundSchema)).optional(),
});

/** @internal */
export type UpdateLayoutDto$Outbound = {
  name: string;
  isTranslationEnabled: boolean;
  controlValues?: ControlValues$Outbound | null | undefined;
};

/** @internal */
export const UpdateLayoutDto$outboundSchema: z.ZodType<UpdateLayoutDto$Outbound, z.ZodTypeDef, UpdateLayoutDto> =
  z.object({
    name: z.string(),
    isTranslationEnabled: z.boolean().default(false),
    controlValues: z.nullable(z.lazy(() => ControlValues$outboundSchema)).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateLayoutDto$ {
  /** @deprecated use `UpdateLayoutDto$inboundSchema` instead. */
  export const inboundSchema = UpdateLayoutDto$inboundSchema;
  /** @deprecated use `UpdateLayoutDto$outboundSchema` instead. */
  export const outboundSchema = UpdateLayoutDto$outboundSchema;
  /** @deprecated use `UpdateLayoutDto$Outbound` instead. */
  export type Outbound = UpdateLayoutDto$Outbound;
}

export function updateLayoutDtoToJSON(updateLayoutDto: UpdateLayoutDto): string {
  return JSON.stringify(UpdateLayoutDto$outboundSchema.parse(updateLayoutDto));
}

export function updateLayoutDtoFromJSON(jsonString: string): SafeParseResult<UpdateLayoutDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateLayoutDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateLayoutDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - controlValuesToJSON(controlValues: ControlValues)
 - controlValuesFromJSON(jsonString: string)
 - updateLayoutDtoToJSON(updateLayoutDto: UpdateLayoutDto)
 - updateLayoutDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ControlValues$Outbound;
}

export function controlValuesToJSON(controlValues: ControlValues): string...)
 - Outbound(UpdateLayoutDto$Outbound;
}

export function updateLayoutDtoToJSON(updateLayoutDto: UpdateLayoutDto)...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function controlValuesToJSON
- export function controlValuesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function updateLayoutDtoToJSON
- export function updateLayoutDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/updatesubscriberchannelrequestdto.ts
Tamaño: 3126 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ChannelCredentials,
  ChannelCredentials$inboundSchema,
  ChannelCredentials$Outbound,
  ChannelCredentials$outboundSchema,
} from './channelcredentials.js';
import {
  ChatOrPushProviderEnum,
  ChatOrPushProviderEnum$inboundSchema,
  ChatOrPushProviderEnum$outboundSchema,
} from './chatorpushproviderenum.js';

export type UpdateSubscriberChannelRequestDto = {
  /**
   * The provider identifier for the credentials
   */
  providerId: ChatOrPushProviderEnum;
  /**
   * The integration identifier
   */
  integrationIdentifier?: string | undefined;
  /**
   * Credentials payload for the specified provider
   */
  credentials: ChannelCredentials;
};

/** @internal */
export const UpdateSubscriberChannelRequestDto$inboundSchema: z.ZodType<
  UpdateSubscriberChannelRequestDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  providerId: ChatOrPushProviderEnum$inboundSchema,
  integrationIdentifier: z.string().optional(),
  credentials: ChannelCredentials$inboundSchema,
});

/** @internal */
export type UpdateSubscriberChannelRequestDto$Outbound = {
  providerId: string;
  integrationIdentifier?: string | undefined;
  credentials: ChannelCredentials$Outbound;
};

/** @internal */
export const UpdateSubscriberChannelRequestDto$outboundSchema: z.ZodType<
  UpdateSubscriberChannelRequestDto$Outbound,
  z.ZodTypeDef,
  UpdateSubscriberChannelRequestDto
> = z.object({
  providerId: ChatOrPushProviderEnum$outboundSchema,
  integrationIdentifier: z.string().optional(),
  credentials: ChannelCredentials$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateSubscriberChannelRequestDto$ {
  /** @deprecated use `UpdateSubscriberChannelRequestDto$inboundSchema` instead. */
  export const inboundSchema = UpdateSubscriberChannelRequestDto$inboundSchema;
  /** @deprecated use `UpdateSubscriberChannelRequestDto$outboundSchema` instead. */
  export const outboundSchema = UpdateSubscriberChannelRequestDto$outboundSchema;
  /** @deprecated use `UpdateSubscriberChannelRequestDto$Outbound` instead. */
  export type Outbound = UpdateSubscriberChannelRequestDto$Outbound;
}

export function updateSubscriberChannelRequestDtoToJSON(
  updateSubscriberChannelRequestDto: UpdateSubscriberChannelRequestDto
): string {
  return JSON.stringify(UpdateSubscriberChannelRequestDto$outboundSchema.parse(updateSubscriberChannelRequestDto));
}

export function updateSubscriberChannelRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<UpdateSubscriberChannelRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateSubscriberChannelRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateSubscriberChannelRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - updateSubscriberChannelRequestDtoToJSON(updateSubscriberChannelRequestDto: UpdateSubscriberChannelRequestDto)
 - updateSubscriberChannelRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(UpdateSubscriberChannelRequestDto$Outbound;
}

export function updateSubscriberChannelRequestDtoToJS...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function updateSubscriberChannelRequestDtoToJSON
- export function updateSubscriberChannelRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/updatesubscriberonlineflagrequestdto.ts
Tamaño: 2272 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type UpdateSubscriberOnlineFlagRequestDto = {
  isOnline: boolean;
};

/** @internal */
export const UpdateSubscriberOnlineFlagRequestDto$inboundSchema: z.ZodType<
  UpdateSubscriberOnlineFlagRequestDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  isOnline: z.boolean(),
});

/** @internal */
export type UpdateSubscriberOnlineFlagRequestDto$Outbound = {
  isOnline: boolean;
};

/** @internal */
export const UpdateSubscriberOnlineFlagRequestDto$outboundSchema: z.ZodType<
  UpdateSubscriberOnlineFlagRequestDto$Outbound,
  z.ZodTypeDef,
  UpdateSubscriberOnlineFlagRequestDto
> = z.object({
  isOnline: z.boolean(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateSubscriberOnlineFlagRequestDto$ {
  /** @deprecated use `UpdateSubscriberOnlineFlagRequestDto$inboundSchema` instead. */
  export const inboundSchema = UpdateSubscriberOnlineFlagRequestDto$inboundSchema;
  /** @deprecated use `UpdateSubscriberOnlineFlagRequestDto$outboundSchema` instead. */
  export const outboundSchema = UpdateSubscriberOnlineFlagRequestDto$outboundSchema;
  /** @deprecated use `UpdateSubscriberOnlineFlagRequestDto$Outbound` instead. */
  export type Outbound = UpdateSubscriberOnlineFlagRequestDto$Outbound;
}

export function updateSubscriberOnlineFlagRequestDtoToJSON(
  updateSubscriberOnlineFlagRequestDto: UpdateSubscriberOnlineFlagRequestDto
): string {
  return JSON.stringify(
    UpdateSubscriberOnlineFlagRequestDto$outboundSchema.parse(updateSubscriberOnlineFlagRequestDto)
  );
}

export function updateSubscriberOnlineFlagRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<UpdateSubscriberOnlineFlagRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateSubscriberOnlineFlagRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateSubscriberOnlineFlagRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - updateSubscriberOnlineFlagRequestDtoToJSON(updateSubscriberOnlineFlagRequestDto: UpdateSubscriberOnlineFlagRequestDto)
 - updateSubscriberOnlineFlagRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(UpdateSubscriberOnlineFlagRequestDto$Outbound;
}

export function updateSubscriberOnlineFlagRequestD...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function updateSubscriberOnlineFlagRequestDtoToJSON
- export function updateSubscriberOnlineFlagRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/updatetopicrequestdto.ts
Tamaño: 1935 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type UpdateTopicRequestDto = {
  /**
   * The display name for the topic
   */
  name: string;
};

/** @internal */
export const UpdateTopicRequestDto$inboundSchema: z.ZodType<UpdateTopicRequestDto, z.ZodTypeDef, unknown> = z.object({
  name: z.string(),
});

/** @internal */
export type UpdateTopicRequestDto$Outbound = {
  name: string;
};

/** @internal */
export const UpdateTopicRequestDto$outboundSchema: z.ZodType<
  UpdateTopicRequestDto$Outbound,
  z.ZodTypeDef,
  UpdateTopicRequestDto
> = z.object({
  name: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateTopicRequestDto$ {
  /** @deprecated use `UpdateTopicRequestDto$inboundSchema` instead. */
  export const inboundSchema = UpdateTopicRequestDto$inboundSchema;
  /** @deprecated use `UpdateTopicRequestDto$outboundSchema` instead. */
  export const outboundSchema = UpdateTopicRequestDto$outboundSchema;
  /** @deprecated use `UpdateTopicRequestDto$Outbound` instead. */
  export type Outbound = UpdateTopicRequestDto$Outbound;
}

export function updateTopicRequestDtoToJSON(updateTopicRequestDto: UpdateTopicRequestDto): string {
  return JSON.stringify(UpdateTopicRequestDto$outboundSchema.parse(updateTopicRequestDto));
}

export function updateTopicRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<UpdateTopicRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateTopicRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateTopicRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - updateTopicRequestDtoToJSON(updateTopicRequestDto: UpdateTopicRequestDto)
 - updateTopicRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(UpdateTopicRequestDto$Outbound;
}

export function updateTopicRequestDtoToJSON(updateTopicRequestDto...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function updateTopicRequestDtoToJSON
- export function updateTopicRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/updateworkflowdto.ts
Tamaño: 13722 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ChatStepUpsertDto,
  ChatStepUpsertDto$inboundSchema,
  ChatStepUpsertDto$Outbound,
  ChatStepUpsertDto$outboundSchema,
} from './chatstepupsertdto.js';
import {
  CustomStepUpsertDto,
  CustomStepUpsertDto$inboundSchema,
  CustomStepUpsertDto$Outbound,
  CustomStepUpsertDto$outboundSchema,
} from './customstepupsertdto.js';
import {
  DelayStepUpsertDto,
  DelayStepUpsertDto$inboundSchema,
  DelayStepUpsertDto$Outbound,
  DelayStepUpsertDto$outboundSchema,
} from './delaystepupsertdto.js';
import {
  DigestStepUpsertDto,
  DigestStepUpsertDto$inboundSchema,
  DigestStepUpsertDto$Outbound,
  DigestStepUpsertDto$outboundSchema,
} from './digeststepupsertdto.js';
import {
  EmailStepUpsertDto,
  EmailStepUpsertDto$inboundSchema,
  EmailStepUpsertDto$Outbound,
  EmailStepUpsertDto$outboundSchema,
} from './emailstepupsertdto.js';
import {
  InAppStepUpsertDto,
  InAppStepUpsertDto$inboundSchema,
  InAppStepUpsertDto$Outbound,
  InAppStepUpsertDto$outboundSchema,
} from './inappstepupsertdto.js';
import {
  PreferencesRequestDto,
  PreferencesRequestDto$inboundSchema,
  PreferencesRequestDto$Outbound,
  PreferencesRequestDto$outboundSchema,
} from './preferencesrequestdto.js';
import {
  PushStepUpsertDto,
  PushStepUpsertDto$inboundSchema,
  PushStepUpsertDto$Outbound,
  PushStepUpsertDto$outboundSchema,
} from './pushstepupsertdto.js';
import {
  ResourceOriginEnum,
  ResourceOriginEnum$inboundSchema,
  ResourceOriginEnum$outboundSchema,
} from './resourceoriginenum.js';
import {
  SeverityLevelEnum,
  SeverityLevelEnum$inboundSchema,
  SeverityLevelEnum$outboundSchema,
} from './severitylevelenum.js';
import {
  SmsStepUpsertDto,
  SmsStepUpsertDto$inboundSchema,
  SmsStepUpsertDto$Outbound,
  SmsStepUpsertDto$outboundSchema,
} from './smsstepupsertdto.js';

export type UpdateWorkflowDtoSteps =
  | (InAppStepUpsertDto & { type: 'in_app' })
  | (EmailStepUpsertDto & { type: 'email' })
  | (SmsStepUpsertDto & { type: 'sms' })
  | (PushStepUpsertDto & { type: 'push' })
  | (ChatStepUpsertDto & { type: 'chat' })
  | (DelayStepUpsertDto & { type: 'delay' })
  | (DigestStepUpsertDto & { type: 'digest' })
  | (CustomStepUpsertDto & { type: 'custom' });

export type UpdateWorkflowDto = {
  /**
   * Name of the workflow
   */
  name: string;
  /**
   * Description of the workflow
   */
  description?: string | undefined;
  /**
   * Tags associated with the workflow
   */
  tags?: Array<string> | undefined;
  /**
   * Whether the workflow is active
   */
  active?: boolean | undefined;
  /**
   * Enable or disable payload schema validation
   */
  validatePayload?: boolean | undefined;
  /**
   * The payload JSON Schema for the workflow
   */
  payloadSchema?: { [k: string]: any } | null | undefined;
  /**
   * Enable or disable translations for this workflow
   */
  isTranslationEnabled?: boolean | undefined;
  /**
   * Workflow ID (allowed only for code-first workflows)
   */
  workflowId?: string | undefined;
  /**
   * Steps of the workflow
   */
  steps: Array<
    | (InAppStepUpsertDto & { type: 'in_app' })
    | (EmailStepUpsertDto & { type: 'email' })
    | (SmsStepUpsertDto & { type: 'sms' })
    | (PushStepUpsertDto & { type: 'push' })
    | (ChatStepUpsertDto & { type: 'chat' })
    | (DelayStepUpsertDto & { type: 'delay' })
    | (DigestStepUpsertDto & { type: 'digest' })
    | (CustomStepUpsertDto & { type: 'custom' })
  >;
  /**
   * Workflow preferences
   */
  preferences: PreferencesRequestDto;
  /**
   * Origin of the layout
   */
  origin: ResourceOriginEnum;
  /**
   * Severity of the workflow
   */
  severity?: SeverityLevelEnum | undefined;
};

/** @internal */
export const UpdateWorkflowDtoSteps$inboundSchema: z.ZodType<UpdateWorkflowDtoSteps, z.ZodTypeDef, unknown> = z.union([
  InAppStepUpsertDto$inboundSchema.and(
    z.object({ type: z.literal('in_app') }).transform((v) => ({
      type: v.type,
    }))
  ),
  EmailStepUpsertDto$inboundSchema.and(z.object({ type: z.literal('email') }).transform((v) => ({ type: v.type }))),
  SmsStepUpsertDto$inboundSchema.and(z.object({ type: z.literal('sms') }).transform((v) => ({ type: v.type }))),
  PushStepUpsertDto$inboundSchema.and(z.object({ type: z.literal('push') }).transform((v) => ({ type: v.type }))),
  ChatStepUpsertDto$inboundSchema.and(z.object({ type: z.literal('chat') }).transform((v) => ({ type: v.type }))),
  DelayStepUpsertDto$inboundSchema.and(z.object({ type: z.literal('delay') }).transform((v) => ({ type: v.type }))),
  DigestStepUpsertDto$inboundSchema.and(
    z.object({ type: z.literal('digest') }).transform((v) => ({
      type: v.type,
    }))
  ),
  CustomStepUpsertDto$inboundSchema.and(
    z.object({ type: z.literal('custom') }).transform((v) => ({
      type: v.type,
    }))
  ),
]);

/** @internal */
export type UpdateWorkflowDtoSteps$Outbound =
  | (InAppStepUpsertDto$Outbound & { type: 'in_app' })
  | (EmailStepUpsertDto$Outbound & { type: 'email' })
  | (SmsStepUpsertDto$Outbound & { type: 'sms' })
  | (PushStepUpsertDto$Outbound & { type: 'push' })
  | (ChatStepUpsertDto$Outbound & { type: 'chat' })
  | (DelayStepUpsertDto$Outbound & { type: 'delay' })
  | (DigestStepUpsertDto$Outbound & { type: 'digest' })
  | (CustomStepUpsertDto$Outbound & { type: 'custom' });

/** @internal */
export const UpdateWorkflowDtoSteps$outboundSchema: z.ZodType<
  UpdateWorkflowDtoSteps$Outbound,
  z.ZodTypeDef,
  UpdateWorkflowDtoSteps
> = z.union([
  InAppStepUpsertDto$outboundSchema.and(
    z.object({ type: z.literal('in_app') }).transform((v) => ({
      type: v.type,
    }))
  ),
  EmailStepUpsertDto$outboundSchema.and(z.object({ type: z.literal('email') }).transform((v) => ({ type: v.type }))),
  SmsStepUpsertDto$outboundSchema.and(z.object({ type: z.literal('sms') }).transform((v) => ({ type: v.type }))),
  PushStepUpsertDto$outboundSchema.and(z.object({ type: z.literal('push') }).transform((v) => ({ type: v.type }))),
  ChatStepUpsertDto$outboundSchema.and(z.object({ type: z.literal('chat') }).transform((v) => ({ type: v.type }))),
  DelayStepUpsertDto$outboundSchema.and(z.object({ type: z.literal('delay') }).transform((v) => ({ type: v.type }))),
  DigestStepUpsertDto$outboundSchema.and(
    z.object({ type: z.literal('digest') }).transform((v) => ({
      type: v.type,
    }))
  ),
  CustomStepUpsertDto$outboundSchema.and(
    z.object({ type: z.literal('custom') }).transform((v) => ({
      type: v.type,
    }))
  ),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateWorkflowDtoSteps$ {
  /** @deprecated use `UpdateWorkflowDtoSteps$inboundSchema` instead. */
  export const inboundSchema = UpdateWorkflowDtoSteps$inboundSchema;
  /** @deprecated use `UpdateWorkflowDtoSteps$outboundSchema` instead. */
  export const outboundSchema = UpdateWorkflowDtoSteps$outboundSchema;
  /** @deprecated use `UpdateWorkflowDtoSteps$Outbound` instead. */
  export type Outbound = UpdateWorkflowDtoSteps$Outbound;
}

export function updateWorkflowDtoStepsToJSON(updateWorkflowDtoSteps: UpdateWorkflowDtoSteps): string {
  return JSON.stringify(UpdateWorkflowDtoSteps$outboundSchema.parse(updateWorkflowDtoSteps));
}

export function updateWorkflowDtoStepsFromJSON(
  jsonString: string
): SafeParseResult<UpdateWorkflowDtoSteps, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateWorkflowDtoSteps$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateWorkflowDtoSteps' from JSON`
  );
}

/** @internal */
export const UpdateWorkflowDto$inboundSchema: z.ZodType<UpdateWorkflowDto, z.ZodTypeDef, unknown> = z.object({
  name: z.string(),
  description: z.string().optional(),
  tags: z.array(z.string()).optional(),
  active: z.boolean().default(false),
  validatePayload: z.boolean().optional(),
  payloadSchema: z.nullable(z.record(z.any())).optional(),
  isTranslationEnabled: z.boolean().default(false),
  workflowId: z.string().optional(),
  steps: z.array(
    z.union([
      InAppStepUpsertDto$inboundSchema.and(
        z.object({ type: z.literal('in_app') }).transform((v) => ({
          type: v.type,
        }))
      ),
      EmailStepUpsertDto$inboundSchema.and(
        z.object({ type: z.literal('email') }).transform((v) => ({
          type: v.type,
        }))
      ),
      SmsStepUpsertDto$inboundSchema.and(
        z.object({ type: z.literal('sms') }).transform((v) => ({
          type: v.type,
        }))
      ),
      PushStepUpsertDto$inboundSchema.and(
        z.object({ type: z.literal('push') }).transform((v) => ({
          type: v.type,
        }))
      ),
      ChatStepUpsertDto$inboundSchema.and(
        z.object({ type: z.literal('chat') }).transform((v) => ({
          type: v.type,
        }))
      ),
      DelayStepUpsertDto$inboundSchema.and(
        z.object({ type: z.literal('delay') }).transform((v) => ({
          type: v.type,
        }))
      ),
      DigestStepUpsertDto$inboundSchema.and(
        z.object({ type: z.literal('digest') }).transform((v) => ({
          type: v.type,
        }))
      ),
      CustomStepUpsertDto$inboundSchema.and(
        z.object({ type: z.literal('custom') }).transform((v) => ({
          type: v.type,
        }))
      ),
    ])
  ),
  preferences: PreferencesRequestDto$inboundSchema,
  origin: ResourceOriginEnum$inboundSchema,
  severity: SeverityLevelEnum$inboundSchema.optional(),
});

/** @internal */
export type UpdateWorkflowDto$Outbound = {
  name: string;
  description?: string | undefined;
  tags?: Array<string> | undefined;
  active: boolean;
  validatePayload?: boolean | undefined;
  payloadSchema?: { [k: string]: any } | null | undefined;
  isTranslationEnabled: boolean;
  workflowId?: string | undefined;
  steps: Array<
    | (InAppStepUpsertDto$Outbound & { type: 'in_app' })
    | (EmailStepUpsertDto$Outbound & { type: 'email' })
    | (SmsStepUpsertDto$Outbound & { type: 'sms' })
    | (PushStepUpsertDto$Outbound & { type: 'push' })
    | (ChatStepUpsertDto$Outbound & { type: 'chat' })
    | (DelayStepUpsertDto$Outbound & { type: 'delay' })
    | (DigestStepUpsertDto$Outbound & { type: 'digest' })
    | (CustomStepUpsertDto$Outbound & { type: 'custom' })
  >;
  preferences: PreferencesRequestDto$Outbound;
  origin: string;
  severity?: string | undefined;
};

/** @internal */
export const UpdateWorkflowDto$outboundSchema: z.ZodType<UpdateWorkflowDto$Outbound, z.ZodTypeDef, UpdateWorkflowDto> =
  z.object({
    name: z.string(),
    description: z.string().optional(),
    tags: z.array(z.string()).optional(),
    active: z.boolean().default(false),
    validatePayload: z.boolean().optional(),
    payloadSchema: z.nullable(z.record(z.any())).optional(),
    isTranslationEnabled: z.boolean().default(false),
    workflowId: z.string().optional(),
    steps: z.array(
      z.union([
        InAppStepUpsertDto$outboundSchema.and(
          z.object({ type: z.literal('in_app') }).transform((v) => ({
            type: v.type,
          }))
        ),
        EmailStepUpsertDto$outboundSchema.and(
          z.object({ type: z.literal('email') }).transform((v) => ({
            type: v.type,
          }))
        ),
        SmsStepUpsertDto$outboundSchema.and(
          z.object({ type: z.literal('sms') }).transform((v) => ({
            type: v.type,
          }))
        ),
        PushStepUpsertDto$outboundSchema.and(
          z.object({ type: z.literal('push') }).transform((v) => ({
            type: v.type,
          }))
        ),
        ChatStepUpsertDto$outboundSchema.and(
          z.object({ type: z.literal('chat') }).transform((v) => ({
            type: v.type,
          }))
        ),
        DelayStepUpsertDto$outboundSchema.and(
          z.object({ type: z.literal('delay') }).transform((v) => ({
            type: v.type,
          }))
        ),
        DigestStepUpsertDto$outboundSchema.and(
          z.object({ type: z.literal('digest') }).transform((v) => ({
            type: v.type,
          }))
        ),
        CustomStepUpsertDto$outboundSchema.and(
          z.object({ type: z.literal('custom') }).transform((v) => ({
            type: v.type,
          }))
        ),
      ])
    ),
    preferences: PreferencesRequestDto$outboundSchema,
    origin: ResourceOriginEnum$outboundSchema,
    severity: SeverityLevelEnum$outboundSchema.optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UpdateWorkflowDto$ {
  /** @deprecated use `UpdateWorkflowDto$inboundSchema` instead. */
  export const inboundSchema = UpdateWorkflowDto$inboundSchema;
  /** @deprecated use `UpdateWorkflowDto$outboundSchema` instead. */
  export const outboundSchema = UpdateWorkflowDto$outboundSchema;
  /** @deprecated use `UpdateWorkflowDto$Outbound` instead. */
  export type Outbound = UpdateWorkflowDto$Outbound;
}

export function updateWorkflowDtoToJSON(updateWorkflowDto: UpdateWorkflowDto): string {
  return JSON.stringify(UpdateWorkflowDto$outboundSchema.parse(updateWorkflowDto));
}

export function updateWorkflowDtoFromJSON(jsonString: string): SafeParseResult<UpdateWorkflowDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateWorkflowDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateWorkflowDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - updateWorkflowDtoStepsToJSON(updateWorkflowDtoSteps: UpdateWorkflowDtoSteps)
 - updateWorkflowDtoStepsFromJSON(jsonString: string)
 - updateWorkflowDtoToJSON(updateWorkflowDto: UpdateWorkflowDto)
 - updateWorkflowDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(UpdateWorkflowDtoSteps$Outbound;
}

export function updateWorkflowDtoStepsToJSON(updateWorkflowDtoSt...)
 - Outbound(UpdateWorkflowDto$Outbound;
}

export function updateWorkflowDtoToJSON(updateWorkflowDto: UpdateWork...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function updateWorkflowDtoStepsToJSON
- export function updateWorkflowDtoStepsFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function updateWorkflowDtoToJSON
- export function updateWorkflowDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/uploadtranslationsrequestdto.ts
Tamaño: 3884 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * The resource type to associate localizations with
 */
export const UploadTranslationsRequestDtoResourceType = {
  Workflow: 'workflow',
  Layout: 'layout',
} as const;
/**
 * The resource type to associate localizations with
 */
export type UploadTranslationsRequestDtoResourceType = ClosedEnum<typeof UploadTranslationsRequestDtoResourceType>;

export type UploadTranslationsRequestDto = {
  /**
   * The resource ID to associate localizations with. Accepts identifier or slug format
   */
  resourceId: string;
  /**
   * The resource type to associate localizations with
   */
  resourceType: UploadTranslationsRequestDtoResourceType;
};

/** @internal */
export const UploadTranslationsRequestDtoResourceType$inboundSchema: z.ZodNativeEnum<
  typeof UploadTranslationsRequestDtoResourceType
> = z.nativeEnum(UploadTranslationsRequestDtoResourceType);

/** @internal */
export const UploadTranslationsRequestDtoResourceType$outboundSchema: z.ZodNativeEnum<
  typeof UploadTranslationsRequestDtoResourceType
> = UploadTranslationsRequestDtoResourceType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UploadTranslationsRequestDtoResourceType$ {
  /** @deprecated use `UploadTranslationsRequestDtoResourceType$inboundSchema` instead. */
  export const inboundSchema = UploadTranslationsRequestDtoResourceType$inboundSchema;
  /** @deprecated use `UploadTranslationsRequestDtoResourceType$outboundSchema` instead. */
  export const outboundSchema = UploadTranslationsRequestDtoResourceType$outboundSchema;
}

/** @internal */
export const UploadTranslationsRequestDto$inboundSchema: z.ZodType<
  UploadTranslationsRequestDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  resourceId: z.string(),
  resourceType: UploadTranslationsRequestDtoResourceType$inboundSchema,
});

/** @internal */
export type UploadTranslationsRequestDto$Outbound = {
  resourceId: string;
  resourceType: string;
};

/** @internal */
export const UploadTranslationsRequestDto$outboundSchema: z.ZodType<
  UploadTranslationsRequestDto$Outbound,
  z.ZodTypeDef,
  UploadTranslationsRequestDto
> = z.object({
  resourceId: z.string(),
  resourceType: UploadTranslationsRequestDtoResourceType$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UploadTranslationsRequestDto$ {
  /** @deprecated use `UploadTranslationsRequestDto$inboundSchema` instead. */
  export const inboundSchema = UploadTranslationsRequestDto$inboundSchema;
  /** @deprecated use `UploadTranslationsRequestDto$outboundSchema` instead. */
  export const outboundSchema = UploadTranslationsRequestDto$outboundSchema;
  /** @deprecated use `UploadTranslationsRequestDto$Outbound` instead. */
  export type Outbound = UploadTranslationsRequestDto$Outbound;
}

export function uploadTranslationsRequestDtoToJSON(uploadTranslationsRequestDto: UploadTranslationsRequestDto): string {
  return JSON.stringify(UploadTranslationsRequestDto$outboundSchema.parse(uploadTranslationsRequestDto));
}

export function uploadTranslationsRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<UploadTranslationsRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UploadTranslationsRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UploadTranslationsRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - uploadTranslationsRequestDtoToJSON(uploadTranslationsRequestDto: UploadTranslationsRequestDto)
 - uploadTranslationsRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(UploadTranslationsRequestDto$Outbound;
}

export function uploadTranslationsRequestDtoToJSON(uploadT...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function uploadTranslationsRequestDtoToJSON
- export function uploadTranslationsRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/uploadtranslationsresponsedto.ts
Tamaño: 2669 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type UploadTranslationsResponseDto = {
  /**
   * Total number of files processed
   */
  totalFiles: number;
  /**
   * Number of files successfully uploaded
   */
  successfulUploads: number;
  /**
   * Number of files that failed to upload
   */
  failedUploads: number;
  /**
   * List of error messages for failed uploads
   */
  errors: Array<string>;
};

/** @internal */
export const UploadTranslationsResponseDto$inboundSchema: z.ZodType<
  UploadTranslationsResponseDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  totalFiles: z.number(),
  successfulUploads: z.number(),
  failedUploads: z.number(),
  errors: z.array(z.string()),
});

/** @internal */
export type UploadTranslationsResponseDto$Outbound = {
  totalFiles: number;
  successfulUploads: number;
  failedUploads: number;
  errors: Array<string>;
};

/** @internal */
export const UploadTranslationsResponseDto$outboundSchema: z.ZodType<
  UploadTranslationsResponseDto$Outbound,
  z.ZodTypeDef,
  UploadTranslationsResponseDto
> = z.object({
  totalFiles: z.number(),
  successfulUploads: z.number(),
  failedUploads: z.number(),
  errors: z.array(z.string()),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UploadTranslationsResponseDto$ {
  /** @deprecated use `UploadTranslationsResponseDto$inboundSchema` instead. */
  export const inboundSchema = UploadTranslationsResponseDto$inboundSchema;
  /** @deprecated use `UploadTranslationsResponseDto$outboundSchema` instead. */
  export const outboundSchema = UploadTranslationsResponseDto$outboundSchema;
  /** @deprecated use `UploadTranslationsResponseDto$Outbound` instead. */
  export type Outbound = UploadTranslationsResponseDto$Outbound;
}

export function uploadTranslationsResponseDtoToJSON(
  uploadTranslationsResponseDto: UploadTranslationsResponseDto
): string {
  return JSON.stringify(UploadTranslationsResponseDto$outboundSchema.parse(uploadTranslationsResponseDto));
}

export function uploadTranslationsResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<UploadTranslationsResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UploadTranslationsResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UploadTranslationsResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - uploadTranslationsResponseDtoToJSON(uploadTranslationsResponseDto: UploadTranslationsResponseDto)
 - uploadTranslationsResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(UploadTranslationsResponseDto$Outbound;
}

export function uploadTranslationsResponseDtoToJSON(
  up...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function uploadTranslationsResponseDtoToJSON
- export function uploadTranslationsResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/webhookresultdto.ts
Tamaño: 2113 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import { EventBody, EventBody$inboundSchema, EventBody$Outbound, EventBody$outboundSchema } from './eventbody.js';

export type WebhookResultDto = {
  /**
   * Unique identifier for the webhook result
   */
  id: string;
  /**
   * Event body containing the webhook event data
   */
  event: EventBody;
};

/** @internal */
export const WebhookResultDto$inboundSchema: z.ZodType<WebhookResultDto, z.ZodTypeDef, unknown> = z.object({
  id: z.string(),
  event: EventBody$inboundSchema,
});

/** @internal */
export type WebhookResultDto$Outbound = {
  id: string;
  event: EventBody$Outbound;
};

/** @internal */
export const WebhookResultDto$outboundSchema: z.ZodType<WebhookResultDto$Outbound, z.ZodTypeDef, WebhookResultDto> =
  z.object({
    id: z.string(),
    event: EventBody$outboundSchema,
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WebhookResultDto$ {
  /** @deprecated use `WebhookResultDto$inboundSchema` instead. */
  export const inboundSchema = WebhookResultDto$inboundSchema;
  /** @deprecated use `WebhookResultDto$outboundSchema` instead. */
  export const outboundSchema = WebhookResultDto$outboundSchema;
  /** @deprecated use `WebhookResultDto$Outbound` instead. */
  export type Outbound = WebhookResultDto$Outbound;
}

export function webhookResultDtoToJSON(webhookResultDto: WebhookResultDto): string {
  return JSON.stringify(WebhookResultDto$outboundSchema.parse(webhookResultDto));
}

export function webhookResultDtoFromJSON(jsonString: string): SafeParseResult<WebhookResultDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WebhookResultDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WebhookResultDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - webhookResultDtoToJSON(webhookResultDto: WebhookResultDto)
 - webhookResultDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WebhookResultDto$Outbound;
}

export function webhookResultDtoToJSON(webhookResultDto: WebhookResult...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function webhookResultDtoToJSON
- export function webhookResultDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/workflowcreationsourceenum.ts
Tamaño: 1573 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Source of workflow creation
 */
export const WorkflowCreationSourceEnum = {
  TemplateStore: 'template_store',
  Editor: 'editor',
  NotificationDirectory: 'notification_directory',
  OnboardingDigestDemo: 'onboarding_digest_demo',
  OnboardingInApp: 'onboarding_in_app',
  EmptyState: 'empty_state',
  Dropdown: 'dropdown',
  OnboardingGetStarted: 'onboarding_get_started',
  Bridge: 'bridge',
  Dashboard: 'dashboard',
} as const;
/**
 * Source of workflow creation
 */
export type WorkflowCreationSourceEnum = ClosedEnum<typeof WorkflowCreationSourceEnum>;

/** @internal */
export const WorkflowCreationSourceEnum$inboundSchema: z.ZodNativeEnum<typeof WorkflowCreationSourceEnum> =
  z.nativeEnum(WorkflowCreationSourceEnum);

/** @internal */
export const WorkflowCreationSourceEnum$outboundSchema: z.ZodNativeEnum<typeof WorkflowCreationSourceEnum> =
  WorkflowCreationSourceEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowCreationSourceEnum$ {
  /** @deprecated use `WorkflowCreationSourceEnum$inboundSchema` instead. */
  export const inboundSchema = WorkflowCreationSourceEnum$inboundSchema;
  /** @deprecated use `WorkflowCreationSourceEnum$outboundSchema` instead. */
  export const outboundSchema = WorkflowCreationSourceEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/workflowinfodto.ts
Tamaño: 1938 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type WorkflowInfoDto = {
  /**
   * The name of the workflow
   */
  name: string;
  /**
   * The unique identifier of the workflow
   */
  workflowId: string;
};

/** @internal */
export const WorkflowInfoDto$inboundSchema: z.ZodType<WorkflowInfoDto, z.ZodTypeDef, unknown> = z.object({
  name: z.string(),
  workflowId: z.string(),
});

/** @internal */
export type WorkflowInfoDto$Outbound = {
  name: string;
  workflowId: string;
};

/** @internal */
export const WorkflowInfoDto$outboundSchema: z.ZodType<WorkflowInfoDto$Outbound, z.ZodTypeDef, WorkflowInfoDto> =
  z.object({
    name: z.string(),
    workflowId: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowInfoDto$ {
  /** @deprecated use `WorkflowInfoDto$inboundSchema` instead. */
  export const inboundSchema = WorkflowInfoDto$inboundSchema;
  /** @deprecated use `WorkflowInfoDto$outboundSchema` instead. */
  export const outboundSchema = WorkflowInfoDto$outboundSchema;
  /** @deprecated use `WorkflowInfoDto$Outbound` instead. */
  export type Outbound = WorkflowInfoDto$Outbound;
}

export function workflowInfoDtoToJSON(workflowInfoDto: WorkflowInfoDto): string {
  return JSON.stringify(WorkflowInfoDto$outboundSchema.parse(workflowInfoDto));
}

export function workflowInfoDtoFromJSON(jsonString: string): SafeParseResult<WorkflowInfoDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowInfoDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowInfoDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowInfoDtoToJSON(workflowInfoDto: WorkflowInfoDto)
 - workflowInfoDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowInfoDto$Outbound;
}

export function workflowInfoDtoToJSON(workflowInfoDto: WorkflowInfoDto)...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowInfoDtoToJSON
- export function workflowInfoDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/workflowlistresponsedto.ts
Tamaño: 11673 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ResourceOriginEnum,
  ResourceOriginEnum$inboundSchema,
  ResourceOriginEnum$outboundSchema,
} from './resourceoriginenum.js';
import {
  StepListResponseDto,
  StepListResponseDto$inboundSchema,
  StepListResponseDto$Outbound,
  StepListResponseDto$outboundSchema,
} from './steplistresponsedto.js';
import { StepTypeEnum, StepTypeEnum$inboundSchema, StepTypeEnum$outboundSchema } from './steptypeenum.js';
import {
  WorkflowStatusEnum,
  WorkflowStatusEnum$inboundSchema,
  WorkflowStatusEnum$outboundSchema,
} from './workflowstatusenum.js';

/**
 * User who last updated the workflow
 */
export type WorkflowListResponseDtoUpdatedBy = {
  /**
   * User ID
   */
  id: string;
  /**
   * User first name
   */
  firstName?: string | null | undefined;
  /**
   * User last name
   */
  lastName?: string | null | undefined;
  /**
   * User external ID
   */
  externalId?: string | null | undefined;
};

/**
 * User who last published the workflow
 */
export type WorkflowListResponseDtoLastPublishedBy = {
  /**
   * User ID
   */
  id: string;
  /**
   * User first name
   */
  firstName?: string | null | undefined;
  /**
   * User last name
   */
  lastName?: string | null | undefined;
  /**
   * User external ID
   */
  externalId?: string | null | undefined;
};

export type WorkflowListResponseDto = {
  /**
   * Name of the workflow
   */
  name: string;
  /**
   * Tags associated with the workflow
   */
  tags?: Array<string> | undefined;
  /**
   * Last updated timestamp
   */
  updatedAt: string;
  /**
   * Creation timestamp
   */
  createdAt: string;
  /**
   * User who last updated the workflow
   */
  updatedBy?: WorkflowListResponseDtoUpdatedBy | null | undefined;
  /**
   * Timestamp of the last workflow publication
   */
  lastPublishedAt?: string | null | undefined;
  /**
   * User who last published the workflow
   */
  lastPublishedBy?: WorkflowListResponseDtoLastPublishedBy | null | undefined;
  /**
   * Unique database identifier
   */
  id: string;
  /**
   * Workflow identifier
   */
  workflowId: string;
  /**
   * Workflow slug
   */
  slug: string;
  /**
   * Status of the workflow
   */
  status: WorkflowStatusEnum;
  /**
   * Origin of the layout
   */
  origin: ResourceOriginEnum;
  /**
   * Timestamp of the last workflow trigger
   */
  lastTriggeredAt?: string | null | undefined;
  /**
   * Overview of step types in the workflow
   */
  stepTypeOverviews: Array<StepTypeEnum>;
  /**
   * Is translation enabled for the workflow
   */
  isTranslationEnabled?: boolean | undefined;
  /**
   * Steps of the workflow
   */
  steps: Array<StepListResponseDto>;
};

/** @internal */
export const WorkflowListResponseDtoUpdatedBy$inboundSchema: z.ZodType<
  WorkflowListResponseDtoUpdatedBy,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    _id: z.string(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    externalId: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type WorkflowListResponseDtoUpdatedBy$Outbound = {
  _id: string;
  firstName?: string | null | undefined;
  lastName?: string | null | undefined;
  externalId?: string | null | undefined;
};

/** @internal */
export const WorkflowListResponseDtoUpdatedBy$outboundSchema: z.ZodType<
  WorkflowListResponseDtoUpdatedBy$Outbound,
  z.ZodTypeDef,
  WorkflowListResponseDtoUpdatedBy
> = z
  .object({
    id: z.string(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    externalId: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowListResponseDtoUpdatedBy$ {
  /** @deprecated use `WorkflowListResponseDtoUpdatedBy$inboundSchema` instead. */
  export const inboundSchema = WorkflowListResponseDtoUpdatedBy$inboundSchema;
  /** @deprecated use `WorkflowListResponseDtoUpdatedBy$outboundSchema` instead. */
  export const outboundSchema = WorkflowListResponseDtoUpdatedBy$outboundSchema;
  /** @deprecated use `WorkflowListResponseDtoUpdatedBy$Outbound` instead. */
  export type Outbound = WorkflowListResponseDtoUpdatedBy$Outbound;
}

export function workflowListResponseDtoUpdatedByToJSON(
  workflowListResponseDtoUpdatedBy: WorkflowListResponseDtoUpdatedBy
): string {
  return JSON.stringify(WorkflowListResponseDtoUpdatedBy$outboundSchema.parse(workflowListResponseDtoUpdatedBy));
}

export function workflowListResponseDtoUpdatedByFromJSON(
  jsonString: string
): SafeParseResult<WorkflowListResponseDtoUpdatedBy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowListResponseDtoUpdatedBy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowListResponseDtoUpdatedBy' from JSON`
  );
}

/** @internal */
export const WorkflowListResponseDtoLastPublishedBy$inboundSchema: z.ZodType<
  WorkflowListResponseDtoLastPublishedBy,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    _id: z.string(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    externalId: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type WorkflowListResponseDtoLastPublishedBy$Outbound = {
  _id: string;
  firstName?: string | null | undefined;
  lastName?: string | null | undefined;
  externalId?: string | null | undefined;
};

/** @internal */
export const WorkflowListResponseDtoLastPublishedBy$outboundSchema: z.ZodType<
  WorkflowListResponseDtoLastPublishedBy$Outbound,
  z.ZodTypeDef,
  WorkflowListResponseDtoLastPublishedBy
> = z
  .object({
    id: z.string(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    externalId: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowListResponseDtoLastPublishedBy$ {
  /** @deprecated use `WorkflowListResponseDtoLastPublishedBy$inboundSchema` instead. */
  export const inboundSchema = WorkflowListResponseDtoLastPublishedBy$inboundSchema;
  /** @deprecated use `WorkflowListResponseDtoLastPublishedBy$outboundSchema` instead. */
  export const outboundSchema = WorkflowListResponseDtoLastPublishedBy$outboundSchema;
  /** @deprecated use `WorkflowListResponseDtoLastPublishedBy$Outbound` instead. */
  export type Outbound = WorkflowListResponseDtoLastPublishedBy$Outbound;
}

export function workflowListResponseDtoLastPublishedByToJSON(
  workflowListResponseDtoLastPublishedBy: WorkflowListResponseDtoLastPublishedBy
): string {
  return JSON.stringify(
    WorkflowListResponseDtoLastPublishedBy$outboundSchema.parse(workflowListResponseDtoLastPublishedBy)
  );
}

export function workflowListResponseDtoLastPublishedByFromJSON(
  jsonString: string
): SafeParseResult<WorkflowListResponseDtoLastPublishedBy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowListResponseDtoLastPublishedBy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowListResponseDtoLastPublishedBy' from JSON`
  );
}

/** @internal */
export const WorkflowListResponseDto$inboundSchema: z.ZodType<WorkflowListResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    name: z.string(),
    tags: z.array(z.string()).optional(),
    updatedAt: z.string(),
    createdAt: z.string(),
    updatedBy: z.nullable(z.lazy(() => WorkflowListResponseDtoUpdatedBy$inboundSchema)).optional(),
    lastPublishedAt: z.nullable(z.string()).optional(),
    lastPublishedBy: z.nullable(z.lazy(() => WorkflowListResponseDtoLastPublishedBy$inboundSchema)).optional(),
    _id: z.string(),
    workflowId: z.string(),
    slug: z.string(),
    status: WorkflowStatusEnum$inboundSchema,
    origin: ResourceOriginEnum$inboundSchema,
    lastTriggeredAt: z.nullable(z.string()).optional(),
    stepTypeOverviews: z.array(StepTypeEnum$inboundSchema),
    isTranslationEnabled: z.boolean().optional(),
    steps: z.array(StepListResponseDto$inboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type WorkflowListResponseDto$Outbound = {
  name: string;
  tags?: Array<string> | undefined;
  updatedAt: string;
  createdAt: string;
  updatedBy?: WorkflowListResponseDtoUpdatedBy$Outbound | null | undefined;
  lastPublishedAt?: string | null | undefined;
  lastPublishedBy?: WorkflowListResponseDtoLastPublishedBy$Outbound | null | undefined;
  _id: string;
  workflowId: string;
  slug: string;
  status: string;
  origin: string;
  lastTriggeredAt?: string | null | undefined;
  stepTypeOverviews: Array<string>;
  isTranslationEnabled?: boolean | undefined;
  steps: Array<StepListResponseDto$Outbound>;
};

/** @internal */
export const WorkflowListResponseDto$outboundSchema: z.ZodType<
  WorkflowListResponseDto$Outbound,
  z.ZodTypeDef,
  WorkflowListResponseDto
> = z
  .object({
    name: z.string(),
    tags: z.array(z.string()).optional(),
    updatedAt: z.string(),
    createdAt: z.string(),
    updatedBy: z.nullable(z.lazy(() => WorkflowListResponseDtoUpdatedBy$outboundSchema)).optional(),
    lastPublishedAt: z.nullable(z.string()).optional(),
    lastPublishedBy: z.nullable(z.lazy(() => WorkflowListResponseDtoLastPublishedBy$outboundSchema)).optional(),
    id: z.string(),
    workflowId: z.string(),
    slug: z.string(),
    status: WorkflowStatusEnum$outboundSchema,
    origin: ResourceOriginEnum$outboundSchema,
    lastTriggeredAt: z.nullable(z.string()).optional(),
    stepTypeOverviews: z.array(StepTypeEnum$outboundSchema),
    isTranslationEnabled: z.boolean().optional(),
    steps: z.array(StepListResponseDto$outboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowListResponseDto$ {
  /** @deprecated use `WorkflowListResponseDto$inboundSchema` instead. */
  export const inboundSchema = WorkflowListResponseDto$inboundSchema;
  /** @deprecated use `WorkflowListResponseDto$outboundSchema` instead. */
  export const outboundSchema = WorkflowListResponseDto$outboundSchema;
  /** @deprecated use `WorkflowListResponseDto$Outbound` instead. */
  export type Outbound = WorkflowListResponseDto$Outbound;
}

export function workflowListResponseDtoToJSON(workflowListResponseDto: WorkflowListResponseDto): string {
  return JSON.stringify(WorkflowListResponseDto$outboundSchema.parse(workflowListResponseDto));
}

export function workflowListResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<WorkflowListResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowListResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowListResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowListResponseDtoUpdatedByToJSON(workflowListResponseDtoUpdatedBy: WorkflowListResponseDtoUpdatedBy)
 - workflowListResponseDtoUpdatedByFromJSON(jsonString: string)
 - workflowListResponseDtoLastPublishedByToJSON(workflowListResponseDtoLastPublishedBy: WorkflowListResponseDtoLastPublishedBy)
 - workflowListResponseDtoLastPublishedByFromJSON(jsonString: string)
 - workflowListResponseDtoToJSON(workflowListResponseDto: WorkflowListResponseDto)
 - workflowListResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowListResponseDtoUpdatedBy$Outbound;
}

export function workflowListResponseDtoUpdatedByToJSON...)
 - Outbound(WorkflowListResponseDtoLastPublishedBy$Outbound;
}

export function workflowListResponseDtoLastPubli...)
 - Outbound(WorkflowListResponseDto$Outbound;
}

export function workflowListResponseDtoToJSON(workflowListRespo...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowListResponseDtoUpdatedByToJSON
- export function workflowListResponseDtoUpdatedByFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowListResponseDtoLastPublishedByToJSON
- export function workflowListResponseDtoLastPublishedByFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowListResponseDtoToJSON
- export function workflowListResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/workflowpreferencedto.ts
Tamaño: 2426 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type WorkflowPreferenceDto = {
  /**
   * A flag specifying if notification delivery is enabled for the workflow. If true, notification delivery is enabled by default for all channels. This setting can be overridden by the channel preferences.
   */
  enabled?: boolean | undefined;
  /**
   * A flag specifying if the preference is read-only. If true, the preference cannot be changed by the Subscriber.
   */
  readOnly?: boolean | undefined;
};

/** @internal */
export const WorkflowPreferenceDto$inboundSchema: z.ZodType<WorkflowPreferenceDto, z.ZodTypeDef, unknown> = z.object({
  enabled: z.boolean().default(true),
  readOnly: z.boolean().default(false),
});

/** @internal */
export type WorkflowPreferenceDto$Outbound = {
  enabled: boolean;
  readOnly: boolean;
};

/** @internal */
export const WorkflowPreferenceDto$outboundSchema: z.ZodType<
  WorkflowPreferenceDto$Outbound,
  z.ZodTypeDef,
  WorkflowPreferenceDto
> = z.object({
  enabled: z.boolean().default(true),
  readOnly: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowPreferenceDto$ {
  /** @deprecated use `WorkflowPreferenceDto$inboundSchema` instead. */
  export const inboundSchema = WorkflowPreferenceDto$inboundSchema;
  /** @deprecated use `WorkflowPreferenceDto$outboundSchema` instead. */
  export const outboundSchema = WorkflowPreferenceDto$outboundSchema;
  /** @deprecated use `WorkflowPreferenceDto$Outbound` instead. */
  export type Outbound = WorkflowPreferenceDto$Outbound;
}

export function workflowPreferenceDtoToJSON(workflowPreferenceDto: WorkflowPreferenceDto): string {
  return JSON.stringify(WorkflowPreferenceDto$outboundSchema.parse(workflowPreferenceDto));
}

export function workflowPreferenceDtoFromJSON(
  jsonString: string
): SafeParseResult<WorkflowPreferenceDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowPreferenceDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowPreferenceDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowPreferenceDtoToJSON(workflowPreferenceDto: WorkflowPreferenceDto)
 - workflowPreferenceDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowPreferenceDto$Outbound;
}

export function workflowPreferenceDtoToJSON(workflowPreferenceDto...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowPreferenceDtoToJSON
- export function workflowPreferenceDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/workflowpreferencesdto.ts
Tamaño: 4085 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ChannelPreferenceDto,
  ChannelPreferenceDto$inboundSchema,
  ChannelPreferenceDto$Outbound,
  ChannelPreferenceDto$outboundSchema,
} from './channelpreferencedto.js';
import {
  WorkflowPreferenceDto,
  WorkflowPreferenceDto$inboundSchema,
  WorkflowPreferenceDto$Outbound,
  WorkflowPreferenceDto$outboundSchema,
} from './workflowpreferencedto.js';

/**
 * A preference for the workflow. The values specified here will be used if no preference is specified for a channel.
 */
export type All = WorkflowPreferenceDto;

export type WorkflowPreferencesDto = {
  /**
   * A preference for the workflow. The values specified here will be used if no preference is specified for a channel.
   */
  all: WorkflowPreferenceDto;
  /**
   * Preferences for different communication channels
   */
  channels: { [k: string]: ChannelPreferenceDto };
};

/** @internal */
export const All$inboundSchema: z.ZodType<All, z.ZodTypeDef, unknown> = WorkflowPreferenceDto$inboundSchema;

/** @internal */
export type All$Outbound = WorkflowPreferenceDto$Outbound;

/** @internal */
export const All$outboundSchema: z.ZodType<All$Outbound, z.ZodTypeDef, All> = WorkflowPreferenceDto$outboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace All$ {
  /** @deprecated use `All$inboundSchema` instead. */
  export const inboundSchema = All$inboundSchema;
  /** @deprecated use `All$outboundSchema` instead. */
  export const outboundSchema = All$outboundSchema;
  /** @deprecated use `All$Outbound` instead. */
  export type Outbound = All$Outbound;
}

export function allToJSON(all: All): string {
  return JSON.stringify(All$outboundSchema.parse(all));
}

export function allFromJSON(jsonString: string): SafeParseResult<All, SDKValidationError> {
  return safeParse(jsonString, (x) => All$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'All' from JSON`);
}

/** @internal */
export const WorkflowPreferencesDto$inboundSchema: z.ZodType<WorkflowPreferencesDto, z.ZodTypeDef, unknown> = z.object({
  all: WorkflowPreferenceDto$inboundSchema,
  channels: z.record(ChannelPreferenceDto$inboundSchema),
});

/** @internal */
export type WorkflowPreferencesDto$Outbound = {
  all: WorkflowPreferenceDto$Outbound;
  channels: { [k: string]: ChannelPreferenceDto$Outbound };
};

/** @internal */
export const WorkflowPreferencesDto$outboundSchema: z.ZodType<
  WorkflowPreferencesDto$Outbound,
  z.ZodTypeDef,
  WorkflowPreferencesDto
> = z.object({
  all: WorkflowPreferenceDto$outboundSchema,
  channels: z.record(ChannelPreferenceDto$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowPreferencesDto$ {
  /** @deprecated use `WorkflowPreferencesDto$inboundSchema` instead. */
  export const inboundSchema = WorkflowPreferencesDto$inboundSchema;
  /** @deprecated use `WorkflowPreferencesDto$outboundSchema` instead. */
  export const outboundSchema = WorkflowPreferencesDto$outboundSchema;
  /** @deprecated use `WorkflowPreferencesDto$Outbound` instead. */
  export type Outbound = WorkflowPreferencesDto$Outbound;
}

export function workflowPreferencesDtoToJSON(workflowPreferencesDto: WorkflowPreferencesDto): string {
  return JSON.stringify(WorkflowPreferencesDto$outboundSchema.parse(workflowPreferencesDto));
}

export function workflowPreferencesDtoFromJSON(
  jsonString: string
): SafeParseResult<WorkflowPreferencesDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowPreferencesDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowPreferencesDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - allToJSON(all: All)
 - allFromJSON(jsonString: string)
 - workflowPreferencesDtoToJSON(workflowPreferencesDto: WorkflowPreferencesDto)
 - workflowPreferencesDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(All$Outbound;
}

export function allToJSON(all: All): string {
  return JSON.stringify(All$outboundS...)
 - Outbound(WorkflowPreferencesDto$Outbound;
}

export function workflowPreferencesDtoToJSON(workflowPreferences...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function allToJSON
- export function allFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowPreferencesDtoToJSON
- export function workflowPreferencesDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/workflowpreferencesresponsedto.ts
Tamaño: 7687 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ChannelPreferenceDto,
  ChannelPreferenceDto$inboundSchema,
  ChannelPreferenceDto$Outbound,
  ChannelPreferenceDto$outboundSchema,
} from './channelpreferencedto.js';
import {
  WorkflowPreferenceDto,
  WorkflowPreferenceDto$inboundSchema,
  WorkflowPreferenceDto$Outbound,
  WorkflowPreferenceDto$outboundSchema,
} from './workflowpreferencedto.js';
import {
  WorkflowPreferencesDto,
  WorkflowPreferencesDto$inboundSchema,
  WorkflowPreferencesDto$Outbound,
  WorkflowPreferencesDto$outboundSchema,
} from './workflowpreferencesdto.js';

/**
 * A preference for the workflow. The values specified here will be used if no preference is specified for a channel.
 */
export type WorkflowPreferencesResponseDtoAll = WorkflowPreferenceDto;

/**
 * User-specific workflow preferences
 */
export type WorkflowPreferencesResponseDtoUser = {
  /**
   * A preference for the workflow. The values specified here will be used if no preference is specified for a channel.
   */
  all: WorkflowPreferenceDto;
  /**
   * Preferences for different communication channels
   */
  channels: { [k: string]: ChannelPreferenceDto };
};

export type WorkflowPreferencesResponseDto = {
  /**
   * User-specific workflow preferences
   */
  user?: WorkflowPreferencesResponseDtoUser | null | undefined;
  /**
   * Default workflow preferences
   */
  default: WorkflowPreferencesDto;
};

/** @internal */
export const WorkflowPreferencesResponseDtoAll$inboundSchema: z.ZodType<
  WorkflowPreferencesResponseDtoAll,
  z.ZodTypeDef,
  unknown
> = WorkflowPreferenceDto$inboundSchema;

/** @internal */
export type WorkflowPreferencesResponseDtoAll$Outbound = WorkflowPreferenceDto$Outbound;

/** @internal */
export const WorkflowPreferencesResponseDtoAll$outboundSchema: z.ZodType<
  WorkflowPreferencesResponseDtoAll$Outbound,
  z.ZodTypeDef,
  WorkflowPreferencesResponseDtoAll
> = WorkflowPreferenceDto$outboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowPreferencesResponseDtoAll$ {
  /** @deprecated use `WorkflowPreferencesResponseDtoAll$inboundSchema` instead. */
  export const inboundSchema = WorkflowPreferencesResponseDtoAll$inboundSchema;
  /** @deprecated use `WorkflowPreferencesResponseDtoAll$outboundSchema` instead. */
  export const outboundSchema = WorkflowPreferencesResponseDtoAll$outboundSchema;
  /** @deprecated use `WorkflowPreferencesResponseDtoAll$Outbound` instead. */
  export type Outbound = WorkflowPreferencesResponseDtoAll$Outbound;
}

export function workflowPreferencesResponseDtoAllToJSON(
  workflowPreferencesResponseDtoAll: WorkflowPreferencesResponseDtoAll
): string {
  return JSON.stringify(WorkflowPreferencesResponseDtoAll$outboundSchema.parse(workflowPreferencesResponseDtoAll));
}

export function workflowPreferencesResponseDtoAllFromJSON(
  jsonString: string
): SafeParseResult<WorkflowPreferencesResponseDtoAll, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowPreferencesResponseDtoAll$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowPreferencesResponseDtoAll' from JSON`
  );
}

/** @internal */
export const WorkflowPreferencesResponseDtoUser$inboundSchema: z.ZodType<
  WorkflowPreferencesResponseDtoUser,
  z.ZodTypeDef,
  unknown
> = z.object({
  all: WorkflowPreferenceDto$inboundSchema,
  channels: z.record(ChannelPreferenceDto$inboundSchema),
});

/** @internal */
export type WorkflowPreferencesResponseDtoUser$Outbound = {
  all: WorkflowPreferenceDto$Outbound;
  channels: { [k: string]: ChannelPreferenceDto$Outbound };
};

/** @internal */
export const WorkflowPreferencesResponseDtoUser$outboundSchema: z.ZodType<
  WorkflowPreferencesResponseDtoUser$Outbound,
  z.ZodTypeDef,
  WorkflowPreferencesResponseDtoUser
> = z.object({
  all: WorkflowPreferenceDto$outboundSchema,
  channels: z.record(ChannelPreferenceDto$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowPreferencesResponseDtoUser$ {
  /** @deprecated use `WorkflowPreferencesResponseDtoUser$inboundSchema` instead. */
  export const inboundSchema = WorkflowPreferencesResponseDtoUser$inboundSchema;
  /** @deprecated use `WorkflowPreferencesResponseDtoUser$outboundSchema` instead. */
  export const outboundSchema = WorkflowPreferencesResponseDtoUser$outboundSchema;
  /** @deprecated use `WorkflowPreferencesResponseDtoUser$Outbound` instead. */
  export type Outbound = WorkflowPreferencesResponseDtoUser$Outbound;
}

export function workflowPreferencesResponseDtoUserToJSON(
  workflowPreferencesResponseDtoUser: WorkflowPreferencesResponseDtoUser
): string {
  return JSON.stringify(WorkflowPreferencesResponseDtoUser$outboundSchema.parse(workflowPreferencesResponseDtoUser));
}

export function workflowPreferencesResponseDtoUserFromJSON(
  jsonString: string
): SafeParseResult<WorkflowPreferencesResponseDtoUser, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowPreferencesResponseDtoUser$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowPreferencesResponseDtoUser' from JSON`
  );
}

/** @internal */
export const WorkflowPreferencesResponseDto$inboundSchema: z.ZodType<
  WorkflowPreferencesResponseDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  user: z.nullable(z.lazy(() => WorkflowPreferencesResponseDtoUser$inboundSchema)).optional(),
  default: WorkflowPreferencesDto$inboundSchema,
});

/** @internal */
export type WorkflowPreferencesResponseDto$Outbound = {
  user?: WorkflowPreferencesResponseDtoUser$Outbound | null | undefined;
  default: WorkflowPreferencesDto$Outbound;
};

/** @internal */
export const WorkflowPreferencesResponseDto$outboundSchema: z.ZodType<
  WorkflowPreferencesResponseDto$Outbound,
  z.ZodTypeDef,
  WorkflowPreferencesResponseDto
> = z.object({
  user: z.nullable(z.lazy(() => WorkflowPreferencesResponseDtoUser$outboundSchema)).optional(),
  default: WorkflowPreferencesDto$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowPreferencesResponseDto$ {
  /** @deprecated use `WorkflowPreferencesResponseDto$inboundSchema` instead. */
  export const inboundSchema = WorkflowPreferencesResponseDto$inboundSchema;
  /** @deprecated use `WorkflowPreferencesResponseDto$outboundSchema` instead. */
  export const outboundSchema = WorkflowPreferencesResponseDto$outboundSchema;
  /** @deprecated use `WorkflowPreferencesResponseDto$Outbound` instead. */
  export type Outbound = WorkflowPreferencesResponseDto$Outbound;
}

export function workflowPreferencesResponseDtoToJSON(
  workflowPreferencesResponseDto: WorkflowPreferencesResponseDto
): string {
  return JSON.stringify(WorkflowPreferencesResponseDto$outboundSchema.parse(workflowPreferencesResponseDto));
}

export function workflowPreferencesResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<WorkflowPreferencesResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowPreferencesResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowPreferencesResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowPreferencesResponseDtoAllToJSON(workflowPreferencesResponseDtoAll: WorkflowPreferencesResponseDtoAll)
 - workflowPreferencesResponseDtoAllFromJSON(jsonString: string)
 - workflowPreferencesResponseDtoUserToJSON(workflowPreferencesResponseDtoUser: WorkflowPreferencesResponseDtoUser)
 - workflowPreferencesResponseDtoUserFromJSON(jsonString: string)
 - workflowPreferencesResponseDtoToJSON(workflowPreferencesResponseDto: WorkflowPreferencesResponseDto)
 - workflowPreferencesResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowPreferencesResponseDtoAll$Outbound;
}

export function workflowPreferencesResponseDtoAllToJS...)
 - Outbound(WorkflowPreferencesResponseDtoUser$Outbound;
}

export function workflowPreferencesResponseDtoUserTo...)
 - Outbound(WorkflowPreferencesResponseDto$Outbound;
}

export function workflowPreferencesResponseDtoToJSON(
  ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowPreferencesResponseDtoAllToJSON
- export function workflowPreferencesResponseDtoAllFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowPreferencesResponseDtoUserToJSON
- export function workflowPreferencesResponseDtoUserFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowPreferencesResponseDtoToJSON
- export function workflowPreferencesResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/workflowresponse.ts
Tamaño: 9183 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  NotificationGroup,
  NotificationGroup$inboundSchema,
  NotificationGroup$Outbound,
  NotificationGroup$outboundSchema,
} from './notificationgroup.js';
import {
  NotificationStepDto,
  NotificationStepDto$inboundSchema,
  NotificationStepDto$Outbound,
  NotificationStepDto$outboundSchema,
} from './notificationstepdto.js';
import {
  NotificationTrigger,
  NotificationTrigger$inboundSchema,
  NotificationTrigger$Outbound,
  NotificationTrigger$outboundSchema,
} from './notificationtrigger.js';
import {
  SubscriberPreferenceChannels,
  SubscriberPreferenceChannels$inboundSchema,
  SubscriberPreferenceChannels$Outbound,
  SubscriberPreferenceChannels$outboundSchema,
} from './subscriberpreferencechannels.js';

export type WorkflowResponseData = {};

export type WorkflowIntegrationStatus = {};

export type WorkflowResponse = {
  id?: string | undefined;
  name: string;
  description: string;
  active: boolean;
  draft: boolean;
  preferenceSettings: SubscriberPreferenceChannels;
  critical: boolean;
  tags: Array<string>;
  steps: Array<NotificationStepDto>;
  organizationId: string;
  creatorId: string;
  environmentId: string;
  triggers: Array<NotificationTrigger>;
  notificationGroupId: string;
  parentId?: string | undefined;
  deleted: boolean;
  deletedAt: string;
  deletedBy: string;
  notificationGroup?: NotificationGroup | undefined;
  data?: WorkflowResponseData | undefined;
  workflowIntegrationStatus?: WorkflowIntegrationStatus | undefined;
};

/** @internal */
export const WorkflowResponseData$inboundSchema: z.ZodType<WorkflowResponseData, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type WorkflowResponseData$Outbound = {};

/** @internal */
export const WorkflowResponseData$outboundSchema: z.ZodType<
  WorkflowResponseData$Outbound,
  z.ZodTypeDef,
  WorkflowResponseData
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowResponseData$ {
  /** @deprecated use `WorkflowResponseData$inboundSchema` instead. */
  export const inboundSchema = WorkflowResponseData$inboundSchema;
  /** @deprecated use `WorkflowResponseData$outboundSchema` instead. */
  export const outboundSchema = WorkflowResponseData$outboundSchema;
  /** @deprecated use `WorkflowResponseData$Outbound` instead. */
  export type Outbound = WorkflowResponseData$Outbound;
}

export function workflowResponseDataToJSON(workflowResponseData: WorkflowResponseData): string {
  return JSON.stringify(WorkflowResponseData$outboundSchema.parse(workflowResponseData));
}

export function workflowResponseDataFromJSON(
  jsonString: string
): SafeParseResult<WorkflowResponseData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowResponseData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowResponseData' from JSON`
  );
}

/** @internal */
export const WorkflowIntegrationStatus$inboundSchema: z.ZodType<WorkflowIntegrationStatus, z.ZodTypeDef, unknown> =
  z.object({});

/** @internal */
export type WorkflowIntegrationStatus$Outbound = {};

/** @internal */
export const WorkflowIntegrationStatus$outboundSchema: z.ZodType<
  WorkflowIntegrationStatus$Outbound,
  z.ZodTypeDef,
  WorkflowIntegrationStatus
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowIntegrationStatus$ {
  /** @deprecated use `WorkflowIntegrationStatus$inboundSchema` instead. */
  export const inboundSchema = WorkflowIntegrationStatus$inboundSchema;
  /** @deprecated use `WorkflowIntegrationStatus$outboundSchema` instead. */
  export const outboundSchema = WorkflowIntegrationStatus$outboundSchema;
  /** @deprecated use `WorkflowIntegrationStatus$Outbound` instead. */
  export type Outbound = WorkflowIntegrationStatus$Outbound;
}

export function workflowIntegrationStatusToJSON(workflowIntegrationStatus: WorkflowIntegrationStatus): string {
  return JSON.stringify(WorkflowIntegrationStatus$outboundSchema.parse(workflowIntegrationStatus));
}

export function workflowIntegrationStatusFromJSON(
  jsonString: string
): SafeParseResult<WorkflowIntegrationStatus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowIntegrationStatus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowIntegrationStatus' from JSON`
  );
}

/** @internal */
export const WorkflowResponse$inboundSchema: z.ZodType<WorkflowResponse, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().optional(),
    name: z.string(),
    description: z.string(),
    active: z.boolean(),
    draft: z.boolean(),
    preferenceSettings: SubscriberPreferenceChannels$inboundSchema,
    critical: z.boolean(),
    tags: z.array(z.string()),
    steps: z.array(NotificationStepDto$inboundSchema),
    _organizationId: z.string(),
    _creatorId: z.string(),
    _environmentId: z.string(),
    triggers: z.array(NotificationTrigger$inboundSchema),
    _notificationGroupId: z.string(),
    _parentId: z.string().optional(),
    deleted: z.boolean(),
    deletedAt: z.string(),
    deletedBy: z.string(),
    notificationGroup: NotificationGroup$inboundSchema.optional(),
    data: z.lazy(() => WorkflowResponseData$inboundSchema).optional(),
    workflowIntegrationStatus: z.lazy(() => WorkflowIntegrationStatus$inboundSchema).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
      _organizationId: 'organizationId',
      _creatorId: 'creatorId',
      _environmentId: 'environmentId',
      _notificationGroupId: 'notificationGroupId',
      _parentId: 'parentId',
    });
  });

/** @internal */
export type WorkflowResponse$Outbound = {
  _id?: string | undefined;
  name: string;
  description: string;
  active: boolean;
  draft: boolean;
  preferenceSettings: SubscriberPreferenceChannels$Outbound;
  critical: boolean;
  tags: Array<string>;
  steps: Array<NotificationStepDto$Outbound>;
  _organizationId: string;
  _creatorId: string;
  _environmentId: string;
  triggers: Array<NotificationTrigger$Outbound>;
  _notificationGroupId: string;
  _parentId?: string | undefined;
  deleted: boolean;
  deletedAt: string;
  deletedBy: string;
  notificationGroup?: NotificationGroup$Outbound | undefined;
  data?: WorkflowResponseData$Outbound | undefined;
  workflowIntegrationStatus?: WorkflowIntegrationStatus$Outbound | undefined;
};

/** @internal */
export const WorkflowResponse$outboundSchema: z.ZodType<WorkflowResponse$Outbound, z.ZodTypeDef, WorkflowResponse> = z
  .object({
    id: z.string().optional(),
    name: z.string(),
    description: z.string(),
    active: z.boolean(),
    draft: z.boolean(),
    preferenceSettings: SubscriberPreferenceChannels$outboundSchema,
    critical: z.boolean(),
    tags: z.array(z.string()),
    steps: z.array(NotificationStepDto$outboundSchema),
    organizationId: z.string(),
    creatorId: z.string(),
    environmentId: z.string(),
    triggers: z.array(NotificationTrigger$outboundSchema),
    notificationGroupId: z.string(),
    parentId: z.string().optional(),
    deleted: z.boolean(),
    deletedAt: z.string(),
    deletedBy: z.string(),
    notificationGroup: NotificationGroup$outboundSchema.optional(),
    data: z.lazy(() => WorkflowResponseData$outboundSchema).optional(),
    workflowIntegrationStatus: z.lazy(() => WorkflowIntegrationStatus$outboundSchema).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
      organizationId: '_organizationId',
      creatorId: '_creatorId',
      environmentId: '_environmentId',
      notificationGroupId: '_notificationGroupId',
      parentId: '_parentId',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowResponse$ {
  /** @deprecated use `WorkflowResponse$inboundSchema` instead. */
  export const inboundSchema = WorkflowResponse$inboundSchema;
  /** @deprecated use `WorkflowResponse$outboundSchema` instead. */
  export const outboundSchema = WorkflowResponse$outboundSchema;
  /** @deprecated use `WorkflowResponse$Outbound` instead. */
  export type Outbound = WorkflowResponse$Outbound;
}

export function workflowResponseToJSON(workflowResponse: WorkflowResponse): string {
  return JSON.stringify(WorkflowResponse$outboundSchema.parse(workflowResponse));
}

export function workflowResponseFromJSON(jsonString: string): SafeParseResult<WorkflowResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowResponseDataToJSON(workflowResponseData: WorkflowResponseData)
 - workflowResponseDataFromJSON(jsonString: string)
 - workflowIntegrationStatusToJSON(workflowIntegrationStatus: WorkflowIntegrationStatus)
 - workflowIntegrationStatusFromJSON(jsonString: string)
 - workflowResponseToJSON(workflowResponse: WorkflowResponse)
 - workflowResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowResponseData$Outbound;
}

export function workflowResponseDataToJSON(workflowResponseData: W...)
 - Outbound(WorkflowIntegrationStatus$Outbound;
}

export function workflowIntegrationStatusToJSON(workflowInteg...)
 - Outbound(WorkflowResponse$Outbound;
}

export function workflowResponseToJSON(workflowResponse: WorkflowRespo...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowResponseDataToJSON
- export function workflowResponseDataFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowIntegrationStatusToJSON
- export function workflowIntegrationStatusFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowResponseToJSON
- export function workflowResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/workflowresponsedto.ts
Tamaño: 23277 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ChatStepResponseDto,
  ChatStepResponseDto$inboundSchema,
  ChatStepResponseDto$Outbound,
  ChatStepResponseDto$outboundSchema,
} from './chatstepresponsedto.js';
import {
  CustomStepResponseDto,
  CustomStepResponseDto$inboundSchema,
  CustomStepResponseDto$Outbound,
  CustomStepResponseDto$outboundSchema,
} from './customstepresponsedto.js';
import {
  DelayStepResponseDto,
  DelayStepResponseDto$inboundSchema,
  DelayStepResponseDto$Outbound,
  DelayStepResponseDto$outboundSchema,
} from './delaystepresponsedto.js';
import {
  DigestStepResponseDto,
  DigestStepResponseDto$inboundSchema,
  DigestStepResponseDto$Outbound,
  DigestStepResponseDto$outboundSchema,
} from './digeststepresponsedto.js';
import {
  EmailStepResponseDto,
  EmailStepResponseDto$inboundSchema,
  EmailStepResponseDto$Outbound,
  EmailStepResponseDto$outboundSchema,
} from './emailstepresponsedto.js';
import {
  InAppStepResponseDto,
  InAppStepResponseDto$inboundSchema,
  InAppStepResponseDto$Outbound,
  InAppStepResponseDto$outboundSchema,
} from './inappstepresponsedto.js';
import {
  PushStepResponseDto,
  PushStepResponseDto$inboundSchema,
  PushStepResponseDto$Outbound,
  PushStepResponseDto$outboundSchema,
} from './pushstepresponsedto.js';
import {
  ResourceOriginEnum,
  ResourceOriginEnum$inboundSchema,
  ResourceOriginEnum$outboundSchema,
} from './resourceoriginenum.js';
import {
  RuntimeIssueDto,
  RuntimeIssueDto$inboundSchema,
  RuntimeIssueDto$Outbound,
  RuntimeIssueDto$outboundSchema,
} from './runtimeissuedto.js';
import {
  SeverityLevelEnum,
  SeverityLevelEnum$inboundSchema,
  SeverityLevelEnum$outboundSchema,
} from './severitylevelenum.js';
import {
  SmsStepResponseDto,
  SmsStepResponseDto$inboundSchema,
  SmsStepResponseDto$Outbound,
  SmsStepResponseDto$outboundSchema,
} from './smsstepresponsedto.js';
import {
  ThrottleStepResponseDto,
  ThrottleStepResponseDto$inboundSchema,
  ThrottleStepResponseDto$Outbound,
  ThrottleStepResponseDto$outboundSchema,
} from './throttlestepresponsedto.js';
import {
  WorkflowPreferencesResponseDto,
  WorkflowPreferencesResponseDto$inboundSchema,
  WorkflowPreferencesResponseDto$Outbound,
  WorkflowPreferencesResponseDto$outboundSchema,
} from './workflowpreferencesresponsedto.js';
import {
  WorkflowStatusEnum,
  WorkflowStatusEnum$inboundSchema,
  WorkflowStatusEnum$outboundSchema,
} from './workflowstatusenum.js';

/**
 * User who last updated the workflow
 */
export type WorkflowResponseDtoUpdatedBy = {
  /**
   * User ID
   */
  id: string;
  /**
   * User first name
   */
  firstName?: string | null | undefined;
  /**
   * User last name
   */
  lastName?: string | null | undefined;
  /**
   * User external ID
   */
  externalId?: string | null | undefined;
};

/**
 * User who last published the workflow
 */
export type LastPublishedBy = {
  /**
   * User ID
   */
  id: string;
  /**
   * User first name
   */
  firstName?: string | null | undefined;
  /**
   * User last name
   */
  lastName?: string | null | undefined;
  /**
   * User external ID
   */
  externalId?: string | null | undefined;
};

export type WorkflowResponseDtoSteps =
  | (InAppStepResponseDto & { type: 'in_app' })
  | (EmailStepResponseDto & { type: 'email' })
  | (SmsStepResponseDto & { type: 'sms' })
  | (PushStepResponseDto & { type: 'push' })
  | (ChatStepResponseDto & { type: 'chat' })
  | (DelayStepResponseDto & { type: 'delay' })
  | (DigestStepResponseDto & { type: 'digest' })
  | (CustomStepResponseDto & { type: 'custom' })
  | (ThrottleStepResponseDto & { type: 'throttle' });

export type WorkflowResponseDto = {
  /**
   * Name of the workflow
   */
  name: string;
  /**
   * Description of the workflow
   */
  description?: string | undefined;
  /**
   * Tags associated with the workflow
   */
  tags?: Array<string> | undefined;
  /**
   * Whether the workflow is active
   */
  active?: boolean | undefined;
  /**
   * Enable or disable payload schema validation
   */
  validatePayload?: boolean | undefined;
  /**
   * The payload JSON Schema for the workflow
   */
  payloadSchema?: { [k: string]: any } | null | undefined;
  /**
   * Enable or disable translations for this workflow
   */
  isTranslationEnabled?: boolean | undefined;
  /**
   * Database identifier of the workflow
   */
  id: string;
  /**
   * Workflow identifier
   */
  workflowId: string;
  /**
   * Slug of the workflow
   */
  slug: string;
  /**
   * Last updated timestamp
   */
  updatedAt: string;
  /**
   * Creation timestamp
   */
  createdAt: string;
  /**
   * User who last updated the workflow
   */
  updatedBy?: WorkflowResponseDtoUpdatedBy | null | undefined;
  /**
   * Timestamp of the last workflow publication
   */
  lastPublishedAt?: string | null | undefined;
  /**
   * User who last published the workflow
   */
  lastPublishedBy?: LastPublishedBy | null | undefined;
  /**
   * Steps of the workflow
   */
  steps: Array<
    | (InAppStepResponseDto & { type: 'in_app' })
    | (EmailStepResponseDto & { type: 'email' })
    | (SmsStepResponseDto & { type: 'sms' })
    | (PushStepResponseDto & { type: 'push' })
    | (ChatStepResponseDto & { type: 'chat' })
    | (DelayStepResponseDto & { type: 'delay' })
    | (DigestStepResponseDto & { type: 'digest' })
    | (CustomStepResponseDto & { type: 'custom' })
    | (ThrottleStepResponseDto & { type: 'throttle' })
  >;
  /**
   * Origin of the layout
   */
  origin: ResourceOriginEnum;
  /**
   * Preferences for the workflow
   */
  preferences: WorkflowPreferencesResponseDto;
  /**
   * Status of the workflow
   */
  status: WorkflowStatusEnum;
  /**
   * Runtime issues for workflow creation and update
   */
  issues?: { [k: string]: RuntimeIssueDto } | undefined;
  /**
   * Timestamp of the last workflow trigger
   */
  lastTriggeredAt?: string | null | undefined;
  /**
   * Generated payload example based on the payload schema
   */
  payloadExample?: { [k: string]: any } | null | undefined;
  /**
   * Severity of the workflow
   */
  severity: SeverityLevelEnum;
};

/** @internal */
export const WorkflowResponseDtoUpdatedBy$inboundSchema: z.ZodType<
  WorkflowResponseDtoUpdatedBy,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    _id: z.string(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    externalId: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type WorkflowResponseDtoUpdatedBy$Outbound = {
  _id: string;
  firstName?: string | null | undefined;
  lastName?: string | null | undefined;
  externalId?: string | null | undefined;
};

/** @internal */
export const WorkflowResponseDtoUpdatedBy$outboundSchema: z.ZodType<
  WorkflowResponseDtoUpdatedBy$Outbound,
  z.ZodTypeDef,
  WorkflowResponseDtoUpdatedBy
> = z
  .object({
    id: z.string(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    externalId: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowResponseDtoUpdatedBy$ {
  /** @deprecated use `WorkflowResponseDtoUpdatedBy$inboundSchema` instead. */
  export const inboundSchema = WorkflowResponseDtoUpdatedBy$inboundSchema;
  /** @deprecated use `WorkflowResponseDtoUpdatedBy$outboundSchema` instead. */
  export const outboundSchema = WorkflowResponseDtoUpdatedBy$outboundSchema;
  /** @deprecated use `WorkflowResponseDtoUpdatedBy$Outbound` instead. */
  export type Outbound = WorkflowResponseDtoUpdatedBy$Outbound;
}

export function workflowResponseDtoUpdatedByToJSON(workflowResponseDtoUpdatedBy: WorkflowResponseDtoUpdatedBy): string {
  return JSON.stringify(WorkflowResponseDtoUpdatedBy$outboundSchema.parse(workflowResponseDtoUpdatedBy));
}

export function workflowResponseDtoUpdatedByFromJSON(
  jsonString: string
): SafeParseResult<WorkflowResponseDtoUpdatedBy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowResponseDtoUpdatedBy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowResponseDtoUpdatedBy' from JSON`
  );
}

/** @internal */
export const LastPublishedBy$inboundSchema: z.ZodType<LastPublishedBy, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    externalId: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type LastPublishedBy$Outbound = {
  _id: string;
  firstName?: string | null | undefined;
  lastName?: string | null | undefined;
  externalId?: string | null | undefined;
};

/** @internal */
export const LastPublishedBy$outboundSchema: z.ZodType<LastPublishedBy$Outbound, z.ZodTypeDef, LastPublishedBy> = z
  .object({
    id: z.string(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    externalId: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LastPublishedBy$ {
  /** @deprecated use `LastPublishedBy$inboundSchema` instead. */
  export const inboundSchema = LastPublishedBy$inboundSchema;
  /** @deprecated use `LastPublishedBy$outboundSchema` instead. */
  export const outboundSchema = LastPublishedBy$outboundSchema;
  /** @deprecated use `LastPublishedBy$Outbound` instead. */
  export type Outbound = LastPublishedBy$Outbound;
}

export function lastPublishedByToJSON(lastPublishedBy: LastPublishedBy): string {
  return JSON.stringify(LastPublishedBy$outboundSchema.parse(lastPublishedBy));
}

export function lastPublishedByFromJSON(jsonString: string): SafeParseResult<LastPublishedBy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LastPublishedBy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LastPublishedBy' from JSON`
  );
}

/** @internal */
export const WorkflowResponseDtoSteps$inboundSchema: z.ZodType<WorkflowResponseDtoSteps, z.ZodTypeDef, unknown> =
  z.union([
    InAppStepResponseDto$inboundSchema.and(
      z.object({ type: z.literal('in_app') }).transform((v) => ({
        type: v.type,
      }))
    ),
    EmailStepResponseDto$inboundSchema.and(z.object({ type: z.literal('email') }).transform((v) => ({ type: v.type }))),
    SmsStepResponseDto$inboundSchema.and(z.object({ type: z.literal('sms') }).transform((v) => ({ type: v.type }))),
    PushStepResponseDto$inboundSchema.and(z.object({ type: z.literal('push') }).transform((v) => ({ type: v.type }))),
    ChatStepResponseDto$inboundSchema.and(z.object({ type: z.literal('chat') }).transform((v) => ({ type: v.type }))),
    DelayStepResponseDto$inboundSchema.and(z.object({ type: z.literal('delay') }).transform((v) => ({ type: v.type }))),
    DigestStepResponseDto$inboundSchema.and(
      z.object({ type: z.literal('digest') }).transform((v) => ({
        type: v.type,
      }))
    ),
    CustomStepResponseDto$inboundSchema.and(
      z.object({ type: z.literal('custom') }).transform((v) => ({
        type: v.type,
      }))
    ),
    ThrottleStepResponseDto$inboundSchema.and(
      z.object({ type: z.literal('throttle') }).transform((v) => ({
        type: v.type,
      }))
    ),
  ]);

/** @internal */
export type WorkflowResponseDtoSteps$Outbound =
  | (InAppStepResponseDto$Outbound & { type: 'in_app' })
  | (EmailStepResponseDto$Outbound & { type: 'email' })
  | (SmsStepResponseDto$Outbound & { type: 'sms' })
  | (PushStepResponseDto$Outbound & { type: 'push' })
  | (ChatStepResponseDto$Outbound & { type: 'chat' })
  | (DelayStepResponseDto$Outbound & { type: 'delay' })
  | (DigestStepResponseDto$Outbound & { type: 'digest' })
  | (CustomStepResponseDto$Outbound & { type: 'custom' })
  | (ThrottleStepResponseDto$Outbound & { type: 'throttle' });

/** @internal */
export const WorkflowResponseDtoSteps$outboundSchema: z.ZodType<
  WorkflowResponseDtoSteps$Outbound,
  z.ZodTypeDef,
  WorkflowResponseDtoSteps
> = z.union([
  InAppStepResponseDto$outboundSchema.and(
    z.object({ type: z.literal('in_app') }).transform((v) => ({
      type: v.type,
    }))
  ),
  EmailStepResponseDto$outboundSchema.and(z.object({ type: z.literal('email') }).transform((v) => ({ type: v.type }))),
  SmsStepResponseDto$outboundSchema.and(z.object({ type: z.literal('sms') }).transform((v) => ({ type: v.type }))),
  PushStepResponseDto$outboundSchema.and(z.object({ type: z.literal('push') }).transform((v) => ({ type: v.type }))),
  ChatStepResponseDto$outboundSchema.and(z.object({ type: z.literal('chat') }).transform((v) => ({ type: v.type }))),
  DelayStepResponseDto$outboundSchema.and(z.object({ type: z.literal('delay') }).transform((v) => ({ type: v.type }))),
  DigestStepResponseDto$outboundSchema.and(
    z.object({ type: z.literal('digest') }).transform((v) => ({
      type: v.type,
    }))
  ),
  CustomStepResponseDto$outboundSchema.and(
    z.object({ type: z.literal('custom') }).transform((v) => ({
      type: v.type,
    }))
  ),
  ThrottleStepResponseDto$outboundSchema.and(
    z.object({ type: z.literal('throttle') }).transform((v) => ({
      type: v.type,
    }))
  ),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowResponseDtoSteps$ {
  /** @deprecated use `WorkflowResponseDtoSteps$inboundSchema` instead. */
  export const inboundSchema = WorkflowResponseDtoSteps$inboundSchema;
  /** @deprecated use `WorkflowResponseDtoSteps$outboundSchema` instead. */
  export const outboundSchema = WorkflowResponseDtoSteps$outboundSchema;
  /** @deprecated use `WorkflowResponseDtoSteps$Outbound` instead. */
  export type Outbound = WorkflowResponseDtoSteps$Outbound;
}

export function workflowResponseDtoStepsToJSON(workflowResponseDtoSteps: WorkflowResponseDtoSteps): string {
  return JSON.stringify(WorkflowResponseDtoSteps$outboundSchema.parse(workflowResponseDtoSteps));
}

export function workflowResponseDtoStepsFromJSON(
  jsonString: string
): SafeParseResult<WorkflowResponseDtoSteps, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowResponseDtoSteps$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowResponseDtoSteps' from JSON`
  );
}

/** @internal */
export const WorkflowResponseDto$inboundSchema: z.ZodType<WorkflowResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    name: z.string(),
    description: z.string().optional(),
    tags: z.array(z.string()).optional(),
    active: z.boolean().default(false),
    validatePayload: z.boolean().optional(),
    payloadSchema: z.nullable(z.record(z.any())).optional(),
    isTranslationEnabled: z.boolean().default(false),
    _id: z.string(),
    workflowId: z.string(),
    slug: z.string(),
    updatedAt: z.string(),
    createdAt: z.string(),
    updatedBy: z.nullable(z.lazy(() => WorkflowResponseDtoUpdatedBy$inboundSchema)).optional(),
    lastPublishedAt: z.nullable(z.string()).optional(),
    lastPublishedBy: z.nullable(z.lazy(() => LastPublishedBy$inboundSchema)).optional(),
    steps: z.array(
      z.union([
        InAppStepResponseDto$inboundSchema.and(
          z.object({ type: z.literal('in_app') }).transform((v) => ({
            type: v.type,
          }))
        ),
        EmailStepResponseDto$inboundSchema.and(
          z.object({ type: z.literal('email') }).transform((v) => ({
            type: v.type,
          }))
        ),
        SmsStepResponseDto$inboundSchema.and(
          z.object({ type: z.literal('sms') }).transform((v) => ({
            type: v.type,
          }))
        ),
        PushStepResponseDto$inboundSchema.and(
          z.object({ type: z.literal('push') }).transform((v) => ({
            type: v.type,
          }))
        ),
        ChatStepResponseDto$inboundSchema.and(
          z.object({ type: z.literal('chat') }).transform((v) => ({
            type: v.type,
          }))
        ),
        DelayStepResponseDto$inboundSchema.and(
          z.object({ type: z.literal('delay') }).transform((v) => ({
            type: v.type,
          }))
        ),
        DigestStepResponseDto$inboundSchema.and(
          z.object({ type: z.literal('digest') }).transform((v) => ({
            type: v.type,
          }))
        ),
        CustomStepResponseDto$inboundSchema.and(
          z.object({ type: z.literal('custom') }).transform((v) => ({
            type: v.type,
          }))
        ),
        ThrottleStepResponseDto$inboundSchema.and(
          z.object({ type: z.literal('throttle') }).transform((v) => ({
            type: v.type,
          }))
        ),
      ])
    ),
    origin: ResourceOriginEnum$inboundSchema,
    preferences: WorkflowPreferencesResponseDto$inboundSchema,
    status: WorkflowStatusEnum$inboundSchema,
    issues: z.record(RuntimeIssueDto$inboundSchema).optional(),
    lastTriggeredAt: z.nullable(z.string()).optional(),
    payloadExample: z.nullable(z.record(z.any())).optional(),
    severity: SeverityLevelEnum$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type WorkflowResponseDto$Outbound = {
  name: string;
  description?: string | undefined;
  tags?: Array<string> | undefined;
  active: boolean;
  validatePayload?: boolean | undefined;
  payloadSchema?: { [k: string]: any } | null | undefined;
  isTranslationEnabled: boolean;
  _id: string;
  workflowId: string;
  slug: string;
  updatedAt: string;
  createdAt: string;
  updatedBy?: WorkflowResponseDtoUpdatedBy$Outbound | null | undefined;
  lastPublishedAt?: string | null | undefined;
  lastPublishedBy?: LastPublishedBy$Outbound | null | undefined;
  steps: Array<
    | (InAppStepResponseDto$Outbound & { type: 'in_app' })
    | (EmailStepResponseDto$Outbound & { type: 'email' })
    | (SmsStepResponseDto$Outbound & { type: 'sms' })
    | (PushStepResponseDto$Outbound & { type: 'push' })
    | (ChatStepResponseDto$Outbound & { type: 'chat' })
    | (DelayStepResponseDto$Outbound & { type: 'delay' })
    | (DigestStepResponseDto$Outbound & { type: 'digest' })
    | (CustomStepResponseDto$Outbound & { type: 'custom' })
    | (ThrottleStepResponseDto$Outbound & { type: 'throttle' })
  >;
  origin: string;
  preferences: WorkflowPreferencesResponseDto$Outbound;
  status: string;
  issues?: { [k: string]: RuntimeIssueDto$Outbound } | undefined;
  lastTriggeredAt?: string | null | undefined;
  payloadExample?: { [k: string]: any } | null | undefined;
  severity: string;
};

/** @internal */
export const WorkflowResponseDto$outboundSchema: z.ZodType<
  WorkflowResponseDto$Outbound,
  z.ZodTypeDef,
  WorkflowResponseDto
> = z
  .object({
    name: z.string(),
    description: z.string().optional(),
    tags: z.array(z.string()).optional(),
    active: z.boolean().default(false),
    validatePayload: z.boolean().optional(),
    payloadSchema: z.nullable(z.record(z.any())).optional(),
    isTranslationEnabled: z.boolean().default(false),
    id: z.string(),
    workflowId: z.string(),
    slug: z.string(),
    updatedAt: z.string(),
    createdAt: z.string(),
    updatedBy: z.nullable(z.lazy(() => WorkflowResponseDtoUpdatedBy$outboundSchema)).optional(),
    lastPublishedAt: z.nullable(z.string()).optional(),
    lastPublishedBy: z.nullable(z.lazy(() => LastPublishedBy$outboundSchema)).optional(),
    steps: z.array(
      z.union([
        InAppStepResponseDto$outboundSchema.and(
          z.object({ type: z.literal('in_app') }).transform((v) => ({
            type: v.type,
          }))
        ),
        EmailStepResponseDto$outboundSchema.and(
          z.object({ type: z.literal('email') }).transform((v) => ({
            type: v.type,
          }))
        ),
        SmsStepResponseDto$outboundSchema.and(
          z.object({ type: z.literal('sms') }).transform((v) => ({
            type: v.type,
          }))
        ),
        PushStepResponseDto$outboundSchema.and(
          z.object({ type: z.literal('push') }).transform((v) => ({
            type: v.type,
          }))
        ),
        ChatStepResponseDto$outboundSchema.and(
          z.object({ type: z.literal('chat') }).transform((v) => ({
            type: v.type,
          }))
        ),
        DelayStepResponseDto$outboundSchema.and(
          z.object({ type: z.literal('delay') }).transform((v) => ({
            type: v.type,
          }))
        ),
        DigestStepResponseDto$outboundSchema.and(
          z.object({ type: z.literal('digest') }).transform((v) => ({
            type: v.type,
          }))
        ),
        CustomStepResponseDto$outboundSchema.and(
          z.object({ type: z.literal('custom') }).transform((v) => ({
            type: v.type,
          }))
        ),
        ThrottleStepResponseDto$outboundSchema.and(
          z.object({ type: z.literal('throttle') }).transform((v) => ({
            type: v.type,
          }))
        ),
      ])
    ),
    origin: ResourceOriginEnum$outboundSchema,
    preferences: WorkflowPreferencesResponseDto$outboundSchema,
    status: WorkflowStatusEnum$outboundSchema,
    issues: z.record(RuntimeIssueDto$outboundSchema).optional(),
    lastTriggeredAt: z.nullable(z.string()).optional(),
    payloadExample: z.nullable(z.record(z.any())).optional(),
    severity: SeverityLevelEnum$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowResponseDto$ {
  /** @deprecated use `WorkflowResponseDto$inboundSchema` instead. */
  export const inboundSchema = WorkflowResponseDto$inboundSchema;
  /** @deprecated use `WorkflowResponseDto$outboundSchema` instead. */
  export const outboundSchema = WorkflowResponseDto$outboundSchema;
  /** @deprecated use `WorkflowResponseDto$Outbound` instead. */
  export type Outbound = WorkflowResponseDto$Outbound;
}

export function workflowResponseDtoToJSON(workflowResponseDto: WorkflowResponseDto): string {
  return JSON.stringify(WorkflowResponseDto$outboundSchema.parse(workflowResponseDto));
}

export function workflowResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<WorkflowResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowResponseDtoUpdatedByToJSON(workflowResponseDtoUpdatedBy: WorkflowResponseDtoUpdatedBy)
 - workflowResponseDtoUpdatedByFromJSON(jsonString: string)
 - lastPublishedByToJSON(lastPublishedBy: LastPublishedBy)
 - lastPublishedByFromJSON(jsonString: string)
 - workflowResponseDtoStepsToJSON(workflowResponseDtoSteps: WorkflowResponseDtoSteps)
 - workflowResponseDtoStepsFromJSON(jsonString: string)
 - workflowResponseDtoToJSON(workflowResponseDto: WorkflowResponseDto)
 - workflowResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowResponseDtoUpdatedBy$Outbound;
}

export function workflowResponseDtoUpdatedByToJSON(workflo...)
 - Outbound(LastPublishedBy$Outbound;
}

export function lastPublishedByToJSON(lastPublishedBy: LastPublishedBy)...)
 - Outbound(WorkflowResponseDtoSteps$Outbound;
}

export function workflowResponseDtoStepsToJSON(workflowRespons...)
 - Outbound(WorkflowResponseDto$Outbound;
}

export function workflowResponseDtoToJSON(workflowResponseDto: Work...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowResponseDtoUpdatedByToJSON
- export function workflowResponseDtoUpdatedByFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function lastPublishedByToJSON
- export function lastPublishedByFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowResponseDtoStepsToJSON
- export function workflowResponseDtoStepsFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowResponseDtoToJSON
- export function workflowResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/workflowresponsedtosortfield.ts
Tamaño: 1284 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

export const WorkflowResponseDtoSortField = {
  CreatedAt: 'createdAt',
  UpdatedAt: 'updatedAt',
  Name: 'name',
  LastTriggeredAt: 'lastTriggeredAt',
} as const;
export type WorkflowResponseDtoSortField = ClosedEnum<typeof WorkflowResponseDtoSortField>;

/** @internal */
export const WorkflowResponseDtoSortField$inboundSchema: z.ZodNativeEnum<typeof WorkflowResponseDtoSortField> =
  z.nativeEnum(WorkflowResponseDtoSortField);

/** @internal */
export const WorkflowResponseDtoSortField$outboundSchema: z.ZodNativeEnum<typeof WorkflowResponseDtoSortField> =
  WorkflowResponseDtoSortField$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowResponseDtoSortField$ {
  /** @deprecated use `WorkflowResponseDtoSortField$inboundSchema` instead. */
  export const inboundSchema = WorkflowResponseDtoSortField$inboundSchema;
  /** @deprecated use `WorkflowResponseDtoSortField$outboundSchema` instead. */
  export const outboundSchema = WorkflowResponseDtoSortField$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/workflowrunstepsdetailsdto.ts
Tamaño: 3863 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Step status
 */
export const WorkflowRunStepsDetailsDtoStatus = {
  Pending: 'pending',
  Queued: 'queued',
  Running: 'running',
  Completed: 'completed',
  Failed: 'failed',
  Delayed: 'delayed',
  Canceled: 'canceled',
  Merged: 'merged',
  Skipped: 'skipped',
} as const;
/**
 * Step status
 */
export type WorkflowRunStepsDetailsDtoStatus = ClosedEnum<typeof WorkflowRunStepsDetailsDtoStatus>;

export type WorkflowRunStepsDetailsDto = {
  /**
   * Step run identifier
   */
  id: string;
  /**
   * Step identifier
   */
  stepRunId: string;
  /**
   * Step type
   */
  stepType: string;
  /**
   * Step status
   */
  status: WorkflowRunStepsDetailsDtoStatus;
};

/** @internal */
export const WorkflowRunStepsDetailsDtoStatus$inboundSchema: z.ZodNativeEnum<typeof WorkflowRunStepsDetailsDtoStatus> =
  z.nativeEnum(WorkflowRunStepsDetailsDtoStatus);

/** @internal */
export const WorkflowRunStepsDetailsDtoStatus$outboundSchema: z.ZodNativeEnum<typeof WorkflowRunStepsDetailsDtoStatus> =
  WorkflowRunStepsDetailsDtoStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowRunStepsDetailsDtoStatus$ {
  /** @deprecated use `WorkflowRunStepsDetailsDtoStatus$inboundSchema` instead. */
  export const inboundSchema = WorkflowRunStepsDetailsDtoStatus$inboundSchema;
  /** @deprecated use `WorkflowRunStepsDetailsDtoStatus$outboundSchema` instead. */
  export const outboundSchema = WorkflowRunStepsDetailsDtoStatus$outboundSchema;
}

/** @internal */
export const WorkflowRunStepsDetailsDto$inboundSchema: z.ZodType<WorkflowRunStepsDetailsDto, z.ZodTypeDef, unknown> =
  z.object({
    id: z.string(),
    stepRunId: z.string(),
    stepType: z.string(),
    status: WorkflowRunStepsDetailsDtoStatus$inboundSchema,
  });

/** @internal */
export type WorkflowRunStepsDetailsDto$Outbound = {
  id: string;
  stepRunId: string;
  stepType: string;
  status: string;
};

/** @internal */
export const WorkflowRunStepsDetailsDto$outboundSchema: z.ZodType<
  WorkflowRunStepsDetailsDto$Outbound,
  z.ZodTypeDef,
  WorkflowRunStepsDetailsDto
> = z.object({
  id: z.string(),
  stepRunId: z.string(),
  stepType: z.string(),
  status: WorkflowRunStepsDetailsDtoStatus$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowRunStepsDetailsDto$ {
  /** @deprecated use `WorkflowRunStepsDetailsDto$inboundSchema` instead. */
  export const inboundSchema = WorkflowRunStepsDetailsDto$inboundSchema;
  /** @deprecated use `WorkflowRunStepsDetailsDto$outboundSchema` instead. */
  export const outboundSchema = WorkflowRunStepsDetailsDto$outboundSchema;
  /** @deprecated use `WorkflowRunStepsDetailsDto$Outbound` instead. */
  export type Outbound = WorkflowRunStepsDetailsDto$Outbound;
}

export function workflowRunStepsDetailsDtoToJSON(workflowRunStepsDetailsDto: WorkflowRunStepsDetailsDto): string {
  return JSON.stringify(WorkflowRunStepsDetailsDto$outboundSchema.parse(workflowRunStepsDetailsDto));
}

export function workflowRunStepsDetailsDtoFromJSON(
  jsonString: string
): SafeParseResult<WorkflowRunStepsDetailsDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowRunStepsDetailsDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowRunStepsDetailsDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowRunStepsDetailsDtoToJSON(workflowRunStepsDetailsDto: WorkflowRunStepsDetailsDto)
 - workflowRunStepsDetailsDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowRunStepsDetailsDto$Outbound;
}

export function workflowRunStepsDetailsDtoToJSON(workflowRun...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowRunStepsDetailsDtoToJSON
- export function workflowRunStepsDetailsDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/workflowstatusenum.ts
Tamaño: 1168 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Status of the workflow
 */
export const WorkflowStatusEnum = {
  Active: 'ACTIVE',
  Inactive: 'INACTIVE',
  Error: 'ERROR',
} as const;
/**
 * Status of the workflow
 */
export type WorkflowStatusEnum = ClosedEnum<typeof WorkflowStatusEnum>;

/** @internal */
export const WorkflowStatusEnum$inboundSchema: z.ZodNativeEnum<typeof WorkflowStatusEnum> =
  z.nativeEnum(WorkflowStatusEnum);

/** @internal */
export const WorkflowStatusEnum$outboundSchema: z.ZodNativeEnum<typeof WorkflowStatusEnum> =
  WorkflowStatusEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowStatusEnum$ {
  /** @deprecated use `WorkflowStatusEnum$inboundSchema` instead. */
  export const inboundSchema = WorkflowStatusEnum$inboundSchema;
  /** @deprecated use `WorkflowStatusEnum$outboundSchema` instead. */
  export const outboundSchema = WorkflowStatusEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/errors/errordto.ts
Tamaño: 8739 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { NovuError } from './novuerror.js';
import { SDKValidationError } from './sdkvalidationerror.js';

export type Five = string | number | boolean | { [k: string]: any };

export type Four = {};

/**
 * Value that failed validation
 */
export type Message = string | number | boolean | Four | Array<string | number | boolean | { [k: string]: any } | null>;

export type ErrorDtoData = {
  /**
   * HTTP status code of the error response.
   */
  statusCode: number;
  /**
   * Timestamp of when the error occurred.
   */
  timestamp: string;
  /**
   * The path where the error occurred.
   */
  path: string;
  /**
   * Value that failed validation
   */
  message?:
    | string
    | number
    | boolean
    | Four
    | Array<string | number | boolean | { [k: string]: any } | null>
    | null
    | undefined;
  /**
   * Optional context object for additional error details.
   */
  ctx?: { [k: string]: any } | undefined;
  /**
   * Optional unique identifier for the error, useful for tracking using Sentry and
   *
   * @remarks
   *       New Relic, only available for 500.
   */
  errorId?: string | undefined;
};

export class ErrorDto extends NovuError {
  /**
   * Timestamp of when the error occurred.
   */
  timestamp: string;
  /**
   * The path where the error occurred.
   */
  path: string;
  /**
   * Optional context object for additional error details.
   */
  ctx?: { [k: string]: any } | undefined;
  /**
   * Optional unique identifier for the error, useful for tracking using Sentry and
   *
   * @remarks
   *       New Relic, only available for 500.
   */
  errorId?: string | undefined;

  /** The original data that was passed to this error instance. */
  data$: ErrorDtoData;

  constructor(err: ErrorDtoData, httpMeta: { response: Response; request: Request; body: string }) {
    const message =
      'message' in err && typeof err.message === 'string' ? err.message : `API error occurred: ${JSON.stringify(err)}`;
    super(message, httpMeta);
    this.data$ = err;
    this.timestamp = err.timestamp;
    this.path = err.path;
    if (err.ctx != null) this.ctx = err.ctx;
    if (err.errorId != null) this.errorId = err.errorId;

    this.name = 'ErrorDto';
  }
}

/** @internal */
export const Five$inboundSchema: z.ZodType<Five, z.ZodTypeDef, unknown> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.record(z.any()),
]);

/** @internal */
export type Five$Outbound = string | number | boolean | { [k: string]: any };

/** @internal */
export const Five$outboundSchema: z.ZodType<Five$Outbound, z.ZodTypeDef, Five> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.record(z.any()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Five$ {
  /** @deprecated use `Five$inboundSchema` instead. */
  export const inboundSchema = Five$inboundSchema;
  /** @deprecated use `Five$outboundSchema` instead. */
  export const outboundSchema = Five$outboundSchema;
  /** @deprecated use `Five$Outbound` instead. */
  export type Outbound = Five$Outbound;
}

export function fiveToJSON(five: Five): string {
  return JSON.stringify(Five$outboundSchema.parse(five));
}

export function fiveFromJSON(jsonString: string): SafeParseResult<Five, SDKValidationError> {
  return safeParse(jsonString, (x) => Five$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Five' from JSON`);
}

/** @internal */
export const Four$inboundSchema: z.ZodType<Four, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type Four$Outbound = {};

/** @internal */
export const Four$outboundSchema: z.ZodType<Four$Outbound, z.ZodTypeDef, Four> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Four$ {
  /** @deprecated use `Four$inboundSchema` instead. */
  export const inboundSchema = Four$inboundSchema;
  /** @deprecated use `Four$outboundSchema` instead. */
  export const outboundSchema = Four$outboundSchema;
  /** @deprecated use `Four$Outbound` instead. */
  export type Outbound = Four$Outbound;
}

export function fourToJSON(four: Four): string {
  return JSON.stringify(Four$outboundSchema.parse(four));
}

export function fourFromJSON(jsonString: string): SafeParseResult<Four, SDKValidationError> {
  return safeParse(jsonString, (x) => Four$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Four' from JSON`);
}

/** @internal */
export const Message$inboundSchema: z.ZodType<Message, z.ZodTypeDef, unknown> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.lazy(() => Four$inboundSchema),
  z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
]);

/** @internal */
export type Message$Outbound =
  | string
  | number
  | boolean
  | Four$Outbound
  | Array<string | number | boolean | { [k: string]: any } | null>;

/** @internal */
export const Message$outboundSchema: z.ZodType<Message$Outbound, z.ZodTypeDef, Message> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.lazy(() => Four$outboundSchema),
  z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Message$ {
  /** @deprecated use `Message$inboundSchema` instead. */
  export const inboundSchema = Message$inboundSchema;
  /** @deprecated use `Message$outboundSchema` instead. */
  export const outboundSchema = Message$outboundSchema;
  /** @deprecated use `Message$Outbound` instead. */
  export type Outbound = Message$Outbound;
}

export function messageToJSON(message: Message): string {
  return JSON.stringify(Message$outboundSchema.parse(message));
}

export function messageFromJSON(jsonString: string): SafeParseResult<Message, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Message$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Message' from JSON`
  );
}

/** @internal */
export const ErrorDto$inboundSchema: z.ZodType<ErrorDto, z.ZodTypeDef, unknown> = z
  .object({
    statusCode: z.number(),
    timestamp: z.string(),
    path: z.string(),
    message: z
      .nullable(
        z.union([
          z.string(),
          z.number(),
          z.boolean(),
          z.lazy(() => Four$inboundSchema),
          z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
        ])
      )
      .optional(),
    ctx: z.record(z.any()).optional(),
    errorId: z.string().optional(),
    request$: z.instanceof(Request),
    response$: z.instanceof(Response),
    body$: z.string(),
  })
  .transform((v) => {
    return new ErrorDto(v, {
      request: v.request$,
      response: v.response$,
      body: v.body$,
    });
  });

/** @internal */
export type ErrorDto$Outbound = {
  statusCode: number;
  timestamp: string;
  path: string;
  message?:
    | string
    | number
    | boolean
    | Four$Outbound
    | Array<string | number | boolean | { [k: string]: any } | null>
    | null
    | undefined;
  ctx?: { [k: string]: any } | undefined;
  errorId?: string | undefined;
};

/** @internal */
export const ErrorDto$outboundSchema: z.ZodType<ErrorDto$Outbound, z.ZodTypeDef, ErrorDto> = z
  .instanceof(ErrorDto)
  .transform((v) => v.data$)
  .pipe(
    z.object({
      statusCode: z.number(),
      timestamp: z.string(),
      path: z.string(),
      message: z
        .nullable(
          z.union([
            z.string(),
            z.number(),
            z.boolean(),
            z.lazy(() => Four$outboundSchema),
            z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
          ])
        )
        .optional(),
      ctx: z.record(z.any()).optional(),
      errorId: z.string().optional(),
    })
  );

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ErrorDto$ {
  /** @deprecated use `ErrorDto$inboundSchema` instead. */
  export const inboundSchema = ErrorDto$inboundSchema;
  /** @deprecated use `ErrorDto$outboundSchema` instead. */
  export const outboundSchema = ErrorDto$outboundSchema;
  /** @deprecated use `ErrorDto$Outbound` instead. */
  export type Outbound = ErrorDto$Outbound;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - fiveToJSON(five: Five)
 - fiveFromJSON(jsonString: string)
 - fourToJSON(four: Four)
 - fourFromJSON(jsonString: string)
 - messageToJSON(message: Message)
 - messageFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Five$Outbound;
}

export function fiveToJSON(five: Five): string {
  return JSON.stringify(Five$outb...)
 - Outbound(Four$Outbound;
}

export function fourToJSON(four: Four): string {
  return JSON.stringify(Four$outb...)
 - Outbound(Message$Outbound;
}

export function messageToJSON(message: Message): string {
  return JSON.stringi...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export class ErrorDto
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function fiveToJSON
- export function fiveFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function fourToJSON
- export function fourFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messageToJSON
- export function messageFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/errors/httpclienterrors.ts
Tamaño: 1651 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

/**
 * Base class for all HTTP errors.
 */
export class HTTPClientError extends Error {
  /** The underlying cause of the error. */
  override readonly cause: unknown;
  override name = "HTTPClientError";
  constructor(message: string, opts?: { cause?: unknown }) {
    let msg = message;
    if (opts?.cause) {
      msg += `: ${opts.cause}`;
    }

    super(msg, opts);
    // In older runtimes, the cause field would not have been assigned through
    // the super() call.
    if (typeof this.cause === "undefined") {
      this.cause = opts?.cause;
    }
  }
}

/**
 * An error to capture unrecognised or unexpected errors when making HTTP calls.
 */
export class UnexpectedClientError extends HTTPClientError {
  override name = "UnexpectedClientError";
}

/**
 * An error that is raised when any inputs used to create a request are invalid.
 */
export class InvalidRequestError extends HTTPClientError {
  override name = "InvalidRequestError";
}

/**
 * An error that is raised when a HTTP request was aborted by the client error.
 */
export class RequestAbortedError extends HTTPClientError {
  override readonly name = "RequestAbortedError";
}

/**
 * An error that is raised when a HTTP request timed out due to an AbortSignal
 * signal timeout.
 */
export class RequestTimeoutError extends HTTPClientError {
  override readonly name = "RequestTimeoutError";
}

/**
 * An error that is raised when a HTTP client is unable to make a request to
 * a server.
 */
export class ConnectionError extends HTTPClientError {
  override readonly name = "ConnectionError";
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class HTTPClientError
- export class UnexpectedClientError
- export class InvalidRequestError
- export class RequestAbortedError
- export class RequestTimeoutError
- export class ConnectionError

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/errors/index.ts
Tamaño: 473 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

export * from "./errordto.js";
export * from "./httpclienterrors.js";
export * from "./novuerror.js";
export * from "./payloadvalidationexceptiondto.js";
export * from "./responsevalidationerror.js";
export * from "./sdkerror.js";
export * from "./sdkvalidationerror.js";
export * from "./subscriberresponsedto.js";
export * from "./topicresponsedto.js";
export * from "./validationerrordto.js";


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/errors/novuerror.ts
Tamaño: 904 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

/** The base class for all HTTP error responses */
export class NovuError extends Error {
  /** HTTP status code */
  public readonly statusCode: number;
  /** HTTP body */
  public readonly body: string;
  /** HTTP headers */
  public readonly headers: Headers;
  /** HTTP content type */
  public readonly contentType: string;
  /** Raw response */
  public readonly rawResponse: Response;

  constructor(
    message: string,
    httpMeta: {
      response: Response;
      request: Request;
      body: string;
    },
  ) {
    super(message);
    this.statusCode = httpMeta.response.status;
    this.body = httpMeta.body;
    this.headers = httpMeta.response.headers;
    this.contentType = httpMeta.response.headers.get("content-type") || "";
    this.rawResponse = httpMeta.response;

    this.name = "NovuError";
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class NovuError

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/errors/payloadvalidationexceptiondto.ts
Tamaño: 14119 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { NovuError } from './novuerror.js';
import { SDKValidationError } from './sdkvalidationerror.js';

export type MessagePayloadValidationExceptionDto5 = string | number | boolean | { [k: string]: any };

export type MessagePayloadValidationExceptionDto4 = {};

/**
 * Value that failed validation
 */
export type PayloadValidationExceptionDtoMessage =
  | string
  | number
  | boolean
  | MessagePayloadValidationExceptionDto4
  | Array<string | number | boolean | { [k: string]: any } | null>;

/**
 * The JSON schema that was used for validation
 */
export type Schema = {};

export type PayloadValidationExceptionDtoData = {
  /**
   * HTTP status code of the error response.
   */
  statusCode: number;
  /**
   * Timestamp of when the error occurred.
   */
  timestamp: string;
  /**
   * The path where the error occurred.
   */
  path: string;
  /**
   * Value that failed validation
   */
  message?:
    | string
    | number
    | boolean
    | MessagePayloadValidationExceptionDto4
    | Array<string | number | boolean | { [k: string]: any } | null>
    | null
    | undefined;
  /**
   * Optional context object for additional error details.
   */
  ctx?: { [k: string]: any } | undefined;
  /**
   * Optional unique identifier for the error, useful for tracking using Sentry and
   *
   * @remarks
   *       New Relic, only available for 500.
   */
  errorId?: string | undefined;
  /**
   * Type identifier for payload validation errors
   */
  type: string;
  /**
   * Array of detailed validation errors
   */
  errors: Array<components.PayloadValidationErrorDto>;
  /**
   * The JSON schema that was used for validation
   */
  schema?: Schema | undefined;
};

export class PayloadValidationExceptionDto extends NovuError {
  /**
   * Timestamp of when the error occurred.
   */
  timestamp: string;
  /**
   * The path where the error occurred.
   */
  path: string;
  /**
   * Optional context object for additional error details.
   */
  ctx?: { [k: string]: any } | undefined;
  /**
   * Optional unique identifier for the error, useful for tracking using Sentry and
   *
   * @remarks
   *       New Relic, only available for 500.
   */
  errorId?: string | undefined;
  /**
   * Type identifier for payload validation errors
   */
  type: string;
  /**
   * Array of detailed validation errors
   */
  errors: Array<components.PayloadValidationErrorDto>;
  /**
   * The JSON schema that was used for validation
   */
  schema?: Schema | undefined;

  /** The original data that was passed to this error instance. */
  data$: PayloadValidationExceptionDtoData;

  constructor(
    err: PayloadValidationExceptionDtoData,
    httpMeta: { response: Response; request: Request; body: string }
  ) {
    const message =
      'message' in err && typeof err.message === 'string' ? err.message : `API error occurred: ${JSON.stringify(err)}`;
    super(message, httpMeta);
    this.data$ = err;
    this.timestamp = err.timestamp;
    this.path = err.path;
    if (err.ctx != null) this.ctx = err.ctx;
    if (err.errorId != null) this.errorId = err.errorId;
    this.type = err.type;
    this.errors = err.errors;
    if (err.schema != null) this.schema = err.schema;

    this.name = 'PayloadValidationExceptionDto';
  }
}

/** @internal */
export const MessagePayloadValidationExceptionDto5$inboundSchema: z.ZodType<
  MessagePayloadValidationExceptionDto5,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]);

/** @internal */
export type MessagePayloadValidationExceptionDto5$Outbound = string | number | boolean | { [k: string]: any };

/** @internal */
export const MessagePayloadValidationExceptionDto5$outboundSchema: z.ZodType<
  MessagePayloadValidationExceptionDto5$Outbound,
  z.ZodTypeDef,
  MessagePayloadValidationExceptionDto5
> = z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessagePayloadValidationExceptionDto5$ {
  /** @deprecated use `MessagePayloadValidationExceptionDto5$inboundSchema` instead. */
  export const inboundSchema = MessagePayloadValidationExceptionDto5$inboundSchema;
  /** @deprecated use `MessagePayloadValidationExceptionDto5$outboundSchema` instead. */
  export const outboundSchema = MessagePayloadValidationExceptionDto5$outboundSchema;
  /** @deprecated use `MessagePayloadValidationExceptionDto5$Outbound` instead. */
  export type Outbound = MessagePayloadValidationExceptionDto5$Outbound;
}

export function messagePayloadValidationExceptionDto5ToJSON(
  messagePayloadValidationExceptionDto5: MessagePayloadValidationExceptionDto5
): string {
  return JSON.stringify(
    MessagePayloadValidationExceptionDto5$outboundSchema.parse(messagePayloadValidationExceptionDto5)
  );
}

export function messagePayloadValidationExceptionDto5FromJSON(
  jsonString: string
): SafeParseResult<MessagePayloadValidationExceptionDto5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagePayloadValidationExceptionDto5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagePayloadValidationExceptionDto5' from JSON`
  );
}

/** @internal */
export const MessagePayloadValidationExceptionDto4$inboundSchema: z.ZodType<
  MessagePayloadValidationExceptionDto4,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type MessagePayloadValidationExceptionDto4$Outbound = {};

/** @internal */
export const MessagePayloadValidationExceptionDto4$outboundSchema: z.ZodType<
  MessagePayloadValidationExceptionDto4$Outbound,
  z.ZodTypeDef,
  MessagePayloadValidationExceptionDto4
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessagePayloadValidationExceptionDto4$ {
  /** @deprecated use `MessagePayloadValidationExceptionDto4$inboundSchema` instead. */
  export const inboundSchema = MessagePayloadValidationExceptionDto4$inboundSchema;
  /** @deprecated use `MessagePayloadValidationExceptionDto4$outboundSchema` instead. */
  export const outboundSchema = MessagePayloadValidationExceptionDto4$outboundSchema;
  /** @deprecated use `MessagePayloadValidationExceptionDto4$Outbound` instead. */
  export type Outbound = MessagePayloadValidationExceptionDto4$Outbound;
}

export function messagePayloadValidationExceptionDto4ToJSON(
  messagePayloadValidationExceptionDto4: MessagePayloadValidationExceptionDto4
): string {
  return JSON.stringify(
    MessagePayloadValidationExceptionDto4$outboundSchema.parse(messagePayloadValidationExceptionDto4)
  );
}

export function messagePayloadValidationExceptionDto4FromJSON(
  jsonString: string
): SafeParseResult<MessagePayloadValidationExceptionDto4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagePayloadValidationExceptionDto4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagePayloadValidationExceptionDto4' from JSON`
  );
}

/** @internal */
export const PayloadValidationExceptionDtoMessage$inboundSchema: z.ZodType<
  PayloadValidationExceptionDtoMessage,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.lazy(() => MessagePayloadValidationExceptionDto4$inboundSchema),
  z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
]);

/** @internal */
export type PayloadValidationExceptionDtoMessage$Outbound =
  | string
  | number
  | boolean
  | MessagePayloadValidationExceptionDto4$Outbound
  | Array<string | number | boolean | { [k: string]: any } | null>;

/** @internal */
export const PayloadValidationExceptionDtoMessage$outboundSchema: z.ZodType<
  PayloadValidationExceptionDtoMessage$Outbound,
  z.ZodTypeDef,
  PayloadValidationExceptionDtoMessage
> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.lazy(() => MessagePayloadValidationExceptionDto4$outboundSchema),
  z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PayloadValidationExceptionDtoMessage$ {
  /** @deprecated use `PayloadValidationExceptionDtoMessage$inboundSchema` instead. */
  export const inboundSchema = PayloadValidationExceptionDtoMessage$inboundSchema;
  /** @deprecated use `PayloadValidationExceptionDtoMessage$outboundSchema` instead. */
  export const outboundSchema = PayloadValidationExceptionDtoMessage$outboundSchema;
  /** @deprecated use `PayloadValidationExceptionDtoMessage$Outbound` instead. */
  export type Outbound = PayloadValidationExceptionDtoMessage$Outbound;
}

export function payloadValidationExceptionDtoMessageToJSON(
  payloadValidationExceptionDtoMessage: PayloadValidationExceptionDtoMessage
): string {
  return JSON.stringify(
    PayloadValidationExceptionDtoMessage$outboundSchema.parse(payloadValidationExceptionDtoMessage)
  );
}

export function payloadValidationExceptionDtoMessageFromJSON(
  jsonString: string
): SafeParseResult<PayloadValidationExceptionDtoMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PayloadValidationExceptionDtoMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PayloadValidationExceptionDtoMessage' from JSON`
  );
}

/** @internal */
export const Schema$inboundSchema: z.ZodType<Schema, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type Schema$Outbound = {};

/** @internal */
export const Schema$outboundSchema: z.ZodType<Schema$Outbound, z.ZodTypeDef, Schema> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Schema$ {
  /** @deprecated use `Schema$inboundSchema` instead. */
  export const inboundSchema = Schema$inboundSchema;
  /** @deprecated use `Schema$outboundSchema` instead. */
  export const outboundSchema = Schema$outboundSchema;
  /** @deprecated use `Schema$Outbound` instead. */
  export type Outbound = Schema$Outbound;
}

export function schemaToJSON(schema: Schema): string {
  return JSON.stringify(Schema$outboundSchema.parse(schema));
}

export function schemaFromJSON(jsonString: string): SafeParseResult<Schema, SDKValidationError> {
  return safeParse(jsonString, (x) => Schema$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Schema' from JSON`);
}

/** @internal */
export const PayloadValidationExceptionDto$inboundSchema: z.ZodType<
  PayloadValidationExceptionDto,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    statusCode: z.number(),
    timestamp: z.string(),
    path: z.string(),
    message: z
      .nullable(
        z.union([
          z.string(),
          z.number(),
          z.boolean(),
          z.lazy(() => MessagePayloadValidationExceptionDto4$inboundSchema),
          z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
        ])
      )
      .optional(),
    ctx: z.record(z.any()).optional(),
    errorId: z.string().optional(),
    type: z.string(),
    errors: z.array(components.PayloadValidationErrorDto$inboundSchema),
    schema: z.lazy(() => Schema$inboundSchema).optional(),
    request$: z.instanceof(Request),
    response$: z.instanceof(Response),
    body$: z.string(),
  })
  .transform((v) => {
    return new PayloadValidationExceptionDto(v, {
      request: v.request$,
      response: v.response$,
      body: v.body$,
    });
  });

/** @internal */
export type PayloadValidationExceptionDto$Outbound = {
  statusCode: number;
  timestamp: string;
  path: string;
  message?:
    | string
    | number
    | boolean
    | MessagePayloadValidationExceptionDto4$Outbound
    | Array<string | number | boolean | { [k: string]: any } | null>
    | null
    | undefined;
  ctx?: { [k: string]: any } | undefined;
  errorId?: string | undefined;
  type: string;
  errors: Array<components.PayloadValidationErrorDto$Outbound>;
  schema?: Schema$Outbound | undefined;
};

/** @internal */
export const PayloadValidationExceptionDto$outboundSchema: z.ZodType<
  PayloadValidationExceptionDto$Outbound,
  z.ZodTypeDef,
  PayloadValidationExceptionDto
> = z
  .instanceof(PayloadValidationExceptionDto)
  .transform((v) => v.data$)
  .pipe(
    z.object({
      statusCode: z.number(),
      timestamp: z.string(),
      path: z.string(),
      message: z
        .nullable(
          z.union([
            z.string(),
            z.number(),
            z.boolean(),
            z.lazy(() => MessagePayloadValidationExceptionDto4$outboundSchema),
            z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
          ])
        )
        .optional(),
      ctx: z.record(z.any()).optional(),
      errorId: z.string().optional(),
      type: z.string(),
      errors: z.array(components.PayloadValidationErrorDto$outboundSchema),
      schema: z.lazy(() => Schema$outboundSchema).optional(),
    })
  );

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PayloadValidationExceptionDto$ {
  /** @deprecated use `PayloadValidationExceptionDto$inboundSchema` instead. */
  export const inboundSchema = PayloadValidationExceptionDto$inboundSchema;
  /** @deprecated use `PayloadValidationExceptionDto$outboundSchema` instead. */
  export const outboundSchema = PayloadValidationExceptionDto$outboundSchema;
  /** @deprecated use `PayloadValidationExceptionDto$Outbound` instead. */
  export type Outbound = PayloadValidationExceptionDto$Outbound;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messagePayloadValidationExceptionDto5ToJSON(messagePayloadValidationExceptionDto5: MessagePayloadValidationExceptionDto5)
 - messagePayloadValidationExceptionDto5FromJSON(jsonString: string)
 - messagePayloadValidationExceptionDto4ToJSON(messagePayloadValidationExceptionDto4: MessagePayloadValidationExceptionDto4)
 - messagePayloadValidationExceptionDto4FromJSON(jsonString: string)
 - payloadValidationExceptionDtoMessageToJSON(payloadValidationExceptionDtoMessage: PayloadValidationExceptionDtoMessage)
 - payloadValidationExceptionDtoMessageFromJSON(jsonString: string)
 - schemaToJSON(schema: Schema)
 - schemaFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MessagePayloadValidationExceptionDto5$Outbound;
}

export function messagePayloadValidationException...)
 - Outbound(MessagePayloadValidationExceptionDto4$Outbound;
}

export function messagePayloadValidationException...)
 - Outbound(PayloadValidationExceptionDtoMessage$Outbound;
}

export function payloadValidationExceptionDtoMessa...)
 - Outbound(Schema$Outbound;
}

export function schemaToJSON(schema: Schema): string {
  return JSON.stringify(S...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  type
- export class PayloadValidationExceptionDto
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messagePayloadValidationExceptionDto5ToJSON
- export function messagePayloadValidationExceptionDto5FromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messagePayloadValidationExceptionDto4ToJSON
- export function messagePayloadValidationExceptionDto4FromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function payloadValidationExceptionDtoMessageToJSON
- export function payloadValidationExceptionDtoMessageFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function schemaToJSON
- export function schemaFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/errors/responsevalidationerror.ts
Tamaño: 1232 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { NovuError } from './novuerror.js';
import { formatZodError } from './sdkvalidationerror.js';

export class ResponseValidationError extends NovuError {
  /**
   * The raw value that failed validation.
   */
  public readonly rawValue: unknown;

  /**
   * The raw message that failed validation.
   */
  public readonly rawMessage: unknown;

  constructor(
    message: string,
    extra: {
      response: Response;
      request: Request;
      body: string;
      cause: unknown;
      rawValue: unknown;
      rawMessage: unknown;
    }
  ) {
    super(message, extra);
    this.name = 'ResponseValidationError';
    this.cause = extra.cause;
    this.rawValue = extra.rawValue;
    this.rawMessage = extra.rawMessage;
  }

  /**
   * Return a pretty-formatted error message if the underlying validation error
   * is a ZodError or some other recognized error type, otherwise return the
   * default error message.
   */
  public pretty(): string {
    if (this.cause instanceof z.ZodError) {
      return `${this.rawMessage}\n${formatZodError(this.cause)}`;
    } else {
      return this.toString();
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ResponseValidationError

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/errors/sdkerror.ts
Tamaño: 1167 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuError } from "./novuerror.js";

/** The fallback error class if no more specific error class is matched */
export class SDKError extends NovuError {
  constructor(
    message: string,
    httpMeta: {
      response: Response;
      request: Request;
      body: string;
    },
  ) {
    if (message) {
      message += `: `;
    }
    message += `Status ${httpMeta.response.status}`;
    const contentType = httpMeta.response.headers.get("content-type") || `""`;
    if (contentType !== "application/json") {
      message += ` Content-Type ${
        contentType.includes(" ") ? `"${contentType}"` : contentType
      }`;
    }
    const body = httpMeta.body || `""`;
    message += body.length > 100 ? "\n" : ". ";
    let bodyDisplay = body;
    if (body.length > 10000) {
      const truncated = body.substring(0, 10000);
      const remaining = body.length - 10000;
      bodyDisplay = `${truncated}...and ${remaining} more chars`;
    }
    message += `Body: ${bodyDisplay}`;
    message = message.trim();
    super(message, httpMeta);
    this.name = "SDKError";
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SDKError

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/errors/sdkvalidationerror.ts
Tamaño: 3113 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';

export class SDKValidationError extends Error {
  /**
   * The raw value that failed validation.
   */
  public readonly rawValue: unknown;

  /**
   * The raw message that failed validation.
   */
  public readonly rawMessage: unknown;

  // Allows for backwards compatibility for `instanceof` checks of `ResponseValidationError`
  static override [Symbol.hasInstance](instance: unknown): instance is SDKValidationError {
    if (!(instance instanceof Error)) return false;
    if (!('rawValue' in instance)) return false;
    if (!('rawMessage' in instance)) return false;
    if (!('pretty' in instance)) return false;
    if (typeof instance.pretty !== 'function') return false;
    return true;
  }

  constructor(message: string, cause: unknown, rawValue: unknown) {
    super(`${message}: ${cause}`);
    this.name = 'SDKValidationError';
    this.cause = cause;
    this.rawValue = rawValue;
    this.rawMessage = message;
  }

  /**
   * Return a pretty-formatted error message if the underlying validation error
   * is a ZodError or some other recognized error type, otherwise return the
   * default error message.
   */
  public pretty(): string {
    if (this.cause instanceof z.ZodError) {
      return `${this.rawMessage}\n${formatZodError(this.cause)}`;
    } else {
      return this.toString();
    }
  }
}

export function formatZodError(err: z.ZodError, level = 0): string {
  let pre = '  '.repeat(level);
  pre = level > 0 ? `│${pre}` : pre;
  pre += ' '.repeat(level);

  let message = '';
  const append = (str: string) => (message += `\n${pre}${str}`);

  const len = err.issues.length;
  const headline = len === 1 ? `${len} issue found` : `${len} issues found`;

  if (len) {
    append(`┌ ${headline}:`);
  }

  for (const issue of err.issues) {
    let path = issue.path.join('.');
    path = path ? `<root>.${path}` : '<root>';
    append(`│ • [${path}]: ${issue.message} (${issue.code})`);
    switch (issue.code) {
      case 'invalid_literal':
      case 'invalid_type': {
        append(`│     Want: ${issue.expected}`);
        append(`│      Got: ${issue.received}`);
        break;
      }
      case 'unrecognized_keys': {
        append(`│     Keys: ${issue.keys.join(', ')}`);
        break;
      }
      case 'invalid_enum_value': {
        append(`│     Allowed: ${issue.options.join(', ')}`);
        append(`│         Got: ${issue.received}`);
        break;
      }
      case 'invalid_union_discriminator': {
        append(`│     Allowed: ${issue.options.join(', ')}`);
        break;
      }
      case 'invalid_union': {
        const len = issue.unionErrors.length;
        append(`│   ✖︎ Attemped to deserialize into one of ${len} union members:`);
        issue.unionErrors.forEach((err, i) => {
          append(`│   ✖︎ Member ${i + 1} of ${len}`);
          append(`${formatZodError(err, level + 1)}`);
        });
      }
    }
  }

  if (err.issues.length) {
    append(`└─*`);
  }

  return message.slice(1);
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - formatZodError(err: z.ZodError, level = 0)
Asignaciones con arrow functions encontradas (posibles funciones):
 - append(str: string))
 - len(issue.unionErrors.length;
        append(`│   ✖︎ Attemped to deserialize into one of ${len} union me...)
Declaraciones 'export' encontradas:
- export class SDKValidationError
- export function formatZodError

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/errors/subscriberresponsedto.ts
Tamaño: 10862 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import * as components from '../components/index.js';
import { NovuError } from './novuerror.js';

export type SubscriberResponseDtoData = {
  /**
   * The internal ID generated by Novu for your subscriber. This ID does not match the `subscriberId` used in your queries. Refer to `subscriberId` for that identifier.
   */
  id?: string | undefined;
  /**
   * The first name of the subscriber.
   */
  firstName?: string | null | undefined;
  /**
   * The last name of the subscriber.
   */
  lastName?: string | null | undefined;
  /**
   * The email address of the subscriber.
   */
  email?: string | null | undefined;
  /**
   * The phone number of the subscriber.
   */
  phone?: string | null | undefined;
  /**
   * The URL of the subscriber's avatar image.
   */
  avatar?: string | null | undefined;
  /**
   * The locale setting of the subscriber, indicating their preferred language or region.
   */
  locale?: string | null | undefined;
  /**
   * An array of channel settings associated with the subscriber.
   */
  channels?: Array<components.ChannelSettingsDto> | undefined;
  /**
   * An array of topics that the subscriber is subscribed to.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  topics?: Array<string> | undefined;
  /**
   * Indicates whether the subscriber is currently online.
   */
  isOnline?: boolean | null | undefined;
  /**
   * The timestamp indicating when the subscriber was last online, in ISO 8601 format.
   */
  lastOnlineAt?: string | null | undefined;
  /**
   * The version of the subscriber document.
   */
  v?: number | undefined;
  /**
   * Additional custom data for the subscriber
   */
  data?: { [k: string]: any } | null | undefined;
  /**
   * Timezone of the subscriber
   */
  timezone?: string | null | undefined;
  /**
   * The identifier used to create this subscriber, which typically corresponds to the user ID in your system.
   */
  subscriberId: string;
  /**
   * The unique identifier of the organization to which the subscriber belongs.
   */
  organizationId: string;
  /**
   * The unique identifier of the environment associated with this subscriber.
   */
  environmentId: string;
  /**
   * Indicates whether the subscriber has been deleted.
   */
  deleted: boolean;
  /**
   * The timestamp indicating when the subscriber was created, in ISO 8601 format.
   */
  createdAt: string;
  /**
   * The timestamp indicating when the subscriber was last updated, in ISO 8601 format.
   */
  updatedAt: string;
};

export class SubscriberResponseDto extends NovuError {
  /**
   * The internal ID generated by Novu for your subscriber. This ID does not match the `subscriberId` used in your queries. Refer to `subscriberId` for that identifier.
   */
  id?: string | undefined;
  /**
   * The first name of the subscriber.
   */
  firstName?: string | null | undefined;
  /**
   * The last name of the subscriber.
   */
  lastName?: string | null | undefined;
  /**
   * The email address of the subscriber.
   */
  email?: string | null | undefined;
  /**
   * The phone number of the subscriber.
   */
  phone?: string | null | undefined;
  /**
   * The URL of the subscriber's avatar image.
   */
  avatar?: string | null | undefined;
  /**
   * The locale setting of the subscriber, indicating their preferred language or region.
   */
  locale?: string | null | undefined;
  /**
   * An array of channel settings associated with the subscriber.
   */
  channels?: Array<components.ChannelSettingsDto> | undefined;
  /**
   * An array of topics that the subscriber is subscribed to.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  topics?: Array<string> | undefined;
  /**
   * Indicates whether the subscriber is currently online.
   */
  isOnline?: boolean | null | undefined;
  /**
   * The timestamp indicating when the subscriber was last online, in ISO 8601 format.
   */
  lastOnlineAt?: string | null | undefined;
  /**
   * The version of the subscriber document.
   */
  v?: number | undefined;
  /**
   * Additional custom data for the subscriber
   */
  data?: { [k: string]: any } | null | undefined;
  /**
   * Timezone of the subscriber
   */
  timezone?: string | null | undefined;
  /**
   * The identifier used to create this subscriber, which typically corresponds to the user ID in your system.
   */
  subscriberId: string;
  /**
   * The unique identifier of the organization to which the subscriber belongs.
   */
  organizationId: string;
  /**
   * The unique identifier of the environment associated with this subscriber.
   */
  environmentId: string;
  /**
   * Indicates whether the subscriber has been deleted.
   */
  deleted: boolean;
  /**
   * The timestamp indicating when the subscriber was created, in ISO 8601 format.
   */
  createdAt: string;
  /**
   * The timestamp indicating when the subscriber was last updated, in ISO 8601 format.
   */
  updatedAt: string;

  /** The original data that was passed to this error instance. */
  data$: SubscriberResponseDtoData;

  constructor(err: SubscriberResponseDtoData, httpMeta: { response: Response; request: Request; body: string }) {
    const message =
      'message' in err && typeof err.message === 'string' ? err.message : `API error occurred: ${JSON.stringify(err)}`;
    super(message, httpMeta);
    this.data$ = err;
    if (err.id != null) this.id = err.id;
    if (err.firstName != null) this.firstName = err.firstName;
    if (err.lastName != null) this.lastName = err.lastName;
    if (err.email != null) this.email = err.email;
    if (err.phone != null) this.phone = err.phone;
    if (err.avatar != null) this.avatar = err.avatar;
    if (err.locale != null) this.locale = err.locale;
    if (err.channels != null) this.channels = err.channels;
    if (err.topics != null) this.topics = err.topics;
    if (err.isOnline != null) this.isOnline = err.isOnline;
    if (err.lastOnlineAt != null) this.lastOnlineAt = err.lastOnlineAt;
    if (err.v != null) this.v = err.v;
    if (err.data != null) this.data = err.data;
    if (err.timezone != null) this.timezone = err.timezone;
    this.subscriberId = err.subscriberId;
    this.organizationId = err.organizationId;
    this.environmentId = err.environmentId;
    this.deleted = err.deleted;
    this.createdAt = err.createdAt;
    this.updatedAt = err.updatedAt;

    this.name = 'SubscriberResponseDto';
  }
}

/** @internal */
export const SubscriberResponseDto$inboundSchema: z.ZodType<SubscriberResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().optional(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    email: z.nullable(z.string()).optional(),
    phone: z.nullable(z.string()).optional(),
    avatar: z.nullable(z.string()).optional(),
    locale: z.nullable(z.string()).optional(),
    channels: z.array(components.ChannelSettingsDto$inboundSchema).optional(),
    topics: z.array(z.string()).optional(),
    isOnline: z.nullable(z.boolean()).optional(),
    lastOnlineAt: z.nullable(z.string()).optional(),
    __v: z.number().optional(),
    data: z.nullable(z.record(z.any())).optional(),
    timezone: z.nullable(z.string()).optional(),
    subscriberId: z.string(),
    _organizationId: z.string(),
    _environmentId: z.string(),
    deleted: z.boolean(),
    createdAt: z.string(),
    updatedAt: z.string(),
    request$: z.instanceof(Request),
    response$: z.instanceof(Response),
    body$: z.string(),
  })
  .transform((v) => {
    const remapped = remap$(v, {
      _id: 'id',
      __v: 'v',
      _organizationId: 'organizationId',
      _environmentId: 'environmentId',
    });

    return new SubscriberResponseDto(remapped, {
      request: v.request$,
      response: v.response$,
      body: v.body$,
    });
  });

/** @internal */
export type SubscriberResponseDto$Outbound = {
  _id?: string | undefined;
  firstName?: string | null | undefined;
  lastName?: string | null | undefined;
  email?: string | null | undefined;
  phone?: string | null | undefined;
  avatar?: string | null | undefined;
  locale?: string | null | undefined;
  channels?: Array<components.ChannelSettingsDto$Outbound> | undefined;
  topics?: Array<string> | undefined;
  isOnline?: boolean | null | undefined;
  lastOnlineAt?: string | null | undefined;
  __v?: number | undefined;
  data?: { [k: string]: any } | null | undefined;
  timezone?: string | null | undefined;
  subscriberId: string;
  _organizationId: string;
  _environmentId: string;
  deleted: boolean;
  createdAt: string;
  updatedAt: string;
};

/** @internal */
export const SubscriberResponseDto$outboundSchema: z.ZodType<
  SubscriberResponseDto$Outbound,
  z.ZodTypeDef,
  SubscriberResponseDto
> = z
  .instanceof(SubscriberResponseDto)
  .transform((v) => v.data$)
  .pipe(
    z
      .object({
        id: z.string().optional(),
        firstName: z.nullable(z.string()).optional(),
        lastName: z.nullable(z.string()).optional(),
        email: z.nullable(z.string()).optional(),
        phone: z.nullable(z.string()).optional(),
        avatar: z.nullable(z.string()).optional(),
        locale: z.nullable(z.string()).optional(),
        channels: z.array(components.ChannelSettingsDto$outboundSchema).optional(),
        topics: z.array(z.string()).optional(),
        isOnline: z.nullable(z.boolean()).optional(),
        lastOnlineAt: z.nullable(z.string()).optional(),
        v: z.number().optional(),
        data: z.nullable(z.record(z.any())).optional(),
        timezone: z.nullable(z.string()).optional(),
        subscriberId: z.string(),
        organizationId: z.string(),
        environmentId: z.string(),
        deleted: z.boolean(),
        createdAt: z.string(),
        updatedAt: z.string(),
      })
      .transform((v) => {
        return remap$(v, {
          id: '_id',
          v: '__v',
          organizationId: '_organizationId',
          environmentId: '_environmentId',
        });
      })
  );

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriberResponseDto$ {
  /** @deprecated use `SubscriberResponseDto$inboundSchema` instead. */
  export const inboundSchema = SubscriberResponseDto$inboundSchema;
  /** @deprecated use `SubscriberResponseDto$outboundSchema` instead. */
  export const outboundSchema = SubscriberResponseDto$outboundSchema;
  /** @deprecated use `SubscriberResponseDto$Outbound` instead. */
  export type Outbound = SubscriberResponseDto$Outbound;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export class SubscriberResponseDto
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/errors/topicresponsedto.ts
Tamaño: 3431 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { NovuError } from './novuerror.js';

export type TopicResponseDtoData = {
  /**
   * The identifier of the topic
   */
  id: string;
  /**
   * The unique key of the topic
   */
  key: string;
  /**
   * The name of the topic
   */
  name?: string | undefined;
  /**
   * The date the topic was created
   */
  createdAt?: string | undefined;
  /**
   * The date the topic was last updated
   */
  updatedAt?: string | undefined;
};

export class TopicResponseDto extends NovuError {
  /**
   * The identifier of the topic
   */
  id: string;
  /**
   * The unique key of the topic
   */
  key: string;
  /**
   * The date the topic was created
   */
  createdAt?: string | undefined;
  /**
   * The date the topic was last updated
   */
  updatedAt?: string | undefined;

  /** The original data that was passed to this error instance. */
  data$: TopicResponseDtoData;

  constructor(err: TopicResponseDtoData, httpMeta: { response: Response; request: Request; body: string }) {
    const message =
      'message' in err && typeof err.message === 'string' ? err.message : `API error occurred: ${JSON.stringify(err)}`;
    super(message, httpMeta);
    this.data$ = err;
    this.id = err.id;
    this.key = err.key;
    if (err.createdAt != null) this.createdAt = err.createdAt;
    if (err.updatedAt != null) this.updatedAt = err.updatedAt;

    this.name = 'TopicResponseDto';
  }
}

/** @internal */
export const TopicResponseDto$inboundSchema: z.ZodType<TopicResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string(),
    key: z.string(),
    name: z.string().optional(),
    createdAt: z.string().optional(),
    updatedAt: z.string().optional(),
    request$: z.instanceof(Request),
    response$: z.instanceof(Response),
    body$: z.string(),
  })
  .transform((v) => {
    const remapped = remap$(v, {
      _id: 'id',
    });

    return new TopicResponseDto(remapped, {
      request: v.request$,
      response: v.response$,
      body: v.body$,
    });
  });

/** @internal */
export type TopicResponseDto$Outbound = {
  _id: string;
  key: string;
  name?: string | undefined;
  createdAt?: string | undefined;
  updatedAt?: string | undefined;
};

/** @internal */
export const TopicResponseDto$outboundSchema: z.ZodType<TopicResponseDto$Outbound, z.ZodTypeDef, TopicResponseDto> = z
  .instanceof(TopicResponseDto)
  .transform((v) => v.data$)
  .pipe(
    z
      .object({
        id: z.string(),
        key: z.string(),
        name: z.string().optional(),
        createdAt: z.string().optional(),
        updatedAt: z.string().optional(),
      })
      .transform((v) => {
        return remap$(v, {
          id: '_id',
        });
      })
  );

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicResponseDto$ {
  /** @deprecated use `TopicResponseDto$inboundSchema` instead. */
  export const inboundSchema = TopicResponseDto$inboundSchema;
  /** @deprecated use `TopicResponseDto$outboundSchema` instead. */
  export const outboundSchema = TopicResponseDto$outboundSchema;
  /** @deprecated use `TopicResponseDto$Outbound` instead. */
  export type Outbound = TopicResponseDto$Outbound;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export class TopicResponseDto
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/errors/validationerrordto.ts
Tamaño: 10216 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { NovuError } from './novuerror.js';
import { SDKValidationError } from './sdkvalidationerror.js';

export type Message5 = string | number | boolean | { [k: string]: any };

export type Message4 = {};

/**
 * Value that failed validation
 */
export type ValidationErrorDtoMessage =
  | string
  | number
  | boolean
  | Message4
  | Array<string | number | boolean | { [k: string]: any } | null>;

export type ValidationErrorDtoData = {
  /**
   * HTTP status code of the error response.
   */
  statusCode: number;
  /**
   * Timestamp of when the error occurred.
   */
  timestamp: string;
  /**
   * The path where the error occurred.
   */
  path: string;
  /**
   * Value that failed validation
   */
  message?:
    | string
    | number
    | boolean
    | Message4
    | Array<string | number | boolean | { [k: string]: any } | null>
    | null
    | undefined;
  /**
   * Optional context object for additional error details.
   */
  ctx?: { [k: string]: any } | undefined;
  /**
   * Optional unique identifier for the error, useful for tracking using Sentry and
   *
   * @remarks
   *       New Relic, only available for 500.
   */
  errorId?: string | undefined;
  /**
   * A record of validation errors keyed by field name
   */
  errors: { [k: string]: components.ConstraintValidation };
};

export class ValidationErrorDto extends NovuError {
  /**
   * Timestamp of when the error occurred.
   */
  timestamp: string;
  /**
   * The path where the error occurred.
   */
  path: string;
  /**
   * Optional context object for additional error details.
   */
  ctx?: { [k: string]: any } | undefined;
  /**
   * Optional unique identifier for the error, useful for tracking using Sentry and
   *
   * @remarks
   *       New Relic, only available for 500.
   */
  errorId?: string | undefined;
  /**
   * A record of validation errors keyed by field name
   */
  errors: { [k: string]: components.ConstraintValidation };

  /** The original data that was passed to this error instance. */
  data$: ValidationErrorDtoData;

  constructor(err: ValidationErrorDtoData, httpMeta: { response: Response; request: Request; body: string }) {
    const message =
      'message' in err && typeof err.message === 'string' ? err.message : `API error occurred: ${JSON.stringify(err)}`;
    super(message, httpMeta);
    this.data$ = err;
    this.timestamp = err.timestamp;
    this.path = err.path;
    if (err.ctx != null) this.ctx = err.ctx;
    if (err.errorId != null) this.errorId = err.errorId;
    this.errors = err.errors;

    this.name = 'ValidationErrorDto';
  }
}

/** @internal */
export const Message5$inboundSchema: z.ZodType<Message5, z.ZodTypeDef, unknown> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.record(z.any()),
]);

/** @internal */
export type Message5$Outbound =
  | string
  | number
  | boolean
  | {
      [k: string]: any;
    };

/** @internal */
export const Message5$outboundSchema: z.ZodType<Message5$Outbound, z.ZodTypeDef, Message5> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.record(z.any()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Message5$ {
  /** @deprecated use `Message5$inboundSchema` instead. */
  export const inboundSchema = Message5$inboundSchema;
  /** @deprecated use `Message5$outboundSchema` instead. */
  export const outboundSchema = Message5$outboundSchema;
  /** @deprecated use `Message5$Outbound` instead. */
  export type Outbound = Message5$Outbound;
}

export function message5ToJSON(message5: Message5): string {
  return JSON.stringify(Message5$outboundSchema.parse(message5));
}

export function message5FromJSON(jsonString: string): SafeParseResult<Message5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Message5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Message5' from JSON`
  );
}

/** @internal */
export const Message4$inboundSchema: z.ZodType<Message4, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type Message4$Outbound = {};

/** @internal */
export const Message4$outboundSchema: z.ZodType<Message4$Outbound, z.ZodTypeDef, Message4> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Message4$ {
  /** @deprecated use `Message4$inboundSchema` instead. */
  export const inboundSchema = Message4$inboundSchema;
  /** @deprecated use `Message4$outboundSchema` instead. */
  export const outboundSchema = Message4$outboundSchema;
  /** @deprecated use `Message4$Outbound` instead. */
  export type Outbound = Message4$Outbound;
}

export function message4ToJSON(message4: Message4): string {
  return JSON.stringify(Message4$outboundSchema.parse(message4));
}

export function message4FromJSON(jsonString: string): SafeParseResult<Message4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Message4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Message4' from JSON`
  );
}

/** @internal */
export const ValidationErrorDtoMessage$inboundSchema: z.ZodType<ValidationErrorDtoMessage, z.ZodTypeDef, unknown> =
  z.union([
    z.string(),
    z.number(),
    z.boolean(),
    z.lazy(() => Message4$inboundSchema),
    z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
  ]);

/** @internal */
export type ValidationErrorDtoMessage$Outbound =
  | string
  | number
  | boolean
  | Message4$Outbound
  | Array<string | number | boolean | { [k: string]: any } | null>;

/** @internal */
export const ValidationErrorDtoMessage$outboundSchema: z.ZodType<
  ValidationErrorDtoMessage$Outbound,
  z.ZodTypeDef,
  ValidationErrorDtoMessage
> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.lazy(() => Message4$outboundSchema),
  z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ValidationErrorDtoMessage$ {
  /** @deprecated use `ValidationErrorDtoMessage$inboundSchema` instead. */
  export const inboundSchema = ValidationErrorDtoMessage$inboundSchema;
  /** @deprecated use `ValidationErrorDtoMessage$outboundSchema` instead. */
  export const outboundSchema = ValidationErrorDtoMessage$outboundSchema;
  /** @deprecated use `ValidationErrorDtoMessage$Outbound` instead. */
  export type Outbound = ValidationErrorDtoMessage$Outbound;
}

export function validationErrorDtoMessageToJSON(validationErrorDtoMessage: ValidationErrorDtoMessage): string {
  return JSON.stringify(ValidationErrorDtoMessage$outboundSchema.parse(validationErrorDtoMessage));
}

export function validationErrorDtoMessageFromJSON(
  jsonString: string
): SafeParseResult<ValidationErrorDtoMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ValidationErrorDtoMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ValidationErrorDtoMessage' from JSON`
  );
}

/** @internal */
export const ValidationErrorDto$inboundSchema: z.ZodType<ValidationErrorDto, z.ZodTypeDef, unknown> = z
  .object({
    statusCode: z.number(),
    timestamp: z.string(),
    path: z.string(),
    message: z
      .nullable(
        z.union([
          z.string(),
          z.number(),
          z.boolean(),
          z.lazy(() => Message4$inboundSchema),
          z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
        ])
      )
      .optional(),
    ctx: z.record(z.any()).optional(),
    errorId: z.string().optional(),
    errors: z.record(components.ConstraintValidation$inboundSchema),
    request$: z.instanceof(Request),
    response$: z.instanceof(Response),
    body$: z.string(),
  })
  .transform((v) => {
    return new ValidationErrorDto(v, {
      request: v.request$,
      response: v.response$,
      body: v.body$,
    });
  });

/** @internal */
export type ValidationErrorDto$Outbound = {
  statusCode: number;
  timestamp: string;
  path: string;
  message?:
    | string
    | number
    | boolean
    | Message4$Outbound
    | Array<string | number | boolean | { [k: string]: any } | null>
    | null
    | undefined;
  ctx?: { [k: string]: any } | undefined;
  errorId?: string | undefined;
  errors: { [k: string]: components.ConstraintValidation$Outbound };
};

/** @internal */
export const ValidationErrorDto$outboundSchema: z.ZodType<
  ValidationErrorDto$Outbound,
  z.ZodTypeDef,
  ValidationErrorDto
> = z
  .instanceof(ValidationErrorDto)
  .transform((v) => v.data$)
  .pipe(
    z.object({
      statusCode: z.number(),
      timestamp: z.string(),
      path: z.string(),
      message: z
        .nullable(
          z.union([
            z.string(),
            z.number(),
            z.boolean(),
            z.lazy(() => Message4$outboundSchema),
            z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
          ])
        )
        .optional(),
      ctx: z.record(z.any()).optional(),
      errorId: z.string().optional(),
      errors: z.record(components.ConstraintValidation$outboundSchema),
    })
  );

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ValidationErrorDto$ {
  /** @deprecated use `ValidationErrorDto$inboundSchema` instead. */
  export const inboundSchema = ValidationErrorDto$inboundSchema;
  /** @deprecated use `ValidationErrorDto$outboundSchema` instead. */
  export const outboundSchema = ValidationErrorDto$outboundSchema;
  /** @deprecated use `ValidationErrorDto$Outbound` instead. */
  export type Outbound = ValidationErrorDto$Outbound;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - message5ToJSON(message5: Message5)
 - message5FromJSON(jsonString: string)
 - message4ToJSON(message4: Message4)
 - message4FromJSON(jsonString: string)
 - validationErrorDtoMessageToJSON(validationErrorDtoMessage: ValidationErrorDtoMessage)
 - validationErrorDtoMessageFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Message5$Outbound;
}

export function message5ToJSON(message5: Message5): string {
  return JSON.str...)
 - Outbound(Message4$Outbound;
}

export function message4ToJSON(message4: Message4): string {
  return JSON.str...)
 - Outbound(ValidationErrorDtoMessage$Outbound;
}

export function validationErrorDtoMessageToJSON(validationErr...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export class ValidationErrorDto
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function message5ToJSON
- export function message5FromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function message4ToJSON
- export function message4FromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function validationErrorDtoMessageToJSON
- export function validationErrorDtoMessageFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/activitycontrollergetcharts.ts
Tamaño: 6337 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export const ReportType = {
  DeliveryTrend: 'delivery-trend',
  InteractionTrend: 'interaction-trend',
  WorkflowByVolume: 'workflow-by-volume',
  ProviderByVolume: 'provider-by-volume',
  MessagesDelivered: 'messages-delivered',
  ActiveSubscribers: 'active-subscribers',
  AvgMessagesPerSubscriber: 'avg-messages-per-subscriber',
  WorkflowRunsMetric: 'workflow-runs-metric',
  TotalInteractions: 'total-interactions',
  WorkflowRunsTrend: 'workflow-runs-trend',
  ActiveSubscribersTrend: 'active-subscribers-trend',
  WorkflowRunsCount: 'workflow-runs-count',
} as const;
export type ReportType = ClosedEnum<typeof ReportType>;

export const Statuses = {
  Processing: 'processing',
  Completed: 'completed',
  Error: 'error',
} as const;
export type Statuses = ClosedEnum<typeof Statuses>;

export type ActivityControllerGetChartsRequest = {
  createdAtGte?: string | undefined;
  createdAtLte?: string | undefined;
  reportType: Array<ReportType>;
  workflowIds?: Array<string> | undefined;
  subscriberIds?: Array<string> | undefined;
  transactionIds?: Array<string> | undefined;
  statuses?: Array<Statuses> | undefined;
  channels?: Array<string> | undefined;
  topicKey?: string | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

/** @internal */
export const ReportType$inboundSchema: z.ZodNativeEnum<typeof ReportType> = z.nativeEnum(ReportType);

/** @internal */
export const ReportType$outboundSchema: z.ZodNativeEnum<typeof ReportType> = ReportType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ReportType$ {
  /** @deprecated use `ReportType$inboundSchema` instead. */
  export const inboundSchema = ReportType$inboundSchema;
  /** @deprecated use `ReportType$outboundSchema` instead. */
  export const outboundSchema = ReportType$outboundSchema;
}

/** @internal */
export const Statuses$inboundSchema: z.ZodNativeEnum<typeof Statuses> = z.nativeEnum(Statuses);

/** @internal */
export const Statuses$outboundSchema: z.ZodNativeEnum<typeof Statuses> = Statuses$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Statuses$ {
  /** @deprecated use `Statuses$inboundSchema` instead. */
  export const inboundSchema = Statuses$inboundSchema;
  /** @deprecated use `Statuses$outboundSchema` instead. */
  export const outboundSchema = Statuses$outboundSchema;
}

/** @internal */
export const ActivityControllerGetChartsRequest$inboundSchema: z.ZodType<
  ActivityControllerGetChartsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    createdAtGte: z.string().optional(),
    createdAtLte: z.string().optional(),
    reportType: z.array(ReportType$inboundSchema),
    workflowIds: z.array(z.string()).optional(),
    subscriberIds: z.array(z.string()).optional(),
    transactionIds: z.array(z.string()).optional(),
    statuses: z.array(Statuses$inboundSchema).optional(),
    channels: z.array(z.string()).optional(),
    topicKey: z.string().optional(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type ActivityControllerGetChartsRequest$Outbound = {
  createdAtGte?: string | undefined;
  createdAtLte?: string | undefined;
  reportType: Array<string>;
  workflowIds?: Array<string> | undefined;
  subscriberIds?: Array<string> | undefined;
  transactionIds?: Array<string> | undefined;
  statuses?: Array<string> | undefined;
  channels?: Array<string> | undefined;
  topicKey?: string | undefined;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const ActivityControllerGetChartsRequest$outboundSchema: z.ZodType<
  ActivityControllerGetChartsRequest$Outbound,
  z.ZodTypeDef,
  ActivityControllerGetChartsRequest
> = z
  .object({
    createdAtGte: z.string().optional(),
    createdAtLte: z.string().optional(),
    reportType: z.array(ReportType$outboundSchema),
    workflowIds: z.array(z.string()).optional(),
    subscriberIds: z.array(z.string()).optional(),
    transactionIds: z.array(z.string()).optional(),
    statuses: z.array(Statuses$outboundSchema).optional(),
    channels: z.array(z.string()).optional(),
    topicKey: z.string().optional(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ActivityControllerGetChartsRequest$ {
  /** @deprecated use `ActivityControllerGetChartsRequest$inboundSchema` instead. */
  export const inboundSchema = ActivityControllerGetChartsRequest$inboundSchema;
  /** @deprecated use `ActivityControllerGetChartsRequest$outboundSchema` instead. */
  export const outboundSchema = ActivityControllerGetChartsRequest$outboundSchema;
  /** @deprecated use `ActivityControllerGetChartsRequest$Outbound` instead. */
  export type Outbound = ActivityControllerGetChartsRequest$Outbound;
}

export function activityControllerGetChartsRequestToJSON(
  activityControllerGetChartsRequest: ActivityControllerGetChartsRequest
): string {
  return JSON.stringify(ActivityControllerGetChartsRequest$outboundSchema.parse(activityControllerGetChartsRequest));
}

export function activityControllerGetChartsRequestFromJSON(
  jsonString: string
): SafeParseResult<ActivityControllerGetChartsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ActivityControllerGetChartsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ActivityControllerGetChartsRequest' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - activityControllerGetChartsRequestToJSON(activityControllerGetChartsRequest: ActivityControllerGetChartsRequest)
 - activityControllerGetChartsRequestFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ActivityControllerGetChartsRequest$Outbound;
}

export function activityControllerGetChartsRequestTo...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function activityControllerGetChartsRequestToJSON
- export function activityControllerGetChartsRequestFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/activitycontrollergetlogs.ts
Tamaño: 3761 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type ActivityControllerGetLogsRequest = {
  /**
   * Page number for pagination
   */
  page?: number | undefined;
  /**
   * Number of items per page
   */
  limit?: number | undefined;
  /**
   * Filter by HTTP status codes
   */
  statusCodes?: Array<number> | undefined;
  /**
   * Filter by URL pattern
   */
  urlPattern?: string | undefined;
  /**
   * Filter by transaction identifier
   */
  transactionId?: string | undefined;
  /**
   * Filter requests created after this timestamp (Unix timestamp)
   */
  createdGte?: number | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

/** @internal */
export const ActivityControllerGetLogsRequest$inboundSchema: z.ZodType<
  ActivityControllerGetLogsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    page: z.number().optional(),
    limit: z.number().optional(),
    statusCodes: z.array(z.number()).optional(),
    urlPattern: z.string().optional(),
    transactionId: z.string().optional(),
    createdGte: z.number().optional(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type ActivityControllerGetLogsRequest$Outbound = {
  page?: number | undefined;
  limit?: number | undefined;
  statusCodes?: Array<number> | undefined;
  urlPattern?: string | undefined;
  transactionId?: string | undefined;
  createdGte?: number | undefined;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const ActivityControllerGetLogsRequest$outboundSchema: z.ZodType<
  ActivityControllerGetLogsRequest$Outbound,
  z.ZodTypeDef,
  ActivityControllerGetLogsRequest
> = z
  .object({
    page: z.number().optional(),
    limit: z.number().optional(),
    statusCodes: z.array(z.number()).optional(),
    urlPattern: z.string().optional(),
    transactionId: z.string().optional(),
    createdGte: z.number().optional(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ActivityControllerGetLogsRequest$ {
  /** @deprecated use `ActivityControllerGetLogsRequest$inboundSchema` instead. */
  export const inboundSchema = ActivityControllerGetLogsRequest$inboundSchema;
  /** @deprecated use `ActivityControllerGetLogsRequest$outboundSchema` instead. */
  export const outboundSchema = ActivityControllerGetLogsRequest$outboundSchema;
  /** @deprecated use `ActivityControllerGetLogsRequest$Outbound` instead. */
  export type Outbound = ActivityControllerGetLogsRequest$Outbound;
}

export function activityControllerGetLogsRequestToJSON(
  activityControllerGetLogsRequest: ActivityControllerGetLogsRequest
): string {
  return JSON.stringify(ActivityControllerGetLogsRequest$outboundSchema.parse(activityControllerGetLogsRequest));
}

export function activityControllerGetLogsRequestFromJSON(
  jsonString: string
): SafeParseResult<ActivityControllerGetLogsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ActivityControllerGetLogsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ActivityControllerGetLogsRequest' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - activityControllerGetLogsRequestToJSON(activityControllerGetLogsRequest: ActivityControllerGetLogsRequest)
 - activityControllerGetLogsRequestFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ActivityControllerGetLogsRequest$Outbound;
}

export function activityControllerGetLogsRequestToJSON...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function activityControllerGetLogsRequestToJSON
- export function activityControllerGetLogsRequestFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/activitycontrollergetrequesttraces.ts
Tamaño: 2881 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type ActivityControllerGetRequestTracesRequest = {
  requestId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

/** @internal */
export const ActivityControllerGetRequestTracesRequest$inboundSchema: z.ZodType<
  ActivityControllerGetRequestTracesRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    requestId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type ActivityControllerGetRequestTracesRequest$Outbound = {
  requestId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const ActivityControllerGetRequestTracesRequest$outboundSchema: z.ZodType<
  ActivityControllerGetRequestTracesRequest$Outbound,
  z.ZodTypeDef,
  ActivityControllerGetRequestTracesRequest
> = z
  .object({
    requestId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ActivityControllerGetRequestTracesRequest$ {
  /** @deprecated use `ActivityControllerGetRequestTracesRequest$inboundSchema` instead. */
  export const inboundSchema = ActivityControllerGetRequestTracesRequest$inboundSchema;
  /** @deprecated use `ActivityControllerGetRequestTracesRequest$outboundSchema` instead. */
  export const outboundSchema = ActivityControllerGetRequestTracesRequest$outboundSchema;
  /** @deprecated use `ActivityControllerGetRequestTracesRequest$Outbound` instead. */
  export type Outbound = ActivityControllerGetRequestTracesRequest$Outbound;
}

export function activityControllerGetRequestTracesRequestToJSON(
  activityControllerGetRequestTracesRequest: ActivityControllerGetRequestTracesRequest
): string {
  return JSON.stringify(
    ActivityControllerGetRequestTracesRequest$outboundSchema.parse(activityControllerGetRequestTracesRequest)
  );
}

export function activityControllerGetRequestTracesRequestFromJSON(
  jsonString: string
): SafeParseResult<ActivityControllerGetRequestTracesRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ActivityControllerGetRequestTracesRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ActivityControllerGetRequestTracesRequest' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - activityControllerGetRequestTracesRequestToJSON(activityControllerGetRequestTracesRequest: ActivityControllerGetRequestTracesRequest)
 - activityControllerGetRequestTracesRequestFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ActivityControllerGetRequestTracesRequest$Outbound;
}

export function activityControllerGetRequestT...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function activityControllerGetRequestTracesRequestToJSON
- export function activityControllerGetRequestTracesRequestFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/activitycontrollergetworkflowrun.ts
Tamaño: 2851 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type ActivityControllerGetWorkflowRunRequest = {
  workflowRunId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

/** @internal */
export const ActivityControllerGetWorkflowRunRequest$inboundSchema: z.ZodType<
  ActivityControllerGetWorkflowRunRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    workflowRunId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type ActivityControllerGetWorkflowRunRequest$Outbound = {
  workflowRunId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const ActivityControllerGetWorkflowRunRequest$outboundSchema: z.ZodType<
  ActivityControllerGetWorkflowRunRequest$Outbound,
  z.ZodTypeDef,
  ActivityControllerGetWorkflowRunRequest
> = z
  .object({
    workflowRunId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ActivityControllerGetWorkflowRunRequest$ {
  /** @deprecated use `ActivityControllerGetWorkflowRunRequest$inboundSchema` instead. */
  export const inboundSchema = ActivityControllerGetWorkflowRunRequest$inboundSchema;
  /** @deprecated use `ActivityControllerGetWorkflowRunRequest$outboundSchema` instead. */
  export const outboundSchema = ActivityControllerGetWorkflowRunRequest$outboundSchema;
  /** @deprecated use `ActivityControllerGetWorkflowRunRequest$Outbound` instead. */
  export type Outbound = ActivityControllerGetWorkflowRunRequest$Outbound;
}

export function activityControllerGetWorkflowRunRequestToJSON(
  activityControllerGetWorkflowRunRequest: ActivityControllerGetWorkflowRunRequest
): string {
  return JSON.stringify(
    ActivityControllerGetWorkflowRunRequest$outboundSchema.parse(activityControllerGetWorkflowRunRequest)
  );
}

export function activityControllerGetWorkflowRunRequestFromJSON(
  jsonString: string
): SafeParseResult<ActivityControllerGetWorkflowRunRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ActivityControllerGetWorkflowRunRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ActivityControllerGetWorkflowRunRequest' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - activityControllerGetWorkflowRunRequestToJSON(activityControllerGetWorkflowRunRequest: ActivityControllerGetWorkflowRunRequest)
 - activityControllerGetWorkflowRunRequestFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ActivityControllerGetWorkflowRunRequest$Outbound;
}

export function activityControllerGetWorkflowRu...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function activityControllerGetWorkflowRunRequestToJSON
- export function activityControllerGetWorkflowRunRequestFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/activitycontrollergetworkflowruns.ts
Tamaño: 6610 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export const QueryParamStatuses = {
  Processing: 'processing',
  Completed: 'completed',
  Error: 'error',
} as const;
export type QueryParamStatuses = ClosedEnum<typeof QueryParamStatuses>;

export const Severity = {
  High: 'high',
  Medium: 'medium',
  Low: 'low',
  None: 'none',
} as const;
export type Severity = ClosedEnum<typeof Severity>;

export type ActivityControllerGetWorkflowRunsRequest = {
  limit?: number | undefined;
  cursor?: string | undefined;
  workflowIds?: Array<string> | undefined;
  subscriberIds?: Array<string> | undefined;
  transactionIds?: Array<string> | undefined;
  statuses?: Array<QueryParamStatuses> | undefined;
  channels?: Array<string> | undefined;
  topicKey?: string | undefined;
  createdGte?: string | undefined;
  createdLte?: string | undefined;
  severity?: Array<Severity> | undefined;
  contextKeys?: Array<string> | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

/** @internal */
export const QueryParamStatuses$inboundSchema: z.ZodNativeEnum<typeof QueryParamStatuses> =
  z.nativeEnum(QueryParamStatuses);

/** @internal */
export const QueryParamStatuses$outboundSchema: z.ZodNativeEnum<typeof QueryParamStatuses> =
  QueryParamStatuses$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueryParamStatuses$ {
  /** @deprecated use `QueryParamStatuses$inboundSchema` instead. */
  export const inboundSchema = QueryParamStatuses$inboundSchema;
  /** @deprecated use `QueryParamStatuses$outboundSchema` instead. */
  export const outboundSchema = QueryParamStatuses$outboundSchema;
}

/** @internal */
export const Severity$inboundSchema: z.ZodNativeEnum<typeof Severity> = z.nativeEnum(Severity);

/** @internal */
export const Severity$outboundSchema: z.ZodNativeEnum<typeof Severity> = Severity$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Severity$ {
  /** @deprecated use `Severity$inboundSchema` instead. */
  export const inboundSchema = Severity$inboundSchema;
  /** @deprecated use `Severity$outboundSchema` instead. */
  export const outboundSchema = Severity$outboundSchema;
}

/** @internal */
export const ActivityControllerGetWorkflowRunsRequest$inboundSchema: z.ZodType<
  ActivityControllerGetWorkflowRunsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    limit: z.number().default(10),
    cursor: z.string().optional(),
    workflowIds: z.array(z.string()).optional(),
    subscriberIds: z.array(z.string()).optional(),
    transactionIds: z.array(z.string()).optional(),
    statuses: z.array(QueryParamStatuses$inboundSchema).optional(),
    channels: z.array(z.string()).optional(),
    topicKey: z.string().optional(),
    createdGte: z.string().optional(),
    createdLte: z.string().optional(),
    severity: z.array(Severity$inboundSchema).optional(),
    contextKeys: z.array(z.string()).optional(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type ActivityControllerGetWorkflowRunsRequest$Outbound = {
  limit: number;
  cursor?: string | undefined;
  workflowIds?: Array<string> | undefined;
  subscriberIds?: Array<string> | undefined;
  transactionIds?: Array<string> | undefined;
  statuses?: Array<string> | undefined;
  channels?: Array<string> | undefined;
  topicKey?: string | undefined;
  createdGte?: string | undefined;
  createdLte?: string | undefined;
  severity?: Array<string> | undefined;
  contextKeys?: Array<string> | undefined;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const ActivityControllerGetWorkflowRunsRequest$outboundSchema: z.ZodType<
  ActivityControllerGetWorkflowRunsRequest$Outbound,
  z.ZodTypeDef,
  ActivityControllerGetWorkflowRunsRequest
> = z
  .object({
    limit: z.number().default(10),
    cursor: z.string().optional(),
    workflowIds: z.array(z.string()).optional(),
    subscriberIds: z.array(z.string()).optional(),
    transactionIds: z.array(z.string()).optional(),
    statuses: z.array(QueryParamStatuses$outboundSchema).optional(),
    channels: z.array(z.string()).optional(),
    topicKey: z.string().optional(),
    createdGte: z.string().optional(),
    createdLte: z.string().optional(),
    severity: z.array(Severity$outboundSchema).optional(),
    contextKeys: z.array(z.string()).optional(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ActivityControllerGetWorkflowRunsRequest$ {
  /** @deprecated use `ActivityControllerGetWorkflowRunsRequest$inboundSchema` instead. */
  export const inboundSchema = ActivityControllerGetWorkflowRunsRequest$inboundSchema;
  /** @deprecated use `ActivityControllerGetWorkflowRunsRequest$outboundSchema` instead. */
  export const outboundSchema = ActivityControllerGetWorkflowRunsRequest$outboundSchema;
  /** @deprecated use `ActivityControllerGetWorkflowRunsRequest$Outbound` instead. */
  export type Outbound = ActivityControllerGetWorkflowRunsRequest$Outbound;
}

export function activityControllerGetWorkflowRunsRequestToJSON(
  activityControllerGetWorkflowRunsRequest: ActivityControllerGetWorkflowRunsRequest
): string {
  return JSON.stringify(
    ActivityControllerGetWorkflowRunsRequest$outboundSchema.parse(activityControllerGetWorkflowRunsRequest)
  );
}

export function activityControllerGetWorkflowRunsRequestFromJSON(
  jsonString: string
): SafeParseResult<ActivityControllerGetWorkflowRunsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ActivityControllerGetWorkflowRunsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ActivityControllerGetWorkflowRunsRequest' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - activityControllerGetWorkflowRunsRequestToJSON(activityControllerGetWorkflowRunsRequest: ActivityControllerGetWorkflowRunsRequest)
 - activityControllerGetWorkflowRunsRequestFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ActivityControllerGetWorkflowRunsRequest$Outbound;
}

export function activityControllerGetWorkflowR...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function activityControllerGetWorkflowRunsRequestToJSON
- export function activityControllerGetWorkflowRunsRequestFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/contextscontrollercreatecontext.ts
Tamaño: 5758 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type ContextsControllerCreateContextRequest = {
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  createContextRequestDto: components.CreateContextRequestDto;
};

export type ContextsControllerCreateContextResponse = {
  headers: { [k: string]: Array<string> };
  result: components.GetContextResponseDto;
};

/** @internal */
export const ContextsControllerCreateContextRequest$inboundSchema: z.ZodType<
  ContextsControllerCreateContextRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    'idempotency-key': z.string().optional(),
    CreateContextRequestDto: components.CreateContextRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      CreateContextRequestDto: 'createContextRequestDto',
    });
  });

/** @internal */
export type ContextsControllerCreateContextRequest$Outbound = {
  'idempotency-key'?: string | undefined;
  CreateContextRequestDto: components.CreateContextRequestDto$Outbound;
};

/** @internal */
export const ContextsControllerCreateContextRequest$outboundSchema: z.ZodType<
  ContextsControllerCreateContextRequest$Outbound,
  z.ZodTypeDef,
  ContextsControllerCreateContextRequest
> = z
  .object({
    idempotencyKey: z.string().optional(),
    createContextRequestDto: components.CreateContextRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      createContextRequestDto: 'CreateContextRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContextsControllerCreateContextRequest$ {
  /** @deprecated use `ContextsControllerCreateContextRequest$inboundSchema` instead. */
  export const inboundSchema = ContextsControllerCreateContextRequest$inboundSchema;
  /** @deprecated use `ContextsControllerCreateContextRequest$outboundSchema` instead. */
  export const outboundSchema = ContextsControllerCreateContextRequest$outboundSchema;
  /** @deprecated use `ContextsControllerCreateContextRequest$Outbound` instead. */
  export type Outbound = ContextsControllerCreateContextRequest$Outbound;
}

export function contextsControllerCreateContextRequestToJSON(
  contextsControllerCreateContextRequest: ContextsControllerCreateContextRequest
): string {
  return JSON.stringify(
    ContextsControllerCreateContextRequest$outboundSchema.parse(contextsControllerCreateContextRequest)
  );
}

export function contextsControllerCreateContextRequestFromJSON(
  jsonString: string
): SafeParseResult<ContextsControllerCreateContextRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContextsControllerCreateContextRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContextsControllerCreateContextRequest' from JSON`
  );
}

/** @internal */
export const ContextsControllerCreateContextResponse$inboundSchema: z.ZodType<
  ContextsControllerCreateContextResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.GetContextResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type ContextsControllerCreateContextResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.GetContextResponseDto$Outbound;
};

/** @internal */
export const ContextsControllerCreateContextResponse$outboundSchema: z.ZodType<
  ContextsControllerCreateContextResponse$Outbound,
  z.ZodTypeDef,
  ContextsControllerCreateContextResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.GetContextResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContextsControllerCreateContextResponse$ {
  /** @deprecated use `ContextsControllerCreateContextResponse$inboundSchema` instead. */
  export const inboundSchema = ContextsControllerCreateContextResponse$inboundSchema;
  /** @deprecated use `ContextsControllerCreateContextResponse$outboundSchema` instead. */
  export const outboundSchema = ContextsControllerCreateContextResponse$outboundSchema;
  /** @deprecated use `ContextsControllerCreateContextResponse$Outbound` instead. */
  export type Outbound = ContextsControllerCreateContextResponse$Outbound;
}

export function contextsControllerCreateContextResponseToJSON(
  contextsControllerCreateContextResponse: ContextsControllerCreateContextResponse
): string {
  return JSON.stringify(
    ContextsControllerCreateContextResponse$outboundSchema.parse(contextsControllerCreateContextResponse)
  );
}

export function contextsControllerCreateContextResponseFromJSON(
  jsonString: string
): SafeParseResult<ContextsControllerCreateContextResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContextsControllerCreateContextResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContextsControllerCreateContextResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - contextsControllerCreateContextRequestToJSON(contextsControllerCreateContextRequest: ContextsControllerCreateContextRequest)
 - contextsControllerCreateContextRequestFromJSON(jsonString: string)
 - contextsControllerCreateContextResponseToJSON(contextsControllerCreateContextResponse: ContextsControllerCreateContextResponse)
 - contextsControllerCreateContextResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ContextsControllerCreateContextRequest$Outbound;
}

export function contextsControllerCreateContextR...)
 - Outbound(ContextsControllerCreateContextResponse$Outbound;
}

export function contextsControllerCreateContext...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function contextsControllerCreateContextRequestToJSON
- export function contextsControllerCreateContextRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function contextsControllerCreateContextResponseToJSON
- export function contextsControllerCreateContextResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/contextscontrollerdeletecontext.ts
Tamaño: 5230 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type ContextsControllerDeleteContextRequest = {
  /**
   * Context type
   */
  type: string;
  /**
   * Context ID
   */
  id: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type ContextsControllerDeleteContextResponse = {
  headers: { [k: string]: Array<string> };
};

/** @internal */
export const ContextsControllerDeleteContextRequest$inboundSchema: z.ZodType<
  ContextsControllerDeleteContextRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    type: z.string(),
    id: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type ContextsControllerDeleteContextRequest$Outbound = {
  type: string;
  id: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const ContextsControllerDeleteContextRequest$outboundSchema: z.ZodType<
  ContextsControllerDeleteContextRequest$Outbound,
  z.ZodTypeDef,
  ContextsControllerDeleteContextRequest
> = z
  .object({
    type: z.string(),
    id: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContextsControllerDeleteContextRequest$ {
  /** @deprecated use `ContextsControllerDeleteContextRequest$inboundSchema` instead. */
  export const inboundSchema = ContextsControllerDeleteContextRequest$inboundSchema;
  /** @deprecated use `ContextsControllerDeleteContextRequest$outboundSchema` instead. */
  export const outboundSchema = ContextsControllerDeleteContextRequest$outboundSchema;
  /** @deprecated use `ContextsControllerDeleteContextRequest$Outbound` instead. */
  export type Outbound = ContextsControllerDeleteContextRequest$Outbound;
}

export function contextsControllerDeleteContextRequestToJSON(
  contextsControllerDeleteContextRequest: ContextsControllerDeleteContextRequest
): string {
  return JSON.stringify(
    ContextsControllerDeleteContextRequest$outboundSchema.parse(contextsControllerDeleteContextRequest)
  );
}

export function contextsControllerDeleteContextRequestFromJSON(
  jsonString: string
): SafeParseResult<ContextsControllerDeleteContextRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContextsControllerDeleteContextRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContextsControllerDeleteContextRequest' from JSON`
  );
}

/** @internal */
export const ContextsControllerDeleteContextResponse$inboundSchema: z.ZodType<
  ContextsControllerDeleteContextResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
    });
  });

/** @internal */
export type ContextsControllerDeleteContextResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
};

/** @internal */
export const ContextsControllerDeleteContextResponse$outboundSchema: z.ZodType<
  ContextsControllerDeleteContextResponse$Outbound,
  z.ZodTypeDef,
  ContextsControllerDeleteContextResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContextsControllerDeleteContextResponse$ {
  /** @deprecated use `ContextsControllerDeleteContextResponse$inboundSchema` instead. */
  export const inboundSchema = ContextsControllerDeleteContextResponse$inboundSchema;
  /** @deprecated use `ContextsControllerDeleteContextResponse$outboundSchema` instead. */
  export const outboundSchema = ContextsControllerDeleteContextResponse$outboundSchema;
  /** @deprecated use `ContextsControllerDeleteContextResponse$Outbound` instead. */
  export type Outbound = ContextsControllerDeleteContextResponse$Outbound;
}

export function contextsControllerDeleteContextResponseToJSON(
  contextsControllerDeleteContextResponse: ContextsControllerDeleteContextResponse
): string {
  return JSON.stringify(
    ContextsControllerDeleteContextResponse$outboundSchema.parse(contextsControllerDeleteContextResponse)
  );
}

export function contextsControllerDeleteContextResponseFromJSON(
  jsonString: string
): SafeParseResult<ContextsControllerDeleteContextResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContextsControllerDeleteContextResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContextsControllerDeleteContextResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - contextsControllerDeleteContextRequestToJSON(contextsControllerDeleteContextRequest: ContextsControllerDeleteContextRequest)
 - contextsControllerDeleteContextRequestFromJSON(jsonString: string)
 - contextsControllerDeleteContextResponseToJSON(contextsControllerDeleteContextResponse: ContextsControllerDeleteContextResponse)
 - contextsControllerDeleteContextResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ContextsControllerDeleteContextRequest$Outbound;
}

export function contextsControllerDeleteContextR...)
 - Outbound(ContextsControllerDeleteContextResponse$Outbound;
}

export function contextsControllerDeleteContext...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function contextsControllerDeleteContextRequestToJSON
- export function contextsControllerDeleteContextRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function contextsControllerDeleteContextResponseToJSON
- export function contextsControllerDeleteContextResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/contextscontrollergetcontext.ts
Tamaño: 5404 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type ContextsControllerGetContextRequest = {
  /**
   * Context type
   */
  type: string;
  /**
   * Context ID
   */
  id: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type ContextsControllerGetContextResponse = {
  headers: { [k: string]: Array<string> };
  result: components.GetContextResponseDto;
};

/** @internal */
export const ContextsControllerGetContextRequest$inboundSchema: z.ZodType<
  ContextsControllerGetContextRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    type: z.string(),
    id: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type ContextsControllerGetContextRequest$Outbound = {
  type: string;
  id: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const ContextsControllerGetContextRequest$outboundSchema: z.ZodType<
  ContextsControllerGetContextRequest$Outbound,
  z.ZodTypeDef,
  ContextsControllerGetContextRequest
> = z
  .object({
    type: z.string(),
    id: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContextsControllerGetContextRequest$ {
  /** @deprecated use `ContextsControllerGetContextRequest$inboundSchema` instead. */
  export const inboundSchema = ContextsControllerGetContextRequest$inboundSchema;
  /** @deprecated use `ContextsControllerGetContextRequest$outboundSchema` instead. */
  export const outboundSchema = ContextsControllerGetContextRequest$outboundSchema;
  /** @deprecated use `ContextsControllerGetContextRequest$Outbound` instead. */
  export type Outbound = ContextsControllerGetContextRequest$Outbound;
}

export function contextsControllerGetContextRequestToJSON(
  contextsControllerGetContextRequest: ContextsControllerGetContextRequest
): string {
  return JSON.stringify(ContextsControllerGetContextRequest$outboundSchema.parse(contextsControllerGetContextRequest));
}

export function contextsControllerGetContextRequestFromJSON(
  jsonString: string
): SafeParseResult<ContextsControllerGetContextRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContextsControllerGetContextRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContextsControllerGetContextRequest' from JSON`
  );
}

/** @internal */
export const ContextsControllerGetContextResponse$inboundSchema: z.ZodType<
  ContextsControllerGetContextResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.GetContextResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type ContextsControllerGetContextResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.GetContextResponseDto$Outbound;
};

/** @internal */
export const ContextsControllerGetContextResponse$outboundSchema: z.ZodType<
  ContextsControllerGetContextResponse$Outbound,
  z.ZodTypeDef,
  ContextsControllerGetContextResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.GetContextResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContextsControllerGetContextResponse$ {
  /** @deprecated use `ContextsControllerGetContextResponse$inboundSchema` instead. */
  export const inboundSchema = ContextsControllerGetContextResponse$inboundSchema;
  /** @deprecated use `ContextsControllerGetContextResponse$outboundSchema` instead. */
  export const outboundSchema = ContextsControllerGetContextResponse$outboundSchema;
  /** @deprecated use `ContextsControllerGetContextResponse$Outbound` instead. */
  export type Outbound = ContextsControllerGetContextResponse$Outbound;
}

export function contextsControllerGetContextResponseToJSON(
  contextsControllerGetContextResponse: ContextsControllerGetContextResponse
): string {
  return JSON.stringify(
    ContextsControllerGetContextResponse$outboundSchema.parse(contextsControllerGetContextResponse)
  );
}

export function contextsControllerGetContextResponseFromJSON(
  jsonString: string
): SafeParseResult<ContextsControllerGetContextResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContextsControllerGetContextResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContextsControllerGetContextResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - contextsControllerGetContextRequestToJSON(contextsControllerGetContextRequest: ContextsControllerGetContextRequest)
 - contextsControllerGetContextRequestFromJSON(jsonString: string)
 - contextsControllerGetContextResponseToJSON(contextsControllerGetContextResponse: ContextsControllerGetContextResponse)
 - contextsControllerGetContextResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ContextsControllerGetContextRequest$Outbound;
}

export function contextsControllerGetContextRequest...)
 - Outbound(ContextsControllerGetContextResponse$Outbound;
}

export function contextsControllerGetContextRespon...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function contextsControllerGetContextRequestToJSON
- export function contextsControllerGetContextRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function contextsControllerGetContextResponseToJSON
- export function contextsControllerGetContextResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/contextscontrollerlistcontexts.ts
Tamaño: 8091 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Direction of sorting
 */
export const OrderDirection = {
  Asc: 'ASC',
  Desc: 'DESC',
} as const;
/**
 * Direction of sorting
 */
export type OrderDirection = ClosedEnum<typeof OrderDirection>;

export type ContextsControllerListContextsRequest = {
  /**
   * Cursor for pagination indicating the starting point after which to fetch results.
   */
  after?: string | undefined;
  /**
   * Cursor for pagination indicating the ending point before which to fetch results.
   */
  before?: string | undefined;
  /**
   * Limit the number of items to return
   */
  limit?: number | undefined;
  /**
   * Direction of sorting
   */
  orderDirection?: OrderDirection | undefined;
  /**
   * Field to order by
   */
  orderBy?: string | undefined;
  /**
   * Include cursor item in response
   */
  includeCursor?: boolean | undefined;
  /**
   * Filter contexts by type
   */
  type?: string | undefined;
  /**
   * Filter contexts by id
   */
  id?: string | undefined;
  /**
   * Search contexts by type or id (supports partial matching across both fields)
   */
  search?: string | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type ContextsControllerListContextsResponse = {
  headers: { [k: string]: Array<string> };
  result: components.ListContextsResponseDto;
};

/** @internal */
export const OrderDirection$inboundSchema: z.ZodNativeEnum<typeof OrderDirection> = z.nativeEnum(OrderDirection);

/** @internal */
export const OrderDirection$outboundSchema: z.ZodNativeEnum<typeof OrderDirection> = OrderDirection$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OrderDirection$ {
  /** @deprecated use `OrderDirection$inboundSchema` instead. */
  export const inboundSchema = OrderDirection$inboundSchema;
  /** @deprecated use `OrderDirection$outboundSchema` instead. */
  export const outboundSchema = OrderDirection$outboundSchema;
}

/** @internal */
export const ContextsControllerListContextsRequest$inboundSchema: z.ZodType<
  ContextsControllerListContextsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    after: z.string().optional(),
    before: z.string().optional(),
    limit: z.number().optional(),
    orderDirection: OrderDirection$inboundSchema.optional(),
    orderBy: z.string().optional(),
    includeCursor: z.boolean().optional(),
    type: z.string().optional(),
    id: z.string().optional(),
    search: z.string().optional(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type ContextsControllerListContextsRequest$Outbound = {
  after?: string | undefined;
  before?: string | undefined;
  limit?: number | undefined;
  orderDirection?: string | undefined;
  orderBy?: string | undefined;
  includeCursor?: boolean | undefined;
  type?: string | undefined;
  id?: string | undefined;
  search?: string | undefined;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const ContextsControllerListContextsRequest$outboundSchema: z.ZodType<
  ContextsControllerListContextsRequest$Outbound,
  z.ZodTypeDef,
  ContextsControllerListContextsRequest
> = z
  .object({
    after: z.string().optional(),
    before: z.string().optional(),
    limit: z.number().optional(),
    orderDirection: OrderDirection$outboundSchema.optional(),
    orderBy: z.string().optional(),
    includeCursor: z.boolean().optional(),
    type: z.string().optional(),
    id: z.string().optional(),
    search: z.string().optional(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContextsControllerListContextsRequest$ {
  /** @deprecated use `ContextsControllerListContextsRequest$inboundSchema` instead. */
  export const inboundSchema = ContextsControllerListContextsRequest$inboundSchema;
  /** @deprecated use `ContextsControllerListContextsRequest$outboundSchema` instead. */
  export const outboundSchema = ContextsControllerListContextsRequest$outboundSchema;
  /** @deprecated use `ContextsControllerListContextsRequest$Outbound` instead. */
  export type Outbound = ContextsControllerListContextsRequest$Outbound;
}

export function contextsControllerListContextsRequestToJSON(
  contextsControllerListContextsRequest: ContextsControllerListContextsRequest
): string {
  return JSON.stringify(
    ContextsControllerListContextsRequest$outboundSchema.parse(contextsControllerListContextsRequest)
  );
}

export function contextsControllerListContextsRequestFromJSON(
  jsonString: string
): SafeParseResult<ContextsControllerListContextsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContextsControllerListContextsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContextsControllerListContextsRequest' from JSON`
  );
}

/** @internal */
export const ContextsControllerListContextsResponse$inboundSchema: z.ZodType<
  ContextsControllerListContextsResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.ListContextsResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type ContextsControllerListContextsResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.ListContextsResponseDto$Outbound;
};

/** @internal */
export const ContextsControllerListContextsResponse$outboundSchema: z.ZodType<
  ContextsControllerListContextsResponse$Outbound,
  z.ZodTypeDef,
  ContextsControllerListContextsResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.ListContextsResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContextsControllerListContextsResponse$ {
  /** @deprecated use `ContextsControllerListContextsResponse$inboundSchema` instead. */
  export const inboundSchema = ContextsControllerListContextsResponse$inboundSchema;
  /** @deprecated use `ContextsControllerListContextsResponse$outboundSchema` instead. */
  export const outboundSchema = ContextsControllerListContextsResponse$outboundSchema;
  /** @deprecated use `ContextsControllerListContextsResponse$Outbound` instead. */
  export type Outbound = ContextsControllerListContextsResponse$Outbound;
}

export function contextsControllerListContextsResponseToJSON(
  contextsControllerListContextsResponse: ContextsControllerListContextsResponse
): string {
  return JSON.stringify(
    ContextsControllerListContextsResponse$outboundSchema.parse(contextsControllerListContextsResponse)
  );
}

export function contextsControllerListContextsResponseFromJSON(
  jsonString: string
): SafeParseResult<ContextsControllerListContextsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContextsControllerListContextsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContextsControllerListContextsResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - contextsControllerListContextsRequestToJSON(contextsControllerListContextsRequest: ContextsControllerListContextsRequest)
 - contextsControllerListContextsRequestFromJSON(jsonString: string)
 - contextsControllerListContextsResponseToJSON(contextsControllerListContextsResponse: ContextsControllerListContextsResponse)
 - contextsControllerListContextsResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ContextsControllerListContextsRequest$Outbound;
}

export function contextsControllerListContextsReq...)
 - Outbound(ContextsControllerListContextsResponse$Outbound;
}

export function contextsControllerListContextsRe...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function contextsControllerListContextsRequestToJSON
- export function contextsControllerListContextsRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function contextsControllerListContextsResponseToJSON
- export function contextsControllerListContextsResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/contextscontrollerupdatecontext.ts
Tamaño: 5960 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type ContextsControllerUpdateContextRequest = {
  /**
   * Context type
   */
  type: string;
  /**
   * Context ID
   */
  id: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  updateContextRequestDto: components.UpdateContextRequestDto;
};

export type ContextsControllerUpdateContextResponse = {
  headers: { [k: string]: Array<string> };
  result: components.GetContextResponseDto;
};

/** @internal */
export const ContextsControllerUpdateContextRequest$inboundSchema: z.ZodType<
  ContextsControllerUpdateContextRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    type: z.string(),
    id: z.string(),
    'idempotency-key': z.string().optional(),
    UpdateContextRequestDto: components.UpdateContextRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      UpdateContextRequestDto: 'updateContextRequestDto',
    });
  });

/** @internal */
export type ContextsControllerUpdateContextRequest$Outbound = {
  type: string;
  id: string;
  'idempotency-key'?: string | undefined;
  UpdateContextRequestDto: components.UpdateContextRequestDto$Outbound;
};

/** @internal */
export const ContextsControllerUpdateContextRequest$outboundSchema: z.ZodType<
  ContextsControllerUpdateContextRequest$Outbound,
  z.ZodTypeDef,
  ContextsControllerUpdateContextRequest
> = z
  .object({
    type: z.string(),
    id: z.string(),
    idempotencyKey: z.string().optional(),
    updateContextRequestDto: components.UpdateContextRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      updateContextRequestDto: 'UpdateContextRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContextsControllerUpdateContextRequest$ {
  /** @deprecated use `ContextsControllerUpdateContextRequest$inboundSchema` instead. */
  export const inboundSchema = ContextsControllerUpdateContextRequest$inboundSchema;
  /** @deprecated use `ContextsControllerUpdateContextRequest$outboundSchema` instead. */
  export const outboundSchema = ContextsControllerUpdateContextRequest$outboundSchema;
  /** @deprecated use `ContextsControllerUpdateContextRequest$Outbound` instead. */
  export type Outbound = ContextsControllerUpdateContextRequest$Outbound;
}

export function contextsControllerUpdateContextRequestToJSON(
  contextsControllerUpdateContextRequest: ContextsControllerUpdateContextRequest
): string {
  return JSON.stringify(
    ContextsControllerUpdateContextRequest$outboundSchema.parse(contextsControllerUpdateContextRequest)
  );
}

export function contextsControllerUpdateContextRequestFromJSON(
  jsonString: string
): SafeParseResult<ContextsControllerUpdateContextRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContextsControllerUpdateContextRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContextsControllerUpdateContextRequest' from JSON`
  );
}

/** @internal */
export const ContextsControllerUpdateContextResponse$inboundSchema: z.ZodType<
  ContextsControllerUpdateContextResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.GetContextResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type ContextsControllerUpdateContextResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.GetContextResponseDto$Outbound;
};

/** @internal */
export const ContextsControllerUpdateContextResponse$outboundSchema: z.ZodType<
  ContextsControllerUpdateContextResponse$Outbound,
  z.ZodTypeDef,
  ContextsControllerUpdateContextResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.GetContextResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContextsControllerUpdateContextResponse$ {
  /** @deprecated use `ContextsControllerUpdateContextResponse$inboundSchema` instead. */
  export const inboundSchema = ContextsControllerUpdateContextResponse$inboundSchema;
  /** @deprecated use `ContextsControllerUpdateContextResponse$outboundSchema` instead. */
  export const outboundSchema = ContextsControllerUpdateContextResponse$outboundSchema;
  /** @deprecated use `ContextsControllerUpdateContextResponse$Outbound` instead. */
  export type Outbound = ContextsControllerUpdateContextResponse$Outbound;
}

export function contextsControllerUpdateContextResponseToJSON(
  contextsControllerUpdateContextResponse: ContextsControllerUpdateContextResponse
): string {
  return JSON.stringify(
    ContextsControllerUpdateContextResponse$outboundSchema.parse(contextsControllerUpdateContextResponse)
  );
}

export function contextsControllerUpdateContextResponseFromJSON(
  jsonString: string
): SafeParseResult<ContextsControllerUpdateContextResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContextsControllerUpdateContextResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContextsControllerUpdateContextResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - contextsControllerUpdateContextRequestToJSON(contextsControllerUpdateContextRequest: ContextsControllerUpdateContextRequest)
 - contextsControllerUpdateContextRequestFromJSON(jsonString: string)
 - contextsControllerUpdateContextResponseToJSON(contextsControllerUpdateContextResponse: ContextsControllerUpdateContextResponse)
 - contextsControllerUpdateContextResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ContextsControllerUpdateContextRequest$Outbound;
}

export function contextsControllerUpdateContextR...)
 - Outbound(ContextsControllerUpdateContextResponse$Outbound;
}

export function contextsControllerUpdateContext...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function contextsControllerUpdateContextRequestToJSON
- export function contextsControllerUpdateContextRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function contextsControllerUpdateContextResponseToJSON
- export function contextsControllerUpdateContextResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/environmentscontrollergetenvironmenttags.ts
Tamaño: 6004 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type EnvironmentsControllerGetEnvironmentTagsRequest = {
  /**
   * Environment internal ID (MongoDB ObjectId) or identifier
   */
  environmentId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type EnvironmentsControllerGetEnvironmentTagsResponse = {
  headers: { [k: string]: Array<string> };
  result: Array<components.GetEnvironmentTagsDto>;
};

/** @internal */
export const EnvironmentsControllerGetEnvironmentTagsRequest$inboundSchema: z.ZodType<
  EnvironmentsControllerGetEnvironmentTagsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    environmentId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type EnvironmentsControllerGetEnvironmentTagsRequest$Outbound = {
  environmentId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const EnvironmentsControllerGetEnvironmentTagsRequest$outboundSchema: z.ZodType<
  EnvironmentsControllerGetEnvironmentTagsRequest$Outbound,
  z.ZodTypeDef,
  EnvironmentsControllerGetEnvironmentTagsRequest
> = z
  .object({
    environmentId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EnvironmentsControllerGetEnvironmentTagsRequest$ {
  /** @deprecated use `EnvironmentsControllerGetEnvironmentTagsRequest$inboundSchema` instead. */
  export const inboundSchema = EnvironmentsControllerGetEnvironmentTagsRequest$inboundSchema;
  /** @deprecated use `EnvironmentsControllerGetEnvironmentTagsRequest$outboundSchema` instead. */
  export const outboundSchema = EnvironmentsControllerGetEnvironmentTagsRequest$outboundSchema;
  /** @deprecated use `EnvironmentsControllerGetEnvironmentTagsRequest$Outbound` instead. */
  export type Outbound = EnvironmentsControllerGetEnvironmentTagsRequest$Outbound;
}

export function environmentsControllerGetEnvironmentTagsRequestToJSON(
  environmentsControllerGetEnvironmentTagsRequest: EnvironmentsControllerGetEnvironmentTagsRequest
): string {
  return JSON.stringify(
    EnvironmentsControllerGetEnvironmentTagsRequest$outboundSchema.parse(
      environmentsControllerGetEnvironmentTagsRequest
    )
  );
}

export function environmentsControllerGetEnvironmentTagsRequestFromJSON(
  jsonString: string
): SafeParseResult<EnvironmentsControllerGetEnvironmentTagsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EnvironmentsControllerGetEnvironmentTagsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EnvironmentsControllerGetEnvironmentTagsRequest' from JSON`
  );
}

/** @internal */
export const EnvironmentsControllerGetEnvironmentTagsResponse$inboundSchema: z.ZodType<
  EnvironmentsControllerGetEnvironmentTagsResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: z.array(components.GetEnvironmentTagsDto$inboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type EnvironmentsControllerGetEnvironmentTagsResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: Array<components.GetEnvironmentTagsDto$Outbound>;
};

/** @internal */
export const EnvironmentsControllerGetEnvironmentTagsResponse$outboundSchema: z.ZodType<
  EnvironmentsControllerGetEnvironmentTagsResponse$Outbound,
  z.ZodTypeDef,
  EnvironmentsControllerGetEnvironmentTagsResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: z.array(components.GetEnvironmentTagsDto$outboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EnvironmentsControllerGetEnvironmentTagsResponse$ {
  /** @deprecated use `EnvironmentsControllerGetEnvironmentTagsResponse$inboundSchema` instead. */
  export const inboundSchema = EnvironmentsControllerGetEnvironmentTagsResponse$inboundSchema;
  /** @deprecated use `EnvironmentsControllerGetEnvironmentTagsResponse$outboundSchema` instead. */
  export const outboundSchema = EnvironmentsControllerGetEnvironmentTagsResponse$outboundSchema;
  /** @deprecated use `EnvironmentsControllerGetEnvironmentTagsResponse$Outbound` instead. */
  export type Outbound = EnvironmentsControllerGetEnvironmentTagsResponse$Outbound;
}

export function environmentsControllerGetEnvironmentTagsResponseToJSON(
  environmentsControllerGetEnvironmentTagsResponse: EnvironmentsControllerGetEnvironmentTagsResponse
): string {
  return JSON.stringify(
    EnvironmentsControllerGetEnvironmentTagsResponse$outboundSchema.parse(
      environmentsControllerGetEnvironmentTagsResponse
    )
  );
}

export function environmentsControllerGetEnvironmentTagsResponseFromJSON(
  jsonString: string
): SafeParseResult<EnvironmentsControllerGetEnvironmentTagsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EnvironmentsControllerGetEnvironmentTagsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EnvironmentsControllerGetEnvironmentTagsResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - environmentsControllerGetEnvironmentTagsRequestToJSON(environmentsControllerGetEnvironmentTagsRequest: EnvironmentsControllerGetEnvironmentTagsRequest)
 - environmentsControllerGetEnvironmentTagsRequestFromJSON(jsonString: string)
 - environmentsControllerGetEnvironmentTagsResponseToJSON(environmentsControllerGetEnvironmentTagsResponse: EnvironmentsControllerGetEnvironmentTagsResponse)
 - environmentsControllerGetEnvironmentTagsResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(EnvironmentsControllerGetEnvironmentTagsRequest$Outbound;
}

export function environmentsControllerG...)
 - Outbound(EnvironmentsControllerGetEnvironmentTagsResponse$Outbound;
}

export function environmentsController...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function environmentsControllerGetEnvironmentTagsRequestToJSON
- export function environmentsControllerGetEnvironmentTagsRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function environmentsControllerGetEnvironmentTagsResponseToJSON
- export function environmentsControllerGetEnvironmentTagsResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/environmentscontrollerv1createenvironment.ts
Tamaño: 6294 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type EnvironmentsControllerV1CreateEnvironmentRequest = {
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  createEnvironmentRequestDto: components.CreateEnvironmentRequestDto;
};

export type EnvironmentsControllerV1CreateEnvironmentResponse = {
  headers: { [k: string]: Array<string> };
  result: components.EnvironmentResponseDto;
};

/** @internal */
export const EnvironmentsControllerV1CreateEnvironmentRequest$inboundSchema: z.ZodType<
  EnvironmentsControllerV1CreateEnvironmentRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    'idempotency-key': z.string().optional(),
    CreateEnvironmentRequestDto: components.CreateEnvironmentRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      CreateEnvironmentRequestDto: 'createEnvironmentRequestDto',
    });
  });

/** @internal */
export type EnvironmentsControllerV1CreateEnvironmentRequest$Outbound = {
  'idempotency-key'?: string | undefined;
  CreateEnvironmentRequestDto: components.CreateEnvironmentRequestDto$Outbound;
};

/** @internal */
export const EnvironmentsControllerV1CreateEnvironmentRequest$outboundSchema: z.ZodType<
  EnvironmentsControllerV1CreateEnvironmentRequest$Outbound,
  z.ZodTypeDef,
  EnvironmentsControllerV1CreateEnvironmentRequest
> = z
  .object({
    idempotencyKey: z.string().optional(),
    createEnvironmentRequestDto: components.CreateEnvironmentRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      createEnvironmentRequestDto: 'CreateEnvironmentRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EnvironmentsControllerV1CreateEnvironmentRequest$ {
  /** @deprecated use `EnvironmentsControllerV1CreateEnvironmentRequest$inboundSchema` instead. */
  export const inboundSchema = EnvironmentsControllerV1CreateEnvironmentRequest$inboundSchema;
  /** @deprecated use `EnvironmentsControllerV1CreateEnvironmentRequest$outboundSchema` instead. */
  export const outboundSchema = EnvironmentsControllerV1CreateEnvironmentRequest$outboundSchema;
  /** @deprecated use `EnvironmentsControllerV1CreateEnvironmentRequest$Outbound` instead. */
  export type Outbound = EnvironmentsControllerV1CreateEnvironmentRequest$Outbound;
}

export function environmentsControllerV1CreateEnvironmentRequestToJSON(
  environmentsControllerV1CreateEnvironmentRequest: EnvironmentsControllerV1CreateEnvironmentRequest
): string {
  return JSON.stringify(
    EnvironmentsControllerV1CreateEnvironmentRequest$outboundSchema.parse(
      environmentsControllerV1CreateEnvironmentRequest
    )
  );
}

export function environmentsControllerV1CreateEnvironmentRequestFromJSON(
  jsonString: string
): SafeParseResult<EnvironmentsControllerV1CreateEnvironmentRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EnvironmentsControllerV1CreateEnvironmentRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EnvironmentsControllerV1CreateEnvironmentRequest' from JSON`
  );
}

/** @internal */
export const EnvironmentsControllerV1CreateEnvironmentResponse$inboundSchema: z.ZodType<
  EnvironmentsControllerV1CreateEnvironmentResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.EnvironmentResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type EnvironmentsControllerV1CreateEnvironmentResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.EnvironmentResponseDto$Outbound;
};

/** @internal */
export const EnvironmentsControllerV1CreateEnvironmentResponse$outboundSchema: z.ZodType<
  EnvironmentsControllerV1CreateEnvironmentResponse$Outbound,
  z.ZodTypeDef,
  EnvironmentsControllerV1CreateEnvironmentResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.EnvironmentResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EnvironmentsControllerV1CreateEnvironmentResponse$ {
  /** @deprecated use `EnvironmentsControllerV1CreateEnvironmentResponse$inboundSchema` instead. */
  export const inboundSchema = EnvironmentsControllerV1CreateEnvironmentResponse$inboundSchema;
  /** @deprecated use `EnvironmentsControllerV1CreateEnvironmentResponse$outboundSchema` instead. */
  export const outboundSchema = EnvironmentsControllerV1CreateEnvironmentResponse$outboundSchema;
  /** @deprecated use `EnvironmentsControllerV1CreateEnvironmentResponse$Outbound` instead. */
  export type Outbound = EnvironmentsControllerV1CreateEnvironmentResponse$Outbound;
}

export function environmentsControllerV1CreateEnvironmentResponseToJSON(
  environmentsControllerV1CreateEnvironmentResponse: EnvironmentsControllerV1CreateEnvironmentResponse
): string {
  return JSON.stringify(
    EnvironmentsControllerV1CreateEnvironmentResponse$outboundSchema.parse(
      environmentsControllerV1CreateEnvironmentResponse
    )
  );
}

export function environmentsControllerV1CreateEnvironmentResponseFromJSON(
  jsonString: string
): SafeParseResult<EnvironmentsControllerV1CreateEnvironmentResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EnvironmentsControllerV1CreateEnvironmentResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EnvironmentsControllerV1CreateEnvironmentResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - environmentsControllerV1CreateEnvironmentRequestToJSON(environmentsControllerV1CreateEnvironmentRequest: EnvironmentsControllerV1CreateEnvironmentRequest)
 - environmentsControllerV1CreateEnvironmentRequestFromJSON(jsonString: string)
 - environmentsControllerV1CreateEnvironmentResponseToJSON(environmentsControllerV1CreateEnvironmentResponse: EnvironmentsControllerV1CreateEnvironmentResponse)
 - environmentsControllerV1CreateEnvironmentResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(EnvironmentsControllerV1CreateEnvironmentRequest$Outbound;
}

export function environmentsController...)
 - Outbound(EnvironmentsControllerV1CreateEnvironmentResponse$Outbound;
}

export function environmentsControlle...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function environmentsControllerV1CreateEnvironmentRequestToJSON
- export function environmentsControllerV1CreateEnvironmentRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function environmentsControllerV1CreateEnvironmentResponseToJSON
- export function environmentsControllerV1CreateEnvironmentResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/environmentscontrollerv1deleteenvironment.ts
Tamaño: 5682 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type EnvironmentsControllerV1DeleteEnvironmentRequest = {
  /**
   * The unique identifier of the environment
   */
  environmentId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type EnvironmentsControllerV1DeleteEnvironmentResponse = {
  headers: { [k: string]: Array<string> };
};

/** @internal */
export const EnvironmentsControllerV1DeleteEnvironmentRequest$inboundSchema: z.ZodType<
  EnvironmentsControllerV1DeleteEnvironmentRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    environmentId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type EnvironmentsControllerV1DeleteEnvironmentRequest$Outbound = {
  environmentId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const EnvironmentsControllerV1DeleteEnvironmentRequest$outboundSchema: z.ZodType<
  EnvironmentsControllerV1DeleteEnvironmentRequest$Outbound,
  z.ZodTypeDef,
  EnvironmentsControllerV1DeleteEnvironmentRequest
> = z
  .object({
    environmentId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EnvironmentsControllerV1DeleteEnvironmentRequest$ {
  /** @deprecated use `EnvironmentsControllerV1DeleteEnvironmentRequest$inboundSchema` instead. */
  export const inboundSchema = EnvironmentsControllerV1DeleteEnvironmentRequest$inboundSchema;
  /** @deprecated use `EnvironmentsControllerV1DeleteEnvironmentRequest$outboundSchema` instead. */
  export const outboundSchema = EnvironmentsControllerV1DeleteEnvironmentRequest$outboundSchema;
  /** @deprecated use `EnvironmentsControllerV1DeleteEnvironmentRequest$Outbound` instead. */
  export type Outbound = EnvironmentsControllerV1DeleteEnvironmentRequest$Outbound;
}

export function environmentsControllerV1DeleteEnvironmentRequestToJSON(
  environmentsControllerV1DeleteEnvironmentRequest: EnvironmentsControllerV1DeleteEnvironmentRequest
): string {
  return JSON.stringify(
    EnvironmentsControllerV1DeleteEnvironmentRequest$outboundSchema.parse(
      environmentsControllerV1DeleteEnvironmentRequest
    )
  );
}

export function environmentsControllerV1DeleteEnvironmentRequestFromJSON(
  jsonString: string
): SafeParseResult<EnvironmentsControllerV1DeleteEnvironmentRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EnvironmentsControllerV1DeleteEnvironmentRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EnvironmentsControllerV1DeleteEnvironmentRequest' from JSON`
  );
}

/** @internal */
export const EnvironmentsControllerV1DeleteEnvironmentResponse$inboundSchema: z.ZodType<
  EnvironmentsControllerV1DeleteEnvironmentResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
    });
  });

/** @internal */
export type EnvironmentsControllerV1DeleteEnvironmentResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
};

/** @internal */
export const EnvironmentsControllerV1DeleteEnvironmentResponse$outboundSchema: z.ZodType<
  EnvironmentsControllerV1DeleteEnvironmentResponse$Outbound,
  z.ZodTypeDef,
  EnvironmentsControllerV1DeleteEnvironmentResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EnvironmentsControllerV1DeleteEnvironmentResponse$ {
  /** @deprecated use `EnvironmentsControllerV1DeleteEnvironmentResponse$inboundSchema` instead. */
  export const inboundSchema = EnvironmentsControllerV1DeleteEnvironmentResponse$inboundSchema;
  /** @deprecated use `EnvironmentsControllerV1DeleteEnvironmentResponse$outboundSchema` instead. */
  export const outboundSchema = EnvironmentsControllerV1DeleteEnvironmentResponse$outboundSchema;
  /** @deprecated use `EnvironmentsControllerV1DeleteEnvironmentResponse$Outbound` instead. */
  export type Outbound = EnvironmentsControllerV1DeleteEnvironmentResponse$Outbound;
}

export function environmentsControllerV1DeleteEnvironmentResponseToJSON(
  environmentsControllerV1DeleteEnvironmentResponse: EnvironmentsControllerV1DeleteEnvironmentResponse
): string {
  return JSON.stringify(
    EnvironmentsControllerV1DeleteEnvironmentResponse$outboundSchema.parse(
      environmentsControllerV1DeleteEnvironmentResponse
    )
  );
}

export function environmentsControllerV1DeleteEnvironmentResponseFromJSON(
  jsonString: string
): SafeParseResult<EnvironmentsControllerV1DeleteEnvironmentResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EnvironmentsControllerV1DeleteEnvironmentResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EnvironmentsControllerV1DeleteEnvironmentResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - environmentsControllerV1DeleteEnvironmentRequestToJSON(environmentsControllerV1DeleteEnvironmentRequest: EnvironmentsControllerV1DeleteEnvironmentRequest)
 - environmentsControllerV1DeleteEnvironmentRequestFromJSON(jsonString: string)
 - environmentsControllerV1DeleteEnvironmentResponseToJSON(environmentsControllerV1DeleteEnvironmentResponse: EnvironmentsControllerV1DeleteEnvironmentResponse)
 - environmentsControllerV1DeleteEnvironmentResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(EnvironmentsControllerV1DeleteEnvironmentRequest$Outbound;
}

export function environmentsController...)
 - Outbound(EnvironmentsControllerV1DeleteEnvironmentResponse$Outbound;
}

export function environmentsControlle...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function environmentsControllerV1DeleteEnvironmentRequestToJSON
- export function environmentsControllerV1DeleteEnvironmentRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function environmentsControllerV1DeleteEnvironmentResponseToJSON
- export function environmentsControllerV1DeleteEnvironmentResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/environmentscontrollerv1listmyenvironments.ts
Tamaño: 5914 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type EnvironmentsControllerV1ListMyEnvironmentsRequest = {
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type EnvironmentsControllerV1ListMyEnvironmentsResponse = {
  headers: { [k: string]: Array<string> };
  result: Array<components.EnvironmentResponseDto>;
};

/** @internal */
export const EnvironmentsControllerV1ListMyEnvironmentsRequest$inboundSchema: z.ZodType<
  EnvironmentsControllerV1ListMyEnvironmentsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type EnvironmentsControllerV1ListMyEnvironmentsRequest$Outbound = {
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const EnvironmentsControllerV1ListMyEnvironmentsRequest$outboundSchema: z.ZodType<
  EnvironmentsControllerV1ListMyEnvironmentsRequest$Outbound,
  z.ZodTypeDef,
  EnvironmentsControllerV1ListMyEnvironmentsRequest
> = z
  .object({
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EnvironmentsControllerV1ListMyEnvironmentsRequest$ {
  /** @deprecated use `EnvironmentsControllerV1ListMyEnvironmentsRequest$inboundSchema` instead. */
  export const inboundSchema = EnvironmentsControllerV1ListMyEnvironmentsRequest$inboundSchema;
  /** @deprecated use `EnvironmentsControllerV1ListMyEnvironmentsRequest$outboundSchema` instead. */
  export const outboundSchema = EnvironmentsControllerV1ListMyEnvironmentsRequest$outboundSchema;
  /** @deprecated use `EnvironmentsControllerV1ListMyEnvironmentsRequest$Outbound` instead. */
  export type Outbound = EnvironmentsControllerV1ListMyEnvironmentsRequest$Outbound;
}

export function environmentsControllerV1ListMyEnvironmentsRequestToJSON(
  environmentsControllerV1ListMyEnvironmentsRequest: EnvironmentsControllerV1ListMyEnvironmentsRequest
): string {
  return JSON.stringify(
    EnvironmentsControllerV1ListMyEnvironmentsRequest$outboundSchema.parse(
      environmentsControllerV1ListMyEnvironmentsRequest
    )
  );
}

export function environmentsControllerV1ListMyEnvironmentsRequestFromJSON(
  jsonString: string
): SafeParseResult<EnvironmentsControllerV1ListMyEnvironmentsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EnvironmentsControllerV1ListMyEnvironmentsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EnvironmentsControllerV1ListMyEnvironmentsRequest' from JSON`
  );
}

/** @internal */
export const EnvironmentsControllerV1ListMyEnvironmentsResponse$inboundSchema: z.ZodType<
  EnvironmentsControllerV1ListMyEnvironmentsResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: z.array(components.EnvironmentResponseDto$inboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type EnvironmentsControllerV1ListMyEnvironmentsResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: Array<components.EnvironmentResponseDto$Outbound>;
};

/** @internal */
export const EnvironmentsControllerV1ListMyEnvironmentsResponse$outboundSchema: z.ZodType<
  EnvironmentsControllerV1ListMyEnvironmentsResponse$Outbound,
  z.ZodTypeDef,
  EnvironmentsControllerV1ListMyEnvironmentsResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: z.array(components.EnvironmentResponseDto$outboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EnvironmentsControllerV1ListMyEnvironmentsResponse$ {
  /** @deprecated use `EnvironmentsControllerV1ListMyEnvironmentsResponse$inboundSchema` instead. */
  export const inboundSchema = EnvironmentsControllerV1ListMyEnvironmentsResponse$inboundSchema;
  /** @deprecated use `EnvironmentsControllerV1ListMyEnvironmentsResponse$outboundSchema` instead. */
  export const outboundSchema = EnvironmentsControllerV1ListMyEnvironmentsResponse$outboundSchema;
  /** @deprecated use `EnvironmentsControllerV1ListMyEnvironmentsResponse$Outbound` instead. */
  export type Outbound = EnvironmentsControllerV1ListMyEnvironmentsResponse$Outbound;
}

export function environmentsControllerV1ListMyEnvironmentsResponseToJSON(
  environmentsControllerV1ListMyEnvironmentsResponse: EnvironmentsControllerV1ListMyEnvironmentsResponse
): string {
  return JSON.stringify(
    EnvironmentsControllerV1ListMyEnvironmentsResponse$outboundSchema.parse(
      environmentsControllerV1ListMyEnvironmentsResponse
    )
  );
}

export function environmentsControllerV1ListMyEnvironmentsResponseFromJSON(
  jsonString: string
): SafeParseResult<EnvironmentsControllerV1ListMyEnvironmentsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EnvironmentsControllerV1ListMyEnvironmentsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EnvironmentsControllerV1ListMyEnvironmentsResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - environmentsControllerV1ListMyEnvironmentsRequestToJSON(environmentsControllerV1ListMyEnvironmentsRequest: EnvironmentsControllerV1ListMyEnvironmentsRequest)
 - environmentsControllerV1ListMyEnvironmentsRequestFromJSON(jsonString: string)
 - environmentsControllerV1ListMyEnvironmentsResponseToJSON(environmentsControllerV1ListMyEnvironmentsResponse: EnvironmentsControllerV1ListMyEnvironmentsResponse)
 - environmentsControllerV1ListMyEnvironmentsResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(EnvironmentsControllerV1ListMyEnvironmentsRequest$Outbound;
}

export function environmentsControlle...)
 - Outbound(EnvironmentsControllerV1ListMyEnvironmentsResponse$Outbound;
}

export function environmentsControll...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function environmentsControllerV1ListMyEnvironmentsRequestToJSON
- export function environmentsControllerV1ListMyEnvironmentsRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function environmentsControllerV1ListMyEnvironmentsResponseToJSON
- export function environmentsControllerV1ListMyEnvironmentsResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/environmentscontrollerv1updatemyenvironment.ts
Tamaño: 6556 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type EnvironmentsControllerV1UpdateMyEnvironmentRequest = {
  /**
   * The unique identifier of the environment
   */
  environmentId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  updateEnvironmentRequestDto: components.UpdateEnvironmentRequestDto;
};

export type EnvironmentsControllerV1UpdateMyEnvironmentResponse = {
  headers: { [k: string]: Array<string> };
  result: components.EnvironmentResponseDto;
};

/** @internal */
export const EnvironmentsControllerV1UpdateMyEnvironmentRequest$inboundSchema: z.ZodType<
  EnvironmentsControllerV1UpdateMyEnvironmentRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    environmentId: z.string(),
    'idempotency-key': z.string().optional(),
    UpdateEnvironmentRequestDto: components.UpdateEnvironmentRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      UpdateEnvironmentRequestDto: 'updateEnvironmentRequestDto',
    });
  });

/** @internal */
export type EnvironmentsControllerV1UpdateMyEnvironmentRequest$Outbound = {
  environmentId: string;
  'idempotency-key'?: string | undefined;
  UpdateEnvironmentRequestDto: components.UpdateEnvironmentRequestDto$Outbound;
};

/** @internal */
export const EnvironmentsControllerV1UpdateMyEnvironmentRequest$outboundSchema: z.ZodType<
  EnvironmentsControllerV1UpdateMyEnvironmentRequest$Outbound,
  z.ZodTypeDef,
  EnvironmentsControllerV1UpdateMyEnvironmentRequest
> = z
  .object({
    environmentId: z.string(),
    idempotencyKey: z.string().optional(),
    updateEnvironmentRequestDto: components.UpdateEnvironmentRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      updateEnvironmentRequestDto: 'UpdateEnvironmentRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EnvironmentsControllerV1UpdateMyEnvironmentRequest$ {
  /** @deprecated use `EnvironmentsControllerV1UpdateMyEnvironmentRequest$inboundSchema` instead. */
  export const inboundSchema = EnvironmentsControllerV1UpdateMyEnvironmentRequest$inboundSchema;
  /** @deprecated use `EnvironmentsControllerV1UpdateMyEnvironmentRequest$outboundSchema` instead. */
  export const outboundSchema = EnvironmentsControllerV1UpdateMyEnvironmentRequest$outboundSchema;
  /** @deprecated use `EnvironmentsControllerV1UpdateMyEnvironmentRequest$Outbound` instead. */
  export type Outbound = EnvironmentsControllerV1UpdateMyEnvironmentRequest$Outbound;
}

export function environmentsControllerV1UpdateMyEnvironmentRequestToJSON(
  environmentsControllerV1UpdateMyEnvironmentRequest: EnvironmentsControllerV1UpdateMyEnvironmentRequest
): string {
  return JSON.stringify(
    EnvironmentsControllerV1UpdateMyEnvironmentRequest$outboundSchema.parse(
      environmentsControllerV1UpdateMyEnvironmentRequest
    )
  );
}

export function environmentsControllerV1UpdateMyEnvironmentRequestFromJSON(
  jsonString: string
): SafeParseResult<EnvironmentsControllerV1UpdateMyEnvironmentRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EnvironmentsControllerV1UpdateMyEnvironmentRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EnvironmentsControllerV1UpdateMyEnvironmentRequest' from JSON`
  );
}

/** @internal */
export const EnvironmentsControllerV1UpdateMyEnvironmentResponse$inboundSchema: z.ZodType<
  EnvironmentsControllerV1UpdateMyEnvironmentResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.EnvironmentResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type EnvironmentsControllerV1UpdateMyEnvironmentResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.EnvironmentResponseDto$Outbound;
};

/** @internal */
export const EnvironmentsControllerV1UpdateMyEnvironmentResponse$outboundSchema: z.ZodType<
  EnvironmentsControllerV1UpdateMyEnvironmentResponse$Outbound,
  z.ZodTypeDef,
  EnvironmentsControllerV1UpdateMyEnvironmentResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.EnvironmentResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EnvironmentsControllerV1UpdateMyEnvironmentResponse$ {
  /** @deprecated use `EnvironmentsControllerV1UpdateMyEnvironmentResponse$inboundSchema` instead. */
  export const inboundSchema = EnvironmentsControllerV1UpdateMyEnvironmentResponse$inboundSchema;
  /** @deprecated use `EnvironmentsControllerV1UpdateMyEnvironmentResponse$outboundSchema` instead. */
  export const outboundSchema = EnvironmentsControllerV1UpdateMyEnvironmentResponse$outboundSchema;
  /** @deprecated use `EnvironmentsControllerV1UpdateMyEnvironmentResponse$Outbound` instead. */
  export type Outbound = EnvironmentsControllerV1UpdateMyEnvironmentResponse$Outbound;
}

export function environmentsControllerV1UpdateMyEnvironmentResponseToJSON(
  environmentsControllerV1UpdateMyEnvironmentResponse: EnvironmentsControllerV1UpdateMyEnvironmentResponse
): string {
  return JSON.stringify(
    EnvironmentsControllerV1UpdateMyEnvironmentResponse$outboundSchema.parse(
      environmentsControllerV1UpdateMyEnvironmentResponse
    )
  );
}

export function environmentsControllerV1UpdateMyEnvironmentResponseFromJSON(
  jsonString: string
): SafeParseResult<EnvironmentsControllerV1UpdateMyEnvironmentResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EnvironmentsControllerV1UpdateMyEnvironmentResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EnvironmentsControllerV1UpdateMyEnvironmentResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - environmentsControllerV1UpdateMyEnvironmentRequestToJSON(environmentsControllerV1UpdateMyEnvironmentRequest: EnvironmentsControllerV1UpdateMyEnvironmentRequest)
 - environmentsControllerV1UpdateMyEnvironmentRequestFromJSON(jsonString: string)
 - environmentsControllerV1UpdateMyEnvironmentResponseToJSON(environmentsControllerV1UpdateMyEnvironmentResponse: EnvironmentsControllerV1UpdateMyEnvironmentResponse)
 - environmentsControllerV1UpdateMyEnvironmentResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(EnvironmentsControllerV1UpdateMyEnvironmentRequest$Outbound;
}

export function environmentsControll...)
 - Outbound(EnvironmentsControllerV1UpdateMyEnvironmentResponse$Outbound;
}

export function environmentsControl...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function environmentsControllerV1UpdateMyEnvironmentRequestToJSON
- export function environmentsControllerV1UpdateMyEnvironmentRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function environmentsControllerV1UpdateMyEnvironmentResponseToJSON
- export function environmentsControllerV1UpdateMyEnvironmentResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/eventscontrollerbroadcasteventtoall.ts
Tamaño: 5998 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type EventsControllerBroadcastEventToAllRequest = {
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  triggerEventToAllRequestDto: components.TriggerEventToAllRequestDto;
};

export type EventsControllerBroadcastEventToAllResponse = {
  headers: { [k: string]: Array<string> };
  result: components.TriggerEventResponseDto;
};

/** @internal */
export const EventsControllerBroadcastEventToAllRequest$inboundSchema: z.ZodType<
  EventsControllerBroadcastEventToAllRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    'idempotency-key': z.string().optional(),
    TriggerEventToAllRequestDto: components.TriggerEventToAllRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      TriggerEventToAllRequestDto: 'triggerEventToAllRequestDto',
    });
  });

/** @internal */
export type EventsControllerBroadcastEventToAllRequest$Outbound = {
  'idempotency-key'?: string | undefined;
  TriggerEventToAllRequestDto: components.TriggerEventToAllRequestDto$Outbound;
};

/** @internal */
export const EventsControllerBroadcastEventToAllRequest$outboundSchema: z.ZodType<
  EventsControllerBroadcastEventToAllRequest$Outbound,
  z.ZodTypeDef,
  EventsControllerBroadcastEventToAllRequest
> = z
  .object({
    idempotencyKey: z.string().optional(),
    triggerEventToAllRequestDto: components.TriggerEventToAllRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      triggerEventToAllRequestDto: 'TriggerEventToAllRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EventsControllerBroadcastEventToAllRequest$ {
  /** @deprecated use `EventsControllerBroadcastEventToAllRequest$inboundSchema` instead. */
  export const inboundSchema = EventsControllerBroadcastEventToAllRequest$inboundSchema;
  /** @deprecated use `EventsControllerBroadcastEventToAllRequest$outboundSchema` instead. */
  export const outboundSchema = EventsControllerBroadcastEventToAllRequest$outboundSchema;
  /** @deprecated use `EventsControllerBroadcastEventToAllRequest$Outbound` instead. */
  export type Outbound = EventsControllerBroadcastEventToAllRequest$Outbound;
}

export function eventsControllerBroadcastEventToAllRequestToJSON(
  eventsControllerBroadcastEventToAllRequest: EventsControllerBroadcastEventToAllRequest
): string {
  return JSON.stringify(
    EventsControllerBroadcastEventToAllRequest$outboundSchema.parse(eventsControllerBroadcastEventToAllRequest)
  );
}

export function eventsControllerBroadcastEventToAllRequestFromJSON(
  jsonString: string
): SafeParseResult<EventsControllerBroadcastEventToAllRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EventsControllerBroadcastEventToAllRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EventsControllerBroadcastEventToAllRequest' from JSON`
  );
}

/** @internal */
export const EventsControllerBroadcastEventToAllResponse$inboundSchema: z.ZodType<
  EventsControllerBroadcastEventToAllResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.TriggerEventResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type EventsControllerBroadcastEventToAllResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.TriggerEventResponseDto$Outbound;
};

/** @internal */
export const EventsControllerBroadcastEventToAllResponse$outboundSchema: z.ZodType<
  EventsControllerBroadcastEventToAllResponse$Outbound,
  z.ZodTypeDef,
  EventsControllerBroadcastEventToAllResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.TriggerEventResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EventsControllerBroadcastEventToAllResponse$ {
  /** @deprecated use `EventsControllerBroadcastEventToAllResponse$inboundSchema` instead. */
  export const inboundSchema = EventsControllerBroadcastEventToAllResponse$inboundSchema;
  /** @deprecated use `EventsControllerBroadcastEventToAllResponse$outboundSchema` instead. */
  export const outboundSchema = EventsControllerBroadcastEventToAllResponse$outboundSchema;
  /** @deprecated use `EventsControllerBroadcastEventToAllResponse$Outbound` instead. */
  export type Outbound = EventsControllerBroadcastEventToAllResponse$Outbound;
}

export function eventsControllerBroadcastEventToAllResponseToJSON(
  eventsControllerBroadcastEventToAllResponse: EventsControllerBroadcastEventToAllResponse
): string {
  return JSON.stringify(
    EventsControllerBroadcastEventToAllResponse$outboundSchema.parse(eventsControllerBroadcastEventToAllResponse)
  );
}

export function eventsControllerBroadcastEventToAllResponseFromJSON(
  jsonString: string
): SafeParseResult<EventsControllerBroadcastEventToAllResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EventsControllerBroadcastEventToAllResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EventsControllerBroadcastEventToAllResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - eventsControllerBroadcastEventToAllRequestToJSON(eventsControllerBroadcastEventToAllRequest: EventsControllerBroadcastEventToAllRequest)
 - eventsControllerBroadcastEventToAllRequestFromJSON(jsonString: string)
 - eventsControllerBroadcastEventToAllResponseToJSON(eventsControllerBroadcastEventToAllResponse: EventsControllerBroadcastEventToAllResponse)
 - eventsControllerBroadcastEventToAllResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(EventsControllerBroadcastEventToAllRequest$Outbound;
}

export function eventsControllerBroadcastEve...)
 - Outbound(EventsControllerBroadcastEventToAllResponse$Outbound;
}

export function eventsControllerBroadcastEv...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function eventsControllerBroadcastEventToAllRequestToJSON
- export function eventsControllerBroadcastEventToAllRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function eventsControllerBroadcastEventToAllResponseToJSON
- export function eventsControllerBroadcastEventToAllResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/eventscontrollercancel.ts
Tamaño: 4846 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type EventsControllerCancelRequest = {
  transactionId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type EventsControllerCancelResponse = {
  headers: { [k: string]: Array<string> };
  result: boolean;
};

/** @internal */
export const EventsControllerCancelRequest$inboundSchema: z.ZodType<
  EventsControllerCancelRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    transactionId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type EventsControllerCancelRequest$Outbound = {
  transactionId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const EventsControllerCancelRequest$outboundSchema: z.ZodType<
  EventsControllerCancelRequest$Outbound,
  z.ZodTypeDef,
  EventsControllerCancelRequest
> = z
  .object({
    transactionId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EventsControllerCancelRequest$ {
  /** @deprecated use `EventsControllerCancelRequest$inboundSchema` instead. */
  export const inboundSchema = EventsControllerCancelRequest$inboundSchema;
  /** @deprecated use `EventsControllerCancelRequest$outboundSchema` instead. */
  export const outboundSchema = EventsControllerCancelRequest$outboundSchema;
  /** @deprecated use `EventsControllerCancelRequest$Outbound` instead. */
  export type Outbound = EventsControllerCancelRequest$Outbound;
}

export function eventsControllerCancelRequestToJSON(
  eventsControllerCancelRequest: EventsControllerCancelRequest
): string {
  return JSON.stringify(EventsControllerCancelRequest$outboundSchema.parse(eventsControllerCancelRequest));
}

export function eventsControllerCancelRequestFromJSON(
  jsonString: string
): SafeParseResult<EventsControllerCancelRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EventsControllerCancelRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EventsControllerCancelRequest' from JSON`
  );
}

/** @internal */
export const EventsControllerCancelResponse$inboundSchema: z.ZodType<
  EventsControllerCancelResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: z.boolean(),
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type EventsControllerCancelResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: boolean;
};

/** @internal */
export const EventsControllerCancelResponse$outboundSchema: z.ZodType<
  EventsControllerCancelResponse$Outbound,
  z.ZodTypeDef,
  EventsControllerCancelResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: z.boolean(),
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EventsControllerCancelResponse$ {
  /** @deprecated use `EventsControllerCancelResponse$inboundSchema` instead. */
  export const inboundSchema = EventsControllerCancelResponse$inboundSchema;
  /** @deprecated use `EventsControllerCancelResponse$outboundSchema` instead. */
  export const outboundSchema = EventsControllerCancelResponse$outboundSchema;
  /** @deprecated use `EventsControllerCancelResponse$Outbound` instead. */
  export type Outbound = EventsControllerCancelResponse$Outbound;
}

export function eventsControllerCancelResponseToJSON(
  eventsControllerCancelResponse: EventsControllerCancelResponse
): string {
  return JSON.stringify(EventsControllerCancelResponse$outboundSchema.parse(eventsControllerCancelResponse));
}

export function eventsControllerCancelResponseFromJSON(
  jsonString: string
): SafeParseResult<EventsControllerCancelResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EventsControllerCancelResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EventsControllerCancelResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - eventsControllerCancelRequestToJSON(eventsControllerCancelRequest: EventsControllerCancelRequest)
 - eventsControllerCancelRequestFromJSON(jsonString: string)
 - eventsControllerCancelResponseToJSON(eventsControllerCancelResponse: EventsControllerCancelResponse)
 - eventsControllerCancelResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(EventsControllerCancelRequest$Outbound;
}

export function eventsControllerCancelRequestToJSON(
  ev...)
 - Outbound(EventsControllerCancelResponse$Outbound;
}

export function eventsControllerCancelResponseToJSON(
  ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function eventsControllerCancelRequestToJSON
- export function eventsControllerCancelRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function eventsControllerCancelResponseToJSON
- export function eventsControllerCancelResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/eventscontrollertrigger.ts
Tamaño: 5370 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type EventsControllerTriggerRequest = {
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  triggerEventRequestDto: components.TriggerEventRequestDto;
};

export type EventsControllerTriggerResponse = {
  headers: { [k: string]: Array<string> };
  result: components.TriggerEventResponseDto;
};

/** @internal */
export const EventsControllerTriggerRequest$inboundSchema: z.ZodType<
  EventsControllerTriggerRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    'idempotency-key': z.string().optional(),
    TriggerEventRequestDto: components.TriggerEventRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      TriggerEventRequestDto: 'triggerEventRequestDto',
    });
  });

/** @internal */
export type EventsControllerTriggerRequest$Outbound = {
  'idempotency-key'?: string | undefined;
  TriggerEventRequestDto: components.TriggerEventRequestDto$Outbound;
};

/** @internal */
export const EventsControllerTriggerRequest$outboundSchema: z.ZodType<
  EventsControllerTriggerRequest$Outbound,
  z.ZodTypeDef,
  EventsControllerTriggerRequest
> = z
  .object({
    idempotencyKey: z.string().optional(),
    triggerEventRequestDto: components.TriggerEventRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      triggerEventRequestDto: 'TriggerEventRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EventsControllerTriggerRequest$ {
  /** @deprecated use `EventsControllerTriggerRequest$inboundSchema` instead. */
  export const inboundSchema = EventsControllerTriggerRequest$inboundSchema;
  /** @deprecated use `EventsControllerTriggerRequest$outboundSchema` instead. */
  export const outboundSchema = EventsControllerTriggerRequest$outboundSchema;
  /** @deprecated use `EventsControllerTriggerRequest$Outbound` instead. */
  export type Outbound = EventsControllerTriggerRequest$Outbound;
}

export function eventsControllerTriggerRequestToJSON(
  eventsControllerTriggerRequest: EventsControllerTriggerRequest
): string {
  return JSON.stringify(EventsControllerTriggerRequest$outboundSchema.parse(eventsControllerTriggerRequest));
}

export function eventsControllerTriggerRequestFromJSON(
  jsonString: string
): SafeParseResult<EventsControllerTriggerRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EventsControllerTriggerRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EventsControllerTriggerRequest' from JSON`
  );
}

/** @internal */
export const EventsControllerTriggerResponse$inboundSchema: z.ZodType<
  EventsControllerTriggerResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.TriggerEventResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type EventsControllerTriggerResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.TriggerEventResponseDto$Outbound;
};

/** @internal */
export const EventsControllerTriggerResponse$outboundSchema: z.ZodType<
  EventsControllerTriggerResponse$Outbound,
  z.ZodTypeDef,
  EventsControllerTriggerResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.TriggerEventResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EventsControllerTriggerResponse$ {
  /** @deprecated use `EventsControllerTriggerResponse$inboundSchema` instead. */
  export const inboundSchema = EventsControllerTriggerResponse$inboundSchema;
  /** @deprecated use `EventsControllerTriggerResponse$outboundSchema` instead. */
  export const outboundSchema = EventsControllerTriggerResponse$outboundSchema;
  /** @deprecated use `EventsControllerTriggerResponse$Outbound` instead. */
  export type Outbound = EventsControllerTriggerResponse$Outbound;
}

export function eventsControllerTriggerResponseToJSON(
  eventsControllerTriggerResponse: EventsControllerTriggerResponse
): string {
  return JSON.stringify(EventsControllerTriggerResponse$outboundSchema.parse(eventsControllerTriggerResponse));
}

export function eventsControllerTriggerResponseFromJSON(
  jsonString: string
): SafeParseResult<EventsControllerTriggerResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EventsControllerTriggerResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EventsControllerTriggerResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - eventsControllerTriggerRequestToJSON(eventsControllerTriggerRequest: EventsControllerTriggerRequest)
 - eventsControllerTriggerRequestFromJSON(jsonString: string)
 - eventsControllerTriggerResponseToJSON(eventsControllerTriggerResponse: EventsControllerTriggerResponse)
 - eventsControllerTriggerResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(EventsControllerTriggerRequest$Outbound;
}

export function eventsControllerTriggerRequestToJSON(
  ...)
 - Outbound(EventsControllerTriggerResponse$Outbound;
}

export function eventsControllerTriggerResponseToJSON(
...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function eventsControllerTriggerRequestToJSON
- export function eventsControllerTriggerRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function eventsControllerTriggerResponseToJSON
- export function eventsControllerTriggerResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/eventscontrollertriggerbulk.ts
Tamaño: 5550 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type EventsControllerTriggerBulkRequest = {
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  bulkTriggerEventDto: components.BulkTriggerEventDto;
};

export type EventsControllerTriggerBulkResponse = {
  headers: { [k: string]: Array<string> };
  result: Array<components.TriggerEventResponseDto>;
};

/** @internal */
export const EventsControllerTriggerBulkRequest$inboundSchema: z.ZodType<
  EventsControllerTriggerBulkRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    'idempotency-key': z.string().optional(),
    BulkTriggerEventDto: components.BulkTriggerEventDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      BulkTriggerEventDto: 'bulkTriggerEventDto',
    });
  });

/** @internal */
export type EventsControllerTriggerBulkRequest$Outbound = {
  'idempotency-key'?: string | undefined;
  BulkTriggerEventDto: components.BulkTriggerEventDto$Outbound;
};

/** @internal */
export const EventsControllerTriggerBulkRequest$outboundSchema: z.ZodType<
  EventsControllerTriggerBulkRequest$Outbound,
  z.ZodTypeDef,
  EventsControllerTriggerBulkRequest
> = z
  .object({
    idempotencyKey: z.string().optional(),
    bulkTriggerEventDto: components.BulkTriggerEventDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      bulkTriggerEventDto: 'BulkTriggerEventDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EventsControllerTriggerBulkRequest$ {
  /** @deprecated use `EventsControllerTriggerBulkRequest$inboundSchema` instead. */
  export const inboundSchema = EventsControllerTriggerBulkRequest$inboundSchema;
  /** @deprecated use `EventsControllerTriggerBulkRequest$outboundSchema` instead. */
  export const outboundSchema = EventsControllerTriggerBulkRequest$outboundSchema;
  /** @deprecated use `EventsControllerTriggerBulkRequest$Outbound` instead. */
  export type Outbound = EventsControllerTriggerBulkRequest$Outbound;
}

export function eventsControllerTriggerBulkRequestToJSON(
  eventsControllerTriggerBulkRequest: EventsControllerTriggerBulkRequest
): string {
  return JSON.stringify(EventsControllerTriggerBulkRequest$outboundSchema.parse(eventsControllerTriggerBulkRequest));
}

export function eventsControllerTriggerBulkRequestFromJSON(
  jsonString: string
): SafeParseResult<EventsControllerTriggerBulkRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EventsControllerTriggerBulkRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EventsControllerTriggerBulkRequest' from JSON`
  );
}

/** @internal */
export const EventsControllerTriggerBulkResponse$inboundSchema: z.ZodType<
  EventsControllerTriggerBulkResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: z.array(components.TriggerEventResponseDto$inboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type EventsControllerTriggerBulkResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: Array<components.TriggerEventResponseDto$Outbound>;
};

/** @internal */
export const EventsControllerTriggerBulkResponse$outboundSchema: z.ZodType<
  EventsControllerTriggerBulkResponse$Outbound,
  z.ZodTypeDef,
  EventsControllerTriggerBulkResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: z.array(components.TriggerEventResponseDto$outboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EventsControllerTriggerBulkResponse$ {
  /** @deprecated use `EventsControllerTriggerBulkResponse$inboundSchema` instead. */
  export const inboundSchema = EventsControllerTriggerBulkResponse$inboundSchema;
  /** @deprecated use `EventsControllerTriggerBulkResponse$outboundSchema` instead. */
  export const outboundSchema = EventsControllerTriggerBulkResponse$outboundSchema;
  /** @deprecated use `EventsControllerTriggerBulkResponse$Outbound` instead. */
  export type Outbound = EventsControllerTriggerBulkResponse$Outbound;
}

export function eventsControllerTriggerBulkResponseToJSON(
  eventsControllerTriggerBulkResponse: EventsControllerTriggerBulkResponse
): string {
  return JSON.stringify(EventsControllerTriggerBulkResponse$outboundSchema.parse(eventsControllerTriggerBulkResponse));
}

export function eventsControllerTriggerBulkResponseFromJSON(
  jsonString: string
): SafeParseResult<EventsControllerTriggerBulkResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EventsControllerTriggerBulkResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EventsControllerTriggerBulkResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - eventsControllerTriggerBulkRequestToJSON(eventsControllerTriggerBulkRequest: EventsControllerTriggerBulkRequest)
 - eventsControllerTriggerBulkRequestFromJSON(jsonString: string)
 - eventsControllerTriggerBulkResponseToJSON(eventsControllerTriggerBulkResponse: EventsControllerTriggerBulkResponse)
 - eventsControllerTriggerBulkResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(EventsControllerTriggerBulkRequest$Outbound;
}

export function eventsControllerTriggerBulkRequestTo...)
 - Outbound(EventsControllerTriggerBulkResponse$Outbound;
}

export function eventsControllerTriggerBulkResponse...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function eventsControllerTriggerBulkRequestToJSON
- export function eventsControllerTriggerBulkRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function eventsControllerTriggerBulkResponseToJSON
- export function eventsControllerTriggerBulkResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/inboundwebhookscontrollerhandlewebhook.ts
Tamaño: 3489 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type InboundWebhooksControllerHandleWebhookRequest = {
  /**
   * The environment identifier
   */
  environmentId: string;
  /**
   * The integration identifier for the delivery provider
   */
  integrationId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  /**
   * Webhook event payload from the delivery provider
   */
  requestBody?: any | undefined;
};

/** @internal */
export const InboundWebhooksControllerHandleWebhookRequest$inboundSchema: z.ZodType<
  InboundWebhooksControllerHandleWebhookRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    environmentId: z.string(),
    integrationId: z.string(),
    'idempotency-key': z.string().optional(),
    RequestBody: z.any().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      RequestBody: 'requestBody',
    });
  });

/** @internal */
export type InboundWebhooksControllerHandleWebhookRequest$Outbound = {
  environmentId: string;
  integrationId: string;
  'idempotency-key'?: string | undefined;
  RequestBody?: any | undefined;
};

/** @internal */
export const InboundWebhooksControllerHandleWebhookRequest$outboundSchema: z.ZodType<
  InboundWebhooksControllerHandleWebhookRequest$Outbound,
  z.ZodTypeDef,
  InboundWebhooksControllerHandleWebhookRequest
> = z
  .object({
    environmentId: z.string(),
    integrationId: z.string(),
    idempotencyKey: z.string().optional(),
    requestBody: z.any().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      requestBody: 'RequestBody',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InboundWebhooksControllerHandleWebhookRequest$ {
  /** @deprecated use `InboundWebhooksControllerHandleWebhookRequest$inboundSchema` instead. */
  export const inboundSchema = InboundWebhooksControllerHandleWebhookRequest$inboundSchema;
  /** @deprecated use `InboundWebhooksControllerHandleWebhookRequest$outboundSchema` instead. */
  export const outboundSchema = InboundWebhooksControllerHandleWebhookRequest$outboundSchema;
  /** @deprecated use `InboundWebhooksControllerHandleWebhookRequest$Outbound` instead. */
  export type Outbound = InboundWebhooksControllerHandleWebhookRequest$Outbound;
}

export function inboundWebhooksControllerHandleWebhookRequestToJSON(
  inboundWebhooksControllerHandleWebhookRequest: InboundWebhooksControllerHandleWebhookRequest
): string {
  return JSON.stringify(
    InboundWebhooksControllerHandleWebhookRequest$outboundSchema.parse(inboundWebhooksControllerHandleWebhookRequest)
  );
}

export function inboundWebhooksControllerHandleWebhookRequestFromJSON(
  jsonString: string
): SafeParseResult<InboundWebhooksControllerHandleWebhookRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InboundWebhooksControllerHandleWebhookRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InboundWebhooksControllerHandleWebhookRequest' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - inboundWebhooksControllerHandleWebhookRequestToJSON(inboundWebhooksControllerHandleWebhookRequest: InboundWebhooksControllerHandleWebhookRequest)
 - inboundWebhooksControllerHandleWebhookRequestFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(InboundWebhooksControllerHandleWebhookRequest$Outbound;
}

export function inboundWebhooksController...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function inboundWebhooksControllerHandleWebhookRequestToJSON
- export function inboundWebhooksControllerHandleWebhookRequestFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/index.ts
Tamaño: 5196 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

export * from "./activitycontrollergetcharts.js";
export * from "./activitycontrollergetlogs.js";
export * from "./activitycontrollergetrequesttraces.js";
export * from "./activitycontrollergetworkflowrun.js";
export * from "./activitycontrollergetworkflowruns.js";
export * from "./contextscontrollercreatecontext.js";
export * from "./contextscontrollerdeletecontext.js";
export * from "./contextscontrollergetcontext.js";
export * from "./contextscontrollerlistcontexts.js";
export * from "./contextscontrollerupdatecontext.js";
export * from "./environmentscontrollergetenvironmenttags.js";
export * from "./environmentscontrollerv1createenvironment.js";
export * from "./environmentscontrollerv1deleteenvironment.js";
export * from "./environmentscontrollerv1listmyenvironments.js";
export * from "./environmentscontrollerv1updatemyenvironment.js";
export * from "./eventscontrollerbroadcasteventtoall.js";
export * from "./eventscontrollercancel.js";
export * from "./eventscontrollertrigger.js";
export * from "./eventscontrollertriggerbulk.js";
export * from "./inboundwebhookscontrollerhandlewebhook.js";
export * from "./integrationscontrollerautoconfigureintegration.js";
export * from "./integrationscontrollercreateintegration.js";
export * from "./integrationscontrollergetactiveintegrations.js";
export * from "./integrationscontrollerlistintegrations.js";
export * from "./integrationscontrollerremoveintegration.js";
export * from "./integrationscontrollersetintegrationasprimary.js";
export * from "./integrationscontrollerupdateintegrationbyid.js";
export * from "./layoutscontrollercreate.js";
export * from "./layoutscontrollerdelete.js";
export * from "./layoutscontrollerduplicate.js";
export * from "./layoutscontrollergeneratepreview.js";
export * from "./layoutscontrollerget.js";
export * from "./layoutscontrollergetusage.js";
export * from "./layoutscontrollerlist.js";
export * from "./layoutscontrollerupdate.js";
export * from "./messagescontrollerdeletemessage.js";
export * from "./messagescontrollerdeletemessagesbytransactionid.js";
export * from "./messagescontrollergetmessages.js";
export * from "./notificationscontrollergetnotification.js";
export * from "./notificationscontrollerlistnotifications.js";
export * from "./subscriberscontrollerbulkupdatesubscriberpreferences.js";
export * from "./subscriberscontrollercreatesubscriber.js";
export * from "./subscriberscontrollergetsubscriber.js";
export * from "./subscriberscontrollergetsubscriberpreferences.js";
export * from "./subscriberscontrollerlistsubscribertopics.js";
export * from "./subscriberscontrollerpatchsubscriber.js";
export * from "./subscriberscontrollerremovesubscriber.js";
export * from "./subscriberscontrollersearchsubscribers.js";
export * from "./subscriberscontrollerupdatesubscriberpreferences.js";
export * from "./subscribersv1controllerbulkcreatesubscribers.js";
export * from "./subscribersv1controllerdeletesubscribercredentials.js";
export * from "./subscribersv1controllergetnotificationsfeed.js";
export * from "./subscribersv1controllergetunseencount.js";
export * from "./subscribersv1controllermarkactionasseen.js";
export * from "./subscribersv1controllermarkallunreadasread.js";
export * from "./subscribersv1controllermarkmessagesas.js";
export * from "./subscribersv1controllermodifysubscriberchannel.js";
export * from "./subscribersv1controllerupdatesubscriberchannel.js";
export * from "./subscribersv1controllerupdatesubscriberonlineflag.js";
export * from "./topicscontrollercreatetopicsubscriptions.js";
export * from "./topicscontrollerdeletetopic.js";
export * from "./topicscontrollerdeletetopicsubscriptions.js";
export * from "./topicscontrollergettopic.js";
export * from "./topicscontrollerlisttopics.js";
export * from "./topicscontrollerlisttopicsubscriptions.js";
export * from "./topicscontrollerupdatetopic.js";
export * from "./topicscontrollerupserttopic.js";
export * from "./topicsv1controllergettopicsubscriber.js";
export * from "./translationcontrollercreatetranslationendpoint.js";
export * from "./translationcontrollerdeletetranslationendpoint.js";
export * from "./translationcontrollerdeletetranslationgroupendpoint.js";
export * from "./translationcontrollergetmasterjsonendpoint.js";
export * from "./translationcontrollergetsingletranslation.js";
export * from "./translationcontrollergettranslationgroupendpoint.js";
export * from "./translationcontrollerimportmasterjsonendpoint.js";
export * from "./translationcontrolleruploadmasterjsonendpoint.js";
export * from "./translationcontrolleruploadtranslationfiles.js";
export * from "./workflowcontrollercreate.js";
export * from "./workflowcontrollerduplicateworkflow.js";
export * from "./workflowcontrollergeneratepreview.js";
export * from "./workflowcontrollergetworkflow.js";
export * from "./workflowcontrollergetworkflowstepdata.js";
export * from "./workflowcontrollerpatchworkflow.js";
export * from "./workflowcontrollerremoveworkflow.js";
export * from "./workflowcontrollersearchworkflows.js";
export * from "./workflowcontrollersync.js";
export * from "./workflowcontrollerupdate.js";


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/integrationscontrollerautoconfigureintegration.ts
Tamaño: 6230 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type IntegrationsControllerAutoConfigureIntegrationRequest = {
  integrationId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type IntegrationsControllerAutoConfigureIntegrationResponse = {
  headers: { [k: string]: Array<string> };
  result: components.AutoConfigureIntegrationResponseDto;
};

/** @internal */
export const IntegrationsControllerAutoConfigureIntegrationRequest$inboundSchema: z.ZodType<
  IntegrationsControllerAutoConfigureIntegrationRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    integrationId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type IntegrationsControllerAutoConfigureIntegrationRequest$Outbound = {
  integrationId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const IntegrationsControllerAutoConfigureIntegrationRequest$outboundSchema: z.ZodType<
  IntegrationsControllerAutoConfigureIntegrationRequest$Outbound,
  z.ZodTypeDef,
  IntegrationsControllerAutoConfigureIntegrationRequest
> = z
  .object({
    integrationId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationsControllerAutoConfigureIntegrationRequest$ {
  /** @deprecated use `IntegrationsControllerAutoConfigureIntegrationRequest$inboundSchema` instead. */
  export const inboundSchema = IntegrationsControllerAutoConfigureIntegrationRequest$inboundSchema;
  /** @deprecated use `IntegrationsControllerAutoConfigureIntegrationRequest$outboundSchema` instead. */
  export const outboundSchema = IntegrationsControllerAutoConfigureIntegrationRequest$outboundSchema;
  /** @deprecated use `IntegrationsControllerAutoConfigureIntegrationRequest$Outbound` instead. */
  export type Outbound = IntegrationsControllerAutoConfigureIntegrationRequest$Outbound;
}

export function integrationsControllerAutoConfigureIntegrationRequestToJSON(
  integrationsControllerAutoConfigureIntegrationRequest: IntegrationsControllerAutoConfigureIntegrationRequest
): string {
  return JSON.stringify(
    IntegrationsControllerAutoConfigureIntegrationRequest$outboundSchema.parse(
      integrationsControllerAutoConfigureIntegrationRequest
    )
  );
}

export function integrationsControllerAutoConfigureIntegrationRequestFromJSON(
  jsonString: string
): SafeParseResult<IntegrationsControllerAutoConfigureIntegrationRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationsControllerAutoConfigureIntegrationRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationsControllerAutoConfigureIntegrationRequest' from JSON`
  );
}

/** @internal */
export const IntegrationsControllerAutoConfigureIntegrationResponse$inboundSchema: z.ZodType<
  IntegrationsControllerAutoConfigureIntegrationResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.AutoConfigureIntegrationResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type IntegrationsControllerAutoConfigureIntegrationResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.AutoConfigureIntegrationResponseDto$Outbound;
};

/** @internal */
export const IntegrationsControllerAutoConfigureIntegrationResponse$outboundSchema: z.ZodType<
  IntegrationsControllerAutoConfigureIntegrationResponse$Outbound,
  z.ZodTypeDef,
  IntegrationsControllerAutoConfigureIntegrationResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.AutoConfigureIntegrationResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationsControllerAutoConfigureIntegrationResponse$ {
  /** @deprecated use `IntegrationsControllerAutoConfigureIntegrationResponse$inboundSchema` instead. */
  export const inboundSchema = IntegrationsControllerAutoConfigureIntegrationResponse$inboundSchema;
  /** @deprecated use `IntegrationsControllerAutoConfigureIntegrationResponse$outboundSchema` instead. */
  export const outboundSchema = IntegrationsControllerAutoConfigureIntegrationResponse$outboundSchema;
  /** @deprecated use `IntegrationsControllerAutoConfigureIntegrationResponse$Outbound` instead. */
  export type Outbound = IntegrationsControllerAutoConfigureIntegrationResponse$Outbound;
}

export function integrationsControllerAutoConfigureIntegrationResponseToJSON(
  integrationsControllerAutoConfigureIntegrationResponse: IntegrationsControllerAutoConfigureIntegrationResponse
): string {
  return JSON.stringify(
    IntegrationsControllerAutoConfigureIntegrationResponse$outboundSchema.parse(
      integrationsControllerAutoConfigureIntegrationResponse
    )
  );
}

export function integrationsControllerAutoConfigureIntegrationResponseFromJSON(
  jsonString: string
): SafeParseResult<IntegrationsControllerAutoConfigureIntegrationResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationsControllerAutoConfigureIntegrationResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationsControllerAutoConfigureIntegrationResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - integrationsControllerAutoConfigureIntegrationRequestToJSON(integrationsControllerAutoConfigureIntegrationRequest: IntegrationsControllerAutoConfigureIntegrationRequest)
 - integrationsControllerAutoConfigureIntegrationRequestFromJSON(jsonString: string)
 - integrationsControllerAutoConfigureIntegrationResponseToJSON(integrationsControllerAutoConfigureIntegrationResponse: IntegrationsControllerAutoConfigureIntegrationResponse)
 - integrationsControllerAutoConfigureIntegrationResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(IntegrationsControllerAutoConfigureIntegrationRequest$Outbound;
}

export function integrationsContr...)
 - Outbound(IntegrationsControllerAutoConfigureIntegrationResponse$Outbound;
}

export function integrationsCont...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function integrationsControllerAutoConfigureIntegrationRequestToJSON
- export function integrationsControllerAutoConfigureIntegrationRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function integrationsControllerAutoConfigureIntegrationResponseToJSON
- export function integrationsControllerAutoConfigureIntegrationResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/integrationscontrollercreateintegration.ts
Tamaño: 6190 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type IntegrationsControllerCreateIntegrationRequest = {
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  createIntegrationRequestDto: components.CreateIntegrationRequestDto;
};

export type IntegrationsControllerCreateIntegrationResponse = {
  headers: { [k: string]: Array<string> };
  result: components.IntegrationResponseDto;
};

/** @internal */
export const IntegrationsControllerCreateIntegrationRequest$inboundSchema: z.ZodType<
  IntegrationsControllerCreateIntegrationRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    'idempotency-key': z.string().optional(),
    CreateIntegrationRequestDto: components.CreateIntegrationRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      CreateIntegrationRequestDto: 'createIntegrationRequestDto',
    });
  });

/** @internal */
export type IntegrationsControllerCreateIntegrationRequest$Outbound = {
  'idempotency-key'?: string | undefined;
  CreateIntegrationRequestDto: components.CreateIntegrationRequestDto$Outbound;
};

/** @internal */
export const IntegrationsControllerCreateIntegrationRequest$outboundSchema: z.ZodType<
  IntegrationsControllerCreateIntegrationRequest$Outbound,
  z.ZodTypeDef,
  IntegrationsControllerCreateIntegrationRequest
> = z
  .object({
    idempotencyKey: z.string().optional(),
    createIntegrationRequestDto: components.CreateIntegrationRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      createIntegrationRequestDto: 'CreateIntegrationRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationsControllerCreateIntegrationRequest$ {
  /** @deprecated use `IntegrationsControllerCreateIntegrationRequest$inboundSchema` instead. */
  export const inboundSchema = IntegrationsControllerCreateIntegrationRequest$inboundSchema;
  /** @deprecated use `IntegrationsControllerCreateIntegrationRequest$outboundSchema` instead. */
  export const outboundSchema = IntegrationsControllerCreateIntegrationRequest$outboundSchema;
  /** @deprecated use `IntegrationsControllerCreateIntegrationRequest$Outbound` instead. */
  export type Outbound = IntegrationsControllerCreateIntegrationRequest$Outbound;
}

export function integrationsControllerCreateIntegrationRequestToJSON(
  integrationsControllerCreateIntegrationRequest: IntegrationsControllerCreateIntegrationRequest
): string {
  return JSON.stringify(
    IntegrationsControllerCreateIntegrationRequest$outboundSchema.parse(integrationsControllerCreateIntegrationRequest)
  );
}

export function integrationsControllerCreateIntegrationRequestFromJSON(
  jsonString: string
): SafeParseResult<IntegrationsControllerCreateIntegrationRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationsControllerCreateIntegrationRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationsControllerCreateIntegrationRequest' from JSON`
  );
}

/** @internal */
export const IntegrationsControllerCreateIntegrationResponse$inboundSchema: z.ZodType<
  IntegrationsControllerCreateIntegrationResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.IntegrationResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type IntegrationsControllerCreateIntegrationResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.IntegrationResponseDto$Outbound;
};

/** @internal */
export const IntegrationsControllerCreateIntegrationResponse$outboundSchema: z.ZodType<
  IntegrationsControllerCreateIntegrationResponse$Outbound,
  z.ZodTypeDef,
  IntegrationsControllerCreateIntegrationResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.IntegrationResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationsControllerCreateIntegrationResponse$ {
  /** @deprecated use `IntegrationsControllerCreateIntegrationResponse$inboundSchema` instead. */
  export const inboundSchema = IntegrationsControllerCreateIntegrationResponse$inboundSchema;
  /** @deprecated use `IntegrationsControllerCreateIntegrationResponse$outboundSchema` instead. */
  export const outboundSchema = IntegrationsControllerCreateIntegrationResponse$outboundSchema;
  /** @deprecated use `IntegrationsControllerCreateIntegrationResponse$Outbound` instead. */
  export type Outbound = IntegrationsControllerCreateIntegrationResponse$Outbound;
}

export function integrationsControllerCreateIntegrationResponseToJSON(
  integrationsControllerCreateIntegrationResponse: IntegrationsControllerCreateIntegrationResponse
): string {
  return JSON.stringify(
    IntegrationsControllerCreateIntegrationResponse$outboundSchema.parse(
      integrationsControllerCreateIntegrationResponse
    )
  );
}

export function integrationsControllerCreateIntegrationResponseFromJSON(
  jsonString: string
): SafeParseResult<IntegrationsControllerCreateIntegrationResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationsControllerCreateIntegrationResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationsControllerCreateIntegrationResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - integrationsControllerCreateIntegrationRequestToJSON(integrationsControllerCreateIntegrationRequest: IntegrationsControllerCreateIntegrationRequest)
 - integrationsControllerCreateIntegrationRequestFromJSON(jsonString: string)
 - integrationsControllerCreateIntegrationResponseToJSON(integrationsControllerCreateIntegrationResponse: IntegrationsControllerCreateIntegrationResponse)
 - integrationsControllerCreateIntegrationResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(IntegrationsControllerCreateIntegrationRequest$Outbound;
}

export function integrationsControllerCr...)
 - Outbound(IntegrationsControllerCreateIntegrationResponse$Outbound;
}

export function integrationsControllerC...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function integrationsControllerCreateIntegrationRequestToJSON
- export function integrationsControllerCreateIntegrationRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function integrationsControllerCreateIntegrationResponseToJSON
- export function integrationsControllerCreateIntegrationResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/integrationscontrollergetactiveintegrations.ts
Tamaño: 5960 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type IntegrationsControllerGetActiveIntegrationsRequest = {
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type IntegrationsControllerGetActiveIntegrationsResponse = {
  headers: { [k: string]: Array<string> };
  result: Array<components.IntegrationResponseDto>;
};

/** @internal */
export const IntegrationsControllerGetActiveIntegrationsRequest$inboundSchema: z.ZodType<
  IntegrationsControllerGetActiveIntegrationsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type IntegrationsControllerGetActiveIntegrationsRequest$Outbound = {
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const IntegrationsControllerGetActiveIntegrationsRequest$outboundSchema: z.ZodType<
  IntegrationsControllerGetActiveIntegrationsRequest$Outbound,
  z.ZodTypeDef,
  IntegrationsControllerGetActiveIntegrationsRequest
> = z
  .object({
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationsControllerGetActiveIntegrationsRequest$ {
  /** @deprecated use `IntegrationsControllerGetActiveIntegrationsRequest$inboundSchema` instead. */
  export const inboundSchema = IntegrationsControllerGetActiveIntegrationsRequest$inboundSchema;
  /** @deprecated use `IntegrationsControllerGetActiveIntegrationsRequest$outboundSchema` instead. */
  export const outboundSchema = IntegrationsControllerGetActiveIntegrationsRequest$outboundSchema;
  /** @deprecated use `IntegrationsControllerGetActiveIntegrationsRequest$Outbound` instead. */
  export type Outbound = IntegrationsControllerGetActiveIntegrationsRequest$Outbound;
}

export function integrationsControllerGetActiveIntegrationsRequestToJSON(
  integrationsControllerGetActiveIntegrationsRequest: IntegrationsControllerGetActiveIntegrationsRequest
): string {
  return JSON.stringify(
    IntegrationsControllerGetActiveIntegrationsRequest$outboundSchema.parse(
      integrationsControllerGetActiveIntegrationsRequest
    )
  );
}

export function integrationsControllerGetActiveIntegrationsRequestFromJSON(
  jsonString: string
): SafeParseResult<IntegrationsControllerGetActiveIntegrationsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationsControllerGetActiveIntegrationsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationsControllerGetActiveIntegrationsRequest' from JSON`
  );
}

/** @internal */
export const IntegrationsControllerGetActiveIntegrationsResponse$inboundSchema: z.ZodType<
  IntegrationsControllerGetActiveIntegrationsResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: z.array(components.IntegrationResponseDto$inboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type IntegrationsControllerGetActiveIntegrationsResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: Array<components.IntegrationResponseDto$Outbound>;
};

/** @internal */
export const IntegrationsControllerGetActiveIntegrationsResponse$outboundSchema: z.ZodType<
  IntegrationsControllerGetActiveIntegrationsResponse$Outbound,
  z.ZodTypeDef,
  IntegrationsControllerGetActiveIntegrationsResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: z.array(components.IntegrationResponseDto$outboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationsControllerGetActiveIntegrationsResponse$ {
  /** @deprecated use `IntegrationsControllerGetActiveIntegrationsResponse$inboundSchema` instead. */
  export const inboundSchema = IntegrationsControllerGetActiveIntegrationsResponse$inboundSchema;
  /** @deprecated use `IntegrationsControllerGetActiveIntegrationsResponse$outboundSchema` instead. */
  export const outboundSchema = IntegrationsControllerGetActiveIntegrationsResponse$outboundSchema;
  /** @deprecated use `IntegrationsControllerGetActiveIntegrationsResponse$Outbound` instead. */
  export type Outbound = IntegrationsControllerGetActiveIntegrationsResponse$Outbound;
}

export function integrationsControllerGetActiveIntegrationsResponseToJSON(
  integrationsControllerGetActiveIntegrationsResponse: IntegrationsControllerGetActiveIntegrationsResponse
): string {
  return JSON.stringify(
    IntegrationsControllerGetActiveIntegrationsResponse$outboundSchema.parse(
      integrationsControllerGetActiveIntegrationsResponse
    )
  );
}

export function integrationsControllerGetActiveIntegrationsResponseFromJSON(
  jsonString: string
): SafeParseResult<IntegrationsControllerGetActiveIntegrationsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationsControllerGetActiveIntegrationsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationsControllerGetActiveIntegrationsResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - integrationsControllerGetActiveIntegrationsRequestToJSON(integrationsControllerGetActiveIntegrationsRequest: IntegrationsControllerGetActiveIntegrationsRequest)
 - integrationsControllerGetActiveIntegrationsRequestFromJSON(jsonString: string)
 - integrationsControllerGetActiveIntegrationsResponseToJSON(integrationsControllerGetActiveIntegrationsResponse: IntegrationsControllerGetActiveIntegrationsResponse)
 - integrationsControllerGetActiveIntegrationsResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(IntegrationsControllerGetActiveIntegrationsRequest$Outbound;
}

export function integrationsControll...)
 - Outbound(IntegrationsControllerGetActiveIntegrationsResponse$Outbound;
}

export function integrationsControl...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function integrationsControllerGetActiveIntegrationsRequestToJSON
- export function integrationsControllerGetActiveIntegrationsRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function integrationsControllerGetActiveIntegrationsResponseToJSON
- export function integrationsControllerGetActiveIntegrationsResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/integrationscontrollerlistintegrations.ts
Tamaño: 5706 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type IntegrationsControllerListIntegrationsRequest = {
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type IntegrationsControllerListIntegrationsResponse = {
  headers: { [k: string]: Array<string> };
  result: Array<components.IntegrationResponseDto>;
};

/** @internal */
export const IntegrationsControllerListIntegrationsRequest$inboundSchema: z.ZodType<
  IntegrationsControllerListIntegrationsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type IntegrationsControllerListIntegrationsRequest$Outbound = {
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const IntegrationsControllerListIntegrationsRequest$outboundSchema: z.ZodType<
  IntegrationsControllerListIntegrationsRequest$Outbound,
  z.ZodTypeDef,
  IntegrationsControllerListIntegrationsRequest
> = z
  .object({
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationsControllerListIntegrationsRequest$ {
  /** @deprecated use `IntegrationsControllerListIntegrationsRequest$inboundSchema` instead. */
  export const inboundSchema = IntegrationsControllerListIntegrationsRequest$inboundSchema;
  /** @deprecated use `IntegrationsControllerListIntegrationsRequest$outboundSchema` instead. */
  export const outboundSchema = IntegrationsControllerListIntegrationsRequest$outboundSchema;
  /** @deprecated use `IntegrationsControllerListIntegrationsRequest$Outbound` instead. */
  export type Outbound = IntegrationsControllerListIntegrationsRequest$Outbound;
}

export function integrationsControllerListIntegrationsRequestToJSON(
  integrationsControllerListIntegrationsRequest: IntegrationsControllerListIntegrationsRequest
): string {
  return JSON.stringify(
    IntegrationsControllerListIntegrationsRequest$outboundSchema.parse(integrationsControllerListIntegrationsRequest)
  );
}

export function integrationsControllerListIntegrationsRequestFromJSON(
  jsonString: string
): SafeParseResult<IntegrationsControllerListIntegrationsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationsControllerListIntegrationsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationsControllerListIntegrationsRequest' from JSON`
  );
}

/** @internal */
export const IntegrationsControllerListIntegrationsResponse$inboundSchema: z.ZodType<
  IntegrationsControllerListIntegrationsResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: z.array(components.IntegrationResponseDto$inboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type IntegrationsControllerListIntegrationsResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: Array<components.IntegrationResponseDto$Outbound>;
};

/** @internal */
export const IntegrationsControllerListIntegrationsResponse$outboundSchema: z.ZodType<
  IntegrationsControllerListIntegrationsResponse$Outbound,
  z.ZodTypeDef,
  IntegrationsControllerListIntegrationsResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: z.array(components.IntegrationResponseDto$outboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationsControllerListIntegrationsResponse$ {
  /** @deprecated use `IntegrationsControllerListIntegrationsResponse$inboundSchema` instead. */
  export const inboundSchema = IntegrationsControllerListIntegrationsResponse$inboundSchema;
  /** @deprecated use `IntegrationsControllerListIntegrationsResponse$outboundSchema` instead. */
  export const outboundSchema = IntegrationsControllerListIntegrationsResponse$outboundSchema;
  /** @deprecated use `IntegrationsControllerListIntegrationsResponse$Outbound` instead. */
  export type Outbound = IntegrationsControllerListIntegrationsResponse$Outbound;
}

export function integrationsControllerListIntegrationsResponseToJSON(
  integrationsControllerListIntegrationsResponse: IntegrationsControllerListIntegrationsResponse
): string {
  return JSON.stringify(
    IntegrationsControllerListIntegrationsResponse$outboundSchema.parse(integrationsControllerListIntegrationsResponse)
  );
}

export function integrationsControllerListIntegrationsResponseFromJSON(
  jsonString: string
): SafeParseResult<IntegrationsControllerListIntegrationsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationsControllerListIntegrationsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationsControllerListIntegrationsResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - integrationsControllerListIntegrationsRequestToJSON(integrationsControllerListIntegrationsRequest: IntegrationsControllerListIntegrationsRequest)
 - integrationsControllerListIntegrationsRequestFromJSON(jsonString: string)
 - integrationsControllerListIntegrationsResponseToJSON(integrationsControllerListIntegrationsResponse: IntegrationsControllerListIntegrationsResponse)
 - integrationsControllerListIntegrationsResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(IntegrationsControllerListIntegrationsRequest$Outbound;
}

export function integrationsControllerLis...)
 - Outbound(IntegrationsControllerListIntegrationsResponse$Outbound;
}

export function integrationsControllerLi...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function integrationsControllerListIntegrationsRequestToJSON
- export function integrationsControllerListIntegrationsRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function integrationsControllerListIntegrationsResponseToJSON
- export function integrationsControllerListIntegrationsResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/integrationscontrollerremoveintegration.ts
Tamaño: 5876 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type IntegrationsControllerRemoveIntegrationRequest = {
  integrationId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type IntegrationsControllerRemoveIntegrationResponse = {
  headers: { [k: string]: Array<string> };
  result: Array<components.IntegrationResponseDto>;
};

/** @internal */
export const IntegrationsControllerRemoveIntegrationRequest$inboundSchema: z.ZodType<
  IntegrationsControllerRemoveIntegrationRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    integrationId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type IntegrationsControllerRemoveIntegrationRequest$Outbound = {
  integrationId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const IntegrationsControllerRemoveIntegrationRequest$outboundSchema: z.ZodType<
  IntegrationsControllerRemoveIntegrationRequest$Outbound,
  z.ZodTypeDef,
  IntegrationsControllerRemoveIntegrationRequest
> = z
  .object({
    integrationId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationsControllerRemoveIntegrationRequest$ {
  /** @deprecated use `IntegrationsControllerRemoveIntegrationRequest$inboundSchema` instead. */
  export const inboundSchema = IntegrationsControllerRemoveIntegrationRequest$inboundSchema;
  /** @deprecated use `IntegrationsControllerRemoveIntegrationRequest$outboundSchema` instead. */
  export const outboundSchema = IntegrationsControllerRemoveIntegrationRequest$outboundSchema;
  /** @deprecated use `IntegrationsControllerRemoveIntegrationRequest$Outbound` instead. */
  export type Outbound = IntegrationsControllerRemoveIntegrationRequest$Outbound;
}

export function integrationsControllerRemoveIntegrationRequestToJSON(
  integrationsControllerRemoveIntegrationRequest: IntegrationsControllerRemoveIntegrationRequest
): string {
  return JSON.stringify(
    IntegrationsControllerRemoveIntegrationRequest$outboundSchema.parse(integrationsControllerRemoveIntegrationRequest)
  );
}

export function integrationsControllerRemoveIntegrationRequestFromJSON(
  jsonString: string
): SafeParseResult<IntegrationsControllerRemoveIntegrationRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationsControllerRemoveIntegrationRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationsControllerRemoveIntegrationRequest' from JSON`
  );
}

/** @internal */
export const IntegrationsControllerRemoveIntegrationResponse$inboundSchema: z.ZodType<
  IntegrationsControllerRemoveIntegrationResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: z.array(components.IntegrationResponseDto$inboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type IntegrationsControllerRemoveIntegrationResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: Array<components.IntegrationResponseDto$Outbound>;
};

/** @internal */
export const IntegrationsControllerRemoveIntegrationResponse$outboundSchema: z.ZodType<
  IntegrationsControllerRemoveIntegrationResponse$Outbound,
  z.ZodTypeDef,
  IntegrationsControllerRemoveIntegrationResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: z.array(components.IntegrationResponseDto$outboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationsControllerRemoveIntegrationResponse$ {
  /** @deprecated use `IntegrationsControllerRemoveIntegrationResponse$inboundSchema` instead. */
  export const inboundSchema = IntegrationsControllerRemoveIntegrationResponse$inboundSchema;
  /** @deprecated use `IntegrationsControllerRemoveIntegrationResponse$outboundSchema` instead. */
  export const outboundSchema = IntegrationsControllerRemoveIntegrationResponse$outboundSchema;
  /** @deprecated use `IntegrationsControllerRemoveIntegrationResponse$Outbound` instead. */
  export type Outbound = IntegrationsControllerRemoveIntegrationResponse$Outbound;
}

export function integrationsControllerRemoveIntegrationResponseToJSON(
  integrationsControllerRemoveIntegrationResponse: IntegrationsControllerRemoveIntegrationResponse
): string {
  return JSON.stringify(
    IntegrationsControllerRemoveIntegrationResponse$outboundSchema.parse(
      integrationsControllerRemoveIntegrationResponse
    )
  );
}

export function integrationsControllerRemoveIntegrationResponseFromJSON(
  jsonString: string
): SafeParseResult<IntegrationsControllerRemoveIntegrationResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationsControllerRemoveIntegrationResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationsControllerRemoveIntegrationResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - integrationsControllerRemoveIntegrationRequestToJSON(integrationsControllerRemoveIntegrationRequest: IntegrationsControllerRemoveIntegrationRequest)
 - integrationsControllerRemoveIntegrationRequestFromJSON(jsonString: string)
 - integrationsControllerRemoveIntegrationResponseToJSON(integrationsControllerRemoveIntegrationResponse: IntegrationsControllerRemoveIntegrationResponse)
 - integrationsControllerRemoveIntegrationResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(IntegrationsControllerRemoveIntegrationRequest$Outbound;
}

export function integrationsControllerRe...)
 - Outbound(IntegrationsControllerRemoveIntegrationResponse$Outbound;
}

export function integrationsControllerR...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function integrationsControllerRemoveIntegrationRequestToJSON
- export function integrationsControllerRemoveIntegrationRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function integrationsControllerRemoveIntegrationResponseToJSON
- export function integrationsControllerRemoveIntegrationResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/integrationscontrollersetintegrationasprimary.ts
Tamaño: 6132 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type IntegrationsControllerSetIntegrationAsPrimaryRequest = {
  integrationId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type IntegrationsControllerSetIntegrationAsPrimaryResponse = {
  headers: { [k: string]: Array<string> };
  result: components.IntegrationResponseDto;
};

/** @internal */
export const IntegrationsControllerSetIntegrationAsPrimaryRequest$inboundSchema: z.ZodType<
  IntegrationsControllerSetIntegrationAsPrimaryRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    integrationId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type IntegrationsControllerSetIntegrationAsPrimaryRequest$Outbound = {
  integrationId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const IntegrationsControllerSetIntegrationAsPrimaryRequest$outboundSchema: z.ZodType<
  IntegrationsControllerSetIntegrationAsPrimaryRequest$Outbound,
  z.ZodTypeDef,
  IntegrationsControllerSetIntegrationAsPrimaryRequest
> = z
  .object({
    integrationId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationsControllerSetIntegrationAsPrimaryRequest$ {
  /** @deprecated use `IntegrationsControllerSetIntegrationAsPrimaryRequest$inboundSchema` instead. */
  export const inboundSchema = IntegrationsControllerSetIntegrationAsPrimaryRequest$inboundSchema;
  /** @deprecated use `IntegrationsControllerSetIntegrationAsPrimaryRequest$outboundSchema` instead. */
  export const outboundSchema = IntegrationsControllerSetIntegrationAsPrimaryRequest$outboundSchema;
  /** @deprecated use `IntegrationsControllerSetIntegrationAsPrimaryRequest$Outbound` instead. */
  export type Outbound = IntegrationsControllerSetIntegrationAsPrimaryRequest$Outbound;
}

export function integrationsControllerSetIntegrationAsPrimaryRequestToJSON(
  integrationsControllerSetIntegrationAsPrimaryRequest: IntegrationsControllerSetIntegrationAsPrimaryRequest
): string {
  return JSON.stringify(
    IntegrationsControllerSetIntegrationAsPrimaryRequest$outboundSchema.parse(
      integrationsControllerSetIntegrationAsPrimaryRequest
    )
  );
}

export function integrationsControllerSetIntegrationAsPrimaryRequestFromJSON(
  jsonString: string
): SafeParseResult<IntegrationsControllerSetIntegrationAsPrimaryRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationsControllerSetIntegrationAsPrimaryRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationsControllerSetIntegrationAsPrimaryRequest' from JSON`
  );
}

/** @internal */
export const IntegrationsControllerSetIntegrationAsPrimaryResponse$inboundSchema: z.ZodType<
  IntegrationsControllerSetIntegrationAsPrimaryResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.IntegrationResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type IntegrationsControllerSetIntegrationAsPrimaryResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.IntegrationResponseDto$Outbound;
};

/** @internal */
export const IntegrationsControllerSetIntegrationAsPrimaryResponse$outboundSchema: z.ZodType<
  IntegrationsControllerSetIntegrationAsPrimaryResponse$Outbound,
  z.ZodTypeDef,
  IntegrationsControllerSetIntegrationAsPrimaryResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.IntegrationResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationsControllerSetIntegrationAsPrimaryResponse$ {
  /** @deprecated use `IntegrationsControllerSetIntegrationAsPrimaryResponse$inboundSchema` instead. */
  export const inboundSchema = IntegrationsControllerSetIntegrationAsPrimaryResponse$inboundSchema;
  /** @deprecated use `IntegrationsControllerSetIntegrationAsPrimaryResponse$outboundSchema` instead. */
  export const outboundSchema = IntegrationsControllerSetIntegrationAsPrimaryResponse$outboundSchema;
  /** @deprecated use `IntegrationsControllerSetIntegrationAsPrimaryResponse$Outbound` instead. */
  export type Outbound = IntegrationsControllerSetIntegrationAsPrimaryResponse$Outbound;
}

export function integrationsControllerSetIntegrationAsPrimaryResponseToJSON(
  integrationsControllerSetIntegrationAsPrimaryResponse: IntegrationsControllerSetIntegrationAsPrimaryResponse
): string {
  return JSON.stringify(
    IntegrationsControllerSetIntegrationAsPrimaryResponse$outboundSchema.parse(
      integrationsControllerSetIntegrationAsPrimaryResponse
    )
  );
}

export function integrationsControllerSetIntegrationAsPrimaryResponseFromJSON(
  jsonString: string
): SafeParseResult<IntegrationsControllerSetIntegrationAsPrimaryResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationsControllerSetIntegrationAsPrimaryResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationsControllerSetIntegrationAsPrimaryResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - integrationsControllerSetIntegrationAsPrimaryRequestToJSON(integrationsControllerSetIntegrationAsPrimaryRequest: IntegrationsControllerSetIntegrationAsPrimaryRequest)
 - integrationsControllerSetIntegrationAsPrimaryRequestFromJSON(jsonString: string)
 - integrationsControllerSetIntegrationAsPrimaryResponseToJSON(integrationsControllerSetIntegrationAsPrimaryResponse: IntegrationsControllerSetIntegrationAsPrimaryResponse)
 - integrationsControllerSetIntegrationAsPrimaryResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(IntegrationsControllerSetIntegrationAsPrimaryRequest$Outbound;
}

export function integrationsContro...)
 - Outbound(IntegrationsControllerSetIntegrationAsPrimaryResponse$Outbound;
}

export function integrationsContr...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function integrationsControllerSetIntegrationAsPrimaryRequestToJSON
- export function integrationsControllerSetIntegrationAsPrimaryRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function integrationsControllerSetIntegrationAsPrimaryResponseToJSON
- export function integrationsControllerSetIntegrationAsPrimaryResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/integrationscontrollerupdateintegrationbyid.ts
Tamaño: 6498 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type IntegrationsControllerUpdateIntegrationByIdRequest = {
  integrationId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  updateIntegrationRequestDto: components.UpdateIntegrationRequestDto;
};

export type IntegrationsControllerUpdateIntegrationByIdResponse = {
  headers: { [k: string]: Array<string> };
  result: components.IntegrationResponseDto;
};

/** @internal */
export const IntegrationsControllerUpdateIntegrationByIdRequest$inboundSchema: z.ZodType<
  IntegrationsControllerUpdateIntegrationByIdRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    integrationId: z.string(),
    'idempotency-key': z.string().optional(),
    UpdateIntegrationRequestDto: components.UpdateIntegrationRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      UpdateIntegrationRequestDto: 'updateIntegrationRequestDto',
    });
  });

/** @internal */
export type IntegrationsControllerUpdateIntegrationByIdRequest$Outbound = {
  integrationId: string;
  'idempotency-key'?: string | undefined;
  UpdateIntegrationRequestDto: components.UpdateIntegrationRequestDto$Outbound;
};

/** @internal */
export const IntegrationsControllerUpdateIntegrationByIdRequest$outboundSchema: z.ZodType<
  IntegrationsControllerUpdateIntegrationByIdRequest$Outbound,
  z.ZodTypeDef,
  IntegrationsControllerUpdateIntegrationByIdRequest
> = z
  .object({
    integrationId: z.string(),
    idempotencyKey: z.string().optional(),
    updateIntegrationRequestDto: components.UpdateIntegrationRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      updateIntegrationRequestDto: 'UpdateIntegrationRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationsControllerUpdateIntegrationByIdRequest$ {
  /** @deprecated use `IntegrationsControllerUpdateIntegrationByIdRequest$inboundSchema` instead. */
  export const inboundSchema = IntegrationsControllerUpdateIntegrationByIdRequest$inboundSchema;
  /** @deprecated use `IntegrationsControllerUpdateIntegrationByIdRequest$outboundSchema` instead. */
  export const outboundSchema = IntegrationsControllerUpdateIntegrationByIdRequest$outboundSchema;
  /** @deprecated use `IntegrationsControllerUpdateIntegrationByIdRequest$Outbound` instead. */
  export type Outbound = IntegrationsControllerUpdateIntegrationByIdRequest$Outbound;
}

export function integrationsControllerUpdateIntegrationByIdRequestToJSON(
  integrationsControllerUpdateIntegrationByIdRequest: IntegrationsControllerUpdateIntegrationByIdRequest
): string {
  return JSON.stringify(
    IntegrationsControllerUpdateIntegrationByIdRequest$outboundSchema.parse(
      integrationsControllerUpdateIntegrationByIdRequest
    )
  );
}

export function integrationsControllerUpdateIntegrationByIdRequestFromJSON(
  jsonString: string
): SafeParseResult<IntegrationsControllerUpdateIntegrationByIdRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationsControllerUpdateIntegrationByIdRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationsControllerUpdateIntegrationByIdRequest' from JSON`
  );
}

/** @internal */
export const IntegrationsControllerUpdateIntegrationByIdResponse$inboundSchema: z.ZodType<
  IntegrationsControllerUpdateIntegrationByIdResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.IntegrationResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type IntegrationsControllerUpdateIntegrationByIdResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.IntegrationResponseDto$Outbound;
};

/** @internal */
export const IntegrationsControllerUpdateIntegrationByIdResponse$outboundSchema: z.ZodType<
  IntegrationsControllerUpdateIntegrationByIdResponse$Outbound,
  z.ZodTypeDef,
  IntegrationsControllerUpdateIntegrationByIdResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.IntegrationResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IntegrationsControllerUpdateIntegrationByIdResponse$ {
  /** @deprecated use `IntegrationsControllerUpdateIntegrationByIdResponse$inboundSchema` instead. */
  export const inboundSchema = IntegrationsControllerUpdateIntegrationByIdResponse$inboundSchema;
  /** @deprecated use `IntegrationsControllerUpdateIntegrationByIdResponse$outboundSchema` instead. */
  export const outboundSchema = IntegrationsControllerUpdateIntegrationByIdResponse$outboundSchema;
  /** @deprecated use `IntegrationsControllerUpdateIntegrationByIdResponse$Outbound` instead. */
  export type Outbound = IntegrationsControllerUpdateIntegrationByIdResponse$Outbound;
}

export function integrationsControllerUpdateIntegrationByIdResponseToJSON(
  integrationsControllerUpdateIntegrationByIdResponse: IntegrationsControllerUpdateIntegrationByIdResponse
): string {
  return JSON.stringify(
    IntegrationsControllerUpdateIntegrationByIdResponse$outboundSchema.parse(
      integrationsControllerUpdateIntegrationByIdResponse
    )
  );
}

export function integrationsControllerUpdateIntegrationByIdResponseFromJSON(
  jsonString: string
): SafeParseResult<IntegrationsControllerUpdateIntegrationByIdResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IntegrationsControllerUpdateIntegrationByIdResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IntegrationsControllerUpdateIntegrationByIdResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - integrationsControllerUpdateIntegrationByIdRequestToJSON(integrationsControllerUpdateIntegrationByIdRequest: IntegrationsControllerUpdateIntegrationByIdRequest)
 - integrationsControllerUpdateIntegrationByIdRequestFromJSON(jsonString: string)
 - integrationsControllerUpdateIntegrationByIdResponseToJSON(integrationsControllerUpdateIntegrationByIdResponse: IntegrationsControllerUpdateIntegrationByIdResponse)
 - integrationsControllerUpdateIntegrationByIdResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(IntegrationsControllerUpdateIntegrationByIdRequest$Outbound;
}

export function integrationsControll...)
 - Outbound(IntegrationsControllerUpdateIntegrationByIdResponse$Outbound;
}

export function integrationsControl...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function integrationsControllerUpdateIntegrationByIdRequestToJSON
- export function integrationsControllerUpdateIntegrationByIdRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function integrationsControllerUpdateIntegrationByIdResponseToJSON
- export function integrationsControllerUpdateIntegrationByIdResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/layoutscontrollercreate.ts
Tamaño: 5303 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type LayoutsControllerCreateRequest = {
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  /**
   * Layout creation details
   */
  createLayoutDto: components.CreateLayoutDto;
};

export type LayoutsControllerCreateResponse = {
  headers: { [k: string]: Array<string> };
  result: components.LayoutResponseDto;
};

/** @internal */
export const LayoutsControllerCreateRequest$inboundSchema: z.ZodType<
  LayoutsControllerCreateRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    'idempotency-key': z.string().optional(),
    CreateLayoutDto: components.CreateLayoutDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      CreateLayoutDto: 'createLayoutDto',
    });
  });

/** @internal */
export type LayoutsControllerCreateRequest$Outbound = {
  'idempotency-key'?: string | undefined;
  CreateLayoutDto: components.CreateLayoutDto$Outbound;
};

/** @internal */
export const LayoutsControllerCreateRequest$outboundSchema: z.ZodType<
  LayoutsControllerCreateRequest$Outbound,
  z.ZodTypeDef,
  LayoutsControllerCreateRequest
> = z
  .object({
    idempotencyKey: z.string().optional(),
    createLayoutDto: components.CreateLayoutDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      createLayoutDto: 'CreateLayoutDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutsControllerCreateRequest$ {
  /** @deprecated use `LayoutsControllerCreateRequest$inboundSchema` instead. */
  export const inboundSchema = LayoutsControllerCreateRequest$inboundSchema;
  /** @deprecated use `LayoutsControllerCreateRequest$outboundSchema` instead. */
  export const outboundSchema = LayoutsControllerCreateRequest$outboundSchema;
  /** @deprecated use `LayoutsControllerCreateRequest$Outbound` instead. */
  export type Outbound = LayoutsControllerCreateRequest$Outbound;
}

export function layoutsControllerCreateRequestToJSON(
  layoutsControllerCreateRequest: LayoutsControllerCreateRequest
): string {
  return JSON.stringify(LayoutsControllerCreateRequest$outboundSchema.parse(layoutsControllerCreateRequest));
}

export function layoutsControllerCreateRequestFromJSON(
  jsonString: string
): SafeParseResult<LayoutsControllerCreateRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutsControllerCreateRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutsControllerCreateRequest' from JSON`
  );
}

/** @internal */
export const LayoutsControllerCreateResponse$inboundSchema: z.ZodType<
  LayoutsControllerCreateResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.LayoutResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type LayoutsControllerCreateResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.LayoutResponseDto$Outbound;
};

/** @internal */
export const LayoutsControllerCreateResponse$outboundSchema: z.ZodType<
  LayoutsControllerCreateResponse$Outbound,
  z.ZodTypeDef,
  LayoutsControllerCreateResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.LayoutResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutsControllerCreateResponse$ {
  /** @deprecated use `LayoutsControllerCreateResponse$inboundSchema` instead. */
  export const inboundSchema = LayoutsControllerCreateResponse$inboundSchema;
  /** @deprecated use `LayoutsControllerCreateResponse$outboundSchema` instead. */
  export const outboundSchema = LayoutsControllerCreateResponse$outboundSchema;
  /** @deprecated use `LayoutsControllerCreateResponse$Outbound` instead. */
  export type Outbound = LayoutsControllerCreateResponse$Outbound;
}

export function layoutsControllerCreateResponseToJSON(
  layoutsControllerCreateResponse: LayoutsControllerCreateResponse
): string {
  return JSON.stringify(LayoutsControllerCreateResponse$outboundSchema.parse(layoutsControllerCreateResponse));
}

export function layoutsControllerCreateResponseFromJSON(
  jsonString: string
): SafeParseResult<LayoutsControllerCreateResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutsControllerCreateResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutsControllerCreateResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - layoutsControllerCreateRequestToJSON(layoutsControllerCreateRequest: LayoutsControllerCreateRequest)
 - layoutsControllerCreateRequestFromJSON(jsonString: string)
 - layoutsControllerCreateResponseToJSON(layoutsControllerCreateResponse: LayoutsControllerCreateResponse)
 - layoutsControllerCreateResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(LayoutsControllerCreateRequest$Outbound;
}

export function layoutsControllerCreateRequestToJSON(
  ...)
 - Outbound(LayoutsControllerCreateResponse$Outbound;
}

export function layoutsControllerCreateResponseToJSON(
...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsControllerCreateRequestToJSON
- export function layoutsControllerCreateRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsControllerCreateResponseToJSON
- export function layoutsControllerCreateResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/layoutscontrollerdelete.ts
Tamaño: 4789 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type LayoutsControllerDeleteRequest = {
  /**
   * The unique identifier of the layout
   */
  layoutId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type LayoutsControllerDeleteResponse = {
  headers: { [k: string]: Array<string> };
};

/** @internal */
export const LayoutsControllerDeleteRequest$inboundSchema: z.ZodType<
  LayoutsControllerDeleteRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    layoutId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type LayoutsControllerDeleteRequest$Outbound = {
  layoutId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const LayoutsControllerDeleteRequest$outboundSchema: z.ZodType<
  LayoutsControllerDeleteRequest$Outbound,
  z.ZodTypeDef,
  LayoutsControllerDeleteRequest
> = z
  .object({
    layoutId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutsControllerDeleteRequest$ {
  /** @deprecated use `LayoutsControllerDeleteRequest$inboundSchema` instead. */
  export const inboundSchema = LayoutsControllerDeleteRequest$inboundSchema;
  /** @deprecated use `LayoutsControllerDeleteRequest$outboundSchema` instead. */
  export const outboundSchema = LayoutsControllerDeleteRequest$outboundSchema;
  /** @deprecated use `LayoutsControllerDeleteRequest$Outbound` instead. */
  export type Outbound = LayoutsControllerDeleteRequest$Outbound;
}

export function layoutsControllerDeleteRequestToJSON(
  layoutsControllerDeleteRequest: LayoutsControllerDeleteRequest
): string {
  return JSON.stringify(LayoutsControllerDeleteRequest$outboundSchema.parse(layoutsControllerDeleteRequest));
}

export function layoutsControllerDeleteRequestFromJSON(
  jsonString: string
): SafeParseResult<LayoutsControllerDeleteRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutsControllerDeleteRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutsControllerDeleteRequest' from JSON`
  );
}

/** @internal */
export const LayoutsControllerDeleteResponse$inboundSchema: z.ZodType<
  LayoutsControllerDeleteResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
    });
  });

/** @internal */
export type LayoutsControllerDeleteResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
};

/** @internal */
export const LayoutsControllerDeleteResponse$outboundSchema: z.ZodType<
  LayoutsControllerDeleteResponse$Outbound,
  z.ZodTypeDef,
  LayoutsControllerDeleteResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutsControllerDeleteResponse$ {
  /** @deprecated use `LayoutsControllerDeleteResponse$inboundSchema` instead. */
  export const inboundSchema = LayoutsControllerDeleteResponse$inboundSchema;
  /** @deprecated use `LayoutsControllerDeleteResponse$outboundSchema` instead. */
  export const outboundSchema = LayoutsControllerDeleteResponse$outboundSchema;
  /** @deprecated use `LayoutsControllerDeleteResponse$Outbound` instead. */
  export type Outbound = LayoutsControllerDeleteResponse$Outbound;
}

export function layoutsControllerDeleteResponseToJSON(
  layoutsControllerDeleteResponse: LayoutsControllerDeleteResponse
): string {
  return JSON.stringify(LayoutsControllerDeleteResponse$outboundSchema.parse(layoutsControllerDeleteResponse));
}

export function layoutsControllerDeleteResponseFromJSON(
  jsonString: string
): SafeParseResult<LayoutsControllerDeleteResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutsControllerDeleteResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutsControllerDeleteResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - layoutsControllerDeleteRequestToJSON(layoutsControllerDeleteRequest: LayoutsControllerDeleteRequest)
 - layoutsControllerDeleteRequestFromJSON(jsonString: string)
 - layoutsControllerDeleteResponseToJSON(layoutsControllerDeleteResponse: LayoutsControllerDeleteResponse)
 - layoutsControllerDeleteResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(LayoutsControllerDeleteRequest$Outbound;
}

export function layoutsControllerDeleteRequestToJSON(
  ...)
 - Outbound(LayoutsControllerDeleteResponse$Outbound;
}

export function layoutsControllerDeleteResponseToJSON(
...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsControllerDeleteRequestToJSON
- export function layoutsControllerDeleteRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsControllerDeleteResponseToJSON
- export function layoutsControllerDeleteResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/layoutscontrollerduplicate.ts
Tamaño: 5528 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type LayoutsControllerDuplicateRequest = {
  layoutId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  duplicateLayoutDto: components.DuplicateLayoutDto;
};

export type LayoutsControllerDuplicateResponse = {
  headers: { [k: string]: Array<string> };
  result: components.LayoutResponseDto;
};

/** @internal */
export const LayoutsControllerDuplicateRequest$inboundSchema: z.ZodType<
  LayoutsControllerDuplicateRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    layoutId: z.string(),
    'idempotency-key': z.string().optional(),
    DuplicateLayoutDto: components.DuplicateLayoutDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      DuplicateLayoutDto: 'duplicateLayoutDto',
    });
  });

/** @internal */
export type LayoutsControllerDuplicateRequest$Outbound = {
  layoutId: string;
  'idempotency-key'?: string | undefined;
  DuplicateLayoutDto: components.DuplicateLayoutDto$Outbound;
};

/** @internal */
export const LayoutsControllerDuplicateRequest$outboundSchema: z.ZodType<
  LayoutsControllerDuplicateRequest$Outbound,
  z.ZodTypeDef,
  LayoutsControllerDuplicateRequest
> = z
  .object({
    layoutId: z.string(),
    idempotencyKey: z.string().optional(),
    duplicateLayoutDto: components.DuplicateLayoutDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      duplicateLayoutDto: 'DuplicateLayoutDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutsControllerDuplicateRequest$ {
  /** @deprecated use `LayoutsControllerDuplicateRequest$inboundSchema` instead. */
  export const inboundSchema = LayoutsControllerDuplicateRequest$inboundSchema;
  /** @deprecated use `LayoutsControllerDuplicateRequest$outboundSchema` instead. */
  export const outboundSchema = LayoutsControllerDuplicateRequest$outboundSchema;
  /** @deprecated use `LayoutsControllerDuplicateRequest$Outbound` instead. */
  export type Outbound = LayoutsControllerDuplicateRequest$Outbound;
}

export function layoutsControllerDuplicateRequestToJSON(
  layoutsControllerDuplicateRequest: LayoutsControllerDuplicateRequest
): string {
  return JSON.stringify(LayoutsControllerDuplicateRequest$outboundSchema.parse(layoutsControllerDuplicateRequest));
}

export function layoutsControllerDuplicateRequestFromJSON(
  jsonString: string
): SafeParseResult<LayoutsControllerDuplicateRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutsControllerDuplicateRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutsControllerDuplicateRequest' from JSON`
  );
}

/** @internal */
export const LayoutsControllerDuplicateResponse$inboundSchema: z.ZodType<
  LayoutsControllerDuplicateResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.LayoutResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type LayoutsControllerDuplicateResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.LayoutResponseDto$Outbound;
};

/** @internal */
export const LayoutsControllerDuplicateResponse$outboundSchema: z.ZodType<
  LayoutsControllerDuplicateResponse$Outbound,
  z.ZodTypeDef,
  LayoutsControllerDuplicateResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.LayoutResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutsControllerDuplicateResponse$ {
  /** @deprecated use `LayoutsControllerDuplicateResponse$inboundSchema` instead. */
  export const inboundSchema = LayoutsControllerDuplicateResponse$inboundSchema;
  /** @deprecated use `LayoutsControllerDuplicateResponse$outboundSchema` instead. */
  export const outboundSchema = LayoutsControllerDuplicateResponse$outboundSchema;
  /** @deprecated use `LayoutsControllerDuplicateResponse$Outbound` instead. */
  export type Outbound = LayoutsControllerDuplicateResponse$Outbound;
}

export function layoutsControllerDuplicateResponseToJSON(
  layoutsControllerDuplicateResponse: LayoutsControllerDuplicateResponse
): string {
  return JSON.stringify(LayoutsControllerDuplicateResponse$outboundSchema.parse(layoutsControllerDuplicateResponse));
}

export function layoutsControllerDuplicateResponseFromJSON(
  jsonString: string
): SafeParseResult<LayoutsControllerDuplicateResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutsControllerDuplicateResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutsControllerDuplicateResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - layoutsControllerDuplicateRequestToJSON(layoutsControllerDuplicateRequest: LayoutsControllerDuplicateRequest)
 - layoutsControllerDuplicateRequestFromJSON(jsonString: string)
 - layoutsControllerDuplicateResponseToJSON(layoutsControllerDuplicateResponse: LayoutsControllerDuplicateResponse)
 - layoutsControllerDuplicateResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(LayoutsControllerDuplicateRequest$Outbound;
}

export function layoutsControllerDuplicateRequestToJS...)
 - Outbound(LayoutsControllerDuplicateResponse$Outbound;
}

export function layoutsControllerDuplicateResponseTo...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsControllerDuplicateRequestToJSON
- export function layoutsControllerDuplicateRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsControllerDuplicateResponseToJSON
- export function layoutsControllerDuplicateResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/layoutscontrollergeneratepreview.ts
Tamaño: 5991 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type LayoutsControllerGeneratePreviewRequest = {
  layoutId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  /**
   * Layout preview generation details
   */
  layoutPreviewRequestDto: components.LayoutPreviewRequestDto;
};

export type LayoutsControllerGeneratePreviewResponse = {
  headers: { [k: string]: Array<string> };
  result: components.GenerateLayoutPreviewResponseDto;
};

/** @internal */
export const LayoutsControllerGeneratePreviewRequest$inboundSchema: z.ZodType<
  LayoutsControllerGeneratePreviewRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    layoutId: z.string(),
    'idempotency-key': z.string().optional(),
    LayoutPreviewRequestDto: components.LayoutPreviewRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      LayoutPreviewRequestDto: 'layoutPreviewRequestDto',
    });
  });

/** @internal */
export type LayoutsControllerGeneratePreviewRequest$Outbound = {
  layoutId: string;
  'idempotency-key'?: string | undefined;
  LayoutPreviewRequestDto: components.LayoutPreviewRequestDto$Outbound;
};

/** @internal */
export const LayoutsControllerGeneratePreviewRequest$outboundSchema: z.ZodType<
  LayoutsControllerGeneratePreviewRequest$Outbound,
  z.ZodTypeDef,
  LayoutsControllerGeneratePreviewRequest
> = z
  .object({
    layoutId: z.string(),
    idempotencyKey: z.string().optional(),
    layoutPreviewRequestDto: components.LayoutPreviewRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      layoutPreviewRequestDto: 'LayoutPreviewRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutsControllerGeneratePreviewRequest$ {
  /** @deprecated use `LayoutsControllerGeneratePreviewRequest$inboundSchema` instead. */
  export const inboundSchema = LayoutsControllerGeneratePreviewRequest$inboundSchema;
  /** @deprecated use `LayoutsControllerGeneratePreviewRequest$outboundSchema` instead. */
  export const outboundSchema = LayoutsControllerGeneratePreviewRequest$outboundSchema;
  /** @deprecated use `LayoutsControllerGeneratePreviewRequest$Outbound` instead. */
  export type Outbound = LayoutsControllerGeneratePreviewRequest$Outbound;
}

export function layoutsControllerGeneratePreviewRequestToJSON(
  layoutsControllerGeneratePreviewRequest: LayoutsControllerGeneratePreviewRequest
): string {
  return JSON.stringify(
    LayoutsControllerGeneratePreviewRequest$outboundSchema.parse(layoutsControllerGeneratePreviewRequest)
  );
}

export function layoutsControllerGeneratePreviewRequestFromJSON(
  jsonString: string
): SafeParseResult<LayoutsControllerGeneratePreviewRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutsControllerGeneratePreviewRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutsControllerGeneratePreviewRequest' from JSON`
  );
}

/** @internal */
export const LayoutsControllerGeneratePreviewResponse$inboundSchema: z.ZodType<
  LayoutsControllerGeneratePreviewResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.GenerateLayoutPreviewResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type LayoutsControllerGeneratePreviewResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.GenerateLayoutPreviewResponseDto$Outbound;
};

/** @internal */
export const LayoutsControllerGeneratePreviewResponse$outboundSchema: z.ZodType<
  LayoutsControllerGeneratePreviewResponse$Outbound,
  z.ZodTypeDef,
  LayoutsControllerGeneratePreviewResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.GenerateLayoutPreviewResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutsControllerGeneratePreviewResponse$ {
  /** @deprecated use `LayoutsControllerGeneratePreviewResponse$inboundSchema` instead. */
  export const inboundSchema = LayoutsControllerGeneratePreviewResponse$inboundSchema;
  /** @deprecated use `LayoutsControllerGeneratePreviewResponse$outboundSchema` instead. */
  export const outboundSchema = LayoutsControllerGeneratePreviewResponse$outboundSchema;
  /** @deprecated use `LayoutsControllerGeneratePreviewResponse$Outbound` instead. */
  export type Outbound = LayoutsControllerGeneratePreviewResponse$Outbound;
}

export function layoutsControllerGeneratePreviewResponseToJSON(
  layoutsControllerGeneratePreviewResponse: LayoutsControllerGeneratePreviewResponse
): string {
  return JSON.stringify(
    LayoutsControllerGeneratePreviewResponse$outboundSchema.parse(layoutsControllerGeneratePreviewResponse)
  );
}

export function layoutsControllerGeneratePreviewResponseFromJSON(
  jsonString: string
): SafeParseResult<LayoutsControllerGeneratePreviewResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutsControllerGeneratePreviewResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutsControllerGeneratePreviewResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - layoutsControllerGeneratePreviewRequestToJSON(layoutsControllerGeneratePreviewRequest: LayoutsControllerGeneratePreviewRequest)
 - layoutsControllerGeneratePreviewRequestFromJSON(jsonString: string)
 - layoutsControllerGeneratePreviewResponseToJSON(layoutsControllerGeneratePreviewResponse: LayoutsControllerGeneratePreviewResponse)
 - layoutsControllerGeneratePreviewResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(LayoutsControllerGeneratePreviewRequest$Outbound;
}

export function layoutsControllerGeneratePrevie...)
 - Outbound(LayoutsControllerGeneratePreviewResponse$Outbound;
}

export function layoutsControllerGeneratePrevi...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsControllerGeneratePreviewRequestToJSON
- export function layoutsControllerGeneratePreviewRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsControllerGeneratePreviewResponseToJSON
- export function layoutsControllerGeneratePreviewResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/layoutscontrollerget.ts
Tamaño: 4906 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type LayoutsControllerGetRequest = {
  layoutId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type LayoutsControllerGetResponse = {
  headers: { [k: string]: Array<string> };
  result: components.LayoutResponseDto;
};

/** @internal */
export const LayoutsControllerGetRequest$inboundSchema: z.ZodType<LayoutsControllerGetRequest, z.ZodTypeDef, unknown> =
  z
    .object({
      layoutId: z.string(),
      'idempotency-key': z.string().optional(),
    })
    .transform((v) => {
      return remap$(v, {
        'idempotency-key': 'idempotencyKey',
      });
    });

/** @internal */
export type LayoutsControllerGetRequest$Outbound = {
  layoutId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const LayoutsControllerGetRequest$outboundSchema: z.ZodType<
  LayoutsControllerGetRequest$Outbound,
  z.ZodTypeDef,
  LayoutsControllerGetRequest
> = z
  .object({
    layoutId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutsControllerGetRequest$ {
  /** @deprecated use `LayoutsControllerGetRequest$inboundSchema` instead. */
  export const inboundSchema = LayoutsControllerGetRequest$inboundSchema;
  /** @deprecated use `LayoutsControllerGetRequest$outboundSchema` instead. */
  export const outboundSchema = LayoutsControllerGetRequest$outboundSchema;
  /** @deprecated use `LayoutsControllerGetRequest$Outbound` instead. */
  export type Outbound = LayoutsControllerGetRequest$Outbound;
}

export function layoutsControllerGetRequestToJSON(layoutsControllerGetRequest: LayoutsControllerGetRequest): string {
  return JSON.stringify(LayoutsControllerGetRequest$outboundSchema.parse(layoutsControllerGetRequest));
}

export function layoutsControllerGetRequestFromJSON(
  jsonString: string
): SafeParseResult<LayoutsControllerGetRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutsControllerGetRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutsControllerGetRequest' from JSON`
  );
}

/** @internal */
export const LayoutsControllerGetResponse$inboundSchema: z.ZodType<
  LayoutsControllerGetResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.LayoutResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type LayoutsControllerGetResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.LayoutResponseDto$Outbound;
};

/** @internal */
export const LayoutsControllerGetResponse$outboundSchema: z.ZodType<
  LayoutsControllerGetResponse$Outbound,
  z.ZodTypeDef,
  LayoutsControllerGetResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.LayoutResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutsControllerGetResponse$ {
  /** @deprecated use `LayoutsControllerGetResponse$inboundSchema` instead. */
  export const inboundSchema = LayoutsControllerGetResponse$inboundSchema;
  /** @deprecated use `LayoutsControllerGetResponse$outboundSchema` instead. */
  export const outboundSchema = LayoutsControllerGetResponse$outboundSchema;
  /** @deprecated use `LayoutsControllerGetResponse$Outbound` instead. */
  export type Outbound = LayoutsControllerGetResponse$Outbound;
}

export function layoutsControllerGetResponseToJSON(layoutsControllerGetResponse: LayoutsControllerGetResponse): string {
  return JSON.stringify(LayoutsControllerGetResponse$outboundSchema.parse(layoutsControllerGetResponse));
}

export function layoutsControllerGetResponseFromJSON(
  jsonString: string
): SafeParseResult<LayoutsControllerGetResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutsControllerGetResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutsControllerGetResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - layoutsControllerGetRequestToJSON(layoutsControllerGetRequest: LayoutsControllerGetRequest)
 - layoutsControllerGetRequestFromJSON(jsonString: string)
 - layoutsControllerGetResponseToJSON(layoutsControllerGetResponse: LayoutsControllerGetResponse)
 - layoutsControllerGetResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(LayoutsControllerGetRequest$Outbound;
}

export function layoutsControllerGetRequestToJSON(layoutsCo...)
 - Outbound(LayoutsControllerGetResponse$Outbound;
}

export function layoutsControllerGetResponseToJSON(layouts...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsControllerGetRequestToJSON
- export function layoutsControllerGetRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsControllerGetResponseToJSON
- export function layoutsControllerGetResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/layoutscontrollergetusage.ts
Tamaño: 5164 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type LayoutsControllerGetUsageRequest = {
  layoutId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type LayoutsControllerGetUsageResponse = {
  headers: { [k: string]: Array<string> };
  result: components.GetLayoutUsageResponseDto;
};

/** @internal */
export const LayoutsControllerGetUsageRequest$inboundSchema: z.ZodType<
  LayoutsControllerGetUsageRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    layoutId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type LayoutsControllerGetUsageRequest$Outbound = {
  layoutId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const LayoutsControllerGetUsageRequest$outboundSchema: z.ZodType<
  LayoutsControllerGetUsageRequest$Outbound,
  z.ZodTypeDef,
  LayoutsControllerGetUsageRequest
> = z
  .object({
    layoutId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutsControllerGetUsageRequest$ {
  /** @deprecated use `LayoutsControllerGetUsageRequest$inboundSchema` instead. */
  export const inboundSchema = LayoutsControllerGetUsageRequest$inboundSchema;
  /** @deprecated use `LayoutsControllerGetUsageRequest$outboundSchema` instead. */
  export const outboundSchema = LayoutsControllerGetUsageRequest$outboundSchema;
  /** @deprecated use `LayoutsControllerGetUsageRequest$Outbound` instead. */
  export type Outbound = LayoutsControllerGetUsageRequest$Outbound;
}

export function layoutsControllerGetUsageRequestToJSON(
  layoutsControllerGetUsageRequest: LayoutsControllerGetUsageRequest
): string {
  return JSON.stringify(LayoutsControllerGetUsageRequest$outboundSchema.parse(layoutsControllerGetUsageRequest));
}

export function layoutsControllerGetUsageRequestFromJSON(
  jsonString: string
): SafeParseResult<LayoutsControllerGetUsageRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutsControllerGetUsageRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutsControllerGetUsageRequest' from JSON`
  );
}

/** @internal */
export const LayoutsControllerGetUsageResponse$inboundSchema: z.ZodType<
  LayoutsControllerGetUsageResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.GetLayoutUsageResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type LayoutsControllerGetUsageResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.GetLayoutUsageResponseDto$Outbound;
};

/** @internal */
export const LayoutsControllerGetUsageResponse$outboundSchema: z.ZodType<
  LayoutsControllerGetUsageResponse$Outbound,
  z.ZodTypeDef,
  LayoutsControllerGetUsageResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.GetLayoutUsageResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutsControllerGetUsageResponse$ {
  /** @deprecated use `LayoutsControllerGetUsageResponse$inboundSchema` instead. */
  export const inboundSchema = LayoutsControllerGetUsageResponse$inboundSchema;
  /** @deprecated use `LayoutsControllerGetUsageResponse$outboundSchema` instead. */
  export const outboundSchema = LayoutsControllerGetUsageResponse$outboundSchema;
  /** @deprecated use `LayoutsControllerGetUsageResponse$Outbound` instead. */
  export type Outbound = LayoutsControllerGetUsageResponse$Outbound;
}

export function layoutsControllerGetUsageResponseToJSON(
  layoutsControllerGetUsageResponse: LayoutsControllerGetUsageResponse
): string {
  return JSON.stringify(LayoutsControllerGetUsageResponse$outboundSchema.parse(layoutsControllerGetUsageResponse));
}

export function layoutsControllerGetUsageResponseFromJSON(
  jsonString: string
): SafeParseResult<LayoutsControllerGetUsageResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutsControllerGetUsageResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutsControllerGetUsageResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - layoutsControllerGetUsageRequestToJSON(layoutsControllerGetUsageRequest: LayoutsControllerGetUsageRequest)
 - layoutsControllerGetUsageRequestFromJSON(jsonString: string)
 - layoutsControllerGetUsageResponseToJSON(layoutsControllerGetUsageResponse: LayoutsControllerGetUsageResponse)
 - layoutsControllerGetUsageResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(LayoutsControllerGetUsageRequest$Outbound;
}

export function layoutsControllerGetUsageRequestToJSON...)
 - Outbound(LayoutsControllerGetUsageResponse$Outbound;
}

export function layoutsControllerGetUsageResponseToJS...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsControllerGetUsageRequestToJSON
- export function layoutsControllerGetUsageRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsControllerGetUsageResponseToJSON
- export function layoutsControllerGetUsageResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/layoutscontrollerlist.ts
Tamaño: 6004 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type LayoutsControllerListRequest = {
  /**
   * Number of items to return per page
   */
  limit?: number | undefined;
  /**
   * Number of items to skip before starting to return results
   */
  offset?: number | undefined;
  /**
   * Direction of sorting
   */
  orderDirection?: components.DirectionEnum | undefined;
  /**
   * Field to sort the results by
   */
  orderBy?: components.LayoutResponseDtoSortField | undefined;
  /**
   * Search query to filter layouts
   */
  query?: string | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type LayoutsControllerListResponse = {
  headers: { [k: string]: Array<string> };
  result: components.ListLayoutResponseDto;
};

/** @internal */
export const LayoutsControllerListRequest$inboundSchema: z.ZodType<
  LayoutsControllerListRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    limit: z.number().optional(),
    offset: z.number().optional(),
    orderDirection: components.DirectionEnum$inboundSchema.optional(),
    orderBy: components.LayoutResponseDtoSortField$inboundSchema.optional(),
    query: z.string().optional(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type LayoutsControllerListRequest$Outbound = {
  limit?: number | undefined;
  offset?: number | undefined;
  orderDirection?: string | undefined;
  orderBy?: string | undefined;
  query?: string | undefined;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const LayoutsControllerListRequest$outboundSchema: z.ZodType<
  LayoutsControllerListRequest$Outbound,
  z.ZodTypeDef,
  LayoutsControllerListRequest
> = z
  .object({
    limit: z.number().optional(),
    offset: z.number().optional(),
    orderDirection: components.DirectionEnum$outboundSchema.optional(),
    orderBy: components.LayoutResponseDtoSortField$outboundSchema.optional(),
    query: z.string().optional(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutsControllerListRequest$ {
  /** @deprecated use `LayoutsControllerListRequest$inboundSchema` instead. */
  export const inboundSchema = LayoutsControllerListRequest$inboundSchema;
  /** @deprecated use `LayoutsControllerListRequest$outboundSchema` instead. */
  export const outboundSchema = LayoutsControllerListRequest$outboundSchema;
  /** @deprecated use `LayoutsControllerListRequest$Outbound` instead. */
  export type Outbound = LayoutsControllerListRequest$Outbound;
}

export function layoutsControllerListRequestToJSON(layoutsControllerListRequest: LayoutsControllerListRequest): string {
  return JSON.stringify(LayoutsControllerListRequest$outboundSchema.parse(layoutsControllerListRequest));
}

export function layoutsControllerListRequestFromJSON(
  jsonString: string
): SafeParseResult<LayoutsControllerListRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutsControllerListRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutsControllerListRequest' from JSON`
  );
}

/** @internal */
export const LayoutsControllerListResponse$inboundSchema: z.ZodType<
  LayoutsControllerListResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.ListLayoutResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type LayoutsControllerListResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.ListLayoutResponseDto$Outbound;
};

/** @internal */
export const LayoutsControllerListResponse$outboundSchema: z.ZodType<
  LayoutsControllerListResponse$Outbound,
  z.ZodTypeDef,
  LayoutsControllerListResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.ListLayoutResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutsControllerListResponse$ {
  /** @deprecated use `LayoutsControllerListResponse$inboundSchema` instead. */
  export const inboundSchema = LayoutsControllerListResponse$inboundSchema;
  /** @deprecated use `LayoutsControllerListResponse$outboundSchema` instead. */
  export const outboundSchema = LayoutsControllerListResponse$outboundSchema;
  /** @deprecated use `LayoutsControllerListResponse$Outbound` instead. */
  export type Outbound = LayoutsControllerListResponse$Outbound;
}

export function layoutsControllerListResponseToJSON(
  layoutsControllerListResponse: LayoutsControllerListResponse
): string {
  return JSON.stringify(LayoutsControllerListResponse$outboundSchema.parse(layoutsControllerListResponse));
}

export function layoutsControllerListResponseFromJSON(
  jsonString: string
): SafeParseResult<LayoutsControllerListResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutsControllerListResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutsControllerListResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - layoutsControllerListRequestToJSON(layoutsControllerListRequest: LayoutsControllerListRequest)
 - layoutsControllerListRequestFromJSON(jsonString: string)
 - layoutsControllerListResponseToJSON(layoutsControllerListResponse: LayoutsControllerListResponse)
 - layoutsControllerListResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(LayoutsControllerListRequest$Outbound;
}

export function layoutsControllerListRequestToJSON(layouts...)
 - Outbound(LayoutsControllerListResponse$Outbound;
}

export function layoutsControllerListResponseToJSON(
  la...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsControllerListRequestToJSON
- export function layoutsControllerListRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsControllerListResponseToJSON
- export function layoutsControllerListResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/layoutscontrollerupdate.ts
Tamaño: 5393 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type LayoutsControllerUpdateRequest = {
  layoutId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  /**
   * Layout update details
   */
  updateLayoutDto: components.UpdateLayoutDto;
};

export type LayoutsControllerUpdateResponse = {
  headers: { [k: string]: Array<string> };
  result: components.LayoutResponseDto;
};

/** @internal */
export const LayoutsControllerUpdateRequest$inboundSchema: z.ZodType<
  LayoutsControllerUpdateRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    layoutId: z.string(),
    'idempotency-key': z.string().optional(),
    UpdateLayoutDto: components.UpdateLayoutDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      UpdateLayoutDto: 'updateLayoutDto',
    });
  });

/** @internal */
export type LayoutsControllerUpdateRequest$Outbound = {
  layoutId: string;
  'idempotency-key'?: string | undefined;
  UpdateLayoutDto: components.UpdateLayoutDto$Outbound;
};

/** @internal */
export const LayoutsControllerUpdateRequest$outboundSchema: z.ZodType<
  LayoutsControllerUpdateRequest$Outbound,
  z.ZodTypeDef,
  LayoutsControllerUpdateRequest
> = z
  .object({
    layoutId: z.string(),
    idempotencyKey: z.string().optional(),
    updateLayoutDto: components.UpdateLayoutDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      updateLayoutDto: 'UpdateLayoutDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutsControllerUpdateRequest$ {
  /** @deprecated use `LayoutsControllerUpdateRequest$inboundSchema` instead. */
  export const inboundSchema = LayoutsControllerUpdateRequest$inboundSchema;
  /** @deprecated use `LayoutsControllerUpdateRequest$outboundSchema` instead. */
  export const outboundSchema = LayoutsControllerUpdateRequest$outboundSchema;
  /** @deprecated use `LayoutsControllerUpdateRequest$Outbound` instead. */
  export type Outbound = LayoutsControllerUpdateRequest$Outbound;
}

export function layoutsControllerUpdateRequestToJSON(
  layoutsControllerUpdateRequest: LayoutsControllerUpdateRequest
): string {
  return JSON.stringify(LayoutsControllerUpdateRequest$outboundSchema.parse(layoutsControllerUpdateRequest));
}

export function layoutsControllerUpdateRequestFromJSON(
  jsonString: string
): SafeParseResult<LayoutsControllerUpdateRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutsControllerUpdateRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutsControllerUpdateRequest' from JSON`
  );
}

/** @internal */
export const LayoutsControllerUpdateResponse$inboundSchema: z.ZodType<
  LayoutsControllerUpdateResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.LayoutResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type LayoutsControllerUpdateResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.LayoutResponseDto$Outbound;
};

/** @internal */
export const LayoutsControllerUpdateResponse$outboundSchema: z.ZodType<
  LayoutsControllerUpdateResponse$Outbound,
  z.ZodTypeDef,
  LayoutsControllerUpdateResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.LayoutResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LayoutsControllerUpdateResponse$ {
  /** @deprecated use `LayoutsControllerUpdateResponse$inboundSchema` instead. */
  export const inboundSchema = LayoutsControllerUpdateResponse$inboundSchema;
  /** @deprecated use `LayoutsControllerUpdateResponse$outboundSchema` instead. */
  export const outboundSchema = LayoutsControllerUpdateResponse$outboundSchema;
  /** @deprecated use `LayoutsControllerUpdateResponse$Outbound` instead. */
  export type Outbound = LayoutsControllerUpdateResponse$Outbound;
}

export function layoutsControllerUpdateResponseToJSON(
  layoutsControllerUpdateResponse: LayoutsControllerUpdateResponse
): string {
  return JSON.stringify(LayoutsControllerUpdateResponse$outboundSchema.parse(layoutsControllerUpdateResponse));
}

export function layoutsControllerUpdateResponseFromJSON(
  jsonString: string
): SafeParseResult<LayoutsControllerUpdateResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LayoutsControllerUpdateResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LayoutsControllerUpdateResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - layoutsControllerUpdateRequestToJSON(layoutsControllerUpdateRequest: LayoutsControllerUpdateRequest)
 - layoutsControllerUpdateRequestFromJSON(jsonString: string)
 - layoutsControllerUpdateResponseToJSON(layoutsControllerUpdateResponse: LayoutsControllerUpdateResponse)
 - layoutsControllerUpdateResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(LayoutsControllerUpdateRequest$Outbound;
}

export function layoutsControllerUpdateRequestToJSON(
  ...)
 - Outbound(LayoutsControllerUpdateResponse$Outbound;
}

export function layoutsControllerUpdateResponseToJSON(
...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsControllerUpdateRequestToJSON
- export function layoutsControllerUpdateRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function layoutsControllerUpdateResponseToJSON
- export function layoutsControllerUpdateResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/messagescontrollerdeletemessage.ts
Tamaño: 5456 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type MessagesControllerDeleteMessageRequest = {
  messageId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type MessagesControllerDeleteMessageResponse = {
  headers: { [k: string]: Array<string> };
  result: components.DeleteMessageResponseDto;
};

/** @internal */
export const MessagesControllerDeleteMessageRequest$inboundSchema: z.ZodType<
  MessagesControllerDeleteMessageRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    messageId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type MessagesControllerDeleteMessageRequest$Outbound = {
  messageId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const MessagesControllerDeleteMessageRequest$outboundSchema: z.ZodType<
  MessagesControllerDeleteMessageRequest$Outbound,
  z.ZodTypeDef,
  MessagesControllerDeleteMessageRequest
> = z
  .object({
    messageId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessagesControllerDeleteMessageRequest$ {
  /** @deprecated use `MessagesControllerDeleteMessageRequest$inboundSchema` instead. */
  export const inboundSchema = MessagesControllerDeleteMessageRequest$inboundSchema;
  /** @deprecated use `MessagesControllerDeleteMessageRequest$outboundSchema` instead. */
  export const outboundSchema = MessagesControllerDeleteMessageRequest$outboundSchema;
  /** @deprecated use `MessagesControllerDeleteMessageRequest$Outbound` instead. */
  export type Outbound = MessagesControllerDeleteMessageRequest$Outbound;
}

export function messagesControllerDeleteMessageRequestToJSON(
  messagesControllerDeleteMessageRequest: MessagesControllerDeleteMessageRequest
): string {
  return JSON.stringify(
    MessagesControllerDeleteMessageRequest$outboundSchema.parse(messagesControllerDeleteMessageRequest)
  );
}

export function messagesControllerDeleteMessageRequestFromJSON(
  jsonString: string
): SafeParseResult<MessagesControllerDeleteMessageRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesControllerDeleteMessageRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesControllerDeleteMessageRequest' from JSON`
  );
}

/** @internal */
export const MessagesControllerDeleteMessageResponse$inboundSchema: z.ZodType<
  MessagesControllerDeleteMessageResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.DeleteMessageResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type MessagesControllerDeleteMessageResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.DeleteMessageResponseDto$Outbound;
};

/** @internal */
export const MessagesControllerDeleteMessageResponse$outboundSchema: z.ZodType<
  MessagesControllerDeleteMessageResponse$Outbound,
  z.ZodTypeDef,
  MessagesControllerDeleteMessageResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.DeleteMessageResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessagesControllerDeleteMessageResponse$ {
  /** @deprecated use `MessagesControllerDeleteMessageResponse$inboundSchema` instead. */
  export const inboundSchema = MessagesControllerDeleteMessageResponse$inboundSchema;
  /** @deprecated use `MessagesControllerDeleteMessageResponse$outboundSchema` instead. */
  export const outboundSchema = MessagesControllerDeleteMessageResponse$outboundSchema;
  /** @deprecated use `MessagesControllerDeleteMessageResponse$Outbound` instead. */
  export type Outbound = MessagesControllerDeleteMessageResponse$Outbound;
}

export function messagesControllerDeleteMessageResponseToJSON(
  messagesControllerDeleteMessageResponse: MessagesControllerDeleteMessageResponse
): string {
  return JSON.stringify(
    MessagesControllerDeleteMessageResponse$outboundSchema.parse(messagesControllerDeleteMessageResponse)
  );
}

export function messagesControllerDeleteMessageResponseFromJSON(
  jsonString: string
): SafeParseResult<MessagesControllerDeleteMessageResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesControllerDeleteMessageResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesControllerDeleteMessageResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messagesControllerDeleteMessageRequestToJSON(messagesControllerDeleteMessageRequest: MessagesControllerDeleteMessageRequest)
 - messagesControllerDeleteMessageRequestFromJSON(jsonString: string)
 - messagesControllerDeleteMessageResponseToJSON(messagesControllerDeleteMessageResponse: MessagesControllerDeleteMessageResponse)
 - messagesControllerDeleteMessageResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MessagesControllerDeleteMessageRequest$Outbound;
}

export function messagesControllerDeleteMessageR...)
 - Outbound(MessagesControllerDeleteMessageResponse$Outbound;
}

export function messagesControllerDeleteMessage...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messagesControllerDeleteMessageRequestToJSON
- export function messagesControllerDeleteMessageRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messagesControllerDeleteMessageResponseToJSON
- export function messagesControllerDeleteMessageResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/messagescontrollerdeletemessagesbytransactionid.ts
Tamaño: 7079 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * The channel of the message to be deleted
 */
export const Channel = {
  InApp: 'in_app',
  Email: 'email',
  Sms: 'sms',
  Chat: 'chat',
  Push: 'push',
} as const;
/**
 * The channel of the message to be deleted
 */
export type Channel = ClosedEnum<typeof Channel>;

export type MessagesControllerDeleteMessagesByTransactionIdRequest = {
  /**
   * The channel of the message to be deleted
   */
  channel?: Channel | undefined;
  transactionId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type MessagesControllerDeleteMessagesByTransactionIdResponse = {
  headers: { [k: string]: Array<string> };
};

/** @internal */
export const Channel$inboundSchema: z.ZodNativeEnum<typeof Channel> = z.nativeEnum(Channel);

/** @internal */
export const Channel$outboundSchema: z.ZodNativeEnum<typeof Channel> = Channel$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Channel$ {
  /** @deprecated use `Channel$inboundSchema` instead. */
  export const inboundSchema = Channel$inboundSchema;
  /** @deprecated use `Channel$outboundSchema` instead. */
  export const outboundSchema = Channel$outboundSchema;
}

/** @internal */
export const MessagesControllerDeleteMessagesByTransactionIdRequest$inboundSchema: z.ZodType<
  MessagesControllerDeleteMessagesByTransactionIdRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    channel: Channel$inboundSchema.optional(),
    transactionId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type MessagesControllerDeleteMessagesByTransactionIdRequest$Outbound = {
  channel?: string | undefined;
  transactionId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const MessagesControllerDeleteMessagesByTransactionIdRequest$outboundSchema: z.ZodType<
  MessagesControllerDeleteMessagesByTransactionIdRequest$Outbound,
  z.ZodTypeDef,
  MessagesControllerDeleteMessagesByTransactionIdRequest
> = z
  .object({
    channel: Channel$outboundSchema.optional(),
    transactionId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessagesControllerDeleteMessagesByTransactionIdRequest$ {
  /** @deprecated use `MessagesControllerDeleteMessagesByTransactionIdRequest$inboundSchema` instead. */
  export const inboundSchema = MessagesControllerDeleteMessagesByTransactionIdRequest$inboundSchema;
  /** @deprecated use `MessagesControllerDeleteMessagesByTransactionIdRequest$outboundSchema` instead. */
  export const outboundSchema = MessagesControllerDeleteMessagesByTransactionIdRequest$outboundSchema;
  /** @deprecated use `MessagesControllerDeleteMessagesByTransactionIdRequest$Outbound` instead. */
  export type Outbound = MessagesControllerDeleteMessagesByTransactionIdRequest$Outbound;
}

export function messagesControllerDeleteMessagesByTransactionIdRequestToJSON(
  messagesControllerDeleteMessagesByTransactionIdRequest: MessagesControllerDeleteMessagesByTransactionIdRequest
): string {
  return JSON.stringify(
    MessagesControllerDeleteMessagesByTransactionIdRequest$outboundSchema.parse(
      messagesControllerDeleteMessagesByTransactionIdRequest
    )
  );
}

export function messagesControllerDeleteMessagesByTransactionIdRequestFromJSON(
  jsonString: string
): SafeParseResult<MessagesControllerDeleteMessagesByTransactionIdRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesControllerDeleteMessagesByTransactionIdRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesControllerDeleteMessagesByTransactionIdRequest' from JSON`
  );
}

/** @internal */
export const MessagesControllerDeleteMessagesByTransactionIdResponse$inboundSchema: z.ZodType<
  MessagesControllerDeleteMessagesByTransactionIdResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
    });
  });

/** @internal */
export type MessagesControllerDeleteMessagesByTransactionIdResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
};

/** @internal */
export const MessagesControllerDeleteMessagesByTransactionIdResponse$outboundSchema: z.ZodType<
  MessagesControllerDeleteMessagesByTransactionIdResponse$Outbound,
  z.ZodTypeDef,
  MessagesControllerDeleteMessagesByTransactionIdResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessagesControllerDeleteMessagesByTransactionIdResponse$ {
  /** @deprecated use `MessagesControllerDeleteMessagesByTransactionIdResponse$inboundSchema` instead. */
  export const inboundSchema = MessagesControllerDeleteMessagesByTransactionIdResponse$inboundSchema;
  /** @deprecated use `MessagesControllerDeleteMessagesByTransactionIdResponse$outboundSchema` instead. */
  export const outboundSchema = MessagesControllerDeleteMessagesByTransactionIdResponse$outboundSchema;
  /** @deprecated use `MessagesControllerDeleteMessagesByTransactionIdResponse$Outbound` instead. */
  export type Outbound = MessagesControllerDeleteMessagesByTransactionIdResponse$Outbound;
}

export function messagesControllerDeleteMessagesByTransactionIdResponseToJSON(
  messagesControllerDeleteMessagesByTransactionIdResponse: MessagesControllerDeleteMessagesByTransactionIdResponse
): string {
  return JSON.stringify(
    MessagesControllerDeleteMessagesByTransactionIdResponse$outboundSchema.parse(
      messagesControllerDeleteMessagesByTransactionIdResponse
    )
  );
}

export function messagesControllerDeleteMessagesByTransactionIdResponseFromJSON(
  jsonString: string
): SafeParseResult<MessagesControllerDeleteMessagesByTransactionIdResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesControllerDeleteMessagesByTransactionIdResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesControllerDeleteMessagesByTransactionIdResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messagesControllerDeleteMessagesByTransactionIdRequestToJSON(messagesControllerDeleteMessagesByTransactionIdRequest: MessagesControllerDeleteMessagesByTransactionIdRequest)
 - messagesControllerDeleteMessagesByTransactionIdRequestFromJSON(jsonString: string)
 - messagesControllerDeleteMessagesByTransactionIdResponseToJSON(messagesControllerDeleteMessagesByTransactionIdResponse: MessagesControllerDeleteMessagesByTransactionIdResponse)
 - messagesControllerDeleteMessagesByTransactionIdResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MessagesControllerDeleteMessagesByTransactionIdRequest$Outbound;
}

export function messagesControll...)
 - Outbound(MessagesControllerDeleteMessagesByTransactionIdResponse$Outbound;
}

export function messagesControl...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messagesControllerDeleteMessagesByTransactionIdRequestToJSON
- export function messagesControllerDeleteMessagesByTransactionIdRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messagesControllerDeleteMessagesByTransactionIdResponseToJSON
- export function messagesControllerDeleteMessagesByTransactionIdResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/messagescontrollergetmessages.ts
Tamaño: 6355 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type MessagesControllerGetMessagesRequest = {
  /**
   * Channel type through which the message is sent
   */
  channel?: components.ChannelTypeEnum | undefined;
  subscriberId?: string | undefined;
  transactionId?: Array<string> | undefined;
  /**
   * Filter by exact context keys (format: "type:id")
   */
  contextKeys?: Array<string> | undefined;
  page?: number | undefined;
  limit?: number | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type MessagesControllerGetMessagesResponse = {
  headers: { [k: string]: Array<string> };
  result: components.MessagesResponseDto;
};

/** @internal */
export const MessagesControllerGetMessagesRequest$inboundSchema: z.ZodType<
  MessagesControllerGetMessagesRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    channel: components.ChannelTypeEnum$inboundSchema.optional(),
    subscriberId: z.string().optional(),
    transactionId: z.array(z.string()).optional(),
    contextKeys: z.array(z.string()).optional(),
    page: z.number().default(0),
    limit: z.number().default(10),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type MessagesControllerGetMessagesRequest$Outbound = {
  channel?: string | undefined;
  subscriberId?: string | undefined;
  transactionId?: Array<string> | undefined;
  contextKeys?: Array<string> | undefined;
  page: number;
  limit: number;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const MessagesControllerGetMessagesRequest$outboundSchema: z.ZodType<
  MessagesControllerGetMessagesRequest$Outbound,
  z.ZodTypeDef,
  MessagesControllerGetMessagesRequest
> = z
  .object({
    channel: components.ChannelTypeEnum$outboundSchema.optional(),
    subscriberId: z.string().optional(),
    transactionId: z.array(z.string()).optional(),
    contextKeys: z.array(z.string()).optional(),
    page: z.number().default(0),
    limit: z.number().default(10),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessagesControllerGetMessagesRequest$ {
  /** @deprecated use `MessagesControllerGetMessagesRequest$inboundSchema` instead. */
  export const inboundSchema = MessagesControllerGetMessagesRequest$inboundSchema;
  /** @deprecated use `MessagesControllerGetMessagesRequest$outboundSchema` instead. */
  export const outboundSchema = MessagesControllerGetMessagesRequest$outboundSchema;
  /** @deprecated use `MessagesControllerGetMessagesRequest$Outbound` instead. */
  export type Outbound = MessagesControllerGetMessagesRequest$Outbound;
}

export function messagesControllerGetMessagesRequestToJSON(
  messagesControllerGetMessagesRequest: MessagesControllerGetMessagesRequest
): string {
  return JSON.stringify(
    MessagesControllerGetMessagesRequest$outboundSchema.parse(messagesControllerGetMessagesRequest)
  );
}

export function messagesControllerGetMessagesRequestFromJSON(
  jsonString: string
): SafeParseResult<MessagesControllerGetMessagesRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesControllerGetMessagesRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesControllerGetMessagesRequest' from JSON`
  );
}

/** @internal */
export const MessagesControllerGetMessagesResponse$inboundSchema: z.ZodType<
  MessagesControllerGetMessagesResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.MessagesResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type MessagesControllerGetMessagesResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.MessagesResponseDto$Outbound;
};

/** @internal */
export const MessagesControllerGetMessagesResponse$outboundSchema: z.ZodType<
  MessagesControllerGetMessagesResponse$Outbound,
  z.ZodTypeDef,
  MessagesControllerGetMessagesResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.MessagesResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessagesControllerGetMessagesResponse$ {
  /** @deprecated use `MessagesControllerGetMessagesResponse$inboundSchema` instead. */
  export const inboundSchema = MessagesControllerGetMessagesResponse$inboundSchema;
  /** @deprecated use `MessagesControllerGetMessagesResponse$outboundSchema` instead. */
  export const outboundSchema = MessagesControllerGetMessagesResponse$outboundSchema;
  /** @deprecated use `MessagesControllerGetMessagesResponse$Outbound` instead. */
  export type Outbound = MessagesControllerGetMessagesResponse$Outbound;
}

export function messagesControllerGetMessagesResponseToJSON(
  messagesControllerGetMessagesResponse: MessagesControllerGetMessagesResponse
): string {
  return JSON.stringify(
    MessagesControllerGetMessagesResponse$outboundSchema.parse(messagesControllerGetMessagesResponse)
  );
}

export function messagesControllerGetMessagesResponseFromJSON(
  jsonString: string
): SafeParseResult<MessagesControllerGetMessagesResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesControllerGetMessagesResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesControllerGetMessagesResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messagesControllerGetMessagesRequestToJSON(messagesControllerGetMessagesRequest: MessagesControllerGetMessagesRequest)
 - messagesControllerGetMessagesRequestFromJSON(jsonString: string)
 - messagesControllerGetMessagesResponseToJSON(messagesControllerGetMessagesResponse: MessagesControllerGetMessagesResponse)
 - messagesControllerGetMessagesResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(MessagesControllerGetMessagesRequest$Outbound;
}

export function messagesControllerGetMessagesReque...)
 - Outbound(MessagesControllerGetMessagesResponse$Outbound;
}

export function messagesControllerGetMessagesResp...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messagesControllerGetMessagesRequestToJSON
- export function messagesControllerGetMessagesRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function messagesControllerGetMessagesResponseToJSON
- export function messagesControllerGetMessagesResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/notificationscontrollergetnotification.ts
Tamaño: 5826 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type NotificationsControllerGetNotificationRequest = {
  notificationId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type NotificationsControllerGetNotificationResponse = {
  headers: { [k: string]: Array<string> };
  result: components.ActivityNotificationResponseDto;
};

/** @internal */
export const NotificationsControllerGetNotificationRequest$inboundSchema: z.ZodType<
  NotificationsControllerGetNotificationRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    notificationId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type NotificationsControllerGetNotificationRequest$Outbound = {
  notificationId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const NotificationsControllerGetNotificationRequest$outboundSchema: z.ZodType<
  NotificationsControllerGetNotificationRequest$Outbound,
  z.ZodTypeDef,
  NotificationsControllerGetNotificationRequest
> = z
  .object({
    notificationId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotificationsControllerGetNotificationRequest$ {
  /** @deprecated use `NotificationsControllerGetNotificationRequest$inboundSchema` instead. */
  export const inboundSchema = NotificationsControllerGetNotificationRequest$inboundSchema;
  /** @deprecated use `NotificationsControllerGetNotificationRequest$outboundSchema` instead. */
  export const outboundSchema = NotificationsControllerGetNotificationRequest$outboundSchema;
  /** @deprecated use `NotificationsControllerGetNotificationRequest$Outbound` instead. */
  export type Outbound = NotificationsControllerGetNotificationRequest$Outbound;
}

export function notificationsControllerGetNotificationRequestToJSON(
  notificationsControllerGetNotificationRequest: NotificationsControllerGetNotificationRequest
): string {
  return JSON.stringify(
    NotificationsControllerGetNotificationRequest$outboundSchema.parse(notificationsControllerGetNotificationRequest)
  );
}

export function notificationsControllerGetNotificationRequestFromJSON(
  jsonString: string
): SafeParseResult<NotificationsControllerGetNotificationRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotificationsControllerGetNotificationRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotificationsControllerGetNotificationRequest' from JSON`
  );
}

/** @internal */
export const NotificationsControllerGetNotificationResponse$inboundSchema: z.ZodType<
  NotificationsControllerGetNotificationResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.ActivityNotificationResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type NotificationsControllerGetNotificationResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.ActivityNotificationResponseDto$Outbound;
};

/** @internal */
export const NotificationsControllerGetNotificationResponse$outboundSchema: z.ZodType<
  NotificationsControllerGetNotificationResponse$Outbound,
  z.ZodTypeDef,
  NotificationsControllerGetNotificationResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.ActivityNotificationResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotificationsControllerGetNotificationResponse$ {
  /** @deprecated use `NotificationsControllerGetNotificationResponse$inboundSchema` instead. */
  export const inboundSchema = NotificationsControllerGetNotificationResponse$inboundSchema;
  /** @deprecated use `NotificationsControllerGetNotificationResponse$outboundSchema` instead. */
  export const outboundSchema = NotificationsControllerGetNotificationResponse$outboundSchema;
  /** @deprecated use `NotificationsControllerGetNotificationResponse$Outbound` instead. */
  export type Outbound = NotificationsControllerGetNotificationResponse$Outbound;
}

export function notificationsControllerGetNotificationResponseToJSON(
  notificationsControllerGetNotificationResponse: NotificationsControllerGetNotificationResponse
): string {
  return JSON.stringify(
    NotificationsControllerGetNotificationResponse$outboundSchema.parse(notificationsControllerGetNotificationResponse)
  );
}

export function notificationsControllerGetNotificationResponseFromJSON(
  jsonString: string
): SafeParseResult<NotificationsControllerGetNotificationResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotificationsControllerGetNotificationResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotificationsControllerGetNotificationResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - notificationsControllerGetNotificationRequestToJSON(notificationsControllerGetNotificationRequest: NotificationsControllerGetNotificationRequest)
 - notificationsControllerGetNotificationRequestFromJSON(jsonString: string)
 - notificationsControllerGetNotificationResponseToJSON(notificationsControllerGetNotificationResponse: NotificationsControllerGetNotificationResponse)
 - notificationsControllerGetNotificationResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(NotificationsControllerGetNotificationRequest$Outbound;
}

export function notificationsControllerGe...)
 - Outbound(NotificationsControllerGetNotificationResponse$Outbound;
}

export function notificationsControllerG...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function notificationsControllerGetNotificationRequestToJSON
- export function notificationsControllerGetNotificationRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function notificationsControllerGetNotificationResponseToJSON
- export function notificationsControllerGetNotificationResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/notificationscontrollerlistnotifications.ts
Tamaño: 8801 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type NotificationsControllerListNotificationsRequest = {
  /**
   * Array of channel types
   */
  channels?: Array<components.ChannelTypeEnum> | undefined;
  /**
   * Array of template IDs or a single template ID
   */
  templates?: Array<string> | undefined;
  /**
   * Array of email addresses or a single email address
   */
  emails?: Array<string> | undefined;
  /**
   * Search term (deprecated)
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  search?: string | undefined;
  /**
   * Array of subscriber IDs or a single subscriber ID
   */
  subscriberIds?: Array<string> | undefined;
  /**
   * Array of severity levels or a single severity level
   */
  severity?: Array<string> | undefined;
  /**
   * Page number for pagination
   */
  page?: number | undefined;
  /**
   * Limit for pagination
   */
  limit?: number | undefined;
  /**
   * The transaction ID to filter by
   */
  transactionId?: string | undefined;
  /**
   * Topic Key for filtering notifications by topic
   */
  topicKey?: string | undefined;
  /**
   * Filter by exact context keys (format: "type:id")
   */
  contextKeys?: Array<string> | undefined;
  /**
   * Date filter for records after this timestamp. Defaults to earliest date allowed by subscription plan
   */
  after?: string | undefined;
  /**
   * Date filter for records before this timestamp. Defaults to current time of request (now)
   */
  before?: string | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type NotificationsControllerListNotificationsResponse = {
  headers: { [k: string]: Array<string> };
  result: components.ActivitiesResponseDto;
};

/** @internal */
export const NotificationsControllerListNotificationsRequest$inboundSchema: z.ZodType<
  NotificationsControllerListNotificationsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    channels: z.array(components.ChannelTypeEnum$inboundSchema).optional(),
    templates: z.array(z.string()).optional(),
    emails: z.array(z.string()).optional(),
    search: z.string().optional(),
    subscriberIds: z.array(z.string()).optional(),
    severity: z.array(z.string()).optional(),
    page: z.number().default(0),
    limit: z.number().default(10),
    transactionId: z.string().optional(),
    topicKey: z.string().optional(),
    contextKeys: z.array(z.string()).optional(),
    after: z.string().optional(),
    before: z.string().optional(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type NotificationsControllerListNotificationsRequest$Outbound = {
  channels?: Array<string> | undefined;
  templates?: Array<string> | undefined;
  emails?: Array<string> | undefined;
  search?: string | undefined;
  subscriberIds?: Array<string> | undefined;
  severity?: Array<string> | undefined;
  page: number;
  limit: number;
  transactionId?: string | undefined;
  topicKey?: string | undefined;
  contextKeys?: Array<string> | undefined;
  after?: string | undefined;
  before?: string | undefined;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const NotificationsControllerListNotificationsRequest$outboundSchema: z.ZodType<
  NotificationsControllerListNotificationsRequest$Outbound,
  z.ZodTypeDef,
  NotificationsControllerListNotificationsRequest
> = z
  .object({
    channels: z.array(components.ChannelTypeEnum$outboundSchema).optional(),
    templates: z.array(z.string()).optional(),
    emails: z.array(z.string()).optional(),
    search: z.string().optional(),
    subscriberIds: z.array(z.string()).optional(),
    severity: z.array(z.string()).optional(),
    page: z.number().default(0),
    limit: z.number().default(10),
    transactionId: z.string().optional(),
    topicKey: z.string().optional(),
    contextKeys: z.array(z.string()).optional(),
    after: z.string().optional(),
    before: z.string().optional(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotificationsControllerListNotificationsRequest$ {
  /** @deprecated use `NotificationsControllerListNotificationsRequest$inboundSchema` instead. */
  export const inboundSchema = NotificationsControllerListNotificationsRequest$inboundSchema;
  /** @deprecated use `NotificationsControllerListNotificationsRequest$outboundSchema` instead. */
  export const outboundSchema = NotificationsControllerListNotificationsRequest$outboundSchema;
  /** @deprecated use `NotificationsControllerListNotificationsRequest$Outbound` instead. */
  export type Outbound = NotificationsControllerListNotificationsRequest$Outbound;
}

export function notificationsControllerListNotificationsRequestToJSON(
  notificationsControllerListNotificationsRequest: NotificationsControllerListNotificationsRequest
): string {
  return JSON.stringify(
    NotificationsControllerListNotificationsRequest$outboundSchema.parse(
      notificationsControllerListNotificationsRequest
    )
  );
}

export function notificationsControllerListNotificationsRequestFromJSON(
  jsonString: string
): SafeParseResult<NotificationsControllerListNotificationsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotificationsControllerListNotificationsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotificationsControllerListNotificationsRequest' from JSON`
  );
}

/** @internal */
export const NotificationsControllerListNotificationsResponse$inboundSchema: z.ZodType<
  NotificationsControllerListNotificationsResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.ActivitiesResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type NotificationsControllerListNotificationsResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.ActivitiesResponseDto$Outbound;
};

/** @internal */
export const NotificationsControllerListNotificationsResponse$outboundSchema: z.ZodType<
  NotificationsControllerListNotificationsResponse$Outbound,
  z.ZodTypeDef,
  NotificationsControllerListNotificationsResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.ActivitiesResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotificationsControllerListNotificationsResponse$ {
  /** @deprecated use `NotificationsControllerListNotificationsResponse$inboundSchema` instead. */
  export const inboundSchema = NotificationsControllerListNotificationsResponse$inboundSchema;
  /** @deprecated use `NotificationsControllerListNotificationsResponse$outboundSchema` instead. */
  export const outboundSchema = NotificationsControllerListNotificationsResponse$outboundSchema;
  /** @deprecated use `NotificationsControllerListNotificationsResponse$Outbound` instead. */
  export type Outbound = NotificationsControllerListNotificationsResponse$Outbound;
}

export function notificationsControllerListNotificationsResponseToJSON(
  notificationsControllerListNotificationsResponse: NotificationsControllerListNotificationsResponse
): string {
  return JSON.stringify(
    NotificationsControllerListNotificationsResponse$outboundSchema.parse(
      notificationsControllerListNotificationsResponse
    )
  );
}

export function notificationsControllerListNotificationsResponseFromJSON(
  jsonString: string
): SafeParseResult<NotificationsControllerListNotificationsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NotificationsControllerListNotificationsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NotificationsControllerListNotificationsResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - notificationsControllerListNotificationsRequestToJSON(notificationsControllerListNotificationsRequest: NotificationsControllerListNotificationsRequest)
 - notificationsControllerListNotificationsRequestFromJSON(jsonString: string)
 - notificationsControllerListNotificationsResponseToJSON(notificationsControllerListNotificationsResponse: NotificationsControllerListNotificationsResponse)
 - notificationsControllerListNotificationsResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(NotificationsControllerListNotificationsRequest$Outbound;
}

export function notificationsController...)
 - Outbound(NotificationsControllerListNotificationsResponse$Outbound;
}

export function notificationsControlle...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function notificationsControllerListNotificationsRequestToJSON
- export function notificationsControllerListNotificationsRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function notificationsControllerListNotificationsResponseToJSON
- export function notificationsControllerListNotificationsResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscriberscontrollerbulkupdatesubscriberpreferences.ts
Tamaño: 7036 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscribersControllerBulkUpdateSubscriberPreferencesRequest = {
  subscriberId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  bulkUpdateSubscriberPreferencesDto: components.BulkUpdateSubscriberPreferencesDto;
};

export type SubscribersControllerBulkUpdateSubscriberPreferencesResponse = {
  headers: { [k: string]: Array<string> };
  result: Array<components.GetPreferencesResponseDto>;
};

/** @internal */
export const SubscribersControllerBulkUpdateSubscriberPreferencesRequest$inboundSchema: z.ZodType<
  SubscribersControllerBulkUpdateSubscriberPreferencesRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    subscriberId: z.string(),
    'idempotency-key': z.string().optional(),
    BulkUpdateSubscriberPreferencesDto: components.BulkUpdateSubscriberPreferencesDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      BulkUpdateSubscriberPreferencesDto: 'bulkUpdateSubscriberPreferencesDto',
    });
  });

/** @internal */
export type SubscribersControllerBulkUpdateSubscriberPreferencesRequest$Outbound = {
  subscriberId: string;
  'idempotency-key'?: string | undefined;
  BulkUpdateSubscriberPreferencesDto: components.BulkUpdateSubscriberPreferencesDto$Outbound;
};

/** @internal */
export const SubscribersControllerBulkUpdateSubscriberPreferencesRequest$outboundSchema: z.ZodType<
  SubscribersControllerBulkUpdateSubscriberPreferencesRequest$Outbound,
  z.ZodTypeDef,
  SubscribersControllerBulkUpdateSubscriberPreferencesRequest
> = z
  .object({
    subscriberId: z.string(),
    idempotencyKey: z.string().optional(),
    bulkUpdateSubscriberPreferencesDto: components.BulkUpdateSubscriberPreferencesDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      bulkUpdateSubscriberPreferencesDto: 'BulkUpdateSubscriberPreferencesDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerBulkUpdateSubscriberPreferencesRequest$ {
  /** @deprecated use `SubscribersControllerBulkUpdateSubscriberPreferencesRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerBulkUpdateSubscriberPreferencesRequest$inboundSchema;
  /** @deprecated use `SubscribersControllerBulkUpdateSubscriberPreferencesRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerBulkUpdateSubscriberPreferencesRequest$outboundSchema;
  /** @deprecated use `SubscribersControllerBulkUpdateSubscriberPreferencesRequest$Outbound` instead. */
  export type Outbound = SubscribersControllerBulkUpdateSubscriberPreferencesRequest$Outbound;
}

export function subscribersControllerBulkUpdateSubscriberPreferencesRequestToJSON(
  subscribersControllerBulkUpdateSubscriberPreferencesRequest: SubscribersControllerBulkUpdateSubscriberPreferencesRequest
): string {
  return JSON.stringify(
    SubscribersControllerBulkUpdateSubscriberPreferencesRequest$outboundSchema.parse(
      subscribersControllerBulkUpdateSubscriberPreferencesRequest
    )
  );
}

export function subscribersControllerBulkUpdateSubscriberPreferencesRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerBulkUpdateSubscriberPreferencesRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerBulkUpdateSubscriberPreferencesRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerBulkUpdateSubscriberPreferencesRequest' from JSON`
  );
}

/** @internal */
export const SubscribersControllerBulkUpdateSubscriberPreferencesResponse$inboundSchema: z.ZodType<
  SubscribersControllerBulkUpdateSubscriberPreferencesResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: z.array(components.GetPreferencesResponseDto$inboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersControllerBulkUpdateSubscriberPreferencesResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: Array<components.GetPreferencesResponseDto$Outbound>;
};

/** @internal */
export const SubscribersControllerBulkUpdateSubscriberPreferencesResponse$outboundSchema: z.ZodType<
  SubscribersControllerBulkUpdateSubscriberPreferencesResponse$Outbound,
  z.ZodTypeDef,
  SubscribersControllerBulkUpdateSubscriberPreferencesResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: z.array(components.GetPreferencesResponseDto$outboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerBulkUpdateSubscriberPreferencesResponse$ {
  /** @deprecated use `SubscribersControllerBulkUpdateSubscriberPreferencesResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerBulkUpdateSubscriberPreferencesResponse$inboundSchema;
  /** @deprecated use `SubscribersControllerBulkUpdateSubscriberPreferencesResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerBulkUpdateSubscriberPreferencesResponse$outboundSchema;
  /** @deprecated use `SubscribersControllerBulkUpdateSubscriberPreferencesResponse$Outbound` instead. */
  export type Outbound = SubscribersControllerBulkUpdateSubscriberPreferencesResponse$Outbound;
}

export function subscribersControllerBulkUpdateSubscriberPreferencesResponseToJSON(
  subscribersControllerBulkUpdateSubscriberPreferencesResponse: SubscribersControllerBulkUpdateSubscriberPreferencesResponse
): string {
  return JSON.stringify(
    SubscribersControllerBulkUpdateSubscriberPreferencesResponse$outboundSchema.parse(
      subscribersControllerBulkUpdateSubscriberPreferencesResponse
    )
  );
}

export function subscribersControllerBulkUpdateSubscriberPreferencesResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerBulkUpdateSubscriberPreferencesResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerBulkUpdateSubscriberPreferencesResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerBulkUpdateSubscriberPreferencesResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersControllerBulkUpdateSubscriberPreferencesRequestToJSON(subscribersControllerBulkUpdateSubscriberPreferencesRequest: SubscribersControllerBulkUpdateSubscriberPreferencesRequest)
 - subscribersControllerBulkUpdateSubscriberPreferencesRequestFromJSON(jsonString: string)
 - subscribersControllerBulkUpdateSubscriberPreferencesResponseToJSON(subscribersControllerBulkUpdateSubscriberPreferencesResponse: SubscribersControllerBulkUpdateSubscriberPreferencesResponse)
 - subscribersControllerBulkUpdateSubscriberPreferencesResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersControllerBulkUpdateSubscriberPreferencesRequest$Outbound;
}

export function subscribers...)
 - Outbound(SubscribersControllerBulkUpdateSubscriberPreferencesResponse$Outbound;
}

export function subscriber...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerBulkUpdateSubscriberPreferencesRequestToJSON
- export function subscribersControllerBulkUpdateSubscriberPreferencesRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerBulkUpdateSubscriberPreferencesResponseToJSON
- export function subscribersControllerBulkUpdateSubscriberPreferencesResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscriberscontrollercreatesubscriber.ts
Tamaño: 6336 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscribersControllerCreateSubscriberRequest = {
  /**
   * If true, the request will fail if a subscriber with the same subscriberId already exists
   */
  failIfExists?: boolean | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  createSubscriberRequestDto: components.CreateSubscriberRequestDto;
};

export type SubscribersControllerCreateSubscriberResponse = {
  headers: { [k: string]: Array<string> };
  result: components.SubscriberResponseDto;
};

/** @internal */
export const SubscribersControllerCreateSubscriberRequest$inboundSchema: z.ZodType<
  SubscribersControllerCreateSubscriberRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    failIfExists: z.boolean().optional(),
    'idempotency-key': z.string().optional(),
    CreateSubscriberRequestDto: components.CreateSubscriberRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      CreateSubscriberRequestDto: 'createSubscriberRequestDto',
    });
  });

/** @internal */
export type SubscribersControllerCreateSubscriberRequest$Outbound = {
  failIfExists?: boolean | undefined;
  'idempotency-key'?: string | undefined;
  CreateSubscriberRequestDto: components.CreateSubscriberRequestDto$Outbound;
};

/** @internal */
export const SubscribersControllerCreateSubscriberRequest$outboundSchema: z.ZodType<
  SubscribersControllerCreateSubscriberRequest$Outbound,
  z.ZodTypeDef,
  SubscribersControllerCreateSubscriberRequest
> = z
  .object({
    failIfExists: z.boolean().optional(),
    idempotencyKey: z.string().optional(),
    createSubscriberRequestDto: components.CreateSubscriberRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      createSubscriberRequestDto: 'CreateSubscriberRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerCreateSubscriberRequest$ {
  /** @deprecated use `SubscribersControllerCreateSubscriberRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerCreateSubscriberRequest$inboundSchema;
  /** @deprecated use `SubscribersControllerCreateSubscriberRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerCreateSubscriberRequest$outboundSchema;
  /** @deprecated use `SubscribersControllerCreateSubscriberRequest$Outbound` instead. */
  export type Outbound = SubscribersControllerCreateSubscriberRequest$Outbound;
}

export function subscribersControllerCreateSubscriberRequestToJSON(
  subscribersControllerCreateSubscriberRequest: SubscribersControllerCreateSubscriberRequest
): string {
  return JSON.stringify(
    SubscribersControllerCreateSubscriberRequest$outboundSchema.parse(subscribersControllerCreateSubscriberRequest)
  );
}

export function subscribersControllerCreateSubscriberRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerCreateSubscriberRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerCreateSubscriberRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerCreateSubscriberRequest' from JSON`
  );
}

/** @internal */
export const SubscribersControllerCreateSubscriberResponse$inboundSchema: z.ZodType<
  SubscribersControllerCreateSubscriberResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.SubscriberResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersControllerCreateSubscriberResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.SubscriberResponseDto$Outbound;
};

/** @internal */
export const SubscribersControllerCreateSubscriberResponse$outboundSchema: z.ZodType<
  SubscribersControllerCreateSubscriberResponse$Outbound,
  z.ZodTypeDef,
  SubscribersControllerCreateSubscriberResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.SubscriberResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerCreateSubscriberResponse$ {
  /** @deprecated use `SubscribersControllerCreateSubscriberResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerCreateSubscriberResponse$inboundSchema;
  /** @deprecated use `SubscribersControllerCreateSubscriberResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerCreateSubscriberResponse$outboundSchema;
  /** @deprecated use `SubscribersControllerCreateSubscriberResponse$Outbound` instead. */
  export type Outbound = SubscribersControllerCreateSubscriberResponse$Outbound;
}

export function subscribersControllerCreateSubscriberResponseToJSON(
  subscribersControllerCreateSubscriberResponse: SubscribersControllerCreateSubscriberResponse
): string {
  return JSON.stringify(
    SubscribersControllerCreateSubscriberResponse$outboundSchema.parse(subscribersControllerCreateSubscriberResponse)
  );
}

export function subscribersControllerCreateSubscriberResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerCreateSubscriberResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerCreateSubscriberResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerCreateSubscriberResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersControllerCreateSubscriberRequestToJSON(subscribersControllerCreateSubscriberRequest: SubscribersControllerCreateSubscriberRequest)
 - subscribersControllerCreateSubscriberRequestFromJSON(jsonString: string)
 - subscribersControllerCreateSubscriberResponseToJSON(subscribersControllerCreateSubscriberResponse: SubscribersControllerCreateSubscriberResponse)
 - subscribersControllerCreateSubscriberResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersControllerCreateSubscriberRequest$Outbound;
}

export function subscribersControllerCreat...)
 - Outbound(SubscribersControllerCreateSubscriberResponse$Outbound;
}

export function subscribersControllerCrea...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerCreateSubscriberRequestToJSON
- export function subscribersControllerCreateSubscriberRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerCreateSubscriberResponseToJSON
- export function subscribersControllerCreateSubscriberResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscriberscontrollergetsubscriber.ts
Tamaño: 5594 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscribersControllerGetSubscriberRequest = {
  subscriberId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type SubscribersControllerGetSubscriberResponse = {
  headers: { [k: string]: Array<string> };
  result: components.SubscriberResponseDto;
};

/** @internal */
export const SubscribersControllerGetSubscriberRequest$inboundSchema: z.ZodType<
  SubscribersControllerGetSubscriberRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    subscriberId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type SubscribersControllerGetSubscriberRequest$Outbound = {
  subscriberId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const SubscribersControllerGetSubscriberRequest$outboundSchema: z.ZodType<
  SubscribersControllerGetSubscriberRequest$Outbound,
  z.ZodTypeDef,
  SubscribersControllerGetSubscriberRequest
> = z
  .object({
    subscriberId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerGetSubscriberRequest$ {
  /** @deprecated use `SubscribersControllerGetSubscriberRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerGetSubscriberRequest$inboundSchema;
  /** @deprecated use `SubscribersControllerGetSubscriberRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerGetSubscriberRequest$outboundSchema;
  /** @deprecated use `SubscribersControllerGetSubscriberRequest$Outbound` instead. */
  export type Outbound = SubscribersControllerGetSubscriberRequest$Outbound;
}

export function subscribersControllerGetSubscriberRequestToJSON(
  subscribersControllerGetSubscriberRequest: SubscribersControllerGetSubscriberRequest
): string {
  return JSON.stringify(
    SubscribersControllerGetSubscriberRequest$outboundSchema.parse(subscribersControllerGetSubscriberRequest)
  );
}

export function subscribersControllerGetSubscriberRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerGetSubscriberRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerGetSubscriberRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerGetSubscriberRequest' from JSON`
  );
}

/** @internal */
export const SubscribersControllerGetSubscriberResponse$inboundSchema: z.ZodType<
  SubscribersControllerGetSubscriberResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.SubscriberResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersControllerGetSubscriberResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.SubscriberResponseDto$Outbound;
};

/** @internal */
export const SubscribersControllerGetSubscriberResponse$outboundSchema: z.ZodType<
  SubscribersControllerGetSubscriberResponse$Outbound,
  z.ZodTypeDef,
  SubscribersControllerGetSubscriberResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.SubscriberResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerGetSubscriberResponse$ {
  /** @deprecated use `SubscribersControllerGetSubscriberResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerGetSubscriberResponse$inboundSchema;
  /** @deprecated use `SubscribersControllerGetSubscriberResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerGetSubscriberResponse$outboundSchema;
  /** @deprecated use `SubscribersControllerGetSubscriberResponse$Outbound` instead. */
  export type Outbound = SubscribersControllerGetSubscriberResponse$Outbound;
}

export function subscribersControllerGetSubscriberResponseToJSON(
  subscribersControllerGetSubscriberResponse: SubscribersControllerGetSubscriberResponse
): string {
  return JSON.stringify(
    SubscribersControllerGetSubscriberResponse$outboundSchema.parse(subscribersControllerGetSubscriberResponse)
  );
}

export function subscribersControllerGetSubscriberResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerGetSubscriberResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerGetSubscriberResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerGetSubscriberResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersControllerGetSubscriberRequestToJSON(subscribersControllerGetSubscriberRequest: SubscribersControllerGetSubscriberRequest)
 - subscribersControllerGetSubscriberRequestFromJSON(jsonString: string)
 - subscribersControllerGetSubscriberResponseToJSON(subscribersControllerGetSubscriberResponse: SubscribersControllerGetSubscriberResponse)
 - subscribersControllerGetSubscriberResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersControllerGetSubscriberRequest$Outbound;
}

export function subscribersControllerGetSubsc...)
 - Outbound(SubscribersControllerGetSubscriberResponse$Outbound;
}

export function subscribersControllerGetSubs...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerGetSubscriberRequestToJSON
- export function subscribersControllerGetSubscriberRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerGetSubscriberResponseToJSON
- export function subscribersControllerGetSubscriberResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscriberscontrollergetsubscriberpreferences.ts
Tamaño: 7245 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export const Criticality = {
  Critical: 'critical',
  NonCritical: 'nonCritical',
  All: 'all',
} as const;
export type Criticality = ClosedEnum<typeof Criticality>;

export type SubscribersControllerGetSubscriberPreferencesRequest = {
  subscriberId: string;
  criticality?: Criticality | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type SubscribersControllerGetSubscriberPreferencesResponse = {
  headers: { [k: string]: Array<string> };
  result: components.GetSubscriberPreferencesDto;
};

/** @internal */
export const Criticality$inboundSchema: z.ZodNativeEnum<typeof Criticality> = z.nativeEnum(Criticality);

/** @internal */
export const Criticality$outboundSchema: z.ZodNativeEnum<typeof Criticality> = Criticality$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Criticality$ {
  /** @deprecated use `Criticality$inboundSchema` instead. */
  export const inboundSchema = Criticality$inboundSchema;
  /** @deprecated use `Criticality$outboundSchema` instead. */
  export const outboundSchema = Criticality$outboundSchema;
}

/** @internal */
export const SubscribersControllerGetSubscriberPreferencesRequest$inboundSchema: z.ZodType<
  SubscribersControllerGetSubscriberPreferencesRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    subscriberId: z.string(),
    criticality: Criticality$inboundSchema.default('nonCritical'),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type SubscribersControllerGetSubscriberPreferencesRequest$Outbound = {
  subscriberId: string;
  criticality: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const SubscribersControllerGetSubscriberPreferencesRequest$outboundSchema: z.ZodType<
  SubscribersControllerGetSubscriberPreferencesRequest$Outbound,
  z.ZodTypeDef,
  SubscribersControllerGetSubscriberPreferencesRequest
> = z
  .object({
    subscriberId: z.string(),
    criticality: Criticality$outboundSchema.default('nonCritical'),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerGetSubscriberPreferencesRequest$ {
  /** @deprecated use `SubscribersControllerGetSubscriberPreferencesRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerGetSubscriberPreferencesRequest$inboundSchema;
  /** @deprecated use `SubscribersControllerGetSubscriberPreferencesRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerGetSubscriberPreferencesRequest$outboundSchema;
  /** @deprecated use `SubscribersControllerGetSubscriberPreferencesRequest$Outbound` instead. */
  export type Outbound = SubscribersControllerGetSubscriberPreferencesRequest$Outbound;
}

export function subscribersControllerGetSubscriberPreferencesRequestToJSON(
  subscribersControllerGetSubscriberPreferencesRequest: SubscribersControllerGetSubscriberPreferencesRequest
): string {
  return JSON.stringify(
    SubscribersControllerGetSubscriberPreferencesRequest$outboundSchema.parse(
      subscribersControllerGetSubscriberPreferencesRequest
    )
  );
}

export function subscribersControllerGetSubscriberPreferencesRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerGetSubscriberPreferencesRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerGetSubscriberPreferencesRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerGetSubscriberPreferencesRequest' from JSON`
  );
}

/** @internal */
export const SubscribersControllerGetSubscriberPreferencesResponse$inboundSchema: z.ZodType<
  SubscribersControllerGetSubscriberPreferencesResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.GetSubscriberPreferencesDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersControllerGetSubscriberPreferencesResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.GetSubscriberPreferencesDto$Outbound;
};

/** @internal */
export const SubscribersControllerGetSubscriberPreferencesResponse$outboundSchema: z.ZodType<
  SubscribersControllerGetSubscriberPreferencesResponse$Outbound,
  z.ZodTypeDef,
  SubscribersControllerGetSubscriberPreferencesResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.GetSubscriberPreferencesDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerGetSubscriberPreferencesResponse$ {
  /** @deprecated use `SubscribersControllerGetSubscriberPreferencesResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerGetSubscriberPreferencesResponse$inboundSchema;
  /** @deprecated use `SubscribersControllerGetSubscriberPreferencesResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerGetSubscriberPreferencesResponse$outboundSchema;
  /** @deprecated use `SubscribersControllerGetSubscriberPreferencesResponse$Outbound` instead. */
  export type Outbound = SubscribersControllerGetSubscriberPreferencesResponse$Outbound;
}

export function subscribersControllerGetSubscriberPreferencesResponseToJSON(
  subscribersControllerGetSubscriberPreferencesResponse: SubscribersControllerGetSubscriberPreferencesResponse
): string {
  return JSON.stringify(
    SubscribersControllerGetSubscriberPreferencesResponse$outboundSchema.parse(
      subscribersControllerGetSubscriberPreferencesResponse
    )
  );
}

export function subscribersControllerGetSubscriberPreferencesResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerGetSubscriberPreferencesResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerGetSubscriberPreferencesResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerGetSubscriberPreferencesResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersControllerGetSubscriberPreferencesRequestToJSON(subscribersControllerGetSubscriberPreferencesRequest: SubscribersControllerGetSubscriberPreferencesRequest)
 - subscribersControllerGetSubscriberPreferencesRequestFromJSON(jsonString: string)
 - subscribersControllerGetSubscriberPreferencesResponseToJSON(subscribersControllerGetSubscriberPreferencesResponse: SubscribersControllerGetSubscriberPreferencesResponse)
 - subscribersControllerGetSubscriberPreferencesResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersControllerGetSubscriberPreferencesRequest$Outbound;
}

export function subscribersControl...)
 - Outbound(SubscribersControllerGetSubscriberPreferencesResponse$Outbound;
}

export function subscribersContro...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerGetSubscriberPreferencesRequestToJSON
- export function subscribersControllerGetSubscriberPreferencesRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerGetSubscriberPreferencesResponseToJSON
- export function subscribersControllerGetSubscriberPreferencesResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscriberscontrollerlistsubscribertopics.ts
Tamaño: 9319 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Direction of sorting
 */
export const SubscribersControllerListSubscriberTopicsQueryParamOrderDirection = {
  Asc: 'ASC',
  Desc: 'DESC',
} as const;
/**
 * Direction of sorting
 */
export type SubscribersControllerListSubscriberTopicsQueryParamOrderDirection = ClosedEnum<
  typeof SubscribersControllerListSubscriberTopicsQueryParamOrderDirection
>;

export type SubscribersControllerListSubscriberTopicsRequest = {
  /**
   * The identifier of the subscriber
   */
  subscriberId: string;
  /**
   * Cursor for pagination indicating the starting point after which to fetch results.
   */
  after?: string | undefined;
  /**
   * Cursor for pagination indicating the ending point before which to fetch results.
   */
  before?: string | undefined;
  /**
   * Limit the number of items to return (max 100)
   */
  limit?: number | undefined;
  /**
   * Direction of sorting
   */
  orderDirection?: SubscribersControllerListSubscriberTopicsQueryParamOrderDirection | undefined;
  /**
   * Field to order by
   */
  orderBy?: string | undefined;
  /**
   * Include cursor item in response
   */
  includeCursor?: boolean | undefined;
  /**
   * Filter by topic key
   */
  key?: string | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type SubscribersControllerListSubscriberTopicsResponse = {
  headers: { [k: string]: Array<string> };
  result: components.ListTopicSubscriptionsResponseDto;
};

/** @internal */
export const SubscribersControllerListSubscriberTopicsQueryParamOrderDirection$inboundSchema: z.ZodNativeEnum<
  typeof SubscribersControllerListSubscriberTopicsQueryParamOrderDirection
> = z.nativeEnum(SubscribersControllerListSubscriberTopicsQueryParamOrderDirection);

/** @internal */
export const SubscribersControllerListSubscriberTopicsQueryParamOrderDirection$outboundSchema: z.ZodNativeEnum<
  typeof SubscribersControllerListSubscriberTopicsQueryParamOrderDirection
> = SubscribersControllerListSubscriberTopicsQueryParamOrderDirection$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerListSubscriberTopicsQueryParamOrderDirection$ {
  /** @deprecated use `SubscribersControllerListSubscriberTopicsQueryParamOrderDirection$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerListSubscriberTopicsQueryParamOrderDirection$inboundSchema;
  /** @deprecated use `SubscribersControllerListSubscriberTopicsQueryParamOrderDirection$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerListSubscriberTopicsQueryParamOrderDirection$outboundSchema;
}

/** @internal */
export const SubscribersControllerListSubscriberTopicsRequest$inboundSchema: z.ZodType<
  SubscribersControllerListSubscriberTopicsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    subscriberId: z.string(),
    after: z.string().optional(),
    before: z.string().optional(),
    limit: z.number().optional(),
    orderDirection: SubscribersControllerListSubscriberTopicsQueryParamOrderDirection$inboundSchema.optional(),
    orderBy: z.string().optional(),
    includeCursor: z.boolean().optional(),
    key: z.string().optional(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type SubscribersControllerListSubscriberTopicsRequest$Outbound = {
  subscriberId: string;
  after?: string | undefined;
  before?: string | undefined;
  limit?: number | undefined;
  orderDirection?: string | undefined;
  orderBy?: string | undefined;
  includeCursor?: boolean | undefined;
  key?: string | undefined;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const SubscribersControllerListSubscriberTopicsRequest$outboundSchema: z.ZodType<
  SubscribersControllerListSubscriberTopicsRequest$Outbound,
  z.ZodTypeDef,
  SubscribersControllerListSubscriberTopicsRequest
> = z
  .object({
    subscriberId: z.string(),
    after: z.string().optional(),
    before: z.string().optional(),
    limit: z.number().optional(),
    orderDirection: SubscribersControllerListSubscriberTopicsQueryParamOrderDirection$outboundSchema.optional(),
    orderBy: z.string().optional(),
    includeCursor: z.boolean().optional(),
    key: z.string().optional(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerListSubscriberTopicsRequest$ {
  /** @deprecated use `SubscribersControllerListSubscriberTopicsRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerListSubscriberTopicsRequest$inboundSchema;
  /** @deprecated use `SubscribersControllerListSubscriberTopicsRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerListSubscriberTopicsRequest$outboundSchema;
  /** @deprecated use `SubscribersControllerListSubscriberTopicsRequest$Outbound` instead. */
  export type Outbound = SubscribersControllerListSubscriberTopicsRequest$Outbound;
}

export function subscribersControllerListSubscriberTopicsRequestToJSON(
  subscribersControllerListSubscriberTopicsRequest: SubscribersControllerListSubscriberTopicsRequest
): string {
  return JSON.stringify(
    SubscribersControllerListSubscriberTopicsRequest$outboundSchema.parse(
      subscribersControllerListSubscriberTopicsRequest
    )
  );
}

export function subscribersControllerListSubscriberTopicsRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerListSubscriberTopicsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerListSubscriberTopicsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerListSubscriberTopicsRequest' from JSON`
  );
}

/** @internal */
export const SubscribersControllerListSubscriberTopicsResponse$inboundSchema: z.ZodType<
  SubscribersControllerListSubscriberTopicsResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.ListTopicSubscriptionsResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersControllerListSubscriberTopicsResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.ListTopicSubscriptionsResponseDto$Outbound;
};

/** @internal */
export const SubscribersControllerListSubscriberTopicsResponse$outboundSchema: z.ZodType<
  SubscribersControllerListSubscriberTopicsResponse$Outbound,
  z.ZodTypeDef,
  SubscribersControllerListSubscriberTopicsResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.ListTopicSubscriptionsResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerListSubscriberTopicsResponse$ {
  /** @deprecated use `SubscribersControllerListSubscriberTopicsResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerListSubscriberTopicsResponse$inboundSchema;
  /** @deprecated use `SubscribersControllerListSubscriberTopicsResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerListSubscriberTopicsResponse$outboundSchema;
  /** @deprecated use `SubscribersControllerListSubscriberTopicsResponse$Outbound` instead. */
  export type Outbound = SubscribersControllerListSubscriberTopicsResponse$Outbound;
}

export function subscribersControllerListSubscriberTopicsResponseToJSON(
  subscribersControllerListSubscriberTopicsResponse: SubscribersControllerListSubscriberTopicsResponse
): string {
  return JSON.stringify(
    SubscribersControllerListSubscriberTopicsResponse$outboundSchema.parse(
      subscribersControllerListSubscriberTopicsResponse
    )
  );
}

export function subscribersControllerListSubscriberTopicsResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerListSubscriberTopicsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerListSubscriberTopicsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerListSubscriberTopicsResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersControllerListSubscriberTopicsRequestToJSON(subscribersControllerListSubscriberTopicsRequest: SubscribersControllerListSubscriberTopicsRequest)
 - subscribersControllerListSubscriberTopicsRequestFromJSON(jsonString: string)
 - subscribersControllerListSubscriberTopicsResponseToJSON(subscribersControllerListSubscriberTopicsResponse: SubscribersControllerListSubscriberTopicsResponse)
 - subscribersControllerListSubscriberTopicsResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersControllerListSubscriberTopicsRequest$Outbound;
}

export function subscribersControllerL...)
 - Outbound(SubscribersControllerListSubscriberTopicsResponse$Outbound;
}

export function subscribersController...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerListSubscriberTopicsRequestToJSON
- export function subscribersControllerListSubscriberTopicsRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerListSubscriberTopicsResponseToJSON
- export function subscribersControllerListSubscriberTopicsResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscriberscontrollerpatchsubscriber.ts
Tamaño: 6120 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscribersControllerPatchSubscriberRequest = {
  subscriberId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  patchSubscriberRequestDto: components.PatchSubscriberRequestDto;
};

export type SubscribersControllerPatchSubscriberResponse = {
  headers: { [k: string]: Array<string> };
  result: components.SubscriberResponseDto;
};

/** @internal */
export const SubscribersControllerPatchSubscriberRequest$inboundSchema: z.ZodType<
  SubscribersControllerPatchSubscriberRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    subscriberId: z.string(),
    'idempotency-key': z.string().optional(),
    PatchSubscriberRequestDto: components.PatchSubscriberRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      PatchSubscriberRequestDto: 'patchSubscriberRequestDto',
    });
  });

/** @internal */
export type SubscribersControllerPatchSubscriberRequest$Outbound = {
  subscriberId: string;
  'idempotency-key'?: string | undefined;
  PatchSubscriberRequestDto: components.PatchSubscriberRequestDto$Outbound;
};

/** @internal */
export const SubscribersControllerPatchSubscriberRequest$outboundSchema: z.ZodType<
  SubscribersControllerPatchSubscriberRequest$Outbound,
  z.ZodTypeDef,
  SubscribersControllerPatchSubscriberRequest
> = z
  .object({
    subscriberId: z.string(),
    idempotencyKey: z.string().optional(),
    patchSubscriberRequestDto: components.PatchSubscriberRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      patchSubscriberRequestDto: 'PatchSubscriberRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerPatchSubscriberRequest$ {
  /** @deprecated use `SubscribersControllerPatchSubscriberRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerPatchSubscriberRequest$inboundSchema;
  /** @deprecated use `SubscribersControllerPatchSubscriberRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerPatchSubscriberRequest$outboundSchema;
  /** @deprecated use `SubscribersControllerPatchSubscriberRequest$Outbound` instead. */
  export type Outbound = SubscribersControllerPatchSubscriberRequest$Outbound;
}

export function subscribersControllerPatchSubscriberRequestToJSON(
  subscribersControllerPatchSubscriberRequest: SubscribersControllerPatchSubscriberRequest
): string {
  return JSON.stringify(
    SubscribersControllerPatchSubscriberRequest$outboundSchema.parse(subscribersControllerPatchSubscriberRequest)
  );
}

export function subscribersControllerPatchSubscriberRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerPatchSubscriberRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerPatchSubscriberRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerPatchSubscriberRequest' from JSON`
  );
}

/** @internal */
export const SubscribersControllerPatchSubscriberResponse$inboundSchema: z.ZodType<
  SubscribersControllerPatchSubscriberResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.SubscriberResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersControllerPatchSubscriberResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.SubscriberResponseDto$Outbound;
};

/** @internal */
export const SubscribersControllerPatchSubscriberResponse$outboundSchema: z.ZodType<
  SubscribersControllerPatchSubscriberResponse$Outbound,
  z.ZodTypeDef,
  SubscribersControllerPatchSubscriberResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.SubscriberResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerPatchSubscriberResponse$ {
  /** @deprecated use `SubscribersControllerPatchSubscriberResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerPatchSubscriberResponse$inboundSchema;
  /** @deprecated use `SubscribersControllerPatchSubscriberResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerPatchSubscriberResponse$outboundSchema;
  /** @deprecated use `SubscribersControllerPatchSubscriberResponse$Outbound` instead. */
  export type Outbound = SubscribersControllerPatchSubscriberResponse$Outbound;
}

export function subscribersControllerPatchSubscriberResponseToJSON(
  subscribersControllerPatchSubscriberResponse: SubscribersControllerPatchSubscriberResponse
): string {
  return JSON.stringify(
    SubscribersControllerPatchSubscriberResponse$outboundSchema.parse(subscribersControllerPatchSubscriberResponse)
  );
}

export function subscribersControllerPatchSubscriberResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerPatchSubscriberResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerPatchSubscriberResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerPatchSubscriberResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersControllerPatchSubscriberRequestToJSON(subscribersControllerPatchSubscriberRequest: SubscribersControllerPatchSubscriberRequest)
 - subscribersControllerPatchSubscriberRequestFromJSON(jsonString: string)
 - subscribersControllerPatchSubscriberResponseToJSON(subscribersControllerPatchSubscriberResponse: SubscribersControllerPatchSubscriberResponse)
 - subscribersControllerPatchSubscriberResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersControllerPatchSubscriberRequest$Outbound;
}

export function subscribersControllerPatchS...)
 - Outbound(SubscribersControllerPatchSubscriberResponse$Outbound;
}

export function subscribersControllerPatch...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerPatchSubscriberRequestToJSON
- export function subscribersControllerPatchSubscriberRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerPatchSubscriberResponseToJSON
- export function subscribersControllerPatchSubscriberResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscriberscontrollerremovesubscriber.ts
Tamaño: 5756 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscribersControllerRemoveSubscriberRequest = {
  subscriberId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type SubscribersControllerRemoveSubscriberResponse = {
  headers: { [k: string]: Array<string> };
  result: components.RemoveSubscriberResponseDto;
};

/** @internal */
export const SubscribersControllerRemoveSubscriberRequest$inboundSchema: z.ZodType<
  SubscribersControllerRemoveSubscriberRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    subscriberId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type SubscribersControllerRemoveSubscriberRequest$Outbound = {
  subscriberId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const SubscribersControllerRemoveSubscriberRequest$outboundSchema: z.ZodType<
  SubscribersControllerRemoveSubscriberRequest$Outbound,
  z.ZodTypeDef,
  SubscribersControllerRemoveSubscriberRequest
> = z
  .object({
    subscriberId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerRemoveSubscriberRequest$ {
  /** @deprecated use `SubscribersControllerRemoveSubscriberRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerRemoveSubscriberRequest$inboundSchema;
  /** @deprecated use `SubscribersControllerRemoveSubscriberRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerRemoveSubscriberRequest$outboundSchema;
  /** @deprecated use `SubscribersControllerRemoveSubscriberRequest$Outbound` instead. */
  export type Outbound = SubscribersControllerRemoveSubscriberRequest$Outbound;
}

export function subscribersControllerRemoveSubscriberRequestToJSON(
  subscribersControllerRemoveSubscriberRequest: SubscribersControllerRemoveSubscriberRequest
): string {
  return JSON.stringify(
    SubscribersControllerRemoveSubscriberRequest$outboundSchema.parse(subscribersControllerRemoveSubscriberRequest)
  );
}

export function subscribersControllerRemoveSubscriberRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerRemoveSubscriberRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerRemoveSubscriberRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerRemoveSubscriberRequest' from JSON`
  );
}

/** @internal */
export const SubscribersControllerRemoveSubscriberResponse$inboundSchema: z.ZodType<
  SubscribersControllerRemoveSubscriberResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.RemoveSubscriberResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersControllerRemoveSubscriberResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.RemoveSubscriberResponseDto$Outbound;
};

/** @internal */
export const SubscribersControllerRemoveSubscriberResponse$outboundSchema: z.ZodType<
  SubscribersControllerRemoveSubscriberResponse$Outbound,
  z.ZodTypeDef,
  SubscribersControllerRemoveSubscriberResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.RemoveSubscriberResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerRemoveSubscriberResponse$ {
  /** @deprecated use `SubscribersControllerRemoveSubscriberResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerRemoveSubscriberResponse$inboundSchema;
  /** @deprecated use `SubscribersControllerRemoveSubscriberResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerRemoveSubscriberResponse$outboundSchema;
  /** @deprecated use `SubscribersControllerRemoveSubscriberResponse$Outbound` instead. */
  export type Outbound = SubscribersControllerRemoveSubscriberResponse$Outbound;
}

export function subscribersControllerRemoveSubscriberResponseToJSON(
  subscribersControllerRemoveSubscriberResponse: SubscribersControllerRemoveSubscriberResponse
): string {
  return JSON.stringify(
    SubscribersControllerRemoveSubscriberResponse$outboundSchema.parse(subscribersControllerRemoveSubscriberResponse)
  );
}

export function subscribersControllerRemoveSubscriberResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerRemoveSubscriberResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerRemoveSubscriberResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerRemoveSubscriberResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersControllerRemoveSubscriberRequestToJSON(subscribersControllerRemoveSubscriberRequest: SubscribersControllerRemoveSubscriberRequest)
 - subscribersControllerRemoveSubscriberRequestFromJSON(jsonString: string)
 - subscribersControllerRemoveSubscriberResponseToJSON(subscribersControllerRemoveSubscriberResponse: SubscribersControllerRemoveSubscriberResponse)
 - subscribersControllerRemoveSubscriberResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersControllerRemoveSubscriberRequest$Outbound;
}

export function subscribersControllerRemov...)
 - Outbound(SubscribersControllerRemoveSubscriberResponse$Outbound;
}

export function subscribersControllerRemo...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerRemoveSubscriberRequestToJSON
- export function subscribersControllerRemoveSubscriberRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerRemoveSubscriberResponseToJSON
- export function subscribersControllerRemoveSubscriberResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscriberscontrollersearchsubscribers.ts
Tamaño: 8901 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Direction of sorting
 */
export const QueryParamOrderDirection = {
  Asc: 'ASC',
  Desc: 'DESC',
} as const;
/**
 * Direction of sorting
 */
export type QueryParamOrderDirection = ClosedEnum<typeof QueryParamOrderDirection>;

export type SubscribersControllerSearchSubscribersRequest = {
  /**
   * Cursor for pagination indicating the starting point after which to fetch results.
   */
  after?: string | undefined;
  /**
   * Cursor for pagination indicating the ending point before which to fetch results.
   */
  before?: string | undefined;
  /**
   * Limit the number of items to return
   */
  limit?: number | undefined;
  /**
   * Direction of sorting
   */
  orderDirection?: QueryParamOrderDirection | undefined;
  /**
   * Field to order by
   */
  orderBy?: string | undefined;
  /**
   * Include cursor item in response
   */
  includeCursor?: boolean | undefined;
  /**
   * Email address of the subscriber to filter results.
   */
  email?: string | undefined;
  /**
   * Name of the subscriber to filter results.
   */
  name?: string | undefined;
  /**
   * Phone number of the subscriber to filter results.
   */
  phone?: string | undefined;
  /**
   * Unique identifier of the subscriber to filter results.
   */
  subscriberId?: string | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type SubscribersControllerSearchSubscribersResponse = {
  headers: { [k: string]: Array<string> };
  result: components.ListSubscribersResponseDto;
};

/** @internal */
export const QueryParamOrderDirection$inboundSchema: z.ZodNativeEnum<typeof QueryParamOrderDirection> =
  z.nativeEnum(QueryParamOrderDirection);

/** @internal */
export const QueryParamOrderDirection$outboundSchema: z.ZodNativeEnum<typeof QueryParamOrderDirection> =
  QueryParamOrderDirection$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueryParamOrderDirection$ {
  /** @deprecated use `QueryParamOrderDirection$inboundSchema` instead. */
  export const inboundSchema = QueryParamOrderDirection$inboundSchema;
  /** @deprecated use `QueryParamOrderDirection$outboundSchema` instead. */
  export const outboundSchema = QueryParamOrderDirection$outboundSchema;
}

/** @internal */
export const SubscribersControllerSearchSubscribersRequest$inboundSchema: z.ZodType<
  SubscribersControllerSearchSubscribersRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    after: z.string().optional(),
    before: z.string().optional(),
    limit: z.number().optional(),
    orderDirection: QueryParamOrderDirection$inboundSchema.optional(),
    orderBy: z.string().optional(),
    includeCursor: z.boolean().optional(),
    email: z.string().optional(),
    name: z.string().optional(),
    phone: z.string().optional(),
    subscriberId: z.string().optional(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type SubscribersControllerSearchSubscribersRequest$Outbound = {
  after?: string | undefined;
  before?: string | undefined;
  limit?: number | undefined;
  orderDirection?: string | undefined;
  orderBy?: string | undefined;
  includeCursor?: boolean | undefined;
  email?: string | undefined;
  name?: string | undefined;
  phone?: string | undefined;
  subscriberId?: string | undefined;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const SubscribersControllerSearchSubscribersRequest$outboundSchema: z.ZodType<
  SubscribersControllerSearchSubscribersRequest$Outbound,
  z.ZodTypeDef,
  SubscribersControllerSearchSubscribersRequest
> = z
  .object({
    after: z.string().optional(),
    before: z.string().optional(),
    limit: z.number().optional(),
    orderDirection: QueryParamOrderDirection$outboundSchema.optional(),
    orderBy: z.string().optional(),
    includeCursor: z.boolean().optional(),
    email: z.string().optional(),
    name: z.string().optional(),
    phone: z.string().optional(),
    subscriberId: z.string().optional(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerSearchSubscribersRequest$ {
  /** @deprecated use `SubscribersControllerSearchSubscribersRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerSearchSubscribersRequest$inboundSchema;
  /** @deprecated use `SubscribersControllerSearchSubscribersRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerSearchSubscribersRequest$outboundSchema;
  /** @deprecated use `SubscribersControllerSearchSubscribersRequest$Outbound` instead. */
  export type Outbound = SubscribersControllerSearchSubscribersRequest$Outbound;
}

export function subscribersControllerSearchSubscribersRequestToJSON(
  subscribersControllerSearchSubscribersRequest: SubscribersControllerSearchSubscribersRequest
): string {
  return JSON.stringify(
    SubscribersControllerSearchSubscribersRequest$outboundSchema.parse(subscribersControllerSearchSubscribersRequest)
  );
}

export function subscribersControllerSearchSubscribersRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerSearchSubscribersRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerSearchSubscribersRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerSearchSubscribersRequest' from JSON`
  );
}

/** @internal */
export const SubscribersControllerSearchSubscribersResponse$inboundSchema: z.ZodType<
  SubscribersControllerSearchSubscribersResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.ListSubscribersResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersControllerSearchSubscribersResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.ListSubscribersResponseDto$Outbound;
};

/** @internal */
export const SubscribersControllerSearchSubscribersResponse$outboundSchema: z.ZodType<
  SubscribersControllerSearchSubscribersResponse$Outbound,
  z.ZodTypeDef,
  SubscribersControllerSearchSubscribersResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.ListSubscribersResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerSearchSubscribersResponse$ {
  /** @deprecated use `SubscribersControllerSearchSubscribersResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerSearchSubscribersResponse$inboundSchema;
  /** @deprecated use `SubscribersControllerSearchSubscribersResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerSearchSubscribersResponse$outboundSchema;
  /** @deprecated use `SubscribersControllerSearchSubscribersResponse$Outbound` instead. */
  export type Outbound = SubscribersControllerSearchSubscribersResponse$Outbound;
}

export function subscribersControllerSearchSubscribersResponseToJSON(
  subscribersControllerSearchSubscribersResponse: SubscribersControllerSearchSubscribersResponse
): string {
  return JSON.stringify(
    SubscribersControllerSearchSubscribersResponse$outboundSchema.parse(subscribersControllerSearchSubscribersResponse)
  );
}

export function subscribersControllerSearchSubscribersResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerSearchSubscribersResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerSearchSubscribersResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerSearchSubscribersResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersControllerSearchSubscribersRequestToJSON(subscribersControllerSearchSubscribersRequest: SubscribersControllerSearchSubscribersRequest)
 - subscribersControllerSearchSubscribersRequestFromJSON(jsonString: string)
 - subscribersControllerSearchSubscribersResponseToJSON(subscribersControllerSearchSubscribersResponse: SubscribersControllerSearchSubscribersResponse)
 - subscribersControllerSearchSubscribersResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersControllerSearchSubscribersRequest$Outbound;
}

export function subscribersControllerSear...)
 - Outbound(SubscribersControllerSearchSubscribersResponse$Outbound;
}

export function subscribersControllerSea...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerSearchSubscribersRequestToJSON
- export function subscribersControllerSearchSubscribersRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerSearchSubscribersResponseToJSON
- export function subscribersControllerSearchSubscribersResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscriberscontrollerupdatesubscriberpreferences.ts
Tamaño: 6768 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscribersControllerUpdateSubscriberPreferencesRequest = {
  subscriberId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  patchSubscriberPreferencesDto: components.PatchSubscriberPreferencesDto;
};

export type SubscribersControllerUpdateSubscriberPreferencesResponse = {
  headers: { [k: string]: Array<string> };
  result: components.GetSubscriberPreferencesDto;
};

/** @internal */
export const SubscribersControllerUpdateSubscriberPreferencesRequest$inboundSchema: z.ZodType<
  SubscribersControllerUpdateSubscriberPreferencesRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    subscriberId: z.string(),
    'idempotency-key': z.string().optional(),
    PatchSubscriberPreferencesDto: components.PatchSubscriberPreferencesDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      PatchSubscriberPreferencesDto: 'patchSubscriberPreferencesDto',
    });
  });

/** @internal */
export type SubscribersControllerUpdateSubscriberPreferencesRequest$Outbound = {
  subscriberId: string;
  'idempotency-key'?: string | undefined;
  PatchSubscriberPreferencesDto: components.PatchSubscriberPreferencesDto$Outbound;
};

/** @internal */
export const SubscribersControllerUpdateSubscriberPreferencesRequest$outboundSchema: z.ZodType<
  SubscribersControllerUpdateSubscriberPreferencesRequest$Outbound,
  z.ZodTypeDef,
  SubscribersControllerUpdateSubscriberPreferencesRequest
> = z
  .object({
    subscriberId: z.string(),
    idempotencyKey: z.string().optional(),
    patchSubscriberPreferencesDto: components.PatchSubscriberPreferencesDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      patchSubscriberPreferencesDto: 'PatchSubscriberPreferencesDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerUpdateSubscriberPreferencesRequest$ {
  /** @deprecated use `SubscribersControllerUpdateSubscriberPreferencesRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerUpdateSubscriberPreferencesRequest$inboundSchema;
  /** @deprecated use `SubscribersControllerUpdateSubscriberPreferencesRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerUpdateSubscriberPreferencesRequest$outboundSchema;
  /** @deprecated use `SubscribersControllerUpdateSubscriberPreferencesRequest$Outbound` instead. */
  export type Outbound = SubscribersControllerUpdateSubscriberPreferencesRequest$Outbound;
}

export function subscribersControllerUpdateSubscriberPreferencesRequestToJSON(
  subscribersControllerUpdateSubscriberPreferencesRequest: SubscribersControllerUpdateSubscriberPreferencesRequest
): string {
  return JSON.stringify(
    SubscribersControllerUpdateSubscriberPreferencesRequest$outboundSchema.parse(
      subscribersControllerUpdateSubscriberPreferencesRequest
    )
  );
}

export function subscribersControllerUpdateSubscriberPreferencesRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerUpdateSubscriberPreferencesRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerUpdateSubscriberPreferencesRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerUpdateSubscriberPreferencesRequest' from JSON`
  );
}

/** @internal */
export const SubscribersControllerUpdateSubscriberPreferencesResponse$inboundSchema: z.ZodType<
  SubscribersControllerUpdateSubscriberPreferencesResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.GetSubscriberPreferencesDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersControllerUpdateSubscriberPreferencesResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.GetSubscriberPreferencesDto$Outbound;
};

/** @internal */
export const SubscribersControllerUpdateSubscriberPreferencesResponse$outboundSchema: z.ZodType<
  SubscribersControllerUpdateSubscriberPreferencesResponse$Outbound,
  z.ZodTypeDef,
  SubscribersControllerUpdateSubscriberPreferencesResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.GetSubscriberPreferencesDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersControllerUpdateSubscriberPreferencesResponse$ {
  /** @deprecated use `SubscribersControllerUpdateSubscriberPreferencesResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersControllerUpdateSubscriberPreferencesResponse$inboundSchema;
  /** @deprecated use `SubscribersControllerUpdateSubscriberPreferencesResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersControllerUpdateSubscriberPreferencesResponse$outboundSchema;
  /** @deprecated use `SubscribersControllerUpdateSubscriberPreferencesResponse$Outbound` instead. */
  export type Outbound = SubscribersControllerUpdateSubscriberPreferencesResponse$Outbound;
}

export function subscribersControllerUpdateSubscriberPreferencesResponseToJSON(
  subscribersControllerUpdateSubscriberPreferencesResponse: SubscribersControllerUpdateSubscriberPreferencesResponse
): string {
  return JSON.stringify(
    SubscribersControllerUpdateSubscriberPreferencesResponse$outboundSchema.parse(
      subscribersControllerUpdateSubscriberPreferencesResponse
    )
  );
}

export function subscribersControllerUpdateSubscriberPreferencesResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersControllerUpdateSubscriberPreferencesResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersControllerUpdateSubscriberPreferencesResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersControllerUpdateSubscriberPreferencesResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersControllerUpdateSubscriberPreferencesRequestToJSON(subscribersControllerUpdateSubscriberPreferencesRequest: SubscribersControllerUpdateSubscriberPreferencesRequest)
 - subscribersControllerUpdateSubscriberPreferencesRequestFromJSON(jsonString: string)
 - subscribersControllerUpdateSubscriberPreferencesResponseToJSON(subscribersControllerUpdateSubscriberPreferencesResponse: SubscribersControllerUpdateSubscriberPreferencesResponse)
 - subscribersControllerUpdateSubscriberPreferencesResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersControllerUpdateSubscriberPreferencesRequest$Outbound;
}

export function subscribersCont...)
 - Outbound(SubscribersControllerUpdateSubscriberPreferencesResponse$Outbound;
}

export function subscribersCon...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerUpdateSubscriberPreferencesRequestToJSON
- export function subscribersControllerUpdateSubscriberPreferencesRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersControllerUpdateSubscriberPreferencesResponseToJSON
- export function subscribersControllerUpdateSubscriberPreferencesResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscribersv1controllerbulkcreatesubscribers.ts
Tamaño: 6420 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscribersV1ControllerBulkCreateSubscribersRequest = {
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  bulkSubscriberCreateDto: components.BulkSubscriberCreateDto;
};

export type SubscribersV1ControllerBulkCreateSubscribersResponse = {
  headers: { [k: string]: Array<string> };
  result: components.BulkCreateSubscriberResponseDto;
};

/** @internal */
export const SubscribersV1ControllerBulkCreateSubscribersRequest$inboundSchema: z.ZodType<
  SubscribersV1ControllerBulkCreateSubscribersRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    'idempotency-key': z.string().optional(),
    BulkSubscriberCreateDto: components.BulkSubscriberCreateDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      BulkSubscriberCreateDto: 'bulkSubscriberCreateDto',
    });
  });

/** @internal */
export type SubscribersV1ControllerBulkCreateSubscribersRequest$Outbound = {
  'idempotency-key'?: string | undefined;
  BulkSubscriberCreateDto: components.BulkSubscriberCreateDto$Outbound;
};

/** @internal */
export const SubscribersV1ControllerBulkCreateSubscribersRequest$outboundSchema: z.ZodType<
  SubscribersV1ControllerBulkCreateSubscribersRequest$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerBulkCreateSubscribersRequest
> = z
  .object({
    idempotencyKey: z.string().optional(),
    bulkSubscriberCreateDto: components.BulkSubscriberCreateDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      bulkSubscriberCreateDto: 'BulkSubscriberCreateDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerBulkCreateSubscribersRequest$ {
  /** @deprecated use `SubscribersV1ControllerBulkCreateSubscribersRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerBulkCreateSubscribersRequest$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerBulkCreateSubscribersRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerBulkCreateSubscribersRequest$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerBulkCreateSubscribersRequest$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerBulkCreateSubscribersRequest$Outbound;
}

export function subscribersV1ControllerBulkCreateSubscribersRequestToJSON(
  subscribersV1ControllerBulkCreateSubscribersRequest: SubscribersV1ControllerBulkCreateSubscribersRequest
): string {
  return JSON.stringify(
    SubscribersV1ControllerBulkCreateSubscribersRequest$outboundSchema.parse(
      subscribersV1ControllerBulkCreateSubscribersRequest
    )
  );
}

export function subscribersV1ControllerBulkCreateSubscribersRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerBulkCreateSubscribersRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerBulkCreateSubscribersRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerBulkCreateSubscribersRequest' from JSON`
  );
}

/** @internal */
export const SubscribersV1ControllerBulkCreateSubscribersResponse$inboundSchema: z.ZodType<
  SubscribersV1ControllerBulkCreateSubscribersResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.BulkCreateSubscriberResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersV1ControllerBulkCreateSubscribersResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.BulkCreateSubscriberResponseDto$Outbound;
};

/** @internal */
export const SubscribersV1ControllerBulkCreateSubscribersResponse$outboundSchema: z.ZodType<
  SubscribersV1ControllerBulkCreateSubscribersResponse$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerBulkCreateSubscribersResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.BulkCreateSubscriberResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerBulkCreateSubscribersResponse$ {
  /** @deprecated use `SubscribersV1ControllerBulkCreateSubscribersResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerBulkCreateSubscribersResponse$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerBulkCreateSubscribersResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerBulkCreateSubscribersResponse$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerBulkCreateSubscribersResponse$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerBulkCreateSubscribersResponse$Outbound;
}

export function subscribersV1ControllerBulkCreateSubscribersResponseToJSON(
  subscribersV1ControllerBulkCreateSubscribersResponse: SubscribersV1ControllerBulkCreateSubscribersResponse
): string {
  return JSON.stringify(
    SubscribersV1ControllerBulkCreateSubscribersResponse$outboundSchema.parse(
      subscribersV1ControllerBulkCreateSubscribersResponse
    )
  );
}

export function subscribersV1ControllerBulkCreateSubscribersResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerBulkCreateSubscribersResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerBulkCreateSubscribersResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerBulkCreateSubscribersResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersV1ControllerBulkCreateSubscribersRequestToJSON(subscribersV1ControllerBulkCreateSubscribersRequest: SubscribersV1ControllerBulkCreateSubscribersRequest)
 - subscribersV1ControllerBulkCreateSubscribersRequestFromJSON(jsonString: string)
 - subscribersV1ControllerBulkCreateSubscribersResponseToJSON(subscribersV1ControllerBulkCreateSubscribersResponse: SubscribersV1ControllerBulkCreateSubscribersResponse)
 - subscribersV1ControllerBulkCreateSubscribersResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersV1ControllerBulkCreateSubscribersRequest$Outbound;
}

export function subscribersV1Contro...)
 - Outbound(SubscribersV1ControllerBulkCreateSubscribersResponse$Outbound;
}

export function subscribersV1Contr...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerBulkCreateSubscribersRequestToJSON
- export function subscribersV1ControllerBulkCreateSubscribersRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerBulkCreateSubscribersResponseToJSON
- export function subscribersV1ControllerBulkCreateSubscribersResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscribersv1controllerdeletesubscribercredentials.ts
Tamaño: 6134 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscribersV1ControllerDeleteSubscriberCredentialsRequest = {
  subscriberId: string;
  providerId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type SubscribersV1ControllerDeleteSubscriberCredentialsResponse = {
  headers: { [k: string]: Array<string> };
};

/** @internal */
export const SubscribersV1ControllerDeleteSubscriberCredentialsRequest$inboundSchema: z.ZodType<
  SubscribersV1ControllerDeleteSubscriberCredentialsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    subscriberId: z.string(),
    providerId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type SubscribersV1ControllerDeleteSubscriberCredentialsRequest$Outbound = {
  subscriberId: string;
  providerId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const SubscribersV1ControllerDeleteSubscriberCredentialsRequest$outboundSchema: z.ZodType<
  SubscribersV1ControllerDeleteSubscriberCredentialsRequest$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerDeleteSubscriberCredentialsRequest
> = z
  .object({
    subscriberId: z.string(),
    providerId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerDeleteSubscriberCredentialsRequest$ {
  /** @deprecated use `SubscribersV1ControllerDeleteSubscriberCredentialsRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerDeleteSubscriberCredentialsRequest$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerDeleteSubscriberCredentialsRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerDeleteSubscriberCredentialsRequest$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerDeleteSubscriberCredentialsRequest$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerDeleteSubscriberCredentialsRequest$Outbound;
}

export function subscribersV1ControllerDeleteSubscriberCredentialsRequestToJSON(
  subscribersV1ControllerDeleteSubscriberCredentialsRequest: SubscribersV1ControllerDeleteSubscriberCredentialsRequest
): string {
  return JSON.stringify(
    SubscribersV1ControllerDeleteSubscriberCredentialsRequest$outboundSchema.parse(
      subscribersV1ControllerDeleteSubscriberCredentialsRequest
    )
  );
}

export function subscribersV1ControllerDeleteSubscriberCredentialsRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerDeleteSubscriberCredentialsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerDeleteSubscriberCredentialsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerDeleteSubscriberCredentialsRequest' from JSON`
  );
}

/** @internal */
export const SubscribersV1ControllerDeleteSubscriberCredentialsResponse$inboundSchema: z.ZodType<
  SubscribersV1ControllerDeleteSubscriberCredentialsResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
    });
  });

/** @internal */
export type SubscribersV1ControllerDeleteSubscriberCredentialsResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
};

/** @internal */
export const SubscribersV1ControllerDeleteSubscriberCredentialsResponse$outboundSchema: z.ZodType<
  SubscribersV1ControllerDeleteSubscriberCredentialsResponse$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerDeleteSubscriberCredentialsResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerDeleteSubscriberCredentialsResponse$ {
  /** @deprecated use `SubscribersV1ControllerDeleteSubscriberCredentialsResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerDeleteSubscriberCredentialsResponse$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerDeleteSubscriberCredentialsResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerDeleteSubscriberCredentialsResponse$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerDeleteSubscriberCredentialsResponse$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerDeleteSubscriberCredentialsResponse$Outbound;
}

export function subscribersV1ControllerDeleteSubscriberCredentialsResponseToJSON(
  subscribersV1ControllerDeleteSubscriberCredentialsResponse: SubscribersV1ControllerDeleteSubscriberCredentialsResponse
): string {
  return JSON.stringify(
    SubscribersV1ControllerDeleteSubscriberCredentialsResponse$outboundSchema.parse(
      subscribersV1ControllerDeleteSubscriberCredentialsResponse
    )
  );
}

export function subscribersV1ControllerDeleteSubscriberCredentialsResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerDeleteSubscriberCredentialsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerDeleteSubscriberCredentialsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerDeleteSubscriberCredentialsResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersV1ControllerDeleteSubscriberCredentialsRequestToJSON(subscribersV1ControllerDeleteSubscriberCredentialsRequest: SubscribersV1ControllerDeleteSubscriberCredentialsRequest)
 - subscribersV1ControllerDeleteSubscriberCredentialsRequestFromJSON(jsonString: string)
 - subscribersV1ControllerDeleteSubscriberCredentialsResponseToJSON(subscribersV1ControllerDeleteSubscriberCredentialsResponse: SubscribersV1ControllerDeleteSubscriberCredentialsResponse)
 - subscribersV1ControllerDeleteSubscriberCredentialsResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersV1ControllerDeleteSubscriberCredentialsRequest$Outbound;
}

export function subscribersV1...)
 - Outbound(SubscribersV1ControllerDeleteSubscriberCredentialsResponse$Outbound;
}

export function subscribersV...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerDeleteSubscriberCredentialsRequestToJSON
- export function subscribersV1ControllerDeleteSubscriberCredentialsRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerDeleteSubscriberCredentialsResponseToJSON
- export function subscribersV1ControllerDeleteSubscriberCredentialsResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscribersv1controllergetnotificationsfeed.ts
Tamaño: 6715 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscribersV1ControllerGetNotificationsFeedRequest = {
  subscriberId: string;
  page?: number | undefined;
  limit?: number | undefined;
  read?: boolean | undefined;
  seen?: boolean | undefined;
  /**
   * Base64 encoded string of the partial payload JSON object
   */
  payload?: string | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type SubscribersV1ControllerGetNotificationsFeedResponse = {
  headers: { [k: string]: Array<string> };
  result: components.FeedResponseDto;
};

/** @internal */
export const SubscribersV1ControllerGetNotificationsFeedRequest$inboundSchema: z.ZodType<
  SubscribersV1ControllerGetNotificationsFeedRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    subscriberId: z.string(),
    page: z.number().optional(),
    limit: z.number().default(10),
    read: z.boolean().optional(),
    seen: z.boolean().optional(),
    payload: z.string().optional(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type SubscribersV1ControllerGetNotificationsFeedRequest$Outbound = {
  subscriberId: string;
  page?: number | undefined;
  limit: number;
  read?: boolean | undefined;
  seen?: boolean | undefined;
  payload?: string | undefined;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const SubscribersV1ControllerGetNotificationsFeedRequest$outboundSchema: z.ZodType<
  SubscribersV1ControllerGetNotificationsFeedRequest$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerGetNotificationsFeedRequest
> = z
  .object({
    subscriberId: z.string(),
    page: z.number().optional(),
    limit: z.number().default(10),
    read: z.boolean().optional(),
    seen: z.boolean().optional(),
    payload: z.string().optional(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerGetNotificationsFeedRequest$ {
  /** @deprecated use `SubscribersV1ControllerGetNotificationsFeedRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerGetNotificationsFeedRequest$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerGetNotificationsFeedRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerGetNotificationsFeedRequest$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerGetNotificationsFeedRequest$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerGetNotificationsFeedRequest$Outbound;
}

export function subscribersV1ControllerGetNotificationsFeedRequestToJSON(
  subscribersV1ControllerGetNotificationsFeedRequest: SubscribersV1ControllerGetNotificationsFeedRequest
): string {
  return JSON.stringify(
    SubscribersV1ControllerGetNotificationsFeedRequest$outboundSchema.parse(
      subscribersV1ControllerGetNotificationsFeedRequest
    )
  );
}

export function subscribersV1ControllerGetNotificationsFeedRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerGetNotificationsFeedRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerGetNotificationsFeedRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerGetNotificationsFeedRequest' from JSON`
  );
}

/** @internal */
export const SubscribersV1ControllerGetNotificationsFeedResponse$inboundSchema: z.ZodType<
  SubscribersV1ControllerGetNotificationsFeedResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.FeedResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersV1ControllerGetNotificationsFeedResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.FeedResponseDto$Outbound;
};

/** @internal */
export const SubscribersV1ControllerGetNotificationsFeedResponse$outboundSchema: z.ZodType<
  SubscribersV1ControllerGetNotificationsFeedResponse$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerGetNotificationsFeedResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.FeedResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerGetNotificationsFeedResponse$ {
  /** @deprecated use `SubscribersV1ControllerGetNotificationsFeedResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerGetNotificationsFeedResponse$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerGetNotificationsFeedResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerGetNotificationsFeedResponse$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerGetNotificationsFeedResponse$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerGetNotificationsFeedResponse$Outbound;
}

export function subscribersV1ControllerGetNotificationsFeedResponseToJSON(
  subscribersV1ControllerGetNotificationsFeedResponse: SubscribersV1ControllerGetNotificationsFeedResponse
): string {
  return JSON.stringify(
    SubscribersV1ControllerGetNotificationsFeedResponse$outboundSchema.parse(
      subscribersV1ControllerGetNotificationsFeedResponse
    )
  );
}

export function subscribersV1ControllerGetNotificationsFeedResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerGetNotificationsFeedResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerGetNotificationsFeedResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerGetNotificationsFeedResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersV1ControllerGetNotificationsFeedRequestToJSON(subscribersV1ControllerGetNotificationsFeedRequest: SubscribersV1ControllerGetNotificationsFeedRequest)
 - subscribersV1ControllerGetNotificationsFeedRequestFromJSON(jsonString: string)
 - subscribersV1ControllerGetNotificationsFeedResponseToJSON(subscribersV1ControllerGetNotificationsFeedResponse: SubscribersV1ControllerGetNotificationsFeedResponse)
 - subscribersV1ControllerGetNotificationsFeedResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersV1ControllerGetNotificationsFeedRequest$Outbound;
}

export function subscribersV1Control...)
 - Outbound(SubscribersV1ControllerGetNotificationsFeedResponse$Outbound;
}

export function subscribersV1Contro...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerGetNotificationsFeedRequestToJSON
- export function subscribersV1ControllerGetNotificationsFeedRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerGetNotificationsFeedResponseToJSON
- export function subscribersV1ControllerGetNotificationsFeedResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscribersv1controllergetunseencount.ts
Tamaño: 6094 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscribersV1ControllerGetUnseenCountRequest = {
  subscriberId: string;
  /**
   * Indicates whether to count seen notifications.
   */
  seen?: boolean | undefined;
  /**
   * The maximum number of notifications to return.
   */
  limit?: number | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type SubscribersV1ControllerGetUnseenCountResponse = {
  headers: { [k: string]: Array<string> };
  result: components.UnseenCountResponse;
};

/** @internal */
export const SubscribersV1ControllerGetUnseenCountRequest$inboundSchema: z.ZodType<
  SubscribersV1ControllerGetUnseenCountRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    subscriberId: z.string(),
    seen: z.boolean().default(false),
    limit: z.number().default(100),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type SubscribersV1ControllerGetUnseenCountRequest$Outbound = {
  subscriberId: string;
  seen: boolean;
  limit: number;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const SubscribersV1ControllerGetUnseenCountRequest$outboundSchema: z.ZodType<
  SubscribersV1ControllerGetUnseenCountRequest$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerGetUnseenCountRequest
> = z
  .object({
    subscriberId: z.string(),
    seen: z.boolean().default(false),
    limit: z.number().default(100),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerGetUnseenCountRequest$ {
  /** @deprecated use `SubscribersV1ControllerGetUnseenCountRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerGetUnseenCountRequest$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerGetUnseenCountRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerGetUnseenCountRequest$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerGetUnseenCountRequest$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerGetUnseenCountRequest$Outbound;
}

export function subscribersV1ControllerGetUnseenCountRequestToJSON(
  subscribersV1ControllerGetUnseenCountRequest: SubscribersV1ControllerGetUnseenCountRequest
): string {
  return JSON.stringify(
    SubscribersV1ControllerGetUnseenCountRequest$outboundSchema.parse(subscribersV1ControllerGetUnseenCountRequest)
  );
}

export function subscribersV1ControllerGetUnseenCountRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerGetUnseenCountRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerGetUnseenCountRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerGetUnseenCountRequest' from JSON`
  );
}

/** @internal */
export const SubscribersV1ControllerGetUnseenCountResponse$inboundSchema: z.ZodType<
  SubscribersV1ControllerGetUnseenCountResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.UnseenCountResponse$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersV1ControllerGetUnseenCountResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.UnseenCountResponse$Outbound;
};

/** @internal */
export const SubscribersV1ControllerGetUnseenCountResponse$outboundSchema: z.ZodType<
  SubscribersV1ControllerGetUnseenCountResponse$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerGetUnseenCountResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.UnseenCountResponse$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerGetUnseenCountResponse$ {
  /** @deprecated use `SubscribersV1ControllerGetUnseenCountResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerGetUnseenCountResponse$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerGetUnseenCountResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerGetUnseenCountResponse$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerGetUnseenCountResponse$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerGetUnseenCountResponse$Outbound;
}

export function subscribersV1ControllerGetUnseenCountResponseToJSON(
  subscribersV1ControllerGetUnseenCountResponse: SubscribersV1ControllerGetUnseenCountResponse
): string {
  return JSON.stringify(
    SubscribersV1ControllerGetUnseenCountResponse$outboundSchema.parse(subscribersV1ControllerGetUnseenCountResponse)
  );
}

export function subscribersV1ControllerGetUnseenCountResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerGetUnseenCountResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerGetUnseenCountResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerGetUnseenCountResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersV1ControllerGetUnseenCountRequestToJSON(subscribersV1ControllerGetUnseenCountRequest: SubscribersV1ControllerGetUnseenCountRequest)
 - subscribersV1ControllerGetUnseenCountRequestFromJSON(jsonString: string)
 - subscribersV1ControllerGetUnseenCountResponseToJSON(subscribersV1ControllerGetUnseenCountResponse: SubscribersV1ControllerGetUnseenCountResponse)
 - subscribersV1ControllerGetUnseenCountResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersV1ControllerGetUnseenCountRequest$Outbound;
}

export function subscribersV1ControllerGet...)
 - Outbound(SubscribersV1ControllerGetUnseenCountResponse$Outbound;
}

export function subscribersV1ControllerGe...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerGetUnseenCountRequestToJSON
- export function subscribersV1ControllerGetUnseenCountRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerGetUnseenCountResponseToJSON
- export function subscribersV1ControllerGetUnseenCountResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscribersv1controllermarkactionasseen.ts
Tamaño: 6442 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscribersV1ControllerMarkActionAsSeenRequest = {
  messageId: string;
  type: string;
  subscriberId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  markMessageActionAsSeenDto: components.MarkMessageActionAsSeenDto;
};

export type SubscribersV1ControllerMarkActionAsSeenResponse = {
  headers: { [k: string]: Array<string> };
  result: components.MessageResponseDto;
};

/** @internal */
export const SubscribersV1ControllerMarkActionAsSeenRequest$inboundSchema: z.ZodType<
  SubscribersV1ControllerMarkActionAsSeenRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    messageId: z.string(),
    type: z.string(),
    subscriberId: z.string(),
    'idempotency-key': z.string().optional(),
    MarkMessageActionAsSeenDto: components.MarkMessageActionAsSeenDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      MarkMessageActionAsSeenDto: 'markMessageActionAsSeenDto',
    });
  });

/** @internal */
export type SubscribersV1ControllerMarkActionAsSeenRequest$Outbound = {
  messageId: string;
  type: string;
  subscriberId: string;
  'idempotency-key'?: string | undefined;
  MarkMessageActionAsSeenDto: components.MarkMessageActionAsSeenDto$Outbound;
};

/** @internal */
export const SubscribersV1ControllerMarkActionAsSeenRequest$outboundSchema: z.ZodType<
  SubscribersV1ControllerMarkActionAsSeenRequest$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerMarkActionAsSeenRequest
> = z
  .object({
    messageId: z.string(),
    type: z.string(),
    subscriberId: z.string(),
    idempotencyKey: z.string().optional(),
    markMessageActionAsSeenDto: components.MarkMessageActionAsSeenDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      markMessageActionAsSeenDto: 'MarkMessageActionAsSeenDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerMarkActionAsSeenRequest$ {
  /** @deprecated use `SubscribersV1ControllerMarkActionAsSeenRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerMarkActionAsSeenRequest$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerMarkActionAsSeenRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerMarkActionAsSeenRequest$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerMarkActionAsSeenRequest$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerMarkActionAsSeenRequest$Outbound;
}

export function subscribersV1ControllerMarkActionAsSeenRequestToJSON(
  subscribersV1ControllerMarkActionAsSeenRequest: SubscribersV1ControllerMarkActionAsSeenRequest
): string {
  return JSON.stringify(
    SubscribersV1ControllerMarkActionAsSeenRequest$outboundSchema.parse(subscribersV1ControllerMarkActionAsSeenRequest)
  );
}

export function subscribersV1ControllerMarkActionAsSeenRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerMarkActionAsSeenRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerMarkActionAsSeenRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerMarkActionAsSeenRequest' from JSON`
  );
}

/** @internal */
export const SubscribersV1ControllerMarkActionAsSeenResponse$inboundSchema: z.ZodType<
  SubscribersV1ControllerMarkActionAsSeenResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.MessageResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersV1ControllerMarkActionAsSeenResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.MessageResponseDto$Outbound;
};

/** @internal */
export const SubscribersV1ControllerMarkActionAsSeenResponse$outboundSchema: z.ZodType<
  SubscribersV1ControllerMarkActionAsSeenResponse$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerMarkActionAsSeenResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.MessageResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerMarkActionAsSeenResponse$ {
  /** @deprecated use `SubscribersV1ControllerMarkActionAsSeenResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerMarkActionAsSeenResponse$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerMarkActionAsSeenResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerMarkActionAsSeenResponse$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerMarkActionAsSeenResponse$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerMarkActionAsSeenResponse$Outbound;
}

export function subscribersV1ControllerMarkActionAsSeenResponseToJSON(
  subscribersV1ControllerMarkActionAsSeenResponse: SubscribersV1ControllerMarkActionAsSeenResponse
): string {
  return JSON.stringify(
    SubscribersV1ControllerMarkActionAsSeenResponse$outboundSchema.parse(
      subscribersV1ControllerMarkActionAsSeenResponse
    )
  );
}

export function subscribersV1ControllerMarkActionAsSeenResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerMarkActionAsSeenResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerMarkActionAsSeenResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerMarkActionAsSeenResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersV1ControllerMarkActionAsSeenRequestToJSON(subscribersV1ControllerMarkActionAsSeenRequest: SubscribersV1ControllerMarkActionAsSeenRequest)
 - subscribersV1ControllerMarkActionAsSeenRequestFromJSON(jsonString: string)
 - subscribersV1ControllerMarkActionAsSeenResponseToJSON(subscribersV1ControllerMarkActionAsSeenResponse: SubscribersV1ControllerMarkActionAsSeenResponse)
 - subscribersV1ControllerMarkActionAsSeenResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersV1ControllerMarkActionAsSeenRequest$Outbound;
}

export function subscribersV1ControllerM...)
 - Outbound(SubscribersV1ControllerMarkActionAsSeenResponse$Outbound;
}

export function subscribersV1Controller...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerMarkActionAsSeenRequestToJSON
- export function subscribersV1ControllerMarkActionAsSeenRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerMarkActionAsSeenResponseToJSON
- export function subscribersV1ControllerMarkActionAsSeenResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscribersv1controllermarkallunreadasread.ts
Tamaño: 6298 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscribersV1ControllerMarkAllUnreadAsReadRequest = {
  subscriberId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  markAllMessageAsRequestDto: components.MarkAllMessageAsRequestDto;
};

export type SubscribersV1ControllerMarkAllUnreadAsReadResponse = {
  headers: { [k: string]: Array<string> };
  result: number;
};

/** @internal */
export const SubscribersV1ControllerMarkAllUnreadAsReadRequest$inboundSchema: z.ZodType<
  SubscribersV1ControllerMarkAllUnreadAsReadRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    subscriberId: z.string(),
    'idempotency-key': z.string().optional(),
    MarkAllMessageAsRequestDto: components.MarkAllMessageAsRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      MarkAllMessageAsRequestDto: 'markAllMessageAsRequestDto',
    });
  });

/** @internal */
export type SubscribersV1ControllerMarkAllUnreadAsReadRequest$Outbound = {
  subscriberId: string;
  'idempotency-key'?: string | undefined;
  MarkAllMessageAsRequestDto: components.MarkAllMessageAsRequestDto$Outbound;
};

/** @internal */
export const SubscribersV1ControllerMarkAllUnreadAsReadRequest$outboundSchema: z.ZodType<
  SubscribersV1ControllerMarkAllUnreadAsReadRequest$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerMarkAllUnreadAsReadRequest
> = z
  .object({
    subscriberId: z.string(),
    idempotencyKey: z.string().optional(),
    markAllMessageAsRequestDto: components.MarkAllMessageAsRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      markAllMessageAsRequestDto: 'MarkAllMessageAsRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerMarkAllUnreadAsReadRequest$ {
  /** @deprecated use `SubscribersV1ControllerMarkAllUnreadAsReadRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerMarkAllUnreadAsReadRequest$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerMarkAllUnreadAsReadRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerMarkAllUnreadAsReadRequest$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerMarkAllUnreadAsReadRequest$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerMarkAllUnreadAsReadRequest$Outbound;
}

export function subscribersV1ControllerMarkAllUnreadAsReadRequestToJSON(
  subscribersV1ControllerMarkAllUnreadAsReadRequest: SubscribersV1ControllerMarkAllUnreadAsReadRequest
): string {
  return JSON.stringify(
    SubscribersV1ControllerMarkAllUnreadAsReadRequest$outboundSchema.parse(
      subscribersV1ControllerMarkAllUnreadAsReadRequest
    )
  );
}

export function subscribersV1ControllerMarkAllUnreadAsReadRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerMarkAllUnreadAsReadRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerMarkAllUnreadAsReadRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerMarkAllUnreadAsReadRequest' from JSON`
  );
}

/** @internal */
export const SubscribersV1ControllerMarkAllUnreadAsReadResponse$inboundSchema: z.ZodType<
  SubscribersV1ControllerMarkAllUnreadAsReadResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: z.number(),
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersV1ControllerMarkAllUnreadAsReadResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: number;
};

/** @internal */
export const SubscribersV1ControllerMarkAllUnreadAsReadResponse$outboundSchema: z.ZodType<
  SubscribersV1ControllerMarkAllUnreadAsReadResponse$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerMarkAllUnreadAsReadResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: z.number(),
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerMarkAllUnreadAsReadResponse$ {
  /** @deprecated use `SubscribersV1ControllerMarkAllUnreadAsReadResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerMarkAllUnreadAsReadResponse$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerMarkAllUnreadAsReadResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerMarkAllUnreadAsReadResponse$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerMarkAllUnreadAsReadResponse$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerMarkAllUnreadAsReadResponse$Outbound;
}

export function subscribersV1ControllerMarkAllUnreadAsReadResponseToJSON(
  subscribersV1ControllerMarkAllUnreadAsReadResponse: SubscribersV1ControllerMarkAllUnreadAsReadResponse
): string {
  return JSON.stringify(
    SubscribersV1ControllerMarkAllUnreadAsReadResponse$outboundSchema.parse(
      subscribersV1ControllerMarkAllUnreadAsReadResponse
    )
  );
}

export function subscribersV1ControllerMarkAllUnreadAsReadResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerMarkAllUnreadAsReadResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerMarkAllUnreadAsReadResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerMarkAllUnreadAsReadResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersV1ControllerMarkAllUnreadAsReadRequestToJSON(subscribersV1ControllerMarkAllUnreadAsReadRequest: SubscribersV1ControllerMarkAllUnreadAsReadRequest)
 - subscribersV1ControllerMarkAllUnreadAsReadRequestFromJSON(jsonString: string)
 - subscribersV1ControllerMarkAllUnreadAsReadResponseToJSON(subscribersV1ControllerMarkAllUnreadAsReadResponse: SubscribersV1ControllerMarkAllUnreadAsReadResponse)
 - subscribersV1ControllerMarkAllUnreadAsReadResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersV1ControllerMarkAllUnreadAsReadRequest$Outbound;
}

export function subscribersV1Controll...)
 - Outbound(SubscribersV1ControllerMarkAllUnreadAsReadResponse$Outbound;
}

export function subscribersV1Control...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerMarkAllUnreadAsReadRequestToJSON
- export function subscribersV1ControllerMarkAllUnreadAsReadRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerMarkAllUnreadAsReadResponseToJSON
- export function subscribersV1ControllerMarkAllUnreadAsReadResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscribersv1controllermarkmessagesas.ts
Tamaño: 6162 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscribersV1ControllerMarkMessagesAsRequest = {
  subscriberId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  messageMarkAsRequestDto: components.MessageMarkAsRequestDto;
};

export type SubscribersV1ControllerMarkMessagesAsResponse = {
  headers: { [k: string]: Array<string> };
  result: Array<components.MessageResponseDto>;
};

/** @internal */
export const SubscribersV1ControllerMarkMessagesAsRequest$inboundSchema: z.ZodType<
  SubscribersV1ControllerMarkMessagesAsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    subscriberId: z.string(),
    'idempotency-key': z.string().optional(),
    MessageMarkAsRequestDto: components.MessageMarkAsRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      MessageMarkAsRequestDto: 'messageMarkAsRequestDto',
    });
  });

/** @internal */
export type SubscribersV1ControllerMarkMessagesAsRequest$Outbound = {
  subscriberId: string;
  'idempotency-key'?: string | undefined;
  MessageMarkAsRequestDto: components.MessageMarkAsRequestDto$Outbound;
};

/** @internal */
export const SubscribersV1ControllerMarkMessagesAsRequest$outboundSchema: z.ZodType<
  SubscribersV1ControllerMarkMessagesAsRequest$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerMarkMessagesAsRequest
> = z
  .object({
    subscriberId: z.string(),
    idempotencyKey: z.string().optional(),
    messageMarkAsRequestDto: components.MessageMarkAsRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      messageMarkAsRequestDto: 'MessageMarkAsRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerMarkMessagesAsRequest$ {
  /** @deprecated use `SubscribersV1ControllerMarkMessagesAsRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerMarkMessagesAsRequest$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerMarkMessagesAsRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerMarkMessagesAsRequest$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerMarkMessagesAsRequest$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerMarkMessagesAsRequest$Outbound;
}

export function subscribersV1ControllerMarkMessagesAsRequestToJSON(
  subscribersV1ControllerMarkMessagesAsRequest: SubscribersV1ControllerMarkMessagesAsRequest
): string {
  return JSON.stringify(
    SubscribersV1ControllerMarkMessagesAsRequest$outboundSchema.parse(subscribersV1ControllerMarkMessagesAsRequest)
  );
}

export function subscribersV1ControllerMarkMessagesAsRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerMarkMessagesAsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerMarkMessagesAsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerMarkMessagesAsRequest' from JSON`
  );
}

/** @internal */
export const SubscribersV1ControllerMarkMessagesAsResponse$inboundSchema: z.ZodType<
  SubscribersV1ControllerMarkMessagesAsResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: z.array(components.MessageResponseDto$inboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersV1ControllerMarkMessagesAsResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: Array<components.MessageResponseDto$Outbound>;
};

/** @internal */
export const SubscribersV1ControllerMarkMessagesAsResponse$outboundSchema: z.ZodType<
  SubscribersV1ControllerMarkMessagesAsResponse$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerMarkMessagesAsResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: z.array(components.MessageResponseDto$outboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerMarkMessagesAsResponse$ {
  /** @deprecated use `SubscribersV1ControllerMarkMessagesAsResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerMarkMessagesAsResponse$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerMarkMessagesAsResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerMarkMessagesAsResponse$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerMarkMessagesAsResponse$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerMarkMessagesAsResponse$Outbound;
}

export function subscribersV1ControllerMarkMessagesAsResponseToJSON(
  subscribersV1ControllerMarkMessagesAsResponse: SubscribersV1ControllerMarkMessagesAsResponse
): string {
  return JSON.stringify(
    SubscribersV1ControllerMarkMessagesAsResponse$outboundSchema.parse(subscribersV1ControllerMarkMessagesAsResponse)
  );
}

export function subscribersV1ControllerMarkMessagesAsResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerMarkMessagesAsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerMarkMessagesAsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerMarkMessagesAsResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersV1ControllerMarkMessagesAsRequestToJSON(subscribersV1ControllerMarkMessagesAsRequest: SubscribersV1ControllerMarkMessagesAsRequest)
 - subscribersV1ControllerMarkMessagesAsRequestFromJSON(jsonString: string)
 - subscribersV1ControllerMarkMessagesAsResponseToJSON(subscribersV1ControllerMarkMessagesAsResponse: SubscribersV1ControllerMarkMessagesAsResponse)
 - subscribersV1ControllerMarkMessagesAsResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersV1ControllerMarkMessagesAsRequest$Outbound;
}

export function subscribersV1ControllerMar...)
 - Outbound(SubscribersV1ControllerMarkMessagesAsResponse$Outbound;
}

export function subscribersV1ControllerMa...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerMarkMessagesAsRequestToJSON
- export function subscribersV1ControllerMarkMessagesAsRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerMarkMessagesAsResponseToJSON
- export function subscribersV1ControllerMarkMessagesAsResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscribersv1controllermodifysubscriberchannel.ts
Tamaño: 6700 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscribersV1ControllerModifySubscriberChannelRequest = {
  subscriberId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  updateSubscriberChannelRequestDto: components.UpdateSubscriberChannelRequestDto;
};

export type SubscribersV1ControllerModifySubscriberChannelResponse = {
  headers: { [k: string]: Array<string> };
  result: components.SubscriberResponseDto;
};

/** @internal */
export const SubscribersV1ControllerModifySubscriberChannelRequest$inboundSchema: z.ZodType<
  SubscribersV1ControllerModifySubscriberChannelRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    subscriberId: z.string(),
    'idempotency-key': z.string().optional(),
    UpdateSubscriberChannelRequestDto: components.UpdateSubscriberChannelRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      UpdateSubscriberChannelRequestDto: 'updateSubscriberChannelRequestDto',
    });
  });

/** @internal */
export type SubscribersV1ControllerModifySubscriberChannelRequest$Outbound = {
  subscriberId: string;
  'idempotency-key'?: string | undefined;
  UpdateSubscriberChannelRequestDto: components.UpdateSubscriberChannelRequestDto$Outbound;
};

/** @internal */
export const SubscribersV1ControllerModifySubscriberChannelRequest$outboundSchema: z.ZodType<
  SubscribersV1ControllerModifySubscriberChannelRequest$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerModifySubscriberChannelRequest
> = z
  .object({
    subscriberId: z.string(),
    idempotencyKey: z.string().optional(),
    updateSubscriberChannelRequestDto: components.UpdateSubscriberChannelRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      updateSubscriberChannelRequestDto: 'UpdateSubscriberChannelRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerModifySubscriberChannelRequest$ {
  /** @deprecated use `SubscribersV1ControllerModifySubscriberChannelRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerModifySubscriberChannelRequest$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerModifySubscriberChannelRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerModifySubscriberChannelRequest$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerModifySubscriberChannelRequest$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerModifySubscriberChannelRequest$Outbound;
}

export function subscribersV1ControllerModifySubscriberChannelRequestToJSON(
  subscribersV1ControllerModifySubscriberChannelRequest: SubscribersV1ControllerModifySubscriberChannelRequest
): string {
  return JSON.stringify(
    SubscribersV1ControllerModifySubscriberChannelRequest$outboundSchema.parse(
      subscribersV1ControllerModifySubscriberChannelRequest
    )
  );
}

export function subscribersV1ControllerModifySubscriberChannelRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerModifySubscriberChannelRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerModifySubscriberChannelRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerModifySubscriberChannelRequest' from JSON`
  );
}

/** @internal */
export const SubscribersV1ControllerModifySubscriberChannelResponse$inboundSchema: z.ZodType<
  SubscribersV1ControllerModifySubscriberChannelResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.SubscriberResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersV1ControllerModifySubscriberChannelResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.SubscriberResponseDto$Outbound;
};

/** @internal */
export const SubscribersV1ControllerModifySubscriberChannelResponse$outboundSchema: z.ZodType<
  SubscribersV1ControllerModifySubscriberChannelResponse$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerModifySubscriberChannelResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.SubscriberResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerModifySubscriberChannelResponse$ {
  /** @deprecated use `SubscribersV1ControllerModifySubscriberChannelResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerModifySubscriberChannelResponse$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerModifySubscriberChannelResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerModifySubscriberChannelResponse$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerModifySubscriberChannelResponse$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerModifySubscriberChannelResponse$Outbound;
}

export function subscribersV1ControllerModifySubscriberChannelResponseToJSON(
  subscribersV1ControllerModifySubscriberChannelResponse: SubscribersV1ControllerModifySubscriberChannelResponse
): string {
  return JSON.stringify(
    SubscribersV1ControllerModifySubscriberChannelResponse$outboundSchema.parse(
      subscribersV1ControllerModifySubscriberChannelResponse
    )
  );
}

export function subscribersV1ControllerModifySubscriberChannelResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerModifySubscriberChannelResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerModifySubscriberChannelResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerModifySubscriberChannelResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersV1ControllerModifySubscriberChannelRequestToJSON(subscribersV1ControllerModifySubscriberChannelRequest: SubscribersV1ControllerModifySubscriberChannelRequest)
 - subscribersV1ControllerModifySubscriberChannelRequestFromJSON(jsonString: string)
 - subscribersV1ControllerModifySubscriberChannelResponseToJSON(subscribersV1ControllerModifySubscriberChannelResponse: SubscribersV1ControllerModifySubscriberChannelResponse)
 - subscribersV1ControllerModifySubscriberChannelResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersV1ControllerModifySubscriberChannelRequest$Outbound;
}

export function subscribersV1Cont...)
 - Outbound(SubscribersV1ControllerModifySubscriberChannelResponse$Outbound;
}

export function subscribersV1Con...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerModifySubscriberChannelRequestToJSON
- export function subscribersV1ControllerModifySubscriberChannelRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerModifySubscriberChannelResponseToJSON
- export function subscribersV1ControllerModifySubscriberChannelResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscribersv1controllerupdatesubscriberchannel.ts
Tamaño: 6700 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscribersV1ControllerUpdateSubscriberChannelRequest = {
  subscriberId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  updateSubscriberChannelRequestDto: components.UpdateSubscriberChannelRequestDto;
};

export type SubscribersV1ControllerUpdateSubscriberChannelResponse = {
  headers: { [k: string]: Array<string> };
  result: components.SubscriberResponseDto;
};

/** @internal */
export const SubscribersV1ControllerUpdateSubscriberChannelRequest$inboundSchema: z.ZodType<
  SubscribersV1ControllerUpdateSubscriberChannelRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    subscriberId: z.string(),
    'idempotency-key': z.string().optional(),
    UpdateSubscriberChannelRequestDto: components.UpdateSubscriberChannelRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      UpdateSubscriberChannelRequestDto: 'updateSubscriberChannelRequestDto',
    });
  });

/** @internal */
export type SubscribersV1ControllerUpdateSubscriberChannelRequest$Outbound = {
  subscriberId: string;
  'idempotency-key'?: string | undefined;
  UpdateSubscriberChannelRequestDto: components.UpdateSubscriberChannelRequestDto$Outbound;
};

/** @internal */
export const SubscribersV1ControllerUpdateSubscriberChannelRequest$outboundSchema: z.ZodType<
  SubscribersV1ControllerUpdateSubscriberChannelRequest$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerUpdateSubscriberChannelRequest
> = z
  .object({
    subscriberId: z.string(),
    idempotencyKey: z.string().optional(),
    updateSubscriberChannelRequestDto: components.UpdateSubscriberChannelRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      updateSubscriberChannelRequestDto: 'UpdateSubscriberChannelRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerUpdateSubscriberChannelRequest$ {
  /** @deprecated use `SubscribersV1ControllerUpdateSubscriberChannelRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerUpdateSubscriberChannelRequest$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerUpdateSubscriberChannelRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerUpdateSubscriberChannelRequest$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerUpdateSubscriberChannelRequest$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerUpdateSubscriberChannelRequest$Outbound;
}

export function subscribersV1ControllerUpdateSubscriberChannelRequestToJSON(
  subscribersV1ControllerUpdateSubscriberChannelRequest: SubscribersV1ControllerUpdateSubscriberChannelRequest
): string {
  return JSON.stringify(
    SubscribersV1ControllerUpdateSubscriberChannelRequest$outboundSchema.parse(
      subscribersV1ControllerUpdateSubscriberChannelRequest
    )
  );
}

export function subscribersV1ControllerUpdateSubscriberChannelRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerUpdateSubscriberChannelRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerUpdateSubscriberChannelRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerUpdateSubscriberChannelRequest' from JSON`
  );
}

/** @internal */
export const SubscribersV1ControllerUpdateSubscriberChannelResponse$inboundSchema: z.ZodType<
  SubscribersV1ControllerUpdateSubscriberChannelResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.SubscriberResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersV1ControllerUpdateSubscriberChannelResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.SubscriberResponseDto$Outbound;
};

/** @internal */
export const SubscribersV1ControllerUpdateSubscriberChannelResponse$outboundSchema: z.ZodType<
  SubscribersV1ControllerUpdateSubscriberChannelResponse$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerUpdateSubscriberChannelResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.SubscriberResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerUpdateSubscriberChannelResponse$ {
  /** @deprecated use `SubscribersV1ControllerUpdateSubscriberChannelResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerUpdateSubscriberChannelResponse$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerUpdateSubscriberChannelResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerUpdateSubscriberChannelResponse$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerUpdateSubscriberChannelResponse$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerUpdateSubscriberChannelResponse$Outbound;
}

export function subscribersV1ControllerUpdateSubscriberChannelResponseToJSON(
  subscribersV1ControllerUpdateSubscriberChannelResponse: SubscribersV1ControllerUpdateSubscriberChannelResponse
): string {
  return JSON.stringify(
    SubscribersV1ControllerUpdateSubscriberChannelResponse$outboundSchema.parse(
      subscribersV1ControllerUpdateSubscriberChannelResponse
    )
  );
}

export function subscribersV1ControllerUpdateSubscriberChannelResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerUpdateSubscriberChannelResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerUpdateSubscriberChannelResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerUpdateSubscriberChannelResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersV1ControllerUpdateSubscriberChannelRequestToJSON(subscribersV1ControllerUpdateSubscriberChannelRequest: SubscribersV1ControllerUpdateSubscriberChannelRequest)
 - subscribersV1ControllerUpdateSubscriberChannelRequestFromJSON(jsonString: string)
 - subscribersV1ControllerUpdateSubscriberChannelResponseToJSON(subscribersV1ControllerUpdateSubscriberChannelResponse: SubscribersV1ControllerUpdateSubscriberChannelResponse)
 - subscribersV1ControllerUpdateSubscriberChannelResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersV1ControllerUpdateSubscriberChannelRequest$Outbound;
}

export function subscribersV1Cont...)
 - Outbound(SubscribersV1ControllerUpdateSubscriberChannelResponse$Outbound;
}

export function subscribersV1Con...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerUpdateSubscriberChannelRequestToJSON
- export function subscribersV1ControllerUpdateSubscriberChannelRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerUpdateSubscriberChannelResponseToJSON
- export function subscribersV1ControllerUpdateSubscriberChannelResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/subscribersv1controllerupdatesubscriberonlineflag.ts
Tamaño: 6874 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest = {
  subscriberId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  updateSubscriberOnlineFlagRequestDto: components.UpdateSubscriberOnlineFlagRequestDto;
};

export type SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse = {
  headers: { [k: string]: Array<string> };
  result: components.SubscriberResponseDto;
};

/** @internal */
export const SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest$inboundSchema: z.ZodType<
  SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    subscriberId: z.string(),
    'idempotency-key': z.string().optional(),
    UpdateSubscriberOnlineFlagRequestDto: components.UpdateSubscriberOnlineFlagRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      UpdateSubscriberOnlineFlagRequestDto: 'updateSubscriberOnlineFlagRequestDto',
    });
  });

/** @internal */
export type SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest$Outbound = {
  subscriberId: string;
  'idempotency-key'?: string | undefined;
  UpdateSubscriberOnlineFlagRequestDto: components.UpdateSubscriberOnlineFlagRequestDto$Outbound;
};

/** @internal */
export const SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest$outboundSchema: z.ZodType<
  SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest
> = z
  .object({
    subscriberId: z.string(),
    idempotencyKey: z.string().optional(),
    updateSubscriberOnlineFlagRequestDto: components.UpdateSubscriberOnlineFlagRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      updateSubscriberOnlineFlagRequestDto: 'UpdateSubscriberOnlineFlagRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest$ {
  /** @deprecated use `SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest$Outbound;
}

export function subscribersV1ControllerUpdateSubscriberOnlineFlagRequestToJSON(
  subscribersV1ControllerUpdateSubscriberOnlineFlagRequest: SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest
): string {
  return JSON.stringify(
    SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest$outboundSchema.parse(
      subscribersV1ControllerUpdateSubscriberOnlineFlagRequest
    )
  );
}

export function subscribersV1ControllerUpdateSubscriberOnlineFlagRequestFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest' from JSON`
  );
}

/** @internal */
export const SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse$inboundSchema: z.ZodType<
  SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.SubscriberResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.SubscriberResponseDto$Outbound;
};

/** @internal */
export const SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse$outboundSchema: z.ZodType<
  SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse$Outbound,
  z.ZodTypeDef,
  SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.SubscriberResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse$ {
  /** @deprecated use `SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse$inboundSchema` instead. */
  export const inboundSchema = SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse$inboundSchema;
  /** @deprecated use `SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse$outboundSchema` instead. */
  export const outboundSchema = SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse$outboundSchema;
  /** @deprecated use `SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse$Outbound` instead. */
  export type Outbound = SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse$Outbound;
}

export function subscribersV1ControllerUpdateSubscriberOnlineFlagResponseToJSON(
  subscribersV1ControllerUpdateSubscriberOnlineFlagResponse: SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse
): string {
  return JSON.stringify(
    SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse$outboundSchema.parse(
      subscribersV1ControllerUpdateSubscriberOnlineFlagResponse
    )
  );
}

export function subscribersV1ControllerUpdateSubscriberOnlineFlagResponseFromJSON(
  jsonString: string
): SafeParseResult<SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersV1ControllerUpdateSubscriberOnlineFlagRequestToJSON(subscribersV1ControllerUpdateSubscriberOnlineFlagRequest: SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest)
 - subscribersV1ControllerUpdateSubscriberOnlineFlagRequestFromJSON(jsonString: string)
 - subscribersV1ControllerUpdateSubscriberOnlineFlagResponseToJSON(subscribersV1ControllerUpdateSubscriberOnlineFlagResponse: SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse)
 - subscribersV1ControllerUpdateSubscriberOnlineFlagResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest$Outbound;
}

export function subscribersV1C...)
 - Outbound(SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse$Outbound;
}

export function subscribersV1...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerUpdateSubscriberOnlineFlagRequestToJSON
- export function subscribersV1ControllerUpdateSubscriberOnlineFlagRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function subscribersV1ControllerUpdateSubscriberOnlineFlagResponseToJSON
- export function subscribersV1ControllerUpdateSubscriberOnlineFlagResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/topicscontrollercreatetopicsubscriptions.ts
Tamaño: 6525 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TopicsControllerCreateTopicSubscriptionsRequest = {
  /**
   * The key identifier of the topic
   */
  topicKey: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  createTopicSubscriptionsRequestDto: components.CreateTopicSubscriptionsRequestDto;
};

export type TopicsControllerCreateTopicSubscriptionsResponse = {
  headers: { [k: string]: Array<string> };
  result: components.CreateTopicSubscriptionsResponseDto;
};

/** @internal */
export const TopicsControllerCreateTopicSubscriptionsRequest$inboundSchema: z.ZodType<
  TopicsControllerCreateTopicSubscriptionsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    topicKey: z.string(),
    'idempotency-key': z.string().optional(),
    CreateTopicSubscriptionsRequestDto: components.CreateTopicSubscriptionsRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      CreateTopicSubscriptionsRequestDto: 'createTopicSubscriptionsRequestDto',
    });
  });

/** @internal */
export type TopicsControllerCreateTopicSubscriptionsRequest$Outbound = {
  topicKey: string;
  'idempotency-key'?: string | undefined;
  CreateTopicSubscriptionsRequestDto: components.CreateTopicSubscriptionsRequestDto$Outbound;
};

/** @internal */
export const TopicsControllerCreateTopicSubscriptionsRequest$outboundSchema: z.ZodType<
  TopicsControllerCreateTopicSubscriptionsRequest$Outbound,
  z.ZodTypeDef,
  TopicsControllerCreateTopicSubscriptionsRequest
> = z
  .object({
    topicKey: z.string(),
    idempotencyKey: z.string().optional(),
    createTopicSubscriptionsRequestDto: components.CreateTopicSubscriptionsRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      createTopicSubscriptionsRequestDto: 'CreateTopicSubscriptionsRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerCreateTopicSubscriptionsRequest$ {
  /** @deprecated use `TopicsControllerCreateTopicSubscriptionsRequest$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerCreateTopicSubscriptionsRequest$inboundSchema;
  /** @deprecated use `TopicsControllerCreateTopicSubscriptionsRequest$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerCreateTopicSubscriptionsRequest$outboundSchema;
  /** @deprecated use `TopicsControllerCreateTopicSubscriptionsRequest$Outbound` instead. */
  export type Outbound = TopicsControllerCreateTopicSubscriptionsRequest$Outbound;
}

export function topicsControllerCreateTopicSubscriptionsRequestToJSON(
  topicsControllerCreateTopicSubscriptionsRequest: TopicsControllerCreateTopicSubscriptionsRequest
): string {
  return JSON.stringify(
    TopicsControllerCreateTopicSubscriptionsRequest$outboundSchema.parse(
      topicsControllerCreateTopicSubscriptionsRequest
    )
  );
}

export function topicsControllerCreateTopicSubscriptionsRequestFromJSON(
  jsonString: string
): SafeParseResult<TopicsControllerCreateTopicSubscriptionsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsControllerCreateTopicSubscriptionsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsControllerCreateTopicSubscriptionsRequest' from JSON`
  );
}

/** @internal */
export const TopicsControllerCreateTopicSubscriptionsResponse$inboundSchema: z.ZodType<
  TopicsControllerCreateTopicSubscriptionsResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.CreateTopicSubscriptionsResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type TopicsControllerCreateTopicSubscriptionsResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.CreateTopicSubscriptionsResponseDto$Outbound;
};

/** @internal */
export const TopicsControllerCreateTopicSubscriptionsResponse$outboundSchema: z.ZodType<
  TopicsControllerCreateTopicSubscriptionsResponse$Outbound,
  z.ZodTypeDef,
  TopicsControllerCreateTopicSubscriptionsResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.CreateTopicSubscriptionsResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerCreateTopicSubscriptionsResponse$ {
  /** @deprecated use `TopicsControllerCreateTopicSubscriptionsResponse$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerCreateTopicSubscriptionsResponse$inboundSchema;
  /** @deprecated use `TopicsControllerCreateTopicSubscriptionsResponse$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerCreateTopicSubscriptionsResponse$outboundSchema;
  /** @deprecated use `TopicsControllerCreateTopicSubscriptionsResponse$Outbound` instead. */
  export type Outbound = TopicsControllerCreateTopicSubscriptionsResponse$Outbound;
}

export function topicsControllerCreateTopicSubscriptionsResponseToJSON(
  topicsControllerCreateTopicSubscriptionsResponse: TopicsControllerCreateTopicSubscriptionsResponse
): string {
  return JSON.stringify(
    TopicsControllerCreateTopicSubscriptionsResponse$outboundSchema.parse(
      topicsControllerCreateTopicSubscriptionsResponse
    )
  );
}

export function topicsControllerCreateTopicSubscriptionsResponseFromJSON(
  jsonString: string
): SafeParseResult<TopicsControllerCreateTopicSubscriptionsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsControllerCreateTopicSubscriptionsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsControllerCreateTopicSubscriptionsResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicsControllerCreateTopicSubscriptionsRequestToJSON(topicsControllerCreateTopicSubscriptionsRequest: TopicsControllerCreateTopicSubscriptionsRequest)
 - topicsControllerCreateTopicSubscriptionsRequestFromJSON(jsonString: string)
 - topicsControllerCreateTopicSubscriptionsResponseToJSON(topicsControllerCreateTopicSubscriptionsResponse: TopicsControllerCreateTopicSubscriptionsResponse)
 - topicsControllerCreateTopicSubscriptionsResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TopicsControllerCreateTopicSubscriptionsRequest$Outbound;
}

export function topicsControllerCreateT...)
 - Outbound(TopicsControllerCreateTopicSubscriptionsResponse$Outbound;
}

export function topicsControllerCreate...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsControllerCreateTopicSubscriptionsRequestToJSON
- export function topicsControllerCreateTopicSubscriptionsRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsControllerCreateTopicSubscriptionsResponseToJSON
- export function topicsControllerCreateTopicSubscriptionsResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/topicscontrollerdeletetopic.ts
Tamaño: 5293 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TopicsControllerDeleteTopicRequest = {
  /**
   * The key identifier of the topic
   */
  topicKey: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type TopicsControllerDeleteTopicResponse = {
  headers: { [k: string]: Array<string> };
  result: components.DeleteTopicResponseDto;
};

/** @internal */
export const TopicsControllerDeleteTopicRequest$inboundSchema: z.ZodType<
  TopicsControllerDeleteTopicRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    topicKey: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type TopicsControllerDeleteTopicRequest$Outbound = {
  topicKey: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const TopicsControllerDeleteTopicRequest$outboundSchema: z.ZodType<
  TopicsControllerDeleteTopicRequest$Outbound,
  z.ZodTypeDef,
  TopicsControllerDeleteTopicRequest
> = z
  .object({
    topicKey: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerDeleteTopicRequest$ {
  /** @deprecated use `TopicsControllerDeleteTopicRequest$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerDeleteTopicRequest$inboundSchema;
  /** @deprecated use `TopicsControllerDeleteTopicRequest$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerDeleteTopicRequest$outboundSchema;
  /** @deprecated use `TopicsControllerDeleteTopicRequest$Outbound` instead. */
  export type Outbound = TopicsControllerDeleteTopicRequest$Outbound;
}

export function topicsControllerDeleteTopicRequestToJSON(
  topicsControllerDeleteTopicRequest: TopicsControllerDeleteTopicRequest
): string {
  return JSON.stringify(TopicsControllerDeleteTopicRequest$outboundSchema.parse(topicsControllerDeleteTopicRequest));
}

export function topicsControllerDeleteTopicRequestFromJSON(
  jsonString: string
): SafeParseResult<TopicsControllerDeleteTopicRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsControllerDeleteTopicRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsControllerDeleteTopicRequest' from JSON`
  );
}

/** @internal */
export const TopicsControllerDeleteTopicResponse$inboundSchema: z.ZodType<
  TopicsControllerDeleteTopicResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.DeleteTopicResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type TopicsControllerDeleteTopicResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.DeleteTopicResponseDto$Outbound;
};

/** @internal */
export const TopicsControllerDeleteTopicResponse$outboundSchema: z.ZodType<
  TopicsControllerDeleteTopicResponse$Outbound,
  z.ZodTypeDef,
  TopicsControllerDeleteTopicResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.DeleteTopicResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerDeleteTopicResponse$ {
  /** @deprecated use `TopicsControllerDeleteTopicResponse$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerDeleteTopicResponse$inboundSchema;
  /** @deprecated use `TopicsControllerDeleteTopicResponse$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerDeleteTopicResponse$outboundSchema;
  /** @deprecated use `TopicsControllerDeleteTopicResponse$Outbound` instead. */
  export type Outbound = TopicsControllerDeleteTopicResponse$Outbound;
}

export function topicsControllerDeleteTopicResponseToJSON(
  topicsControllerDeleteTopicResponse: TopicsControllerDeleteTopicResponse
): string {
  return JSON.stringify(TopicsControllerDeleteTopicResponse$outboundSchema.parse(topicsControllerDeleteTopicResponse));
}

export function topicsControllerDeleteTopicResponseFromJSON(
  jsonString: string
): SafeParseResult<TopicsControllerDeleteTopicResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsControllerDeleteTopicResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsControllerDeleteTopicResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicsControllerDeleteTopicRequestToJSON(topicsControllerDeleteTopicRequest: TopicsControllerDeleteTopicRequest)
 - topicsControllerDeleteTopicRequestFromJSON(jsonString: string)
 - topicsControllerDeleteTopicResponseToJSON(topicsControllerDeleteTopicResponse: TopicsControllerDeleteTopicResponse)
 - topicsControllerDeleteTopicResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TopicsControllerDeleteTopicRequest$Outbound;
}

export function topicsControllerDeleteTopicRequestTo...)
 - Outbound(TopicsControllerDeleteTopicResponse$Outbound;
}

export function topicsControllerDeleteTopicResponse...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsControllerDeleteTopicRequestToJSON
- export function topicsControllerDeleteTopicRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsControllerDeleteTopicResponseToJSON
- export function topicsControllerDeleteTopicResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/topicscontrollerdeletetopicsubscriptions.ts
Tamaño: 6525 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TopicsControllerDeleteTopicSubscriptionsRequest = {
  /**
   * The key identifier of the topic
   */
  topicKey: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  deleteTopicSubscriptionsRequestDto: components.DeleteTopicSubscriptionsRequestDto;
};

export type TopicsControllerDeleteTopicSubscriptionsResponse = {
  headers: { [k: string]: Array<string> };
  result: components.DeleteTopicSubscriptionsResponseDto;
};

/** @internal */
export const TopicsControllerDeleteTopicSubscriptionsRequest$inboundSchema: z.ZodType<
  TopicsControllerDeleteTopicSubscriptionsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    topicKey: z.string(),
    'idempotency-key': z.string().optional(),
    DeleteTopicSubscriptionsRequestDto: components.DeleteTopicSubscriptionsRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      DeleteTopicSubscriptionsRequestDto: 'deleteTopicSubscriptionsRequestDto',
    });
  });

/** @internal */
export type TopicsControllerDeleteTopicSubscriptionsRequest$Outbound = {
  topicKey: string;
  'idempotency-key'?: string | undefined;
  DeleteTopicSubscriptionsRequestDto: components.DeleteTopicSubscriptionsRequestDto$Outbound;
};

/** @internal */
export const TopicsControllerDeleteTopicSubscriptionsRequest$outboundSchema: z.ZodType<
  TopicsControllerDeleteTopicSubscriptionsRequest$Outbound,
  z.ZodTypeDef,
  TopicsControllerDeleteTopicSubscriptionsRequest
> = z
  .object({
    topicKey: z.string(),
    idempotencyKey: z.string().optional(),
    deleteTopicSubscriptionsRequestDto: components.DeleteTopicSubscriptionsRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      deleteTopicSubscriptionsRequestDto: 'DeleteTopicSubscriptionsRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerDeleteTopicSubscriptionsRequest$ {
  /** @deprecated use `TopicsControllerDeleteTopicSubscriptionsRequest$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerDeleteTopicSubscriptionsRequest$inboundSchema;
  /** @deprecated use `TopicsControllerDeleteTopicSubscriptionsRequest$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerDeleteTopicSubscriptionsRequest$outboundSchema;
  /** @deprecated use `TopicsControllerDeleteTopicSubscriptionsRequest$Outbound` instead. */
  export type Outbound = TopicsControllerDeleteTopicSubscriptionsRequest$Outbound;
}

export function topicsControllerDeleteTopicSubscriptionsRequestToJSON(
  topicsControllerDeleteTopicSubscriptionsRequest: TopicsControllerDeleteTopicSubscriptionsRequest
): string {
  return JSON.stringify(
    TopicsControllerDeleteTopicSubscriptionsRequest$outboundSchema.parse(
      topicsControllerDeleteTopicSubscriptionsRequest
    )
  );
}

export function topicsControllerDeleteTopicSubscriptionsRequestFromJSON(
  jsonString: string
): SafeParseResult<TopicsControllerDeleteTopicSubscriptionsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsControllerDeleteTopicSubscriptionsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsControllerDeleteTopicSubscriptionsRequest' from JSON`
  );
}

/** @internal */
export const TopicsControllerDeleteTopicSubscriptionsResponse$inboundSchema: z.ZodType<
  TopicsControllerDeleteTopicSubscriptionsResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.DeleteTopicSubscriptionsResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type TopicsControllerDeleteTopicSubscriptionsResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.DeleteTopicSubscriptionsResponseDto$Outbound;
};

/** @internal */
export const TopicsControllerDeleteTopicSubscriptionsResponse$outboundSchema: z.ZodType<
  TopicsControllerDeleteTopicSubscriptionsResponse$Outbound,
  z.ZodTypeDef,
  TopicsControllerDeleteTopicSubscriptionsResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.DeleteTopicSubscriptionsResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerDeleteTopicSubscriptionsResponse$ {
  /** @deprecated use `TopicsControllerDeleteTopicSubscriptionsResponse$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerDeleteTopicSubscriptionsResponse$inboundSchema;
  /** @deprecated use `TopicsControllerDeleteTopicSubscriptionsResponse$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerDeleteTopicSubscriptionsResponse$outboundSchema;
  /** @deprecated use `TopicsControllerDeleteTopicSubscriptionsResponse$Outbound` instead. */
  export type Outbound = TopicsControllerDeleteTopicSubscriptionsResponse$Outbound;
}

export function topicsControllerDeleteTopicSubscriptionsResponseToJSON(
  topicsControllerDeleteTopicSubscriptionsResponse: TopicsControllerDeleteTopicSubscriptionsResponse
): string {
  return JSON.stringify(
    TopicsControllerDeleteTopicSubscriptionsResponse$outboundSchema.parse(
      topicsControllerDeleteTopicSubscriptionsResponse
    )
  );
}

export function topicsControllerDeleteTopicSubscriptionsResponseFromJSON(
  jsonString: string
): SafeParseResult<TopicsControllerDeleteTopicSubscriptionsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsControllerDeleteTopicSubscriptionsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsControllerDeleteTopicSubscriptionsResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicsControllerDeleteTopicSubscriptionsRequestToJSON(topicsControllerDeleteTopicSubscriptionsRequest: TopicsControllerDeleteTopicSubscriptionsRequest)
 - topicsControllerDeleteTopicSubscriptionsRequestFromJSON(jsonString: string)
 - topicsControllerDeleteTopicSubscriptionsResponseToJSON(topicsControllerDeleteTopicSubscriptionsResponse: TopicsControllerDeleteTopicSubscriptionsResponse)
 - topicsControllerDeleteTopicSubscriptionsResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TopicsControllerDeleteTopicSubscriptionsRequest$Outbound;
}

export function topicsControllerDeleteT...)
 - Outbound(TopicsControllerDeleteTopicSubscriptionsResponse$Outbound;
}

export function topicsControllerDelete...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsControllerDeleteTopicSubscriptionsRequestToJSON
- export function topicsControllerDeleteTopicSubscriptionsRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsControllerDeleteTopicSubscriptionsResponseToJSON
- export function topicsControllerDeleteTopicSubscriptionsResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/topicscontrollergettopic.ts
Tamaño: 5131 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TopicsControllerGetTopicRequest = {
  /**
   * The key identifier of the topic
   */
  topicKey: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type TopicsControllerGetTopicResponse = {
  headers: { [k: string]: Array<string> };
  result: components.TopicResponseDto;
};

/** @internal */
export const TopicsControllerGetTopicRequest$inboundSchema: z.ZodType<
  TopicsControllerGetTopicRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    topicKey: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type TopicsControllerGetTopicRequest$Outbound = {
  topicKey: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const TopicsControllerGetTopicRequest$outboundSchema: z.ZodType<
  TopicsControllerGetTopicRequest$Outbound,
  z.ZodTypeDef,
  TopicsControllerGetTopicRequest
> = z
  .object({
    topicKey: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerGetTopicRequest$ {
  /** @deprecated use `TopicsControllerGetTopicRequest$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerGetTopicRequest$inboundSchema;
  /** @deprecated use `TopicsControllerGetTopicRequest$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerGetTopicRequest$outboundSchema;
  /** @deprecated use `TopicsControllerGetTopicRequest$Outbound` instead. */
  export type Outbound = TopicsControllerGetTopicRequest$Outbound;
}

export function topicsControllerGetTopicRequestToJSON(
  topicsControllerGetTopicRequest: TopicsControllerGetTopicRequest
): string {
  return JSON.stringify(TopicsControllerGetTopicRequest$outboundSchema.parse(topicsControllerGetTopicRequest));
}

export function topicsControllerGetTopicRequestFromJSON(
  jsonString: string
): SafeParseResult<TopicsControllerGetTopicRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsControllerGetTopicRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsControllerGetTopicRequest' from JSON`
  );
}

/** @internal */
export const TopicsControllerGetTopicResponse$inboundSchema: z.ZodType<
  TopicsControllerGetTopicResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.TopicResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type TopicsControllerGetTopicResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.TopicResponseDto$Outbound;
};

/** @internal */
export const TopicsControllerGetTopicResponse$outboundSchema: z.ZodType<
  TopicsControllerGetTopicResponse$Outbound,
  z.ZodTypeDef,
  TopicsControllerGetTopicResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.TopicResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerGetTopicResponse$ {
  /** @deprecated use `TopicsControllerGetTopicResponse$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerGetTopicResponse$inboundSchema;
  /** @deprecated use `TopicsControllerGetTopicResponse$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerGetTopicResponse$outboundSchema;
  /** @deprecated use `TopicsControllerGetTopicResponse$Outbound` instead. */
  export type Outbound = TopicsControllerGetTopicResponse$Outbound;
}

export function topicsControllerGetTopicResponseToJSON(
  topicsControllerGetTopicResponse: TopicsControllerGetTopicResponse
): string {
  return JSON.stringify(TopicsControllerGetTopicResponse$outboundSchema.parse(topicsControllerGetTopicResponse));
}

export function topicsControllerGetTopicResponseFromJSON(
  jsonString: string
): SafeParseResult<TopicsControllerGetTopicResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsControllerGetTopicResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsControllerGetTopicResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicsControllerGetTopicRequestToJSON(topicsControllerGetTopicRequest: TopicsControllerGetTopicRequest)
 - topicsControllerGetTopicRequestFromJSON(jsonString: string)
 - topicsControllerGetTopicResponseToJSON(topicsControllerGetTopicResponse: TopicsControllerGetTopicResponse)
 - topicsControllerGetTopicResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TopicsControllerGetTopicRequest$Outbound;
}

export function topicsControllerGetTopicRequestToJSON(
...)
 - Outbound(TopicsControllerGetTopicResponse$Outbound;
}

export function topicsControllerGetTopicResponseToJSON...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsControllerGetTopicRequestToJSON
- export function topicsControllerGetTopicRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsControllerGetTopicResponseToJSON
- export function topicsControllerGetTopicResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/topicscontrollerlisttopics.ts
Tamaño: 8322 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Direction of sorting
 */
export const TopicsControllerListTopicsQueryParamOrderDirection = {
  Asc: 'ASC',
  Desc: 'DESC',
} as const;
/**
 * Direction of sorting
 */
export type TopicsControllerListTopicsQueryParamOrderDirection = ClosedEnum<
  typeof TopicsControllerListTopicsQueryParamOrderDirection
>;

export type TopicsControllerListTopicsRequest = {
  /**
   * Cursor for pagination indicating the starting point after which to fetch results.
   */
  after?: string | undefined;
  /**
   * Cursor for pagination indicating the ending point before which to fetch results.
   */
  before?: string | undefined;
  /**
   * Limit the number of items to return (max 100)
   */
  limit?: number | undefined;
  /**
   * Direction of sorting
   */
  orderDirection?: TopicsControllerListTopicsQueryParamOrderDirection | undefined;
  /**
   * Field to order by
   */
  orderBy?: string | undefined;
  /**
   * Include cursor item in response
   */
  includeCursor?: boolean | undefined;
  /**
   * Key of the topic to filter results.
   */
  key?: string | undefined;
  /**
   * Name of the topic to filter results.
   */
  name?: string | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type TopicsControllerListTopicsResponse = {
  headers: { [k: string]: Array<string> };
  result: components.ListTopicsResponseDto;
};

/** @internal */
export const TopicsControllerListTopicsQueryParamOrderDirection$inboundSchema: z.ZodNativeEnum<
  typeof TopicsControllerListTopicsQueryParamOrderDirection
> = z.nativeEnum(TopicsControllerListTopicsQueryParamOrderDirection);

/** @internal */
export const TopicsControllerListTopicsQueryParamOrderDirection$outboundSchema: z.ZodNativeEnum<
  typeof TopicsControllerListTopicsQueryParamOrderDirection
> = TopicsControllerListTopicsQueryParamOrderDirection$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerListTopicsQueryParamOrderDirection$ {
  /** @deprecated use `TopicsControllerListTopicsQueryParamOrderDirection$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerListTopicsQueryParamOrderDirection$inboundSchema;
  /** @deprecated use `TopicsControllerListTopicsQueryParamOrderDirection$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerListTopicsQueryParamOrderDirection$outboundSchema;
}

/** @internal */
export const TopicsControllerListTopicsRequest$inboundSchema: z.ZodType<
  TopicsControllerListTopicsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    after: z.string().optional(),
    before: z.string().optional(),
    limit: z.number().optional(),
    orderDirection: TopicsControllerListTopicsQueryParamOrderDirection$inboundSchema.optional(),
    orderBy: z.string().optional(),
    includeCursor: z.boolean().optional(),
    key: z.string().optional(),
    name: z.string().optional(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type TopicsControllerListTopicsRequest$Outbound = {
  after?: string | undefined;
  before?: string | undefined;
  limit?: number | undefined;
  orderDirection?: string | undefined;
  orderBy?: string | undefined;
  includeCursor?: boolean | undefined;
  key?: string | undefined;
  name?: string | undefined;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const TopicsControllerListTopicsRequest$outboundSchema: z.ZodType<
  TopicsControllerListTopicsRequest$Outbound,
  z.ZodTypeDef,
  TopicsControllerListTopicsRequest
> = z
  .object({
    after: z.string().optional(),
    before: z.string().optional(),
    limit: z.number().optional(),
    orderDirection: TopicsControllerListTopicsQueryParamOrderDirection$outboundSchema.optional(),
    orderBy: z.string().optional(),
    includeCursor: z.boolean().optional(),
    key: z.string().optional(),
    name: z.string().optional(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerListTopicsRequest$ {
  /** @deprecated use `TopicsControllerListTopicsRequest$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerListTopicsRequest$inboundSchema;
  /** @deprecated use `TopicsControllerListTopicsRequest$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerListTopicsRequest$outboundSchema;
  /** @deprecated use `TopicsControllerListTopicsRequest$Outbound` instead. */
  export type Outbound = TopicsControllerListTopicsRequest$Outbound;
}

export function topicsControllerListTopicsRequestToJSON(
  topicsControllerListTopicsRequest: TopicsControllerListTopicsRequest
): string {
  return JSON.stringify(TopicsControllerListTopicsRequest$outboundSchema.parse(topicsControllerListTopicsRequest));
}

export function topicsControllerListTopicsRequestFromJSON(
  jsonString: string
): SafeParseResult<TopicsControllerListTopicsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsControllerListTopicsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsControllerListTopicsRequest' from JSON`
  );
}

/** @internal */
export const TopicsControllerListTopicsResponse$inboundSchema: z.ZodType<
  TopicsControllerListTopicsResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.ListTopicsResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type TopicsControllerListTopicsResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.ListTopicsResponseDto$Outbound;
};

/** @internal */
export const TopicsControllerListTopicsResponse$outboundSchema: z.ZodType<
  TopicsControllerListTopicsResponse$Outbound,
  z.ZodTypeDef,
  TopicsControllerListTopicsResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.ListTopicsResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerListTopicsResponse$ {
  /** @deprecated use `TopicsControllerListTopicsResponse$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerListTopicsResponse$inboundSchema;
  /** @deprecated use `TopicsControllerListTopicsResponse$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerListTopicsResponse$outboundSchema;
  /** @deprecated use `TopicsControllerListTopicsResponse$Outbound` instead. */
  export type Outbound = TopicsControllerListTopicsResponse$Outbound;
}

export function topicsControllerListTopicsResponseToJSON(
  topicsControllerListTopicsResponse: TopicsControllerListTopicsResponse
): string {
  return JSON.stringify(TopicsControllerListTopicsResponse$outboundSchema.parse(topicsControllerListTopicsResponse));
}

export function topicsControllerListTopicsResponseFromJSON(
  jsonString: string
): SafeParseResult<TopicsControllerListTopicsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsControllerListTopicsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsControllerListTopicsResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicsControllerListTopicsRequestToJSON(topicsControllerListTopicsRequest: TopicsControllerListTopicsRequest)
 - topicsControllerListTopicsRequestFromJSON(jsonString: string)
 - topicsControllerListTopicsResponseToJSON(topicsControllerListTopicsResponse: TopicsControllerListTopicsResponse)
 - topicsControllerListTopicsResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TopicsControllerListTopicsRequest$Outbound;
}

export function topicsControllerListTopicsRequestToJS...)
 - Outbound(TopicsControllerListTopicsResponse$Outbound;
}

export function topicsControllerListTopicsResponseTo...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsControllerListTopicsRequestToJSON
- export function topicsControllerListTopicsRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsControllerListTopicsResponseToJSON
- export function topicsControllerListTopicsResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/topicscontrollerlisttopicsubscriptions.ts
Tamaño: 9129 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Direction of sorting
 */
export const TopicsControllerListTopicSubscriptionsQueryParamOrderDirection = {
  Asc: 'ASC',
  Desc: 'DESC',
} as const;
/**
 * Direction of sorting
 */
export type TopicsControllerListTopicSubscriptionsQueryParamOrderDirection = ClosedEnum<
  typeof TopicsControllerListTopicSubscriptionsQueryParamOrderDirection
>;

export type TopicsControllerListTopicSubscriptionsRequest = {
  /**
   * The key identifier of the topic
   */
  topicKey: string;
  /**
   * Cursor for pagination indicating the starting point after which to fetch results.
   */
  after?: string | undefined;
  /**
   * Cursor for pagination indicating the ending point before which to fetch results.
   */
  before?: string | undefined;
  /**
   * Limit the number of items to return (max 100)
   */
  limit?: number | undefined;
  /**
   * Direction of sorting
   */
  orderDirection?: TopicsControllerListTopicSubscriptionsQueryParamOrderDirection | undefined;
  /**
   * Field to order by
   */
  orderBy?: string | undefined;
  /**
   * Include cursor item in response
   */
  includeCursor?: boolean | undefined;
  /**
   * Filter by subscriber ID
   */
  subscriberId?: string | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type TopicsControllerListTopicSubscriptionsResponse = {
  headers: { [k: string]: Array<string> };
  result: components.ListTopicSubscriptionsResponseDto;
};

/** @internal */
export const TopicsControllerListTopicSubscriptionsQueryParamOrderDirection$inboundSchema: z.ZodNativeEnum<
  typeof TopicsControllerListTopicSubscriptionsQueryParamOrderDirection
> = z.nativeEnum(TopicsControllerListTopicSubscriptionsQueryParamOrderDirection);

/** @internal */
export const TopicsControllerListTopicSubscriptionsQueryParamOrderDirection$outboundSchema: z.ZodNativeEnum<
  typeof TopicsControllerListTopicSubscriptionsQueryParamOrderDirection
> = TopicsControllerListTopicSubscriptionsQueryParamOrderDirection$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerListTopicSubscriptionsQueryParamOrderDirection$ {
  /** @deprecated use `TopicsControllerListTopicSubscriptionsQueryParamOrderDirection$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerListTopicSubscriptionsQueryParamOrderDirection$inboundSchema;
  /** @deprecated use `TopicsControllerListTopicSubscriptionsQueryParamOrderDirection$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerListTopicSubscriptionsQueryParamOrderDirection$outboundSchema;
}

/** @internal */
export const TopicsControllerListTopicSubscriptionsRequest$inboundSchema: z.ZodType<
  TopicsControllerListTopicSubscriptionsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    topicKey: z.string(),
    after: z.string().optional(),
    before: z.string().optional(),
    limit: z.number().optional(),
    orderDirection: TopicsControllerListTopicSubscriptionsQueryParamOrderDirection$inboundSchema.optional(),
    orderBy: z.string().optional(),
    includeCursor: z.boolean().optional(),
    subscriberId: z.string().optional(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type TopicsControllerListTopicSubscriptionsRequest$Outbound = {
  topicKey: string;
  after?: string | undefined;
  before?: string | undefined;
  limit?: number | undefined;
  orderDirection?: string | undefined;
  orderBy?: string | undefined;
  includeCursor?: boolean | undefined;
  subscriberId?: string | undefined;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const TopicsControllerListTopicSubscriptionsRequest$outboundSchema: z.ZodType<
  TopicsControllerListTopicSubscriptionsRequest$Outbound,
  z.ZodTypeDef,
  TopicsControllerListTopicSubscriptionsRequest
> = z
  .object({
    topicKey: z.string(),
    after: z.string().optional(),
    before: z.string().optional(),
    limit: z.number().optional(),
    orderDirection: TopicsControllerListTopicSubscriptionsQueryParamOrderDirection$outboundSchema.optional(),
    orderBy: z.string().optional(),
    includeCursor: z.boolean().optional(),
    subscriberId: z.string().optional(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerListTopicSubscriptionsRequest$ {
  /** @deprecated use `TopicsControllerListTopicSubscriptionsRequest$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerListTopicSubscriptionsRequest$inboundSchema;
  /** @deprecated use `TopicsControllerListTopicSubscriptionsRequest$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerListTopicSubscriptionsRequest$outboundSchema;
  /** @deprecated use `TopicsControllerListTopicSubscriptionsRequest$Outbound` instead. */
  export type Outbound = TopicsControllerListTopicSubscriptionsRequest$Outbound;
}

export function topicsControllerListTopicSubscriptionsRequestToJSON(
  topicsControllerListTopicSubscriptionsRequest: TopicsControllerListTopicSubscriptionsRequest
): string {
  return JSON.stringify(
    TopicsControllerListTopicSubscriptionsRequest$outboundSchema.parse(topicsControllerListTopicSubscriptionsRequest)
  );
}

export function topicsControllerListTopicSubscriptionsRequestFromJSON(
  jsonString: string
): SafeParseResult<TopicsControllerListTopicSubscriptionsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsControllerListTopicSubscriptionsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsControllerListTopicSubscriptionsRequest' from JSON`
  );
}

/** @internal */
export const TopicsControllerListTopicSubscriptionsResponse$inboundSchema: z.ZodType<
  TopicsControllerListTopicSubscriptionsResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.ListTopicSubscriptionsResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type TopicsControllerListTopicSubscriptionsResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.ListTopicSubscriptionsResponseDto$Outbound;
};

/** @internal */
export const TopicsControllerListTopicSubscriptionsResponse$outboundSchema: z.ZodType<
  TopicsControllerListTopicSubscriptionsResponse$Outbound,
  z.ZodTypeDef,
  TopicsControllerListTopicSubscriptionsResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.ListTopicSubscriptionsResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerListTopicSubscriptionsResponse$ {
  /** @deprecated use `TopicsControllerListTopicSubscriptionsResponse$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerListTopicSubscriptionsResponse$inboundSchema;
  /** @deprecated use `TopicsControllerListTopicSubscriptionsResponse$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerListTopicSubscriptionsResponse$outboundSchema;
  /** @deprecated use `TopicsControllerListTopicSubscriptionsResponse$Outbound` instead. */
  export type Outbound = TopicsControllerListTopicSubscriptionsResponse$Outbound;
}

export function topicsControllerListTopicSubscriptionsResponseToJSON(
  topicsControllerListTopicSubscriptionsResponse: TopicsControllerListTopicSubscriptionsResponse
): string {
  return JSON.stringify(
    TopicsControllerListTopicSubscriptionsResponse$outboundSchema.parse(topicsControllerListTopicSubscriptionsResponse)
  );
}

export function topicsControllerListTopicSubscriptionsResponseFromJSON(
  jsonString: string
): SafeParseResult<TopicsControllerListTopicSubscriptionsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsControllerListTopicSubscriptionsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsControllerListTopicSubscriptionsResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicsControllerListTopicSubscriptionsRequestToJSON(topicsControllerListTopicSubscriptionsRequest: TopicsControllerListTopicSubscriptionsRequest)
 - topicsControllerListTopicSubscriptionsRequestFromJSON(jsonString: string)
 - topicsControllerListTopicSubscriptionsResponseToJSON(topicsControllerListTopicSubscriptionsResponse: TopicsControllerListTopicSubscriptionsResponse)
 - topicsControllerListTopicSubscriptionsResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TopicsControllerListTopicSubscriptionsRequest$Outbound;
}

export function topicsControllerListTopic...)
 - Outbound(TopicsControllerListTopicSubscriptionsResponse$Outbound;
}

export function topicsControllerListTopi...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsControllerListTopicSubscriptionsRequestToJSON
- export function topicsControllerListTopicSubscriptionsRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsControllerListTopicSubscriptionsResponseToJSON
- export function topicsControllerListTopicSubscriptionsResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/topicscontrollerupdatetopic.ts
Tamaño: 5655 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TopicsControllerUpdateTopicRequest = {
  /**
   * The key identifier of the topic
   */
  topicKey: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  updateTopicRequestDto: components.UpdateTopicRequestDto;
};

export type TopicsControllerUpdateTopicResponse = {
  headers: { [k: string]: Array<string> };
  result: components.TopicResponseDto;
};

/** @internal */
export const TopicsControllerUpdateTopicRequest$inboundSchema: z.ZodType<
  TopicsControllerUpdateTopicRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    topicKey: z.string(),
    'idempotency-key': z.string().optional(),
    UpdateTopicRequestDto: components.UpdateTopicRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      UpdateTopicRequestDto: 'updateTopicRequestDto',
    });
  });

/** @internal */
export type TopicsControllerUpdateTopicRequest$Outbound = {
  topicKey: string;
  'idempotency-key'?: string | undefined;
  UpdateTopicRequestDto: components.UpdateTopicRequestDto$Outbound;
};

/** @internal */
export const TopicsControllerUpdateTopicRequest$outboundSchema: z.ZodType<
  TopicsControllerUpdateTopicRequest$Outbound,
  z.ZodTypeDef,
  TopicsControllerUpdateTopicRequest
> = z
  .object({
    topicKey: z.string(),
    idempotencyKey: z.string().optional(),
    updateTopicRequestDto: components.UpdateTopicRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      updateTopicRequestDto: 'UpdateTopicRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerUpdateTopicRequest$ {
  /** @deprecated use `TopicsControllerUpdateTopicRequest$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerUpdateTopicRequest$inboundSchema;
  /** @deprecated use `TopicsControllerUpdateTopicRequest$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerUpdateTopicRequest$outboundSchema;
  /** @deprecated use `TopicsControllerUpdateTopicRequest$Outbound` instead. */
  export type Outbound = TopicsControllerUpdateTopicRequest$Outbound;
}

export function topicsControllerUpdateTopicRequestToJSON(
  topicsControllerUpdateTopicRequest: TopicsControllerUpdateTopicRequest
): string {
  return JSON.stringify(TopicsControllerUpdateTopicRequest$outboundSchema.parse(topicsControllerUpdateTopicRequest));
}

export function topicsControllerUpdateTopicRequestFromJSON(
  jsonString: string
): SafeParseResult<TopicsControllerUpdateTopicRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsControllerUpdateTopicRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsControllerUpdateTopicRequest' from JSON`
  );
}

/** @internal */
export const TopicsControllerUpdateTopicResponse$inboundSchema: z.ZodType<
  TopicsControllerUpdateTopicResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.TopicResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type TopicsControllerUpdateTopicResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.TopicResponseDto$Outbound;
};

/** @internal */
export const TopicsControllerUpdateTopicResponse$outboundSchema: z.ZodType<
  TopicsControllerUpdateTopicResponse$Outbound,
  z.ZodTypeDef,
  TopicsControllerUpdateTopicResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.TopicResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerUpdateTopicResponse$ {
  /** @deprecated use `TopicsControllerUpdateTopicResponse$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerUpdateTopicResponse$inboundSchema;
  /** @deprecated use `TopicsControllerUpdateTopicResponse$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerUpdateTopicResponse$outboundSchema;
  /** @deprecated use `TopicsControllerUpdateTopicResponse$Outbound` instead. */
  export type Outbound = TopicsControllerUpdateTopicResponse$Outbound;
}

export function topicsControllerUpdateTopicResponseToJSON(
  topicsControllerUpdateTopicResponse: TopicsControllerUpdateTopicResponse
): string {
  return JSON.stringify(TopicsControllerUpdateTopicResponse$outboundSchema.parse(topicsControllerUpdateTopicResponse));
}

export function topicsControllerUpdateTopicResponseFromJSON(
  jsonString: string
): SafeParseResult<TopicsControllerUpdateTopicResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsControllerUpdateTopicResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsControllerUpdateTopicResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicsControllerUpdateTopicRequestToJSON(topicsControllerUpdateTopicRequest: TopicsControllerUpdateTopicRequest)
 - topicsControllerUpdateTopicRequestFromJSON(jsonString: string)
 - topicsControllerUpdateTopicResponseToJSON(topicsControllerUpdateTopicResponse: TopicsControllerUpdateTopicResponse)
 - topicsControllerUpdateTopicResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TopicsControllerUpdateTopicRequest$Outbound;
}

export function topicsControllerUpdateTopicRequestTo...)
 - Outbound(TopicsControllerUpdateTopicResponse$Outbound;
}

export function topicsControllerUpdateTopicResponse...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsControllerUpdateTopicRequestToJSON
- export function topicsControllerUpdateTopicRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsControllerUpdateTopicResponseToJSON
- export function topicsControllerUpdateTopicResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/topicscontrollerupserttopic.ts
Tamaño: 5838 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TopicsControllerUpsertTopicRequest = {
  /**
   * If true, the request will fail if a topic with the same key already exists
   */
  failIfExists?: boolean | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  createUpdateTopicRequestDto: components.CreateUpdateTopicRequestDto;
};

export type TopicsControllerUpsertTopicResponse = {
  headers: { [k: string]: Array<string> };
  result: components.TopicResponseDto;
};

/** @internal */
export const TopicsControllerUpsertTopicRequest$inboundSchema: z.ZodType<
  TopicsControllerUpsertTopicRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    failIfExists: z.boolean().optional(),
    'idempotency-key': z.string().optional(),
    CreateUpdateTopicRequestDto: components.CreateUpdateTopicRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      CreateUpdateTopicRequestDto: 'createUpdateTopicRequestDto',
    });
  });

/** @internal */
export type TopicsControllerUpsertTopicRequest$Outbound = {
  failIfExists?: boolean | undefined;
  'idempotency-key'?: string | undefined;
  CreateUpdateTopicRequestDto: components.CreateUpdateTopicRequestDto$Outbound;
};

/** @internal */
export const TopicsControllerUpsertTopicRequest$outboundSchema: z.ZodType<
  TopicsControllerUpsertTopicRequest$Outbound,
  z.ZodTypeDef,
  TopicsControllerUpsertTopicRequest
> = z
  .object({
    failIfExists: z.boolean().optional(),
    idempotencyKey: z.string().optional(),
    createUpdateTopicRequestDto: components.CreateUpdateTopicRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      createUpdateTopicRequestDto: 'CreateUpdateTopicRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerUpsertTopicRequest$ {
  /** @deprecated use `TopicsControllerUpsertTopicRequest$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerUpsertTopicRequest$inboundSchema;
  /** @deprecated use `TopicsControllerUpsertTopicRequest$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerUpsertTopicRequest$outboundSchema;
  /** @deprecated use `TopicsControllerUpsertTopicRequest$Outbound` instead. */
  export type Outbound = TopicsControllerUpsertTopicRequest$Outbound;
}

export function topicsControllerUpsertTopicRequestToJSON(
  topicsControllerUpsertTopicRequest: TopicsControllerUpsertTopicRequest
): string {
  return JSON.stringify(TopicsControllerUpsertTopicRequest$outboundSchema.parse(topicsControllerUpsertTopicRequest));
}

export function topicsControllerUpsertTopicRequestFromJSON(
  jsonString: string
): SafeParseResult<TopicsControllerUpsertTopicRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsControllerUpsertTopicRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsControllerUpsertTopicRequest' from JSON`
  );
}

/** @internal */
export const TopicsControllerUpsertTopicResponse$inboundSchema: z.ZodType<
  TopicsControllerUpsertTopicResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.TopicResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type TopicsControllerUpsertTopicResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.TopicResponseDto$Outbound;
};

/** @internal */
export const TopicsControllerUpsertTopicResponse$outboundSchema: z.ZodType<
  TopicsControllerUpsertTopicResponse$Outbound,
  z.ZodTypeDef,
  TopicsControllerUpsertTopicResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.TopicResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsControllerUpsertTopicResponse$ {
  /** @deprecated use `TopicsControllerUpsertTopicResponse$inboundSchema` instead. */
  export const inboundSchema = TopicsControllerUpsertTopicResponse$inboundSchema;
  /** @deprecated use `TopicsControllerUpsertTopicResponse$outboundSchema` instead. */
  export const outboundSchema = TopicsControllerUpsertTopicResponse$outboundSchema;
  /** @deprecated use `TopicsControllerUpsertTopicResponse$Outbound` instead. */
  export type Outbound = TopicsControllerUpsertTopicResponse$Outbound;
}

export function topicsControllerUpsertTopicResponseToJSON(
  topicsControllerUpsertTopicResponse: TopicsControllerUpsertTopicResponse
): string {
  return JSON.stringify(TopicsControllerUpsertTopicResponse$outboundSchema.parse(topicsControllerUpsertTopicResponse));
}

export function topicsControllerUpsertTopicResponseFromJSON(
  jsonString: string
): SafeParseResult<TopicsControllerUpsertTopicResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsControllerUpsertTopicResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsControllerUpsertTopicResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicsControllerUpsertTopicRequestToJSON(topicsControllerUpsertTopicRequest: TopicsControllerUpsertTopicRequest)
 - topicsControllerUpsertTopicRequestFromJSON(jsonString: string)
 - topicsControllerUpsertTopicResponseToJSON(topicsControllerUpsertTopicResponse: TopicsControllerUpsertTopicResponse)
 - topicsControllerUpsertTopicResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TopicsControllerUpsertTopicRequest$Outbound;
}

export function topicsControllerUpsertTopicRequestTo...)
 - Outbound(TopicsControllerUpsertTopicResponse$Outbound;
}

export function topicsControllerUpsertTopicResponse...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsControllerUpsertTopicRequestToJSON
- export function topicsControllerUpsertTopicRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsControllerUpsertTopicResponseToJSON
- export function topicsControllerUpsertTopicResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/topicsv1controllergettopicsubscriber.ts
Tamaño: 5873 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TopicsV1ControllerGetTopicSubscriberRequest = {
  /**
   * The topic key
   */
  topicKey: string;
  /**
   * The external subscriber id
   */
  externalSubscriberId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type TopicsV1ControllerGetTopicSubscriberResponse = {
  headers: { [k: string]: Array<string> };
  result: components.TopicSubscriberDto;
};

/** @internal */
export const TopicsV1ControllerGetTopicSubscriberRequest$inboundSchema: z.ZodType<
  TopicsV1ControllerGetTopicSubscriberRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    topicKey: z.string(),
    externalSubscriberId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type TopicsV1ControllerGetTopicSubscriberRequest$Outbound = {
  topicKey: string;
  externalSubscriberId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const TopicsV1ControllerGetTopicSubscriberRequest$outboundSchema: z.ZodType<
  TopicsV1ControllerGetTopicSubscriberRequest$Outbound,
  z.ZodTypeDef,
  TopicsV1ControllerGetTopicSubscriberRequest
> = z
  .object({
    topicKey: z.string(),
    externalSubscriberId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsV1ControllerGetTopicSubscriberRequest$ {
  /** @deprecated use `TopicsV1ControllerGetTopicSubscriberRequest$inboundSchema` instead. */
  export const inboundSchema = TopicsV1ControllerGetTopicSubscriberRequest$inboundSchema;
  /** @deprecated use `TopicsV1ControllerGetTopicSubscriberRequest$outboundSchema` instead. */
  export const outboundSchema = TopicsV1ControllerGetTopicSubscriberRequest$outboundSchema;
  /** @deprecated use `TopicsV1ControllerGetTopicSubscriberRequest$Outbound` instead. */
  export type Outbound = TopicsV1ControllerGetTopicSubscriberRequest$Outbound;
}

export function topicsV1ControllerGetTopicSubscriberRequestToJSON(
  topicsV1ControllerGetTopicSubscriberRequest: TopicsV1ControllerGetTopicSubscriberRequest
): string {
  return JSON.stringify(
    TopicsV1ControllerGetTopicSubscriberRequest$outboundSchema.parse(topicsV1ControllerGetTopicSubscriberRequest)
  );
}

export function topicsV1ControllerGetTopicSubscriberRequestFromJSON(
  jsonString: string
): SafeParseResult<TopicsV1ControllerGetTopicSubscriberRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsV1ControllerGetTopicSubscriberRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsV1ControllerGetTopicSubscriberRequest' from JSON`
  );
}

/** @internal */
export const TopicsV1ControllerGetTopicSubscriberResponse$inboundSchema: z.ZodType<
  TopicsV1ControllerGetTopicSubscriberResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.TopicSubscriberDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type TopicsV1ControllerGetTopicSubscriberResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.TopicSubscriberDto$Outbound;
};

/** @internal */
export const TopicsV1ControllerGetTopicSubscriberResponse$outboundSchema: z.ZodType<
  TopicsV1ControllerGetTopicSubscriberResponse$Outbound,
  z.ZodTypeDef,
  TopicsV1ControllerGetTopicSubscriberResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.TopicSubscriberDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TopicsV1ControllerGetTopicSubscriberResponse$ {
  /** @deprecated use `TopicsV1ControllerGetTopicSubscriberResponse$inboundSchema` instead. */
  export const inboundSchema = TopicsV1ControllerGetTopicSubscriberResponse$inboundSchema;
  /** @deprecated use `TopicsV1ControllerGetTopicSubscriberResponse$outboundSchema` instead. */
  export const outboundSchema = TopicsV1ControllerGetTopicSubscriberResponse$outboundSchema;
  /** @deprecated use `TopicsV1ControllerGetTopicSubscriberResponse$Outbound` instead. */
  export type Outbound = TopicsV1ControllerGetTopicSubscriberResponse$Outbound;
}

export function topicsV1ControllerGetTopicSubscriberResponseToJSON(
  topicsV1ControllerGetTopicSubscriberResponse: TopicsV1ControllerGetTopicSubscriberResponse
): string {
  return JSON.stringify(
    TopicsV1ControllerGetTopicSubscriberResponse$outboundSchema.parse(topicsV1ControllerGetTopicSubscriberResponse)
  );
}

export function topicsV1ControllerGetTopicSubscriberResponseFromJSON(
  jsonString: string
): SafeParseResult<TopicsV1ControllerGetTopicSubscriberResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopicsV1ControllerGetTopicSubscriberResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopicsV1ControllerGetTopicSubscriberResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicsV1ControllerGetTopicSubscriberRequestToJSON(topicsV1ControllerGetTopicSubscriberRequest: TopicsV1ControllerGetTopicSubscriberRequest)
 - topicsV1ControllerGetTopicSubscriberRequestFromJSON(jsonString: string)
 - topicsV1ControllerGetTopicSubscriberResponseToJSON(topicsV1ControllerGetTopicSubscriberResponse: TopicsV1ControllerGetTopicSubscriberResponse)
 - topicsV1ControllerGetTopicSubscriberResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TopicsV1ControllerGetTopicSubscriberRequest$Outbound;
}

export function topicsV1ControllerGetTopicS...)
 - Outbound(TopicsV1ControllerGetTopicSubscriberResponse$Outbound;
}

export function topicsV1ControllerGetTopic...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsV1ControllerGetTopicSubscriberRequestToJSON
- export function topicsV1ControllerGetTopicSubscriberRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function topicsV1ControllerGetTopicSubscriberResponseToJSON
- export function topicsV1ControllerGetTopicSubscriberResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/translationcontrollercreatetranslationendpoint.ts
Tamaño: 3585 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TranslationControllerCreateTranslationEndpointRequest = {
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  createTranslationRequestDto: components.CreateTranslationRequestDto;
};

/** @internal */
export const TranslationControllerCreateTranslationEndpointRequest$inboundSchema: z.ZodType<
  TranslationControllerCreateTranslationEndpointRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    'idempotency-key': z.string().optional(),
    CreateTranslationRequestDto: components.CreateTranslationRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      CreateTranslationRequestDto: 'createTranslationRequestDto',
    });
  });

/** @internal */
export type TranslationControllerCreateTranslationEndpointRequest$Outbound = {
  'idempotency-key'?: string | undefined;
  CreateTranslationRequestDto: components.CreateTranslationRequestDto$Outbound;
};

/** @internal */
export const TranslationControllerCreateTranslationEndpointRequest$outboundSchema: z.ZodType<
  TranslationControllerCreateTranslationEndpointRequest$Outbound,
  z.ZodTypeDef,
  TranslationControllerCreateTranslationEndpointRequest
> = z
  .object({
    idempotencyKey: z.string().optional(),
    createTranslationRequestDto: components.CreateTranslationRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      createTranslationRequestDto: 'CreateTranslationRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TranslationControllerCreateTranslationEndpointRequest$ {
  /** @deprecated use `TranslationControllerCreateTranslationEndpointRequest$inboundSchema` instead. */
  export const inboundSchema = TranslationControllerCreateTranslationEndpointRequest$inboundSchema;
  /** @deprecated use `TranslationControllerCreateTranslationEndpointRequest$outboundSchema` instead. */
  export const outboundSchema = TranslationControllerCreateTranslationEndpointRequest$outboundSchema;
  /** @deprecated use `TranslationControllerCreateTranslationEndpointRequest$Outbound` instead. */
  export type Outbound = TranslationControllerCreateTranslationEndpointRequest$Outbound;
}

export function translationControllerCreateTranslationEndpointRequestToJSON(
  translationControllerCreateTranslationEndpointRequest: TranslationControllerCreateTranslationEndpointRequest
): string {
  return JSON.stringify(
    TranslationControllerCreateTranslationEndpointRequest$outboundSchema.parse(
      translationControllerCreateTranslationEndpointRequest
    )
  );
}

export function translationControllerCreateTranslationEndpointRequestFromJSON(
  jsonString: string
): SafeParseResult<TranslationControllerCreateTranslationEndpointRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TranslationControllerCreateTranslationEndpointRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TranslationControllerCreateTranslationEndpointRequest' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - translationControllerCreateTranslationEndpointRequestToJSON(translationControllerCreateTranslationEndpointRequest: TranslationControllerCreateTranslationEndpointRequest)
 - translationControllerCreateTranslationEndpointRequestFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TranslationControllerCreateTranslationEndpointRequest$Outbound;
}

export function translationContro...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function translationControllerCreateTranslationEndpointRequestToJSON
- export function translationControllerCreateTranslationEndpointRequestFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/translationcontrollerdeletetranslationendpoint.ts
Tamaño: 5378 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Resource type
 */
export const TranslationControllerDeleteTranslationEndpointPathParamResourceType = {
  Workflow: 'workflow',
  Layout: 'layout',
} as const;
/**
 * Resource type
 */
export type TranslationControllerDeleteTranslationEndpointPathParamResourceType = ClosedEnum<
  typeof TranslationControllerDeleteTranslationEndpointPathParamResourceType
>;

export type TranslationControllerDeleteTranslationEndpointRequest = {
  /**
   * Resource type
   */
  resourceType: TranslationControllerDeleteTranslationEndpointPathParamResourceType;
  /**
   * Resource ID
   */
  resourceId: string;
  /**
   * Locale code
   */
  locale: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

/** @internal */
export const TranslationControllerDeleteTranslationEndpointPathParamResourceType$inboundSchema: z.ZodNativeEnum<
  typeof TranslationControllerDeleteTranslationEndpointPathParamResourceType
> = z.nativeEnum(TranslationControllerDeleteTranslationEndpointPathParamResourceType);

/** @internal */
export const TranslationControllerDeleteTranslationEndpointPathParamResourceType$outboundSchema: z.ZodNativeEnum<
  typeof TranslationControllerDeleteTranslationEndpointPathParamResourceType
> = TranslationControllerDeleteTranslationEndpointPathParamResourceType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TranslationControllerDeleteTranslationEndpointPathParamResourceType$ {
  /** @deprecated use `TranslationControllerDeleteTranslationEndpointPathParamResourceType$inboundSchema` instead. */
  export const inboundSchema = TranslationControllerDeleteTranslationEndpointPathParamResourceType$inboundSchema;
  /** @deprecated use `TranslationControllerDeleteTranslationEndpointPathParamResourceType$outboundSchema` instead. */
  export const outboundSchema = TranslationControllerDeleteTranslationEndpointPathParamResourceType$outboundSchema;
}

/** @internal */
export const TranslationControllerDeleteTranslationEndpointRequest$inboundSchema: z.ZodType<
  TranslationControllerDeleteTranslationEndpointRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    resourceType: TranslationControllerDeleteTranslationEndpointPathParamResourceType$inboundSchema,
    resourceId: z.string(),
    locale: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type TranslationControllerDeleteTranslationEndpointRequest$Outbound = {
  resourceType: string;
  resourceId: string;
  locale: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const TranslationControllerDeleteTranslationEndpointRequest$outboundSchema: z.ZodType<
  TranslationControllerDeleteTranslationEndpointRequest$Outbound,
  z.ZodTypeDef,
  TranslationControllerDeleteTranslationEndpointRequest
> = z
  .object({
    resourceType: TranslationControllerDeleteTranslationEndpointPathParamResourceType$outboundSchema,
    resourceId: z.string(),
    locale: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TranslationControllerDeleteTranslationEndpointRequest$ {
  /** @deprecated use `TranslationControllerDeleteTranslationEndpointRequest$inboundSchema` instead. */
  export const inboundSchema = TranslationControllerDeleteTranslationEndpointRequest$inboundSchema;
  /** @deprecated use `TranslationControllerDeleteTranslationEndpointRequest$outboundSchema` instead. */
  export const outboundSchema = TranslationControllerDeleteTranslationEndpointRequest$outboundSchema;
  /** @deprecated use `TranslationControllerDeleteTranslationEndpointRequest$Outbound` instead. */
  export type Outbound = TranslationControllerDeleteTranslationEndpointRequest$Outbound;
}

export function translationControllerDeleteTranslationEndpointRequestToJSON(
  translationControllerDeleteTranslationEndpointRequest: TranslationControllerDeleteTranslationEndpointRequest
): string {
  return JSON.stringify(
    TranslationControllerDeleteTranslationEndpointRequest$outboundSchema.parse(
      translationControllerDeleteTranslationEndpointRequest
    )
  );
}

export function translationControllerDeleteTranslationEndpointRequestFromJSON(
  jsonString: string
): SafeParseResult<TranslationControllerDeleteTranslationEndpointRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TranslationControllerDeleteTranslationEndpointRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TranslationControllerDeleteTranslationEndpointRequest' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - translationControllerDeleteTranslationEndpointRequestToJSON(translationControllerDeleteTranslationEndpointRequest: TranslationControllerDeleteTranslationEndpointRequest)
 - translationControllerDeleteTranslationEndpointRequestFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TranslationControllerDeleteTranslationEndpointRequest$Outbound;
}

export function translationContro...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function translationControllerDeleteTranslationEndpointRequestToJSON
- export function translationControllerDeleteTranslationEndpointRequestFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/translationcontrollerdeletetranslationgroupendpoint.ts
Tamaño: 4433 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Resource type
 */
export const ResourceType = {
  Workflow: 'workflow',
  Layout: 'layout',
} as const;
/**
 * Resource type
 */
export type ResourceType = ClosedEnum<typeof ResourceType>;

export type TranslationControllerDeleteTranslationGroupEndpointRequest = {
  /**
   * Resource type
   */
  resourceType: ResourceType;
  /**
   * Resource ID
   */
  resourceId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

/** @internal */
export const ResourceType$inboundSchema: z.ZodNativeEnum<typeof ResourceType> = z.nativeEnum(ResourceType);

/** @internal */
export const ResourceType$outboundSchema: z.ZodNativeEnum<typeof ResourceType> = ResourceType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResourceType$ {
  /** @deprecated use `ResourceType$inboundSchema` instead. */
  export const inboundSchema = ResourceType$inboundSchema;
  /** @deprecated use `ResourceType$outboundSchema` instead. */
  export const outboundSchema = ResourceType$outboundSchema;
}

/** @internal */
export const TranslationControllerDeleteTranslationGroupEndpointRequest$inboundSchema: z.ZodType<
  TranslationControllerDeleteTranslationGroupEndpointRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    resourceType: ResourceType$inboundSchema,
    resourceId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type TranslationControllerDeleteTranslationGroupEndpointRequest$Outbound = {
  resourceType: string;
  resourceId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const TranslationControllerDeleteTranslationGroupEndpointRequest$outboundSchema: z.ZodType<
  TranslationControllerDeleteTranslationGroupEndpointRequest$Outbound,
  z.ZodTypeDef,
  TranslationControllerDeleteTranslationGroupEndpointRequest
> = z
  .object({
    resourceType: ResourceType$outboundSchema,
    resourceId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TranslationControllerDeleteTranslationGroupEndpointRequest$ {
  /** @deprecated use `TranslationControllerDeleteTranslationGroupEndpointRequest$inboundSchema` instead. */
  export const inboundSchema = TranslationControllerDeleteTranslationGroupEndpointRequest$inboundSchema;
  /** @deprecated use `TranslationControllerDeleteTranslationGroupEndpointRequest$outboundSchema` instead. */
  export const outboundSchema = TranslationControllerDeleteTranslationGroupEndpointRequest$outboundSchema;
  /** @deprecated use `TranslationControllerDeleteTranslationGroupEndpointRequest$Outbound` instead. */
  export type Outbound = TranslationControllerDeleteTranslationGroupEndpointRequest$Outbound;
}

export function translationControllerDeleteTranslationGroupEndpointRequestToJSON(
  translationControllerDeleteTranslationGroupEndpointRequest: TranslationControllerDeleteTranslationGroupEndpointRequest
): string {
  return JSON.stringify(
    TranslationControllerDeleteTranslationGroupEndpointRequest$outboundSchema.parse(
      translationControllerDeleteTranslationGroupEndpointRequest
    )
  );
}

export function translationControllerDeleteTranslationGroupEndpointRequestFromJSON(
  jsonString: string
): SafeParseResult<TranslationControllerDeleteTranslationGroupEndpointRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TranslationControllerDeleteTranslationGroupEndpointRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TranslationControllerDeleteTranslationGroupEndpointRequest' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - translationControllerDeleteTranslationGroupEndpointRequestToJSON(translationControllerDeleteTranslationGroupEndpointRequest: TranslationControllerDeleteTranslationGroupEndpointRequest)
 - translationControllerDeleteTranslationGroupEndpointRequestFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TranslationControllerDeleteTranslationGroupEndpointRequest$Outbound;
}

export function translationC...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function translationControllerDeleteTranslationGroupEndpointRequestToJSON
- export function translationControllerDeleteTranslationGroupEndpointRequestFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/translationcontrollergetmasterjsonendpoint.ts
Tamaño: 3201 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TranslationControllerGetMasterJsonEndpointRequest = {
  /**
   * Locale to export. If not provided, exports organization default locale
   */
  locale?: string | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

/** @internal */
export const TranslationControllerGetMasterJsonEndpointRequest$inboundSchema: z.ZodType<
  TranslationControllerGetMasterJsonEndpointRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    locale: z.string().optional(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type TranslationControllerGetMasterJsonEndpointRequest$Outbound = {
  locale?: string | undefined;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const TranslationControllerGetMasterJsonEndpointRequest$outboundSchema: z.ZodType<
  TranslationControllerGetMasterJsonEndpointRequest$Outbound,
  z.ZodTypeDef,
  TranslationControllerGetMasterJsonEndpointRequest
> = z
  .object({
    locale: z.string().optional(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TranslationControllerGetMasterJsonEndpointRequest$ {
  /** @deprecated use `TranslationControllerGetMasterJsonEndpointRequest$inboundSchema` instead. */
  export const inboundSchema = TranslationControllerGetMasterJsonEndpointRequest$inboundSchema;
  /** @deprecated use `TranslationControllerGetMasterJsonEndpointRequest$outboundSchema` instead. */
  export const outboundSchema = TranslationControllerGetMasterJsonEndpointRequest$outboundSchema;
  /** @deprecated use `TranslationControllerGetMasterJsonEndpointRequest$Outbound` instead. */
  export type Outbound = TranslationControllerGetMasterJsonEndpointRequest$Outbound;
}

export function translationControllerGetMasterJsonEndpointRequestToJSON(
  translationControllerGetMasterJsonEndpointRequest: TranslationControllerGetMasterJsonEndpointRequest
): string {
  return JSON.stringify(
    TranslationControllerGetMasterJsonEndpointRequest$outboundSchema.parse(
      translationControllerGetMasterJsonEndpointRequest
    )
  );
}

export function translationControllerGetMasterJsonEndpointRequestFromJSON(
  jsonString: string
): SafeParseResult<TranslationControllerGetMasterJsonEndpointRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TranslationControllerGetMasterJsonEndpointRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TranslationControllerGetMasterJsonEndpointRequest' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - translationControllerGetMasterJsonEndpointRequestToJSON(translationControllerGetMasterJsonEndpointRequest: TranslationControllerGetMasterJsonEndpointRequest)
 - translationControllerGetMasterJsonEndpointRequestFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TranslationControllerGetMasterJsonEndpointRequest$Outbound;
}

export function translationController...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function translationControllerGetMasterJsonEndpointRequestToJSON
- export function translationControllerGetMasterJsonEndpointRequestFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/translationcontrollergetsingletranslation.ts
Tamaño: 4473 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Resource type
 */
export const PathParamResourceType = {
  Workflow: 'workflow',
  Layout: 'layout',
} as const;
/**
 * Resource type
 */
export type PathParamResourceType = ClosedEnum<typeof PathParamResourceType>;

export type TranslationControllerGetSingleTranslationRequest = {
  /**
   * Resource type
   */
  resourceType: PathParamResourceType;
  /**
   * Resource ID
   */
  resourceId: string;
  /**
   * Locale code
   */
  locale: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

/** @internal */
export const PathParamResourceType$inboundSchema: z.ZodNativeEnum<typeof PathParamResourceType> =
  z.nativeEnum(PathParamResourceType);

/** @internal */
export const PathParamResourceType$outboundSchema: z.ZodNativeEnum<typeof PathParamResourceType> =
  PathParamResourceType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PathParamResourceType$ {
  /** @deprecated use `PathParamResourceType$inboundSchema` instead. */
  export const inboundSchema = PathParamResourceType$inboundSchema;
  /** @deprecated use `PathParamResourceType$outboundSchema` instead. */
  export const outboundSchema = PathParamResourceType$outboundSchema;
}

/** @internal */
export const TranslationControllerGetSingleTranslationRequest$inboundSchema: z.ZodType<
  TranslationControllerGetSingleTranslationRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    resourceType: PathParamResourceType$inboundSchema,
    resourceId: z.string(),
    locale: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type TranslationControllerGetSingleTranslationRequest$Outbound = {
  resourceType: string;
  resourceId: string;
  locale: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const TranslationControllerGetSingleTranslationRequest$outboundSchema: z.ZodType<
  TranslationControllerGetSingleTranslationRequest$Outbound,
  z.ZodTypeDef,
  TranslationControllerGetSingleTranslationRequest
> = z
  .object({
    resourceType: PathParamResourceType$outboundSchema,
    resourceId: z.string(),
    locale: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TranslationControllerGetSingleTranslationRequest$ {
  /** @deprecated use `TranslationControllerGetSingleTranslationRequest$inboundSchema` instead. */
  export const inboundSchema = TranslationControllerGetSingleTranslationRequest$inboundSchema;
  /** @deprecated use `TranslationControllerGetSingleTranslationRequest$outboundSchema` instead. */
  export const outboundSchema = TranslationControllerGetSingleTranslationRequest$outboundSchema;
  /** @deprecated use `TranslationControllerGetSingleTranslationRequest$Outbound` instead. */
  export type Outbound = TranslationControllerGetSingleTranslationRequest$Outbound;
}

export function translationControllerGetSingleTranslationRequestToJSON(
  translationControllerGetSingleTranslationRequest: TranslationControllerGetSingleTranslationRequest
): string {
  return JSON.stringify(
    TranslationControllerGetSingleTranslationRequest$outboundSchema.parse(
      translationControllerGetSingleTranslationRequest
    )
  );
}

export function translationControllerGetSingleTranslationRequestFromJSON(
  jsonString: string
): SafeParseResult<TranslationControllerGetSingleTranslationRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TranslationControllerGetSingleTranslationRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TranslationControllerGetSingleTranslationRequest' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - translationControllerGetSingleTranslationRequestToJSON(translationControllerGetSingleTranslationRequest: TranslationControllerGetSingleTranslationRequest)
 - translationControllerGetSingleTranslationRequestFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TranslationControllerGetSingleTranslationRequest$Outbound;
}

export function translationControllerG...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function translationControllerGetSingleTranslationRequestToJSON
- export function translationControllerGetSingleTranslationRequestFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/translationcontrollergettranslationgroupendpoint.ts
Tamaño: 5345 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Resource type
 */
export const TranslationControllerGetTranslationGroupEndpointPathParamResourceType = {
  Workflow: 'workflow',
  Layout: 'layout',
} as const;
/**
 * Resource type
 */
export type TranslationControllerGetTranslationGroupEndpointPathParamResourceType = ClosedEnum<
  typeof TranslationControllerGetTranslationGroupEndpointPathParamResourceType
>;

export type TranslationControllerGetTranslationGroupEndpointRequest = {
  /**
   * Resource type
   */
  resourceType: TranslationControllerGetTranslationGroupEndpointPathParamResourceType;
  /**
   * Resource ID
   */
  resourceId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

/** @internal */
export const TranslationControllerGetTranslationGroupEndpointPathParamResourceType$inboundSchema: z.ZodNativeEnum<
  typeof TranslationControllerGetTranslationGroupEndpointPathParamResourceType
> = z.nativeEnum(TranslationControllerGetTranslationGroupEndpointPathParamResourceType);

/** @internal */
export const TranslationControllerGetTranslationGroupEndpointPathParamResourceType$outboundSchema: z.ZodNativeEnum<
  typeof TranslationControllerGetTranslationGroupEndpointPathParamResourceType
> = TranslationControllerGetTranslationGroupEndpointPathParamResourceType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TranslationControllerGetTranslationGroupEndpointPathParamResourceType$ {
  /** @deprecated use `TranslationControllerGetTranslationGroupEndpointPathParamResourceType$inboundSchema` instead. */
  export const inboundSchema = TranslationControllerGetTranslationGroupEndpointPathParamResourceType$inboundSchema;
  /** @deprecated use `TranslationControllerGetTranslationGroupEndpointPathParamResourceType$outboundSchema` instead. */
  export const outboundSchema = TranslationControllerGetTranslationGroupEndpointPathParamResourceType$outboundSchema;
}

/** @internal */
export const TranslationControllerGetTranslationGroupEndpointRequest$inboundSchema: z.ZodType<
  TranslationControllerGetTranslationGroupEndpointRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    resourceType: TranslationControllerGetTranslationGroupEndpointPathParamResourceType$inboundSchema,
    resourceId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type TranslationControllerGetTranslationGroupEndpointRequest$Outbound = {
  resourceType: string;
  resourceId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const TranslationControllerGetTranslationGroupEndpointRequest$outboundSchema: z.ZodType<
  TranslationControllerGetTranslationGroupEndpointRequest$Outbound,
  z.ZodTypeDef,
  TranslationControllerGetTranslationGroupEndpointRequest
> = z
  .object({
    resourceType: TranslationControllerGetTranslationGroupEndpointPathParamResourceType$outboundSchema,
    resourceId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TranslationControllerGetTranslationGroupEndpointRequest$ {
  /** @deprecated use `TranslationControllerGetTranslationGroupEndpointRequest$inboundSchema` instead. */
  export const inboundSchema = TranslationControllerGetTranslationGroupEndpointRequest$inboundSchema;
  /** @deprecated use `TranslationControllerGetTranslationGroupEndpointRequest$outboundSchema` instead. */
  export const outboundSchema = TranslationControllerGetTranslationGroupEndpointRequest$outboundSchema;
  /** @deprecated use `TranslationControllerGetTranslationGroupEndpointRequest$Outbound` instead. */
  export type Outbound = TranslationControllerGetTranslationGroupEndpointRequest$Outbound;
}

export function translationControllerGetTranslationGroupEndpointRequestToJSON(
  translationControllerGetTranslationGroupEndpointRequest: TranslationControllerGetTranslationGroupEndpointRequest
): string {
  return JSON.stringify(
    TranslationControllerGetTranslationGroupEndpointRequest$outboundSchema.parse(
      translationControllerGetTranslationGroupEndpointRequest
    )
  );
}

export function translationControllerGetTranslationGroupEndpointRequestFromJSON(
  jsonString: string
): SafeParseResult<TranslationControllerGetTranslationGroupEndpointRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TranslationControllerGetTranslationGroupEndpointRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TranslationControllerGetTranslationGroupEndpointRequest' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - translationControllerGetTranslationGroupEndpointRequestToJSON(translationControllerGetTranslationGroupEndpointRequest: TranslationControllerGetTranslationGroupEndpointRequest)
 - translationControllerGetTranslationGroupEndpointRequestFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TranslationControllerGetTranslationGroupEndpointRequest$Outbound;
}

export function translationCont...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function translationControllerGetTranslationGroupEndpointRequestToJSON
- export function translationControllerGetTranslationGroupEndpointRequestFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/translationcontrollerimportmasterjsonendpoint.ts
Tamaño: 3550 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TranslationControllerImportMasterJsonEndpointRequest = {
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  importMasterJsonRequestDto: components.ImportMasterJsonRequestDto;
};

/** @internal */
export const TranslationControllerImportMasterJsonEndpointRequest$inboundSchema: z.ZodType<
  TranslationControllerImportMasterJsonEndpointRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    'idempotency-key': z.string().optional(),
    ImportMasterJsonRequestDto: components.ImportMasterJsonRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      ImportMasterJsonRequestDto: 'importMasterJsonRequestDto',
    });
  });

/** @internal */
export type TranslationControllerImportMasterJsonEndpointRequest$Outbound = {
  'idempotency-key'?: string | undefined;
  ImportMasterJsonRequestDto: components.ImportMasterJsonRequestDto$Outbound;
};

/** @internal */
export const TranslationControllerImportMasterJsonEndpointRequest$outboundSchema: z.ZodType<
  TranslationControllerImportMasterJsonEndpointRequest$Outbound,
  z.ZodTypeDef,
  TranslationControllerImportMasterJsonEndpointRequest
> = z
  .object({
    idempotencyKey: z.string().optional(),
    importMasterJsonRequestDto: components.ImportMasterJsonRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      importMasterJsonRequestDto: 'ImportMasterJsonRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TranslationControllerImportMasterJsonEndpointRequest$ {
  /** @deprecated use `TranslationControllerImportMasterJsonEndpointRequest$inboundSchema` instead. */
  export const inboundSchema = TranslationControllerImportMasterJsonEndpointRequest$inboundSchema;
  /** @deprecated use `TranslationControllerImportMasterJsonEndpointRequest$outboundSchema` instead. */
  export const outboundSchema = TranslationControllerImportMasterJsonEndpointRequest$outboundSchema;
  /** @deprecated use `TranslationControllerImportMasterJsonEndpointRequest$Outbound` instead. */
  export type Outbound = TranslationControllerImportMasterJsonEndpointRequest$Outbound;
}

export function translationControllerImportMasterJsonEndpointRequestToJSON(
  translationControllerImportMasterJsonEndpointRequest: TranslationControllerImportMasterJsonEndpointRequest
): string {
  return JSON.stringify(
    TranslationControllerImportMasterJsonEndpointRequest$outboundSchema.parse(
      translationControllerImportMasterJsonEndpointRequest
    )
  );
}

export function translationControllerImportMasterJsonEndpointRequestFromJSON(
  jsonString: string
): SafeParseResult<TranslationControllerImportMasterJsonEndpointRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TranslationControllerImportMasterJsonEndpointRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TranslationControllerImportMasterJsonEndpointRequest' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - translationControllerImportMasterJsonEndpointRequestToJSON(translationControllerImportMasterJsonEndpointRequest: TranslationControllerImportMasterJsonEndpointRequest)
 - translationControllerImportMasterJsonEndpointRequestFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TranslationControllerImportMasterJsonEndpointRequest$Outbound;
}

export function translationControl...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function translationControllerImportMasterJsonEndpointRequestToJSON
- export function translationControllerImportMasterJsonEndpointRequestFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/translationcontrolleruploadmasterjsonendpoint.ts
Tamaño: 3050 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TranslationControllerUploadMasterJsonEndpointRequest = {
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

/** @internal */
export const TranslationControllerUploadMasterJsonEndpointRequest$inboundSchema: z.ZodType<
  TranslationControllerUploadMasterJsonEndpointRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type TranslationControllerUploadMasterJsonEndpointRequest$Outbound = {
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const TranslationControllerUploadMasterJsonEndpointRequest$outboundSchema: z.ZodType<
  TranslationControllerUploadMasterJsonEndpointRequest$Outbound,
  z.ZodTypeDef,
  TranslationControllerUploadMasterJsonEndpointRequest
> = z
  .object({
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TranslationControllerUploadMasterJsonEndpointRequest$ {
  /** @deprecated use `TranslationControllerUploadMasterJsonEndpointRequest$inboundSchema` instead. */
  export const inboundSchema = TranslationControllerUploadMasterJsonEndpointRequest$inboundSchema;
  /** @deprecated use `TranslationControllerUploadMasterJsonEndpointRequest$outboundSchema` instead. */
  export const outboundSchema = TranslationControllerUploadMasterJsonEndpointRequest$outboundSchema;
  /** @deprecated use `TranslationControllerUploadMasterJsonEndpointRequest$Outbound` instead. */
  export type Outbound = TranslationControllerUploadMasterJsonEndpointRequest$Outbound;
}

export function translationControllerUploadMasterJsonEndpointRequestToJSON(
  translationControllerUploadMasterJsonEndpointRequest: TranslationControllerUploadMasterJsonEndpointRequest
): string {
  return JSON.stringify(
    TranslationControllerUploadMasterJsonEndpointRequest$outboundSchema.parse(
      translationControllerUploadMasterJsonEndpointRequest
    )
  );
}

export function translationControllerUploadMasterJsonEndpointRequestFromJSON(
  jsonString: string
): SafeParseResult<TranslationControllerUploadMasterJsonEndpointRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TranslationControllerUploadMasterJsonEndpointRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TranslationControllerUploadMasterJsonEndpointRequest' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - translationControllerUploadMasterJsonEndpointRequestToJSON(translationControllerUploadMasterJsonEndpointRequest: TranslationControllerUploadMasterJsonEndpointRequest)
 - translationControllerUploadMasterJsonEndpointRequestFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TranslationControllerUploadMasterJsonEndpointRequest$Outbound;
}

export function translationControl...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function translationControllerUploadMasterJsonEndpointRequestToJSON
- export function translationControllerUploadMasterJsonEndpointRequestFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/translationcontrolleruploadtranslationfiles.ts
Tamaño: 3583 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TranslationControllerUploadTranslationFilesRequest = {
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  /**
   * Translation files upload body details
   */
  uploadTranslationsRequestDto: components.UploadTranslationsRequestDto;
};

/** @internal */
export const TranslationControllerUploadTranslationFilesRequest$inboundSchema: z.ZodType<
  TranslationControllerUploadTranslationFilesRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    'idempotency-key': z.string().optional(),
    UploadTranslationsRequestDto: components.UploadTranslationsRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      UploadTranslationsRequestDto: 'uploadTranslationsRequestDto',
    });
  });

/** @internal */
export type TranslationControllerUploadTranslationFilesRequest$Outbound = {
  'idempotency-key'?: string | undefined;
  UploadTranslationsRequestDto: components.UploadTranslationsRequestDto$Outbound;
};

/** @internal */
export const TranslationControllerUploadTranslationFilesRequest$outboundSchema: z.ZodType<
  TranslationControllerUploadTranslationFilesRequest$Outbound,
  z.ZodTypeDef,
  TranslationControllerUploadTranslationFilesRequest
> = z
  .object({
    idempotencyKey: z.string().optional(),
    uploadTranslationsRequestDto: components.UploadTranslationsRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      uploadTranslationsRequestDto: 'UploadTranslationsRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TranslationControllerUploadTranslationFilesRequest$ {
  /** @deprecated use `TranslationControllerUploadTranslationFilesRequest$inboundSchema` instead. */
  export const inboundSchema = TranslationControllerUploadTranslationFilesRequest$inboundSchema;
  /** @deprecated use `TranslationControllerUploadTranslationFilesRequest$outboundSchema` instead. */
  export const outboundSchema = TranslationControllerUploadTranslationFilesRequest$outboundSchema;
  /** @deprecated use `TranslationControllerUploadTranslationFilesRequest$Outbound` instead. */
  export type Outbound = TranslationControllerUploadTranslationFilesRequest$Outbound;
}

export function translationControllerUploadTranslationFilesRequestToJSON(
  translationControllerUploadTranslationFilesRequest: TranslationControllerUploadTranslationFilesRequest
): string {
  return JSON.stringify(
    TranslationControllerUploadTranslationFilesRequest$outboundSchema.parse(
      translationControllerUploadTranslationFilesRequest
    )
  );
}

export function translationControllerUploadTranslationFilesRequestFromJSON(
  jsonString: string
): SafeParseResult<TranslationControllerUploadTranslationFilesRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TranslationControllerUploadTranslationFilesRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TranslationControllerUploadTranslationFilesRequest' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - translationControllerUploadTranslationFilesRequestToJSON(translationControllerUploadTranslationFilesRequest: TranslationControllerUploadTranslationFilesRequest)
 - translationControllerUploadTranslationFilesRequestFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TranslationControllerUploadTranslationFilesRequest$Outbound;
}

export function translationControlle...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function translationControllerUploadTranslationFilesRequestToJSON
- export function translationControllerUploadTranslationFilesRequestFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/workflowcontrollercreate.ts
Tamaño: 5383 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type WorkflowControllerCreateRequest = {
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  /**
   * Workflow creation details
   */
  createWorkflowDto: components.CreateWorkflowDto;
};

export type WorkflowControllerCreateResponse = {
  headers: { [k: string]: Array<string> };
  result: components.WorkflowResponseDto;
};

/** @internal */
export const WorkflowControllerCreateRequest$inboundSchema: z.ZodType<
  WorkflowControllerCreateRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    'idempotency-key': z.string().optional(),
    CreateWorkflowDto: components.CreateWorkflowDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      CreateWorkflowDto: 'createWorkflowDto',
    });
  });

/** @internal */
export type WorkflowControllerCreateRequest$Outbound = {
  'idempotency-key'?: string | undefined;
  CreateWorkflowDto: components.CreateWorkflowDto$Outbound;
};

/** @internal */
export const WorkflowControllerCreateRequest$outboundSchema: z.ZodType<
  WorkflowControllerCreateRequest$Outbound,
  z.ZodTypeDef,
  WorkflowControllerCreateRequest
> = z
  .object({
    idempotencyKey: z.string().optional(),
    createWorkflowDto: components.CreateWorkflowDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      createWorkflowDto: 'CreateWorkflowDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerCreateRequest$ {
  /** @deprecated use `WorkflowControllerCreateRequest$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerCreateRequest$inboundSchema;
  /** @deprecated use `WorkflowControllerCreateRequest$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerCreateRequest$outboundSchema;
  /** @deprecated use `WorkflowControllerCreateRequest$Outbound` instead. */
  export type Outbound = WorkflowControllerCreateRequest$Outbound;
}

export function workflowControllerCreateRequestToJSON(
  workflowControllerCreateRequest: WorkflowControllerCreateRequest
): string {
  return JSON.stringify(WorkflowControllerCreateRequest$outboundSchema.parse(workflowControllerCreateRequest));
}

export function workflowControllerCreateRequestFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerCreateRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerCreateRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerCreateRequest' from JSON`
  );
}

/** @internal */
export const WorkflowControllerCreateResponse$inboundSchema: z.ZodType<
  WorkflowControllerCreateResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.WorkflowResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type WorkflowControllerCreateResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.WorkflowResponseDto$Outbound;
};

/** @internal */
export const WorkflowControllerCreateResponse$outboundSchema: z.ZodType<
  WorkflowControllerCreateResponse$Outbound,
  z.ZodTypeDef,
  WorkflowControllerCreateResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.WorkflowResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerCreateResponse$ {
  /** @deprecated use `WorkflowControllerCreateResponse$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerCreateResponse$inboundSchema;
  /** @deprecated use `WorkflowControllerCreateResponse$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerCreateResponse$outboundSchema;
  /** @deprecated use `WorkflowControllerCreateResponse$Outbound` instead. */
  export type Outbound = WorkflowControllerCreateResponse$Outbound;
}

export function workflowControllerCreateResponseToJSON(
  workflowControllerCreateResponse: WorkflowControllerCreateResponse
): string {
  return JSON.stringify(WorkflowControllerCreateResponse$outboundSchema.parse(workflowControllerCreateResponse));
}

export function workflowControllerCreateResponseFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerCreateResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerCreateResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerCreateResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowControllerCreateRequestToJSON(workflowControllerCreateRequest: WorkflowControllerCreateRequest)
 - workflowControllerCreateRequestFromJSON(jsonString: string)
 - workflowControllerCreateResponseToJSON(workflowControllerCreateResponse: WorkflowControllerCreateResponse)
 - workflowControllerCreateResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowControllerCreateRequest$Outbound;
}

export function workflowControllerCreateRequestToJSON(
...)
 - Outbound(WorkflowControllerCreateResponse$Outbound;
}

export function workflowControllerCreateResponseToJSON...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerCreateRequestToJSON
- export function workflowControllerCreateRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerCreateResponseToJSON
- export function workflowControllerCreateResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/workflowcontrollerduplicateworkflow.ts
Tamaño: 5998 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type WorkflowControllerDuplicateWorkflowRequest = {
  workflowId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  duplicateWorkflowDto: components.DuplicateWorkflowDto;
};

export type WorkflowControllerDuplicateWorkflowResponse = {
  headers: { [k: string]: Array<string> };
  result: components.WorkflowResponseDto;
};

/** @internal */
export const WorkflowControllerDuplicateWorkflowRequest$inboundSchema: z.ZodType<
  WorkflowControllerDuplicateWorkflowRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    workflowId: z.string(),
    'idempotency-key': z.string().optional(),
    DuplicateWorkflowDto: components.DuplicateWorkflowDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      DuplicateWorkflowDto: 'duplicateWorkflowDto',
    });
  });

/** @internal */
export type WorkflowControllerDuplicateWorkflowRequest$Outbound = {
  workflowId: string;
  'idempotency-key'?: string | undefined;
  DuplicateWorkflowDto: components.DuplicateWorkflowDto$Outbound;
};

/** @internal */
export const WorkflowControllerDuplicateWorkflowRequest$outboundSchema: z.ZodType<
  WorkflowControllerDuplicateWorkflowRequest$Outbound,
  z.ZodTypeDef,
  WorkflowControllerDuplicateWorkflowRequest
> = z
  .object({
    workflowId: z.string(),
    idempotencyKey: z.string().optional(),
    duplicateWorkflowDto: components.DuplicateWorkflowDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      duplicateWorkflowDto: 'DuplicateWorkflowDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerDuplicateWorkflowRequest$ {
  /** @deprecated use `WorkflowControllerDuplicateWorkflowRequest$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerDuplicateWorkflowRequest$inboundSchema;
  /** @deprecated use `WorkflowControllerDuplicateWorkflowRequest$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerDuplicateWorkflowRequest$outboundSchema;
  /** @deprecated use `WorkflowControllerDuplicateWorkflowRequest$Outbound` instead. */
  export type Outbound = WorkflowControllerDuplicateWorkflowRequest$Outbound;
}

export function workflowControllerDuplicateWorkflowRequestToJSON(
  workflowControllerDuplicateWorkflowRequest: WorkflowControllerDuplicateWorkflowRequest
): string {
  return JSON.stringify(
    WorkflowControllerDuplicateWorkflowRequest$outboundSchema.parse(workflowControllerDuplicateWorkflowRequest)
  );
}

export function workflowControllerDuplicateWorkflowRequestFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerDuplicateWorkflowRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerDuplicateWorkflowRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerDuplicateWorkflowRequest' from JSON`
  );
}

/** @internal */
export const WorkflowControllerDuplicateWorkflowResponse$inboundSchema: z.ZodType<
  WorkflowControllerDuplicateWorkflowResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.WorkflowResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type WorkflowControllerDuplicateWorkflowResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.WorkflowResponseDto$Outbound;
};

/** @internal */
export const WorkflowControllerDuplicateWorkflowResponse$outboundSchema: z.ZodType<
  WorkflowControllerDuplicateWorkflowResponse$Outbound,
  z.ZodTypeDef,
  WorkflowControllerDuplicateWorkflowResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.WorkflowResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerDuplicateWorkflowResponse$ {
  /** @deprecated use `WorkflowControllerDuplicateWorkflowResponse$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerDuplicateWorkflowResponse$inboundSchema;
  /** @deprecated use `WorkflowControllerDuplicateWorkflowResponse$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerDuplicateWorkflowResponse$outboundSchema;
  /** @deprecated use `WorkflowControllerDuplicateWorkflowResponse$Outbound` instead. */
  export type Outbound = WorkflowControllerDuplicateWorkflowResponse$Outbound;
}

export function workflowControllerDuplicateWorkflowResponseToJSON(
  workflowControllerDuplicateWorkflowResponse: WorkflowControllerDuplicateWorkflowResponse
): string {
  return JSON.stringify(
    WorkflowControllerDuplicateWorkflowResponse$outboundSchema.parse(workflowControllerDuplicateWorkflowResponse)
  );
}

export function workflowControllerDuplicateWorkflowResponseFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerDuplicateWorkflowResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerDuplicateWorkflowResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerDuplicateWorkflowResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowControllerDuplicateWorkflowRequestToJSON(workflowControllerDuplicateWorkflowRequest: WorkflowControllerDuplicateWorkflowRequest)
 - workflowControllerDuplicateWorkflowRequestFromJSON(jsonString: string)
 - workflowControllerDuplicateWorkflowResponseToJSON(workflowControllerDuplicateWorkflowResponse: WorkflowControllerDuplicateWorkflowResponse)
 - workflowControllerDuplicateWorkflowResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowControllerDuplicateWorkflowRequest$Outbound;
}

export function workflowControllerDuplicateW...)
 - Outbound(WorkflowControllerDuplicateWorkflowResponse$Outbound;
}

export function workflowControllerDuplicate...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerDuplicateWorkflowRequestToJSON
- export function workflowControllerDuplicateWorkflowRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerDuplicateWorkflowResponseToJSON
- export function workflowControllerDuplicateWorkflowResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/workflowcontrollergeneratepreview.ts
Tamaño: 6122 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type WorkflowControllerGeneratePreviewRequest = {
  workflowId: string;
  stepId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  /**
   * Preview generation details
   */
  generatePreviewRequestDto: components.GeneratePreviewRequestDto;
};

export type WorkflowControllerGeneratePreviewResponse = {
  headers: { [k: string]: Array<string> };
  result: components.GeneratePreviewResponseDto;
};

/** @internal */
export const WorkflowControllerGeneratePreviewRequest$inboundSchema: z.ZodType<
  WorkflowControllerGeneratePreviewRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    workflowId: z.string(),
    stepId: z.string(),
    'idempotency-key': z.string().optional(),
    GeneratePreviewRequestDto: components.GeneratePreviewRequestDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      GeneratePreviewRequestDto: 'generatePreviewRequestDto',
    });
  });

/** @internal */
export type WorkflowControllerGeneratePreviewRequest$Outbound = {
  workflowId: string;
  stepId: string;
  'idempotency-key'?: string | undefined;
  GeneratePreviewRequestDto: components.GeneratePreviewRequestDto$Outbound;
};

/** @internal */
export const WorkflowControllerGeneratePreviewRequest$outboundSchema: z.ZodType<
  WorkflowControllerGeneratePreviewRequest$Outbound,
  z.ZodTypeDef,
  WorkflowControllerGeneratePreviewRequest
> = z
  .object({
    workflowId: z.string(),
    stepId: z.string(),
    idempotencyKey: z.string().optional(),
    generatePreviewRequestDto: components.GeneratePreviewRequestDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      generatePreviewRequestDto: 'GeneratePreviewRequestDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerGeneratePreviewRequest$ {
  /** @deprecated use `WorkflowControllerGeneratePreviewRequest$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerGeneratePreviewRequest$inboundSchema;
  /** @deprecated use `WorkflowControllerGeneratePreviewRequest$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerGeneratePreviewRequest$outboundSchema;
  /** @deprecated use `WorkflowControllerGeneratePreviewRequest$Outbound` instead. */
  export type Outbound = WorkflowControllerGeneratePreviewRequest$Outbound;
}

export function workflowControllerGeneratePreviewRequestToJSON(
  workflowControllerGeneratePreviewRequest: WorkflowControllerGeneratePreviewRequest
): string {
  return JSON.stringify(
    WorkflowControllerGeneratePreviewRequest$outboundSchema.parse(workflowControllerGeneratePreviewRequest)
  );
}

export function workflowControllerGeneratePreviewRequestFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerGeneratePreviewRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerGeneratePreviewRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerGeneratePreviewRequest' from JSON`
  );
}

/** @internal */
export const WorkflowControllerGeneratePreviewResponse$inboundSchema: z.ZodType<
  WorkflowControllerGeneratePreviewResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.GeneratePreviewResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type WorkflowControllerGeneratePreviewResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.GeneratePreviewResponseDto$Outbound;
};

/** @internal */
export const WorkflowControllerGeneratePreviewResponse$outboundSchema: z.ZodType<
  WorkflowControllerGeneratePreviewResponse$Outbound,
  z.ZodTypeDef,
  WorkflowControllerGeneratePreviewResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.GeneratePreviewResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerGeneratePreviewResponse$ {
  /** @deprecated use `WorkflowControllerGeneratePreviewResponse$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerGeneratePreviewResponse$inboundSchema;
  /** @deprecated use `WorkflowControllerGeneratePreviewResponse$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerGeneratePreviewResponse$outboundSchema;
  /** @deprecated use `WorkflowControllerGeneratePreviewResponse$Outbound` instead. */
  export type Outbound = WorkflowControllerGeneratePreviewResponse$Outbound;
}

export function workflowControllerGeneratePreviewResponseToJSON(
  workflowControllerGeneratePreviewResponse: WorkflowControllerGeneratePreviewResponse
): string {
  return JSON.stringify(
    WorkflowControllerGeneratePreviewResponse$outboundSchema.parse(workflowControllerGeneratePreviewResponse)
  );
}

export function workflowControllerGeneratePreviewResponseFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerGeneratePreviewResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerGeneratePreviewResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerGeneratePreviewResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowControllerGeneratePreviewRequestToJSON(workflowControllerGeneratePreviewRequest: WorkflowControllerGeneratePreviewRequest)
 - workflowControllerGeneratePreviewRequestFromJSON(jsonString: string)
 - workflowControllerGeneratePreviewResponseToJSON(workflowControllerGeneratePreviewResponse: WorkflowControllerGeneratePreviewResponse)
 - workflowControllerGeneratePreviewResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowControllerGeneratePreviewRequest$Outbound;
}

export function workflowControllerGeneratePrev...)
 - Outbound(WorkflowControllerGeneratePreviewResponse$Outbound;
}

export function workflowControllerGeneratePre...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerGeneratePreviewRequestToJSON
- export function workflowControllerGeneratePreviewRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerGeneratePreviewResponseToJSON
- export function workflowControllerGeneratePreviewResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/workflowcontrollergetworkflow.ts
Tamaño: 5508 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type WorkflowControllerGetWorkflowRequest = {
  workflowId: string;
  environmentId?: string | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type WorkflowControllerGetWorkflowResponse = {
  headers: { [k: string]: Array<string> };
  result: components.WorkflowResponseDto;
};

/** @internal */
export const WorkflowControllerGetWorkflowRequest$inboundSchema: z.ZodType<
  WorkflowControllerGetWorkflowRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    workflowId: z.string(),
    environmentId: z.string().optional(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type WorkflowControllerGetWorkflowRequest$Outbound = {
  workflowId: string;
  environmentId?: string | undefined;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const WorkflowControllerGetWorkflowRequest$outboundSchema: z.ZodType<
  WorkflowControllerGetWorkflowRequest$Outbound,
  z.ZodTypeDef,
  WorkflowControllerGetWorkflowRequest
> = z
  .object({
    workflowId: z.string(),
    environmentId: z.string().optional(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerGetWorkflowRequest$ {
  /** @deprecated use `WorkflowControllerGetWorkflowRequest$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerGetWorkflowRequest$inboundSchema;
  /** @deprecated use `WorkflowControllerGetWorkflowRequest$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerGetWorkflowRequest$outboundSchema;
  /** @deprecated use `WorkflowControllerGetWorkflowRequest$Outbound` instead. */
  export type Outbound = WorkflowControllerGetWorkflowRequest$Outbound;
}

export function workflowControllerGetWorkflowRequestToJSON(
  workflowControllerGetWorkflowRequest: WorkflowControllerGetWorkflowRequest
): string {
  return JSON.stringify(
    WorkflowControllerGetWorkflowRequest$outboundSchema.parse(workflowControllerGetWorkflowRequest)
  );
}

export function workflowControllerGetWorkflowRequestFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerGetWorkflowRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerGetWorkflowRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerGetWorkflowRequest' from JSON`
  );
}

/** @internal */
export const WorkflowControllerGetWorkflowResponse$inboundSchema: z.ZodType<
  WorkflowControllerGetWorkflowResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.WorkflowResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type WorkflowControllerGetWorkflowResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.WorkflowResponseDto$Outbound;
};

/** @internal */
export const WorkflowControllerGetWorkflowResponse$outboundSchema: z.ZodType<
  WorkflowControllerGetWorkflowResponse$Outbound,
  z.ZodTypeDef,
  WorkflowControllerGetWorkflowResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.WorkflowResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerGetWorkflowResponse$ {
  /** @deprecated use `WorkflowControllerGetWorkflowResponse$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerGetWorkflowResponse$inboundSchema;
  /** @deprecated use `WorkflowControllerGetWorkflowResponse$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerGetWorkflowResponse$outboundSchema;
  /** @deprecated use `WorkflowControllerGetWorkflowResponse$Outbound` instead. */
  export type Outbound = WorkflowControllerGetWorkflowResponse$Outbound;
}

export function workflowControllerGetWorkflowResponseToJSON(
  workflowControllerGetWorkflowResponse: WorkflowControllerGetWorkflowResponse
): string {
  return JSON.stringify(
    WorkflowControllerGetWorkflowResponse$outboundSchema.parse(workflowControllerGetWorkflowResponse)
  );
}

export function workflowControllerGetWorkflowResponseFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerGetWorkflowResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerGetWorkflowResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerGetWorkflowResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowControllerGetWorkflowRequestToJSON(workflowControllerGetWorkflowRequest: WorkflowControllerGetWorkflowRequest)
 - workflowControllerGetWorkflowRequestFromJSON(jsonString: string)
 - workflowControllerGetWorkflowResponseToJSON(workflowControllerGetWorkflowResponse: WorkflowControllerGetWorkflowResponse)
 - workflowControllerGetWorkflowResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowControllerGetWorkflowRequest$Outbound;
}

export function workflowControllerGetWorkflowReque...)
 - Outbound(WorkflowControllerGetWorkflowResponse$Outbound;
}

export function workflowControllerGetWorkflowResp...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerGetWorkflowRequestToJSON
- export function workflowControllerGetWorkflowRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerGetWorkflowResponseToJSON
- export function workflowControllerGetWorkflowResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/workflowcontrollergetworkflowstepdata.ts
Tamaño: 5784 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type WorkflowControllerGetWorkflowStepDataRequest = {
  workflowId: string;
  stepId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type WorkflowControllerGetWorkflowStepDataResponse = {
  headers: { [k: string]: Array<string> };
  result: components.StepResponseDto;
};

/** @internal */
export const WorkflowControllerGetWorkflowStepDataRequest$inboundSchema: z.ZodType<
  WorkflowControllerGetWorkflowStepDataRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    workflowId: z.string(),
    stepId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type WorkflowControllerGetWorkflowStepDataRequest$Outbound = {
  workflowId: string;
  stepId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const WorkflowControllerGetWorkflowStepDataRequest$outboundSchema: z.ZodType<
  WorkflowControllerGetWorkflowStepDataRequest$Outbound,
  z.ZodTypeDef,
  WorkflowControllerGetWorkflowStepDataRequest
> = z
  .object({
    workflowId: z.string(),
    stepId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerGetWorkflowStepDataRequest$ {
  /** @deprecated use `WorkflowControllerGetWorkflowStepDataRequest$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerGetWorkflowStepDataRequest$inboundSchema;
  /** @deprecated use `WorkflowControllerGetWorkflowStepDataRequest$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerGetWorkflowStepDataRequest$outboundSchema;
  /** @deprecated use `WorkflowControllerGetWorkflowStepDataRequest$Outbound` instead. */
  export type Outbound = WorkflowControllerGetWorkflowStepDataRequest$Outbound;
}

export function workflowControllerGetWorkflowStepDataRequestToJSON(
  workflowControllerGetWorkflowStepDataRequest: WorkflowControllerGetWorkflowStepDataRequest
): string {
  return JSON.stringify(
    WorkflowControllerGetWorkflowStepDataRequest$outboundSchema.parse(workflowControllerGetWorkflowStepDataRequest)
  );
}

export function workflowControllerGetWorkflowStepDataRequestFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerGetWorkflowStepDataRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerGetWorkflowStepDataRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerGetWorkflowStepDataRequest' from JSON`
  );
}

/** @internal */
export const WorkflowControllerGetWorkflowStepDataResponse$inboundSchema: z.ZodType<
  WorkflowControllerGetWorkflowStepDataResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.StepResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type WorkflowControllerGetWorkflowStepDataResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.StepResponseDto$Outbound;
};

/** @internal */
export const WorkflowControllerGetWorkflowStepDataResponse$outboundSchema: z.ZodType<
  WorkflowControllerGetWorkflowStepDataResponse$Outbound,
  z.ZodTypeDef,
  WorkflowControllerGetWorkflowStepDataResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.StepResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerGetWorkflowStepDataResponse$ {
  /** @deprecated use `WorkflowControllerGetWorkflowStepDataResponse$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerGetWorkflowStepDataResponse$inboundSchema;
  /** @deprecated use `WorkflowControllerGetWorkflowStepDataResponse$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerGetWorkflowStepDataResponse$outboundSchema;
  /** @deprecated use `WorkflowControllerGetWorkflowStepDataResponse$Outbound` instead. */
  export type Outbound = WorkflowControllerGetWorkflowStepDataResponse$Outbound;
}

export function workflowControllerGetWorkflowStepDataResponseToJSON(
  workflowControllerGetWorkflowStepDataResponse: WorkflowControllerGetWorkflowStepDataResponse
): string {
  return JSON.stringify(
    WorkflowControllerGetWorkflowStepDataResponse$outboundSchema.parse(workflowControllerGetWorkflowStepDataResponse)
  );
}

export function workflowControllerGetWorkflowStepDataResponseFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerGetWorkflowStepDataResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerGetWorkflowStepDataResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerGetWorkflowStepDataResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowControllerGetWorkflowStepDataRequestToJSON(workflowControllerGetWorkflowStepDataRequest: WorkflowControllerGetWorkflowStepDataRequest)
 - workflowControllerGetWorkflowStepDataRequestFromJSON(jsonString: string)
 - workflowControllerGetWorkflowStepDataResponseToJSON(workflowControllerGetWorkflowStepDataResponse: WorkflowControllerGetWorkflowStepDataResponse)
 - workflowControllerGetWorkflowStepDataResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowControllerGetWorkflowStepDataRequest$Outbound;
}

export function workflowControllerGetWorkf...)
 - Outbound(WorkflowControllerGetWorkflowStepDataResponse$Outbound;
}

export function workflowControllerGetWork...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerGetWorkflowStepDataRequestToJSON
- export function workflowControllerGetWorkflowStepDataRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerGetWorkflowStepDataResponseToJSON
- export function workflowControllerGetWorkflowStepDataResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/workflowcontrollerpatchworkflow.ts
Tamaño: 5806 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type WorkflowControllerPatchWorkflowRequest = {
  workflowId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  /**
   * Workflow patch details
   */
  patchWorkflowDto: components.PatchWorkflowDto;
};

export type WorkflowControllerPatchWorkflowResponse = {
  headers: { [k: string]: Array<string> };
  result: components.WorkflowResponseDto;
};

/** @internal */
export const WorkflowControllerPatchWorkflowRequest$inboundSchema: z.ZodType<
  WorkflowControllerPatchWorkflowRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    workflowId: z.string(),
    'idempotency-key': z.string().optional(),
    PatchWorkflowDto: components.PatchWorkflowDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      PatchWorkflowDto: 'patchWorkflowDto',
    });
  });

/** @internal */
export type WorkflowControllerPatchWorkflowRequest$Outbound = {
  workflowId: string;
  'idempotency-key'?: string | undefined;
  PatchWorkflowDto: components.PatchWorkflowDto$Outbound;
};

/** @internal */
export const WorkflowControllerPatchWorkflowRequest$outboundSchema: z.ZodType<
  WorkflowControllerPatchWorkflowRequest$Outbound,
  z.ZodTypeDef,
  WorkflowControllerPatchWorkflowRequest
> = z
  .object({
    workflowId: z.string(),
    idempotencyKey: z.string().optional(),
    patchWorkflowDto: components.PatchWorkflowDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      patchWorkflowDto: 'PatchWorkflowDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerPatchWorkflowRequest$ {
  /** @deprecated use `WorkflowControllerPatchWorkflowRequest$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerPatchWorkflowRequest$inboundSchema;
  /** @deprecated use `WorkflowControllerPatchWorkflowRequest$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerPatchWorkflowRequest$outboundSchema;
  /** @deprecated use `WorkflowControllerPatchWorkflowRequest$Outbound` instead. */
  export type Outbound = WorkflowControllerPatchWorkflowRequest$Outbound;
}

export function workflowControllerPatchWorkflowRequestToJSON(
  workflowControllerPatchWorkflowRequest: WorkflowControllerPatchWorkflowRequest
): string {
  return JSON.stringify(
    WorkflowControllerPatchWorkflowRequest$outboundSchema.parse(workflowControllerPatchWorkflowRequest)
  );
}

export function workflowControllerPatchWorkflowRequestFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerPatchWorkflowRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerPatchWorkflowRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerPatchWorkflowRequest' from JSON`
  );
}

/** @internal */
export const WorkflowControllerPatchWorkflowResponse$inboundSchema: z.ZodType<
  WorkflowControllerPatchWorkflowResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.WorkflowResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type WorkflowControllerPatchWorkflowResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.WorkflowResponseDto$Outbound;
};

/** @internal */
export const WorkflowControllerPatchWorkflowResponse$outboundSchema: z.ZodType<
  WorkflowControllerPatchWorkflowResponse$Outbound,
  z.ZodTypeDef,
  WorkflowControllerPatchWorkflowResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.WorkflowResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerPatchWorkflowResponse$ {
  /** @deprecated use `WorkflowControllerPatchWorkflowResponse$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerPatchWorkflowResponse$inboundSchema;
  /** @deprecated use `WorkflowControllerPatchWorkflowResponse$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerPatchWorkflowResponse$outboundSchema;
  /** @deprecated use `WorkflowControllerPatchWorkflowResponse$Outbound` instead. */
  export type Outbound = WorkflowControllerPatchWorkflowResponse$Outbound;
}

export function workflowControllerPatchWorkflowResponseToJSON(
  workflowControllerPatchWorkflowResponse: WorkflowControllerPatchWorkflowResponse
): string {
  return JSON.stringify(
    WorkflowControllerPatchWorkflowResponse$outboundSchema.parse(workflowControllerPatchWorkflowResponse)
  );
}

export function workflowControllerPatchWorkflowResponseFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerPatchWorkflowResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerPatchWorkflowResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerPatchWorkflowResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowControllerPatchWorkflowRequestToJSON(workflowControllerPatchWorkflowRequest: WorkflowControllerPatchWorkflowRequest)
 - workflowControllerPatchWorkflowRequestFromJSON(jsonString: string)
 - workflowControllerPatchWorkflowResponseToJSON(workflowControllerPatchWorkflowResponse: WorkflowControllerPatchWorkflowResponse)
 - workflowControllerPatchWorkflowResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowControllerPatchWorkflowRequest$Outbound;
}

export function workflowControllerPatchWorkflowR...)
 - Outbound(WorkflowControllerPatchWorkflowResponse$Outbound;
}

export function workflowControllerPatchWorkflow...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerPatchWorkflowRequestToJSON
- export function workflowControllerPatchWorkflowRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerPatchWorkflowResponseToJSON
- export function workflowControllerPatchWorkflowResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/workflowcontrollerremoveworkflow.ts
Tamaño: 5174 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type WorkflowControllerRemoveWorkflowRequest = {
  workflowId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type WorkflowControllerRemoveWorkflowResponse = {
  headers: { [k: string]: Array<string> };
};

/** @internal */
export const WorkflowControllerRemoveWorkflowRequest$inboundSchema: z.ZodType<
  WorkflowControllerRemoveWorkflowRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    workflowId: z.string(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type WorkflowControllerRemoveWorkflowRequest$Outbound = {
  workflowId: string;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const WorkflowControllerRemoveWorkflowRequest$outboundSchema: z.ZodType<
  WorkflowControllerRemoveWorkflowRequest$Outbound,
  z.ZodTypeDef,
  WorkflowControllerRemoveWorkflowRequest
> = z
  .object({
    workflowId: z.string(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerRemoveWorkflowRequest$ {
  /** @deprecated use `WorkflowControllerRemoveWorkflowRequest$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerRemoveWorkflowRequest$inboundSchema;
  /** @deprecated use `WorkflowControllerRemoveWorkflowRequest$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerRemoveWorkflowRequest$outboundSchema;
  /** @deprecated use `WorkflowControllerRemoveWorkflowRequest$Outbound` instead. */
  export type Outbound = WorkflowControllerRemoveWorkflowRequest$Outbound;
}

export function workflowControllerRemoveWorkflowRequestToJSON(
  workflowControllerRemoveWorkflowRequest: WorkflowControllerRemoveWorkflowRequest
): string {
  return JSON.stringify(
    WorkflowControllerRemoveWorkflowRequest$outboundSchema.parse(workflowControllerRemoveWorkflowRequest)
  );
}

export function workflowControllerRemoveWorkflowRequestFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerRemoveWorkflowRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerRemoveWorkflowRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerRemoveWorkflowRequest' from JSON`
  );
}

/** @internal */
export const WorkflowControllerRemoveWorkflowResponse$inboundSchema: z.ZodType<
  WorkflowControllerRemoveWorkflowResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
    });
  });

/** @internal */
export type WorkflowControllerRemoveWorkflowResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
};

/** @internal */
export const WorkflowControllerRemoveWorkflowResponse$outboundSchema: z.ZodType<
  WorkflowControllerRemoveWorkflowResponse$Outbound,
  z.ZodTypeDef,
  WorkflowControllerRemoveWorkflowResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerRemoveWorkflowResponse$ {
  /** @deprecated use `WorkflowControllerRemoveWorkflowResponse$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerRemoveWorkflowResponse$inboundSchema;
  /** @deprecated use `WorkflowControllerRemoveWorkflowResponse$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerRemoveWorkflowResponse$outboundSchema;
  /** @deprecated use `WorkflowControllerRemoveWorkflowResponse$Outbound` instead. */
  export type Outbound = WorkflowControllerRemoveWorkflowResponse$Outbound;
}

export function workflowControllerRemoveWorkflowResponseToJSON(
  workflowControllerRemoveWorkflowResponse: WorkflowControllerRemoveWorkflowResponse
): string {
  return JSON.stringify(
    WorkflowControllerRemoveWorkflowResponse$outboundSchema.parse(workflowControllerRemoveWorkflowResponse)
  );
}

export function workflowControllerRemoveWorkflowResponseFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerRemoveWorkflowResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerRemoveWorkflowResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerRemoveWorkflowResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowControllerRemoveWorkflowRequestToJSON(workflowControllerRemoveWorkflowRequest: WorkflowControllerRemoveWorkflowRequest)
 - workflowControllerRemoveWorkflowRequestFromJSON(jsonString: string)
 - workflowControllerRemoveWorkflowResponseToJSON(workflowControllerRemoveWorkflowResponse: WorkflowControllerRemoveWorkflowResponse)
 - workflowControllerRemoveWorkflowResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowControllerRemoveWorkflowRequest$Outbound;
}

export function workflowControllerRemoveWorkflo...)
 - Outbound(WorkflowControllerRemoveWorkflowResponse$Outbound;
}

export function workflowControllerRemoveWorkfl...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerRemoveWorkflowRequestToJSON
- export function workflowControllerRemoveWorkflowRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerRemoveWorkflowResponseToJSON
- export function workflowControllerRemoveWorkflowResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/workflowcontrollersearchworkflows.ts
Tamaño: 7076 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type WorkflowControllerSearchWorkflowsRequest = {
  /**
   * Number of items to return per page
   */
  limit?: number | undefined;
  /**
   * Number of items to skip before starting to return results
   */
  offset?: number | undefined;
  /**
   * Direction of sorting
   */
  orderDirection?: components.DirectionEnum | undefined;
  /**
   * Field to sort the results by
   */
  orderBy?: components.WorkflowResponseDtoSortField | undefined;
  /**
   * Search query to filter workflows
   */
  query?: string | undefined;
  /**
   * Filter workflows by tags
   */
  tags?: Array<string> | undefined;
  /**
   * Filter workflows by status
   */
  status?: Array<components.WorkflowStatusEnum> | undefined;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
};

export type WorkflowControllerSearchWorkflowsResponse = {
  headers: { [k: string]: Array<string> };
  result: components.ListWorkflowResponse;
};

/** @internal */
export const WorkflowControllerSearchWorkflowsRequest$inboundSchema: z.ZodType<
  WorkflowControllerSearchWorkflowsRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    limit: z.number().optional(),
    offset: z.number().optional(),
    orderDirection: components.DirectionEnum$inboundSchema.optional(),
    orderBy: components.WorkflowResponseDtoSortField$inboundSchema.optional(),
    query: z.string().optional(),
    tags: z.array(z.string()).optional(),
    status: z.array(components.WorkflowStatusEnum$inboundSchema).optional(),
    'idempotency-key': z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
    });
  });

/** @internal */
export type WorkflowControllerSearchWorkflowsRequest$Outbound = {
  limit?: number | undefined;
  offset?: number | undefined;
  orderDirection?: string | undefined;
  orderBy?: string | undefined;
  query?: string | undefined;
  tags?: Array<string> | undefined;
  status?: Array<string> | undefined;
  'idempotency-key'?: string | undefined;
};

/** @internal */
export const WorkflowControllerSearchWorkflowsRequest$outboundSchema: z.ZodType<
  WorkflowControllerSearchWorkflowsRequest$Outbound,
  z.ZodTypeDef,
  WorkflowControllerSearchWorkflowsRequest
> = z
  .object({
    limit: z.number().optional(),
    offset: z.number().optional(),
    orderDirection: components.DirectionEnum$outboundSchema.optional(),
    orderBy: components.WorkflowResponseDtoSortField$outboundSchema.optional(),
    query: z.string().optional(),
    tags: z.array(z.string()).optional(),
    status: z.array(components.WorkflowStatusEnum$outboundSchema).optional(),
    idempotencyKey: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerSearchWorkflowsRequest$ {
  /** @deprecated use `WorkflowControllerSearchWorkflowsRequest$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerSearchWorkflowsRequest$inboundSchema;
  /** @deprecated use `WorkflowControllerSearchWorkflowsRequest$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerSearchWorkflowsRequest$outboundSchema;
  /** @deprecated use `WorkflowControllerSearchWorkflowsRequest$Outbound` instead. */
  export type Outbound = WorkflowControllerSearchWorkflowsRequest$Outbound;
}

export function workflowControllerSearchWorkflowsRequestToJSON(
  workflowControllerSearchWorkflowsRequest: WorkflowControllerSearchWorkflowsRequest
): string {
  return JSON.stringify(
    WorkflowControllerSearchWorkflowsRequest$outboundSchema.parse(workflowControllerSearchWorkflowsRequest)
  );
}

export function workflowControllerSearchWorkflowsRequestFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerSearchWorkflowsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerSearchWorkflowsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerSearchWorkflowsRequest' from JSON`
  );
}

/** @internal */
export const WorkflowControllerSearchWorkflowsResponse$inboundSchema: z.ZodType<
  WorkflowControllerSearchWorkflowsResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.ListWorkflowResponse$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type WorkflowControllerSearchWorkflowsResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.ListWorkflowResponse$Outbound;
};

/** @internal */
export const WorkflowControllerSearchWorkflowsResponse$outboundSchema: z.ZodType<
  WorkflowControllerSearchWorkflowsResponse$Outbound,
  z.ZodTypeDef,
  WorkflowControllerSearchWorkflowsResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.ListWorkflowResponse$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerSearchWorkflowsResponse$ {
  /** @deprecated use `WorkflowControllerSearchWorkflowsResponse$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerSearchWorkflowsResponse$inboundSchema;
  /** @deprecated use `WorkflowControllerSearchWorkflowsResponse$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerSearchWorkflowsResponse$outboundSchema;
  /** @deprecated use `WorkflowControllerSearchWorkflowsResponse$Outbound` instead. */
  export type Outbound = WorkflowControllerSearchWorkflowsResponse$Outbound;
}

export function workflowControllerSearchWorkflowsResponseToJSON(
  workflowControllerSearchWorkflowsResponse: WorkflowControllerSearchWorkflowsResponse
): string {
  return JSON.stringify(
    WorkflowControllerSearchWorkflowsResponse$outboundSchema.parse(workflowControllerSearchWorkflowsResponse)
  );
}

export function workflowControllerSearchWorkflowsResponseFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerSearchWorkflowsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerSearchWorkflowsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerSearchWorkflowsResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowControllerSearchWorkflowsRequestToJSON(workflowControllerSearchWorkflowsRequest: WorkflowControllerSearchWorkflowsRequest)
 - workflowControllerSearchWorkflowsRequestFromJSON(jsonString: string)
 - workflowControllerSearchWorkflowsResponseToJSON(workflowControllerSearchWorkflowsResponse: WorkflowControllerSearchWorkflowsResponse)
 - workflowControllerSearchWorkflowsResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowControllerSearchWorkflowsRequest$Outbound;
}

export function workflowControllerSearchWorkfl...)
 - Outbound(WorkflowControllerSearchWorkflowsResponse$Outbound;
}

export function workflowControllerSearchWorkf...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerSearchWorkflowsRequestToJSON
- export function workflowControllerSearchWorkflowsRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerSearchWorkflowsResponseToJSON
- export function workflowControllerSearchWorkflowsResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/workflowcontrollersync.ts
Tamaño: 5363 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type WorkflowControllerSyncRequest = {
  workflowId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  /**
   * Sync workflow details
   */
  syncWorkflowDto: components.SyncWorkflowDto;
};

export type WorkflowControllerSyncResponse = {
  headers: { [k: string]: Array<string> };
  result: components.WorkflowResponseDto;
};

/** @internal */
export const WorkflowControllerSyncRequest$inboundSchema: z.ZodType<
  WorkflowControllerSyncRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    workflowId: z.string(),
    'idempotency-key': z.string().optional(),
    SyncWorkflowDto: components.SyncWorkflowDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      SyncWorkflowDto: 'syncWorkflowDto',
    });
  });

/** @internal */
export type WorkflowControllerSyncRequest$Outbound = {
  workflowId: string;
  'idempotency-key'?: string | undefined;
  SyncWorkflowDto: components.SyncWorkflowDto$Outbound;
};

/** @internal */
export const WorkflowControllerSyncRequest$outboundSchema: z.ZodType<
  WorkflowControllerSyncRequest$Outbound,
  z.ZodTypeDef,
  WorkflowControllerSyncRequest
> = z
  .object({
    workflowId: z.string(),
    idempotencyKey: z.string().optional(),
    syncWorkflowDto: components.SyncWorkflowDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      syncWorkflowDto: 'SyncWorkflowDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerSyncRequest$ {
  /** @deprecated use `WorkflowControllerSyncRequest$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerSyncRequest$inboundSchema;
  /** @deprecated use `WorkflowControllerSyncRequest$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerSyncRequest$outboundSchema;
  /** @deprecated use `WorkflowControllerSyncRequest$Outbound` instead. */
  export type Outbound = WorkflowControllerSyncRequest$Outbound;
}

export function workflowControllerSyncRequestToJSON(
  workflowControllerSyncRequest: WorkflowControllerSyncRequest
): string {
  return JSON.stringify(WorkflowControllerSyncRequest$outboundSchema.parse(workflowControllerSyncRequest));
}

export function workflowControllerSyncRequestFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerSyncRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerSyncRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerSyncRequest' from JSON`
  );
}

/** @internal */
export const WorkflowControllerSyncResponse$inboundSchema: z.ZodType<
  WorkflowControllerSyncResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.WorkflowResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type WorkflowControllerSyncResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.WorkflowResponseDto$Outbound;
};

/** @internal */
export const WorkflowControllerSyncResponse$outboundSchema: z.ZodType<
  WorkflowControllerSyncResponse$Outbound,
  z.ZodTypeDef,
  WorkflowControllerSyncResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.WorkflowResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerSyncResponse$ {
  /** @deprecated use `WorkflowControllerSyncResponse$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerSyncResponse$inboundSchema;
  /** @deprecated use `WorkflowControllerSyncResponse$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerSyncResponse$outboundSchema;
  /** @deprecated use `WorkflowControllerSyncResponse$Outbound` instead. */
  export type Outbound = WorkflowControllerSyncResponse$Outbound;
}

export function workflowControllerSyncResponseToJSON(
  workflowControllerSyncResponse: WorkflowControllerSyncResponse
): string {
  return JSON.stringify(WorkflowControllerSyncResponse$outboundSchema.parse(workflowControllerSyncResponse));
}

export function workflowControllerSyncResponseFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerSyncResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerSyncResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerSyncResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowControllerSyncRequestToJSON(workflowControllerSyncRequest: WorkflowControllerSyncRequest)
 - workflowControllerSyncRequestFromJSON(jsonString: string)
 - workflowControllerSyncResponseToJSON(workflowControllerSyncResponse: WorkflowControllerSyncResponse)
 - workflowControllerSyncResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowControllerSyncRequest$Outbound;
}

export function workflowControllerSyncRequestToJSON(
  wo...)
 - Outbound(WorkflowControllerSyncResponse$Outbound;
}

export function workflowControllerSyncResponseToJSON(
  ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerSyncRequestToJSON
- export function workflowControllerSyncRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerSyncResponseToJSON
- export function workflowControllerSyncResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/operations/workflowcontrollerupdate.ts
Tamaño: 5481 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import * as components from '../components/index.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type WorkflowControllerUpdateRequest = {
  workflowId: string;
  /**
   * A header for idempotency purposes
   */
  idempotencyKey?: string | undefined;
  /**
   * Workflow update details
   */
  updateWorkflowDto: components.UpdateWorkflowDto;
};

export type WorkflowControllerUpdateResponse = {
  headers: { [k: string]: Array<string> };
  result: components.WorkflowResponseDto;
};

/** @internal */
export const WorkflowControllerUpdateRequest$inboundSchema: z.ZodType<
  WorkflowControllerUpdateRequest,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    workflowId: z.string(),
    'idempotency-key': z.string().optional(),
    UpdateWorkflowDto: components.UpdateWorkflowDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      'idempotency-key': 'idempotencyKey',
      UpdateWorkflowDto: 'updateWorkflowDto',
    });
  });

/** @internal */
export type WorkflowControllerUpdateRequest$Outbound = {
  workflowId: string;
  'idempotency-key'?: string | undefined;
  UpdateWorkflowDto: components.UpdateWorkflowDto$Outbound;
};

/** @internal */
export const WorkflowControllerUpdateRequest$outboundSchema: z.ZodType<
  WorkflowControllerUpdateRequest$Outbound,
  z.ZodTypeDef,
  WorkflowControllerUpdateRequest
> = z
  .object({
    workflowId: z.string(),
    idempotencyKey: z.string().optional(),
    updateWorkflowDto: components.UpdateWorkflowDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      idempotencyKey: 'idempotency-key',
      updateWorkflowDto: 'UpdateWorkflowDto',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerUpdateRequest$ {
  /** @deprecated use `WorkflowControllerUpdateRequest$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerUpdateRequest$inboundSchema;
  /** @deprecated use `WorkflowControllerUpdateRequest$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerUpdateRequest$outboundSchema;
  /** @deprecated use `WorkflowControllerUpdateRequest$Outbound` instead. */
  export type Outbound = WorkflowControllerUpdateRequest$Outbound;
}

export function workflowControllerUpdateRequestToJSON(
  workflowControllerUpdateRequest: WorkflowControllerUpdateRequest
): string {
  return JSON.stringify(WorkflowControllerUpdateRequest$outboundSchema.parse(workflowControllerUpdateRequest));
}

export function workflowControllerUpdateRequestFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerUpdateRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerUpdateRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerUpdateRequest' from JSON`
  );
}

/** @internal */
export const WorkflowControllerUpdateResponse$inboundSchema: z.ZodType<
  WorkflowControllerUpdateResponse,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    Headers: z.record(z.array(z.string())),
    Result: components.WorkflowResponseDto$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      Headers: 'headers',
      Result: 'result',
    });
  });

/** @internal */
export type WorkflowControllerUpdateResponse$Outbound = {
  Headers: { [k: string]: Array<string> };
  Result: components.WorkflowResponseDto$Outbound;
};

/** @internal */
export const WorkflowControllerUpdateResponse$outboundSchema: z.ZodType<
  WorkflowControllerUpdateResponse$Outbound,
  z.ZodTypeDef,
  WorkflowControllerUpdateResponse
> = z
  .object({
    headers: z.record(z.array(z.string())),
    result: components.WorkflowResponseDto$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      headers: 'Headers',
      result: 'Result',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WorkflowControllerUpdateResponse$ {
  /** @deprecated use `WorkflowControllerUpdateResponse$inboundSchema` instead. */
  export const inboundSchema = WorkflowControllerUpdateResponse$inboundSchema;
  /** @deprecated use `WorkflowControllerUpdateResponse$outboundSchema` instead. */
  export const outboundSchema = WorkflowControllerUpdateResponse$outboundSchema;
  /** @deprecated use `WorkflowControllerUpdateResponse$Outbound` instead. */
  export type Outbound = WorkflowControllerUpdateResponse$Outbound;
}

export function workflowControllerUpdateResponseToJSON(
  workflowControllerUpdateResponse: WorkflowControllerUpdateResponse
): string {
  return JSON.stringify(WorkflowControllerUpdateResponse$outboundSchema.parse(workflowControllerUpdateResponse));
}

export function workflowControllerUpdateResponseFromJSON(
  jsonString: string
): SafeParseResult<WorkflowControllerUpdateResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WorkflowControllerUpdateResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WorkflowControllerUpdateResponse' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowControllerUpdateRequestToJSON(workflowControllerUpdateRequest: WorkflowControllerUpdateRequest)
 - workflowControllerUpdateRequestFromJSON(jsonString: string)
 - workflowControllerUpdateResponseToJSON(workflowControllerUpdateResponse: WorkflowControllerUpdateResponse)
 - workflowControllerUpdateResponseFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(WorkflowControllerUpdateRequest$Outbound;
}

export function workflowControllerUpdateRequestToJSON(
...)
 - Outbound(WorkflowControllerUpdateResponse$Outbound;
}

export function workflowControllerUpdateResponseToJSON...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerUpdateRequestToJSON
- export function workflowControllerUpdateRequestFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function workflowControllerUpdateResponseToJSON
- export function workflowControllerUpdateResponseFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/_context.tsx
Tamaño: 605 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###


import React from "react";

import { NovuCore } from "../core.js";

const NovuContext = React.createContext<NovuCore | null>(null);

export function NovuProvider(props: { client: NovuCore, children: React.ReactNode }): React.ReactNode { 
  return (
    <NovuContext.Provider value={props.client}>
      {props.children}
    </NovuContext.Provider>
  );
}

export function useNovuContext(): NovuCore { 
  const value = React.useContext(NovuContext);
  if (value === null) {
    throw new Error("SDK not initialized. Create an instance of NovuCore and pass it to <NovuProvider />.");
  }
  return value;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import React from "react";
import { NovuCore } from "../core.js";
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/_types.ts
Tamaño: 3801 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { RequestOptions } from "../lib/sdks.js";
import { PageIterator } from "../types/operations.js";

import type {
  DefaultError,
  InfiniteData,
  InfiniteQueryPageParamsOptions,
  OmitKeyof,
  QueryKey,
  QueryObserverOptions,
  SkipToken,
  UseMutationOptions,
  UseQueryOptions,
  UseSuspenseQueryOptions,
} from "@tanstack/react-query";

// Reaction to breaking change in 5.80.0 https://github.com/TanStack/query/pull/9224#issuecomment-2934835936
interface UseInfiniteQueryOptions<
  TQueryFnData = unknown,
  TError = DefaultError,
  TData = TQueryFnData,
  TQueryKey extends QueryKey = QueryKey,
  TPageParam = unknown,
> extends
  OmitKeyof<
    InfiniteQueryObserverOptions<
      TQueryFnData,
      TError,
      TData,
      TQueryKey,
      TPageParam
    >,
    "suspense"
  >
{
  /**
   * Set this to `false` to unsubscribe this observer from updates to the query cache.
   * Defaults to `true`.
   */
  subscribed?: boolean;
}

// Reaction to breaking change in 5.80.0 https://github.com/TanStack/query/pull/9224#issuecomment-2934835936
interface InfiniteQueryObserverOptions<
  TQueryFnData = unknown,
  TError = DefaultError,
  TData = TQueryFnData,
  TQueryKey extends QueryKey = QueryKey,
  TPageParam = unknown,
> extends
  QueryObserverOptions<
    TQueryFnData,
    TError,
    TData,
    InfiniteData<TQueryFnData, TPageParam>,
    TQueryKey,
    TPageParam
  >,
  InfiniteQueryPageParamsOptions<TQueryFnData, TPageParam>
{
}

// Reaction to breaking change in 5.80.0 https://github.com/TanStack/query/pull/9224#issuecomment-2934835936
interface UseSuspenseInfiniteQueryOptions<
  TQueryFnData = unknown,
  TError = DefaultError,
  TData = TQueryFnData,
  TQueryKey extends QueryKey = QueryKey,
  TPageParam = unknown,
> extends
  OmitKeyof<
    UseInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>,
    "queryFn" | "enabled" | "throwOnError" | "placeholderData"
  >
{
  queryFn?: Exclude<
    UseInfiniteQueryOptions<
      TQueryFnData,
      TError,
      TData,
      TQueryKey,
      TPageParam
    >["queryFn"],
    SkipToken
  >;
}
export type TupleToPrefixes<T extends any[]> = T extends [...infer Prefix, any]
  ? TupleToPrefixes<Prefix> | T
  : never;

export type QueryHookOptions<Data> =
  & Omit<
    UseQueryOptions<Data, Error>,
    "queryKey" | "queryFn" | "select" | keyof RequestOptions
  >
  & RequestOptions;

export type SuspenseQueryHookOptions<Data> =
  & Omit<
    UseSuspenseQueryOptions<Data, Error>,
    "queryKey" | "queryFn" | "select" | keyof RequestOptions
  >
  & RequestOptions;

export type InfiniteQueryHookOptions<
  Data extends PageIterator<unknown, unknown>,
> =
  & Omit<
    UseInfiniteQueryOptions<
      Data,
      Error,
      InfiniteData<Data, Data["~next"]>,
      QueryKey,
      Data["~next"]
    >,
    | "queryKey"
    | "queryFn"
    | "select"
    | "getNextPageParam"
    | "getPreviousPageParam"
    | "initialPageParam"
    | keyof RequestOptions
  >
  & RequestOptions
  & { initialPageParam?: Data["~next"] };

export type SuspenseInfiniteQueryHookOptions<
  Data extends PageIterator<unknown, unknown>,
> =
  & Omit<
    UseSuspenseInfiniteQueryOptions<
      Data,
      Error,
      InfiniteData<Data, Data["~next"]>,
      QueryKey,
      Data["~next"]
    >,
    | "queryKey"
    | "queryFn"
    | "select"
    | "getNextPageParam"
    | "getPreviousPageParam"
    | "initialPageParam"
    | keyof RequestOptions
  >
  & RequestOptions
  & { initialPageParam?: Data["~next"] };

export type MutationHookOptions<
  Data = unknown,
  Err = Error,
  Variables = unknown,
> =
  & Omit<
    UseMutationOptions<Data, Err, Variables>,
    "mutationKey" | "mutationFn" | keyof RequestOptions
  >
  & RequestOptions;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/activityChartsRetrieve.ts
Tamaño: 5951 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { activityChartsRetrieve } from "../funcs/activityChartsRetrieve.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type ActivityChartsRetrieveQueryData = components.GetChartsResponseDto;

/**
 * Retrieve activity charts
 *
 * @remarks
 * Retrieve chart data for activity analytics and metrics visualization.
 */
export function useActivityChartsRetrieve(
  request: operations.ActivityControllerGetChartsRequest,
  options?: QueryHookOptions<ActivityChartsRetrieveQueryData>,
): UseQueryResult<ActivityChartsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildActivityChartsRetrieveQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

/**
 * Retrieve activity charts
 *
 * @remarks
 * Retrieve chart data for activity analytics and metrics visualization.
 */
export function useActivityChartsRetrieveSuspense(
  request: operations.ActivityControllerGetChartsRequest,
  options?: SuspenseQueryHookOptions<ActivityChartsRetrieveQueryData>,
): UseSuspenseQueryResult<ActivityChartsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildActivityChartsRetrieveQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

export function prefetchActivityChartsRetrieve(
  queryClient: QueryClient,
  client$: NovuCore,
  request: operations.ActivityControllerGetChartsRequest,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildActivityChartsRetrieveQuery(
      client$,
      request,
    ),
  });
}

export function setActivityChartsRetrieveData(
  client: QueryClient,
  queryKeyBase: [
    parameters: {
      createdAtGte?: string | undefined;
      createdAtLte?: string | undefined;
      reportType: Array<operations.ReportType>;
      workflowIds?: Array<string> | undefined;
      subscriberIds?: Array<string> | undefined;
      transactionIds?: Array<string> | undefined;
      statuses?: Array<operations.Statuses> | undefined;
      channels?: Array<string> | undefined;
      topicKey?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: ActivityChartsRetrieveQueryData,
): ActivityChartsRetrieveQueryData | undefined {
  const key = queryKeyActivityChartsRetrieve(...queryKeyBase);

  return client.setQueryData<ActivityChartsRetrieveQueryData>(key, data);
}

export function invalidateActivityChartsRetrieve(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      createdAtGte?: string | undefined;
      createdAtLte?: string | undefined;
      reportType: Array<operations.ReportType>;
      workflowIds?: Array<string> | undefined;
      subscriberIds?: Array<string> | undefined;
      transactionIds?: Array<string> | undefined;
      statuses?: Array<operations.Statuses> | undefined;
      channels?: Array<string> | undefined;
      topicKey?: string | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Charts", "retrieve", ...queryKeyBase],
  });
}

export function invalidateAllActivityChartsRetrieve(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Charts", "retrieve"],
  });
}

export function buildActivityChartsRetrieveQuery(
  client$: NovuCore,
  request: operations.ActivityControllerGetChartsRequest,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<ActivityChartsRetrieveQueryData>;
} {
  return {
    queryKey: queryKeyActivityChartsRetrieve({
      createdAtGte: request.createdAtGte,
      createdAtLte: request.createdAtLte,
      reportType: request.reportType,
      workflowIds: request.workflowIds,
      subscriberIds: request.subscriberIds,
      transactionIds: request.transactionIds,
      statuses: request.statuses,
      channels: request.channels,
      topicKey: request.topicKey,
      idempotencyKey: request.idempotencyKey,
    }),
    queryFn: async function activityChartsRetrieveQueryFn(
      ctx,
    ): Promise<ActivityChartsRetrieveQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(activityChartsRetrieve(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyActivityChartsRetrieve(
  parameters: {
    createdAtGte?: string | undefined;
    createdAtLte?: string | undefined;
    reportType: Array<operations.ReportType>;
    workflowIds?: Array<string> | undefined;
    subscriberIds?: Array<string> | undefined;
    transactionIds?: Array<string> | undefined;
    statuses?: Array<operations.Statuses> | undefined;
    channels?: Array<string> | undefined;
    topicKey?: string | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return ["@novu/api", "Charts", "retrieve", parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useActivityChartsRetrieve(request: operations.ActivityControllerGetChartsRequest,
  options?: QueryHookOptions<ActivityChartsRetrieveQueryData>,)
 - useActivityChartsRetrieveSuspense(request: operations.ActivityControllerGetChartsRequest,
  options?: SuspenseQueryHookOptions<ActivityChartsRetrieveQueryData>,)
 - prefetchActivityChartsRetrieve(queryClient: QueryClient,
  client$: NovuCore,
  request: operations.ActivityControllerGetChartsRequest,)
 - setActivityChartsRetrieveData(client: QueryClient,
  queryKeyBase: [
    parameters: {
      createdAtGte?: string | undefined;
      createdAtLte?: string | undefined;
      reportType: Array<operations.ReportType>;
      workflowIds?: Array<string> | undefined;
      subscriberIds?: Array<string> | undefined;
      transactionIds?: Array<string> | undefined;
      statuses?: Array<operations.Statuses> | undefined;
      channels?: Array<string> | undefined;
      topicKey?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: ActivityChartsRetrieveQueryData,)
 - invalidateActivityChartsRetrieve(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      createdAtGte?: string | undefined;
      createdAtLte?: string | undefined;
      reportType: Array<operations.ReportType>;
      workflowIds?: Array<string> | undefined;
      subscriberIds?: Array<string> | undefined;
      transactionIds?: Array<string> | undefined;
      statuses?: Array<operations.Statuses> | undefined;
      channels?: Array<string> | undefined;
      topicKey?: string | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllActivityChartsRetrieve(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildActivityChartsRetrieveQuery(client$: NovuCore,
  request: operations.ActivityControllerGetChartsRequest,
  options?: RequestOptions,)
 - activityChartsRetrieveQueryFn(ctx,)
 - queryKeyActivityChartsRetrieve(parameters: {
    createdAtGte?: string | undefined;
    createdAtLte?: string | undefined;
    reportType: Array<operations.ReportType>;
    workflowIds?: Array<string> | undefined;
    subscriberIds?: Array<string> | undefined;
    transactionIds?: Array<string> | undefined;
    statuses?: Array<operations.Statuses> | undefined;
    channels?: Array<string> | undefined;
    topicKey?: string | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyActivityChartsRetrieve(...queryKeyBase);

  return client.setQueryData<ActivityChartsRetriev...)
Declaraciones 'export' encontradas:
- export  type
- export function useActivityChartsRetrieve
- export function useActivityChartsRetrieveSuspense
- export function prefetchActivityChartsRetrieve
- export function setActivityChartsRetrieveData
- export function invalidateActivityChartsRetrieve
- export function invalidateAllActivityChartsRetrieve
- export function buildActivityChartsRetrieveQuery
- export function queryKeyActivityChartsRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/activityRequestsList.ts
Tamaño: 5221 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { activityRequestsList } from "../funcs/activityRequestsList.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type ActivityRequestsListQueryData = components.GetRequestsResponseDto;

/**
 * List activity requests
 *
 * @remarks
 * Retrieve a list of activity requests with optional filtering and pagination.
 */
export function useActivityRequestsList(
  request: operations.ActivityControllerGetLogsRequest,
  options?: QueryHookOptions<ActivityRequestsListQueryData>,
): UseQueryResult<ActivityRequestsListQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildActivityRequestsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

/**
 * List activity requests
 *
 * @remarks
 * Retrieve a list of activity requests with optional filtering and pagination.
 */
export function useActivityRequestsListSuspense(
  request: operations.ActivityControllerGetLogsRequest,
  options?: SuspenseQueryHookOptions<ActivityRequestsListQueryData>,
): UseSuspenseQueryResult<ActivityRequestsListQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildActivityRequestsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

export function prefetchActivityRequestsList(
  queryClient: QueryClient,
  client$: NovuCore,
  request: operations.ActivityControllerGetLogsRequest,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildActivityRequestsListQuery(
      client$,
      request,
    ),
  });
}

export function setActivityRequestsListData(
  client: QueryClient,
  queryKeyBase: [
    parameters: {
      page?: number | undefined;
      limit?: number | undefined;
      statusCodes?: Array<number> | undefined;
      urlPattern?: string | undefined;
      transactionId?: string | undefined;
      createdGte?: number | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: ActivityRequestsListQueryData,
): ActivityRequestsListQueryData | undefined {
  const key = queryKeyActivityRequestsList(...queryKeyBase);

  return client.setQueryData<ActivityRequestsListQueryData>(key, data);
}

export function invalidateActivityRequestsList(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      page?: number | undefined;
      limit?: number | undefined;
      statusCodes?: Array<number> | undefined;
      urlPattern?: string | undefined;
      transactionId?: string | undefined;
      createdGte?: number | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Requests", "list", ...queryKeyBase],
  });
}

export function invalidateAllActivityRequestsList(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Requests", "list"],
  });
}

export function buildActivityRequestsListQuery(
  client$: NovuCore,
  request: operations.ActivityControllerGetLogsRequest,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<ActivityRequestsListQueryData>;
} {
  return {
    queryKey: queryKeyActivityRequestsList({
      page: request.page,
      limit: request.limit,
      statusCodes: request.statusCodes,
      urlPattern: request.urlPattern,
      transactionId: request.transactionId,
      createdGte: request.createdGte,
      idempotencyKey: request.idempotencyKey,
    }),
    queryFn: async function activityRequestsListQueryFn(
      ctx,
    ): Promise<ActivityRequestsListQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(activityRequestsList(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyActivityRequestsList(
  parameters: {
    page?: number | undefined;
    limit?: number | undefined;
    statusCodes?: Array<number> | undefined;
    urlPattern?: string | undefined;
    transactionId?: string | undefined;
    createdGte?: number | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return ["@novu/api", "Requests", "list", parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useActivityRequestsList(request: operations.ActivityControllerGetLogsRequest,
  options?: QueryHookOptions<ActivityRequestsListQueryData>,)
 - useActivityRequestsListSuspense(request: operations.ActivityControllerGetLogsRequest,
  options?: SuspenseQueryHookOptions<ActivityRequestsListQueryData>,)
 - prefetchActivityRequestsList(queryClient: QueryClient,
  client$: NovuCore,
  request: operations.ActivityControllerGetLogsRequest,)
 - setActivityRequestsListData(client: QueryClient,
  queryKeyBase: [
    parameters: {
      page?: number | undefined;
      limit?: number | undefined;
      statusCodes?: Array<number> | undefined;
      urlPattern?: string | undefined;
      transactionId?: string | undefined;
      createdGte?: number | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: ActivityRequestsListQueryData,)
 - invalidateActivityRequestsList(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      page?: number | undefined;
      limit?: number | undefined;
      statusCodes?: Array<number> | undefined;
      urlPattern?: string | undefined;
      transactionId?: string | undefined;
      createdGte?: number | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllActivityRequestsList(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildActivityRequestsListQuery(client$: NovuCore,
  request: operations.ActivityControllerGetLogsRequest,
  options?: RequestOptions,)
 - activityRequestsListQueryFn(ctx,)
 - queryKeyActivityRequestsList(parameters: {
    page?: number | undefined;
    limit?: number | undefined;
    statusCodes?: Array<number> | undefined;
    urlPattern?: string | undefined;
    transactionId?: string | undefined;
    createdGte?: number | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyActivityRequestsList(...queryKeyBase);

  return client.setQueryData<ActivityRequestsListQue...)
Declaraciones 'export' encontradas:
- export  type
- export function useActivityRequestsList
- export function useActivityRequestsListSuspense
- export function prefetchActivityRequestsList
- export function setActivityRequestsListData
- export function invalidateActivityRequestsList
- export function invalidateAllActivityRequestsList
- export function buildActivityRequestsListQuery
- export function queryKeyActivityRequestsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/activityRequestsRetrieve.ts
Tamaño: 4524 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { activityRequestsRetrieve } from "../funcs/activityRequestsRetrieve.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type ActivityRequestsRetrieveQueryData =
  components.GetRequestResponseDto;

/**
 * Retrieve activity request
 *
 * @remarks
 * Retrieve detailed traces and information for a specific activity request by ID.
 */
export function useActivityRequestsRetrieve(
  requestId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<ActivityRequestsRetrieveQueryData>,
): UseQueryResult<ActivityRequestsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildActivityRequestsRetrieveQuery(
      client,
      requestId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * Retrieve activity request
 *
 * @remarks
 * Retrieve detailed traces and information for a specific activity request by ID.
 */
export function useActivityRequestsRetrieveSuspense(
  requestId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<ActivityRequestsRetrieveQueryData>,
): UseSuspenseQueryResult<ActivityRequestsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildActivityRequestsRetrieveQuery(
      client,
      requestId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchActivityRequestsRetrieve(
  queryClient: QueryClient,
  client$: NovuCore,
  requestId: string,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildActivityRequestsRetrieveQuery(
      client$,
      requestId,
      idempotencyKey,
    ),
  });
}

export function setActivityRequestsRetrieveData(
  client: QueryClient,
  queryKeyBase: [
    requestId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: ActivityRequestsRetrieveQueryData,
): ActivityRequestsRetrieveQueryData | undefined {
  const key = queryKeyActivityRequestsRetrieve(...queryKeyBase);

  return client.setQueryData<ActivityRequestsRetrieveQueryData>(key, data);
}

export function invalidateActivityRequestsRetrieve(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [requestId: string, parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Requests", "retrieve", ...queryKeyBase],
  });
}

export function invalidateAllActivityRequestsRetrieve(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Requests", "retrieve"],
  });
}

export function buildActivityRequestsRetrieveQuery(
  client$: NovuCore,
  requestId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<ActivityRequestsRetrieveQueryData>;
} {
  return {
    queryKey: queryKeyActivityRequestsRetrieve(requestId, { idempotencyKey }),
    queryFn: async function activityRequestsRetrieveQueryFn(
      ctx,
    ): Promise<ActivityRequestsRetrieveQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(activityRequestsRetrieve(
        client$,
        requestId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyActivityRequestsRetrieve(
  requestId: string,
  parameters: { idempotencyKey?: string | undefined },
): QueryKey {
  return ["@novu/api", "Requests", "retrieve", requestId, parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useActivityRequestsRetrieve(requestId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<ActivityRequestsRetrieveQueryData>,)
 - useActivityRequestsRetrieveSuspense(requestId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<ActivityRequestsRetrieveQueryData>,)
 - prefetchActivityRequestsRetrieve(queryClient: QueryClient,
  client$: NovuCore,
  requestId: string,
  idempotencyKey?: string | undefined,)
 - setActivityRequestsRetrieveData(client: QueryClient,
  queryKeyBase: [
    requestId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: ActivityRequestsRetrieveQueryData,)
 - invalidateActivityRequestsRetrieve(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [requestId: string, parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllActivityRequestsRetrieve(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildActivityRequestsRetrieveQuery(client$: NovuCore,
  requestId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - activityRequestsRetrieveQueryFn(ctx,)
 - queryKeyActivityRequestsRetrieve(requestId: string,
  parameters: { idempotencyKey?: string | undefined },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyActivityRequestsRetrieve(...queryKeyBase);

  return client.setQueryData<ActivityRequestsRet...)
Declaraciones 'export' encontradas:
- export  type
- export function useActivityRequestsRetrieve
- export function useActivityRequestsRetrieveSuspense
- export function prefetchActivityRequestsRetrieve
- export function setActivityRequestsRetrieveData
- export function invalidateActivityRequestsRetrieve
- export function invalidateAllActivityRequestsRetrieve
- export function buildActivityRequestsRetrieveQuery
- export function queryKeyActivityRequestsRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/activityTrack.ts
Tamaño: 2369 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { activityTrack } from "../funcs/activityTrack.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type ActivityTrackMutationVariables = {
  request: operations.InboundWebhooksControllerHandleWebhookRequest;
  options?: RequestOptions;
};

export type ActivityTrackMutationData = Array<components.WebhookResultDto>;

/**
 * Track activity and engagement events
 *
 * @remarks
 * Track activity and engagement events for a specific delivery provider
 */
export function useActivityTrackMutation(
  options?: MutationHookOptions<
    ActivityTrackMutationData,
    Error,
    ActivityTrackMutationVariables
  >,
): UseMutationResult<
  ActivityTrackMutationData,
  Error,
  ActivityTrackMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildActivityTrackMutation(client, options),
    ...options,
  });
}

export function mutationKeyActivityTrack(): MutationKey {
  return ["@novu/api", "Activity", "track"];
}

export function buildActivityTrackMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: ActivityTrackMutationVariables,
  ) => Promise<ActivityTrackMutationData>;
} {
  return {
    mutationKey: mutationKeyActivityTrack(),
    mutationFn: function activityTrackMutationFn({
      request,
      options,
    }): Promise<ActivityTrackMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(activityTrack(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useActivityTrackMutation(options?: MutationHookOptions<
    ActivityTrackMutationData,
    Error,
    ActivityTrackMutationVariables
  >,)
 - mutationKeyActivityTrack()
 - buildActivityTrackMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - activityTrackMutationFn({
      request,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildActivityTrackMutation(client, options),
    ......)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useActivityTrackMutation
- export function mutationKeyActivityTrack
- export function buildActivityTrackMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/activityWorkflowRunsList.ts
Tamaño: 6507 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { activityWorkflowRunsList } from "../funcs/activityWorkflowRunsList.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type ActivityWorkflowRunsListQueryData =
  components.GetWorkflowRunsResponseDto;

/**
 * List workflow runs
 *
 * @remarks
 * Retrieve a list of workflow runs with optional filtering and pagination.
 */
export function useActivityWorkflowRunsList(
  request: operations.ActivityControllerGetWorkflowRunsRequest,
  options?: QueryHookOptions<ActivityWorkflowRunsListQueryData>,
): UseQueryResult<ActivityWorkflowRunsListQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildActivityWorkflowRunsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

/**
 * List workflow runs
 *
 * @remarks
 * Retrieve a list of workflow runs with optional filtering and pagination.
 */
export function useActivityWorkflowRunsListSuspense(
  request: operations.ActivityControllerGetWorkflowRunsRequest,
  options?: SuspenseQueryHookOptions<ActivityWorkflowRunsListQueryData>,
): UseSuspenseQueryResult<ActivityWorkflowRunsListQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildActivityWorkflowRunsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

export function prefetchActivityWorkflowRunsList(
  queryClient: QueryClient,
  client$: NovuCore,
  request: operations.ActivityControllerGetWorkflowRunsRequest,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildActivityWorkflowRunsListQuery(
      client$,
      request,
    ),
  });
}

export function setActivityWorkflowRunsListData(
  client: QueryClient,
  queryKeyBase: [
    parameters: {
      limit: number | undefined;
      cursor?: string | undefined;
      workflowIds?: Array<string> | undefined;
      subscriberIds?: Array<string> | undefined;
      transactionIds?: Array<string> | undefined;
      statuses?: Array<operations.QueryParamStatuses> | undefined;
      channels?: Array<string> | undefined;
      topicKey?: string | undefined;
      createdGte?: string | undefined;
      createdLte?: string | undefined;
      severity?: Array<operations.Severity> | undefined;
      contextKeys?: Array<string> | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: ActivityWorkflowRunsListQueryData,
): ActivityWorkflowRunsListQueryData | undefined {
  const key = queryKeyActivityWorkflowRunsList(...queryKeyBase);

  return client.setQueryData<ActivityWorkflowRunsListQueryData>(key, data);
}

export function invalidateActivityWorkflowRunsList(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      limit: number | undefined;
      cursor?: string | undefined;
      workflowIds?: Array<string> | undefined;
      subscriberIds?: Array<string> | undefined;
      transactionIds?: Array<string> | undefined;
      statuses?: Array<operations.QueryParamStatuses> | undefined;
      channels?: Array<string> | undefined;
      topicKey?: string | undefined;
      createdGte?: string | undefined;
      createdLte?: string | undefined;
      severity?: Array<operations.Severity> | undefined;
      contextKeys?: Array<string> | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "WorkflowRuns", "list", ...queryKeyBase],
  });
}

export function invalidateAllActivityWorkflowRunsList(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "WorkflowRuns", "list"],
  });
}

export function buildActivityWorkflowRunsListQuery(
  client$: NovuCore,
  request: operations.ActivityControllerGetWorkflowRunsRequest,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<ActivityWorkflowRunsListQueryData>;
} {
  return {
    queryKey: queryKeyActivityWorkflowRunsList({
      limit: request.limit,
      cursor: request.cursor,
      workflowIds: request.workflowIds,
      subscriberIds: request.subscriberIds,
      transactionIds: request.transactionIds,
      statuses: request.statuses,
      channels: request.channels,
      topicKey: request.topicKey,
      createdGte: request.createdGte,
      createdLte: request.createdLte,
      severity: request.severity,
      contextKeys: request.contextKeys,
      idempotencyKey: request.idempotencyKey,
    }),
    queryFn: async function activityWorkflowRunsListQueryFn(
      ctx,
    ): Promise<ActivityWorkflowRunsListQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(activityWorkflowRunsList(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyActivityWorkflowRunsList(
  parameters: {
    limit: number | undefined;
    cursor?: string | undefined;
    workflowIds?: Array<string> | undefined;
    subscriberIds?: Array<string> | undefined;
    transactionIds?: Array<string> | undefined;
    statuses?: Array<operations.QueryParamStatuses> | undefined;
    channels?: Array<string> | undefined;
    topicKey?: string | undefined;
    createdGte?: string | undefined;
    createdLte?: string | undefined;
    severity?: Array<operations.Severity> | undefined;
    contextKeys?: Array<string> | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return ["@novu/api", "WorkflowRuns", "list", parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useActivityWorkflowRunsList(request: operations.ActivityControllerGetWorkflowRunsRequest,
  options?: QueryHookOptions<ActivityWorkflowRunsListQueryData>,)
 - useActivityWorkflowRunsListSuspense(request: operations.ActivityControllerGetWorkflowRunsRequest,
  options?: SuspenseQueryHookOptions<ActivityWorkflowRunsListQueryData>,)
 - prefetchActivityWorkflowRunsList(queryClient: QueryClient,
  client$: NovuCore,
  request: operations.ActivityControllerGetWorkflowRunsRequest,)
 - setActivityWorkflowRunsListData(client: QueryClient,
  queryKeyBase: [
    parameters: {
      limit: number | undefined;
      cursor?: string | undefined;
      workflowIds?: Array<string> | undefined;
      subscriberIds?: Array<string> | undefined;
      transactionIds?: Array<string> | undefined;
      statuses?: Array<operations.QueryParamStatuses> | undefined;
      channels?: Array<string> | undefined;
      topicKey?: string | undefined;
      createdGte?: string | undefined;
      createdLte?: string | undefined;
      severity?: Array<operations.Severity> | undefined;
      contextKeys?: Array<string> | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: ActivityWorkflowRunsListQueryData,)
 - invalidateActivityWorkflowRunsList(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      limit: number | undefined;
      cursor?: string | undefined;
      workflowIds?: Array<string> | undefined;
      subscriberIds?: Array<string> | undefined;
      transactionIds?: Array<string> | undefined;
      statuses?: Array<operations.QueryParamStatuses> | undefined;
      channels?: Array<string> | undefined;
      topicKey?: string | undefined;
      createdGte?: string | undefined;
      createdLte?: string | undefined;
      severity?: Array<operations.Severity> | undefined;
      contextKeys?: Array<string> | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllActivityWorkflowRunsList(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildActivityWorkflowRunsListQuery(client$: NovuCore,
  request: operations.ActivityControllerGetWorkflowRunsRequest,
  options?: RequestOptions,)
 - activityWorkflowRunsListQueryFn(ctx,)
 - queryKeyActivityWorkflowRunsList(parameters: {
    limit: number | undefined;
    cursor?: string | undefined;
    workflowIds?: Array<string> | undefined;
    subscriberIds?: Array<string> | undefined;
    transactionIds?: Array<string> | undefined;
    statuses?: Array<operations.QueryParamStatuses> | undefined;
    channels?: Array<string> | undefined;
    topicKey?: string | undefined;
    createdGte?: string | undefined;
    createdLte?: string | undefined;
    severity?: Array<operations.Severity> | undefined;
    contextKeys?: Array<string> | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyActivityWorkflowRunsList(...queryKeyBase);

  return client.setQueryData<ActivityWorkflowRun...)
Declaraciones 'export' encontradas:
- export  type
- export function useActivityWorkflowRunsList
- export function useActivityWorkflowRunsListSuspense
- export function prefetchActivityWorkflowRunsList
- export function setActivityWorkflowRunsListData
- export function invalidateActivityWorkflowRunsList
- export function invalidateAllActivityWorkflowRunsList
- export function buildActivityWorkflowRunsListQuery
- export function queryKeyActivityWorkflowRunsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/activityWorkflowRunsRetrieve.ts
Tamaño: 4673 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { activityWorkflowRunsRetrieve } from "../funcs/activityWorkflowRunsRetrieve.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type ActivityWorkflowRunsRetrieveQueryData =
  components.GetWorkflowRunResponseDto;

/**
 * Retrieve workflow run
 *
 * @remarks
 * Retrieve detailed information for a specific workflow run by ID.
 */
export function useActivityWorkflowRunsRetrieve(
  workflowRunId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<ActivityWorkflowRunsRetrieveQueryData>,
): UseQueryResult<ActivityWorkflowRunsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildActivityWorkflowRunsRetrieveQuery(
      client,
      workflowRunId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * Retrieve workflow run
 *
 * @remarks
 * Retrieve detailed information for a specific workflow run by ID.
 */
export function useActivityWorkflowRunsRetrieveSuspense(
  workflowRunId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<ActivityWorkflowRunsRetrieveQueryData>,
): UseSuspenseQueryResult<ActivityWorkflowRunsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildActivityWorkflowRunsRetrieveQuery(
      client,
      workflowRunId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchActivityWorkflowRunsRetrieve(
  queryClient: QueryClient,
  client$: NovuCore,
  workflowRunId: string,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildActivityWorkflowRunsRetrieveQuery(
      client$,
      workflowRunId,
      idempotencyKey,
    ),
  });
}

export function setActivityWorkflowRunsRetrieveData(
  client: QueryClient,
  queryKeyBase: [
    workflowRunId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: ActivityWorkflowRunsRetrieveQueryData,
): ActivityWorkflowRunsRetrieveQueryData | undefined {
  const key = queryKeyActivityWorkflowRunsRetrieve(...queryKeyBase);

  return client.setQueryData<ActivityWorkflowRunsRetrieveQueryData>(key, data);
}

export function invalidateActivityWorkflowRunsRetrieve(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [workflowRunId: string, parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "WorkflowRuns", "retrieve", ...queryKeyBase],
  });
}

export function invalidateAllActivityWorkflowRunsRetrieve(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "WorkflowRuns", "retrieve"],
  });
}

export function buildActivityWorkflowRunsRetrieveQuery(
  client$: NovuCore,
  workflowRunId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<ActivityWorkflowRunsRetrieveQueryData>;
} {
  return {
    queryKey: queryKeyActivityWorkflowRunsRetrieve(workflowRunId, {
      idempotencyKey,
    }),
    queryFn: async function activityWorkflowRunsRetrieveQueryFn(
      ctx,
    ): Promise<ActivityWorkflowRunsRetrieveQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(activityWorkflowRunsRetrieve(
        client$,
        workflowRunId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyActivityWorkflowRunsRetrieve(
  workflowRunId: string,
  parameters: { idempotencyKey?: string | undefined },
): QueryKey {
  return ["@novu/api", "WorkflowRuns", "retrieve", workflowRunId, parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useActivityWorkflowRunsRetrieve(workflowRunId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<ActivityWorkflowRunsRetrieveQueryData>,)
 - useActivityWorkflowRunsRetrieveSuspense(workflowRunId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<ActivityWorkflowRunsRetrieveQueryData>,)
 - prefetchActivityWorkflowRunsRetrieve(queryClient: QueryClient,
  client$: NovuCore,
  workflowRunId: string,
  idempotencyKey?: string | undefined,)
 - setActivityWorkflowRunsRetrieveData(client: QueryClient,
  queryKeyBase: [
    workflowRunId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: ActivityWorkflowRunsRetrieveQueryData,)
 - invalidateActivityWorkflowRunsRetrieve(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [workflowRunId: string, parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllActivityWorkflowRunsRetrieve(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildActivityWorkflowRunsRetrieveQuery(client$: NovuCore,
  workflowRunId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - activityWorkflowRunsRetrieveQueryFn(ctx,)
 - queryKeyActivityWorkflowRunsRetrieve(workflowRunId: string,
  parameters: { idempotencyKey?: string | undefined },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyActivityWorkflowRunsRetrieve(...queryKeyBase);

  return client.setQueryData<ActivityWorkflo...)
Declaraciones 'export' encontradas:
- export  type
- export function useActivityWorkflowRunsRetrieve
- export function useActivityWorkflowRunsRetrieveSuspense
- export function prefetchActivityWorkflowRunsRetrieve
- export function setActivityWorkflowRunsRetrieveData
- export function invalidateActivityWorkflowRunsRetrieve
- export function invalidateAllActivityWorkflowRunsRetrieve
- export function buildActivityWorkflowRunsRetrieveQuery
- export function queryKeyActivityWorkflowRunsRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/cancel.ts
Tamaño: 2323 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { cancel } from "../funcs/cancel.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type CancelMutationVariables = {
  transactionId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type CancelMutationData = operations.EventsControllerCancelResponse;

/**
 * Cancel triggered event
 *
 * @remarks
 *
 *     Using a previously generated transactionId during the event trigger,
 *      will cancel any active or pending workflows. This is useful to cancel active digests, delays etc...
 */
export function useCancelMutation(
  options?: MutationHookOptions<
    CancelMutationData,
    Error,
    CancelMutationVariables
  >,
): UseMutationResult<CancelMutationData, Error, CancelMutationVariables> {
  const client = useNovuContext();
  return useMutation({
    ...buildCancelMutation(client, options),
    ...options,
  });
}

export function mutationKeyCancel(): MutationKey {
  return ["@novu/api", "cancel"];
}

export function buildCancelMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: CancelMutationVariables,
  ) => Promise<CancelMutationData>;
} {
  return {
    mutationKey: mutationKeyCancel(),
    mutationFn: function cancelMutationFn({
      transactionId,
      idempotencyKey,
      options,
    }): Promise<CancelMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(cancel(
        client$,
        transactionId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useCancelMutation(options?: MutationHookOptions<
    CancelMutationData,
    Error,
    CancelMutationVariables
  >,)
 - mutationKeyCancel()
 - buildCancelMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - cancelMutationFn({
      transactionId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildCancelMutation(client, options),
    ...options...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useCancelMutation
- export function mutationKeyCancel
- export function buildCancelMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/contextsCreate.ts
Tamaño: 2524 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { contextsCreate } from "../funcs/contextsCreate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type ContextsCreateMutationVariables = {
  createContextRequestDto: components.CreateContextRequestDto;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type ContextsCreateMutationData =
  operations.ContextsControllerCreateContextResponse;

/**
 * Create context
 *
 * @remarks
 * Create a new context with the specified type, id, and data. Returns 409 if context already exists.
 */
export function useContextsCreateMutation(
  options?: MutationHookOptions<
    ContextsCreateMutationData,
    Error,
    ContextsCreateMutationVariables
  >,
): UseMutationResult<
  ContextsCreateMutationData,
  Error,
  ContextsCreateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildContextsCreateMutation(client, options),
    ...options,
  });
}

export function mutationKeyContextsCreate(): MutationKey {
  return ["@novu/api", "Contexts", "create"];
}

export function buildContextsCreateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: ContextsCreateMutationVariables,
  ) => Promise<ContextsCreateMutationData>;
} {
  return {
    mutationKey: mutationKeyContextsCreate(),
    mutationFn: function contextsCreateMutationFn({
      createContextRequestDto,
      idempotencyKey,
      options,
    }): Promise<ContextsCreateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(contextsCreate(
        client$,
        createContextRequestDto,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useContextsCreateMutation(options?: MutationHookOptions<
    ContextsCreateMutationData,
    Error,
    ContextsCreateMutationVariables
  >,)
 - mutationKeyContextsCreate()
 - buildContextsCreateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - contextsCreateMutationFn({
      createContextRequestDto,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildContextsCreateMutation(client, options),
    .....)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useContextsCreateMutation
- export function mutationKeyContextsCreate
- export function buildContextsCreateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/contextsDelete.ts
Tamaño: 2367 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { contextsDelete } from "../funcs/contextsDelete.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type ContextsDeleteMutationVariables = {
  type: string;
  id: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type ContextsDeleteMutationData =
  | operations.ContextsControllerDeleteContextResponse
  | undefined;

/**
 * Delete context
 *
 * @remarks
 * Delete a context by its type and id
 */
export function useContextsDeleteMutation(
  options?: MutationHookOptions<
    ContextsDeleteMutationData,
    Error,
    ContextsDeleteMutationVariables
  >,
): UseMutationResult<
  ContextsDeleteMutationData,
  Error,
  ContextsDeleteMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildContextsDeleteMutation(client, options),
    ...options,
  });
}

export function mutationKeyContextsDelete(): MutationKey {
  return ["@novu/api", "Contexts", "delete"];
}

export function buildContextsDeleteMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: ContextsDeleteMutationVariables,
  ) => Promise<ContextsDeleteMutationData>;
} {
  return {
    mutationKey: mutationKeyContextsDelete(),
    mutationFn: function contextsDeleteMutationFn({
      type,
      id,
      idempotencyKey,
      options,
    }): Promise<ContextsDeleteMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(contextsDelete(
        client$,
        type,
        id,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useContextsDeleteMutation(options?: MutationHookOptions<
    ContextsDeleteMutationData,
    Error,
    ContextsDeleteMutationVariables
  >,)
 - mutationKeyContextsDelete()
 - buildContextsDeleteMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - contextsDeleteMutationFn({
      type,
      id,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildContextsDeleteMutation(client, options),
    .....)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useContextsDeleteMutation
- export function mutationKeyContextsDelete
- export function buildContextsDeleteMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/contextsList.ts
Tamaño: 5360 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { contextsList } from "../funcs/contextsList.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type ContextsListQueryData =
  operations.ContextsControllerListContextsResponse;

/**
 * List contexts
 *
 * @remarks
 * Retrieve a paginated list of contexts, optionally filtered by type and key pattern
 */
export function useContextsList(
  request: operations.ContextsControllerListContextsRequest,
  options?: QueryHookOptions<ContextsListQueryData>,
): UseQueryResult<ContextsListQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildContextsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

/**
 * List contexts
 *
 * @remarks
 * Retrieve a paginated list of contexts, optionally filtered by type and key pattern
 */
export function useContextsListSuspense(
  request: operations.ContextsControllerListContextsRequest,
  options?: SuspenseQueryHookOptions<ContextsListQueryData>,
): UseSuspenseQueryResult<ContextsListQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildContextsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

export function prefetchContextsList(
  queryClient: QueryClient,
  client$: NovuCore,
  request: operations.ContextsControllerListContextsRequest,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildContextsListQuery(
      client$,
      request,
    ),
  });
}

export function setContextsListData(
  client: QueryClient,
  queryKeyBase: [
    parameters: {
      after?: string | undefined;
      before?: string | undefined;
      limit?: number | undefined;
      orderDirection?: operations.OrderDirection | undefined;
      orderBy?: string | undefined;
      includeCursor?: boolean | undefined;
      type?: string | undefined;
      id?: string | undefined;
      search?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: ContextsListQueryData,
): ContextsListQueryData | undefined {
  const key = queryKeyContextsList(...queryKeyBase);

  return client.setQueryData<ContextsListQueryData>(key, data);
}

export function invalidateContextsList(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      after?: string | undefined;
      before?: string | undefined;
      limit?: number | undefined;
      orderDirection?: operations.OrderDirection | undefined;
      orderBy?: string | undefined;
      includeCursor?: boolean | undefined;
      type?: string | undefined;
      id?: string | undefined;
      search?: string | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Contexts", "list", ...queryKeyBase],
  });
}

export function invalidateAllContextsList(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Contexts", "list"],
  });
}

export function buildContextsListQuery(
  client$: NovuCore,
  request: operations.ContextsControllerListContextsRequest,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (context: QueryFunctionContext) => Promise<ContextsListQueryData>;
} {
  return {
    queryKey: queryKeyContextsList({
      after: request.after,
      before: request.before,
      limit: request.limit,
      orderDirection: request.orderDirection,
      orderBy: request.orderBy,
      includeCursor: request.includeCursor,
      type: request.type,
      id: request.id,
      search: request.search,
      idempotencyKey: request.idempotencyKey,
    }),
    queryFn: async function contextsListQueryFn(
      ctx,
    ): Promise<ContextsListQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(contextsList(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyContextsList(
  parameters: {
    after?: string | undefined;
    before?: string | undefined;
    limit?: number | undefined;
    orderDirection?: operations.OrderDirection | undefined;
    orderBy?: string | undefined;
    includeCursor?: boolean | undefined;
    type?: string | undefined;
    id?: string | undefined;
    search?: string | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return ["@novu/api", "Contexts", "list", parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useContextsList(request: operations.ContextsControllerListContextsRequest,
  options?: QueryHookOptions<ContextsListQueryData>,)
 - useContextsListSuspense(request: operations.ContextsControllerListContextsRequest,
  options?: SuspenseQueryHookOptions<ContextsListQueryData>,)
 - prefetchContextsList(queryClient: QueryClient,
  client$: NovuCore,
  request: operations.ContextsControllerListContextsRequest,)
 - setContextsListData(client: QueryClient,
  queryKeyBase: [
    parameters: {
      after?: string | undefined;
      before?: string | undefined;
      limit?: number | undefined;
      orderDirection?: operations.OrderDirection | undefined;
      orderBy?: string | undefined;
      includeCursor?: boolean | undefined;
      type?: string | undefined;
      id?: string | undefined;
      search?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: ContextsListQueryData,)
 - invalidateContextsList(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      after?: string | undefined;
      before?: string | undefined;
      limit?: number | undefined;
      orderDirection?: operations.OrderDirection | undefined;
      orderBy?: string | undefined;
      includeCursor?: boolean | undefined;
      type?: string | undefined;
      id?: string | undefined;
      search?: string | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllContextsList(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildContextsListQuery(client$: NovuCore,
  request: operations.ContextsControllerListContextsRequest,
  options?: RequestOptions,)
 - contextsListQueryFn(ctx,)
 - queryKeyContextsList(parameters: {
    after?: string | undefined;
    before?: string | undefined;
    limit?: number | undefined;
    orderDirection?: operations.OrderDirection | undefined;
    orderBy?: string | undefined;
    includeCursor?: boolean | undefined;
    type?: string | undefined;
    id?: string | undefined;
    search?: string | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyContextsList(...queryKeyBase);

  return client.setQueryData<ContextsListQueryData>(key, dat...)
Declaraciones 'export' encontradas:
- export  type
- export function useContextsList
- export function useContextsListSuspense
- export function prefetchContextsList
- export function setContextsListData
- export function invalidateContextsList
- export function invalidateAllContextsList
- export function buildContextsListQuery
- export function queryKeyContextsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/contextsRetrieve.ts
Tamaño: 4349 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { contextsRetrieve } from "../funcs/contextsRetrieve.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type ContextsRetrieveQueryData =
  operations.ContextsControllerGetContextResponse;

/**
 * Get context by id
 *
 * @remarks
 * Retrieve a specific context by its type and id
 */
export function useContextsRetrieve(
  type: string,
  id: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<ContextsRetrieveQueryData>,
): UseQueryResult<ContextsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildContextsRetrieveQuery(
      client,
      type,
      id,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * Get context by id
 *
 * @remarks
 * Retrieve a specific context by its type and id
 */
export function useContextsRetrieveSuspense(
  type: string,
  id: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<ContextsRetrieveQueryData>,
): UseSuspenseQueryResult<ContextsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildContextsRetrieveQuery(
      client,
      type,
      id,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchContextsRetrieve(
  queryClient: QueryClient,
  client$: NovuCore,
  type: string,
  id: string,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildContextsRetrieveQuery(
      client$,
      type,
      id,
      idempotencyKey,
    ),
  });
}

export function setContextsRetrieveData(
  client: QueryClient,
  queryKeyBase: [
    type: string,
    id: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: ContextsRetrieveQueryData,
): ContextsRetrieveQueryData | undefined {
  const key = queryKeyContextsRetrieve(...queryKeyBase);

  return client.setQueryData<ContextsRetrieveQueryData>(key, data);
}

export function invalidateContextsRetrieve(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      type: string,
      id: string,
      parameters: { idempotencyKey?: string | undefined },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Contexts", "retrieve", ...queryKeyBase],
  });
}

export function invalidateAllContextsRetrieve(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Contexts", "retrieve"],
  });
}

export function buildContextsRetrieveQuery(
  client$: NovuCore,
  type: string,
  id: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<ContextsRetrieveQueryData>;
} {
  return {
    queryKey: queryKeyContextsRetrieve(type, id, { idempotencyKey }),
    queryFn: async function contextsRetrieveQueryFn(
      ctx,
    ): Promise<ContextsRetrieveQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(contextsRetrieve(
        client$,
        type,
        id,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyContextsRetrieve(
  type: string,
  id: string,
  parameters: { idempotencyKey?: string | undefined },
): QueryKey {
  return ["@novu/api", "Contexts", "retrieve", type, id, parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useContextsRetrieve(type: string,
  id: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<ContextsRetrieveQueryData>,)
 - useContextsRetrieveSuspense(type: string,
  id: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<ContextsRetrieveQueryData>,)
 - prefetchContextsRetrieve(queryClient: QueryClient,
  client$: NovuCore,
  type: string,
  id: string,
  idempotencyKey?: string | undefined,)
 - setContextsRetrieveData(client: QueryClient,
  queryKeyBase: [
    type: string,
    id: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: ContextsRetrieveQueryData,)
 - invalidateContextsRetrieve(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      type: string,
      id: string,
      parameters: { idempotencyKey?: string | undefined },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllContextsRetrieve(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildContextsRetrieveQuery(client$: NovuCore,
  type: string,
  id: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - contextsRetrieveQueryFn(ctx,)
 - queryKeyContextsRetrieve(type: string,
  id: string,
  parameters: { idempotencyKey?: string | undefined },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyContextsRetrieve(...queryKeyBase);

  return client.setQueryData<ContextsRetrieveQueryData>(...)
Declaraciones 'export' encontradas:
- export  type
- export function useContextsRetrieve
- export function useContextsRetrieveSuspense
- export function prefetchContextsRetrieve
- export function setContextsRetrieveData
- export function invalidateContextsRetrieve
- export function invalidateAllContextsRetrieve
- export function buildContextsRetrieveQuery
- export function queryKeyContextsRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/contextsUpdate.ts
Tamaño: 2330 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { contextsUpdate } from "../funcs/contextsUpdate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type ContextsUpdateMutationVariables = {
  request: operations.ContextsControllerUpdateContextRequest;
  options?: RequestOptions;
};

export type ContextsUpdateMutationData =
  operations.ContextsControllerUpdateContextResponse;

/**
 * Update context data
 *
 * @remarks
 * Update the data of an existing context. Returns 404 if context does not exist.
 */
export function useContextsUpdateMutation(
  options?: MutationHookOptions<
    ContextsUpdateMutationData,
    Error,
    ContextsUpdateMutationVariables
  >,
): UseMutationResult<
  ContextsUpdateMutationData,
  Error,
  ContextsUpdateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildContextsUpdateMutation(client, options),
    ...options,
  });
}

export function mutationKeyContextsUpdate(): MutationKey {
  return ["@novu/api", "Contexts", "update"];
}

export function buildContextsUpdateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: ContextsUpdateMutationVariables,
  ) => Promise<ContextsUpdateMutationData>;
} {
  return {
    mutationKey: mutationKeyContextsUpdate(),
    mutationFn: function contextsUpdateMutationFn({
      request,
      options,
    }): Promise<ContextsUpdateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(contextsUpdate(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useContextsUpdateMutation(options?: MutationHookOptions<
    ContextsUpdateMutationData,
    Error,
    ContextsUpdateMutationVariables
  >,)
 - mutationKeyContextsUpdate()
 - buildContextsUpdateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - contextsUpdateMutationFn({
      request,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildContextsUpdateMutation(client, options),
    .....)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useContextsUpdateMutation
- export function mutationKeyContextsUpdate
- export function buildContextsUpdateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/environmentsCreate.ts
Tamaño: 2765 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { environmentsCreate } from "../funcs/environmentsCreate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type EnvironmentsCreateMutationVariables = {
  createEnvironmentRequestDto: components.CreateEnvironmentRequestDto;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type EnvironmentsCreateMutationData =
  operations.EnvironmentsControllerV1CreateEnvironmentResponse;

/**
 * Create an environment
 *
 * @remarks
 * Creates a new environment within the current organization.
 *     Environments allow you to manage different stages of your application development lifecycle.
 *     Each environment has its own set of API keys and configurations.
 */
export function useEnvironmentsCreateMutation(
  options?: MutationHookOptions<
    EnvironmentsCreateMutationData,
    Error,
    EnvironmentsCreateMutationVariables
  >,
): UseMutationResult<
  EnvironmentsCreateMutationData,
  Error,
  EnvironmentsCreateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildEnvironmentsCreateMutation(client, options),
    ...options,
  });
}

export function mutationKeyEnvironmentsCreate(): MutationKey {
  return ["@novu/api", "Environments", "create"];
}

export function buildEnvironmentsCreateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: EnvironmentsCreateMutationVariables,
  ) => Promise<EnvironmentsCreateMutationData>;
} {
  return {
    mutationKey: mutationKeyEnvironmentsCreate(),
    mutationFn: function environmentsCreateMutationFn({
      createEnvironmentRequestDto,
      idempotencyKey,
      options,
    }): Promise<EnvironmentsCreateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(environmentsCreate(
        client$,
        createEnvironmentRequestDto,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useEnvironmentsCreateMutation(options?: MutationHookOptions<
    EnvironmentsCreateMutationData,
    Error,
    EnvironmentsCreateMutationVariables
  >,)
 - mutationKeyEnvironmentsCreate()
 - buildEnvironmentsCreateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - environmentsCreateMutationFn({
      createEnvironmentRequestDto,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildEnvironmentsCreateMutation(client, options),
  ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useEnvironmentsCreateMutation
- export function mutationKeyEnvironmentsCreate
- export function buildEnvironmentsCreateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/environmentsDelete.ts
Tamaño: 2577 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { environmentsDelete } from "../funcs/environmentsDelete.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type EnvironmentsDeleteMutationVariables = {
  environmentId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type EnvironmentsDeleteMutationData =
  | operations.EnvironmentsControllerV1DeleteEnvironmentResponse
  | undefined;

/**
 * Delete an environment
 *
 * @remarks
 * Delete an environment by its unique identifier **environmentId**.
 *     This action is irreversible and will remove the environment and all its associated data.
 */
export function useEnvironmentsDeleteMutation(
  options?: MutationHookOptions<
    EnvironmentsDeleteMutationData,
    Error,
    EnvironmentsDeleteMutationVariables
  >,
): UseMutationResult<
  EnvironmentsDeleteMutationData,
  Error,
  EnvironmentsDeleteMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildEnvironmentsDeleteMutation(client, options),
    ...options,
  });
}

export function mutationKeyEnvironmentsDelete(): MutationKey {
  return ["@novu/api", "Environments", "delete"];
}

export function buildEnvironmentsDeleteMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: EnvironmentsDeleteMutationVariables,
  ) => Promise<EnvironmentsDeleteMutationData>;
} {
  return {
    mutationKey: mutationKeyEnvironmentsDelete(),
    mutationFn: function environmentsDeleteMutationFn({
      environmentId,
      idempotencyKey,
      options,
    }): Promise<EnvironmentsDeleteMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(environmentsDelete(
        client$,
        environmentId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useEnvironmentsDeleteMutation(options?: MutationHookOptions<
    EnvironmentsDeleteMutationData,
    Error,
    EnvironmentsDeleteMutationVariables
  >,)
 - mutationKeyEnvironmentsDelete()
 - buildEnvironmentsDeleteMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - environmentsDeleteMutationFn({
      environmentId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildEnvironmentsDeleteMutation(client, options),
  ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useEnvironmentsDeleteMutation
- export function mutationKeyEnvironmentsDelete
- export function buildEnvironmentsDeleteMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/environmentsGetTags.ts
Tamaño: 4557 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { environmentsGetTags } from "../funcs/environmentsGetTags.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type EnvironmentsGetTagsQueryData =
  operations.EnvironmentsControllerGetEnvironmentTagsResponse;

/**
 * Get environment tags
 *
 * @remarks
 * Retrieve all unique tags used in workflows within the specified environment. These tags can be used for filtering workflows.
 */
export function useEnvironmentsGetTags(
  environmentId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<EnvironmentsGetTagsQueryData>,
): UseQueryResult<EnvironmentsGetTagsQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildEnvironmentsGetTagsQuery(
      client,
      environmentId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * Get environment tags
 *
 * @remarks
 * Retrieve all unique tags used in workflows within the specified environment. These tags can be used for filtering workflows.
 */
export function useEnvironmentsGetTagsSuspense(
  environmentId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<EnvironmentsGetTagsQueryData>,
): UseSuspenseQueryResult<EnvironmentsGetTagsQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildEnvironmentsGetTagsQuery(
      client,
      environmentId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchEnvironmentsGetTags(
  queryClient: QueryClient,
  client$: NovuCore,
  environmentId: string,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildEnvironmentsGetTagsQuery(
      client$,
      environmentId,
      idempotencyKey,
    ),
  });
}

export function setEnvironmentsGetTagsData(
  client: QueryClient,
  queryKeyBase: [
    environmentId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: EnvironmentsGetTagsQueryData,
): EnvironmentsGetTagsQueryData | undefined {
  const key = queryKeyEnvironmentsGetTags(...queryKeyBase);

  return client.setQueryData<EnvironmentsGetTagsQueryData>(key, data);
}

export function invalidateEnvironmentsGetTags(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [environmentId: string, parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Environments", "getTags", ...queryKeyBase],
  });
}

export function invalidateAllEnvironmentsGetTags(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Environments", "getTags"],
  });
}

export function buildEnvironmentsGetTagsQuery(
  client$: NovuCore,
  environmentId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<EnvironmentsGetTagsQueryData>;
} {
  return {
    queryKey: queryKeyEnvironmentsGetTags(environmentId, { idempotencyKey }),
    queryFn: async function environmentsGetTagsQueryFn(
      ctx,
    ): Promise<EnvironmentsGetTagsQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(environmentsGetTags(
        client$,
        environmentId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyEnvironmentsGetTags(
  environmentId: string,
  parameters: { idempotencyKey?: string | undefined },
): QueryKey {
  return ["@novu/api", "Environments", "getTags", environmentId, parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useEnvironmentsGetTags(environmentId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<EnvironmentsGetTagsQueryData>,)
 - useEnvironmentsGetTagsSuspense(environmentId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<EnvironmentsGetTagsQueryData>,)
 - prefetchEnvironmentsGetTags(queryClient: QueryClient,
  client$: NovuCore,
  environmentId: string,
  idempotencyKey?: string | undefined,)
 - setEnvironmentsGetTagsData(client: QueryClient,
  queryKeyBase: [
    environmentId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: EnvironmentsGetTagsQueryData,)
 - invalidateEnvironmentsGetTags(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [environmentId: string, parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllEnvironmentsGetTags(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildEnvironmentsGetTagsQuery(client$: NovuCore,
  environmentId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - environmentsGetTagsQueryFn(ctx,)
 - queryKeyEnvironmentsGetTags(environmentId: string,
  parameters: { idempotencyKey?: string | undefined },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyEnvironmentsGetTags(...queryKeyBase);

  return client.setQueryData<EnvironmentsGetTagsQuery...)
Declaraciones 'export' encontradas:
- export  type
- export function useEnvironmentsGetTags
- export function useEnvironmentsGetTagsSuspense
- export function prefetchEnvironmentsGetTags
- export function setEnvironmentsGetTagsData
- export function invalidateEnvironmentsGetTags
- export function invalidateAllEnvironmentsGetTags
- export function buildEnvironmentsGetTagsQuery
- export function queryKeyEnvironmentsGetTags

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/environmentsList.ts
Tamaño: 4255 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { environmentsList } from "../funcs/environmentsList.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type EnvironmentsListQueryData =
  operations.EnvironmentsControllerV1ListMyEnvironmentsResponse;

/**
 * List all environments
 *
 * @remarks
 * This API returns a list of environments for the current organization.
 *     Each environment contains its configuration, API keys (if user has access), and metadata.
 */
export function useEnvironmentsList(
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<EnvironmentsListQueryData>,
): UseQueryResult<EnvironmentsListQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildEnvironmentsListQuery(
      client,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * List all environments
 *
 * @remarks
 * This API returns a list of environments for the current organization.
 *     Each environment contains its configuration, API keys (if user has access), and metadata.
 */
export function useEnvironmentsListSuspense(
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<EnvironmentsListQueryData>,
): UseSuspenseQueryResult<EnvironmentsListQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildEnvironmentsListQuery(
      client,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchEnvironmentsList(
  queryClient: QueryClient,
  client$: NovuCore,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildEnvironmentsListQuery(
      client$,
      idempotencyKey,
    ),
  });
}

export function setEnvironmentsListData(
  client: QueryClient,
  queryKeyBase: [parameters: { idempotencyKey?: string | undefined }],
  data: EnvironmentsListQueryData,
): EnvironmentsListQueryData | undefined {
  const key = queryKeyEnvironmentsList(...queryKeyBase);

  return client.setQueryData<EnvironmentsListQueryData>(key, data);
}

export function invalidateEnvironmentsList(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Environments", "list", ...queryKeyBase],
  });
}

export function invalidateAllEnvironmentsList(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Environments", "list"],
  });
}

export function buildEnvironmentsListQuery(
  client$: NovuCore,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<EnvironmentsListQueryData>;
} {
  return {
    queryKey: queryKeyEnvironmentsList({ idempotencyKey }),
    queryFn: async function environmentsListQueryFn(
      ctx,
    ): Promise<EnvironmentsListQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(environmentsList(
        client$,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyEnvironmentsList(
  parameters: { idempotencyKey?: string | undefined },
): QueryKey {
  return ["@novu/api", "Environments", "list", parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useEnvironmentsList(idempotencyKey?: string | undefined,
  options?: QueryHookOptions<EnvironmentsListQueryData>,)
 - useEnvironmentsListSuspense(idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<EnvironmentsListQueryData>,)
 - prefetchEnvironmentsList(queryClient: QueryClient,
  client$: NovuCore,
  idempotencyKey?: string | undefined,)
 - setEnvironmentsListData(client: QueryClient,
  queryKeyBase: [parameters: { idempotencyKey?: string | undefined }],
  data: EnvironmentsListQueryData,)
 - invalidateEnvironmentsList(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllEnvironmentsList(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildEnvironmentsListQuery(client$: NovuCore,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - environmentsListQueryFn(ctx,)
 - queryKeyEnvironmentsList(parameters: { idempotencyKey?: string | undefined },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyEnvironmentsList(...queryKeyBase);

  return client.setQueryData<EnvironmentsListQueryData>(...)
Declaraciones 'export' encontradas:
- export  type
- export function useEnvironmentsList
- export function useEnvironmentsListSuspense
- export function prefetchEnvironmentsList
- export function setEnvironmentsListData
- export function invalidateEnvironmentsList
- export function invalidateAllEnvironmentsList
- export function buildEnvironmentsListQuery
- export function queryKeyEnvironmentsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/environmentsUpdate.ts
Tamaño: 2768 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { environmentsUpdate } from "../funcs/environmentsUpdate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type EnvironmentsUpdateMutationVariables = {
  updateEnvironmentRequestDto: components.UpdateEnvironmentRequestDto;
  environmentId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type EnvironmentsUpdateMutationData =
  operations.EnvironmentsControllerV1UpdateMyEnvironmentResponse;

/**
 * Update an environment
 *
 * @remarks
 * Update an environment by its unique identifier **environmentId**.
 *     You can modify the environment name, identifier, color, and other configuration settings.
 */
export function useEnvironmentsUpdateMutation(
  options?: MutationHookOptions<
    EnvironmentsUpdateMutationData,
    Error,
    EnvironmentsUpdateMutationVariables
  >,
): UseMutationResult<
  EnvironmentsUpdateMutationData,
  Error,
  EnvironmentsUpdateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildEnvironmentsUpdateMutation(client, options),
    ...options,
  });
}

export function mutationKeyEnvironmentsUpdate(): MutationKey {
  return ["@novu/api", "Environments", "update"];
}

export function buildEnvironmentsUpdateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: EnvironmentsUpdateMutationVariables,
  ) => Promise<EnvironmentsUpdateMutationData>;
} {
  return {
    mutationKey: mutationKeyEnvironmentsUpdate(),
    mutationFn: function environmentsUpdateMutationFn({
      updateEnvironmentRequestDto,
      environmentId,
      idempotencyKey,
      options,
    }): Promise<EnvironmentsUpdateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(environmentsUpdate(
        client$,
        updateEnvironmentRequestDto,
        environmentId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useEnvironmentsUpdateMutation(options?: MutationHookOptions<
    EnvironmentsUpdateMutationData,
    Error,
    EnvironmentsUpdateMutationVariables
  >,)
 - mutationKeyEnvironmentsUpdate()
 - buildEnvironmentsUpdateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - environmentsUpdateMutationFn({
      updateEnvironmentRequestDto,
      environmentId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildEnvironmentsUpdateMutation(client, options),
  ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useEnvironmentsUpdateMutation
- export function mutationKeyEnvironmentsUpdate
- export function buildEnvironmentsUpdateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/index.ts
Tamaño: 3886 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

export { NovuProvider, useNovuContext } from "./_context.js";
export * from "./_types.js";

export * from "./activityChartsRetrieve.js";
export * from "./activityRequestsList.js";
export * from "./activityRequestsRetrieve.js";
export * from "./activityTrack.js";
export * from "./activityWorkflowRunsList.js";
export * from "./activityWorkflowRunsRetrieve.js";
export * from "./cancel.js";
export * from "./contextsCreate.js";
export * from "./contextsDelete.js";
export * from "./contextsList.js";
export * from "./contextsRetrieve.js";
export * from "./contextsUpdate.js";
export * from "./environmentsCreate.js";
export * from "./environmentsDelete.js";
export * from "./environmentsGetTags.js";
export * from "./environmentsList.js";
export * from "./environmentsUpdate.js";
export * from "./integrationsCreate.js";
export * from "./integrationsDelete.js";
export * from "./integrationsIntegrationsControllerAutoConfigureIntegration.js";
export * from "./integrationsList.js";
export * from "./integrationsListActive.js";
export * from "./integrationsSetAsPrimary.js";
export * from "./integrationsUpdate.js";
export * from "./layoutsCreate.js";
export * from "./layoutsDelete.js";
export * from "./layoutsDuplicate.js";
export * from "./layoutsGeneratePreview.js";
export * from "./layoutsList.js";
export * from "./layoutsRetrieve.js";
export * from "./layoutsUpdate.js";
export * from "./layoutsUsage.js";
export * from "./messagesDelete.js";
export * from "./messagesDeleteByTransactionId.js";
export * from "./messagesRetrieve.js";
export * from "./notificationsList.js";
export * from "./notificationsRetrieve.js";
export * from "./subscribersCreate.js";
export * from "./subscribersCreateBulk.js";
export * from "./subscribersCredentialsAppend.js";
export * from "./subscribersCredentialsDelete.js";
export * from "./subscribersCredentialsUpdate.js";
export * from "./subscribersDelete.js";
export * from "./subscribersMessagesMarkAll.js";
export * from "./subscribersMessagesMarkAllAs.js";
export * from "./subscribersMessagesUpdateAsSeen.js";
export * from "./subscribersNotificationsFeed.js";
export * from "./subscribersNotificationsUnseenCount.js";
export * from "./subscribersPatch.js";
export * from "./subscribersPreferencesBulkUpdate.js";
export * from "./subscribersPreferencesList.js";
export * from "./subscribersPreferencesUpdate.js";
export * from "./subscribersPropertiesUpdateOnlineFlag.js";
export * from "./subscribersRetrieve.js";
export * from "./subscribersSearch.js";
export * from "./subscribersTopicsList.js";
export * from "./topicsCreate.js";
export * from "./topicsDelete.js";
export * from "./topicsGet.js";
export * from "./topicsList.js";
export * from "./topicsSubscribersRetrieve.js";
export * from "./topicsSubscriptionsCreate.js";
export * from "./topicsSubscriptionsDelete.js";
export * from "./topicsSubscriptionsList.js";
export * from "./topicsUpdate.js";
export * from "./translationsCreate.js";
export * from "./translationsDelete.js";
export * from "./translationsGroupsDelete.js";
export * from "./translationsGroupsRetrieve.js";
export * from "./translationsMasterImport.js";
export * from "./translationsMasterRetrieve.js";
export * from "./translationsMasterUpload.js";
export * from "./translationsRetrieve.js";
export * from "./translationsUpload.js";
export * from "./trigger.js";
export * from "./triggerBroadcast.js";
export * from "./triggerBulk.js";
export * from "./workflowsCreate.js";
export * from "./workflowsDelete.js";
export * from "./workflowsDuplicate.js";
export * from "./workflowsGet.js";
export * from "./workflowsList.js";
export * from "./workflowsPatch.js";
export * from "./workflowsStepsGeneratePreview.js";
export * from "./workflowsStepsRetrieve.js";
export * from "./workflowsSync.js";
export * from "./workflowsUpdate.js";


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/integrationsCreate.ts
Tamaño: 2729 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { integrationsCreate } from "../funcs/integrationsCreate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type IntegrationsCreateMutationVariables = {
  createIntegrationRequestDto: components.CreateIntegrationRequestDto;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type IntegrationsCreateMutationData =
  operations.IntegrationsControllerCreateIntegrationResponse;

/**
 * Create an integration
 *
 * @remarks
 * Create an integration for the current environment the user is based on the API key provided.
 *     Each provider supports different credentials, check the provider documentation for more details.
 */
export function useIntegrationsCreateMutation(
  options?: MutationHookOptions<
    IntegrationsCreateMutationData,
    Error,
    IntegrationsCreateMutationVariables
  >,
): UseMutationResult<
  IntegrationsCreateMutationData,
  Error,
  IntegrationsCreateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildIntegrationsCreateMutation(client, options),
    ...options,
  });
}

export function mutationKeyIntegrationsCreate(): MutationKey {
  return ["@novu/api", "Integrations", "create"];
}

export function buildIntegrationsCreateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: IntegrationsCreateMutationVariables,
  ) => Promise<IntegrationsCreateMutationData>;
} {
  return {
    mutationKey: mutationKeyIntegrationsCreate(),
    mutationFn: function integrationsCreateMutationFn({
      createIntegrationRequestDto,
      idempotencyKey,
      options,
    }): Promise<IntegrationsCreateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(integrationsCreate(
        client$,
        createIntegrationRequestDto,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useIntegrationsCreateMutation(options?: MutationHookOptions<
    IntegrationsCreateMutationData,
    Error,
    IntegrationsCreateMutationVariables
  >,)
 - mutationKeyIntegrationsCreate()
 - buildIntegrationsCreateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - integrationsCreateMutationFn({
      createIntegrationRequestDto,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildIntegrationsCreateMutation(client, options),
  ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useIntegrationsCreateMutation
- export function mutationKeyIntegrationsCreate
- export function buildIntegrationsCreateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/integrationsDelete.ts
Tamaño: 2503 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { integrationsDelete } from "../funcs/integrationsDelete.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type IntegrationsDeleteMutationVariables = {
  integrationId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type IntegrationsDeleteMutationData =
  operations.IntegrationsControllerRemoveIntegrationResponse;

/**
 * Delete an integration
 *
 * @remarks
 * Delete an integration by its unique key identifier **integrationId**.
 *     This action is irreversible.
 */
export function useIntegrationsDeleteMutation(
  options?: MutationHookOptions<
    IntegrationsDeleteMutationData,
    Error,
    IntegrationsDeleteMutationVariables
  >,
): UseMutationResult<
  IntegrationsDeleteMutationData,
  Error,
  IntegrationsDeleteMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildIntegrationsDeleteMutation(client, options),
    ...options,
  });
}

export function mutationKeyIntegrationsDelete(): MutationKey {
  return ["@novu/api", "Integrations", "delete"];
}

export function buildIntegrationsDeleteMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: IntegrationsDeleteMutationVariables,
  ) => Promise<IntegrationsDeleteMutationData>;
} {
  return {
    mutationKey: mutationKeyIntegrationsDelete(),
    mutationFn: function integrationsDeleteMutationFn({
      integrationId,
      idempotencyKey,
      options,
    }): Promise<IntegrationsDeleteMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(integrationsDelete(
        client$,
        integrationId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useIntegrationsDeleteMutation(options?: MutationHookOptions<
    IntegrationsDeleteMutationData,
    Error,
    IntegrationsDeleteMutationVariables
  >,)
 - mutationKeyIntegrationsDelete()
 - buildIntegrationsDeleteMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - integrationsDeleteMutationFn({
      integrationId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildIntegrationsDeleteMutation(client, options),
  ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useIntegrationsDeleteMutation
- export function mutationKeyIntegrationsDelete
- export function buildIntegrationsDeleteMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/integrationsIntegrationsControllerAutoConfigureIntegration.ts
Tamaño: 3592 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { integrationsIntegrationsControllerAutoConfigureIntegration } from "../funcs/integrationsIntegrationsControllerAutoConfigureIntegration.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type IntegrationsIntegrationsControllerAutoConfigureIntegrationMutationVariables =
  {
    integrationId: string;
    idempotencyKey?: string | undefined;
    options?: RequestOptions;
  };

export type IntegrationsIntegrationsControllerAutoConfigureIntegrationMutationData =
  operations.IntegrationsControllerAutoConfigureIntegrationResponse;

/**
 * Auto-configure an integration for inbound webhooks
 *
 * @remarks
 * Auto-configure an integration by its unique key identifier **integrationId** for inbound webhook support.
 *     This will automatically generate required webhook signing keys and configure webhook endpoints.
 */
export function useIntegrationsIntegrationsControllerAutoConfigureIntegrationMutation(
  options?: MutationHookOptions<
    IntegrationsIntegrationsControllerAutoConfigureIntegrationMutationData,
    Error,
    IntegrationsIntegrationsControllerAutoConfigureIntegrationMutationVariables
  >,
): UseMutationResult<
  IntegrationsIntegrationsControllerAutoConfigureIntegrationMutationData,
  Error,
  IntegrationsIntegrationsControllerAutoConfigureIntegrationMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildIntegrationsIntegrationsControllerAutoConfigureIntegrationMutation(
      client,
      options,
    ),
    ...options,
  });
}

export function mutationKeyIntegrationsIntegrationsControllerAutoConfigureIntegration(): MutationKey {
  return [
    "@novu/api",
    "Integrations",
    "integrationsControllerAutoConfigureIntegration",
  ];
}

export function buildIntegrationsIntegrationsControllerAutoConfigureIntegrationMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables:
      IntegrationsIntegrationsControllerAutoConfigureIntegrationMutationVariables,
  ) => Promise<
    IntegrationsIntegrationsControllerAutoConfigureIntegrationMutationData
  >;
} {
  return {
    mutationKey:
      mutationKeyIntegrationsIntegrationsControllerAutoConfigureIntegration(),
    mutationFn:
      function integrationsIntegrationsControllerAutoConfigureIntegrationMutationFn(
        {
          integrationId,
          idempotencyKey,
          options,
        },
      ): Promise<
        IntegrationsIntegrationsControllerAutoConfigureIntegrationMutationData
      > {
        const mergedOptions = {
          ...hookOptions,
          ...options,
          fetchOptions: {
            ...hookOptions?.fetchOptions,
            ...options?.fetchOptions,
            signal: combineSignals(
              hookOptions?.fetchOptions?.signal,
              options?.fetchOptions?.signal,
            ),
          },
        };
        return unwrapAsync(
          integrationsIntegrationsControllerAutoConfigureIntegration(
            client$,
            integrationId,
            idempotencyKey,
            mergedOptions,
          ),
        );
      },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useIntegrationsIntegrationsControllerAutoConfigureIntegrationMutation(options?: MutationHookOptions<
    IntegrationsIntegrationsControllerAutoConfigureIntegrationMutationData,
    Error,
    IntegrationsIntegrationsControllerAutoConfigureIntegrationMutationVariables
  >,)
 - mutationKeyIntegrationsIntegrationsControllerAutoConfigureIntegration()
 - buildIntegrationsIntegrationsControllerAutoConfigureIntegrationMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - integrationsIntegrationsControllerAutoConfigureIntegrationMutationFn({
          integrationId,
          idempotencyKey,
          options,
        },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildIntegrationsIntegrationsControllerAutoConfigure...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useIntegrationsIntegrationsControllerAutoConfigureIntegrationMutation
- export function mutationKeyIntegrationsIntegrationsControllerAutoConfigureIntegration
- export function buildIntegrationsIntegrationsControllerAutoConfigureIntegrationMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/integrationsList.ts
Tamaño: 4043 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { integrationsList } from "../funcs/integrationsList.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type IntegrationsListQueryData =
  operations.IntegrationsControllerListIntegrationsResponse;

/**
 * List all integrations
 *
 * @remarks
 * List all the channels integrations created in the organization
 */
export function useIntegrationsList(
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<IntegrationsListQueryData>,
): UseQueryResult<IntegrationsListQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildIntegrationsListQuery(
      client,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * List all integrations
 *
 * @remarks
 * List all the channels integrations created in the organization
 */
export function useIntegrationsListSuspense(
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<IntegrationsListQueryData>,
): UseSuspenseQueryResult<IntegrationsListQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildIntegrationsListQuery(
      client,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchIntegrationsList(
  queryClient: QueryClient,
  client$: NovuCore,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildIntegrationsListQuery(
      client$,
      idempotencyKey,
    ),
  });
}

export function setIntegrationsListData(
  client: QueryClient,
  queryKeyBase: [parameters: { idempotencyKey?: string | undefined }],
  data: IntegrationsListQueryData,
): IntegrationsListQueryData | undefined {
  const key = queryKeyIntegrationsList(...queryKeyBase);

  return client.setQueryData<IntegrationsListQueryData>(key, data);
}

export function invalidateIntegrationsList(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Integrations", "list", ...queryKeyBase],
  });
}

export function invalidateAllIntegrationsList(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Integrations", "list"],
  });
}

export function buildIntegrationsListQuery(
  client$: NovuCore,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<IntegrationsListQueryData>;
} {
  return {
    queryKey: queryKeyIntegrationsList({ idempotencyKey }),
    queryFn: async function integrationsListQueryFn(
      ctx,
    ): Promise<IntegrationsListQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(integrationsList(
        client$,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyIntegrationsList(
  parameters: { idempotencyKey?: string | undefined },
): QueryKey {
  return ["@novu/api", "Integrations", "list", parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useIntegrationsList(idempotencyKey?: string | undefined,
  options?: QueryHookOptions<IntegrationsListQueryData>,)
 - useIntegrationsListSuspense(idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<IntegrationsListQueryData>,)
 - prefetchIntegrationsList(queryClient: QueryClient,
  client$: NovuCore,
  idempotencyKey?: string | undefined,)
 - setIntegrationsListData(client: QueryClient,
  queryKeyBase: [parameters: { idempotencyKey?: string | undefined }],
  data: IntegrationsListQueryData,)
 - invalidateIntegrationsList(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllIntegrationsList(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildIntegrationsListQuery(client$: NovuCore,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - integrationsListQueryFn(ctx,)
 - queryKeyIntegrationsList(parameters: { idempotencyKey?: string | undefined },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyIntegrationsList(...queryKeyBase);

  return client.setQueryData<IntegrationsListQueryData>(...)
Declaraciones 'export' encontradas:
- export  type
- export function useIntegrationsList
- export function useIntegrationsListSuspense
- export function prefetchIntegrationsList
- export function setIntegrationsListData
- export function invalidateIntegrationsList
- export function invalidateAllIntegrationsList
- export function buildIntegrationsListQuery
- export function queryKeyIntegrationsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/integrationsListActive.ts
Tamaño: 4230 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { integrationsListActive } from "../funcs/integrationsListActive.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type IntegrationsListActiveQueryData =
  operations.IntegrationsControllerGetActiveIntegrationsResponse;

/**
 * List active integrations
 *
 * @remarks
 * List all the active integrations created in the organization
 */
export function useIntegrationsListActive(
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<IntegrationsListActiveQueryData>,
): UseQueryResult<IntegrationsListActiveQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildIntegrationsListActiveQuery(
      client,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * List active integrations
 *
 * @remarks
 * List all the active integrations created in the organization
 */
export function useIntegrationsListActiveSuspense(
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<IntegrationsListActiveQueryData>,
): UseSuspenseQueryResult<IntegrationsListActiveQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildIntegrationsListActiveQuery(
      client,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchIntegrationsListActive(
  queryClient: QueryClient,
  client$: NovuCore,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildIntegrationsListActiveQuery(
      client$,
      idempotencyKey,
    ),
  });
}

export function setIntegrationsListActiveData(
  client: QueryClient,
  queryKeyBase: [parameters: { idempotencyKey?: string | undefined }],
  data: IntegrationsListActiveQueryData,
): IntegrationsListActiveQueryData | undefined {
  const key = queryKeyIntegrationsListActive(...queryKeyBase);

  return client.setQueryData<IntegrationsListActiveQueryData>(key, data);
}

export function invalidateIntegrationsListActive(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Integrations", "listActive", ...queryKeyBase],
  });
}

export function invalidateAllIntegrationsListActive(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Integrations", "listActive"],
  });
}

export function buildIntegrationsListActiveQuery(
  client$: NovuCore,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<IntegrationsListActiveQueryData>;
} {
  return {
    queryKey: queryKeyIntegrationsListActive({ idempotencyKey }),
    queryFn: async function integrationsListActiveQueryFn(
      ctx,
    ): Promise<IntegrationsListActiveQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(integrationsListActive(
        client$,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyIntegrationsListActive(
  parameters: { idempotencyKey?: string | undefined },
): QueryKey {
  return ["@novu/api", "Integrations", "listActive", parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useIntegrationsListActive(idempotencyKey?: string | undefined,
  options?: QueryHookOptions<IntegrationsListActiveQueryData>,)
 - useIntegrationsListActiveSuspense(idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<IntegrationsListActiveQueryData>,)
 - prefetchIntegrationsListActive(queryClient: QueryClient,
  client$: NovuCore,
  idempotencyKey?: string | undefined,)
 - setIntegrationsListActiveData(client: QueryClient,
  queryKeyBase: [parameters: { idempotencyKey?: string | undefined }],
  data: IntegrationsListActiveQueryData,)
 - invalidateIntegrationsListActive(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllIntegrationsListActive(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildIntegrationsListActiveQuery(client$: NovuCore,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - integrationsListActiveQueryFn(ctx,)
 - queryKeyIntegrationsListActive(parameters: { idempotencyKey?: string | undefined },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyIntegrationsListActive(...queryKeyBase);

  return client.setQueryData<IntegrationsListActiv...)
Declaraciones 'export' encontradas:
- export  type
- export function useIntegrationsListActive
- export function useIntegrationsListActiveSuspense
- export function prefetchIntegrationsListActive
- export function setIntegrationsListActiveData
- export function invalidateIntegrationsListActive
- export function invalidateAllIntegrationsListActive
- export function buildIntegrationsListActiveQuery
- export function queryKeyIntegrationsListActive

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/integrationsSetAsPrimary.ts
Tamaño: 2810 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { integrationsSetAsPrimary } from "../funcs/integrationsSetAsPrimary.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type IntegrationsSetAsPrimaryMutationVariables = {
  integrationId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type IntegrationsSetAsPrimaryMutationData =
  operations.IntegrationsControllerSetIntegrationAsPrimaryResponse;

/**
 * Update integration as primary
 *
 * @remarks
 * Update an integration as **primary** by its unique key identifier **integrationId**.
 *     This API will set the integration as primary for that channel in the current environment.
 *     Primary integration is used to deliver notification for sms and email channels in the workflow.
 */
export function useIntegrationsSetAsPrimaryMutation(
  options?: MutationHookOptions<
    IntegrationsSetAsPrimaryMutationData,
    Error,
    IntegrationsSetAsPrimaryMutationVariables
  >,
): UseMutationResult<
  IntegrationsSetAsPrimaryMutationData,
  Error,
  IntegrationsSetAsPrimaryMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildIntegrationsSetAsPrimaryMutation(client, options),
    ...options,
  });
}

export function mutationKeyIntegrationsSetAsPrimary(): MutationKey {
  return ["@novu/api", "Integrations", "setAsPrimary"];
}

export function buildIntegrationsSetAsPrimaryMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: IntegrationsSetAsPrimaryMutationVariables,
  ) => Promise<IntegrationsSetAsPrimaryMutationData>;
} {
  return {
    mutationKey: mutationKeyIntegrationsSetAsPrimary(),
    mutationFn: function integrationsSetAsPrimaryMutationFn({
      integrationId,
      idempotencyKey,
      options,
    }): Promise<IntegrationsSetAsPrimaryMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(integrationsSetAsPrimary(
        client$,
        integrationId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useIntegrationsSetAsPrimaryMutation(options?: MutationHookOptions<
    IntegrationsSetAsPrimaryMutationData,
    Error,
    IntegrationsSetAsPrimaryMutationVariables
  >,)
 - mutationKeyIntegrationsSetAsPrimary()
 - buildIntegrationsSetAsPrimaryMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - integrationsSetAsPrimaryMutationFn({
      integrationId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildIntegrationsSetAsPrimaryMutation(client, option...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useIntegrationsSetAsPrimaryMutation
- export function mutationKeyIntegrationsSetAsPrimary
- export function buildIntegrationsSetAsPrimaryMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/integrationsUpdate.ts
Tamaño: 2779 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { integrationsUpdate } from "../funcs/integrationsUpdate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type IntegrationsUpdateMutationVariables = {
  updateIntegrationRequestDto: components.UpdateIntegrationRequestDto;
  integrationId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type IntegrationsUpdateMutationData =
  operations.IntegrationsControllerUpdateIntegrationByIdResponse;

/**
 * Update an integration
 *
 * @remarks
 * Update an integration by its unique key identifier **integrationId**.
 *     Each provider supports different credentials, check the provider documentation for more details.
 */
export function useIntegrationsUpdateMutation(
  options?: MutationHookOptions<
    IntegrationsUpdateMutationData,
    Error,
    IntegrationsUpdateMutationVariables
  >,
): UseMutationResult<
  IntegrationsUpdateMutationData,
  Error,
  IntegrationsUpdateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildIntegrationsUpdateMutation(client, options),
    ...options,
  });
}

export function mutationKeyIntegrationsUpdate(): MutationKey {
  return ["@novu/api", "Integrations", "update"];
}

export function buildIntegrationsUpdateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: IntegrationsUpdateMutationVariables,
  ) => Promise<IntegrationsUpdateMutationData>;
} {
  return {
    mutationKey: mutationKeyIntegrationsUpdate(),
    mutationFn: function integrationsUpdateMutationFn({
      updateIntegrationRequestDto,
      integrationId,
      idempotencyKey,
      options,
    }): Promise<IntegrationsUpdateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(integrationsUpdate(
        client$,
        updateIntegrationRequestDto,
        integrationId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useIntegrationsUpdateMutation(options?: MutationHookOptions<
    IntegrationsUpdateMutationData,
    Error,
    IntegrationsUpdateMutationVariables
  >,)
 - mutationKeyIntegrationsUpdate()
 - buildIntegrationsUpdateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - integrationsUpdateMutationFn({
      updateIntegrationRequestDto,
      integrationId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildIntegrationsUpdateMutation(client, options),
  ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useIntegrationsUpdateMutation
- export function mutationKeyIntegrationsUpdate
- export function buildIntegrationsUpdateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/layoutsCreate.ts
Tamaño: 2418 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { layoutsCreate } from "../funcs/layoutsCreate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type LayoutsCreateMutationVariables = {
  createLayoutDto: components.CreateLayoutDto;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type LayoutsCreateMutationData =
  operations.LayoutsControllerCreateResponse;

/**
 * Create a layout
 *
 * @remarks
 * Creates a new layout in the Novu Cloud environment
 */
export function useLayoutsCreateMutation(
  options?: MutationHookOptions<
    LayoutsCreateMutationData,
    Error,
    LayoutsCreateMutationVariables
  >,
): UseMutationResult<
  LayoutsCreateMutationData,
  Error,
  LayoutsCreateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildLayoutsCreateMutation(client, options),
    ...options,
  });
}

export function mutationKeyLayoutsCreate(): MutationKey {
  return ["@novu/api", "Layouts", "create"];
}

export function buildLayoutsCreateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: LayoutsCreateMutationVariables,
  ) => Promise<LayoutsCreateMutationData>;
} {
  return {
    mutationKey: mutationKeyLayoutsCreate(),
    mutationFn: function layoutsCreateMutationFn({
      createLayoutDto,
      idempotencyKey,
      options,
    }): Promise<LayoutsCreateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(layoutsCreate(
        client$,
        createLayoutDto,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useLayoutsCreateMutation(options?: MutationHookOptions<
    LayoutsCreateMutationData,
    Error,
    LayoutsCreateMutationVariables
  >,)
 - mutationKeyLayoutsCreate()
 - buildLayoutsCreateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - layoutsCreateMutationFn({
      createLayoutDto,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildLayoutsCreateMutation(client, options),
    ......)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useLayoutsCreateMutation
- export function mutationKeyLayoutsCreate
- export function buildLayoutsCreateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/layoutsDelete.ts
Tamaño: 2345 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { layoutsDelete } from "../funcs/layoutsDelete.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type LayoutsDeleteMutationVariables = {
  layoutId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type LayoutsDeleteMutationData =
  | operations.LayoutsControllerDeleteResponse
  | undefined;

/**
 * Delete a layout
 *
 * @remarks
 * Removes a specific layout by its unique identifier **layoutId**
 */
export function useLayoutsDeleteMutation(
  options?: MutationHookOptions<
    LayoutsDeleteMutationData,
    Error,
    LayoutsDeleteMutationVariables
  >,
): UseMutationResult<
  LayoutsDeleteMutationData,
  Error,
  LayoutsDeleteMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildLayoutsDeleteMutation(client, options),
    ...options,
  });
}

export function mutationKeyLayoutsDelete(): MutationKey {
  return ["@novu/api", "Layouts", "delete"];
}

export function buildLayoutsDeleteMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: LayoutsDeleteMutationVariables,
  ) => Promise<LayoutsDeleteMutationData>;
} {
  return {
    mutationKey: mutationKeyLayoutsDelete(),
    mutationFn: function layoutsDeleteMutationFn({
      layoutId,
      idempotencyKey,
      options,
    }): Promise<LayoutsDeleteMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(layoutsDelete(
        client$,
        layoutId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useLayoutsDeleteMutation(options?: MutationHookOptions<
    LayoutsDeleteMutationData,
    Error,
    LayoutsDeleteMutationVariables
  >,)
 - mutationKeyLayoutsDelete()
 - buildLayoutsDeleteMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - layoutsDeleteMutationFn({
      layoutId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildLayoutsDeleteMutation(client, options),
    ......)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useLayoutsDeleteMutation
- export function mutationKeyLayoutsDelete
- export function buildLayoutsDeleteMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/layoutsDuplicate.ts
Tamaño: 2626 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { layoutsDuplicate } from "../funcs/layoutsDuplicate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type LayoutsDuplicateMutationVariables = {
  duplicateLayoutDto: components.DuplicateLayoutDto;
  layoutId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type LayoutsDuplicateMutationData =
  operations.LayoutsControllerDuplicateResponse;

/**
 * Duplicate a layout
 *
 * @remarks
 * Duplicates a layout by its unique identifier **layoutId**. This will create a new layout with the content of the original layout.
 */
export function useLayoutsDuplicateMutation(
  options?: MutationHookOptions<
    LayoutsDuplicateMutationData,
    Error,
    LayoutsDuplicateMutationVariables
  >,
): UseMutationResult<
  LayoutsDuplicateMutationData,
  Error,
  LayoutsDuplicateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildLayoutsDuplicateMutation(client, options),
    ...options,
  });
}

export function mutationKeyLayoutsDuplicate(): MutationKey {
  return ["@novu/api", "Layouts", "duplicate"];
}

export function buildLayoutsDuplicateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: LayoutsDuplicateMutationVariables,
  ) => Promise<LayoutsDuplicateMutationData>;
} {
  return {
    mutationKey: mutationKeyLayoutsDuplicate(),
    mutationFn: function layoutsDuplicateMutationFn({
      duplicateLayoutDto,
      layoutId,
      idempotencyKey,
      options,
    }): Promise<LayoutsDuplicateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(layoutsDuplicate(
        client$,
        duplicateLayoutDto,
        layoutId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useLayoutsDuplicateMutation(options?: MutationHookOptions<
    LayoutsDuplicateMutationData,
    Error,
    LayoutsDuplicateMutationVariables
  >,)
 - mutationKeyLayoutsDuplicate()
 - buildLayoutsDuplicateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - layoutsDuplicateMutationFn({
      duplicateLayoutDto,
      layoutId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildLayoutsDuplicateMutation(client, options),
    ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useLayoutsDuplicateMutation
- export function mutationKeyLayoutsDuplicate
- export function buildLayoutsDuplicateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/layoutsGeneratePreview.ts
Tamaño: 2712 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { layoutsGeneratePreview } from "../funcs/layoutsGeneratePreview.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type LayoutsGeneratePreviewMutationVariables = {
  layoutPreviewRequestDto: components.LayoutPreviewRequestDto;
  layoutId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type LayoutsGeneratePreviewMutationData =
  operations.LayoutsControllerGeneratePreviewResponse;

/**
 * Generate layout preview
 *
 * @remarks
 * Generates a preview for a layout by its unique identifier **layoutId**
 */
export function useLayoutsGeneratePreviewMutation(
  options?: MutationHookOptions<
    LayoutsGeneratePreviewMutationData,
    Error,
    LayoutsGeneratePreviewMutationVariables
  >,
): UseMutationResult<
  LayoutsGeneratePreviewMutationData,
  Error,
  LayoutsGeneratePreviewMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildLayoutsGeneratePreviewMutation(client, options),
    ...options,
  });
}

export function mutationKeyLayoutsGeneratePreview(): MutationKey {
  return ["@novu/api", "Layouts", "generatePreview"];
}

export function buildLayoutsGeneratePreviewMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: LayoutsGeneratePreviewMutationVariables,
  ) => Promise<LayoutsGeneratePreviewMutationData>;
} {
  return {
    mutationKey: mutationKeyLayoutsGeneratePreview(),
    mutationFn: function layoutsGeneratePreviewMutationFn({
      layoutPreviewRequestDto,
      layoutId,
      idempotencyKey,
      options,
    }): Promise<LayoutsGeneratePreviewMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(layoutsGeneratePreview(
        client$,
        layoutPreviewRequestDto,
        layoutId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useLayoutsGeneratePreviewMutation(options?: MutationHookOptions<
    LayoutsGeneratePreviewMutationData,
    Error,
    LayoutsGeneratePreviewMutationVariables
  >,)
 - mutationKeyLayoutsGeneratePreview()
 - buildLayoutsGeneratePreviewMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - layoutsGeneratePreviewMutationFn({
      layoutPreviewRequestDto,
      layoutId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildLayoutsGeneratePreviewMutation(client, options)...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useLayoutsGeneratePreviewMutation
- export function mutationKeyLayoutsGeneratePreview
- export function buildLayoutsGeneratePreviewMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/layoutsList.ts
Tamaño: 4868 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { layoutsList } from "../funcs/layoutsList.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type LayoutsListQueryData = operations.LayoutsControllerListResponse;

/**
 * List all layouts
 *
 * @remarks
 * Retrieves a list of layouts with optional filtering and pagination
 */
export function useLayoutsList(
  request: operations.LayoutsControllerListRequest,
  options?: QueryHookOptions<LayoutsListQueryData>,
): UseQueryResult<LayoutsListQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildLayoutsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

/**
 * List all layouts
 *
 * @remarks
 * Retrieves a list of layouts with optional filtering and pagination
 */
export function useLayoutsListSuspense(
  request: operations.LayoutsControllerListRequest,
  options?: SuspenseQueryHookOptions<LayoutsListQueryData>,
): UseSuspenseQueryResult<LayoutsListQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildLayoutsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

export function prefetchLayoutsList(
  queryClient: QueryClient,
  client$: NovuCore,
  request: operations.LayoutsControllerListRequest,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildLayoutsListQuery(
      client$,
      request,
    ),
  });
}

export function setLayoutsListData(
  client: QueryClient,
  queryKeyBase: [
    parameters: {
      limit?: number | undefined;
      offset?: number | undefined;
      orderDirection?: components.DirectionEnum | undefined;
      orderBy?: components.LayoutResponseDtoSortField | undefined;
      query?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: LayoutsListQueryData,
): LayoutsListQueryData | undefined {
  const key = queryKeyLayoutsList(...queryKeyBase);

  return client.setQueryData<LayoutsListQueryData>(key, data);
}

export function invalidateLayoutsList(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      limit?: number | undefined;
      offset?: number | undefined;
      orderDirection?: components.DirectionEnum | undefined;
      orderBy?: components.LayoutResponseDtoSortField | undefined;
      query?: string | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Layouts", "list", ...queryKeyBase],
  });
}

export function invalidateAllLayoutsList(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Layouts", "list"],
  });
}

export function buildLayoutsListQuery(
  client$: NovuCore,
  request: operations.LayoutsControllerListRequest,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (context: QueryFunctionContext) => Promise<LayoutsListQueryData>;
} {
  return {
    queryKey: queryKeyLayoutsList({
      limit: request.limit,
      offset: request.offset,
      orderDirection: request.orderDirection,
      orderBy: request.orderBy,
      query: request.query,
      idempotencyKey: request.idempotencyKey,
    }),
    queryFn: async function layoutsListQueryFn(
      ctx,
    ): Promise<LayoutsListQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(layoutsList(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyLayoutsList(
  parameters: {
    limit?: number | undefined;
    offset?: number | undefined;
    orderDirection?: components.DirectionEnum | undefined;
    orderBy?: components.LayoutResponseDtoSortField | undefined;
    query?: string | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return ["@novu/api", "Layouts", "list", parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useLayoutsList(request: operations.LayoutsControllerListRequest,
  options?: QueryHookOptions<LayoutsListQueryData>,)
 - useLayoutsListSuspense(request: operations.LayoutsControllerListRequest,
  options?: SuspenseQueryHookOptions<LayoutsListQueryData>,)
 - prefetchLayoutsList(queryClient: QueryClient,
  client$: NovuCore,
  request: operations.LayoutsControllerListRequest,)
 - setLayoutsListData(client: QueryClient,
  queryKeyBase: [
    parameters: {
      limit?: number | undefined;
      offset?: number | undefined;
      orderDirection?: components.DirectionEnum | undefined;
      orderBy?: components.LayoutResponseDtoSortField | undefined;
      query?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: LayoutsListQueryData,)
 - invalidateLayoutsList(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      limit?: number | undefined;
      offset?: number | undefined;
      orderDirection?: components.DirectionEnum | undefined;
      orderBy?: components.LayoutResponseDtoSortField | undefined;
      query?: string | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllLayoutsList(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildLayoutsListQuery(client$: NovuCore,
  request: operations.LayoutsControllerListRequest,
  options?: RequestOptions,)
 - layoutsListQueryFn(ctx,)
 - queryKeyLayoutsList(parameters: {
    limit?: number | undefined;
    offset?: number | undefined;
    orderDirection?: components.DirectionEnum | undefined;
    orderBy?: components.LayoutResponseDtoSortField | undefined;
    query?: string | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyLayoutsList(...queryKeyBase);

  return client.setQueryData<LayoutsListQueryData>(key, data)...)
Declaraciones 'export' encontradas:
- export  type
- export function useLayoutsList
- export function useLayoutsListSuspense
- export function prefetchLayoutsList
- export function setLayoutsListData
- export function invalidateLayoutsList
- export function invalidateAllLayoutsList
- export function buildLayoutsListQuery
- export function queryKeyLayoutsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/layoutsRetrieve.ts
Tamaño: 4235 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { layoutsRetrieve } from "../funcs/layoutsRetrieve.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type LayoutsRetrieveQueryData = operations.LayoutsControllerGetResponse;

/**
 * Retrieve a layout
 *
 * @remarks
 * Fetches details of a specific layout by its unique identifier **layoutId**
 */
export function useLayoutsRetrieve(
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<LayoutsRetrieveQueryData>,
): UseQueryResult<LayoutsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildLayoutsRetrieveQuery(
      client,
      layoutId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * Retrieve a layout
 *
 * @remarks
 * Fetches details of a specific layout by its unique identifier **layoutId**
 */
export function useLayoutsRetrieveSuspense(
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<LayoutsRetrieveQueryData>,
): UseSuspenseQueryResult<LayoutsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildLayoutsRetrieveQuery(
      client,
      layoutId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchLayoutsRetrieve(
  queryClient: QueryClient,
  client$: NovuCore,
  layoutId: string,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildLayoutsRetrieveQuery(
      client$,
      layoutId,
      idempotencyKey,
    ),
  });
}

export function setLayoutsRetrieveData(
  client: QueryClient,
  queryKeyBase: [
    layoutId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: LayoutsRetrieveQueryData,
): LayoutsRetrieveQueryData | undefined {
  const key = queryKeyLayoutsRetrieve(...queryKeyBase);

  return client.setQueryData<LayoutsRetrieveQueryData>(key, data);
}

export function invalidateLayoutsRetrieve(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [layoutId: string, parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Layouts", "retrieve", ...queryKeyBase],
  });
}

export function invalidateAllLayoutsRetrieve(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Layouts", "retrieve"],
  });
}

export function buildLayoutsRetrieveQuery(
  client$: NovuCore,
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (context: QueryFunctionContext) => Promise<LayoutsRetrieveQueryData>;
} {
  return {
    queryKey: queryKeyLayoutsRetrieve(layoutId, { idempotencyKey }),
    queryFn: async function layoutsRetrieveQueryFn(
      ctx,
    ): Promise<LayoutsRetrieveQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(layoutsRetrieve(
        client$,
        layoutId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyLayoutsRetrieve(
  layoutId: string,
  parameters: { idempotencyKey?: string | undefined },
): QueryKey {
  return ["@novu/api", "Layouts", "retrieve", layoutId, parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useLayoutsRetrieve(layoutId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<LayoutsRetrieveQueryData>,)
 - useLayoutsRetrieveSuspense(layoutId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<LayoutsRetrieveQueryData>,)
 - prefetchLayoutsRetrieve(queryClient: QueryClient,
  client$: NovuCore,
  layoutId: string,
  idempotencyKey?: string | undefined,)
 - setLayoutsRetrieveData(client: QueryClient,
  queryKeyBase: [
    layoutId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: LayoutsRetrieveQueryData,)
 - invalidateLayoutsRetrieve(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [layoutId: string, parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllLayoutsRetrieve(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildLayoutsRetrieveQuery(client$: NovuCore,
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - layoutsRetrieveQueryFn(ctx,)
 - queryKeyLayoutsRetrieve(layoutId: string,
  parameters: { idempotencyKey?: string | undefined },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyLayoutsRetrieve(...queryKeyBase);

  return client.setQueryData<LayoutsRetrieveQueryData>(ke...)
Declaraciones 'export' encontradas:
- export  type
- export function useLayoutsRetrieve
- export function useLayoutsRetrieveSuspense
- export function prefetchLayoutsRetrieve
- export function setLayoutsRetrieveData
- export function invalidateLayoutsRetrieve
- export function invalidateAllLayoutsRetrieve
- export function buildLayoutsRetrieveQuery
- export function queryKeyLayoutsRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/layoutsUpdate.ts
Tamaño: 2514 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { layoutsUpdate } from "../funcs/layoutsUpdate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type LayoutsUpdateMutationVariables = {
  updateLayoutDto: components.UpdateLayoutDto;
  layoutId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type LayoutsUpdateMutationData =
  operations.LayoutsControllerUpdateResponse;

/**
 * Update a layout
 *
 * @remarks
 * Updates the details of an existing layout, here **layoutId** is the identifier of the layout
 */
export function useLayoutsUpdateMutation(
  options?: MutationHookOptions<
    LayoutsUpdateMutationData,
    Error,
    LayoutsUpdateMutationVariables
  >,
): UseMutationResult<
  LayoutsUpdateMutationData,
  Error,
  LayoutsUpdateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildLayoutsUpdateMutation(client, options),
    ...options,
  });
}

export function mutationKeyLayoutsUpdate(): MutationKey {
  return ["@novu/api", "Layouts", "update"];
}

export function buildLayoutsUpdateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: LayoutsUpdateMutationVariables,
  ) => Promise<LayoutsUpdateMutationData>;
} {
  return {
    mutationKey: mutationKeyLayoutsUpdate(),
    mutationFn: function layoutsUpdateMutationFn({
      updateLayoutDto,
      layoutId,
      idempotencyKey,
      options,
    }): Promise<LayoutsUpdateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(layoutsUpdate(
        client$,
        updateLayoutDto,
        layoutId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useLayoutsUpdateMutation(options?: MutationHookOptions<
    LayoutsUpdateMutationData,
    Error,
    LayoutsUpdateMutationVariables
  >,)
 - mutationKeyLayoutsUpdate()
 - buildLayoutsUpdateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - layoutsUpdateMutationFn({
      updateLayoutDto,
      layoutId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildLayoutsUpdateMutation(client, options),
    ......)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useLayoutsUpdateMutation
- export function mutationKeyLayoutsUpdate
- export function buildLayoutsUpdateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/layoutsUsage.ts
Tamaño: 4212 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { layoutsUsage } from "../funcs/layoutsUsage.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type LayoutsUsageQueryData =
  operations.LayoutsControllerGetUsageResponse;

/**
 * Get layout usage
 *
 * @remarks
 * Retrieves information about workflows that use the specified layout by its unique identifier **layoutId**
 */
export function useLayoutsUsage(
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<LayoutsUsageQueryData>,
): UseQueryResult<LayoutsUsageQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildLayoutsUsageQuery(
      client,
      layoutId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * Get layout usage
 *
 * @remarks
 * Retrieves information about workflows that use the specified layout by its unique identifier **layoutId**
 */
export function useLayoutsUsageSuspense(
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<LayoutsUsageQueryData>,
): UseSuspenseQueryResult<LayoutsUsageQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildLayoutsUsageQuery(
      client,
      layoutId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchLayoutsUsage(
  queryClient: QueryClient,
  client$: NovuCore,
  layoutId: string,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildLayoutsUsageQuery(
      client$,
      layoutId,
      idempotencyKey,
    ),
  });
}

export function setLayoutsUsageData(
  client: QueryClient,
  queryKeyBase: [
    layoutId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: LayoutsUsageQueryData,
): LayoutsUsageQueryData | undefined {
  const key = queryKeyLayoutsUsage(...queryKeyBase);

  return client.setQueryData<LayoutsUsageQueryData>(key, data);
}

export function invalidateLayoutsUsage(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [layoutId: string, parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Layouts", "usage", ...queryKeyBase],
  });
}

export function invalidateAllLayoutsUsage(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Layouts", "usage"],
  });
}

export function buildLayoutsUsageQuery(
  client$: NovuCore,
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (context: QueryFunctionContext) => Promise<LayoutsUsageQueryData>;
} {
  return {
    queryKey: queryKeyLayoutsUsage(layoutId, { idempotencyKey }),
    queryFn: async function layoutsUsageQueryFn(
      ctx,
    ): Promise<LayoutsUsageQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(layoutsUsage(
        client$,
        layoutId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyLayoutsUsage(
  layoutId: string,
  parameters: { idempotencyKey?: string | undefined },
): QueryKey {
  return ["@novu/api", "Layouts", "usage", layoutId, parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useLayoutsUsage(layoutId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<LayoutsUsageQueryData>,)
 - useLayoutsUsageSuspense(layoutId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<LayoutsUsageQueryData>,)
 - prefetchLayoutsUsage(queryClient: QueryClient,
  client$: NovuCore,
  layoutId: string,
  idempotencyKey?: string | undefined,)
 - setLayoutsUsageData(client: QueryClient,
  queryKeyBase: [
    layoutId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: LayoutsUsageQueryData,)
 - invalidateLayoutsUsage(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [layoutId: string, parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllLayoutsUsage(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildLayoutsUsageQuery(client$: NovuCore,
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - layoutsUsageQueryFn(ctx,)
 - queryKeyLayoutsUsage(layoutId: string,
  parameters: { idempotencyKey?: string | undefined },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyLayoutsUsage(...queryKeyBase);

  return client.setQueryData<LayoutsUsageQueryData>(key, dat...)
Declaraciones 'export' encontradas:
- export  type
- export function useLayoutsUsage
- export function useLayoutsUsageSuspense
- export function prefetchLayoutsUsage
- export function setLayoutsUsageData
- export function invalidateLayoutsUsage
- export function invalidateAllLayoutsUsage
- export function buildLayoutsUsageQuery
- export function queryKeyLayoutsUsage

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/messagesDelete.ts
Tamaño: 2446 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { messagesDelete } from "../funcs/messagesDelete.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type MessagesDeleteMutationVariables = {
  messageId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type MessagesDeleteMutationData =
  operations.MessagesControllerDeleteMessageResponse;

/**
 * Delete a message
 *
 * @remarks
 * Delete a message entity from the Novu platform by **messageId**.
 *     This action is irreversible. **messageId** is required and of mongodbId type.
 */
export function useMessagesDeleteMutation(
  options?: MutationHookOptions<
    MessagesDeleteMutationData,
    Error,
    MessagesDeleteMutationVariables
  >,
): UseMutationResult<
  MessagesDeleteMutationData,
  Error,
  MessagesDeleteMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildMessagesDeleteMutation(client, options),
    ...options,
  });
}

export function mutationKeyMessagesDelete(): MutationKey {
  return ["@novu/api", "Messages", "delete"];
}

export function buildMessagesDeleteMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: MessagesDeleteMutationVariables,
  ) => Promise<MessagesDeleteMutationData>;
} {
  return {
    mutationKey: mutationKeyMessagesDelete(),
    mutationFn: function messagesDeleteMutationFn({
      messageId,
      idempotencyKey,
      options,
    }): Promise<MessagesDeleteMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(messagesDelete(
        client$,
        messageId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useMessagesDeleteMutation(options?: MutationHookOptions<
    MessagesDeleteMutationData,
    Error,
    MessagesDeleteMutationVariables
  >,)
 - mutationKeyMessagesDelete()
 - buildMessagesDeleteMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - messagesDeleteMutationFn({
      messageId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildMessagesDeleteMutation(client, options),
    .....)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useMessagesDeleteMutation
- export function mutationKeyMessagesDelete
- export function buildMessagesDeleteMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/messagesDeleteByTransactionId.ts
Tamaño: 2922 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { messagesDeleteByTransactionId } from "../funcs/messagesDeleteByTransactionId.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type MessagesDeleteByTransactionIdMutationVariables = {
  transactionId: string;
  channel?: operations.Channel | undefined;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type MessagesDeleteByTransactionIdMutationData =
  | operations.MessagesControllerDeleteMessagesByTransactionIdResponse
  | undefined;

/**
 * Delete messages by transactionId
 *
 * @remarks
 * Delete multiple messages from the Novu platform using **transactionId** of triggered event.
 *     This API supports filtering by **channel** and delete all messages associated with the **transactionId**.
 */
export function useMessagesDeleteByTransactionIdMutation(
  options?: MutationHookOptions<
    MessagesDeleteByTransactionIdMutationData,
    Error,
    MessagesDeleteByTransactionIdMutationVariables
  >,
): UseMutationResult<
  MessagesDeleteByTransactionIdMutationData,
  Error,
  MessagesDeleteByTransactionIdMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildMessagesDeleteByTransactionIdMutation(client, options),
    ...options,
  });
}

export function mutationKeyMessagesDeleteByTransactionId(): MutationKey {
  return ["@novu/api", "Messages", "deleteByTransactionId"];
}

export function buildMessagesDeleteByTransactionIdMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: MessagesDeleteByTransactionIdMutationVariables,
  ) => Promise<MessagesDeleteByTransactionIdMutationData>;
} {
  return {
    mutationKey: mutationKeyMessagesDeleteByTransactionId(),
    mutationFn: function messagesDeleteByTransactionIdMutationFn({
      transactionId,
      channel,
      idempotencyKey,
      options,
    }): Promise<MessagesDeleteByTransactionIdMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(messagesDeleteByTransactionId(
        client$,
        transactionId,
        channel,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useMessagesDeleteByTransactionIdMutation(options?: MutationHookOptions<
    MessagesDeleteByTransactionIdMutationData,
    Error,
    MessagesDeleteByTransactionIdMutationVariables
  >,)
 - mutationKeyMessagesDeleteByTransactionId()
 - buildMessagesDeleteByTransactionIdMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - messagesDeleteByTransactionIdMutationFn({
      transactionId,
      channel,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildMessagesDeleteByTransactionIdMutation(client, o...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useMessagesDeleteByTransactionIdMutation
- export function mutationKeyMessagesDeleteByTransactionId
- export function buildMessagesDeleteByTransactionIdMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/messagesRetrieve.ts
Tamaño: 5456 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { messagesRetrieve } from "../funcs/messagesRetrieve.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type MessagesRetrieveQueryData =
  operations.MessagesControllerGetMessagesResponse;

/**
 * List all messages
 *
 * @remarks
 * List all messages for the current environment.
 *     This API supports filtering by **channel**, **subscriberId**, and **transactionId**.
 *     This API returns a paginated list of messages.
 */
export function useMessagesRetrieve(
  request: operations.MessagesControllerGetMessagesRequest,
  options?: QueryHookOptions<MessagesRetrieveQueryData>,
): UseQueryResult<MessagesRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildMessagesRetrieveQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

/**
 * List all messages
 *
 * @remarks
 * List all messages for the current environment.
 *     This API supports filtering by **channel**, **subscriberId**, and **transactionId**.
 *     This API returns a paginated list of messages.
 */
export function useMessagesRetrieveSuspense(
  request: operations.MessagesControllerGetMessagesRequest,
  options?: SuspenseQueryHookOptions<MessagesRetrieveQueryData>,
): UseSuspenseQueryResult<MessagesRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildMessagesRetrieveQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

export function prefetchMessagesRetrieve(
  queryClient: QueryClient,
  client$: NovuCore,
  request: operations.MessagesControllerGetMessagesRequest,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildMessagesRetrieveQuery(
      client$,
      request,
    ),
  });
}

export function setMessagesRetrieveData(
  client: QueryClient,
  queryKeyBase: [
    parameters: {
      channel?: components.ChannelTypeEnum | undefined;
      subscriberId?: string | undefined;
      transactionId?: Array<string> | undefined;
      contextKeys?: Array<string> | undefined;
      page?: number | undefined;
      limit?: number | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: MessagesRetrieveQueryData,
): MessagesRetrieveQueryData | undefined {
  const key = queryKeyMessagesRetrieve(...queryKeyBase);

  return client.setQueryData<MessagesRetrieveQueryData>(key, data);
}

export function invalidateMessagesRetrieve(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      channel?: components.ChannelTypeEnum | undefined;
      subscriberId?: string | undefined;
      transactionId?: Array<string> | undefined;
      contextKeys?: Array<string> | undefined;
      page?: number | undefined;
      limit?: number | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Messages", "retrieve", ...queryKeyBase],
  });
}

export function invalidateAllMessagesRetrieve(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Messages", "retrieve"],
  });
}

export function buildMessagesRetrieveQuery(
  client$: NovuCore,
  request: operations.MessagesControllerGetMessagesRequest,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<MessagesRetrieveQueryData>;
} {
  return {
    queryKey: queryKeyMessagesRetrieve({
      channel: request.channel,
      subscriberId: request.subscriberId,
      transactionId: request.transactionId,
      contextKeys: request.contextKeys,
      page: request.page,
      limit: request.limit,
      idempotencyKey: request.idempotencyKey,
    }),
    queryFn: async function messagesRetrieveQueryFn(
      ctx,
    ): Promise<MessagesRetrieveQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(messagesRetrieve(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyMessagesRetrieve(
  parameters: {
    channel?: components.ChannelTypeEnum | undefined;
    subscriberId?: string | undefined;
    transactionId?: Array<string> | undefined;
    contextKeys?: Array<string> | undefined;
    page?: number | undefined;
    limit?: number | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return ["@novu/api", "Messages", "retrieve", parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useMessagesRetrieve(request: operations.MessagesControllerGetMessagesRequest,
  options?: QueryHookOptions<MessagesRetrieveQueryData>,)
 - useMessagesRetrieveSuspense(request: operations.MessagesControllerGetMessagesRequest,
  options?: SuspenseQueryHookOptions<MessagesRetrieveQueryData>,)
 - prefetchMessagesRetrieve(queryClient: QueryClient,
  client$: NovuCore,
  request: operations.MessagesControllerGetMessagesRequest,)
 - setMessagesRetrieveData(client: QueryClient,
  queryKeyBase: [
    parameters: {
      channel?: components.ChannelTypeEnum | undefined;
      subscriberId?: string | undefined;
      transactionId?: Array<string> | undefined;
      contextKeys?: Array<string> | undefined;
      page?: number | undefined;
      limit?: number | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: MessagesRetrieveQueryData,)
 - invalidateMessagesRetrieve(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      channel?: components.ChannelTypeEnum | undefined;
      subscriberId?: string | undefined;
      transactionId?: Array<string> | undefined;
      contextKeys?: Array<string> | undefined;
      page?: number | undefined;
      limit?: number | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllMessagesRetrieve(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildMessagesRetrieveQuery(client$: NovuCore,
  request: operations.MessagesControllerGetMessagesRequest,
  options?: RequestOptions,)
 - messagesRetrieveQueryFn(ctx,)
 - queryKeyMessagesRetrieve(parameters: {
    channel?: components.ChannelTypeEnum | undefined;
    subscriberId?: string | undefined;
    transactionId?: Array<string> | undefined;
    contextKeys?: Array<string> | undefined;
    page?: number | undefined;
    limit?: number | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyMessagesRetrieve(...queryKeyBase);

  return client.setQueryData<MessagesRetrieveQueryData>(...)
Declaraciones 'export' encontradas:
- export  type
- export function useMessagesRetrieve
- export function useMessagesRetrieveSuspense
- export function prefetchMessagesRetrieve
- export function setMessagesRetrieveData
- export function invalidateMessagesRetrieve
- export function invalidateAllMessagesRetrieve
- export function buildMessagesRetrieveQuery
- export function queryKeyMessagesRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/notificationsList.ts
Tamaño: 6936 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { notificationsList } from "../funcs/notificationsList.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type NotificationsListQueryData =
  operations.NotificationsControllerListNotificationsResponse;

/**
 * List all events
 *
 * @remarks
 * List all notification events (triggered events) for the current environment.
 *     This API supports filtering by **channels**, **templates**, **emails**, **subscriberIds**, **transactionId**, **topicKey**.
 *     Checkout all available filters in the query section.
 *     This API returns event triggers, to list each channel notifications, check messages APIs.
 */
export function useNotificationsList(
  request: operations.NotificationsControllerListNotificationsRequest,
  options?: QueryHookOptions<NotificationsListQueryData>,
): UseQueryResult<NotificationsListQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildNotificationsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

/**
 * List all events
 *
 * @remarks
 * List all notification events (triggered events) for the current environment.
 *     This API supports filtering by **channels**, **templates**, **emails**, **subscriberIds**, **transactionId**, **topicKey**.
 *     Checkout all available filters in the query section.
 *     This API returns event triggers, to list each channel notifications, check messages APIs.
 */
export function useNotificationsListSuspense(
  request: operations.NotificationsControllerListNotificationsRequest,
  options?: SuspenseQueryHookOptions<NotificationsListQueryData>,
): UseSuspenseQueryResult<NotificationsListQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildNotificationsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

export function prefetchNotificationsList(
  queryClient: QueryClient,
  client$: NovuCore,
  request: operations.NotificationsControllerListNotificationsRequest,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildNotificationsListQuery(
      client$,
      request,
    ),
  });
}

export function setNotificationsListData(
  client: QueryClient,
  queryKeyBase: [
    parameters: {
      channels?: Array<components.ChannelTypeEnum> | undefined;
      templates?: Array<string> | undefined;
      emails?: Array<string> | undefined;
      search?: string | undefined;
      subscriberIds?: Array<string> | undefined;
      severity?: Array<string> | undefined;
      page?: number | undefined;
      limit?: number | undefined;
      transactionId?: string | undefined;
      topicKey?: string | undefined;
      contextKeys?: Array<string> | undefined;
      after?: string | undefined;
      before?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: NotificationsListQueryData,
): NotificationsListQueryData | undefined {
  const key = queryKeyNotificationsList(...queryKeyBase);

  return client.setQueryData<NotificationsListQueryData>(key, data);
}

export function invalidateNotificationsList(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      channels?: Array<components.ChannelTypeEnum> | undefined;
      templates?: Array<string> | undefined;
      emails?: Array<string> | undefined;
      search?: string | undefined;
      subscriberIds?: Array<string> | undefined;
      severity?: Array<string> | undefined;
      page?: number | undefined;
      limit?: number | undefined;
      transactionId?: string | undefined;
      topicKey?: string | undefined;
      contextKeys?: Array<string> | undefined;
      after?: string | undefined;
      before?: string | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Notifications", "list", ...queryKeyBase],
  });
}

export function invalidateAllNotificationsList(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Notifications", "list"],
  });
}

export function buildNotificationsListQuery(
  client$: NovuCore,
  request: operations.NotificationsControllerListNotificationsRequest,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<NotificationsListQueryData>;
} {
  return {
    queryKey: queryKeyNotificationsList({
      channels: request.channels,
      templates: request.templates,
      emails: request.emails,
      search: request.search,
      subscriberIds: request.subscriberIds,
      severity: request.severity,
      page: request.page,
      limit: request.limit,
      transactionId: request.transactionId,
      topicKey: request.topicKey,
      contextKeys: request.contextKeys,
      after: request.after,
      before: request.before,
      idempotencyKey: request.idempotencyKey,
    }),
    queryFn: async function notificationsListQueryFn(
      ctx,
    ): Promise<NotificationsListQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(notificationsList(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyNotificationsList(
  parameters: {
    channels?: Array<components.ChannelTypeEnum> | undefined;
    templates?: Array<string> | undefined;
    emails?: Array<string> | undefined;
    search?: string | undefined;
    subscriberIds?: Array<string> | undefined;
    severity?: Array<string> | undefined;
    page?: number | undefined;
    limit?: number | undefined;
    transactionId?: string | undefined;
    topicKey?: string | undefined;
    contextKeys?: Array<string> | undefined;
    after?: string | undefined;
    before?: string | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return ["@novu/api", "Notifications", "list", parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useNotificationsList(request: operations.NotificationsControllerListNotificationsRequest,
  options?: QueryHookOptions<NotificationsListQueryData>,)
 - useNotificationsListSuspense(request: operations.NotificationsControllerListNotificationsRequest,
  options?: SuspenseQueryHookOptions<NotificationsListQueryData>,)
 - prefetchNotificationsList(queryClient: QueryClient,
  client$: NovuCore,
  request: operations.NotificationsControllerListNotificationsRequest,)
 - setNotificationsListData(client: QueryClient,
  queryKeyBase: [
    parameters: {
      channels?: Array<components.ChannelTypeEnum> | undefined;
      templates?: Array<string> | undefined;
      emails?: Array<string> | undefined;
      search?: string | undefined;
      subscriberIds?: Array<string> | undefined;
      severity?: Array<string> | undefined;
      page?: number | undefined;
      limit?: number | undefined;
      transactionId?: string | undefined;
      topicKey?: string | undefined;
      contextKeys?: Array<string> | undefined;
      after?: string | undefined;
      before?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: NotificationsListQueryData,)
 - invalidateNotificationsList(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      channels?: Array<components.ChannelTypeEnum> | undefined;
      templates?: Array<string> | undefined;
      emails?: Array<string> | undefined;
      search?: string | undefined;
      subscriberIds?: Array<string> | undefined;
      severity?: Array<string> | undefined;
      page?: number | undefined;
      limit?: number | undefined;
      transactionId?: string | undefined;
      topicKey?: string | undefined;
      contextKeys?: Array<string> | undefined;
      after?: string | undefined;
      before?: string | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllNotificationsList(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildNotificationsListQuery(client$: NovuCore,
  request: operations.NotificationsControllerListNotificationsRequest,
  options?: RequestOptions,)
 - notificationsListQueryFn(ctx,)
 - queryKeyNotificationsList(parameters: {
    channels?: Array<components.ChannelTypeEnum> | undefined;
    templates?: Array<string> | undefined;
    emails?: Array<string> | undefined;
    search?: string | undefined;
    subscriberIds?: Array<string> | undefined;
    severity?: Array<string> | undefined;
    page?: number | undefined;
    limit?: number | undefined;
    transactionId?: string | undefined;
    topicKey?: string | undefined;
    contextKeys?: Array<string> | undefined;
    after?: string | undefined;
    before?: string | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyNotificationsList(...queryKeyBase);

  return client.setQueryData<NotificationsListQueryData...)
Declaraciones 'export' encontradas:
- export  type
- export function useNotificationsList
- export function useNotificationsListSuspense
- export function prefetchNotificationsList
- export function setNotificationsListData
- export function invalidateNotificationsList
- export function invalidateAllNotificationsList
- export function buildNotificationsListQuery
- export function queryKeyNotificationsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/notificationsRetrieve.ts
Tamaño: 4893 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { notificationsRetrieve } from "../funcs/notificationsRetrieve.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type NotificationsRetrieveQueryData =
  operations.NotificationsControllerGetNotificationResponse;

/**
 * Retrieve an event
 *
 * @remarks
 * Retrieve an event by its unique key identifier **notificationId**.
 *     Here **notificationId** is of mongodbId type.
 *     This API returns the event details - execution logs, status, actual notification (message) generated by each workflow step.
 */
export function useNotificationsRetrieve(
  notificationId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<NotificationsRetrieveQueryData>,
): UseQueryResult<NotificationsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildNotificationsRetrieveQuery(
      client,
      notificationId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * Retrieve an event
 *
 * @remarks
 * Retrieve an event by its unique key identifier **notificationId**.
 *     Here **notificationId** is of mongodbId type.
 *     This API returns the event details - execution logs, status, actual notification (message) generated by each workflow step.
 */
export function useNotificationsRetrieveSuspense(
  notificationId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<NotificationsRetrieveQueryData>,
): UseSuspenseQueryResult<NotificationsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildNotificationsRetrieveQuery(
      client,
      notificationId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchNotificationsRetrieve(
  queryClient: QueryClient,
  client$: NovuCore,
  notificationId: string,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildNotificationsRetrieveQuery(
      client$,
      notificationId,
      idempotencyKey,
    ),
  });
}

export function setNotificationsRetrieveData(
  client: QueryClient,
  queryKeyBase: [
    notificationId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: NotificationsRetrieveQueryData,
): NotificationsRetrieveQueryData | undefined {
  const key = queryKeyNotificationsRetrieve(...queryKeyBase);

  return client.setQueryData<NotificationsRetrieveQueryData>(key, data);
}

export function invalidateNotificationsRetrieve(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      notificationId: string,
      parameters: { idempotencyKey?: string | undefined },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Notifications", "retrieve", ...queryKeyBase],
  });
}

export function invalidateAllNotificationsRetrieve(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Notifications", "retrieve"],
  });
}

export function buildNotificationsRetrieveQuery(
  client$: NovuCore,
  notificationId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<NotificationsRetrieveQueryData>;
} {
  return {
    queryKey: queryKeyNotificationsRetrieve(notificationId, { idempotencyKey }),
    queryFn: async function notificationsRetrieveQueryFn(
      ctx,
    ): Promise<NotificationsRetrieveQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(notificationsRetrieve(
        client$,
        notificationId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyNotificationsRetrieve(
  notificationId: string,
  parameters: { idempotencyKey?: string | undefined },
): QueryKey {
  return ["@novu/api", "Notifications", "retrieve", notificationId, parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useNotificationsRetrieve(notificationId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<NotificationsRetrieveQueryData>,)
 - useNotificationsRetrieveSuspense(notificationId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<NotificationsRetrieveQueryData>,)
 - prefetchNotificationsRetrieve(queryClient: QueryClient,
  client$: NovuCore,
  notificationId: string,
  idempotencyKey?: string | undefined,)
 - setNotificationsRetrieveData(client: QueryClient,
  queryKeyBase: [
    notificationId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: NotificationsRetrieveQueryData,)
 - invalidateNotificationsRetrieve(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      notificationId: string,
      parameters: { idempotencyKey?: string | undefined },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllNotificationsRetrieve(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildNotificationsRetrieveQuery(client$: NovuCore,
  notificationId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - notificationsRetrieveQueryFn(ctx,)
 - queryKeyNotificationsRetrieve(notificationId: string,
  parameters: { idempotencyKey?: string | undefined },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyNotificationsRetrieve(...queryKeyBase);

  return client.setQueryData<NotificationsRetrieveQ...)
Declaraciones 'export' encontradas:
- export  type
- export function useNotificationsRetrieve
- export function useNotificationsRetrieveSuspense
- export function prefetchNotificationsRetrieve
- export function setNotificationsRetrieveData
- export function invalidateNotificationsRetrieve
- export function invalidateAllNotificationsRetrieve
- export function buildNotificationsRetrieveQuery
- export function queryKeyNotificationsRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersCreate.ts
Tamaño: 2769 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersCreate } from "../funcs/subscribersCreate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type SubscribersCreateMutationVariables = {
  createSubscriberRequestDto: components.CreateSubscriberRequestDto;
  failIfExists?: boolean | undefined;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type SubscribersCreateMutationData =
  operations.SubscribersControllerCreateSubscriberResponse;

/**
 * Create a subscriber
 *
 * @remarks
 * Create a subscriber with the subscriber attributes.
 *       **subscriberId** is a required field, rest other fields are optional, if the subscriber already exists, it will be updated
 */
export function useSubscribersCreateMutation(
  options?: MutationHookOptions<
    SubscribersCreateMutationData,
    Error,
    SubscribersCreateMutationVariables
  >,
): UseMutationResult<
  SubscribersCreateMutationData,
  Error,
  SubscribersCreateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildSubscribersCreateMutation(client, options),
    ...options,
  });
}

export function mutationKeySubscribersCreate(): MutationKey {
  return ["@novu/api", "Subscribers", "create"];
}

export function buildSubscribersCreateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: SubscribersCreateMutationVariables,
  ) => Promise<SubscribersCreateMutationData>;
} {
  return {
    mutationKey: mutationKeySubscribersCreate(),
    mutationFn: function subscribersCreateMutationFn({
      createSubscriberRequestDto,
      failIfExists,
      idempotencyKey,
      options,
    }): Promise<SubscribersCreateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(subscribersCreate(
        client$,
        createSubscriberRequestDto,
        failIfExists,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersCreateMutation(options?: MutationHookOptions<
    SubscribersCreateMutationData,
    Error,
    SubscribersCreateMutationVariables
  >,)
 - mutationKeySubscribersCreate()
 - buildSubscribersCreateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - subscribersCreateMutationFn({
      createSubscriberRequestDto,
      failIfExists,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildSubscribersCreateMutation(client, options),
   ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useSubscribersCreateMutation
- export function mutationKeySubscribersCreate
- export function buildSubscribersCreateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersCreateBulk.ts
Tamaño: 2710 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersCreateBulk } from "../funcs/subscribersCreateBulk.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type SubscribersCreateBulkMutationVariables = {
  bulkSubscriberCreateDto: components.BulkSubscriberCreateDto;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type SubscribersCreateBulkMutationData =
  operations.SubscribersV1ControllerBulkCreateSubscribersResponse;

/**
 * Bulk create subscribers
 *
 * @remarks
 *
 *       Using this endpoint multiple subscribers can be created at once. The bulk API is limited to 500 subscribers per request.
 */
export function useSubscribersCreateBulkMutation(
  options?: MutationHookOptions<
    SubscribersCreateBulkMutationData,
    Error,
    SubscribersCreateBulkMutationVariables
  >,
): UseMutationResult<
  SubscribersCreateBulkMutationData,
  Error,
  SubscribersCreateBulkMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildSubscribersCreateBulkMutation(client, options),
    ...options,
  });
}

export function mutationKeySubscribersCreateBulk(): MutationKey {
  return ["@novu/api", "Subscribers", "createBulk"];
}

export function buildSubscribersCreateBulkMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: SubscribersCreateBulkMutationVariables,
  ) => Promise<SubscribersCreateBulkMutationData>;
} {
  return {
    mutationKey: mutationKeySubscribersCreateBulk(),
    mutationFn: function subscribersCreateBulkMutationFn({
      bulkSubscriberCreateDto,
      idempotencyKey,
      options,
    }): Promise<SubscribersCreateBulkMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(subscribersCreateBulk(
        client$,
        bulkSubscriberCreateDto,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersCreateBulkMutation(options?: MutationHookOptions<
    SubscribersCreateBulkMutationData,
    Error,
    SubscribersCreateBulkMutationVariables
  >,)
 - mutationKeySubscribersCreateBulk()
 - buildSubscribersCreateBulkMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - subscribersCreateBulkMutationFn({
      bulkSubscriberCreateDto,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildSubscribersCreateBulkMutation(client, options),...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useSubscribersCreateBulkMutation
- export function mutationKeySubscribersCreateBulk
- export function buildSubscribersCreateBulkMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersCredentialsAppend.ts
Tamaño: 2995 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersCredentialsAppend } from "../funcs/subscribersCredentialsAppend.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type SubscribersCredentialsAppendMutationVariables = {
  updateSubscriberChannelRequestDto:
    components.UpdateSubscriberChannelRequestDto;
  subscriberId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type SubscribersCredentialsAppendMutationData =
  operations.SubscribersV1ControllerModifySubscriberChannelResponse;

/**
 * Update provider credentials
 *
 * @remarks
 * Update credentials for a provider such as **slack** and **FCM**.
 *       **providerId** is required field. This API creates the **deviceTokens** or replaces the existing ones.
 */
export function useSubscribersCredentialsAppendMutation(
  options?: MutationHookOptions<
    SubscribersCredentialsAppendMutationData,
    Error,
    SubscribersCredentialsAppendMutationVariables
  >,
): UseMutationResult<
  SubscribersCredentialsAppendMutationData,
  Error,
  SubscribersCredentialsAppendMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildSubscribersCredentialsAppendMutation(client, options),
    ...options,
  });
}

export function mutationKeySubscribersCredentialsAppend(): MutationKey {
  return ["@novu/api", "Credentials", "append"];
}

export function buildSubscribersCredentialsAppendMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: SubscribersCredentialsAppendMutationVariables,
  ) => Promise<SubscribersCredentialsAppendMutationData>;
} {
  return {
    mutationKey: mutationKeySubscribersCredentialsAppend(),
    mutationFn: function subscribersCredentialsAppendMutationFn({
      updateSubscriberChannelRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    }): Promise<SubscribersCredentialsAppendMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(subscribersCredentialsAppend(
        client$,
        updateSubscriberChannelRequestDto,
        subscriberId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersCredentialsAppendMutation(options?: MutationHookOptions<
    SubscribersCredentialsAppendMutationData,
    Error,
    SubscribersCredentialsAppendMutationVariables
  >,)
 - mutationKeySubscribersCredentialsAppend()
 - buildSubscribersCredentialsAppendMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - subscribersCredentialsAppendMutationFn({
      updateSubscriberChannelRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildSubscribersCredentialsAppendMutation(client, op...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useSubscribersCredentialsAppendMutation
- export function mutationKeySubscribersCredentialsAppend
- export function buildSubscribersCredentialsAppendMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersCredentialsDelete.ts
Tamaño: 2877 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersCredentialsDelete } from "../funcs/subscribersCredentialsDelete.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type SubscribersCredentialsDeleteMutationVariables = {
  subscriberId: string;
  providerId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type SubscribersCredentialsDeleteMutationData =
  | operations.SubscribersV1ControllerDeleteSubscriberCredentialsResponse
  | undefined;

/**
 * Delete provider credentials
 *
 * @remarks
 * Delete subscriber credentials for a provider such as **slack** and **FCM** by **providerId**.
 *     This action is irreversible and will remove the credentials for the provider for particular **subscriberId**.
 */
export function useSubscribersCredentialsDeleteMutation(
  options?: MutationHookOptions<
    SubscribersCredentialsDeleteMutationData,
    Error,
    SubscribersCredentialsDeleteMutationVariables
  >,
): UseMutationResult<
  SubscribersCredentialsDeleteMutationData,
  Error,
  SubscribersCredentialsDeleteMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildSubscribersCredentialsDeleteMutation(client, options),
    ...options,
  });
}

export function mutationKeySubscribersCredentialsDelete(): MutationKey {
  return ["@novu/api", "Credentials", "delete"];
}

export function buildSubscribersCredentialsDeleteMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: SubscribersCredentialsDeleteMutationVariables,
  ) => Promise<SubscribersCredentialsDeleteMutationData>;
} {
  return {
    mutationKey: mutationKeySubscribersCredentialsDelete(),
    mutationFn: function subscribersCredentialsDeleteMutationFn({
      subscriberId,
      providerId,
      idempotencyKey,
      options,
    }): Promise<SubscribersCredentialsDeleteMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(subscribersCredentialsDelete(
        client$,
        subscriberId,
        providerId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersCredentialsDeleteMutation(options?: MutationHookOptions<
    SubscribersCredentialsDeleteMutationData,
    Error,
    SubscribersCredentialsDeleteMutationVariables
  >,)
 - mutationKeySubscribersCredentialsDelete()
 - buildSubscribersCredentialsDeleteMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - subscribersCredentialsDeleteMutationFn({
      subscriberId,
      providerId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildSubscribersCredentialsDeleteMutation(client, op...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useSubscribersCredentialsDeleteMutation
- export function mutationKeySubscribersCredentialsDelete
- export function buildSubscribersCredentialsDeleteMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersCredentialsUpdate.ts
Tamaño: 2993 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersCredentialsUpdate } from "../funcs/subscribersCredentialsUpdate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type SubscribersCredentialsUpdateMutationVariables = {
  updateSubscriberChannelRequestDto:
    components.UpdateSubscriberChannelRequestDto;
  subscriberId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type SubscribersCredentialsUpdateMutationData =
  operations.SubscribersV1ControllerUpdateSubscriberChannelResponse;

/**
 * Upsert provider credentials
 *
 * @remarks
 * Upsert credentials for a provider such as slack and push tokens.
 *       **providerId** is required field. This API creates **deviceTokens** or appends to the existing ones.
 */
export function useSubscribersCredentialsUpdateMutation(
  options?: MutationHookOptions<
    SubscribersCredentialsUpdateMutationData,
    Error,
    SubscribersCredentialsUpdateMutationVariables
  >,
): UseMutationResult<
  SubscribersCredentialsUpdateMutationData,
  Error,
  SubscribersCredentialsUpdateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildSubscribersCredentialsUpdateMutation(client, options),
    ...options,
  });
}

export function mutationKeySubscribersCredentialsUpdate(): MutationKey {
  return ["@novu/api", "Credentials", "update"];
}

export function buildSubscribersCredentialsUpdateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: SubscribersCredentialsUpdateMutationVariables,
  ) => Promise<SubscribersCredentialsUpdateMutationData>;
} {
  return {
    mutationKey: mutationKeySubscribersCredentialsUpdate(),
    mutationFn: function subscribersCredentialsUpdateMutationFn({
      updateSubscriberChannelRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    }): Promise<SubscribersCredentialsUpdateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(subscribersCredentialsUpdate(
        client$,
        updateSubscriberChannelRequestDto,
        subscriberId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersCredentialsUpdateMutation(options?: MutationHookOptions<
    SubscribersCredentialsUpdateMutationData,
    Error,
    SubscribersCredentialsUpdateMutationVariables
  >,)
 - mutationKeySubscribersCredentialsUpdate()
 - buildSubscribersCredentialsUpdateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - subscribersCredentialsUpdateMutationFn({
      updateSubscriberChannelRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildSubscribersCredentialsUpdateMutation(client, op...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useSubscribersCredentialsUpdateMutation
- export function mutationKeySubscribersCredentialsUpdate
- export function buildSubscribersCredentialsUpdateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersDelete.ts
Tamaño: 2539 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersDelete } from "../funcs/subscribersDelete.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type SubscribersDeleteMutationVariables = {
  subscriberId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type SubscribersDeleteMutationData =
  operations.SubscribersControllerRemoveSubscriberResponse;

/**
 * Delete a subscriber
 *
 * @remarks
 * Deletes a subscriber entity from the Novu platform along with associated messages, preferences, and topic subscriptions.
 *       **subscriberId** is a required field.
 */
export function useSubscribersDeleteMutation(
  options?: MutationHookOptions<
    SubscribersDeleteMutationData,
    Error,
    SubscribersDeleteMutationVariables
  >,
): UseMutationResult<
  SubscribersDeleteMutationData,
  Error,
  SubscribersDeleteMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildSubscribersDeleteMutation(client, options),
    ...options,
  });
}

export function mutationKeySubscribersDelete(): MutationKey {
  return ["@novu/api", "Subscribers", "delete"];
}

export function buildSubscribersDeleteMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: SubscribersDeleteMutationVariables,
  ) => Promise<SubscribersDeleteMutationData>;
} {
  return {
    mutationKey: mutationKeySubscribersDelete(),
    mutationFn: function subscribersDeleteMutationFn({
      subscriberId,
      idempotencyKey,
      options,
    }): Promise<SubscribersDeleteMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(subscribersDelete(
        client$,
        subscriberId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersDeleteMutation(options?: MutationHookOptions<
    SubscribersDeleteMutationData,
    Error,
    SubscribersDeleteMutationVariables
  >,)
 - mutationKeySubscribersDelete()
 - buildSubscribersDeleteMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - subscribersDeleteMutationFn({
      subscriberId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildSubscribersDeleteMutation(client, options),
   ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useSubscribersDeleteMutation
- export function mutationKeySubscribersDelete
- export function buildSubscribersDeleteMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersMessagesMarkAll.ts
Tamaño: 2862 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersMessagesMarkAll } from "../funcs/subscribersMessagesMarkAll.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type SubscribersMessagesMarkAllMutationVariables = {
  markAllMessageAsRequestDto: components.MarkAllMessageAsRequestDto;
  subscriberId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type SubscribersMessagesMarkAllMutationData =
  operations.SubscribersV1ControllerMarkAllUnreadAsReadResponse;

/**
 * Update all notifications state
 *
 * @remarks
 * Update all subscriber in-app (inbox) notifications state such as read, unread, seen or unseen by **subscriberId**.
 */
export function useSubscribersMessagesMarkAllMutation(
  options?: MutationHookOptions<
    SubscribersMessagesMarkAllMutationData,
    Error,
    SubscribersMessagesMarkAllMutationVariables
  >,
): UseMutationResult<
  SubscribersMessagesMarkAllMutationData,
  Error,
  SubscribersMessagesMarkAllMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildSubscribersMessagesMarkAllMutation(client, options),
    ...options,
  });
}

export function mutationKeySubscribersMessagesMarkAll(): MutationKey {
  return ["@novu/api", "Messages", "markAll"];
}

export function buildSubscribersMessagesMarkAllMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: SubscribersMessagesMarkAllMutationVariables,
  ) => Promise<SubscribersMessagesMarkAllMutationData>;
} {
  return {
    mutationKey: mutationKeySubscribersMessagesMarkAll(),
    mutationFn: function subscribersMessagesMarkAllMutationFn({
      markAllMessageAsRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    }): Promise<SubscribersMessagesMarkAllMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(subscribersMessagesMarkAll(
        client$,
        markAllMessageAsRequestDto,
        subscriberId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersMessagesMarkAllMutation(options?: MutationHookOptions<
    SubscribersMessagesMarkAllMutationData,
    Error,
    SubscribersMessagesMarkAllMutationVariables
  >,)
 - mutationKeySubscribersMessagesMarkAll()
 - buildSubscribersMessagesMarkAllMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - subscribersMessagesMarkAllMutationFn({
      markAllMessageAsRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildSubscribersMessagesMarkAllMutation(client, opti...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useSubscribersMessagesMarkAllMutation
- export function mutationKeySubscribersMessagesMarkAll
- export function buildSubscribersMessagesMarkAllMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersMessagesMarkAllAs.ts
Tamaño: 2947 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersMessagesMarkAllAs } from "../funcs/subscribersMessagesMarkAllAs.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type SubscribersMessagesMarkAllAsMutationVariables = {
  messageMarkAsRequestDto: components.MessageMarkAsRequestDto;
  subscriberId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type SubscribersMessagesMarkAllAsMutationData =
  operations.SubscribersV1ControllerMarkMessagesAsResponse;

/**
 * Update notifications state
 *
 * @remarks
 * Update subscriber's multiple in-app (inbox) notifications state such as seen, read, unseen or unread by **subscriberId**.
 *       **messageId** is of type mongodbId of notifications
 */
export function useSubscribersMessagesMarkAllAsMutation(
  options?: MutationHookOptions<
    SubscribersMessagesMarkAllAsMutationData,
    Error,
    SubscribersMessagesMarkAllAsMutationVariables
  >,
): UseMutationResult<
  SubscribersMessagesMarkAllAsMutationData,
  Error,
  SubscribersMessagesMarkAllAsMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildSubscribersMessagesMarkAllAsMutation(client, options),
    ...options,
  });
}

export function mutationKeySubscribersMessagesMarkAllAs(): MutationKey {
  return ["@novu/api", "Messages", "markAllAs"];
}

export function buildSubscribersMessagesMarkAllAsMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: SubscribersMessagesMarkAllAsMutationVariables,
  ) => Promise<SubscribersMessagesMarkAllAsMutationData>;
} {
  return {
    mutationKey: mutationKeySubscribersMessagesMarkAllAs(),
    mutationFn: function subscribersMessagesMarkAllAsMutationFn({
      messageMarkAsRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    }): Promise<SubscribersMessagesMarkAllAsMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(subscribersMessagesMarkAllAs(
        client$,
        messageMarkAsRequestDto,
        subscriberId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersMessagesMarkAllAsMutation(options?: MutationHookOptions<
    SubscribersMessagesMarkAllAsMutationData,
    Error,
    SubscribersMessagesMarkAllAsMutationVariables
  >,)
 - mutationKeySubscribersMessagesMarkAllAs()
 - buildSubscribersMessagesMarkAllAsMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - subscribersMessagesMarkAllAsMutationFn({
      messageMarkAsRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildSubscribersMessagesMarkAllAsMutation(client, op...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useSubscribersMessagesMarkAllAsMutation
- export function mutationKeySubscribersMessagesMarkAllAs
- export function buildSubscribersMessagesMarkAllAsMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersMessagesUpdateAsSeen.ts
Tamaño: 2772 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersMessagesUpdateAsSeen } from "../funcs/subscribersMessagesUpdateAsSeen.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type SubscribersMessagesUpdateAsSeenMutationVariables = {
  request: operations.SubscribersV1ControllerMarkActionAsSeenRequest;
  options?: RequestOptions;
};

export type SubscribersMessagesUpdateAsSeenMutationData =
  operations.SubscribersV1ControllerMarkActionAsSeenResponse;

/**
 * Update notification action status
 *
 * @remarks
 * Update in-app (inbox) notification's action status by its unique key identifier **messageId** and type field **type**.
 *       **type** field can be **primary** or **secondary**
 */
export function useSubscribersMessagesUpdateAsSeenMutation(
  options?: MutationHookOptions<
    SubscribersMessagesUpdateAsSeenMutationData,
    Error,
    SubscribersMessagesUpdateAsSeenMutationVariables
  >,
): UseMutationResult<
  SubscribersMessagesUpdateAsSeenMutationData,
  Error,
  SubscribersMessagesUpdateAsSeenMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildSubscribersMessagesUpdateAsSeenMutation(client, options),
    ...options,
  });
}

export function mutationKeySubscribersMessagesUpdateAsSeen(): MutationKey {
  return ["@novu/api", "Messages", "updateAsSeen"];
}

export function buildSubscribersMessagesUpdateAsSeenMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: SubscribersMessagesUpdateAsSeenMutationVariables,
  ) => Promise<SubscribersMessagesUpdateAsSeenMutationData>;
} {
  return {
    mutationKey: mutationKeySubscribersMessagesUpdateAsSeen(),
    mutationFn: function subscribersMessagesUpdateAsSeenMutationFn({
      request,
      options,
    }): Promise<SubscribersMessagesUpdateAsSeenMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(subscribersMessagesUpdateAsSeen(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersMessagesUpdateAsSeenMutation(options?: MutationHookOptions<
    SubscribersMessagesUpdateAsSeenMutationData,
    Error,
    SubscribersMessagesUpdateAsSeenMutationVariables
  >,)
 - mutationKeySubscribersMessagesUpdateAsSeen()
 - buildSubscribersMessagesUpdateAsSeenMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - subscribersMessagesUpdateAsSeenMutationFn({
      request,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildSubscribersMessagesUpdateAsSeenMutation(client,...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useSubscribersMessagesUpdateAsSeenMutation
- export function mutationKeySubscribersMessagesUpdateAsSeen
- export function buildSubscribersMessagesUpdateAsSeenMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersNotificationsFeed.ts
Tamaño: 5432 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersNotificationsFeed } from "../funcs/subscribersNotificationsFeed.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type SubscribersNotificationsFeedQueryData =
  operations.SubscribersV1ControllerGetNotificationsFeedResponse;

/**
 * Retrieve subscriber notifications
 *
 * @remarks
 * Retrieve subscriber in-app (inbox) notifications by its unique key identifier **subscriberId**.
 */
export function useSubscribersNotificationsFeed(
  request: operations.SubscribersV1ControllerGetNotificationsFeedRequest,
  options?: QueryHookOptions<SubscribersNotificationsFeedQueryData>,
): UseQueryResult<SubscribersNotificationsFeedQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildSubscribersNotificationsFeedQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

/**
 * Retrieve subscriber notifications
 *
 * @remarks
 * Retrieve subscriber in-app (inbox) notifications by its unique key identifier **subscriberId**.
 */
export function useSubscribersNotificationsFeedSuspense(
  request: operations.SubscribersV1ControllerGetNotificationsFeedRequest,
  options?: SuspenseQueryHookOptions<SubscribersNotificationsFeedQueryData>,
): UseSuspenseQueryResult<SubscribersNotificationsFeedQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildSubscribersNotificationsFeedQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

export function prefetchSubscribersNotificationsFeed(
  queryClient: QueryClient,
  client$: NovuCore,
  request: operations.SubscribersV1ControllerGetNotificationsFeedRequest,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildSubscribersNotificationsFeedQuery(
      client$,
      request,
    ),
  });
}

export function setSubscribersNotificationsFeedData(
  client: QueryClient,
  queryKeyBase: [
    subscriberId: string,
    parameters: {
      page?: number | undefined;
      limit?: number | undefined;
      read?: boolean | undefined;
      seen?: boolean | undefined;
      payload?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: SubscribersNotificationsFeedQueryData,
): SubscribersNotificationsFeedQueryData | undefined {
  const key = queryKeySubscribersNotificationsFeed(...queryKeyBase);

  return client.setQueryData<SubscribersNotificationsFeedQueryData>(key, data);
}

export function invalidateSubscribersNotificationsFeed(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      subscriberId: string,
      parameters: {
        page?: number | undefined;
        limit?: number | undefined;
        read?: boolean | undefined;
        seen?: boolean | undefined;
        payload?: string | undefined;
        idempotencyKey?: string | undefined;
      },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Notifications", "feed", ...queryKeyBase],
  });
}

export function invalidateAllSubscribersNotificationsFeed(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Notifications", "feed"],
  });
}

export function buildSubscribersNotificationsFeedQuery(
  client$: NovuCore,
  request: operations.SubscribersV1ControllerGetNotificationsFeedRequest,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<SubscribersNotificationsFeedQueryData>;
} {
  return {
    queryKey: queryKeySubscribersNotificationsFeed(request.subscriberId, {
      page: request.page,
      limit: request.limit,
      read: request.read,
      seen: request.seen,
      payload: request.payload,
      idempotencyKey: request.idempotencyKey,
    }),
    queryFn: async function subscribersNotificationsFeedQueryFn(
      ctx,
    ): Promise<SubscribersNotificationsFeedQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(subscribersNotificationsFeed(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}

export function queryKeySubscribersNotificationsFeed(
  subscriberId: string,
  parameters: {
    page?: number | undefined;
    limit?: number | undefined;
    read?: boolean | undefined;
    seen?: boolean | undefined;
    payload?: string | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return ["@novu/api", "Notifications", "feed", subscriberId, parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersNotificationsFeed(request: operations.SubscribersV1ControllerGetNotificationsFeedRequest,
  options?: QueryHookOptions<SubscribersNotificationsFeedQueryData>,)
 - useSubscribersNotificationsFeedSuspense(request: operations.SubscribersV1ControllerGetNotificationsFeedRequest,
  options?: SuspenseQueryHookOptions<SubscribersNotificationsFeedQueryData>,)
 - prefetchSubscribersNotificationsFeed(queryClient: QueryClient,
  client$: NovuCore,
  request: operations.SubscribersV1ControllerGetNotificationsFeedRequest,)
 - setSubscribersNotificationsFeedData(client: QueryClient,
  queryKeyBase: [
    subscriberId: string,
    parameters: {
      page?: number | undefined;
      limit?: number | undefined;
      read?: boolean | undefined;
      seen?: boolean | undefined;
      payload?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: SubscribersNotificationsFeedQueryData,)
 - invalidateSubscribersNotificationsFeed(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      subscriberId: string,
      parameters: {
        page?: number | undefined;
        limit?: number | undefined;
        read?: boolean | undefined;
        seen?: boolean | undefined;
        payload?: string | undefined;
        idempotencyKey?: string | undefined;
      },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllSubscribersNotificationsFeed(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildSubscribersNotificationsFeedQuery(client$: NovuCore,
  request: operations.SubscribersV1ControllerGetNotificationsFeedRequest,
  options?: RequestOptions,)
 - subscribersNotificationsFeedQueryFn(ctx,)
 - queryKeySubscribersNotificationsFeed(subscriberId: string,
  parameters: {
    page?: number | undefined;
    limit?: number | undefined;
    read?: boolean | undefined;
    seen?: boolean | undefined;
    payload?: string | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeySubscribersNotificationsFeed(...queryKeyBase);

  return client.setQueryData<SubscribersNoti...)
Declaraciones 'export' encontradas:
- export  type
- export function useSubscribersNotificationsFeed
- export function useSubscribersNotificationsFeedSuspense
- export function prefetchSubscribersNotificationsFeed
- export function setSubscribersNotificationsFeedData
- export function invalidateSubscribersNotificationsFeed
- export function invalidateAllSubscribersNotificationsFeed
- export function buildSubscribersNotificationsFeedQuery
- export function queryKeySubscribersNotificationsFeed

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersNotificationsUnseenCount.ts
Tamaño: 5334 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersNotificationsUnseenCount } from "../funcs/subscribersNotificationsUnseenCount.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type SubscribersNotificationsUnseenCountQueryData =
  operations.SubscribersV1ControllerGetUnseenCountResponse;

/**
 * Retrieve unseen notifications count
 *
 * @remarks
 * Retrieve unseen in-app (inbox) notifications count for a subscriber by its unique key identifier **subscriberId**.
 */
export function useSubscribersNotificationsUnseenCount(
  request: operations.SubscribersV1ControllerGetUnseenCountRequest,
  options?: QueryHookOptions<SubscribersNotificationsUnseenCountQueryData>,
): UseQueryResult<SubscribersNotificationsUnseenCountQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildSubscribersNotificationsUnseenCountQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

/**
 * Retrieve unseen notifications count
 *
 * @remarks
 * Retrieve unseen in-app (inbox) notifications count for a subscriber by its unique key identifier **subscriberId**.
 */
export function useSubscribersNotificationsUnseenCountSuspense(
  request: operations.SubscribersV1ControllerGetUnseenCountRequest,
  options?: SuspenseQueryHookOptions<
    SubscribersNotificationsUnseenCountQueryData
  >,
): UseSuspenseQueryResult<SubscribersNotificationsUnseenCountQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildSubscribersNotificationsUnseenCountQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

export function prefetchSubscribersNotificationsUnseenCount(
  queryClient: QueryClient,
  client$: NovuCore,
  request: operations.SubscribersV1ControllerGetUnseenCountRequest,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildSubscribersNotificationsUnseenCountQuery(
      client$,
      request,
    ),
  });
}

export function setSubscribersNotificationsUnseenCountData(
  client: QueryClient,
  queryKeyBase: [
    subscriberId: string,
    parameters: {
      seen?: boolean | undefined;
      limit?: number | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: SubscribersNotificationsUnseenCountQueryData,
): SubscribersNotificationsUnseenCountQueryData | undefined {
  const key = queryKeySubscribersNotificationsUnseenCount(...queryKeyBase);

  return client.setQueryData<SubscribersNotificationsUnseenCountQueryData>(
    key,
    data,
  );
}

export function invalidateSubscribersNotificationsUnseenCount(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      subscriberId: string,
      parameters: {
        seen?: boolean | undefined;
        limit?: number | undefined;
        idempotencyKey?: string | undefined;
      },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Notifications", "unseenCount", ...queryKeyBase],
  });
}

export function invalidateAllSubscribersNotificationsUnseenCount(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Notifications", "unseenCount"],
  });
}

export function buildSubscribersNotificationsUnseenCountQuery(
  client$: NovuCore,
  request: operations.SubscribersV1ControllerGetUnseenCountRequest,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<SubscribersNotificationsUnseenCountQueryData>;
} {
  return {
    queryKey: queryKeySubscribersNotificationsUnseenCount(
      request.subscriberId,
      {
        seen: request.seen,
        limit: request.limit,
        idempotencyKey: request.idempotencyKey,
      },
    ),
    queryFn: async function subscribersNotificationsUnseenCountQueryFn(
      ctx,
    ): Promise<SubscribersNotificationsUnseenCountQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(subscribersNotificationsUnseenCount(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}

export function queryKeySubscribersNotificationsUnseenCount(
  subscriberId: string,
  parameters: {
    seen?: boolean | undefined;
    limit?: number | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return [
    "@novu/api",
    "Notifications",
    "unseenCount",
    subscriberId,
    parameters,
  ];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersNotificationsUnseenCount(request: operations.SubscribersV1ControllerGetUnseenCountRequest,
  options?: QueryHookOptions<SubscribersNotificationsUnseenCountQueryData>,)
 - useSubscribersNotificationsUnseenCountSuspense(request: operations.SubscribersV1ControllerGetUnseenCountRequest,
  options?: SuspenseQueryHookOptions<
    SubscribersNotificationsUnseenCountQueryData
  >,)
 - prefetchSubscribersNotificationsUnseenCount(queryClient: QueryClient,
  client$: NovuCore,
  request: operations.SubscribersV1ControllerGetUnseenCountRequest,)
 - setSubscribersNotificationsUnseenCountData(client: QueryClient,
  queryKeyBase: [
    subscriberId: string,
    parameters: {
      seen?: boolean | undefined;
      limit?: number | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: SubscribersNotificationsUnseenCountQueryData,)
 - invalidateSubscribersNotificationsUnseenCount(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      subscriberId: string,
      parameters: {
        seen?: boolean | undefined;
        limit?: number | undefined;
        idempotencyKey?: string | undefined;
      },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllSubscribersNotificationsUnseenCount(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildSubscribersNotificationsUnseenCountQuery(client$: NovuCore,
  request: operations.SubscribersV1ControllerGetUnseenCountRequest,
  options?: RequestOptions,)
 - subscribersNotificationsUnseenCountQueryFn(ctx,)
 - queryKeySubscribersNotificationsUnseenCount(subscriberId: string,
  parameters: {
    seen?: boolean | undefined;
    limit?: number | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeySubscribersNotificationsUnseenCount(...queryKeyBase);

  return client.setQueryData<Subscrib...)
Declaraciones 'export' encontradas:
- export  type
- export function useSubscribersNotificationsUnseenCount
- export function useSubscribersNotificationsUnseenCountSuspense
- export function prefetchSubscribersNotificationsUnseenCount
- export function setSubscribersNotificationsUnseenCountData
- export function invalidateSubscribersNotificationsUnseenCount
- export function invalidateAllSubscribersNotificationsUnseenCount
- export function buildSubscribersNotificationsUnseenCountQuery
- export function queryKeySubscribersNotificationsUnseenCount

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersPatch.ts
Tamaño: 2690 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersPatch } from "../funcs/subscribersPatch.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type SubscribersPatchMutationVariables = {
  patchSubscriberRequestDto: components.PatchSubscriberRequestDto;
  subscriberId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type SubscribersPatchMutationData =
  operations.SubscribersControllerPatchSubscriberResponse;

/**
 * Update a subscriber
 *
 * @remarks
 * Update a subscriber by its unique key identifier **subscriberId**.
 *     **subscriberId** is a required field, rest other fields are optional
 */
export function useSubscribersPatchMutation(
  options?: MutationHookOptions<
    SubscribersPatchMutationData,
    Error,
    SubscribersPatchMutationVariables
  >,
): UseMutationResult<
  SubscribersPatchMutationData,
  Error,
  SubscribersPatchMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildSubscribersPatchMutation(client, options),
    ...options,
  });
}

export function mutationKeySubscribersPatch(): MutationKey {
  return ["@novu/api", "Subscribers", "patch"];
}

export function buildSubscribersPatchMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: SubscribersPatchMutationVariables,
  ) => Promise<SubscribersPatchMutationData>;
} {
  return {
    mutationKey: mutationKeySubscribersPatch(),
    mutationFn: function subscribersPatchMutationFn({
      patchSubscriberRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    }): Promise<SubscribersPatchMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(subscribersPatch(
        client$,
        patchSubscriberRequestDto,
        subscriberId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersPatchMutation(options?: MutationHookOptions<
    SubscribersPatchMutationData,
    Error,
    SubscribersPatchMutationVariables
  >,)
 - mutationKeySubscribersPatch()
 - buildSubscribersPatchMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - subscribersPatchMutationFn({
      patchSubscriberRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildSubscribersPatchMutation(client, options),
    ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useSubscribersPatchMutation
- export function mutationKeySubscribersPatch
- export function buildSubscribersPatchMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersPreferencesBulkUpdate.ts
Tamaño: 3076 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersPreferencesBulkUpdate } from "../funcs/subscribersPreferencesBulkUpdate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type SubscribersPreferencesBulkUpdateMutationVariables = {
  bulkUpdateSubscriberPreferencesDto:
    components.BulkUpdateSubscriberPreferencesDto;
  subscriberId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type SubscribersPreferencesBulkUpdateMutationData =
  operations.SubscribersControllerBulkUpdateSubscriberPreferencesResponse;

/**
 * Bulk update subscriber preferences
 *
 * @remarks
 * Bulk update subscriber preferences by its unique key identifier **subscriberId**.
 *     This API allows updating multiple workflow preferences in a single request.
 */
export function useSubscribersPreferencesBulkUpdateMutation(
  options?: MutationHookOptions<
    SubscribersPreferencesBulkUpdateMutationData,
    Error,
    SubscribersPreferencesBulkUpdateMutationVariables
  >,
): UseMutationResult<
  SubscribersPreferencesBulkUpdateMutationData,
  Error,
  SubscribersPreferencesBulkUpdateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildSubscribersPreferencesBulkUpdateMutation(client, options),
    ...options,
  });
}

export function mutationKeySubscribersPreferencesBulkUpdate(): MutationKey {
  return ["@novu/api", "Preferences", "bulkUpdate"];
}

export function buildSubscribersPreferencesBulkUpdateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: SubscribersPreferencesBulkUpdateMutationVariables,
  ) => Promise<SubscribersPreferencesBulkUpdateMutationData>;
} {
  return {
    mutationKey: mutationKeySubscribersPreferencesBulkUpdate(),
    mutationFn: function subscribersPreferencesBulkUpdateMutationFn({
      bulkUpdateSubscriberPreferencesDto,
      subscriberId,
      idempotencyKey,
      options,
    }): Promise<SubscribersPreferencesBulkUpdateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(subscribersPreferencesBulkUpdate(
        client$,
        bulkUpdateSubscriberPreferencesDto,
        subscriberId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersPreferencesBulkUpdateMutation(options?: MutationHookOptions<
    SubscribersPreferencesBulkUpdateMutationData,
    Error,
    SubscribersPreferencesBulkUpdateMutationVariables
  >,)
 - mutationKeySubscribersPreferencesBulkUpdate()
 - buildSubscribersPreferencesBulkUpdateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - subscribersPreferencesBulkUpdateMutationFn({
      bulkUpdateSubscriberPreferencesDto,
      subscriberId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildSubscribersPreferencesBulkUpdateMutation(client...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useSubscribersPreferencesBulkUpdateMutation
- export function mutationKeySubscribersPreferencesBulkUpdate
- export function buildSubscribersPreferencesBulkUpdateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersPreferencesList.ts
Tamaño: 5400 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersPreferencesList } from "../funcs/subscribersPreferencesList.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type SubscribersPreferencesListQueryData =
  operations.SubscribersControllerGetSubscriberPreferencesResponse;

/**
 * Retrieve subscriber preferences
 *
 * @remarks
 * Retrieve subscriber channel preferences by its unique key identifier **subscriberId**.
 *     This API returns all five channels preferences for all workflows and global preferences.
 */
export function useSubscribersPreferencesList(
  subscriberId: string,
  criticality?: operations.Criticality | undefined,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<SubscribersPreferencesListQueryData>,
): UseQueryResult<SubscribersPreferencesListQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildSubscribersPreferencesListQuery(
      client,
      subscriberId,
      criticality,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * Retrieve subscriber preferences
 *
 * @remarks
 * Retrieve subscriber channel preferences by its unique key identifier **subscriberId**.
 *     This API returns all five channels preferences for all workflows and global preferences.
 */
export function useSubscribersPreferencesListSuspense(
  subscriberId: string,
  criticality?: operations.Criticality | undefined,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<SubscribersPreferencesListQueryData>,
): UseSuspenseQueryResult<SubscribersPreferencesListQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildSubscribersPreferencesListQuery(
      client,
      subscriberId,
      criticality,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchSubscribersPreferencesList(
  queryClient: QueryClient,
  client$: NovuCore,
  subscriberId: string,
  criticality?: operations.Criticality | undefined,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildSubscribersPreferencesListQuery(
      client$,
      subscriberId,
      criticality,
      idempotencyKey,
    ),
  });
}

export function setSubscribersPreferencesListData(
  client: QueryClient,
  queryKeyBase: [
    subscriberId: string,
    parameters: {
      criticality?: operations.Criticality | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: SubscribersPreferencesListQueryData,
): SubscribersPreferencesListQueryData | undefined {
  const key = queryKeySubscribersPreferencesList(...queryKeyBase);

  return client.setQueryData<SubscribersPreferencesListQueryData>(key, data);
}

export function invalidateSubscribersPreferencesList(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      subscriberId: string,
      parameters: {
        criticality?: operations.Criticality | undefined;
        idempotencyKey?: string | undefined;
      },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Preferences", "list", ...queryKeyBase],
  });
}

export function invalidateAllSubscribersPreferencesList(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Preferences", "list"],
  });
}

export function buildSubscribersPreferencesListQuery(
  client$: NovuCore,
  subscriberId: string,
  criticality?: operations.Criticality | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<SubscribersPreferencesListQueryData>;
} {
  return {
    queryKey: queryKeySubscribersPreferencesList(subscriberId, {
      criticality,
      idempotencyKey,
    }),
    queryFn: async function subscribersPreferencesListQueryFn(
      ctx,
    ): Promise<SubscribersPreferencesListQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(subscribersPreferencesList(
        client$,
        subscriberId,
        criticality,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeySubscribersPreferencesList(
  subscriberId: string,
  parameters: {
    criticality?: operations.Criticality | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return ["@novu/api", "Preferences", "list", subscriberId, parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersPreferencesList(subscriberId: string,
  criticality?: operations.Criticality | undefined,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<SubscribersPreferencesListQueryData>,)
 - useSubscribersPreferencesListSuspense(subscriberId: string,
  criticality?: operations.Criticality | undefined,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<SubscribersPreferencesListQueryData>,)
 - prefetchSubscribersPreferencesList(queryClient: QueryClient,
  client$: NovuCore,
  subscriberId: string,
  criticality?: operations.Criticality | undefined,
  idempotencyKey?: string | undefined,)
 - setSubscribersPreferencesListData(client: QueryClient,
  queryKeyBase: [
    subscriberId: string,
    parameters: {
      criticality?: operations.Criticality | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: SubscribersPreferencesListQueryData,)
 - invalidateSubscribersPreferencesList(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      subscriberId: string,
      parameters: {
        criticality?: operations.Criticality | undefined;
        idempotencyKey?: string | undefined;
      },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllSubscribersPreferencesList(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildSubscribersPreferencesListQuery(client$: NovuCore,
  subscriberId: string,
  criticality?: operations.Criticality | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - subscribersPreferencesListQueryFn(ctx,)
 - queryKeySubscribersPreferencesList(subscriberId: string,
  parameters: {
    criticality?: operations.Criticality | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeySubscribersPreferencesList(...queryKeyBase);

  return client.setQueryData<SubscribersPrefer...)
Declaraciones 'export' encontradas:
- export  type
- export function useSubscribersPreferencesList
- export function useSubscribersPreferencesListSuspense
- export function prefetchSubscribersPreferencesList
- export function setSubscribersPreferencesListData
- export function invalidateSubscribersPreferencesList
- export function invalidateAllSubscribersPreferencesList
- export function buildSubscribersPreferencesListQuery
- export function queryKeySubscribersPreferencesList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersPreferencesUpdate.ts
Tamaño: 3031 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersPreferencesUpdate } from "../funcs/subscribersPreferencesUpdate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type SubscribersPreferencesUpdateMutationVariables = {
  patchSubscriberPreferencesDto: components.PatchSubscriberPreferencesDto;
  subscriberId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type SubscribersPreferencesUpdateMutationData =
  operations.SubscribersControllerUpdateSubscriberPreferencesResponse;

/**
 * Update subscriber preferences
 *
 * @remarks
 * Update subscriber preferences by its unique key identifier **subscriberId**.
 *     **workflowId** is optional field, if provided, this API will update that workflow preference,
 *     otherwise it will update global preferences
 */
export function useSubscribersPreferencesUpdateMutation(
  options?: MutationHookOptions<
    SubscribersPreferencesUpdateMutationData,
    Error,
    SubscribersPreferencesUpdateMutationVariables
  >,
): UseMutationResult<
  SubscribersPreferencesUpdateMutationData,
  Error,
  SubscribersPreferencesUpdateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildSubscribersPreferencesUpdateMutation(client, options),
    ...options,
  });
}

export function mutationKeySubscribersPreferencesUpdate(): MutationKey {
  return ["@novu/api", "Preferences", "update"];
}

export function buildSubscribersPreferencesUpdateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: SubscribersPreferencesUpdateMutationVariables,
  ) => Promise<SubscribersPreferencesUpdateMutationData>;
} {
  return {
    mutationKey: mutationKeySubscribersPreferencesUpdate(),
    mutationFn: function subscribersPreferencesUpdateMutationFn({
      patchSubscriberPreferencesDto,
      subscriberId,
      idempotencyKey,
      options,
    }): Promise<SubscribersPreferencesUpdateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(subscribersPreferencesUpdate(
        client$,
        patchSubscriberPreferencesDto,
        subscriberId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersPreferencesUpdateMutation(options?: MutationHookOptions<
    SubscribersPreferencesUpdateMutationData,
    Error,
    SubscribersPreferencesUpdateMutationVariables
  >,)
 - mutationKeySubscribersPreferencesUpdate()
 - buildSubscribersPreferencesUpdateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - subscribersPreferencesUpdateMutationFn({
      patchSubscriberPreferencesDto,
      subscriberId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildSubscribersPreferencesUpdateMutation(client, op...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useSubscribersPreferencesUpdateMutation
- export function mutationKeySubscribersPreferencesUpdate
- export function buildSubscribersPreferencesUpdateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersPropertiesUpdateOnlineFlag.ts
Tamaño: 3090 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersPropertiesUpdateOnlineFlag } from "../funcs/subscribersPropertiesUpdateOnlineFlag.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type SubscribersPropertiesUpdateOnlineFlagMutationVariables = {
  updateSubscriberOnlineFlagRequestDto:
    components.UpdateSubscriberOnlineFlagRequestDto;
  subscriberId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type SubscribersPropertiesUpdateOnlineFlagMutationData =
  operations.SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse;

/**
 * Update subscriber online status
 *
 * @remarks
 * Update the subscriber online status by its unique key identifier **subscriberId**
 */
export function useSubscribersPropertiesUpdateOnlineFlagMutation(
  options?: MutationHookOptions<
    SubscribersPropertiesUpdateOnlineFlagMutationData,
    Error,
    SubscribersPropertiesUpdateOnlineFlagMutationVariables
  >,
): UseMutationResult<
  SubscribersPropertiesUpdateOnlineFlagMutationData,
  Error,
  SubscribersPropertiesUpdateOnlineFlagMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildSubscribersPropertiesUpdateOnlineFlagMutation(client, options),
    ...options,
  });
}

export function mutationKeySubscribersPropertiesUpdateOnlineFlag(): MutationKey {
  return ["@novu/api", "properties", "updateOnlineFlag"];
}

export function buildSubscribersPropertiesUpdateOnlineFlagMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: SubscribersPropertiesUpdateOnlineFlagMutationVariables,
  ) => Promise<SubscribersPropertiesUpdateOnlineFlagMutationData>;
} {
  return {
    mutationKey: mutationKeySubscribersPropertiesUpdateOnlineFlag(),
    mutationFn: function subscribersPropertiesUpdateOnlineFlagMutationFn({
      updateSubscriberOnlineFlagRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    }): Promise<SubscribersPropertiesUpdateOnlineFlagMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(subscribersPropertiesUpdateOnlineFlag(
        client$,
        updateSubscriberOnlineFlagRequestDto,
        subscriberId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersPropertiesUpdateOnlineFlagMutation(options?: MutationHookOptions<
    SubscribersPropertiesUpdateOnlineFlagMutationData,
    Error,
    SubscribersPropertiesUpdateOnlineFlagMutationVariables
  >,)
 - mutationKeySubscribersPropertiesUpdateOnlineFlag()
 - buildSubscribersPropertiesUpdateOnlineFlagMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - subscribersPropertiesUpdateOnlineFlagMutationFn({
      updateSubscriberOnlineFlagRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildSubscribersPropertiesUpdateOnlineFlagMutation(c...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useSubscribersPropertiesUpdateOnlineFlagMutation
- export function mutationKeySubscribersPropertiesUpdateOnlineFlag
- export function buildSubscribersPropertiesUpdateOnlineFlagMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersRetrieve.ts
Tamaño: 4514 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersRetrieve } from "../funcs/subscribersRetrieve.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type SubscribersRetrieveQueryData =
  operations.SubscribersControllerGetSubscriberResponse;

/**
 * Retrieve a subscriber
 *
 * @remarks
 * Retrieve a subscriber by its unique key identifier **subscriberId**.
 *     **subscriberId** field is required.
 */
export function useSubscribersRetrieve(
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<SubscribersRetrieveQueryData>,
): UseQueryResult<SubscribersRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildSubscribersRetrieveQuery(
      client,
      subscriberId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * Retrieve a subscriber
 *
 * @remarks
 * Retrieve a subscriber by its unique key identifier **subscriberId**.
 *     **subscriberId** field is required.
 */
export function useSubscribersRetrieveSuspense(
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<SubscribersRetrieveQueryData>,
): UseSuspenseQueryResult<SubscribersRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildSubscribersRetrieveQuery(
      client,
      subscriberId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchSubscribersRetrieve(
  queryClient: QueryClient,
  client$: NovuCore,
  subscriberId: string,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildSubscribersRetrieveQuery(
      client$,
      subscriberId,
      idempotencyKey,
    ),
  });
}

export function setSubscribersRetrieveData(
  client: QueryClient,
  queryKeyBase: [
    subscriberId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: SubscribersRetrieveQueryData,
): SubscribersRetrieveQueryData | undefined {
  const key = queryKeySubscribersRetrieve(...queryKeyBase);

  return client.setQueryData<SubscribersRetrieveQueryData>(key, data);
}

export function invalidateSubscribersRetrieve(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [subscriberId: string, parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Subscribers", "retrieve", ...queryKeyBase],
  });
}

export function invalidateAllSubscribersRetrieve(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Subscribers", "retrieve"],
  });
}

export function buildSubscribersRetrieveQuery(
  client$: NovuCore,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<SubscribersRetrieveQueryData>;
} {
  return {
    queryKey: queryKeySubscribersRetrieve(subscriberId, { idempotencyKey }),
    queryFn: async function subscribersRetrieveQueryFn(
      ctx,
    ): Promise<SubscribersRetrieveQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(subscribersRetrieve(
        client$,
        subscriberId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeySubscribersRetrieve(
  subscriberId: string,
  parameters: { idempotencyKey?: string | undefined },
): QueryKey {
  return ["@novu/api", "Subscribers", "retrieve", subscriberId, parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersRetrieve(subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<SubscribersRetrieveQueryData>,)
 - useSubscribersRetrieveSuspense(subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<SubscribersRetrieveQueryData>,)
 - prefetchSubscribersRetrieve(queryClient: QueryClient,
  client$: NovuCore,
  subscriberId: string,
  idempotencyKey?: string | undefined,)
 - setSubscribersRetrieveData(client: QueryClient,
  queryKeyBase: [
    subscriberId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: SubscribersRetrieveQueryData,)
 - invalidateSubscribersRetrieve(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [subscriberId: string, parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllSubscribersRetrieve(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildSubscribersRetrieveQuery(client$: NovuCore,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - subscribersRetrieveQueryFn(ctx,)
 - queryKeySubscribersRetrieve(subscriberId: string,
  parameters: { idempotencyKey?: string | undefined },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeySubscribersRetrieve(...queryKeyBase);

  return client.setQueryData<SubscribersRetrieveQuery...)
Declaraciones 'export' encontradas:
- export  type
- export function useSubscribersRetrieve
- export function useSubscribersRetrieveSuspense
- export function prefetchSubscribersRetrieve
- export function setSubscribersRetrieveData
- export function invalidateSubscribersRetrieve
- export function invalidateAllSubscribersRetrieve
- export function buildSubscribersRetrieveQuery
- export function queryKeySubscribersRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersSearch.ts
Tamaño: 5994 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersSearch } from "../funcs/subscribersSearch.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type SubscribersSearchQueryData =
  operations.SubscribersControllerSearchSubscribersResponse;

/**
 * Search subscribers
 *
 * @remarks
 * Search subscribers by their **email**, **phone**, **subscriberId** and **name**.
 *     The search is case sensitive and supports pagination.Checkout all available filters in the query section.
 */
export function useSubscribersSearch(
  request: operations.SubscribersControllerSearchSubscribersRequest,
  options?: QueryHookOptions<SubscribersSearchQueryData>,
): UseQueryResult<SubscribersSearchQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildSubscribersSearchQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

/**
 * Search subscribers
 *
 * @remarks
 * Search subscribers by their **email**, **phone**, **subscriberId** and **name**.
 *     The search is case sensitive and supports pagination.Checkout all available filters in the query section.
 */
export function useSubscribersSearchSuspense(
  request: operations.SubscribersControllerSearchSubscribersRequest,
  options?: SuspenseQueryHookOptions<SubscribersSearchQueryData>,
): UseSuspenseQueryResult<SubscribersSearchQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildSubscribersSearchQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

export function prefetchSubscribersSearch(
  queryClient: QueryClient,
  client$: NovuCore,
  request: operations.SubscribersControllerSearchSubscribersRequest,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildSubscribersSearchQuery(
      client$,
      request,
    ),
  });
}

export function setSubscribersSearchData(
  client: QueryClient,
  queryKeyBase: [
    parameters: {
      after?: string | undefined;
      before?: string | undefined;
      limit?: number | undefined;
      orderDirection?: operations.QueryParamOrderDirection | undefined;
      orderBy?: string | undefined;
      includeCursor?: boolean | undefined;
      email?: string | undefined;
      name?: string | undefined;
      phone?: string | undefined;
      subscriberId?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: SubscribersSearchQueryData,
): SubscribersSearchQueryData | undefined {
  const key = queryKeySubscribersSearch(...queryKeyBase);

  return client.setQueryData<SubscribersSearchQueryData>(key, data);
}

export function invalidateSubscribersSearch(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      after?: string | undefined;
      before?: string | undefined;
      limit?: number | undefined;
      orderDirection?: operations.QueryParamOrderDirection | undefined;
      orderBy?: string | undefined;
      includeCursor?: boolean | undefined;
      email?: string | undefined;
      name?: string | undefined;
      phone?: string | undefined;
      subscriberId?: string | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Subscribers", "search", ...queryKeyBase],
  });
}

export function invalidateAllSubscribersSearch(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Subscribers", "search"],
  });
}

export function buildSubscribersSearchQuery(
  client$: NovuCore,
  request: operations.SubscribersControllerSearchSubscribersRequest,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<SubscribersSearchQueryData>;
} {
  return {
    queryKey: queryKeySubscribersSearch({
      after: request.after,
      before: request.before,
      limit: request.limit,
      orderDirection: request.orderDirection,
      orderBy: request.orderBy,
      includeCursor: request.includeCursor,
      email: request.email,
      name: request.name,
      phone: request.phone,
      subscriberId: request.subscriberId,
      idempotencyKey: request.idempotencyKey,
    }),
    queryFn: async function subscribersSearchQueryFn(
      ctx,
    ): Promise<SubscribersSearchQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(subscribersSearch(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}

export function queryKeySubscribersSearch(
  parameters: {
    after?: string | undefined;
    before?: string | undefined;
    limit?: number | undefined;
    orderDirection?: operations.QueryParamOrderDirection | undefined;
    orderBy?: string | undefined;
    includeCursor?: boolean | undefined;
    email?: string | undefined;
    name?: string | undefined;
    phone?: string | undefined;
    subscriberId?: string | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return ["@novu/api", "Subscribers", "search", parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersSearch(request: operations.SubscribersControllerSearchSubscribersRequest,
  options?: QueryHookOptions<SubscribersSearchQueryData>,)
 - useSubscribersSearchSuspense(request: operations.SubscribersControllerSearchSubscribersRequest,
  options?: SuspenseQueryHookOptions<SubscribersSearchQueryData>,)
 - prefetchSubscribersSearch(queryClient: QueryClient,
  client$: NovuCore,
  request: operations.SubscribersControllerSearchSubscribersRequest,)
 - setSubscribersSearchData(client: QueryClient,
  queryKeyBase: [
    parameters: {
      after?: string | undefined;
      before?: string | undefined;
      limit?: number | undefined;
      orderDirection?: operations.QueryParamOrderDirection | undefined;
      orderBy?: string | undefined;
      includeCursor?: boolean | undefined;
      email?: string | undefined;
      name?: string | undefined;
      phone?: string | undefined;
      subscriberId?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: SubscribersSearchQueryData,)
 - invalidateSubscribersSearch(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      after?: string | undefined;
      before?: string | undefined;
      limit?: number | undefined;
      orderDirection?: operations.QueryParamOrderDirection | undefined;
      orderBy?: string | undefined;
      includeCursor?: boolean | undefined;
      email?: string | undefined;
      name?: string | undefined;
      phone?: string | undefined;
      subscriberId?: string | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllSubscribersSearch(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildSubscribersSearchQuery(client$: NovuCore,
  request: operations.SubscribersControllerSearchSubscribersRequest,
  options?: RequestOptions,)
 - subscribersSearchQueryFn(ctx,)
 - queryKeySubscribersSearch(parameters: {
    after?: string | undefined;
    before?: string | undefined;
    limit?: number | undefined;
    orderDirection?: operations.QueryParamOrderDirection | undefined;
    orderBy?: string | undefined;
    includeCursor?: boolean | undefined;
    email?: string | undefined;
    name?: string | undefined;
    phone?: string | undefined;
    subscriberId?: string | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeySubscribersSearch(...queryKeyBase);

  return client.setQueryData<SubscribersSearchQueryData...)
Declaraciones 'export' encontradas:
- export  type
- export function useSubscribersSearch
- export function useSubscribersSearchSuspense
- export function prefetchSubscribersSearch
- export function setSubscribersSearchData
- export function invalidateSubscribersSearch
- export function invalidateAllSubscribersSearch
- export function buildSubscribersSearchQuery
- export function queryKeySubscribersSearch

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/subscribersTopicsList.ts
Tamaño: 5934 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { subscribersTopicsList } from "../funcs/subscribersTopicsList.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type SubscribersTopicsListQueryData =
  operations.SubscribersControllerListSubscriberTopicsResponse;

/**
 * Retrieve subscriber subscriptions
 *
 * @remarks
 * Retrieve subscriber's topic subscriptions by its unique key identifier **subscriberId**.
 *     Checkout all available filters in the query section.
 */
export function useSubscribersTopicsList(
  request: operations.SubscribersControllerListSubscriberTopicsRequest,
  options?: QueryHookOptions<SubscribersTopicsListQueryData>,
): UseQueryResult<SubscribersTopicsListQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildSubscribersTopicsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

/**
 * Retrieve subscriber subscriptions
 *
 * @remarks
 * Retrieve subscriber's topic subscriptions by its unique key identifier **subscriberId**.
 *     Checkout all available filters in the query section.
 */
export function useSubscribersTopicsListSuspense(
  request: operations.SubscribersControllerListSubscriberTopicsRequest,
  options?: SuspenseQueryHookOptions<SubscribersTopicsListQueryData>,
): UseSuspenseQueryResult<SubscribersTopicsListQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildSubscribersTopicsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

export function prefetchSubscribersTopicsList(
  queryClient: QueryClient,
  client$: NovuCore,
  request: operations.SubscribersControllerListSubscriberTopicsRequest,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildSubscribersTopicsListQuery(
      client$,
      request,
    ),
  });
}

export function setSubscribersTopicsListData(
  client: QueryClient,
  queryKeyBase: [
    subscriberId: string,
    parameters: {
      after?: string | undefined;
      before?: string | undefined;
      limit?: number | undefined;
      orderDirection?:
        | operations.SubscribersControllerListSubscriberTopicsQueryParamOrderDirection
        | undefined;
      orderBy?: string | undefined;
      includeCursor?: boolean | undefined;
      key?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: SubscribersTopicsListQueryData,
): SubscribersTopicsListQueryData | undefined {
  const key = queryKeySubscribersTopicsList(...queryKeyBase);

  return client.setQueryData<SubscribersTopicsListQueryData>(key, data);
}

export function invalidateSubscribersTopicsList(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      subscriberId: string,
      parameters: {
        after?: string | undefined;
        before?: string | undefined;
        limit?: number | undefined;
        orderDirection?:
          | operations.SubscribersControllerListSubscriberTopicsQueryParamOrderDirection
          | undefined;
        orderBy?: string | undefined;
        includeCursor?: boolean | undefined;
        key?: string | undefined;
        idempotencyKey?: string | undefined;
      },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Topics", "list", ...queryKeyBase],
  });
}

export function invalidateAllSubscribersTopicsList(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Topics", "list"],
  });
}

export function buildSubscribersTopicsListQuery(
  client$: NovuCore,
  request: operations.SubscribersControllerListSubscriberTopicsRequest,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<SubscribersTopicsListQueryData>;
} {
  return {
    queryKey: queryKeySubscribersTopicsList(request.subscriberId, {
      after: request.after,
      before: request.before,
      limit: request.limit,
      orderDirection: request.orderDirection,
      orderBy: request.orderBy,
      includeCursor: request.includeCursor,
      key: request.key,
      idempotencyKey: request.idempotencyKey,
    }),
    queryFn: async function subscribersTopicsListQueryFn(
      ctx,
    ): Promise<SubscribersTopicsListQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(subscribersTopicsList(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}

export function queryKeySubscribersTopicsList(
  subscriberId: string,
  parameters: {
    after?: string | undefined;
    before?: string | undefined;
    limit?: number | undefined;
    orderDirection?:
      | operations.SubscribersControllerListSubscriberTopicsQueryParamOrderDirection
      | undefined;
    orderBy?: string | undefined;
    includeCursor?: boolean | undefined;
    key?: string | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return ["@novu/api", "Topics", "list", subscriberId, parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useSubscribersTopicsList(request: operations.SubscribersControllerListSubscriberTopicsRequest,
  options?: QueryHookOptions<SubscribersTopicsListQueryData>,)
 - useSubscribersTopicsListSuspense(request: operations.SubscribersControllerListSubscriberTopicsRequest,
  options?: SuspenseQueryHookOptions<SubscribersTopicsListQueryData>,)
 - prefetchSubscribersTopicsList(queryClient: QueryClient,
  client$: NovuCore,
  request: operations.SubscribersControllerListSubscriberTopicsRequest,)
 - setSubscribersTopicsListData(client: QueryClient,
  queryKeyBase: [
    subscriberId: string,
    parameters: {
      after?: string | undefined;
      before?: string | undefined;
      limit?: number | undefined;
      orderDirection?:
        | operations.SubscribersControllerListSubscriberTopicsQueryParamOrderDirection
        | undefined;
      orderBy?: string | undefined;
      includeCursor?: boolean | undefined;
      key?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: SubscribersTopicsListQueryData,)
 - invalidateSubscribersTopicsList(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      subscriberId: string,
      parameters: {
        after?: string | undefined;
        before?: string | undefined;
        limit?: number | undefined;
        orderDirection?:
          | operations.SubscribersControllerListSubscriberTopicsQueryParamOrderDirection
          | undefined;
        orderBy?: string | undefined;
        includeCursor?: boolean | undefined;
        key?: string | undefined;
        idempotencyKey?: string | undefined;
      },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllSubscribersTopicsList(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildSubscribersTopicsListQuery(client$: NovuCore,
  request: operations.SubscribersControllerListSubscriberTopicsRequest,
  options?: RequestOptions,)
 - subscribersTopicsListQueryFn(ctx,)
 - queryKeySubscribersTopicsList(subscriberId: string,
  parameters: {
    after?: string | undefined;
    before?: string | undefined;
    limit?: number | undefined;
    orderDirection?:
      | operations.SubscribersControllerListSubscriberTopicsQueryParamOrderDirection
      | undefined;
    orderBy?: string | undefined;
    includeCursor?: boolean | undefined;
    key?: string | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeySubscribersTopicsList(...queryKeyBase);

  return client.setQueryData<SubscribersTopicsListQ...)
Declaraciones 'export' encontradas:
- export  type
- export function useSubscribersTopicsList
- export function useSubscribersTopicsListSuspense
- export function prefetchSubscribersTopicsList
- export function setSubscribersTopicsListData
- export function invalidateSubscribersTopicsList
- export function invalidateAllSubscribersTopicsList
- export function buildSubscribersTopicsListQuery
- export function queryKeySubscribersTopicsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/topicsCreate.ts
Tamaño: 2615 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { topicsCreate } from "../funcs/topicsCreate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type TopicsCreateMutationVariables = {
  createUpdateTopicRequestDto: components.CreateUpdateTopicRequestDto;
  failIfExists?: boolean | undefined;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type TopicsCreateMutationData =
  operations.TopicsControllerUpsertTopicResponse;

/**
 * Create a topic
 *
 * @remarks
 * Creates a new topic if it does not exist, or updates an existing topic if it already exists. Use ?failIfExists=true to prevent updates.
 */
export function useTopicsCreateMutation(
  options?: MutationHookOptions<
    TopicsCreateMutationData,
    Error,
    TopicsCreateMutationVariables
  >,
): UseMutationResult<
  TopicsCreateMutationData,
  Error,
  TopicsCreateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildTopicsCreateMutation(client, options),
    ...options,
  });
}

export function mutationKeyTopicsCreate(): MutationKey {
  return ["@novu/api", "Topics", "create"];
}

export function buildTopicsCreateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: TopicsCreateMutationVariables,
  ) => Promise<TopicsCreateMutationData>;
} {
  return {
    mutationKey: mutationKeyTopicsCreate(),
    mutationFn: function topicsCreateMutationFn({
      createUpdateTopicRequestDto,
      failIfExists,
      idempotencyKey,
      options,
    }): Promise<TopicsCreateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(topicsCreate(
        client$,
        createUpdateTopicRequestDto,
        failIfExists,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTopicsCreateMutation(options?: MutationHookOptions<
    TopicsCreateMutationData,
    Error,
    TopicsCreateMutationVariables
  >,)
 - mutationKeyTopicsCreate()
 - buildTopicsCreateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - topicsCreateMutationFn({
      createUpdateTopicRequestDto,
      failIfExists,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildTopicsCreateMutation(client, options),
    ...o...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useTopicsCreateMutation
- export function mutationKeyTopicsCreate
- export function buildTopicsCreateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/topicsDelete.ts
Tamaño: 2390 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { topicsDelete } from "../funcs/topicsDelete.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type TopicsDeleteMutationVariables = {
  topicKey: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type TopicsDeleteMutationData =
  operations.TopicsControllerDeleteTopicResponse;

/**
 * Delete a topic
 *
 * @remarks
 * Delete a topic by its unique key identifier **topicKey**.
 *     This action is irreversible and will remove all subscriptions to the topic.
 */
export function useTopicsDeleteMutation(
  options?: MutationHookOptions<
    TopicsDeleteMutationData,
    Error,
    TopicsDeleteMutationVariables
  >,
): UseMutationResult<
  TopicsDeleteMutationData,
  Error,
  TopicsDeleteMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildTopicsDeleteMutation(client, options),
    ...options,
  });
}

export function mutationKeyTopicsDelete(): MutationKey {
  return ["@novu/api", "Topics", "delete"];
}

export function buildTopicsDeleteMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: TopicsDeleteMutationVariables,
  ) => Promise<TopicsDeleteMutationData>;
} {
  return {
    mutationKey: mutationKeyTopicsDelete(),
    mutationFn: function topicsDeleteMutationFn({
      topicKey,
      idempotencyKey,
      options,
    }): Promise<TopicsDeleteMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(topicsDelete(
        client$,
        topicKey,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTopicsDeleteMutation(options?: MutationHookOptions<
    TopicsDeleteMutationData,
    Error,
    TopicsDeleteMutationVariables
  >,)
 - mutationKeyTopicsDelete()
 - buildTopicsDeleteMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - topicsDeleteMutationFn({
      topicKey,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildTopicsDeleteMutation(client, options),
    ...o...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useTopicsDeleteMutation
- export function mutationKeyTopicsDelete
- export function buildTopicsDeleteMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/topicsGet.ts
Tamaño: 4012 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { topicsGet } from "../funcs/topicsGet.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type TopicsGetQueryData = operations.TopicsControllerGetTopicResponse;

/**
 * Retrieve a topic
 *
 * @remarks
 * Retrieve a topic by its unique key identifier **topicKey**
 */
export function useTopicsGet(
  topicKey: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<TopicsGetQueryData>,
): UseQueryResult<TopicsGetQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildTopicsGetQuery(
      client,
      topicKey,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * Retrieve a topic
 *
 * @remarks
 * Retrieve a topic by its unique key identifier **topicKey**
 */
export function useTopicsGetSuspense(
  topicKey: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<TopicsGetQueryData>,
): UseSuspenseQueryResult<TopicsGetQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildTopicsGetQuery(
      client,
      topicKey,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchTopicsGet(
  queryClient: QueryClient,
  client$: NovuCore,
  topicKey: string,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildTopicsGetQuery(
      client$,
      topicKey,
      idempotencyKey,
    ),
  });
}

export function setTopicsGetData(
  client: QueryClient,
  queryKeyBase: [
    topicKey: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: TopicsGetQueryData,
): TopicsGetQueryData | undefined {
  const key = queryKeyTopicsGet(...queryKeyBase);

  return client.setQueryData<TopicsGetQueryData>(key, data);
}

export function invalidateTopicsGet(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [topicKey: string, parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Topics", "get", ...queryKeyBase],
  });
}

export function invalidateAllTopicsGet(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Topics", "get"],
  });
}

export function buildTopicsGetQuery(
  client$: NovuCore,
  topicKey: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (context: QueryFunctionContext) => Promise<TopicsGetQueryData>;
} {
  return {
    queryKey: queryKeyTopicsGet(topicKey, { idempotencyKey }),
    queryFn: async function topicsGetQueryFn(ctx): Promise<TopicsGetQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(topicsGet(
        client$,
        topicKey,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyTopicsGet(
  topicKey: string,
  parameters: { idempotencyKey?: string | undefined },
): QueryKey {
  return ["@novu/api", "Topics", "get", topicKey, parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTopicsGet(topicKey: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<TopicsGetQueryData>,)
 - useTopicsGetSuspense(topicKey: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<TopicsGetQueryData>,)
 - prefetchTopicsGet(queryClient: QueryClient,
  client$: NovuCore,
  topicKey: string,
  idempotencyKey?: string | undefined,)
 - setTopicsGetData(client: QueryClient,
  queryKeyBase: [
    topicKey: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: TopicsGetQueryData,)
 - invalidateTopicsGet(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [topicKey: string, parameters: { idempotencyKey?: string | undefined }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllTopicsGet(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildTopicsGetQuery(client$: NovuCore,
  topicKey: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - topicsGetQueryFn(ctx)
 - queryKeyTopicsGet(topicKey: string,
  parameters: { idempotencyKey?: string | undefined },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyTopicsGet(...queryKeyBase);

  return client.setQueryData<TopicsGetQueryData>(key, data);
}
...)
Declaraciones 'export' encontradas:
- export  type
- export function useTopicsGet
- export function useTopicsGetSuspense
- export function prefetchTopicsGet
- export function setTopicsGetData
- export function invalidateTopicsGet
- export function invalidateAllTopicsGet
- export function buildTopicsGetQuery
- export function queryKeyTopicsGet

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/topicsList.ts
Tamaño: 5562 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { topicsList } from "../funcs/topicsList.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type TopicsListQueryData = operations.TopicsControllerListTopicsResponse;

/**
 * List all topics
 *
 * @remarks
 * This api returns a paginated list of topics.
 *     Topics can be filtered by **key**, **name**, or **includeCursor** to paginate through the list.
 *     Checkout all available filters in the query section.
 */
export function useTopicsList(
  request: operations.TopicsControllerListTopicsRequest,
  options?: QueryHookOptions<TopicsListQueryData>,
): UseQueryResult<TopicsListQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildTopicsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

/**
 * List all topics
 *
 * @remarks
 * This api returns a paginated list of topics.
 *     Topics can be filtered by **key**, **name**, or **includeCursor** to paginate through the list.
 *     Checkout all available filters in the query section.
 */
export function useTopicsListSuspense(
  request: operations.TopicsControllerListTopicsRequest,
  options?: SuspenseQueryHookOptions<TopicsListQueryData>,
): UseSuspenseQueryResult<TopicsListQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildTopicsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

export function prefetchTopicsList(
  queryClient: QueryClient,
  client$: NovuCore,
  request: operations.TopicsControllerListTopicsRequest,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildTopicsListQuery(
      client$,
      request,
    ),
  });
}

export function setTopicsListData(
  client: QueryClient,
  queryKeyBase: [
    parameters: {
      after?: string | undefined;
      before?: string | undefined;
      limit?: number | undefined;
      orderDirection?:
        | operations.TopicsControllerListTopicsQueryParamOrderDirection
        | undefined;
      orderBy?: string | undefined;
      includeCursor?: boolean | undefined;
      key?: string | undefined;
      name?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: TopicsListQueryData,
): TopicsListQueryData | undefined {
  const key = queryKeyTopicsList(...queryKeyBase);

  return client.setQueryData<TopicsListQueryData>(key, data);
}

export function invalidateTopicsList(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      after?: string | undefined;
      before?: string | undefined;
      limit?: number | undefined;
      orderDirection?:
        | operations.TopicsControllerListTopicsQueryParamOrderDirection
        | undefined;
      orderBy?: string | undefined;
      includeCursor?: boolean | undefined;
      key?: string | undefined;
      name?: string | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Topics", "list", ...queryKeyBase],
  });
}

export function invalidateAllTopicsList(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Topics", "list"],
  });
}

export function buildTopicsListQuery(
  client$: NovuCore,
  request: operations.TopicsControllerListTopicsRequest,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (context: QueryFunctionContext) => Promise<TopicsListQueryData>;
} {
  return {
    queryKey: queryKeyTopicsList({
      after: request.after,
      before: request.before,
      limit: request.limit,
      orderDirection: request.orderDirection,
      orderBy: request.orderBy,
      includeCursor: request.includeCursor,
      key: request.key,
      name: request.name,
      idempotencyKey: request.idempotencyKey,
    }),
    queryFn: async function topicsListQueryFn(
      ctx,
    ): Promise<TopicsListQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(topicsList(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyTopicsList(
  parameters: {
    after?: string | undefined;
    before?: string | undefined;
    limit?: number | undefined;
    orderDirection?:
      | operations.TopicsControllerListTopicsQueryParamOrderDirection
      | undefined;
    orderBy?: string | undefined;
    includeCursor?: boolean | undefined;
    key?: string | undefined;
    name?: string | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return ["@novu/api", "Topics", "list", parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTopicsList(request: operations.TopicsControllerListTopicsRequest,
  options?: QueryHookOptions<TopicsListQueryData>,)
 - useTopicsListSuspense(request: operations.TopicsControllerListTopicsRequest,
  options?: SuspenseQueryHookOptions<TopicsListQueryData>,)
 - prefetchTopicsList(queryClient: QueryClient,
  client$: NovuCore,
  request: operations.TopicsControllerListTopicsRequest,)
 - setTopicsListData(client: QueryClient,
  queryKeyBase: [
    parameters: {
      after?: string | undefined;
      before?: string | undefined;
      limit?: number | undefined;
      orderDirection?:
        | operations.TopicsControllerListTopicsQueryParamOrderDirection
        | undefined;
      orderBy?: string | undefined;
      includeCursor?: boolean | undefined;
      key?: string | undefined;
      name?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: TopicsListQueryData,)
 - invalidateTopicsList(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      after?: string | undefined;
      before?: string | undefined;
      limit?: number | undefined;
      orderDirection?:
        | operations.TopicsControllerListTopicsQueryParamOrderDirection
        | undefined;
      orderBy?: string | undefined;
      includeCursor?: boolean | undefined;
      key?: string | undefined;
      name?: string | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllTopicsList(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildTopicsListQuery(client$: NovuCore,
  request: operations.TopicsControllerListTopicsRequest,
  options?: RequestOptions,)
 - topicsListQueryFn(ctx,)
 - queryKeyTopicsList(parameters: {
    after?: string | undefined;
    before?: string | undefined;
    limit?: number | undefined;
    orderDirection?:
      | operations.TopicsControllerListTopicsQueryParamOrderDirection
      | undefined;
    orderBy?: string | undefined;
    includeCursor?: boolean | undefined;
    key?: string | undefined;
    name?: string | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyTopicsList(...queryKeyBase);

  return client.setQueryData<TopicsListQueryData>(key, data);
...)
Declaraciones 'export' encontradas:
- export  type
- export function useTopicsList
- export function useTopicsListSuspense
- export function prefetchTopicsList
- export function setTopicsListData
- export function invalidateTopicsList
- export function invalidateAllTopicsList
- export function buildTopicsListQuery
- export function queryKeyTopicsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/topicsSubscribersRetrieve.ts
Tamaño: 4963 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { topicsSubscribersRetrieve } from "../funcs/topicsSubscribersRetrieve.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type TopicsSubscribersRetrieveQueryData =
  operations.TopicsV1ControllerGetTopicSubscriberResponse;

/**
 * Check topic subscriber
 *
 * @remarks
 * Check if a subscriber belongs to a certain topic
 */
export function useTopicsSubscribersRetrieve(
  topicKey: string,
  externalSubscriberId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<TopicsSubscribersRetrieveQueryData>,
): UseQueryResult<TopicsSubscribersRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildTopicsSubscribersRetrieveQuery(
      client,
      topicKey,
      externalSubscriberId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * Check topic subscriber
 *
 * @remarks
 * Check if a subscriber belongs to a certain topic
 */
export function useTopicsSubscribersRetrieveSuspense(
  topicKey: string,
  externalSubscriberId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<TopicsSubscribersRetrieveQueryData>,
): UseSuspenseQueryResult<TopicsSubscribersRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildTopicsSubscribersRetrieveQuery(
      client,
      topicKey,
      externalSubscriberId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchTopicsSubscribersRetrieve(
  queryClient: QueryClient,
  client$: NovuCore,
  topicKey: string,
  externalSubscriberId: string,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildTopicsSubscribersRetrieveQuery(
      client$,
      topicKey,
      externalSubscriberId,
      idempotencyKey,
    ),
  });
}

export function setTopicsSubscribersRetrieveData(
  client: QueryClient,
  queryKeyBase: [
    topicKey: string,
    externalSubscriberId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: TopicsSubscribersRetrieveQueryData,
): TopicsSubscribersRetrieveQueryData | undefined {
  const key = queryKeyTopicsSubscribersRetrieve(...queryKeyBase);

  return client.setQueryData<TopicsSubscribersRetrieveQueryData>(key, data);
}

export function invalidateTopicsSubscribersRetrieve(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      topicKey: string,
      externalSubscriberId: string,
      parameters: { idempotencyKey?: string | undefined },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Subscribers", "retrieve", ...queryKeyBase],
  });
}

export function invalidateAllTopicsSubscribersRetrieve(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Subscribers", "retrieve"],
  });
}

export function buildTopicsSubscribersRetrieveQuery(
  client$: NovuCore,
  topicKey: string,
  externalSubscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<TopicsSubscribersRetrieveQueryData>;
} {
  return {
    queryKey: queryKeyTopicsSubscribersRetrieve(
      topicKey,
      externalSubscriberId,
      { idempotencyKey },
    ),
    queryFn: async function topicsSubscribersRetrieveQueryFn(
      ctx,
    ): Promise<TopicsSubscribersRetrieveQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(topicsSubscribersRetrieve(
        client$,
        topicKey,
        externalSubscriberId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyTopicsSubscribersRetrieve(
  topicKey: string,
  externalSubscriberId: string,
  parameters: { idempotencyKey?: string | undefined },
): QueryKey {
  return [
    "@novu/api",
    "Subscribers",
    "retrieve",
    topicKey,
    externalSubscriberId,
    parameters,
  ];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTopicsSubscribersRetrieve(topicKey: string,
  externalSubscriberId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<TopicsSubscribersRetrieveQueryData>,)
 - useTopicsSubscribersRetrieveSuspense(topicKey: string,
  externalSubscriberId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<TopicsSubscribersRetrieveQueryData>,)
 - prefetchTopicsSubscribersRetrieve(queryClient: QueryClient,
  client$: NovuCore,
  topicKey: string,
  externalSubscriberId: string,
  idempotencyKey?: string | undefined,)
 - setTopicsSubscribersRetrieveData(client: QueryClient,
  queryKeyBase: [
    topicKey: string,
    externalSubscriberId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: TopicsSubscribersRetrieveQueryData,)
 - invalidateTopicsSubscribersRetrieve(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      topicKey: string,
      externalSubscriberId: string,
      parameters: { idempotencyKey?: string | undefined },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllTopicsSubscribersRetrieve(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildTopicsSubscribersRetrieveQuery(client$: NovuCore,
  topicKey: string,
  externalSubscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - topicsSubscribersRetrieveQueryFn(ctx,)
 - queryKeyTopicsSubscribersRetrieve(topicKey: string,
  externalSubscriberId: string,
  parameters: { idempotencyKey?: string | undefined },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyTopicsSubscribersRetrieve(...queryKeyBase);

  return client.setQueryData<TopicsSubscribersR...)
Declaraciones 'export' encontradas:
- export  type
- export function useTopicsSubscribersRetrieve
- export function useTopicsSubscribersRetrieveSuspense
- export function prefetchTopicsSubscribersRetrieve
- export function setTopicsSubscribersRetrieveData
- export function invalidateTopicsSubscribersRetrieve
- export function invalidateAllTopicsSubscribersRetrieve
- export function buildTopicsSubscribersRetrieveQuery
- export function queryKeyTopicsSubscribersRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/topicsSubscriptionsCreate.ts
Tamaño: 2919 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { topicsSubscriptionsCreate } from "../funcs/topicsSubscriptionsCreate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type TopicsSubscriptionsCreateMutationVariables = {
  createTopicSubscriptionsRequestDto:
    components.CreateTopicSubscriptionsRequestDto;
  topicKey: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type TopicsSubscriptionsCreateMutationData =
  operations.TopicsControllerCreateTopicSubscriptionsResponse;

/**
 * Create topic subscriptions
 *
 * @remarks
 * This api will create subscription for subscriberIds for a topic.
 *       Its like subscribing to a common interest group. if topic does not exist, it will be created.
 */
export function useTopicsSubscriptionsCreateMutation(
  options?: MutationHookOptions<
    TopicsSubscriptionsCreateMutationData,
    Error,
    TopicsSubscriptionsCreateMutationVariables
  >,
): UseMutationResult<
  TopicsSubscriptionsCreateMutationData,
  Error,
  TopicsSubscriptionsCreateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildTopicsSubscriptionsCreateMutation(client, options),
    ...options,
  });
}

export function mutationKeyTopicsSubscriptionsCreate(): MutationKey {
  return ["@novu/api", "Subscriptions", "create"];
}

export function buildTopicsSubscriptionsCreateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: TopicsSubscriptionsCreateMutationVariables,
  ) => Promise<TopicsSubscriptionsCreateMutationData>;
} {
  return {
    mutationKey: mutationKeyTopicsSubscriptionsCreate(),
    mutationFn: function topicsSubscriptionsCreateMutationFn({
      createTopicSubscriptionsRequestDto,
      topicKey,
      idempotencyKey,
      options,
    }): Promise<TopicsSubscriptionsCreateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(topicsSubscriptionsCreate(
        client$,
        createTopicSubscriptionsRequestDto,
        topicKey,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTopicsSubscriptionsCreateMutation(options?: MutationHookOptions<
    TopicsSubscriptionsCreateMutationData,
    Error,
    TopicsSubscriptionsCreateMutationVariables
  >,)
 - mutationKeyTopicsSubscriptionsCreate()
 - buildTopicsSubscriptionsCreateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - topicsSubscriptionsCreateMutationFn({
      createTopicSubscriptionsRequestDto,
      topicKey,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildTopicsSubscriptionsCreateMutation(client, optio...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useTopicsSubscriptionsCreateMutation
- export function mutationKeyTopicsSubscriptionsCreate
- export function buildTopicsSubscriptionsCreateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/topicsSubscriptionsDelete.ts
Tamaño: 2803 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { topicsSubscriptionsDelete } from "../funcs/topicsSubscriptionsDelete.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type TopicsSubscriptionsDeleteMutationVariables = {
  deleteTopicSubscriptionsRequestDto:
    components.DeleteTopicSubscriptionsRequestDto;
  topicKey: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type TopicsSubscriptionsDeleteMutationData =
  operations.TopicsControllerDeleteTopicSubscriptionsResponse;

/**
 * Delete topic subscriptions
 *
 * @remarks
 * Delete subscriptions for subscriberIds for a topic.
 */
export function useTopicsSubscriptionsDeleteMutation(
  options?: MutationHookOptions<
    TopicsSubscriptionsDeleteMutationData,
    Error,
    TopicsSubscriptionsDeleteMutationVariables
  >,
): UseMutationResult<
  TopicsSubscriptionsDeleteMutationData,
  Error,
  TopicsSubscriptionsDeleteMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildTopicsSubscriptionsDeleteMutation(client, options),
    ...options,
  });
}

export function mutationKeyTopicsSubscriptionsDelete(): MutationKey {
  return ["@novu/api", "Subscriptions", "delete"];
}

export function buildTopicsSubscriptionsDeleteMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: TopicsSubscriptionsDeleteMutationVariables,
  ) => Promise<TopicsSubscriptionsDeleteMutationData>;
} {
  return {
    mutationKey: mutationKeyTopicsSubscriptionsDelete(),
    mutationFn: function topicsSubscriptionsDeleteMutationFn({
      deleteTopicSubscriptionsRequestDto,
      topicKey,
      idempotencyKey,
      options,
    }): Promise<TopicsSubscriptionsDeleteMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(topicsSubscriptionsDelete(
        client$,
        deleteTopicSubscriptionsRequestDto,
        topicKey,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTopicsSubscriptionsDeleteMutation(options?: MutationHookOptions<
    TopicsSubscriptionsDeleteMutationData,
    Error,
    TopicsSubscriptionsDeleteMutationVariables
  >,)
 - mutationKeyTopicsSubscriptionsDelete()
 - buildTopicsSubscriptionsDeleteMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - topicsSubscriptionsDeleteMutationFn({
      deleteTopicSubscriptionsRequestDto,
      topicKey,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildTopicsSubscriptionsDeleteMutation(client, optio...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useTopicsSubscriptionsDeleteMutation
- export function mutationKeyTopicsSubscriptionsDelete
- export function buildTopicsSubscriptionsDeleteMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/topicsSubscriptionsList.ts
Tamaño: 5916 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { topicsSubscriptionsList } from "../funcs/topicsSubscriptionsList.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type TopicsSubscriptionsListQueryData =
  operations.TopicsControllerListTopicSubscriptionsResponse;

/**
 * List topic subscriptions
 *
 * @remarks
 * List all subscriptions of subscribers for a topic.
 *     Checkout all available filters in the query section.
 */
export function useTopicsSubscriptionsList(
  request: operations.TopicsControllerListTopicSubscriptionsRequest,
  options?: QueryHookOptions<TopicsSubscriptionsListQueryData>,
): UseQueryResult<TopicsSubscriptionsListQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildTopicsSubscriptionsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

/**
 * List topic subscriptions
 *
 * @remarks
 * List all subscriptions of subscribers for a topic.
 *     Checkout all available filters in the query section.
 */
export function useTopicsSubscriptionsListSuspense(
  request: operations.TopicsControllerListTopicSubscriptionsRequest,
  options?: SuspenseQueryHookOptions<TopicsSubscriptionsListQueryData>,
): UseSuspenseQueryResult<TopicsSubscriptionsListQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildTopicsSubscriptionsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

export function prefetchTopicsSubscriptionsList(
  queryClient: QueryClient,
  client$: NovuCore,
  request: operations.TopicsControllerListTopicSubscriptionsRequest,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildTopicsSubscriptionsListQuery(
      client$,
      request,
    ),
  });
}

export function setTopicsSubscriptionsListData(
  client: QueryClient,
  queryKeyBase: [
    topicKey: string,
    parameters: {
      after?: string | undefined;
      before?: string | undefined;
      limit?: number | undefined;
      orderDirection?:
        | operations.TopicsControllerListTopicSubscriptionsQueryParamOrderDirection
        | undefined;
      orderBy?: string | undefined;
      includeCursor?: boolean | undefined;
      subscriberId?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: TopicsSubscriptionsListQueryData,
): TopicsSubscriptionsListQueryData | undefined {
  const key = queryKeyTopicsSubscriptionsList(...queryKeyBase);

  return client.setQueryData<TopicsSubscriptionsListQueryData>(key, data);
}

export function invalidateTopicsSubscriptionsList(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      topicKey: string,
      parameters: {
        after?: string | undefined;
        before?: string | undefined;
        limit?: number | undefined;
        orderDirection?:
          | operations.TopicsControllerListTopicSubscriptionsQueryParamOrderDirection
          | undefined;
        orderBy?: string | undefined;
        includeCursor?: boolean | undefined;
        subscriberId?: string | undefined;
        idempotencyKey?: string | undefined;
      },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Subscriptions", "list", ...queryKeyBase],
  });
}

export function invalidateAllTopicsSubscriptionsList(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Subscriptions", "list"],
  });
}

export function buildTopicsSubscriptionsListQuery(
  client$: NovuCore,
  request: operations.TopicsControllerListTopicSubscriptionsRequest,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<TopicsSubscriptionsListQueryData>;
} {
  return {
    queryKey: queryKeyTopicsSubscriptionsList(request.topicKey, {
      after: request.after,
      before: request.before,
      limit: request.limit,
      orderDirection: request.orderDirection,
      orderBy: request.orderBy,
      includeCursor: request.includeCursor,
      subscriberId: request.subscriberId,
      idempotencyKey: request.idempotencyKey,
    }),
    queryFn: async function topicsSubscriptionsListQueryFn(
      ctx,
    ): Promise<TopicsSubscriptionsListQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(topicsSubscriptionsList(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyTopicsSubscriptionsList(
  topicKey: string,
  parameters: {
    after?: string | undefined;
    before?: string | undefined;
    limit?: number | undefined;
    orderDirection?:
      | operations.TopicsControllerListTopicSubscriptionsQueryParamOrderDirection
      | undefined;
    orderBy?: string | undefined;
    includeCursor?: boolean | undefined;
    subscriberId?: string | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return ["@novu/api", "Subscriptions", "list", topicKey, parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTopicsSubscriptionsList(request: operations.TopicsControllerListTopicSubscriptionsRequest,
  options?: QueryHookOptions<TopicsSubscriptionsListQueryData>,)
 - useTopicsSubscriptionsListSuspense(request: operations.TopicsControllerListTopicSubscriptionsRequest,
  options?: SuspenseQueryHookOptions<TopicsSubscriptionsListQueryData>,)
 - prefetchTopicsSubscriptionsList(queryClient: QueryClient,
  client$: NovuCore,
  request: operations.TopicsControllerListTopicSubscriptionsRequest,)
 - setTopicsSubscriptionsListData(client: QueryClient,
  queryKeyBase: [
    topicKey: string,
    parameters: {
      after?: string | undefined;
      before?: string | undefined;
      limit?: number | undefined;
      orderDirection?:
        | operations.TopicsControllerListTopicSubscriptionsQueryParamOrderDirection
        | undefined;
      orderBy?: string | undefined;
      includeCursor?: boolean | undefined;
      subscriberId?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: TopicsSubscriptionsListQueryData,)
 - invalidateTopicsSubscriptionsList(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      topicKey: string,
      parameters: {
        after?: string | undefined;
        before?: string | undefined;
        limit?: number | undefined;
        orderDirection?:
          | operations.TopicsControllerListTopicSubscriptionsQueryParamOrderDirection
          | undefined;
        orderBy?: string | undefined;
        includeCursor?: boolean | undefined;
        subscriberId?: string | undefined;
        idempotencyKey?: string | undefined;
      },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllTopicsSubscriptionsList(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildTopicsSubscriptionsListQuery(client$: NovuCore,
  request: operations.TopicsControllerListTopicSubscriptionsRequest,
  options?: RequestOptions,)
 - topicsSubscriptionsListQueryFn(ctx,)
 - queryKeyTopicsSubscriptionsList(topicKey: string,
  parameters: {
    after?: string | undefined;
    before?: string | undefined;
    limit?: number | undefined;
    orderDirection?:
      | operations.TopicsControllerListTopicSubscriptionsQueryParamOrderDirection
      | undefined;
    orderBy?: string | undefined;
    includeCursor?: boolean | undefined;
    subscriberId?: string | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyTopicsSubscriptionsList(...queryKeyBase);

  return client.setQueryData<TopicsSubscriptionsL...)
Declaraciones 'export' encontradas:
- export  type
- export function useTopicsSubscriptionsList
- export function useTopicsSubscriptionsListSuspense
- export function prefetchTopicsSubscriptionsList
- export function setTopicsSubscriptionsListData
- export function invalidateTopicsSubscriptionsList
- export function invalidateAllTopicsSubscriptionsList
- export function buildTopicsSubscriptionsListQuery
- export function queryKeyTopicsSubscriptionsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/topicsUpdate.ts
Tamaño: 2491 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { topicsUpdate } from "../funcs/topicsUpdate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type TopicsUpdateMutationVariables = {
  updateTopicRequestDto: components.UpdateTopicRequestDto;
  topicKey: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type TopicsUpdateMutationData =
  operations.TopicsControllerUpdateTopicResponse;

/**
 * Update a topic
 *
 * @remarks
 * Update a topic name by its unique key identifier **topicKey**
 */
export function useTopicsUpdateMutation(
  options?: MutationHookOptions<
    TopicsUpdateMutationData,
    Error,
    TopicsUpdateMutationVariables
  >,
): UseMutationResult<
  TopicsUpdateMutationData,
  Error,
  TopicsUpdateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildTopicsUpdateMutation(client, options),
    ...options,
  });
}

export function mutationKeyTopicsUpdate(): MutationKey {
  return ["@novu/api", "Topics", "update"];
}

export function buildTopicsUpdateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: TopicsUpdateMutationVariables,
  ) => Promise<TopicsUpdateMutationData>;
} {
  return {
    mutationKey: mutationKeyTopicsUpdate(),
    mutationFn: function topicsUpdateMutationFn({
      updateTopicRequestDto,
      topicKey,
      idempotencyKey,
      options,
    }): Promise<TopicsUpdateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(topicsUpdate(
        client$,
        updateTopicRequestDto,
        topicKey,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTopicsUpdateMutation(options?: MutationHookOptions<
    TopicsUpdateMutationData,
    Error,
    TopicsUpdateMutationVariables
  >,)
 - mutationKeyTopicsUpdate()
 - buildTopicsUpdateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - topicsUpdateMutationFn({
      updateTopicRequestDto,
      topicKey,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildTopicsUpdateMutation(client, options),
    ...o...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useTopicsUpdateMutation
- export function mutationKeyTopicsUpdate
- export function buildTopicsUpdateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/translationsCreate.ts
Tamaño: 2554 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { translationsCreate } from "../funcs/translationsCreate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type TranslationsCreateMutationVariables = {
  createTranslationRequestDto: components.CreateTranslationRequestDto;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type TranslationsCreateMutationData = components.TranslationResponseDto;

/**
 * Create a translation
 *
 * @remarks
 * Create a translation for a specific workflow and locale, if the translation already exists, it will be updated
 */
export function useTranslationsCreateMutation(
  options?: MutationHookOptions<
    TranslationsCreateMutationData,
    Error,
    TranslationsCreateMutationVariables
  >,
): UseMutationResult<
  TranslationsCreateMutationData,
  Error,
  TranslationsCreateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildTranslationsCreateMutation(client, options),
    ...options,
  });
}

export function mutationKeyTranslationsCreate(): MutationKey {
  return ["@novu/api", "Translations", "create"];
}

export function buildTranslationsCreateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: TranslationsCreateMutationVariables,
  ) => Promise<TranslationsCreateMutationData>;
} {
  return {
    mutationKey: mutationKeyTranslationsCreate(),
    mutationFn: function translationsCreateMutationFn({
      createTranslationRequestDto,
      idempotencyKey,
      options,
    }): Promise<TranslationsCreateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(translationsCreate(
        client$,
        createTranslationRequestDto,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTranslationsCreateMutation(options?: MutationHookOptions<
    TranslationsCreateMutationData,
    Error,
    TranslationsCreateMutationVariables
  >,)
 - mutationKeyTranslationsCreate()
 - buildTranslationsCreateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - translationsCreateMutationFn({
      createTranslationRequestDto,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildTranslationsCreateMutation(client, options),
  ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useTranslationsCreateMutation
- export function mutationKeyTranslationsCreate
- export function buildTranslationsCreateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/translationsDelete.ts
Tamaño: 2366 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { translationsDelete } from "../funcs/translationsDelete.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type TranslationsDeleteMutationVariables = {
  request: operations.TranslationControllerDeleteTranslationEndpointRequest;
  options?: RequestOptions;
};

export type TranslationsDeleteMutationData = void;

/**
 * Delete a translation
 *
 * @remarks
 * Delete a specific translation by resource type, resource ID and locale
 */
export function useTranslationsDeleteMutation(
  options?: MutationHookOptions<
    TranslationsDeleteMutationData,
    Error,
    TranslationsDeleteMutationVariables
  >,
): UseMutationResult<
  TranslationsDeleteMutationData,
  Error,
  TranslationsDeleteMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildTranslationsDeleteMutation(client, options),
    ...options,
  });
}

export function mutationKeyTranslationsDelete(): MutationKey {
  return ["@novu/api", "Translations", "delete"];
}

export function buildTranslationsDeleteMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: TranslationsDeleteMutationVariables,
  ) => Promise<TranslationsDeleteMutationData>;
} {
  return {
    mutationKey: mutationKeyTranslationsDelete(),
    mutationFn: function translationsDeleteMutationFn({
      request,
      options,
    }): Promise<TranslationsDeleteMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(translationsDelete(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTranslationsDeleteMutation(options?: MutationHookOptions<
    TranslationsDeleteMutationData,
    Error,
    TranslationsDeleteMutationVariables
  >,)
 - mutationKeyTranslationsDelete()
 - buildTranslationsDeleteMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - translationsDeleteMutationFn({
      request,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildTranslationsDeleteMutation(client, options),
  ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useTranslationsDeleteMutation
- export function mutationKeyTranslationsDelete
- export function buildTranslationsDeleteMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/translationsGroupsDelete.ts
Tamaño: 2582 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { translationsGroupsDelete } from "../funcs/translationsGroupsDelete.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type TranslationsGroupsDeleteMutationVariables = {
  resourceType: operations.ResourceType;
  resourceId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type TranslationsGroupsDeleteMutationData = void;

/**
 * Delete a translation group
 *
 * @remarks
 * Delete an entire translation group and all its translations
 */
export function useTranslationsGroupsDeleteMutation(
  options?: MutationHookOptions<
    TranslationsGroupsDeleteMutationData,
    Error,
    TranslationsGroupsDeleteMutationVariables
  >,
): UseMutationResult<
  TranslationsGroupsDeleteMutationData,
  Error,
  TranslationsGroupsDeleteMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildTranslationsGroupsDeleteMutation(client, options),
    ...options,
  });
}

export function mutationKeyTranslationsGroupsDelete(): MutationKey {
  return ["@novu/api", "Groups", "delete"];
}

export function buildTranslationsGroupsDeleteMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: TranslationsGroupsDeleteMutationVariables,
  ) => Promise<TranslationsGroupsDeleteMutationData>;
} {
  return {
    mutationKey: mutationKeyTranslationsGroupsDelete(),
    mutationFn: function translationsGroupsDeleteMutationFn({
      resourceType,
      resourceId,
      idempotencyKey,
      options,
    }): Promise<TranslationsGroupsDeleteMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(translationsGroupsDelete(
        client$,
        resourceType,
        resourceId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTranslationsGroupsDeleteMutation(options?: MutationHookOptions<
    TranslationsGroupsDeleteMutationData,
    Error,
    TranslationsGroupsDeleteMutationVariables
  >,)
 - mutationKeyTranslationsGroupsDelete()
 - buildTranslationsGroupsDeleteMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - translationsGroupsDeleteMutationFn({
      resourceType,
      resourceId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildTranslationsGroupsDeleteMutation(client, option...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useTranslationsGroupsDeleteMutation
- export function mutationKeyTranslationsGroupsDelete
- export function buildTranslationsGroupsDeleteMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/translationsGroupsRetrieve.ts
Tamaño: 5609 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { translationsGroupsRetrieve } from "../funcs/translationsGroupsRetrieve.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type TranslationsGroupsRetrieveQueryData =
  components.TranslationGroupDto;

/**
 * Retrieve a translation group
 *
 * @remarks
 * Retrieves a single translation group by resource type (workflow, layout) and resource ID (workflowId, layoutId)
 */
export function useTranslationsGroupsRetrieve(
  resourceType:
    operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
  resourceId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<TranslationsGroupsRetrieveQueryData>,
): UseQueryResult<TranslationsGroupsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildTranslationsGroupsRetrieveQuery(
      client,
      resourceType,
      resourceId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * Retrieve a translation group
 *
 * @remarks
 * Retrieves a single translation group by resource type (workflow, layout) and resource ID (workflowId, layoutId)
 */
export function useTranslationsGroupsRetrieveSuspense(
  resourceType:
    operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
  resourceId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<TranslationsGroupsRetrieveQueryData>,
): UseSuspenseQueryResult<TranslationsGroupsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildTranslationsGroupsRetrieveQuery(
      client,
      resourceType,
      resourceId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchTranslationsGroupsRetrieve(
  queryClient: QueryClient,
  client$: NovuCore,
  resourceType:
    operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
  resourceId: string,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildTranslationsGroupsRetrieveQuery(
      client$,
      resourceType,
      resourceId,
      idempotencyKey,
    ),
  });
}

export function setTranslationsGroupsRetrieveData(
  client: QueryClient,
  queryKeyBase: [
    resourceType:
      operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
    resourceId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: TranslationsGroupsRetrieveQueryData,
): TranslationsGroupsRetrieveQueryData | undefined {
  const key = queryKeyTranslationsGroupsRetrieve(...queryKeyBase);

  return client.setQueryData<TranslationsGroupsRetrieveQueryData>(key, data);
}

export function invalidateTranslationsGroupsRetrieve(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      resourceType:
        operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
      resourceId: string,
      parameters: { idempotencyKey?: string | undefined },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Groups", "retrieve", ...queryKeyBase],
  });
}

export function invalidateAllTranslationsGroupsRetrieve(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Groups", "retrieve"],
  });
}

export function buildTranslationsGroupsRetrieveQuery(
  client$: NovuCore,
  resourceType:
    operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
  resourceId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<TranslationsGroupsRetrieveQueryData>;
} {
  return {
    queryKey: queryKeyTranslationsGroupsRetrieve(resourceType, resourceId, {
      idempotencyKey,
    }),
    queryFn: async function translationsGroupsRetrieveQueryFn(
      ctx,
    ): Promise<TranslationsGroupsRetrieveQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(translationsGroupsRetrieve(
        client$,
        resourceType,
        resourceId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyTranslationsGroupsRetrieve(
  resourceType:
    operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
  resourceId: string,
  parameters: { idempotencyKey?: string | undefined },
): QueryKey {
  return [
    "@novu/api",
    "Groups",
    "retrieve",
    resourceType,
    resourceId,
    parameters,
  ];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTranslationsGroupsRetrieve(resourceType:
    operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
  resourceId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<TranslationsGroupsRetrieveQueryData>,)
 - useTranslationsGroupsRetrieveSuspense(resourceType:
    operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
  resourceId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<TranslationsGroupsRetrieveQueryData>,)
 - prefetchTranslationsGroupsRetrieve(queryClient: QueryClient,
  client$: NovuCore,
  resourceType:
    operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
  resourceId: string,
  idempotencyKey?: string | undefined,)
 - setTranslationsGroupsRetrieveData(client: QueryClient,
  queryKeyBase: [
    resourceType:
      operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
    resourceId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: TranslationsGroupsRetrieveQueryData,)
 - invalidateTranslationsGroupsRetrieve(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      resourceType:
        operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
      resourceId: string,
      parameters: { idempotencyKey?: string | undefined },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllTranslationsGroupsRetrieve(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildTranslationsGroupsRetrieveQuery(client$: NovuCore,
  resourceType:
    operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
  resourceId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - translationsGroupsRetrieveQueryFn(ctx,)
 - queryKeyTranslationsGroupsRetrieve(resourceType:
    operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
  resourceId: string,
  parameters: { idempotencyKey?: string | undefined },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyTranslationsGroupsRetrieve(...queryKeyBase);

  return client.setQueryData<TranslationsGroup...)
Declaraciones 'export' encontradas:
- export  type
- export function useTranslationsGroupsRetrieve
- export function useTranslationsGroupsRetrieveSuspense
- export function prefetchTranslationsGroupsRetrieve
- export function setTranslationsGroupsRetrieveData
- export function invalidateTranslationsGroupsRetrieve
- export function invalidateAllTranslationsGroupsRetrieve
- export function buildTranslationsGroupsRetrieveQuery
- export function queryKeyTranslationsGroupsRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/translationsMasterImport.ts
Tamaño: 2648 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { translationsMasterImport } from "../funcs/translationsMasterImport.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type TranslationsMasterImportMutationVariables = {
  importMasterJsonRequestDto: components.ImportMasterJsonRequestDto;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type TranslationsMasterImportMutationData =
  components.ImportMasterJsonResponseDto;

/**
 * Import master translations JSON
 *
 * @remarks
 * Import translations for multiple workflows from master JSON format for a specific locale
 */
export function useTranslationsMasterImportMutation(
  options?: MutationHookOptions<
    TranslationsMasterImportMutationData,
    Error,
    TranslationsMasterImportMutationVariables
  >,
): UseMutationResult<
  TranslationsMasterImportMutationData,
  Error,
  TranslationsMasterImportMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildTranslationsMasterImportMutation(client, options),
    ...options,
  });
}

export function mutationKeyTranslationsMasterImport(): MutationKey {
  return ["@novu/api", "master", "import"];
}

export function buildTranslationsMasterImportMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: TranslationsMasterImportMutationVariables,
  ) => Promise<TranslationsMasterImportMutationData>;
} {
  return {
    mutationKey: mutationKeyTranslationsMasterImport(),
    mutationFn: function translationsMasterImportMutationFn({
      importMasterJsonRequestDto,
      idempotencyKey,
      options,
    }): Promise<TranslationsMasterImportMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(translationsMasterImport(
        client$,
        importMasterJsonRequestDto,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTranslationsMasterImportMutation(options?: MutationHookOptions<
    TranslationsMasterImportMutationData,
    Error,
    TranslationsMasterImportMutationVariables
  >,)
 - mutationKeyTranslationsMasterImport()
 - buildTranslationsMasterImportMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - translationsMasterImportMutationFn({
      importMasterJsonRequestDto,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildTranslationsMasterImportMutation(client, option...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useTranslationsMasterImportMutation
- export function mutationKeyTranslationsMasterImport
- export function buildTranslationsMasterImportMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/translationsMasterRetrieve.ts
Tamaño: 4710 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { translationsMasterRetrieve } from "../funcs/translationsMasterRetrieve.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type TranslationsMasterRetrieveQueryData =
  components.GetMasterJsonResponseDto;

/**
 * Retrieve master translations JSON
 *
 * @remarks
 * Retrieve all translations for a locale in master JSON format organized by resourceId (workflowId)
 */
export function useTranslationsMasterRetrieve(
  locale?: string | undefined,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<TranslationsMasterRetrieveQueryData>,
): UseQueryResult<TranslationsMasterRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildTranslationsMasterRetrieveQuery(
      client,
      locale,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * Retrieve master translations JSON
 *
 * @remarks
 * Retrieve all translations for a locale in master JSON format organized by resourceId (workflowId)
 */
export function useTranslationsMasterRetrieveSuspense(
  locale?: string | undefined,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<TranslationsMasterRetrieveQueryData>,
): UseSuspenseQueryResult<TranslationsMasterRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildTranslationsMasterRetrieveQuery(
      client,
      locale,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchTranslationsMasterRetrieve(
  queryClient: QueryClient,
  client$: NovuCore,
  locale?: string | undefined,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildTranslationsMasterRetrieveQuery(
      client$,
      locale,
      idempotencyKey,
    ),
  });
}

export function setTranslationsMasterRetrieveData(
  client: QueryClient,
  queryKeyBase: [
    parameters: {
      locale?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: TranslationsMasterRetrieveQueryData,
): TranslationsMasterRetrieveQueryData | undefined {
  const key = queryKeyTranslationsMasterRetrieve(...queryKeyBase);

  return client.setQueryData<TranslationsMasterRetrieveQueryData>(key, data);
}

export function invalidateTranslationsMasterRetrieve(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      locale?: string | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "master", "retrieve", ...queryKeyBase],
  });
}

export function invalidateAllTranslationsMasterRetrieve(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "master", "retrieve"],
  });
}

export function buildTranslationsMasterRetrieveQuery(
  client$: NovuCore,
  locale?: string | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<TranslationsMasterRetrieveQueryData>;
} {
  return {
    queryKey: queryKeyTranslationsMasterRetrieve({ locale, idempotencyKey }),
    queryFn: async function translationsMasterRetrieveQueryFn(
      ctx,
    ): Promise<TranslationsMasterRetrieveQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(translationsMasterRetrieve(
        client$,
        locale,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyTranslationsMasterRetrieve(
  parameters: {
    locale?: string | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return ["@novu/api", "master", "retrieve", parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTranslationsMasterRetrieve(locale?: string | undefined,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<TranslationsMasterRetrieveQueryData>,)
 - useTranslationsMasterRetrieveSuspense(locale?: string | undefined,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<TranslationsMasterRetrieveQueryData>,)
 - prefetchTranslationsMasterRetrieve(queryClient: QueryClient,
  client$: NovuCore,
  locale?: string | undefined,
  idempotencyKey?: string | undefined,)
 - setTranslationsMasterRetrieveData(client: QueryClient,
  queryKeyBase: [
    parameters: {
      locale?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: TranslationsMasterRetrieveQueryData,)
 - invalidateTranslationsMasterRetrieve(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      locale?: string | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllTranslationsMasterRetrieve(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildTranslationsMasterRetrieveQuery(client$: NovuCore,
  locale?: string | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - translationsMasterRetrieveQueryFn(ctx,)
 - queryKeyTranslationsMasterRetrieve(parameters: {
    locale?: string | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyTranslationsMasterRetrieve(...queryKeyBase);

  return client.setQueryData<TranslationsMaste...)
Declaraciones 'export' encontradas:
- export  type
- export function useTranslationsMasterRetrieve
- export function useTranslationsMasterRetrieveSuspense
- export function prefetchTranslationsMasterRetrieve
- export function setTranslationsMasterRetrieveData
- export function invalidateTranslationsMasterRetrieve
- export function invalidateAllTranslationsMasterRetrieve
- export function buildTranslationsMasterRetrieveQuery
- export function queryKeyTranslationsMasterRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/translationsMasterUpload.ts
Tamaño: 2565 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { translationsMasterUpload } from "../funcs/translationsMasterUpload.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type TranslationsMasterUploadMutationVariables = {
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type TranslationsMasterUploadMutationData =
  components.ImportMasterJsonResponseDto;

/**
 * Upload master translations JSON file
 *
 * @remarks
 * Upload a master JSON file containing translations for multiple workflows. Locale is automatically detected from filename (e.g., en_US.json)
 */
export function useTranslationsMasterUploadMutation(
  options?: MutationHookOptions<
    TranslationsMasterUploadMutationData,
    Error,
    TranslationsMasterUploadMutationVariables
  >,
): UseMutationResult<
  TranslationsMasterUploadMutationData,
  Error,
  TranslationsMasterUploadMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildTranslationsMasterUploadMutation(client, options),
    ...options,
  });
}

export function mutationKeyTranslationsMasterUpload(): MutationKey {
  return ["@novu/api", "master", "upload"];
}

export function buildTranslationsMasterUploadMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: TranslationsMasterUploadMutationVariables,
  ) => Promise<TranslationsMasterUploadMutationData>;
} {
  return {
    mutationKey: mutationKeyTranslationsMasterUpload(),
    mutationFn: function translationsMasterUploadMutationFn({
      idempotencyKey,
      options,
    }): Promise<TranslationsMasterUploadMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(translationsMasterUpload(
        client$,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTranslationsMasterUploadMutation(options?: MutationHookOptions<
    TranslationsMasterUploadMutationData,
    Error,
    TranslationsMasterUploadMutationVariables
  >,)
 - mutationKeyTranslationsMasterUpload()
 - buildTranslationsMasterUploadMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - translationsMasterUploadMutationFn({
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildTranslationsMasterUploadMutation(client, option...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useTranslationsMasterUploadMutation
- export function mutationKeyTranslationsMasterUpload
- export function buildTranslationsMasterUploadMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/translationsRetrieve.ts
Tamaño: 4814 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { translationsRetrieve } from "../funcs/translationsRetrieve.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type TranslationsRetrieveQueryData = components.TranslationResponseDto;

/**
 * Retrieve a translation
 *
 * @remarks
 * Retrieve a specific translation by resource type, resource ID and locale
 */
export function useTranslationsRetrieve(
  request: operations.TranslationControllerGetSingleTranslationRequest,
  options?: QueryHookOptions<TranslationsRetrieveQueryData>,
): UseQueryResult<TranslationsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildTranslationsRetrieveQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

/**
 * Retrieve a translation
 *
 * @remarks
 * Retrieve a specific translation by resource type, resource ID and locale
 */
export function useTranslationsRetrieveSuspense(
  request: operations.TranslationControllerGetSingleTranslationRequest,
  options?: SuspenseQueryHookOptions<TranslationsRetrieveQueryData>,
): UseSuspenseQueryResult<TranslationsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildTranslationsRetrieveQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

export function prefetchTranslationsRetrieve(
  queryClient: QueryClient,
  client$: NovuCore,
  request: operations.TranslationControllerGetSingleTranslationRequest,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildTranslationsRetrieveQuery(
      client$,
      request,
    ),
  });
}

export function setTranslationsRetrieveData(
  client: QueryClient,
  queryKeyBase: [
    resourceType: operations.PathParamResourceType,
    resourceId: string,
    locale: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: TranslationsRetrieveQueryData,
): TranslationsRetrieveQueryData | undefined {
  const key = queryKeyTranslationsRetrieve(...queryKeyBase);

  return client.setQueryData<TranslationsRetrieveQueryData>(key, data);
}

export function invalidateTranslationsRetrieve(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      resourceType: operations.PathParamResourceType,
      resourceId: string,
      locale: string,
      parameters: { idempotencyKey?: string | undefined },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Translations", "retrieve", ...queryKeyBase],
  });
}

export function invalidateAllTranslationsRetrieve(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Translations", "retrieve"],
  });
}

export function buildTranslationsRetrieveQuery(
  client$: NovuCore,
  request: operations.TranslationControllerGetSingleTranslationRequest,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<TranslationsRetrieveQueryData>;
} {
  return {
    queryKey: queryKeyTranslationsRetrieve(
      request.resourceType,
      request.resourceId,
      request.locale,
      { idempotencyKey: request.idempotencyKey },
    ),
    queryFn: async function translationsRetrieveQueryFn(
      ctx,
    ): Promise<TranslationsRetrieveQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(translationsRetrieve(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyTranslationsRetrieve(
  resourceType: operations.PathParamResourceType,
  resourceId: string,
  locale: string,
  parameters: { idempotencyKey?: string | undefined },
): QueryKey {
  return [
    "@novu/api",
    "Translations",
    "retrieve",
    resourceType,
    resourceId,
    locale,
    parameters,
  ];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTranslationsRetrieve(request: operations.TranslationControllerGetSingleTranslationRequest,
  options?: QueryHookOptions<TranslationsRetrieveQueryData>,)
 - useTranslationsRetrieveSuspense(request: operations.TranslationControllerGetSingleTranslationRequest,
  options?: SuspenseQueryHookOptions<TranslationsRetrieveQueryData>,)
 - prefetchTranslationsRetrieve(queryClient: QueryClient,
  client$: NovuCore,
  request: operations.TranslationControllerGetSingleTranslationRequest,)
 - setTranslationsRetrieveData(client: QueryClient,
  queryKeyBase: [
    resourceType: operations.PathParamResourceType,
    resourceId: string,
    locale: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: TranslationsRetrieveQueryData,)
 - invalidateTranslationsRetrieve(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      resourceType: operations.PathParamResourceType,
      resourceId: string,
      locale: string,
      parameters: { idempotencyKey?: string | undefined },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllTranslationsRetrieve(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildTranslationsRetrieveQuery(client$: NovuCore,
  request: operations.TranslationControllerGetSingleTranslationRequest,
  options?: RequestOptions,)
 - translationsRetrieveQueryFn(ctx,)
 - queryKeyTranslationsRetrieve(resourceType: operations.PathParamResourceType,
  resourceId: string,
  locale: string,
  parameters: { idempotencyKey?: string | undefined },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyTranslationsRetrieve(...queryKeyBase);

  return client.setQueryData<TranslationsRetrieveQue...)
Declaraciones 'export' encontradas:
- export  type
- export function useTranslationsRetrieve
- export function useTranslationsRetrieveSuspense
- export function prefetchTranslationsRetrieve
- export function setTranslationsRetrieveData
- export function invalidateTranslationsRetrieve
- export function invalidateAllTranslationsRetrieve
- export function buildTranslationsRetrieveQuery
- export function queryKeyTranslationsRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/translationsUpload.ts
Tamaño: 2577 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { translationsUpload } from "../funcs/translationsUpload.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type TranslationsUploadMutationVariables = {
  uploadTranslationsRequestDto: components.UploadTranslationsRequestDto;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type TranslationsUploadMutationData =
  components.UploadTranslationsResponseDto;

/**
 * Upload translation files
 *
 * @remarks
 * Upload one or more JSON translation files for a specific workflow. Files name must match the locale, e.g. en_US.json
 */
export function useTranslationsUploadMutation(
  options?: MutationHookOptions<
    TranslationsUploadMutationData,
    Error,
    TranslationsUploadMutationVariables
  >,
): UseMutationResult<
  TranslationsUploadMutationData,
  Error,
  TranslationsUploadMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildTranslationsUploadMutation(client, options),
    ...options,
  });
}

export function mutationKeyTranslationsUpload(): MutationKey {
  return ["@novu/api", "Translations", "upload"];
}

export function buildTranslationsUploadMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: TranslationsUploadMutationVariables,
  ) => Promise<TranslationsUploadMutationData>;
} {
  return {
    mutationKey: mutationKeyTranslationsUpload(),
    mutationFn: function translationsUploadMutationFn({
      uploadTranslationsRequestDto,
      idempotencyKey,
      options,
    }): Promise<TranslationsUploadMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(translationsUpload(
        client$,
        uploadTranslationsRequestDto,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTranslationsUploadMutation(options?: MutationHookOptions<
    TranslationsUploadMutationData,
    Error,
    TranslationsUploadMutationVariables
  >,)
 - mutationKeyTranslationsUpload()
 - buildTranslationsUploadMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - translationsUploadMutationFn({
      uploadTranslationsRequestDto,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildTranslationsUploadMutation(client, options),
  ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useTranslationsUploadMutation
- export function mutationKeyTranslationsUpload
- export function buildTranslationsUploadMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/trigger.ts
Tamaño: 2736 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { trigger } from "../funcs/trigger.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type TriggerMutationVariables = {
  triggerEventRequestDto: components.TriggerEventRequestDto;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type TriggerMutationData = operations.EventsControllerTriggerResponse;

/**
 * Trigger event
 *
 * @remarks
 *
 *     Trigger event is the main (and only) way to send notifications to subscribers. The trigger identifier is used to match the particular workflow associated with it. Additional information can be passed according the body interface below.
 *     To prevent duplicate triggers, you can optionally pass a **transactionId** in the request body. If the same **transactionId** is used again, the trigger will be ignored. The retention period depends on your billing tier.
 */
export function useTriggerMutation(
  options?: MutationHookOptions<
    TriggerMutationData,
    Error,
    TriggerMutationVariables
  >,
): UseMutationResult<TriggerMutationData, Error, TriggerMutationVariables> {
  const client = useNovuContext();
  return useMutation({
    ...buildTriggerMutation(client, options),
    ...options,
  });
}

export function mutationKeyTrigger(): MutationKey {
  return ["@novu/api", "trigger"];
}

export function buildTriggerMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: TriggerMutationVariables,
  ) => Promise<TriggerMutationData>;
} {
  return {
    mutationKey: mutationKeyTrigger(),
    mutationFn: function triggerMutationFn({
      triggerEventRequestDto,
      idempotencyKey,
      options,
    }): Promise<TriggerMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(trigger(
        client$,
        triggerEventRequestDto,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTriggerMutation(options?: MutationHookOptions<
    TriggerMutationData,
    Error,
    TriggerMutationVariables
  >,)
 - mutationKeyTrigger()
 - buildTriggerMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - triggerMutationFn({
      triggerEventRequestDto,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildTriggerMutation(client, options),
    ...option...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useTriggerMutation
- export function mutationKeyTrigger
- export function buildTriggerMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/triggerBroadcast.ts
Tamaño: 2692 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { triggerBroadcast } from "../funcs/triggerBroadcast.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type TriggerBroadcastMutationVariables = {
  triggerEventToAllRequestDto: components.TriggerEventToAllRequestDto;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type TriggerBroadcastMutationData =
  operations.EventsControllerBroadcastEventToAllResponse;

/**
 * Broadcast event to all
 *
 * @remarks
 * Trigger a broadcast event to all existing subscribers, could be used to send announcements, etc.
 *       In the future could be used to trigger events to a subset of subscribers based on defined filters.
 */
export function useTriggerBroadcastMutation(
  options?: MutationHookOptions<
    TriggerBroadcastMutationData,
    Error,
    TriggerBroadcastMutationVariables
  >,
): UseMutationResult<
  TriggerBroadcastMutationData,
  Error,
  TriggerBroadcastMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildTriggerBroadcastMutation(client, options),
    ...options,
  });
}

export function mutationKeyTriggerBroadcast(): MutationKey {
  return ["@novu/api", "triggerBroadcast"];
}

export function buildTriggerBroadcastMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: TriggerBroadcastMutationVariables,
  ) => Promise<TriggerBroadcastMutationData>;
} {
  return {
    mutationKey: mutationKeyTriggerBroadcast(),
    mutationFn: function triggerBroadcastMutationFn({
      triggerEventToAllRequestDto,
      idempotencyKey,
      options,
    }): Promise<TriggerBroadcastMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(triggerBroadcast(
        client$,
        triggerEventToAllRequestDto,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTriggerBroadcastMutation(options?: MutationHookOptions<
    TriggerBroadcastMutationData,
    Error,
    TriggerBroadcastMutationVariables
  >,)
 - mutationKeyTriggerBroadcast()
 - buildTriggerBroadcastMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - triggerBroadcastMutationFn({
      triggerEventToAllRequestDto,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildTriggerBroadcastMutation(client, options),
    ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useTriggerBroadcastMutation
- export function mutationKeyTriggerBroadcast
- export function buildTriggerBroadcastMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/triggerBulk.ts
Tamaño: 2514 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { triggerBulk } from "../funcs/triggerBulk.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type TriggerBulkMutationVariables = {
  bulkTriggerEventDto: components.BulkTriggerEventDto;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type TriggerBulkMutationData =
  operations.EventsControllerTriggerBulkResponse;

/**
 * Bulk trigger event
 *
 * @remarks
 *
 *       Using this endpoint you can trigger multiple events at once, to avoid multiple calls to the API.
 *       The bulk API is limited to 100 events per request.
 */
export function useTriggerBulkMutation(
  options?: MutationHookOptions<
    TriggerBulkMutationData,
    Error,
    TriggerBulkMutationVariables
  >,
): UseMutationResult<
  TriggerBulkMutationData,
  Error,
  TriggerBulkMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildTriggerBulkMutation(client, options),
    ...options,
  });
}

export function mutationKeyTriggerBulk(): MutationKey {
  return ["@novu/api", "triggerBulk"];
}

export function buildTriggerBulkMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: TriggerBulkMutationVariables,
  ) => Promise<TriggerBulkMutationData>;
} {
  return {
    mutationKey: mutationKeyTriggerBulk(),
    mutationFn: function triggerBulkMutationFn({
      bulkTriggerEventDto,
      idempotencyKey,
      options,
    }): Promise<TriggerBulkMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(triggerBulk(
        client$,
        bulkTriggerEventDto,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useTriggerBulkMutation(options?: MutationHookOptions<
    TriggerBulkMutationData,
    Error,
    TriggerBulkMutationVariables
  >,)
 - mutationKeyTriggerBulk()
 - buildTriggerBulkMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - triggerBulkMutationFn({
      bulkTriggerEventDto,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildTriggerBulkMutation(client, options),
    ...op...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useTriggerBulkMutation
- export function mutationKeyTriggerBulk
- export function buildTriggerBulkMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/workflowsCreate.ts
Tamaño: 2469 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { workflowsCreate } from "../funcs/workflowsCreate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type WorkflowsCreateMutationVariables = {
  createWorkflowDto: components.CreateWorkflowDto;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type WorkflowsCreateMutationData =
  operations.WorkflowControllerCreateResponse;

/**
 * Create a workflow
 *
 * @remarks
 * Creates a new workflow in the Novu Cloud environment
 */
export function useWorkflowsCreateMutation(
  options?: MutationHookOptions<
    WorkflowsCreateMutationData,
    Error,
    WorkflowsCreateMutationVariables
  >,
): UseMutationResult<
  WorkflowsCreateMutationData,
  Error,
  WorkflowsCreateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildWorkflowsCreateMutation(client, options),
    ...options,
  });
}

export function mutationKeyWorkflowsCreate(): MutationKey {
  return ["@novu/api", "Workflows", "create"];
}

export function buildWorkflowsCreateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: WorkflowsCreateMutationVariables,
  ) => Promise<WorkflowsCreateMutationData>;
} {
  return {
    mutationKey: mutationKeyWorkflowsCreate(),
    mutationFn: function workflowsCreateMutationFn({
      createWorkflowDto,
      idempotencyKey,
      options,
    }): Promise<WorkflowsCreateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(workflowsCreate(
        client$,
        createWorkflowDto,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useWorkflowsCreateMutation(options?: MutationHookOptions<
    WorkflowsCreateMutationData,
    Error,
    WorkflowsCreateMutationVariables
  >,)
 - mutationKeyWorkflowsCreate()
 - buildWorkflowsCreateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - workflowsCreateMutationFn({
      createWorkflowDto,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildWorkflowsCreateMutation(client, options),
    ....)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useWorkflowsCreateMutation
- export function mutationKeyWorkflowsCreate
- export function buildWorkflowsCreateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/workflowsDelete.ts
Tamaño: 2404 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { workflowsDelete } from "../funcs/workflowsDelete.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type WorkflowsDeleteMutationVariables = {
  workflowId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type WorkflowsDeleteMutationData =
  | operations.WorkflowControllerRemoveWorkflowResponse
  | undefined;

/**
 * Delete a workflow
 *
 * @remarks
 * Removes a specific workflow by its unique identifier **workflowId**
 */
export function useWorkflowsDeleteMutation(
  options?: MutationHookOptions<
    WorkflowsDeleteMutationData,
    Error,
    WorkflowsDeleteMutationVariables
  >,
): UseMutationResult<
  WorkflowsDeleteMutationData,
  Error,
  WorkflowsDeleteMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildWorkflowsDeleteMutation(client, options),
    ...options,
  });
}

export function mutationKeyWorkflowsDelete(): MutationKey {
  return ["@novu/api", "Workflows", "delete"];
}

export function buildWorkflowsDeleteMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: WorkflowsDeleteMutationVariables,
  ) => Promise<WorkflowsDeleteMutationData>;
} {
  return {
    mutationKey: mutationKeyWorkflowsDelete(),
    mutationFn: function workflowsDeleteMutationFn({
      workflowId,
      idempotencyKey,
      options,
    }): Promise<WorkflowsDeleteMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(workflowsDelete(
        client$,
        workflowId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useWorkflowsDeleteMutation(options?: MutationHookOptions<
    WorkflowsDeleteMutationData,
    Error,
    WorkflowsDeleteMutationVariables
  >,)
 - mutationKeyWorkflowsDelete()
 - buildWorkflowsDeleteMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - workflowsDeleteMutationFn({
      workflowId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildWorkflowsDeleteMutation(client, options),
    ....)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useWorkflowsDeleteMutation
- export function mutationKeyWorkflowsDelete
- export function buildWorkflowsDeleteMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/workflowsDuplicate.ts
Tamaño: 2688 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { workflowsDuplicate } from "../funcs/workflowsDuplicate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type WorkflowsDuplicateMutationVariables = {
  duplicateWorkflowDto: components.DuplicateWorkflowDto;
  workflowId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type WorkflowsDuplicateMutationData =
  operations.WorkflowControllerDuplicateWorkflowResponse;

/**
 * Duplicate a workflow
 *
 * @remarks
 * Duplicates a workflow by its unique identifier **workflowId**. This will create a new workflow with the same steps and settings.
 */
export function useWorkflowsDuplicateMutation(
  options?: MutationHookOptions<
    WorkflowsDuplicateMutationData,
    Error,
    WorkflowsDuplicateMutationVariables
  >,
): UseMutationResult<
  WorkflowsDuplicateMutationData,
  Error,
  WorkflowsDuplicateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildWorkflowsDuplicateMutation(client, options),
    ...options,
  });
}

export function mutationKeyWorkflowsDuplicate(): MutationKey {
  return ["@novu/api", "Workflows", "duplicate"];
}

export function buildWorkflowsDuplicateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: WorkflowsDuplicateMutationVariables,
  ) => Promise<WorkflowsDuplicateMutationData>;
} {
  return {
    mutationKey: mutationKeyWorkflowsDuplicate(),
    mutationFn: function workflowsDuplicateMutationFn({
      duplicateWorkflowDto,
      workflowId,
      idempotencyKey,
      options,
    }): Promise<WorkflowsDuplicateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(workflowsDuplicate(
        client$,
        duplicateWorkflowDto,
        workflowId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useWorkflowsDuplicateMutation(options?: MutationHookOptions<
    WorkflowsDuplicateMutationData,
    Error,
    WorkflowsDuplicateMutationVariables
  >,)
 - mutationKeyWorkflowsDuplicate()
 - buildWorkflowsDuplicateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - workflowsDuplicateMutationFn({
      duplicateWorkflowDto,
      workflowId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildWorkflowsDuplicateMutation(client, options),
  ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useWorkflowsDuplicateMutation
- export function mutationKeyWorkflowsDuplicate
- export function buildWorkflowsDuplicateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/workflowsGet.ts
Tamaño: 4642 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { workflowsGet } from "../funcs/workflowsGet.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type WorkflowsGetQueryData =
  operations.WorkflowControllerGetWorkflowResponse;

/**
 * Retrieve a workflow
 *
 * @remarks
 * Fetches details of a specific workflow by its unique identifier **workflowId**
 */
export function useWorkflowsGet(
  workflowId: string,
  environmentId?: string | undefined,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<WorkflowsGetQueryData>,
): UseQueryResult<WorkflowsGetQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildWorkflowsGetQuery(
      client,
      workflowId,
      environmentId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * Retrieve a workflow
 *
 * @remarks
 * Fetches details of a specific workflow by its unique identifier **workflowId**
 */
export function useWorkflowsGetSuspense(
  workflowId: string,
  environmentId?: string | undefined,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<WorkflowsGetQueryData>,
): UseSuspenseQueryResult<WorkflowsGetQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildWorkflowsGetQuery(
      client,
      workflowId,
      environmentId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchWorkflowsGet(
  queryClient: QueryClient,
  client$: NovuCore,
  workflowId: string,
  environmentId?: string | undefined,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildWorkflowsGetQuery(
      client$,
      workflowId,
      environmentId,
      idempotencyKey,
    ),
  });
}

export function setWorkflowsGetData(
  client: QueryClient,
  queryKeyBase: [
    workflowId: string,
    parameters: {
      environmentId?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: WorkflowsGetQueryData,
): WorkflowsGetQueryData | undefined {
  const key = queryKeyWorkflowsGet(...queryKeyBase);

  return client.setQueryData<WorkflowsGetQueryData>(key, data);
}

export function invalidateWorkflowsGet(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      workflowId: string,
      parameters: {
        environmentId?: string | undefined;
        idempotencyKey?: string | undefined;
      },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Workflows", "get", ...queryKeyBase],
  });
}

export function invalidateAllWorkflowsGet(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Workflows", "get"],
  });
}

export function buildWorkflowsGetQuery(
  client$: NovuCore,
  workflowId: string,
  environmentId?: string | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (context: QueryFunctionContext) => Promise<WorkflowsGetQueryData>;
} {
  return {
    queryKey: queryKeyWorkflowsGet(workflowId, {
      environmentId,
      idempotencyKey,
    }),
    queryFn: async function workflowsGetQueryFn(
      ctx,
    ): Promise<WorkflowsGetQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(workflowsGet(
        client$,
        workflowId,
        environmentId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyWorkflowsGet(
  workflowId: string,
  parameters: {
    environmentId?: string | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return ["@novu/api", "Workflows", "get", workflowId, parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useWorkflowsGet(workflowId: string,
  environmentId?: string | undefined,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<WorkflowsGetQueryData>,)
 - useWorkflowsGetSuspense(workflowId: string,
  environmentId?: string | undefined,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<WorkflowsGetQueryData>,)
 - prefetchWorkflowsGet(queryClient: QueryClient,
  client$: NovuCore,
  workflowId: string,
  environmentId?: string | undefined,
  idempotencyKey?: string | undefined,)
 - setWorkflowsGetData(client: QueryClient,
  queryKeyBase: [
    workflowId: string,
    parameters: {
      environmentId?: string | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: WorkflowsGetQueryData,)
 - invalidateWorkflowsGet(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      workflowId: string,
      parameters: {
        environmentId?: string | undefined;
        idempotencyKey?: string | undefined;
      },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllWorkflowsGet(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildWorkflowsGetQuery(client$: NovuCore,
  workflowId: string,
  environmentId?: string | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - workflowsGetQueryFn(ctx,)
 - queryKeyWorkflowsGet(workflowId: string,
  parameters: {
    environmentId?: string | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyWorkflowsGet(...queryKeyBase);

  return client.setQueryData<WorkflowsGetQueryData>(key, dat...)
Declaraciones 'export' encontradas:
- export  type
- export function useWorkflowsGet
- export function useWorkflowsGetSuspense
- export function prefetchWorkflowsGet
- export function setWorkflowsGetData
- export function invalidateWorkflowsGet
- export function invalidateAllWorkflowsGet
- export function buildWorkflowsGetQuery
- export function queryKeyWorkflowsGet

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/workflowsList.ts
Tamaño: 5371 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { workflowsList } from "../funcs/workflowsList.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type WorkflowsListQueryData =
  operations.WorkflowControllerSearchWorkflowsResponse;

/**
 * List all workflows
 *
 * @remarks
 * Retrieves a list of workflows with optional filtering and pagination
 */
export function useWorkflowsList(
  request: operations.WorkflowControllerSearchWorkflowsRequest,
  options?: QueryHookOptions<WorkflowsListQueryData>,
): UseQueryResult<WorkflowsListQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildWorkflowsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

/**
 * List all workflows
 *
 * @remarks
 * Retrieves a list of workflows with optional filtering and pagination
 */
export function useWorkflowsListSuspense(
  request: operations.WorkflowControllerSearchWorkflowsRequest,
  options?: SuspenseQueryHookOptions<WorkflowsListQueryData>,
): UseSuspenseQueryResult<WorkflowsListQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildWorkflowsListQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

export function prefetchWorkflowsList(
  queryClient: QueryClient,
  client$: NovuCore,
  request: operations.WorkflowControllerSearchWorkflowsRequest,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildWorkflowsListQuery(
      client$,
      request,
    ),
  });
}

export function setWorkflowsListData(
  client: QueryClient,
  queryKeyBase: [
    parameters: {
      limit?: number | undefined;
      offset?: number | undefined;
      orderDirection?: components.DirectionEnum | undefined;
      orderBy?: components.WorkflowResponseDtoSortField | undefined;
      query?: string | undefined;
      tags?: Array<string> | undefined;
      status?: Array<components.WorkflowStatusEnum> | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: WorkflowsListQueryData,
): WorkflowsListQueryData | undefined {
  const key = queryKeyWorkflowsList(...queryKeyBase);

  return client.setQueryData<WorkflowsListQueryData>(key, data);
}

export function invalidateWorkflowsList(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      limit?: number | undefined;
      offset?: number | undefined;
      orderDirection?: components.DirectionEnum | undefined;
      orderBy?: components.WorkflowResponseDtoSortField | undefined;
      query?: string | undefined;
      tags?: Array<string> | undefined;
      status?: Array<components.WorkflowStatusEnum> | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Workflows", "list", ...queryKeyBase],
  });
}

export function invalidateAllWorkflowsList(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Workflows", "list"],
  });
}

export function buildWorkflowsListQuery(
  client$: NovuCore,
  request: operations.WorkflowControllerSearchWorkflowsRequest,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (context: QueryFunctionContext) => Promise<WorkflowsListQueryData>;
} {
  return {
    queryKey: queryKeyWorkflowsList({
      limit: request.limit,
      offset: request.offset,
      orderDirection: request.orderDirection,
      orderBy: request.orderBy,
      query: request.query,
      tags: request.tags,
      status: request.status,
      idempotencyKey: request.idempotencyKey,
    }),
    queryFn: async function workflowsListQueryFn(
      ctx,
    ): Promise<WorkflowsListQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(workflowsList(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyWorkflowsList(
  parameters: {
    limit?: number | undefined;
    offset?: number | undefined;
    orderDirection?: components.DirectionEnum | undefined;
    orderBy?: components.WorkflowResponseDtoSortField | undefined;
    query?: string | undefined;
    tags?: Array<string> | undefined;
    status?: Array<components.WorkflowStatusEnum> | undefined;
    idempotencyKey?: string | undefined;
  },
): QueryKey {
  return ["@novu/api", "Workflows", "list", parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useWorkflowsList(request: operations.WorkflowControllerSearchWorkflowsRequest,
  options?: QueryHookOptions<WorkflowsListQueryData>,)
 - useWorkflowsListSuspense(request: operations.WorkflowControllerSearchWorkflowsRequest,
  options?: SuspenseQueryHookOptions<WorkflowsListQueryData>,)
 - prefetchWorkflowsList(queryClient: QueryClient,
  client$: NovuCore,
  request: operations.WorkflowControllerSearchWorkflowsRequest,)
 - setWorkflowsListData(client: QueryClient,
  queryKeyBase: [
    parameters: {
      limit?: number | undefined;
      offset?: number | undefined;
      orderDirection?: components.DirectionEnum | undefined;
      orderBy?: components.WorkflowResponseDtoSortField | undefined;
      query?: string | undefined;
      tags?: Array<string> | undefined;
      status?: Array<components.WorkflowStatusEnum> | undefined;
      idempotencyKey?: string | undefined;
    },
  ],
  data: WorkflowsListQueryData,)
 - invalidateWorkflowsList(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [parameters: {
      limit?: number | undefined;
      offset?: number | undefined;
      orderDirection?: components.DirectionEnum | undefined;
      orderBy?: components.WorkflowResponseDtoSortField | undefined;
      query?: string | undefined;
      tags?: Array<string> | undefined;
      status?: Array<components.WorkflowStatusEnum> | undefined;
      idempotencyKey?: string | undefined;
    }]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllWorkflowsList(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildWorkflowsListQuery(client$: NovuCore,
  request: operations.WorkflowControllerSearchWorkflowsRequest,
  options?: RequestOptions,)
 - workflowsListQueryFn(ctx,)
 - queryKeyWorkflowsList(parameters: {
    limit?: number | undefined;
    offset?: number | undefined;
    orderDirection?: components.DirectionEnum | undefined;
    orderBy?: components.WorkflowResponseDtoSortField | undefined;
    query?: string | undefined;
    tags?: Array<string> | undefined;
    status?: Array<components.WorkflowStatusEnum> | undefined;
    idempotencyKey?: string | undefined;
  },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyWorkflowsList(...queryKeyBase);

  return client.setQueryData<WorkflowsListQueryData>(key, d...)
Declaraciones 'export' encontradas:
- export  type
- export function useWorkflowsList
- export function useWorkflowsListSuspense
- export function prefetchWorkflowsList
- export function setWorkflowsListData
- export function invalidateWorkflowsList
- export function invalidateAllWorkflowsList
- export function buildWorkflowsListQuery
- export function queryKeyWorkflowsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/workflowsPatch.ts
Tamaño: 2529 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { workflowsPatch } from "../funcs/workflowsPatch.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type WorkflowsPatchMutationVariables = {
  patchWorkflowDto: components.PatchWorkflowDto;
  workflowId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type WorkflowsPatchMutationData =
  operations.WorkflowControllerPatchWorkflowResponse;

/**
 * Update a workflow
 *
 * @remarks
 * Partially updates a workflow by its unique identifier **workflowId**
 */
export function useWorkflowsPatchMutation(
  options?: MutationHookOptions<
    WorkflowsPatchMutationData,
    Error,
    WorkflowsPatchMutationVariables
  >,
): UseMutationResult<
  WorkflowsPatchMutationData,
  Error,
  WorkflowsPatchMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildWorkflowsPatchMutation(client, options),
    ...options,
  });
}

export function mutationKeyWorkflowsPatch(): MutationKey {
  return ["@novu/api", "Workflows", "patch"];
}

export function buildWorkflowsPatchMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: WorkflowsPatchMutationVariables,
  ) => Promise<WorkflowsPatchMutationData>;
} {
  return {
    mutationKey: mutationKeyWorkflowsPatch(),
    mutationFn: function workflowsPatchMutationFn({
      patchWorkflowDto,
      workflowId,
      idempotencyKey,
      options,
    }): Promise<WorkflowsPatchMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(workflowsPatch(
        client$,
        patchWorkflowDto,
        workflowId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useWorkflowsPatchMutation(options?: MutationHookOptions<
    WorkflowsPatchMutationData,
    Error,
    WorkflowsPatchMutationVariables
  >,)
 - mutationKeyWorkflowsPatch()
 - buildWorkflowsPatchMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - workflowsPatchMutationFn({
      patchWorkflowDto,
      workflowId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildWorkflowsPatchMutation(client, options),
    .....)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useWorkflowsPatchMutation
- export function mutationKeyWorkflowsPatch
- export function buildWorkflowsPatchMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/workflowsStepsGeneratePreview.ts
Tamaño: 2618 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { workflowsStepsGeneratePreview } from "../funcs/workflowsStepsGeneratePreview.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type WorkflowsStepsGeneratePreviewMutationVariables = {
  request: operations.WorkflowControllerGeneratePreviewRequest;
  options?: RequestOptions;
};

export type WorkflowsStepsGeneratePreviewMutationData =
  operations.WorkflowControllerGeneratePreviewResponse;

/**
 * Generate step preview
 *
 * @remarks
 * Generates a preview for a specific workflow step by its unique identifier **stepId**
 */
export function useWorkflowsStepsGeneratePreviewMutation(
  options?: MutationHookOptions<
    WorkflowsStepsGeneratePreviewMutationData,
    Error,
    WorkflowsStepsGeneratePreviewMutationVariables
  >,
): UseMutationResult<
  WorkflowsStepsGeneratePreviewMutationData,
  Error,
  WorkflowsStepsGeneratePreviewMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildWorkflowsStepsGeneratePreviewMutation(client, options),
    ...options,
  });
}

export function mutationKeyWorkflowsStepsGeneratePreview(): MutationKey {
  return ["@novu/api", "Steps", "generatePreview"];
}

export function buildWorkflowsStepsGeneratePreviewMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: WorkflowsStepsGeneratePreviewMutationVariables,
  ) => Promise<WorkflowsStepsGeneratePreviewMutationData>;
} {
  return {
    mutationKey: mutationKeyWorkflowsStepsGeneratePreview(),
    mutationFn: function workflowsStepsGeneratePreviewMutationFn({
      request,
      options,
    }): Promise<WorkflowsStepsGeneratePreviewMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(workflowsStepsGeneratePreview(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useWorkflowsStepsGeneratePreviewMutation(options?: MutationHookOptions<
    WorkflowsStepsGeneratePreviewMutationData,
    Error,
    WorkflowsStepsGeneratePreviewMutationVariables
  >,)
 - mutationKeyWorkflowsStepsGeneratePreview()
 - buildWorkflowsStepsGeneratePreviewMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - workflowsStepsGeneratePreviewMutationFn({
      request,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildWorkflowsStepsGeneratePreviewMutation(client, o...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useWorkflowsStepsGeneratePreviewMutation
- export function mutationKeyWorkflowsStepsGeneratePreview
- export function buildWorkflowsStepsGeneratePreviewMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/workflowsStepsRetrieve.ts
Tamaño: 4666 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { workflowsStepsRetrieve } from "../funcs/workflowsStepsRetrieve.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type WorkflowsStepsRetrieveQueryData =
  operations.WorkflowControllerGetWorkflowStepDataResponse;

/**
 * Retrieve workflow step
 *
 * @remarks
 * Retrieves data for a specific step in a workflow
 */
export function useWorkflowsStepsRetrieve(
  workflowId: string,
  stepId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<WorkflowsStepsRetrieveQueryData>,
): UseQueryResult<WorkflowsStepsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useQuery({
    ...buildWorkflowsStepsRetrieveQuery(
      client,
      workflowId,
      stepId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

/**
 * Retrieve workflow step
 *
 * @remarks
 * Retrieves data for a specific step in a workflow
 */
export function useWorkflowsStepsRetrieveSuspense(
  workflowId: string,
  stepId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<WorkflowsStepsRetrieveQueryData>,
): UseSuspenseQueryResult<WorkflowsStepsRetrieveQueryData, Error> {
  const client = useNovuContext();
  return useSuspenseQuery({
    ...buildWorkflowsStepsRetrieveQuery(
      client,
      workflowId,
      stepId,
      idempotencyKey,
      options,
    ),
    ...options,
  });
}

export function prefetchWorkflowsStepsRetrieve(
  queryClient: QueryClient,
  client$: NovuCore,
  workflowId: string,
  stepId: string,
  idempotencyKey?: string | undefined,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildWorkflowsStepsRetrieveQuery(
      client$,
      workflowId,
      stepId,
      idempotencyKey,
    ),
  });
}

export function setWorkflowsStepsRetrieveData(
  client: QueryClient,
  queryKeyBase: [
    workflowId: string,
    stepId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: WorkflowsStepsRetrieveQueryData,
): WorkflowsStepsRetrieveQueryData | undefined {
  const key = queryKeyWorkflowsStepsRetrieve(...queryKeyBase);

  return client.setQueryData<WorkflowsStepsRetrieveQueryData>(key, data);
}

export function invalidateWorkflowsStepsRetrieve(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      workflowId: string,
      stepId: string,
      parameters: { idempotencyKey?: string | undefined },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Steps", "retrieve", ...queryKeyBase],
  });
}

export function invalidateAllWorkflowsStepsRetrieve(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@novu/api", "Steps", "retrieve"],
  });
}

export function buildWorkflowsStepsRetrieveQuery(
  client$: NovuCore,
  workflowId: string,
  stepId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<WorkflowsStepsRetrieveQueryData>;
} {
  return {
    queryKey: queryKeyWorkflowsStepsRetrieve(workflowId, stepId, {
      idempotencyKey,
    }),
    queryFn: async function workflowsStepsRetrieveQueryFn(
      ctx,
    ): Promise<WorkflowsStepsRetrieveQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(workflowsStepsRetrieve(
        client$,
        workflowId,
        stepId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyWorkflowsStepsRetrieve(
  workflowId: string,
  stepId: string,
  parameters: { idempotencyKey?: string | undefined },
): QueryKey {
  return ["@novu/api", "Steps", "retrieve", workflowId, stepId, parameters];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useWorkflowsStepsRetrieve(workflowId: string,
  stepId: string,
  idempotencyKey?: string | undefined,
  options?: QueryHookOptions<WorkflowsStepsRetrieveQueryData>,)
 - useWorkflowsStepsRetrieveSuspense(workflowId: string,
  stepId: string,
  idempotencyKey?: string | undefined,
  options?: SuspenseQueryHookOptions<WorkflowsStepsRetrieveQueryData>,)
 - prefetchWorkflowsStepsRetrieve(queryClient: QueryClient,
  client$: NovuCore,
  workflowId: string,
  stepId: string,
  idempotencyKey?: string | undefined,)
 - setWorkflowsStepsRetrieveData(client: QueryClient,
  queryKeyBase: [
    workflowId: string,
    stepId: string,
    parameters: { idempotencyKey?: string | undefined },
  ],
  data: WorkflowsStepsRetrieveQueryData,)
 - invalidateWorkflowsStepsRetrieve(client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      workflowId: string,
      stepId: string,
      parameters: { idempotencyKey?: string | undefined },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - invalidateAllWorkflowsStepsRetrieve(client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,)
 - buildWorkflowsStepsRetrieveQuery(client$: NovuCore,
  workflowId: string,
  stepId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - workflowsStepsRetrieveQueryFn(ctx,)
 - queryKeyWorkflowsStepsRetrieve(workflowId: string,
  stepId: string,
  parameters: { idempotencyKey?: string | undefined },)
Asignaciones con arrow functions encontradas (posibles funciones):
 - key(queryKeyWorkflowsStepsRetrieve(...queryKeyBase);

  return client.setQueryData<WorkflowsStepsRetriev...)
Declaraciones 'export' encontradas:
- export  type
- export function useWorkflowsStepsRetrieve
- export function useWorkflowsStepsRetrieveSuspense
- export function prefetchWorkflowsStepsRetrieve
- export function setWorkflowsStepsRetrieveData
- export function invalidateWorkflowsStepsRetrieve
- export function invalidateAllWorkflowsStepsRetrieve
- export function buildWorkflowsStepsRetrieveQuery
- export function queryKeyWorkflowsStepsRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/workflowsSync.ts
Tamaño: 2476 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { workflowsSync } from "../funcs/workflowsSync.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type WorkflowsSyncMutationVariables = {
  syncWorkflowDto: components.SyncWorkflowDto;
  workflowId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type WorkflowsSyncMutationData =
  operations.WorkflowControllerSyncResponse;

/**
 * Sync a workflow
 *
 * @remarks
 * Synchronizes a workflow to the target environment
 */
export function useWorkflowsSyncMutation(
  options?: MutationHookOptions<
    WorkflowsSyncMutationData,
    Error,
    WorkflowsSyncMutationVariables
  >,
): UseMutationResult<
  WorkflowsSyncMutationData,
  Error,
  WorkflowsSyncMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildWorkflowsSyncMutation(client, options),
    ...options,
  });
}

export function mutationKeyWorkflowsSync(): MutationKey {
  return ["@novu/api", "Workflows", "sync"];
}

export function buildWorkflowsSyncMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: WorkflowsSyncMutationVariables,
  ) => Promise<WorkflowsSyncMutationData>;
} {
  return {
    mutationKey: mutationKeyWorkflowsSync(),
    mutationFn: function workflowsSyncMutationFn({
      syncWorkflowDto,
      workflowId,
      idempotencyKey,
      options,
    }): Promise<WorkflowsSyncMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(workflowsSync(
        client$,
        syncWorkflowDto,
        workflowId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useWorkflowsSyncMutation(options?: MutationHookOptions<
    WorkflowsSyncMutationData,
    Error,
    WorkflowsSyncMutationVariables
  >,)
 - mutationKeyWorkflowsSync()
 - buildWorkflowsSyncMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - workflowsSyncMutationFn({
      syncWorkflowDto,
      workflowId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildWorkflowsSyncMutation(client, options),
    ......)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useWorkflowsSyncMutation
- export function mutationKeyWorkflowsSync
- export function buildWorkflowsSyncMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/react-query/workflowsUpdate.ts
Tamaño: 2575 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  MutationKey,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { NovuCore } from "../core.js";
import { workflowsUpdate } from "../funcs/workflowsUpdate.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useNovuContext } from "./_context.js";
import { MutationHookOptions } from "./_types.js";

export type WorkflowsUpdateMutationVariables = {
  updateWorkflowDto: components.UpdateWorkflowDto;
  workflowId: string;
  idempotencyKey?: string | undefined;
  options?: RequestOptions;
};

export type WorkflowsUpdateMutationData =
  operations.WorkflowControllerUpdateResponse;

/**
 * Update a workflow
 *
 * @remarks
 * Updates the details of an existing workflow, here **workflowId** is the identifier of the workflow
 */
export function useWorkflowsUpdateMutation(
  options?: MutationHookOptions<
    WorkflowsUpdateMutationData,
    Error,
    WorkflowsUpdateMutationVariables
  >,
): UseMutationResult<
  WorkflowsUpdateMutationData,
  Error,
  WorkflowsUpdateMutationVariables
> {
  const client = useNovuContext();
  return useMutation({
    ...buildWorkflowsUpdateMutation(client, options),
    ...options,
  });
}

export function mutationKeyWorkflowsUpdate(): MutationKey {
  return ["@novu/api", "Workflows", "update"];
}

export function buildWorkflowsUpdateMutation(
  client$: NovuCore,
  hookOptions?: RequestOptions,
): {
  mutationKey: MutationKey;
  mutationFn: (
    variables: WorkflowsUpdateMutationVariables,
  ) => Promise<WorkflowsUpdateMutationData>;
} {
  return {
    mutationKey: mutationKeyWorkflowsUpdate(),
    mutationFn: function workflowsUpdateMutationFn({
      updateWorkflowDto,
      workflowId,
      idempotencyKey,
      options,
    }): Promise<WorkflowsUpdateMutationData> {
      const mergedOptions = {
        ...hookOptions,
        ...options,
        fetchOptions: {
          ...hookOptions?.fetchOptions,
          ...options?.fetchOptions,
          signal: combineSignals(
            hookOptions?.fetchOptions?.signal,
            options?.fetchOptions?.signal,
          ),
        },
      };
      return unwrapAsync(workflowsUpdate(
        client$,
        updateWorkflowDto,
        workflowId,
        idempotencyKey,
        mergedOptions,
      ));
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useWorkflowsUpdateMutation(options?: MutationHookOptions<
    WorkflowsUpdateMutationData,
    Error,
    WorkflowsUpdateMutationVariables
  >,)
 - mutationKeyWorkflowsUpdate()
 - buildWorkflowsUpdateMutation(client$: NovuCore,
  hookOptions?: RequestOptions,)
 - workflowsUpdateMutationFn({
      updateWorkflowDto,
      workflowId,
      idempotencyKey,
      options,
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - client(useNovuContext();
  return useMutation({
    ...buildWorkflowsUpdateMutation(client, options),
    ....)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function useWorkflowsUpdateMutation
- export function mutationKeyWorkflowsUpdate
- export function buildWorkflowsUpdateMutation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/activity.ts
Tamaño: 1339 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { activityTrack } from "../funcs/activityTrack.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { Charts } from "./charts.js";
import { Requests } from "./requests.js";
import { WorkflowRuns } from "./workflowruns.js";

export class Activity extends ClientSDK {
  private _charts?: Charts;
  get charts(): Charts {
    return (this._charts ??= new Charts(this._options));
  }

  private _requests?: Requests;
  get requests(): Requests {
    return (this._requests ??= new Requests(this._options));
  }

  private _workflowRuns?: WorkflowRuns;
  get workflowRuns(): WorkflowRuns {
    return (this._workflowRuns ??= new WorkflowRuns(this._options));
  }

  /**
   * Track activity and engagement events
   *
   * @remarks
   * Track activity and engagement events for a specific delivery provider
   */
  async track(
    request: operations.InboundWebhooksControllerHandleWebhookRequest,
    options?: RequestOptions,
  ): Promise<Array<components.WebhookResultDto>> {
    return unwrapAsync(activityTrack(
      this,
      request,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Activity

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/charts.ts
Tamaño: 818 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { activityChartsRetrieve } from "../funcs/activityChartsRetrieve.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Charts extends ClientSDK {
  /**
   * Retrieve activity charts
   *
   * @remarks
   * Retrieve chart data for activity analytics and metrics visualization.
   */
  async retrieve(
    request: operations.ActivityControllerGetChartsRequest,
    options?: RequestOptions,
  ): Promise<components.GetChartsResponseDto> {
    return unwrapAsync(activityChartsRetrieve(
      this,
      request,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Charts

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/contexts.ts
Tamaño: 2807 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { contextsCreate } from "../funcs/contextsCreate.js";
import { contextsDelete } from "../funcs/contextsDelete.js";
import { contextsList } from "../funcs/contextsList.js";
import { contextsRetrieve } from "../funcs/contextsRetrieve.js";
import { contextsUpdate } from "../funcs/contextsUpdate.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Contexts extends ClientSDK {
  /**
   * Create context
   *
   * @remarks
   * Create a new context with the specified type, id, and data. Returns 409 if context already exists.
   */
  async create(
    createContextRequestDto: components.CreateContextRequestDto,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.ContextsControllerCreateContextResponse> {
    return unwrapAsync(contextsCreate(
      this,
      createContextRequestDto,
      idempotencyKey,
      options,
    ));
  }

  /**
   * List contexts
   *
   * @remarks
   * Retrieve a paginated list of contexts, optionally filtered by type and key pattern
   */
  async list(
    request: operations.ContextsControllerListContextsRequest,
    options?: RequestOptions,
  ): Promise<operations.ContextsControllerListContextsResponse> {
    return unwrapAsync(contextsList(
      this,
      request,
      options,
    ));
  }

  /**
   * Update context data
   *
   * @remarks
   * Update the data of an existing context. Returns 404 if context does not exist.
   */
  async update(
    request: operations.ContextsControllerUpdateContextRequest,
    options?: RequestOptions,
  ): Promise<operations.ContextsControllerUpdateContextResponse> {
    return unwrapAsync(contextsUpdate(
      this,
      request,
      options,
    ));
  }

  /**
   * Get context by id
   *
   * @remarks
   * Retrieve a specific context by its type and id
   */
  async retrieve(
    type: string,
    id: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.ContextsControllerGetContextResponse> {
    return unwrapAsync(contextsRetrieve(
      this,
      type,
      id,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Delete context
   *
   * @remarks
   * Delete a context by its type and id
   */
  async delete(
    type: string,
    id: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.ContextsControllerDeleteContextResponse | undefined> {
    return unwrapAsync(contextsDelete(
      this,
      type,
      id,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Contexts

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/credentials.ts
Tamaño: 2737 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { subscribersCredentialsAppend } from "../funcs/subscribersCredentialsAppend.js";
import { subscribersCredentialsDelete } from "../funcs/subscribersCredentialsDelete.js";
import { subscribersCredentialsUpdate } from "../funcs/subscribersCredentialsUpdate.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Credentials extends ClientSDK {
  /**
   * Upsert provider credentials
   *
   * @remarks
   * Upsert credentials for a provider such as slack and push tokens.
   *       **providerId** is required field. This API creates **deviceTokens** or appends to the existing ones.
   */
  async update(
    updateSubscriberChannelRequestDto:
      components.UpdateSubscriberChannelRequestDto,
    subscriberId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<
    operations.SubscribersV1ControllerUpdateSubscriberChannelResponse
  > {
    return unwrapAsync(subscribersCredentialsUpdate(
      this,
      updateSubscriberChannelRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Update provider credentials
   *
   * @remarks
   * Update credentials for a provider such as **slack** and **FCM**.
   *       **providerId** is required field. This API creates the **deviceTokens** or replaces the existing ones.
   */
  async append(
    updateSubscriberChannelRequestDto:
      components.UpdateSubscriberChannelRequestDto,
    subscriberId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<
    operations.SubscribersV1ControllerModifySubscriberChannelResponse
  > {
    return unwrapAsync(subscribersCredentialsAppend(
      this,
      updateSubscriberChannelRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Delete provider credentials
   *
   * @remarks
   * Delete subscriber credentials for a provider such as **slack** and **FCM** by **providerId**.
   *     This action is irreversible and will remove the credentials for the provider for particular **subscriberId**.
   */
  async delete(
    subscriberId: string,
    providerId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<
    | operations.SubscribersV1ControllerDeleteSubscriberCredentialsResponse
    | undefined
  > {
    return unwrapAsync(subscribersCredentialsDelete(
      this,
      subscriberId,
      providerId,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Credentials

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/environments.ts
Tamaño: 3593 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { environmentsCreate } from "../funcs/environmentsCreate.js";
import { environmentsDelete } from "../funcs/environmentsDelete.js";
import { environmentsGetTags } from "../funcs/environmentsGetTags.js";
import { environmentsList } from "../funcs/environmentsList.js";
import { environmentsUpdate } from "../funcs/environmentsUpdate.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Environments extends ClientSDK {
  /**
   * Get environment tags
   *
   * @remarks
   * Retrieve all unique tags used in workflows within the specified environment. These tags can be used for filtering workflows.
   */
  async getTags(
    environmentId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.EnvironmentsControllerGetEnvironmentTagsResponse> {
    return unwrapAsync(environmentsGetTags(
      this,
      environmentId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Create an environment
   *
   * @remarks
   * Creates a new environment within the current organization.
   *     Environments allow you to manage different stages of your application development lifecycle.
   *     Each environment has its own set of API keys and configurations.
   */
  async create(
    createEnvironmentRequestDto: components.CreateEnvironmentRequestDto,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.EnvironmentsControllerV1CreateEnvironmentResponse> {
    return unwrapAsync(environmentsCreate(
      this,
      createEnvironmentRequestDto,
      idempotencyKey,
      options,
    ));
  }

  /**
   * List all environments
   *
   * @remarks
   * This API returns a list of environments for the current organization.
   *     Each environment contains its configuration, API keys (if user has access), and metadata.
   */
  async list(
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.EnvironmentsControllerV1ListMyEnvironmentsResponse> {
    return unwrapAsync(environmentsList(
      this,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Update an environment
   *
   * @remarks
   * Update an environment by its unique identifier **environmentId**.
   *     You can modify the environment name, identifier, color, and other configuration settings.
   */
  async update(
    updateEnvironmentRequestDto: components.UpdateEnvironmentRequestDto,
    environmentId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.EnvironmentsControllerV1UpdateMyEnvironmentResponse> {
    return unwrapAsync(environmentsUpdate(
      this,
      updateEnvironmentRequestDto,
      environmentId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Delete an environment
   *
   * @remarks
   * Delete an environment by its unique identifier **environmentId**.
   *     This action is irreversible and will remove the environment and all its associated data.
   */
  async delete(
    environmentId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<
    operations.EnvironmentsControllerV1DeleteEnvironmentResponse | undefined
  > {
    return unwrapAsync(environmentsDelete(
      this,
      environmentId,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Environments

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/groups.ts
Tamaño: 1564 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { translationsGroupsDelete } from "../funcs/translationsGroupsDelete.js";
import { translationsGroupsRetrieve } from "../funcs/translationsGroupsRetrieve.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Groups extends ClientSDK {
  /**
   * Delete a translation group
   *
   * @remarks
   * Delete an entire translation group and all its translations
   */
  async delete(
    resourceType: operations.ResourceType,
    resourceId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(translationsGroupsDelete(
      this,
      resourceType,
      resourceId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Retrieve a translation group
   *
   * @remarks
   * Retrieves a single translation group by resource type (workflow, layout) and resource ID (workflowId, layoutId)
   */
  async retrieve(
    resourceType:
      operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
    resourceId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<components.TranslationGroupDto> {
    return unwrapAsync(translationsGroupsRetrieve(
      this,
      resourceType,
      resourceId,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Groups

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/index.ts
Tamaño: 103 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

export * from "./sdk.js";


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/integrations.ts
Tamaño: 4944 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { integrationsCreate } from "../funcs/integrationsCreate.js";
import { integrationsDelete } from "../funcs/integrationsDelete.js";
import { integrationsIntegrationsControllerAutoConfigureIntegration } from "../funcs/integrationsIntegrationsControllerAutoConfigureIntegration.js";
import { integrationsList } from "../funcs/integrationsList.js";
import { integrationsListActive } from "../funcs/integrationsListActive.js";
import { integrationsSetAsPrimary } from "../funcs/integrationsSetAsPrimary.js";
import { integrationsUpdate } from "../funcs/integrationsUpdate.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Integrations extends ClientSDK {
  /**
   * List all integrations
   *
   * @remarks
   * List all the channels integrations created in the organization
   */
  async list(
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.IntegrationsControllerListIntegrationsResponse> {
    return unwrapAsync(integrationsList(
      this,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Create an integration
   *
   * @remarks
   * Create an integration for the current environment the user is based on the API key provided.
   *     Each provider supports different credentials, check the provider documentation for more details.
   */
  async create(
    createIntegrationRequestDto: components.CreateIntegrationRequestDto,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.IntegrationsControllerCreateIntegrationResponse> {
    return unwrapAsync(integrationsCreate(
      this,
      createIntegrationRequestDto,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Update an integration
   *
   * @remarks
   * Update an integration by its unique key identifier **integrationId**.
   *     Each provider supports different credentials, check the provider documentation for more details.
   */
  async update(
    updateIntegrationRequestDto: components.UpdateIntegrationRequestDto,
    integrationId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.IntegrationsControllerUpdateIntegrationByIdResponse> {
    return unwrapAsync(integrationsUpdate(
      this,
      updateIntegrationRequestDto,
      integrationId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Delete an integration
   *
   * @remarks
   * Delete an integration by its unique key identifier **integrationId**.
   *     This action is irreversible.
   */
  async delete(
    integrationId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.IntegrationsControllerRemoveIntegrationResponse> {
    return unwrapAsync(integrationsDelete(
      this,
      integrationId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Auto-configure an integration for inbound webhooks
   *
   * @remarks
   * Auto-configure an integration by its unique key identifier **integrationId** for inbound webhook support.
   *     This will automatically generate required webhook signing keys and configure webhook endpoints.
   */
  async integrationsControllerAutoConfigureIntegration(
    integrationId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<
    operations.IntegrationsControllerAutoConfigureIntegrationResponse
  > {
    return unwrapAsync(
      integrationsIntegrationsControllerAutoConfigureIntegration(
        this,
        integrationId,
        idempotencyKey,
        options,
      ),
    );
  }

  /**
   * Update integration as primary
   *
   * @remarks
   * Update an integration as **primary** by its unique key identifier **integrationId**.
   *     This API will set the integration as primary for that channel in the current environment.
   *     Primary integration is used to deliver notification for sms and email channels in the workflow.
   */
  async setAsPrimary(
    integrationId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.IntegrationsControllerSetIntegrationAsPrimaryResponse> {
    return unwrapAsync(integrationsSetAsPrimary(
      this,
      integrationId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * List active integrations
   *
   * @remarks
   * List all the active integrations created in the organization
   */
  async listActive(
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.IntegrationsControllerGetActiveIntegrationsResponse> {
    return unwrapAsync(integrationsListActive(
      this,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Integrations

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/layouts.ts
Tamaño: 4536 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { layoutsCreate } from "../funcs/layoutsCreate.js";
import { layoutsDelete } from "../funcs/layoutsDelete.js";
import { layoutsDuplicate } from "../funcs/layoutsDuplicate.js";
import { layoutsGeneratePreview } from "../funcs/layoutsGeneratePreview.js";
import { layoutsList } from "../funcs/layoutsList.js";
import { layoutsRetrieve } from "../funcs/layoutsRetrieve.js";
import { layoutsUpdate } from "../funcs/layoutsUpdate.js";
import { layoutsUsage } from "../funcs/layoutsUsage.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Layouts extends ClientSDK {
  /**
   * Create a layout
   *
   * @remarks
   * Creates a new layout in the Novu Cloud environment
   */
  async create(
    createLayoutDto: components.CreateLayoutDto,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.LayoutsControllerCreateResponse> {
    return unwrapAsync(layoutsCreate(
      this,
      createLayoutDto,
      idempotencyKey,
      options,
    ));
  }

  /**
   * List all layouts
   *
   * @remarks
   * Retrieves a list of layouts with optional filtering and pagination
   */
  async list(
    request: operations.LayoutsControllerListRequest,
    options?: RequestOptions,
  ): Promise<operations.LayoutsControllerListResponse> {
    return unwrapAsync(layoutsList(
      this,
      request,
      options,
    ));
  }

  /**
   * Update a layout
   *
   * @remarks
   * Updates the details of an existing layout, here **layoutId** is the identifier of the layout
   */
  async update(
    updateLayoutDto: components.UpdateLayoutDto,
    layoutId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.LayoutsControllerUpdateResponse> {
    return unwrapAsync(layoutsUpdate(
      this,
      updateLayoutDto,
      layoutId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Retrieve a layout
   *
   * @remarks
   * Fetches details of a specific layout by its unique identifier **layoutId**
   */
  async retrieve(
    layoutId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.LayoutsControllerGetResponse> {
    return unwrapAsync(layoutsRetrieve(
      this,
      layoutId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Delete a layout
   *
   * @remarks
   * Removes a specific layout by its unique identifier **layoutId**
   */
  async delete(
    layoutId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.LayoutsControllerDeleteResponse | undefined> {
    return unwrapAsync(layoutsDelete(
      this,
      layoutId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Duplicate a layout
   *
   * @remarks
   * Duplicates a layout by its unique identifier **layoutId**. This will create a new layout with the content of the original layout.
   */
  async duplicate(
    duplicateLayoutDto: components.DuplicateLayoutDto,
    layoutId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.LayoutsControllerDuplicateResponse> {
    return unwrapAsync(layoutsDuplicate(
      this,
      duplicateLayoutDto,
      layoutId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Generate layout preview
   *
   * @remarks
   * Generates a preview for a layout by its unique identifier **layoutId**
   */
  async generatePreview(
    layoutPreviewRequestDto: components.LayoutPreviewRequestDto,
    layoutId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.LayoutsControllerGeneratePreviewResponse> {
    return unwrapAsync(layoutsGeneratePreview(
      this,
      layoutPreviewRequestDto,
      layoutId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Get layout usage
   *
   * @remarks
   * Retrieves information about workflows that use the specified layout by its unique identifier **layoutId**
   */
  async usage(
    layoutId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.LayoutsControllerGetUsageResponse> {
    return unwrapAsync(layoutsUsage(
      this,
      layoutId,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Layouts

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/master.ts
Tamaño: 1998 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { translationsMasterImport } from "../funcs/translationsMasterImport.js";
import { translationsMasterRetrieve } from "../funcs/translationsMasterRetrieve.js";
import { translationsMasterUpload } from "../funcs/translationsMasterUpload.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Master extends ClientSDK {
  /**
   * Retrieve master translations JSON
   *
   * @remarks
   * Retrieve all translations for a locale in master JSON format organized by resourceId (workflowId)
   */
  async retrieve(
    locale?: string | undefined,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<components.GetMasterJsonResponseDto> {
    return unwrapAsync(translationsMasterRetrieve(
      this,
      locale,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Import master translations JSON
   *
   * @remarks
   * Import translations for multiple workflows from master JSON format for a specific locale
   */
  async import(
    importMasterJsonRequestDto: components.ImportMasterJsonRequestDto,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<components.ImportMasterJsonResponseDto> {
    return unwrapAsync(translationsMasterImport(
      this,
      importMasterJsonRequestDto,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Upload master translations JSON file
   *
   * @remarks
   * Upload a master JSON file containing translations for multiple workflows. Locale is automatically detected from filename (e.g., en_US.json)
   */
  async upload(
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<components.ImportMasterJsonResponseDto> {
    return unwrapAsync(translationsMasterUpload(
      this,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Master

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/messages.ts
Tamaño: 2254 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { messagesDelete } from "../funcs/messagesDelete.js";
import { messagesDeleteByTransactionId } from "../funcs/messagesDeleteByTransactionId.js";
import { messagesRetrieve } from "../funcs/messagesRetrieve.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Messages extends ClientSDK {
  /**
   * List all messages
   *
   * @remarks
   * List all messages for the current environment.
   *     This API supports filtering by **channel**, **subscriberId**, and **transactionId**.
   *     This API returns a paginated list of messages.
   */
  async retrieve(
    request: operations.MessagesControllerGetMessagesRequest,
    options?: RequestOptions,
  ): Promise<operations.MessagesControllerGetMessagesResponse> {
    return unwrapAsync(messagesRetrieve(
      this,
      request,
      options,
    ));
  }

  /**
   * Delete a message
   *
   * @remarks
   * Delete a message entity from the Novu platform by **messageId**.
   *     This action is irreversible. **messageId** is required and of mongodbId type.
   */
  async delete(
    messageId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.MessagesControllerDeleteMessageResponse> {
    return unwrapAsync(messagesDelete(
      this,
      messageId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Delete messages by transactionId
   *
   * @remarks
   * Delete multiple messages from the Novu platform using **transactionId** of triggered event.
   *     This API supports filtering by **channel** and delete all messages associated with the **transactionId**.
   */
  async deleteByTransactionId(
    transactionId: string,
    channel?: operations.Channel | undefined,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<
    | operations.MessagesControllerDeleteMessagesByTransactionIdResponse
    | undefined
  > {
    return unwrapAsync(messagesDeleteByTransactionId(
      this,
      transactionId,
      channel,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Messages

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/notifications.ts
Tamaño: 1788 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { notificationsList } from "../funcs/notificationsList.js";
import { notificationsRetrieve } from "../funcs/notificationsRetrieve.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Notifications extends ClientSDK {
  /**
   * List all events
   *
   * @remarks
   * List all notification events (triggered events) for the current environment.
   *     This API supports filtering by **channels**, **templates**, **emails**, **subscriberIds**, **transactionId**, **topicKey**.
   *     Checkout all available filters in the query section.
   *     This API returns event triggers, to list each channel notifications, check messages APIs.
   */
  async list(
    request: operations.NotificationsControllerListNotificationsRequest,
    options?: RequestOptions,
  ): Promise<operations.NotificationsControllerListNotificationsResponse> {
    return unwrapAsync(notificationsList(
      this,
      request,
      options,
    ));
  }

  /**
   * Retrieve an event
   *
   * @remarks
   * Retrieve an event by its unique key identifier **notificationId**.
   *     Here **notificationId** is of mongodbId type.
   *     This API returns the event details - execution logs, status, actual notification (message) generated by each workflow step.
   */
  async retrieve(
    notificationId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.NotificationsControllerGetNotificationResponse> {
    return unwrapAsync(notificationsRetrieve(
      this,
      notificationId,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Notifications

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/novumessages.ts
Tamaño: 2478 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { subscribersMessagesMarkAll } from "../funcs/subscribersMessagesMarkAll.js";
import { subscribersMessagesMarkAllAs } from "../funcs/subscribersMessagesMarkAllAs.js";
import { subscribersMessagesUpdateAsSeen } from "../funcs/subscribersMessagesUpdateAsSeen.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class NovuMessages extends ClientSDK {
  /**
   * Update notification action status
   *
   * @remarks
   * Update in-app (inbox) notification's action status by its unique key identifier **messageId** and type field **type**.
   *       **type** field can be **primary** or **secondary**
   */
  async updateAsSeen(
    request: operations.SubscribersV1ControllerMarkActionAsSeenRequest,
    options?: RequestOptions,
  ): Promise<operations.SubscribersV1ControllerMarkActionAsSeenResponse> {
    return unwrapAsync(subscribersMessagesUpdateAsSeen(
      this,
      request,
      options,
    ));
  }

  /**
   * Update all notifications state
   *
   * @remarks
   * Update all subscriber in-app (inbox) notifications state such as read, unread, seen or unseen by **subscriberId**.
   */
  async markAll(
    markAllMessageAsRequestDto: components.MarkAllMessageAsRequestDto,
    subscriberId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.SubscribersV1ControllerMarkAllUnreadAsReadResponse> {
    return unwrapAsync(subscribersMessagesMarkAll(
      this,
      markAllMessageAsRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Update notifications state
   *
   * @remarks
   * Update subscriber's multiple in-app (inbox) notifications state such as seen, read, unseen or unread by **subscriberId**.
   *       **messageId** is of type mongodbId of notifications
   */
  async markAllAs(
    messageMarkAsRequestDto: components.MessageMarkAsRequestDto,
    subscriberId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.SubscribersV1ControllerMarkMessagesAsResponse> {
    return unwrapAsync(subscribersMessagesMarkAllAs(
      this,
      messageMarkAsRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class NovuMessages

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/novunotifications.ts
Tamaño: 1468 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { subscribersNotificationsFeed } from "../funcs/subscribersNotificationsFeed.js";
import { subscribersNotificationsUnseenCount } from "../funcs/subscribersNotificationsUnseenCount.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class NovuNotifications extends ClientSDK {
  /**
   * Retrieve subscriber notifications
   *
   * @remarks
   * Retrieve subscriber in-app (inbox) notifications by its unique key identifier **subscriberId**.
   */
  async feed(
    request: operations.SubscribersV1ControllerGetNotificationsFeedRequest,
    options?: RequestOptions,
  ): Promise<operations.SubscribersV1ControllerGetNotificationsFeedResponse> {
    return unwrapAsync(subscribersNotificationsFeed(
      this,
      request,
      options,
    ));
  }

  /**
   * Retrieve unseen notifications count
   *
   * @remarks
   * Retrieve unseen in-app (inbox) notifications count for a subscriber by its unique key identifier **subscriberId**.
   */
  async unseenCount(
    request: operations.SubscribersV1ControllerGetUnseenCountRequest,
    options?: RequestOptions,
  ): Promise<operations.SubscribersV1ControllerGetUnseenCountResponse> {
    return unwrapAsync(subscribersNotificationsUnseenCount(
      this,
      request,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class NovuNotifications

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/novusubscribers.ts
Tamaño: 864 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { topicsSubscribersRetrieve } from "../funcs/topicsSubscribersRetrieve.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class NovuSubscribers extends ClientSDK {
  /**
   * Check topic subscriber
   *
   * @remarks
   * Check if a subscriber belongs to a certain topic
   */
  async retrieve(
    topicKey: string,
    externalSubscriberId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.TopicsV1ControllerGetTopicSubscriberResponse> {
    return unwrapAsync(topicsSubscribersRetrieve(
      this,
      topicKey,
      externalSubscriberId,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class NovuSubscribers

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/novutopics.ts
Tamaño: 887 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { subscribersTopicsList } from "../funcs/subscribersTopicsList.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class NovuTopics extends ClientSDK {
  /**
   * Retrieve subscriber subscriptions
   *
   * @remarks
   * Retrieve subscriber's topic subscriptions by its unique key identifier **subscriberId**.
   *     Checkout all available filters in the query section.
   */
  async list(
    request: operations.SubscribersControllerListSubscriberTopicsRequest,
    options?: RequestOptions,
  ): Promise<operations.SubscribersControllerListSubscriberTopicsResponse> {
    return unwrapAsync(subscribersTopicsList(
      this,
      request,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class NovuTopics

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/preferences.ts
Tamaño: 2767 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { subscribersPreferencesBulkUpdate } from "../funcs/subscribersPreferencesBulkUpdate.js";
import { subscribersPreferencesList } from "../funcs/subscribersPreferencesList.js";
import { subscribersPreferencesUpdate } from "../funcs/subscribersPreferencesUpdate.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Preferences extends ClientSDK {
  /**
   * Retrieve subscriber preferences
   *
   * @remarks
   * Retrieve subscriber channel preferences by its unique key identifier **subscriberId**.
   *     This API returns all five channels preferences for all workflows and global preferences.
   */
  async list(
    subscriberId: string,
    criticality?: operations.Criticality | undefined,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.SubscribersControllerGetSubscriberPreferencesResponse> {
    return unwrapAsync(subscribersPreferencesList(
      this,
      subscriberId,
      criticality,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Update subscriber preferences
   *
   * @remarks
   * Update subscriber preferences by its unique key identifier **subscriberId**.
   *     **workflowId** is optional field, if provided, this API will update that workflow preference,
   *     otherwise it will update global preferences
   */
  async update(
    patchSubscriberPreferencesDto: components.PatchSubscriberPreferencesDto,
    subscriberId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<
    operations.SubscribersControllerUpdateSubscriberPreferencesResponse
  > {
    return unwrapAsync(subscribersPreferencesUpdate(
      this,
      patchSubscriberPreferencesDto,
      subscriberId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Bulk update subscriber preferences
   *
   * @remarks
   * Bulk update subscriber preferences by its unique key identifier **subscriberId**.
   *     This API allows updating multiple workflow preferences in a single request.
   */
  async bulkUpdate(
    bulkUpdateSubscriberPreferencesDto:
      components.BulkUpdateSubscriberPreferencesDto,
    subscriberId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<
    operations.SubscribersControllerBulkUpdateSubscriberPreferencesResponse
  > {
    return unwrapAsync(subscribersPreferencesBulkUpdate(
      this,
      bulkUpdateSubscriberPreferencesDto,
      subscriberId,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Preferences

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/properties.ts
Tamaño: 1114 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { subscribersPropertiesUpdateOnlineFlag } from "../funcs/subscribersPropertiesUpdateOnlineFlag.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Properties extends ClientSDK {
  /**
   * Update subscriber online status
   *
   * @remarks
   * Update the subscriber online status by its unique key identifier **subscriberId**
   */
  async updateOnlineFlag(
    updateSubscriberOnlineFlagRequestDto:
      components.UpdateSubscriberOnlineFlagRequestDto,
    subscriberId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<
    operations.SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse
  > {
    return unwrapAsync(subscribersPropertiesUpdateOnlineFlag(
      this,
      updateSubscriberOnlineFlagRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Properties

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/requests.ts
Tamaño: 1332 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { activityRequestsList } from "../funcs/activityRequestsList.js";
import { activityRequestsRetrieve } from "../funcs/activityRequestsRetrieve.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Requests extends ClientSDK {
  /**
   * List activity requests
   *
   * @remarks
   * Retrieve a list of activity requests with optional filtering and pagination.
   */
  async list(
    request: operations.ActivityControllerGetLogsRequest,
    options?: RequestOptions,
  ): Promise<components.GetRequestsResponseDto> {
    return unwrapAsync(activityRequestsList(
      this,
      request,
      options,
    ));
  }

  /**
   * Retrieve activity request
   *
   * @remarks
   * Retrieve detailed traces and information for a specific activity request by ID.
   */
  async retrieve(
    requestId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<components.GetRequestResponseDto> {
    return unwrapAsync(activityRequestsRetrieve(
      this,
      requestId,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Requests

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/sdk.ts
Tamaño: 5179 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { cancel } from "../funcs/cancel.js";
import { trigger } from "../funcs/trigger.js";
import { triggerBroadcast } from "../funcs/triggerBroadcast.js";
import { triggerBulk } from "../funcs/triggerBulk.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { Activity } from "./activity.js";
import { Contexts } from "./contexts.js";
import { Environments } from "./environments.js";
import { Integrations } from "./integrations.js";
import { Layouts } from "./layouts.js";
import { Messages } from "./messages.js";
import { Notifications } from "./notifications.js";
import { Subscribers } from "./subscribers.js";
import { Topics } from "./topics.js";
import { Translations } from "./translations.js";
import { Workflows } from "./workflows.js";

export class Novu extends ClientSDK {
  private _contexts?: Contexts;
  get contexts(): Contexts {
    return (this._contexts ??= new Contexts(this._options));
  }

  private _environments?: Environments;
  get environments(): Environments {
    return (this._environments ??= new Environments(this._options));
  }

  private _activity?: Activity;
  get activity(): Activity {
    return (this._activity ??= new Activity(this._options));
  }

  private _layouts?: Layouts;
  get layouts(): Layouts {
    return (this._layouts ??= new Layouts(this._options));
  }

  private _subscribers?: Subscribers;
  get subscribers(): Subscribers {
    return (this._subscribers ??= new Subscribers(this._options));
  }

  private _topics?: Topics;
  get topics(): Topics {
    return (this._topics ??= new Topics(this._options));
  }

  private _translations?: Translations;
  get translations(): Translations {
    return (this._translations ??= new Translations(this._options));
  }

  private _workflows?: Workflows;
  get workflows(): Workflows {
    return (this._workflows ??= new Workflows(this._options));
  }

  private _integrations?: Integrations;
  get integrations(): Integrations {
    return (this._integrations ??= new Integrations(this._options));
  }

  private _messages?: Messages;
  get messages(): Messages {
    return (this._messages ??= new Messages(this._options));
  }

  private _notifications?: Notifications;
  get notifications(): Notifications {
    return (this._notifications ??= new Notifications(this._options));
  }

  /**
   * Trigger event
   *
   * @remarks
   *
   *     Trigger event is the main (and only) way to send notifications to subscribers. The trigger identifier is used to match the particular workflow associated with it. Additional information can be passed according the body interface below.
   *     To prevent duplicate triggers, you can optionally pass a **transactionId** in the request body. If the same **transactionId** is used again, the trigger will be ignored. The retention period depends on your billing tier.
   */
  async trigger(
    triggerEventRequestDto: components.TriggerEventRequestDto,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.EventsControllerTriggerResponse> {
    return unwrapAsync(trigger(
      this,
      triggerEventRequestDto,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Cancel triggered event
   *
   * @remarks
   *
   *     Using a previously generated transactionId during the event trigger,
   *      will cancel any active or pending workflows. This is useful to cancel active digests, delays etc...
   */
  async cancel(
    transactionId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.EventsControllerCancelResponse> {
    return unwrapAsync(cancel(
      this,
      transactionId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Broadcast event to all
   *
   * @remarks
   * Trigger a broadcast event to all existing subscribers, could be used to send announcements, etc.
   *       In the future could be used to trigger events to a subset of subscribers based on defined filters.
   */
  async triggerBroadcast(
    triggerEventToAllRequestDto: components.TriggerEventToAllRequestDto,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.EventsControllerBroadcastEventToAllResponse> {
    return unwrapAsync(triggerBroadcast(
      this,
      triggerEventToAllRequestDto,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Bulk trigger event
   *
   * @remarks
   *
   *       Using this endpoint you can trigger multiple events at once, to avoid multiple calls to the API.
   *       The bulk API is limited to 100 events per request.
   */
  async triggerBulk(
    bulkTriggerEventDto: components.BulkTriggerEventDto,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.EventsControllerTriggerBulkResponse> {
    return unwrapAsync(triggerBulk(
      this,
      bulkTriggerEventDto,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Novu

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/steps.ts
Tamaño: 1360 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { workflowsStepsGeneratePreview } from "../funcs/workflowsStepsGeneratePreview.js";
import { workflowsStepsRetrieve } from "../funcs/workflowsStepsRetrieve.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Steps extends ClientSDK {
  /**
   * Generate step preview
   *
   * @remarks
   * Generates a preview for a specific workflow step by its unique identifier **stepId**
   */
  async generatePreview(
    request: operations.WorkflowControllerGeneratePreviewRequest,
    options?: RequestOptions,
  ): Promise<operations.WorkflowControllerGeneratePreviewResponse> {
    return unwrapAsync(workflowsStepsGeneratePreview(
      this,
      request,
      options,
    ));
  }

  /**
   * Retrieve workflow step
   *
   * @remarks
   * Retrieves data for a specific step in a workflow
   */
  async retrieve(
    workflowId: string,
    stepId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.WorkflowControllerGetWorkflowStepDataResponse> {
    return unwrapAsync(workflowsStepsRetrieve(
      this,
      workflowId,
      stepId,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Steps

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/subscribers.ts
Tamaño: 5362 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { subscribersCreate } from "../funcs/subscribersCreate.js";
import { subscribersCreateBulk } from "../funcs/subscribersCreateBulk.js";
import { subscribersDelete } from "../funcs/subscribersDelete.js";
import { subscribersPatch } from "../funcs/subscribersPatch.js";
import { subscribersRetrieve } from "../funcs/subscribersRetrieve.js";
import { subscribersSearch } from "../funcs/subscribersSearch.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { Credentials } from "./credentials.js";
import { NovuMessages } from "./novumessages.js";
import { NovuNotifications } from "./novunotifications.js";
import { NovuTopics } from "./novutopics.js";
import { Preferences } from "./preferences.js";
import { Properties } from "./properties.js";

export class Subscribers extends ClientSDK {
  private _preferences?: Preferences;
  get preferences(): Preferences {
    return (this._preferences ??= new Preferences(this._options));
  }

  private _topics?: NovuTopics;
  get topics(): NovuTopics {
    return (this._topics ??= new NovuTopics(this._options));
  }

  private _credentials?: Credentials;
  get credentials(): Credentials {
    return (this._credentials ??= new Credentials(this._options));
  }

  private _messages?: NovuMessages;
  get messages(): NovuMessages {
    return (this._messages ??= new NovuMessages(this._options));
  }

  private _notifications?: NovuNotifications;
  get notifications(): NovuNotifications {
    return (this._notifications ??= new NovuNotifications(this._options));
  }

  private _properties?: Properties;
  get properties(): Properties {
    return (this._properties ??= new Properties(this._options));
  }

  /**
   * Search subscribers
   *
   * @remarks
   * Search subscribers by their **email**, **phone**, **subscriberId** and **name**.
   *     The search is case sensitive and supports pagination.Checkout all available filters in the query section.
   */
  async search(
    request: operations.SubscribersControllerSearchSubscribersRequest,
    options?: RequestOptions,
  ): Promise<operations.SubscribersControllerSearchSubscribersResponse> {
    return unwrapAsync(subscribersSearch(
      this,
      request,
      options,
    ));
  }

  /**
   * Create a subscriber
   *
   * @remarks
   * Create a subscriber with the subscriber attributes.
   *       **subscriberId** is a required field, rest other fields are optional, if the subscriber already exists, it will be updated
   */
  async create(
    createSubscriberRequestDto: components.CreateSubscriberRequestDto,
    failIfExists?: boolean | undefined,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.SubscribersControllerCreateSubscriberResponse> {
    return unwrapAsync(subscribersCreate(
      this,
      createSubscriberRequestDto,
      failIfExists,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Retrieve a subscriber
   *
   * @remarks
   * Retrieve a subscriber by its unique key identifier **subscriberId**.
   *     **subscriberId** field is required.
   */
  async retrieve(
    subscriberId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.SubscribersControllerGetSubscriberResponse> {
    return unwrapAsync(subscribersRetrieve(
      this,
      subscriberId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Update a subscriber
   *
   * @remarks
   * Update a subscriber by its unique key identifier **subscriberId**.
   *     **subscriberId** is a required field, rest other fields are optional
   */
  async patch(
    patchSubscriberRequestDto: components.PatchSubscriberRequestDto,
    subscriberId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.SubscribersControllerPatchSubscriberResponse> {
    return unwrapAsync(subscribersPatch(
      this,
      patchSubscriberRequestDto,
      subscriberId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Delete a subscriber
   *
   * @remarks
   * Deletes a subscriber entity from the Novu platform along with associated messages, preferences, and topic subscriptions.
   *       **subscriberId** is a required field.
   */
  async delete(
    subscriberId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.SubscribersControllerRemoveSubscriberResponse> {
    return unwrapAsync(subscribersDelete(
      this,
      subscriberId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Bulk create subscribers
   *
   * @remarks
   *
   *       Using this endpoint multiple subscribers can be created at once. The bulk API is limited to 500 subscribers per request.
   */
  async createBulk(
    bulkSubscriberCreateDto: components.BulkSubscriberCreateDto,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.SubscribersV1ControllerBulkCreateSubscribersResponse> {
    return unwrapAsync(subscribersCreateBulk(
      this,
      bulkSubscriberCreateDto,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Subscribers

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/subscriptions.ts
Tamaño: 2324 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { topicsSubscriptionsCreate } from "../funcs/topicsSubscriptionsCreate.js";
import { topicsSubscriptionsDelete } from "../funcs/topicsSubscriptionsDelete.js";
import { topicsSubscriptionsList } from "../funcs/topicsSubscriptionsList.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Subscriptions extends ClientSDK {
  /**
   * List topic subscriptions
   *
   * @remarks
   * List all subscriptions of subscribers for a topic.
   *     Checkout all available filters in the query section.
   */
  async list(
    request: operations.TopicsControllerListTopicSubscriptionsRequest,
    options?: RequestOptions,
  ): Promise<operations.TopicsControllerListTopicSubscriptionsResponse> {
    return unwrapAsync(topicsSubscriptionsList(
      this,
      request,
      options,
    ));
  }

  /**
   * Create topic subscriptions
   *
   * @remarks
   * This api will create subscription for subscriberIds for a topic.
   *       Its like subscribing to a common interest group. if topic does not exist, it will be created.
   */
  async create(
    createTopicSubscriptionsRequestDto:
      components.CreateTopicSubscriptionsRequestDto,
    topicKey: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.TopicsControllerCreateTopicSubscriptionsResponse> {
    return unwrapAsync(topicsSubscriptionsCreate(
      this,
      createTopicSubscriptionsRequestDto,
      topicKey,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Delete topic subscriptions
   *
   * @remarks
   * Delete subscriptions for subscriberIds for a topic.
   */
  async delete(
    deleteTopicSubscriptionsRequestDto:
      components.DeleteTopicSubscriptionsRequestDto,
    topicKey: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.TopicsControllerDeleteTopicSubscriptionsResponse> {
    return unwrapAsync(topicsSubscriptionsDelete(
      this,
      deleteTopicSubscriptionsRequestDto,
      topicKey,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Subscriptions

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/topics.ts
Tamaño: 3553 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { topicsCreate } from "../funcs/topicsCreate.js";
import { topicsDelete } from "../funcs/topicsDelete.js";
import { topicsGet } from "../funcs/topicsGet.js";
import { topicsList } from "../funcs/topicsList.js";
import { topicsUpdate } from "../funcs/topicsUpdate.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { NovuSubscribers } from "./novusubscribers.js";
import { Subscriptions } from "./subscriptions.js";

export class Topics extends ClientSDK {
  private _subscriptions?: Subscriptions;
  get subscriptions(): Subscriptions {
    return (this._subscriptions ??= new Subscriptions(this._options));
  }

  private _subscribers?: NovuSubscribers;
  get subscribers(): NovuSubscribers {
    return (this._subscribers ??= new NovuSubscribers(this._options));
  }

  /**
   * List all topics
   *
   * @remarks
   * This api returns a paginated list of topics.
   *     Topics can be filtered by **key**, **name**, or **includeCursor** to paginate through the list.
   *     Checkout all available filters in the query section.
   */
  async list(
    request: operations.TopicsControllerListTopicsRequest,
    options?: RequestOptions,
  ): Promise<operations.TopicsControllerListTopicsResponse> {
    return unwrapAsync(topicsList(
      this,
      request,
      options,
    ));
  }

  /**
   * Create a topic
   *
   * @remarks
   * Creates a new topic if it does not exist, or updates an existing topic if it already exists. Use ?failIfExists=true to prevent updates.
   */
  async create(
    createUpdateTopicRequestDto: components.CreateUpdateTopicRequestDto,
    failIfExists?: boolean | undefined,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.TopicsControllerUpsertTopicResponse> {
    return unwrapAsync(topicsCreate(
      this,
      createUpdateTopicRequestDto,
      failIfExists,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Retrieve a topic
   *
   * @remarks
   * Retrieve a topic by its unique key identifier **topicKey**
   */
  async get(
    topicKey: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.TopicsControllerGetTopicResponse> {
    return unwrapAsync(topicsGet(
      this,
      topicKey,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Update a topic
   *
   * @remarks
   * Update a topic name by its unique key identifier **topicKey**
   */
  async update(
    updateTopicRequestDto: components.UpdateTopicRequestDto,
    topicKey: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.TopicsControllerUpdateTopicResponse> {
    return unwrapAsync(topicsUpdate(
      this,
      updateTopicRequestDto,
      topicKey,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Delete a topic
   *
   * @remarks
   * Delete a topic by its unique key identifier **topicKey**.
   *     This action is irreversible and will remove all subscriptions to the topic.
   */
  async delete(
    topicKey: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.TopicsControllerDeleteTopicResponse> {
    return unwrapAsync(topicsDelete(
      this,
      topicKey,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Topics

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/translations.ts
Tamaño: 2791 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { translationsCreate } from "../funcs/translationsCreate.js";
import { translationsDelete } from "../funcs/translationsDelete.js";
import { translationsRetrieve } from "../funcs/translationsRetrieve.js";
import { translationsUpload } from "../funcs/translationsUpload.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { Groups } from "./groups.js";
import { Master } from "./master.js";

export class Translations extends ClientSDK {
  private _groups?: Groups;
  get groups(): Groups {
    return (this._groups ??= new Groups(this._options));
  }

  private _master?: Master;
  get master(): Master {
    return (this._master ??= new Master(this._options));
  }

  /**
   * Create a translation
   *
   * @remarks
   * Create a translation for a specific workflow and locale, if the translation already exists, it will be updated
   */
  async create(
    createTranslationRequestDto: components.CreateTranslationRequestDto,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<components.TranslationResponseDto> {
    return unwrapAsync(translationsCreate(
      this,
      createTranslationRequestDto,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Retrieve a translation
   *
   * @remarks
   * Retrieve a specific translation by resource type, resource ID and locale
   */
  async retrieve(
    request: operations.TranslationControllerGetSingleTranslationRequest,
    options?: RequestOptions,
  ): Promise<components.TranslationResponseDto> {
    return unwrapAsync(translationsRetrieve(
      this,
      request,
      options,
    ));
  }

  /**
   * Delete a translation
   *
   * @remarks
   * Delete a specific translation by resource type, resource ID and locale
   */
  async delete(
    request: operations.TranslationControllerDeleteTranslationEndpointRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(translationsDelete(
      this,
      request,
      options,
    ));
  }

  /**
   * Upload translation files
   *
   * @remarks
   * Upload one or more JSON translation files for a specific workflow. Files name must match the locale, e.g. en_US.json
   */
  async upload(
    uploadTranslationsRequestDto: components.UploadTranslationsRequestDto,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<components.UploadTranslationsResponseDto> {
    return unwrapAsync(translationsUpload(
      this,
      uploadTranslationsRequestDto,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Translations

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/workflowruns.ts
Tamaño: 1357 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { activityWorkflowRunsList } from "../funcs/activityWorkflowRunsList.js";
import { activityWorkflowRunsRetrieve } from "../funcs/activityWorkflowRunsRetrieve.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class WorkflowRuns extends ClientSDK {
  /**
   * List workflow runs
   *
   * @remarks
   * Retrieve a list of workflow runs with optional filtering and pagination.
   */
  async list(
    request: operations.ActivityControllerGetWorkflowRunsRequest,
    options?: RequestOptions,
  ): Promise<components.GetWorkflowRunsResponseDto> {
    return unwrapAsync(activityWorkflowRunsList(
      this,
      request,
      options,
    ));
  }

  /**
   * Retrieve workflow run
   *
   * @remarks
   * Retrieve detailed information for a specific workflow run by ID.
   */
  async retrieve(
    workflowRunId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<components.GetWorkflowRunResponseDto> {
    return unwrapAsync(activityWorkflowRunsRetrieve(
      this,
      workflowRunId,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class WorkflowRuns

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/sdk/workflows.ts
Tamaño: 4834 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { workflowsCreate } from "../funcs/workflowsCreate.js";
import { workflowsDelete } from "../funcs/workflowsDelete.js";
import { workflowsDuplicate } from "../funcs/workflowsDuplicate.js";
import { workflowsGet } from "../funcs/workflowsGet.js";
import { workflowsList } from "../funcs/workflowsList.js";
import { workflowsPatch } from "../funcs/workflowsPatch.js";
import { workflowsSync } from "../funcs/workflowsSync.js";
import { workflowsUpdate } from "../funcs/workflowsUpdate.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { Steps } from "./steps.js";

export class Workflows extends ClientSDK {
  private _steps?: Steps;
  get steps(): Steps {
    return (this._steps ??= new Steps(this._options));
  }

  /**
   * Create a workflow
   *
   * @remarks
   * Creates a new workflow in the Novu Cloud environment
   */
  async create(
    createWorkflowDto: components.CreateWorkflowDto,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.WorkflowControllerCreateResponse> {
    return unwrapAsync(workflowsCreate(
      this,
      createWorkflowDto,
      idempotencyKey,
      options,
    ));
  }

  /**
   * List all workflows
   *
   * @remarks
   * Retrieves a list of workflows with optional filtering and pagination
   */
  async list(
    request: operations.WorkflowControllerSearchWorkflowsRequest,
    options?: RequestOptions,
  ): Promise<operations.WorkflowControllerSearchWorkflowsResponse> {
    return unwrapAsync(workflowsList(
      this,
      request,
      options,
    ));
  }

  /**
   * Update a workflow
   *
   * @remarks
   * Updates the details of an existing workflow, here **workflowId** is the identifier of the workflow
   */
  async update(
    updateWorkflowDto: components.UpdateWorkflowDto,
    workflowId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.WorkflowControllerUpdateResponse> {
    return unwrapAsync(workflowsUpdate(
      this,
      updateWorkflowDto,
      workflowId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Retrieve a workflow
   *
   * @remarks
   * Fetches details of a specific workflow by its unique identifier **workflowId**
   */
  async get(
    workflowId: string,
    environmentId?: string | undefined,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.WorkflowControllerGetWorkflowResponse> {
    return unwrapAsync(workflowsGet(
      this,
      workflowId,
      environmentId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Delete a workflow
   *
   * @remarks
   * Removes a specific workflow by its unique identifier **workflowId**
   */
  async delete(
    workflowId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.WorkflowControllerRemoveWorkflowResponse | undefined> {
    return unwrapAsync(workflowsDelete(
      this,
      workflowId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Update a workflow
   *
   * @remarks
   * Partially updates a workflow by its unique identifier **workflowId**
   */
  async patch(
    patchWorkflowDto: components.PatchWorkflowDto,
    workflowId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.WorkflowControllerPatchWorkflowResponse> {
    return unwrapAsync(workflowsPatch(
      this,
      patchWorkflowDto,
      workflowId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Duplicate a workflow
   *
   * @remarks
   * Duplicates a workflow by its unique identifier **workflowId**. This will create a new workflow with the same steps and settings.
   */
  async duplicate(
    duplicateWorkflowDto: components.DuplicateWorkflowDto,
    workflowId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.WorkflowControllerDuplicateWorkflowResponse> {
    return unwrapAsync(workflowsDuplicate(
      this,
      duplicateWorkflowDto,
      workflowId,
      idempotencyKey,
      options,
    ));
  }

  /**
   * Sync a workflow
   *
   * @remarks
   * Synchronizes a workflow to the target environment
   */
  async sync(
    syncWorkflowDto: components.SyncWorkflowDto,
    workflowId: string,
    idempotencyKey?: string | undefined,
    options?: RequestOptions,
  ): Promise<operations.WorkflowControllerSyncResponse> {
    return unwrapAsync(workflowsSync(
      this,
      syncWorkflowDto,
      workflowId,
      idempotencyKey,
      options,
    ));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Workflows

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/types/async.ts
Tamaño: 1634 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

export type APICall =
  | {
      status: "complete";
      request: Request;
      response: Response;
    }
  | {
      status: "request-error";
      request: Request;
      response?: undefined;
    }
  | {
      status: "invalid";
      request?: undefined;
      response?: undefined;
    };

export class APIPromise<T> implements Promise<T> {
  readonly #promise: Promise<[T, APICall]>;
  readonly #unwrapped: Promise<T>;

  readonly [Symbol.toStringTag] = "APIPromise";

  constructor(p: [T, APICall] | Promise<[T, APICall]>) {
    this.#promise = p instanceof Promise ? p : Promise.resolve(p);
    this.#unwrapped =
      p instanceof Promise
        ? this.#promise.then(([value]) => value)
        : Promise.resolve(p[0]);
  }

  then<TResult1 = T, TResult2 = never>(
    onfulfilled?:
      | ((value: T) => TResult1 | PromiseLike<TResult1>)
      | null
      | undefined,
    onrejected?:
      | ((reason: any) => TResult2 | PromiseLike<TResult2>)
      | null
      | undefined,
  ): Promise<TResult1 | TResult2> {
    return this.#promise.then(
      onfulfilled ? ([value]) => onfulfilled(value) : void 0,
      onrejected,
    );
  }

  catch<TResult = never>(
    onrejected?:
      | ((reason: any) => TResult | PromiseLike<TResult>)
      | null
      | undefined,
  ): Promise<T | TResult> {
    return this.#unwrapped.catch(onrejected);
  }

  finally(onfinally?: (() => void) | null | undefined): Promise<T> {
    return this.#unwrapped.finally(onfinally);
  }

  $inspect(): Promise<[T, APICall]> {
    return this.#promise;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - unwrapped(p instanceof Promise
        ? this.#promise.then(([value]))
 - TResult2(never>(
    onfulfilled?:
      | ((value: T))
 - TResult(never>(
    onrejected?:
      | ((reason: any))
Declaraciones 'export' encontradas:
- export  type
- export class APIPromise

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/types/blobs.ts
Tamaño: 716 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';

export const blobLikeSchema: z.ZodType<Blob, z.ZodTypeDef, Blob> = z.custom<Blob>(isBlobLike, {
  message: 'expected a Blob, File or Blob-like object',
  fatal: true,
});

export function isBlobLike(val: unknown): val is Blob {
  if (val instanceof Blob) {
    return true;
  }

  if (typeof val !== 'object' || val == null || !(Symbol.toStringTag in val)) {
    return false;
  }

  const name = val[Symbol.toStringTag];
  if (typeof name !== 'string') {
    return false;
  }
  if (name !== 'Blob' && name !== 'File') {
    return false;
  }

  return 'stream' in val && typeof val.stream === 'function';
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - isBlobLike(val: unknown)
Declaraciones 'export' encontradas:
- export  const
- export function isBlobLike

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/types/constdatetime.ts
Tamaño: 362 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';

export function constDateTime(val: string): z.ZodType<string, z.ZodTypeDef, unknown> {
  return z.custom<string>((v) => {
    return typeof v === 'string' && new Date(v).getTime() === new Date(val).getTime();
  }, `Value must be equivalent to ${val}`);
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - constDateTime(val: string)
Declaraciones 'export' encontradas:
- export function constDateTime

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/types/enums.ts
Tamaño: 493 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

declare const __brand: unique symbol;
export type Unrecognized<T> = T & { [__brand]: "unrecognized" };

export function catchUnrecognizedEnum<T>(value: T): Unrecognized<T> {
  return value as Unrecognized<T>;
}

type Prettify<T> = { [K in keyof T]: T[K] } & {};
export type ClosedEnum<T> = T[keyof T];
export type OpenEnum<T> =
  | Prettify<T[keyof T]>
  | Unrecognized<T[keyof T] extends number ? number : string>;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export function catchUnrecognizedEnum
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/types/fp.ts
Tamaño: 1442 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

/**
 * A monad that captures the result of a function call or an error if it was not
 * successful. Railway programming, enabled by this type, can be a nicer
 * alternative to traditional exception throwing because it allows functions to
 * declare all _known_ errors with static types and then check for them
 * exhaustively in application code. Thrown exception have a type of `unknown`
 * and break out of regular control flow of programs making them harder to
 * inspect and more verbose work with due to try-catch blocks.
 */
export type Result<T, E = unknown> =
  | { ok: true; value: T; error?: never }
  | { ok: false; value?: never; error: E };

export function OK<V>(value: V): Result<V, never> {
  return { ok: true, value };
}

export function ERR<E>(error: E): Result<never, E> {
  return { ok: false, error };
}

/**
 * unwrap is a convenience function for extracting a value from a result or
 * throwing if there was an error.
 */
export function unwrap<T>(r: Result<T, unknown>): T {
  if (!r.ok) {
    throw r.error;
  }
  return r.value;
}

/**
 * unwrapAsync is a convenience function for resolving a value from a Promise
 * of a result or rejecting if an error occurred.
 */
export async function unwrapAsync<T>(
  pr: Promise<Result<T, unknown>>,
): Promise<T> {
  const r = await pr;
  if (!r.ok) {
    throw r.error;
  }

  return r.value;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export function OK
- export function ERR
- export function unwrap
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/types/index.ts
Tamaño: 453 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

export { blobLikeSchema, isBlobLike } from "./blobs.js";
export { catchUnrecognizedEnum } from "./enums.js";
export type { ClosedEnum, OpenEnum, Unrecognized } from "./enums.js";
export type { Result } from "./fp.js";
export type { PageIterator, Paginator } from "./operations.js";
export { createPageIterator } from "./operations.js";
export { RFCDate } from "./rfcdate.js";


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export  type
- export  type
- export  type
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/types/operations.ts
Tamaño: 2500 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { Result } from "./fp.js";

export type Paginator<V> = () => Promise<V & { next: Paginator<V> }> | null;

export type PageIterator<V, PageState = unknown> = V & {
  next: Paginator<V>;
  [Symbol.asyncIterator]: () => AsyncIterableIterator<V>;
  "~next"?: PageState | undefined;
};

export function createPageIterator<V>(
  page: V & { next: Paginator<V> },
  halt: (v: V) => boolean,
): {
  [Symbol.asyncIterator]: () => AsyncIterableIterator<V>;
} {
  return {
    [Symbol.asyncIterator]: async function* paginator() {
      yield page;
      if (halt(page)) {
        return;
      }

      let p: typeof page | null = page;
      for (p = await p.next(); p != null; p = await p.next()) {
        yield p;
        if (halt(p)) {
          return;
        }
      }
    },
  };
}

/**
 * This utility create a special iterator that yields a single value and
 * terminates. It is useful in paginated SDK functions that have early return
 * paths when things go wrong.
 */
export function haltIterator<V extends object>(
  v: V,
): PageIterator<V, undefined> {
  return {
    ...v,
    next: () => null,
    [Symbol.asyncIterator]: async function* paginator() {
      yield v;
    },
  };
}

/**
 * Converts an async iterator of `Result<V, E>` into an async iterator of `V`.
 * When error results occur, the underlying error value is thrown.
 */
export async function unwrapResultIterator<V, PageState>(
  iteratorPromise: Promise<PageIterator<Result<V, unknown>, PageState>>,
): Promise<PageIterator<V, PageState>> {
  const resultIter = await iteratorPromise;

  if (!resultIter.ok) {
    throw resultIter.error;
  }

  return {
    ...resultIter.value,
    next: unwrapPaginator(resultIter.next),
    "~next": resultIter["~next"],
    [Symbol.asyncIterator]: async function* paginator() {
      for await (const page of resultIter) {
        if (!page.ok) {
          throw page.error;
        }
        yield page.value;
      }
    },
  };
}

function unwrapPaginator<V>(
  paginator: Paginator<Result<V, unknown>>,
): Paginator<V> {
  return () => {
    const nextResult = paginator();
    if (nextResult == null) {
      return null;
    }
    return nextResult.then((res) => {
      if (!res.ok) {
        throw res.error;
      }
      const out = {
        ...res.value,
        next: unwrapPaginator(res.next),
      };
      return out;
    });
  };
}

export const URL_OVERRIDE = Symbol("URL_OVERRIDE");


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - p(await p.next()) {
        yield p;
        if (halt(p)) {
          return;
        }
      }
    },...)
 - resultIter(await iteratorPromise;

  if (!resultIter.ok) {
    throw resultIter.error;
  }

  return {
    ...r...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export function createPageIterator
- export function haltIterator
- export  async
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/types/rfcdate.ts
Tamaño: 1339 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

const dateRE = /^\d{4}-\d{2}-\d{2}$/;

export class RFCDate {
  private serialized: string;

  /**
   * Creates a new RFCDate instance using today's date.
   */
  static today(): RFCDate {
    return new RFCDate(new Date());
  }

  /**
   * Creates a new RFCDate instance using the provided input.
   * If a string is used then in must be in the format YYYY-MM-DD.
   *
   * @param date A Date object or a date string in YYYY-MM-DD format
   * @example
   * new RFCDate("2022-01-01")
   * @example
   * new RFCDate(new Date())
   */
  constructor(date: Date | string) {
    if (typeof date === "string" && !dateRE.test(date)) {
      throw new RangeError(
        "RFCDate: date strings must be in the format YYYY-MM-DD: " + date,
      );
    }

    const value = new Date(date);
    if (isNaN(+value)) {
      throw new RangeError("RFCDate: invalid date provided: " + date);
    }

    this.serialized = value.toISOString().slice(0, "YYYY-MM-DD".length);
    if (!dateRE.test(this.serialized)) {
      throw new TypeError(
        `RFCDate: failed to build valid date with given value: ${date} serialized to ${this.serialized}`,
      );
    }
  }

  toJSON(): string {
    return this.toString();
  }

  toString(): string {
    return this.serialized;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RFCDate

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/types/streams.ts
Tamaño: 572 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

export function isReadableStream<T = Uint8Array>(
  val: unknown,
): val is ReadableStream<T> {
  if (typeof val !== "object" || val === null) {
    return false;
  }

  // Check for the presence of methods specific to ReadableStream
  const stream = val as ReadableStream<Uint8Array>;

  // ReadableStream has methods like getReader, cancel, and tee
  return (
    typeof stream.getReader === "function" &&
    typeof stream.cancel === "function" &&
    typeof stream.tee === "function"
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export function isReadableStream

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/temp/example.ts
Tamaño: 115 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

const value: number = [object Object];

### ANALISIS AUTOMATICO (ESPAÑOL) ###

No se detectaron funciones/exportaciones con heurística JS/TS.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/notifications/.gitignore
Tamaño: 87 bytes
Lenguaje detectado: GITIGNORE

### CONTENIDO ORIGINAL ###

.idea/*
.nyc_output
build
node_modules
test
src/**.js
coverage
*.log
package-lock.json


### ANALISIS AUTOMATICO (ESPAÑOL) ###

.idea/*
.nyc_output
build
node_modules
test
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/notifications/README.md
Tamaño: 109 bytes
Lenguaje detectado: Markdown

### CONTENIDO ORIGINAL ###

# @novu/notifications

Reusable notification templates and workflows for the Novu platform.

## Installation


### ANALISIS AUTOMATICO (ESPAÑOL) ###

# @novu/notifications
Reusable notification templates and workflows for the Novu platform.
## Installation
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/notifications/package.json
Tamaño: 1336 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "name": "@novu/notifications",
  "version": "1.0.10",
  "description": "Novu notification templates and workflows",
  "main": "build/main/index.js",
  "typings": "build/main/index.d.ts",
  "module": "build/module/index.js",
  "private": true,
  "license": "MIT",
  "keywords": [],
  "scripts": {
    "build": "run-p build:*",
    "build:main": "tsc -p tsconfig.json",
    "build:module": "tsc -p tsconfig.module.json",
    "fix": "run-s fix:*",
    "check": "biome check .",
    "check:fix": "biome check --write .",
    "test": "echo 'Not tests available'",
    "test:watch": "echo 'Not tests available'",
    "watch:build": "tsc -p tsconfig.json -w",
    "reset-hard": "git clean -dfx && git reset --hard && pnpm install",
    "start:studio": "novu dev --port 3000 --route /v1/bridge/novu"
  },
  "dependencies": {
    "@react-email/components": "^0.0.15",
    "@novu/framework": "workspace:*",
    "@novu/shared": "workspace:*",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "typescript": "5.6.2",
    "npm-run-all": "^4.1.5",
    "novu": "workspace:*"
  },
  "files": [
    "build/main",
    "build/module",
    "!**/*.spec.*",
    "!**/*.json",
    "CHANGELOG.md",
    "LICENSE",
    "README.md"
  ]
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"name": "@novu/notifications",
"version": "1.0.10",
"description": "Novu notification templates and workflows",
"main": "build/main/index.js",
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/notifications/project.json
Tamaño: 265 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "name": "@novu/notifications",
  "sourceRoot": "libs/notifications/src",
  "projectType": "library",
  "targets": {
    "lint": {
      "executor": "nx:run-commands",
      "options": {
        "command": "npx biome lint libs/notifications"
      }
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"name": "@novu/notifications",
"sourceRoot": "libs/notifications/src",
"projectType": "library",
"targets": {
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/notifications/tsconfig.json
Tamaño: 496 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "sourceMap": true,
    "strictNullChecks": false,
    "allowSyntheticDefaultImports": true,
    "outDir": "build/main",
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true,
    "rootDir": "src",
    "strict": true,
    "types": ["node", "jest"],
    "jsx": "react",
    "typeRoots": ["./node_modules/@types", "../../node_modules/@types"]
  },
  "include": ["src/**/*.ts"],
  "exclude": ["node_modules/**"]
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"extends": "../../tsconfig.json",
"compilerOptions": {
"sourceMap": true,
"strictNullChecks": false,
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/notifications/tsconfig.module.json
Tamaño: 394 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "extends": "./tsconfig",
  "compilerOptions": {
    "sourceMap": true,
    "target": "esnext",
    "outDir": "build/module",
    "module": "esnext",
    "esModuleInterop": true,
    "types": ["jest", "node"],
    "jsx": "preserve",
    "typeRoots": ["./node_modules/@types", "../../node_modules/@types"]
  },
  "include": ["src/**/*.ts", "src/**/*.tsx"],
  "exclude": ["node_modules/**"]
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"extends": "./tsconfig",
"compilerOptions": {
"sourceMap": true,
"target": "esnext",
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/notifications/src/index.ts
Tamaño: 64 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './workflows/usage-limits/usage-limits.workflow';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/notifications/src/templates/layout.tsx
Tamaño: 908 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Body, Container, Head, Html, Img, Preview, Tailwind } from '@react-email/components';
import React from 'react';

interface IBaseEmailLayoutProps {
  previewText: string;
  children: React.ReactNode;
}

export function EmailLayout({ previewText, children }: IBaseEmailLayoutProps) {
  return (
    <Html>
      <Head />
      <Preview>{previewText}</Preview>
      <Tailwind>
        <Body className="mx-auto my-auto bg-white px-2 font-sans">
          <Container className="mx-auto my-[40px] max-w-[465px] rounded border border-solid border-[#eaeaea] p-[20px]">
            <Img
              src={`https://dashboard.novu.co/static/images/novu-colored-text.png`}
              width="100"
              height="37"
              alt="Novu"
              className="mx-auto my-[32px]"
            />
            {children}
          </Container>
        </Body>
      </Tailwind>
    </Html>
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Body, Container, Head, Html, Img, Preview, Tailwind } from '@react-email/components';
import React from 'react';
interface IBaseEmailLayoutProps {
previewText: string;
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/notifications/src/workflows/usage-limits/email.tsx
Tamaño: 2001 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Button, Heading, renderAsync, Section, Text } from '@react-email/components';
import React from 'react';
import { EmailLayout } from '../../templates/layout';

interface IEmailProps {
  percentage?: number;
  organizationName?: string;
  previewText?: string;
}

export function UsageLimitsEmail({ percentage, organizationName, previewText }: IEmailProps) {
  const roundedPercentage = Math.round(percentage || 0);

  return (
    <EmailLayout previewText={previewText}>
      <Heading className="mx-0 my-[30px] p-0 text-center text-[24px] font-normal text-black">
        Used {roundedPercentage}% of Your Monthly Events
      </Heading>
      <Text className="text-[14px] leading-[24px] text-black">
        Your organization {organizationName} has used {roundedPercentage}% of the free tier monthly limit of 30,000
        events.
      </Text>

      <Text className="text-[14px] leading-[24px] text-black">
        To ensure uninterrupted service and access to additional features, we recommend upgrading your plan before
        reaching the limit.
      </Text>

      <Section className="mb-[32px] mt-[32px] text-center">
        <Button
          className="rounded bg-[#000000] px-5 py-3 text-center text-[12px] font-semibold text-white no-underline"
          href={'https://dashboard.novu.co/settings/billing'}
        >
          Upgrade Your Plan
        </Button>
      </Section>

      <Text className="text-[12px] leading-[20px] text-gray-500">
        Note: Once you consume 100% of your monthly limit, notifications will be blocked until you upgrade or the next
        billing cycle begins. begins.
      </Text>
    </EmailLayout>
  );
}

export interface IRenderEmailPayload {
  percentage?: number;
  organizationName?: string;
}

export interface IEmailControls {
  previewText?: string;
}

export async function renderUsageLimitsEmail(payload: IRenderEmailPayload, controls: IEmailControls) {
  return renderAsync(<UsageLimitsEmail {...payload} {...controls} />);
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Button, Heading, renderAsync, Section, Text } from '@react-email/components';
import React from 'react';
import { EmailLayout } from '../../templates/layout';
interface IEmailProps {
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/notifications/src/workflows/usage-limits/usage-limits.workflow.ts
Tamaño: 1379 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { workflow } from '@novu/framework';
import { z } from 'zod';
import { renderUsageLimitsEmail } from './email';

export const usageLimitsWorkflow = workflow(
  'usage-limits',
  async ({ step, payload }) => {
    await step.digest('digest', async () => {
      return {
        amount: 5,
        unit: 'minutes',
      };
    });

    await step.email(
      'email',
      async (controls) => {
        return {
          subject: controls.subject,
          body: await renderUsageLimitsEmail(payload, controls),
        };
      },
      {
        controlSchema: z.object({
          subject: z.string().default('You are approaching your usage limits'),
          previewText: z.string().default('You have used {{payload.percentage}}% of your monthly events'),
        }),
      }
    );

    await step.inApp(
      'in-app',
      async (controls) => {
        return {
          subject: controls.subject,
          body: controls.body,
        };
      },
      {
        controlSchema: z.object({
          subject: z.string().default('You are approaching your usage limits'),
          body: z.string().default('You have used {{payload.percentage}}% of your monthly events'),
        }),
      }
    );
  },
  {
    name: 'Usage Limits Alert',
    payloadSchema: z.object({
      percentage: z.number().min(0),
      organizationName: z.string(),
    }),
  }
);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - usageLimitsWorkflow(workflow(
  'usage-limits',
  async ({ step, payload }))
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/.gitignore
Tamaño: 366 bytes
Lenguaje detectado: GITIGNORE

### CONTENIDO ORIGINAL ###

# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage


# production
build

.npmrc
.idea/*
.nyc_output

test

src/**.js
coverage
*.log
package-lock.json

storybook-static

## Panda
styled-system
styled-system-studio

# react-scanner
src/component-audit/component-scans


### ANALISIS AUTOMATICO (ESPAÑOL) ###

# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.
# dependencies
/node_modules
/.pnp
# testing
# production
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/package.json
Tamaño: 4660 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "name": "@novu/novui",
  "version": "2.0.1",
  "repository": "https://github.com/novuhq/novu",
  "description": "Novu's Design System & Component Library",
  "types": "./dist/index.d.ts",
  "main": "./dist/index.js",
  "files": [
    "dist",
    "styled-system"
  ],
  "exports": {
    ".": {
      "source": "./src/index.ts",
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js"
    },
    "./icons": {
      "source": "./src/icons/index.ts",
      "types": "./dist/icons/index.d.ts",
      "require": "./dist/icons/index.js",
      "import": "./dist/icons/index.js"
    },
    "./css": {
      "types": "./styled-system/css/index.d.ts",
      "require": "./styled-system/css/index.js",
      "import": "./styled-system/css/index.js"
    },
    "./tokens": {
      "types": "./styled-system/tokens/index.d.ts",
      "require": "./styled-system/tokens/index.js",
      "import": "./styled-system/tokens/index.js"
    },
    "./types": {
      "types": "./styled-system/types/index.d.ts",
      "require": "./styled-system/types/index.js",
      "import": "./styled-system/types/index.js"
    },
    "./patterns": {
      "types": "./styled-system/patterns/index.d.ts",
      "require": "./styled-system/patterns/index.js",
      "import": "./styled-system/patterns/index.js"
    },
    "./recipes": {
      "types": "./styled-system/recipes/index.d.ts",
      "require": "./styled-system/recipes/index.js",
      "import": "./styled-system/recipes/index.js"
    },
    "./jsx": {
      "types": "./styled-system/jsx/index.d.ts",
      "require": "./styled-system/jsx/index.js",
      "import": "./styled-system/jsx/index.js"
    },
    "./styles.css": "./src/index.css"
  },
  "scripts": {
    "dev": "pnpm build && pnpm storybook",
    "start": "npm run build:watch",
    "setup": "pnpm prepare:panda && pnpm build",
    "prepare:lib": "pnpm prepare:panda && pnpm prepare:audit",
    "prepare:panda": "pnpm panda codegen",
    "prepare:audit": "pnpm audit-components",
    "clean": "rimraf dist styled-system",
    "prebuild": "pnpm prepare:panda",
    "check": "biome check .",
    "check:fix": "biome check --write .",
    "build": "cross-env node_modules/.bin/tsc",
    "build:watch": "pnpm panda --watch & cross-env node_modules/.bin/tsc -w --preserveWatchOutput",
    "build:storybook": "pnpm panda && storybook build",
    "storybook": "pnpm panda --watch & storybook dev -p 6006",
    "studio": "pnpm panda studio",
    "audit-components": "pnpm react-scanner -c './react-scanner.config.js'"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@pandacss/dev": "^0.42.0",
    "@pandacss/studio": "^0.42.0",
    "@storybook/addon-actions": "8.1.0",
    "@storybook/addon-controls": "^8.1.0",
    "@storybook/addon-docs": "^8.1.0",
    "@storybook/react": "^8.1.0",
    "@storybook/react-vite": "^8.1.0",
    "@storybook/theming": "^8.1.0",
    "@storybook/types": "^8.1.0",
    "@testing-library/jest-dom": "^6.4.1",
    "@testing-library/react": "^12.1.5",
    "@testing-library/react-hooks": "^8.0.1",
    "@testing-library/user-event": "^14.5.2",
    "@types/node": "^20.15.0",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.0.3",
    "postcss": "^8.4.38",
    "postcss-preset-mantine": "^1.15.0",
    "postcss-simple-vars": "^7.0.1",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-scanner": "^1.2.0",
    "rimraf": "^3.0.2",
    "storybook": "^8.1.0",
    "storybook-dark-mode": "^4.0.1",
    "typescript": "5.6.2",
    "vite": "^4.5.2",
    "vite-tsconfig-paths": "^4.3.2",
    "vitest": "^1.2.1"
  },
  "peerDependencies": {
    "react": ">=17.0.0",
    "react-dom": ">=17.0.0"
  },
  "nx": {
    "targets": {
      "build-storybook": {
        "dependsOn": [
          "^build"
        ],
        "outputs": [
          "{projectRoot}/storybook-static"
        ],
        "inputs": [
          "{projectRoot}/.storybook",
          "{projectRoot}/src"
        ]
      }
    }
  },
  "dependencies": {
    "@mantine/code-highlight": "^7.12.1",
    "@mantine/core": "^7.12.1",
    "@mantine/hooks": "^7.12.1",
    "@mantine/tiptap": "^7.12.1",
    "@rjsf/core": "^5.20.0",
    "@rjsf/utils": "^5.20.0",
    "@rjsf/validator-ajv8": "^5.17.1",
    "@tanstack/react-table": "^8.17.3",
    "@tiptap/extension-document": "^2.6.6",
    "@tiptap/extension-history": "^2.6.6",
    "@tiptap/extension-mention": "^2.6.6",
    "@tiptap/extension-paragraph": "^2.6.6",
    "@tiptap/extension-text": "^2.6.6",
    "@tiptap/pm": "^2.6.6",
    "@tiptap/react": "^2.6.6",
    "@tiptap/suggestion": "^2.6.6",
    "react-icons": "5.0.1"
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"name": "@novu/novui",
"version": "2.0.1",
"repository": "https://github.com/novuhq/novu",
"description": "Novu's Design System & Component Library",
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/panda.config.ts
Tamaño: 1071 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { defineConfig } from '@pandacss/dev';
import { novuPandaPreset } from './src/panda-preset';

export default defineConfig({
  // Whether to use css reset
  preflight: true,

  /** Only allow defined values */
  strictTokens: true,

  // Where to look for your css declarations
  include: ['./src/**/*.{js,jsx,ts,tsx}', './.storybook/**/*.{js,jsx,ts,tsx}'],

  // Files to exclude
  exclude: ['./react-scanner.config.js'],

  presets: [novuPandaPreset],

  /**
   * Prefixes generated classes with the specified string (e.g. `nv-text_blue`)
   * https://panda-css.com/docs/references/config#prefix
   */
  prefix: 'nv',

  /*
   * Any additional configuration that is specific to design-system, but SHOULD NOT be propagated to
   * other apps or consumers. Use this sparingly!
   */
  theme: {
    extend: {},
  },

  importMap: 'styled-system',

  // extension of generated files
  outExtension: 'js',

  // The output directory for your css system
  outdir: 'styled-system',

  // Enables JSX util generation!
  jsxFramework: 'react',

  validation: 'error',
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export default  defineConfig

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/postcss.config.cjs
Tamaño: 607 bytes
Lenguaje detectado: CJS

### CONTENIDO ORIGINAL ###

module.exports = {
  /**
   * Must use array + require syntax for vite + postcss & panda
   * https://vitejs.dev/config/shared-options.html#css-postcss
   * https://panda-css.com/docs/installation/storybook#install-panda
   */
  plugins: [
    require('@pandacss/dev/postcss')(),
    require('postcss-preset-mantine')(),
    require('postcss-simple-vars')({
      variables: {
        'mantine-breakpoint-xs': '36em',
        'mantine-breakpoint-sm': '48em',
        'mantine-breakpoint-md': '62em',
        'mantine-breakpoint-lg': '75em',
        'mantine-breakpoint-xl': '88em',
      },
    }),
  ],
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

module.exports = {
/**
* Must use array + require syntax for vite + postcss & panda
* https://vitejs.dev/config/shared-options.html#css-postcss
* https://panda-css.com/docs/installation/storybook#install-panda
Contiene 'require' o 'module.exports' (posible Node.js).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/project.json
Tamaño: 528 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "name": "@novu/novui",
  "sourceRoot": "libs/novui/src",
  "projectType": "library",
  "targets": {
    "build": {
      "cache": false,
      "dependsOn": ["^build"],
      "inputs": [
        "default",
        "{projectRoot}/**/*",
        "!{projectRoot}/**/?(*.)+(spec|test).[jt]s?(x)?(.snap)",
        "!{projectRoot}/tsconfig.spec.json",
        "!{projectRoot}/jest.config.[jt]s"
      ],
      "outputs": ["{projectRoot}/dist", "{projectRoot}/build", "{projectRoot}/lib", "{projectRoot}/styled-system"]
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"name": "@novu/novui",
"sourceRoot": "libs/novui/src",
"projectType": "library",
"targets": {
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/react-scanner.config.js
Tamaño: 5043 bytes
Lenguaje detectado: JavaScript

### CONTENIDO ORIGINAL ###

/**
 * Configuration file for react-scanner: https://github.com/moroshko/react-scanner
 *
 * Used to assess usage of Mantine and Design System components in web.
 *
 * To use:
 * 1. Run `pnpm audit-components`
 * 2. Check `OUTPUT_PATH` for your scan results!
 */

/** the path of the scan output */
const OUTPUT_PATH = './src/component-audit/component-scans';
const OUTPUT_FILE_NAME = 'scan';
const OUTPUT_FILE_EXTENSION = 'json';

/**
 * @param {string} suffix Optional filename suffix
 * @returns file path for the output file
 */
const getOutputFilePath = (suffix) => {
  return `${OUTPUT_PATH}/${OUTPUT_FILE_NAME}${suffix ?? ''}.${OUTPUT_FILE_EXTENSION}`;
};

const NOVU_ICON_REGEX = /^Icon(?!Button)[A-Z0-9]{1}[a-zA-Z0-9]+$/;
const RELATIVE_PATH_REGEX = /^(\.(\.){0,}\/)/;
const ANTD_ICON_MODULE_NAME = '@ant-design/icons';

const COMPONENT_NAME_EXCLUSION_REGEX = /^web\/.*(Page|Container|Provider|Sidebar|Modal)$/;

module.exports = {
  /** directory to scan */
  crawlFrom: '../../apps/web/src/',
  includeSubComponents: true,
  /**
   * Regex for determining which imports to include.
   * Currently includes: novu, antd, mantine, and local imports
   *
   * To see only local imports, replace with: /(\.(\.){0,}\/.*)/gim
   */
  importedFrom:
    /(@novu\/(novui|design-system|shared-web|notification-center)|@mantine\/core|@ant-design)(\/[a-z0-9\-)]+){0,}|(\.(\.){0,}\/.*)/gim,
  exclude: ['/src/api', '/src/styled-system'],
  processors: [countComponentsAndPropsProcessor({ minNumInstances: 1 }), groupByNamespaceProcessor],
  /** file patterns to scan */
  globs: ['**/!(*.test|*.spec|*.stories).@(js|ts)x'],
  /** function for naming components -- we use the returned name as the "group by" key. */
  getComponentName,
};

function getComponentName({ imported, local, moduleName, importType }) {
  const importedName = imported ?? local;

  // any relative imports should return early and be scoped to "web"
  if (RELATIVE_PATH_REGEX.test(moduleName)) {
    return `web/${importedName}`;
  }

  // get the module namespace / org (AKA novu or mantine), but remove @
  const moduleOrg = moduleName.split('/').join('_').replace('@', '');

  // group Icons if from Novu Design System or AntD
  const name =
    (moduleName === '@novu/design-system' && NOVU_ICON_REGEX.test(importedName)) || moduleName === ANTD_ICON_MODULE_NAME
      ? 'Icon'
      : importedName;

  return `${moduleOrg}/${name}`;
}

/**
 * @param {object} _ with the following properties:
 * @param {number} minNumInstances Minimum instance count (inclusive) of a component to include it in the output
 * @default 1
 *
 * Extension of a built-in processor from react-scanner to make it easier to customize.
 * https://github.com/moroshko/react-scanner/blob/master/src/processors/count-components-and-props.js
 */
function countComponentsAndPropsProcessor({ minNumInstances = 1 } = {}) {
  return ({ forEachComponent, sortObjectKeysByValue, output }) => {
    let result = {};

    forEachComponent(({ componentName, component }) => {
      const { instances } = component;

      if (!instances || instances.length < minNumInstances) {
        return;
      }

      if (COMPONENT_NAME_EXCLUSION_REGEX.test(componentName)) {
        console.log('Excluding component ' + componentName);

        return;
      }

      // include the package source as a prop
      const [srcPkg] = componentName.split('/');

      result[componentName] = {
        instances: instances.length,
        props: {},
        srcPkg,
      };

      instances.forEach((instance) => {
        for (const prop in instance.props) {
          if (result[componentName].props[prop] === undefined) {
            result[componentName].props[prop] = 0;
          }

          result[componentName].props[prop] += 1;
        }

        // aggregate icon names and output as a prop to stay consistent across all output components.
        if (componentName.includes('/Icon')) {
          const iconName = instance.importInfo.imported;
          const existingIconNames = result[componentName].props.iconNames;

          result[componentName].props.iconNames = existingIconNames ? existingIconNames.concat(iconName) : [iconName];
        }
      });

      result[componentName].props = sortObjectKeysByValue(result[componentName].props);
    });

    result = sortObjectKeysByValue(result, (component) => component.instances);

    output(result, getOutputFilePath());

    return result;
  };
}

/**
 * @precondition Must be called after `countComponentsAndPropsProcessor` in the processors array.
 * Processor for grouping by namespace (i.e. Novu, Mantine, etc)
 */
function groupByNamespaceProcessor({ prevResult, output }) {
  const result = Object.entries(prevResult).reduce((groupedResult, [compKey, compVal]) => {
    const [namespace, compName] = compKey.split('/');

    return {
      ...groupedResult,
      [namespace]: {
        ...groupedResult[namespace],
        [compName]: compVal,
      },
    };
  }, {});

  output(result, getOutputFilePath('.grouped'));

  return result;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getComponentName({ imported, local, moduleName, importType })
 - countComponentsAndPropsProcessor({ minNumInstances = 1 } = {})
 - groupByNamespaceProcessor({ prevResult, output })
Asignaciones con arrow functions encontradas (posibles funciones):
 - getOutputFilePath(suffix))
 - result({};

    forEachComponent(({ componentName, component }))
 - result(sortObjectKeysByValue(result, (component))
 - result(Object.entries(prevResult).reduce((groupedResult, [compKey, compVal]))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/setup-tests.ts
Tamaño: 224 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { cleanup } from '@testing-library/react';
import { afterEach } from 'vitest';
import '@testing-library/jest-dom/vitest';

// runs a clean after each test case (e.g. clearing jsdom)
afterEach(() => {
  cleanup();
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

No se detectaron funciones/exportaciones con heurística JS/TS.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/tsconfig.json
Tamaño: 596 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "include": ["src", "styled-system"],
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "dist",
    "forceConsistentCasingInFileNames": true,
    "target": "es6",
    "module": "ESNext",
    "strict": true,
    "typeRoots": ["node_modules/@types"],
    "jsx": "react-jsx",
    "lib": ["ESNext", "dom", "dom.iterable"],
    "skipLibCheck": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "removeComments": false,
    "allowSyntheticDefaultImports": true,
    "baseUrl": "."
  },
  "exclude": ["node_modules", "src/**/*.stories.*"]
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"include": ["src", "styled-system"],
"extends": "../../tsconfig.json",
"compilerOptions": {
"outDir": "dist",
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/vite.config.ts
Tamaño: 554 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import react from '@vitejs/plugin-react';
import { resolve } from 'path';
import { defineConfig } from 'vite';
import tsconfigPaths from 'vite-tsconfig-paths';

export default defineConfig({
  plugins: [
    // leverages tsconfig to work with panda styled-system
    tsconfigPaths(),
    react(),
  ],
  build: {
    lib: {
      entry: resolve(__dirname, 'src/index.ts'),
      formats: ['es'],
    },
    rollupOptions: {
      external: ['react', 'react/jsx-runtime'],
    },
  },
  resolve: {
    extensions: ['.tsx', '.ts', '.jsx', '.js'],
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export default  defineConfig

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/vitest.config.ts
Tamaño: 211 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/// <reference types="vitest" />

import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: './setup-tests.ts',
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export default  defineConfig

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/.storybook/NovuTheme.tsx
Tamaño: 538 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { ThemeVarsPartial } from '@storybook/theming';
import { create } from '@storybook/theming/create';

const themeBase: ThemeVarsPartial = {
  base: 'light',
  brandTitle: 'Novu Design System',
  brandTarget: '_self',
};
/**
 * Novu Design System theme for Storybook
 *
 * @see https://storybook.js.org/docs/configure/theming
 */
export const lightTheme = create({
  ...themeBase,
  brandImage: './novu-logo-light.svg',
});

export const darkTheme = create({
  ...themeBase,
  base: 'dark',
  brandImage: './novu-logo-dark.svg',
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { ThemeVarsPartial } from '@storybook/theming';
import { create } from '@storybook/theming/create';
const themeBase: ThemeVarsPartial = {
base: 'light',
/**
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/.storybook/main.ts
Tamaño: 455 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { StorybookConfig } from '@storybook/react-vite';

export default {
  stories: ['../src/**/*.stories.mdx', '../src/**/*.stories.@(js|jsx|ts|tsx)'],

  addons: ['storybook-dark-mode', '@storybook/addon-controls'],

  framework: {
    name: '@storybook/react-vite',
    options: {},
  },

  docs: {
    // TODO: re-enable docs when we decide how to incorporate them
    autodocs: false,
  },

  staticDirs: ['./public'],
} satisfies StorybookConfig;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export default

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/.storybook/manager-head.html
Tamaño: 62 bytes
Lenguaje detectado: HTML

### CONTENIDO ORIGINAL ###

<link rel="icon" type="image/svg+xml" href="./favicon.svg" />


### ANALISIS AUTOMATICO (ESPAÑOL) ###

<link rel="icon" type="image/svg+xml" href="./favicon.svg" />
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/.storybook/preview-head.html
Tamaño: 210 bytes
Lenguaje detectado: HTML

### CONTENIDO ORIGINAL ###

<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<script>
  window._env_ = {
    SKIP_PREFLIGHT_CHECK: 'true',
  };
</script>


### ANALISIS AUTOMATICO (ESPAÑOL) ###

<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<script>
window._env_ = {
SKIP_PREFLIGHT_CHECK: 'true',
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/.storybook/preview.tsx
Tamaño: 1867 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { MantineThemeProvider } from '@mantine/core';
import { Decorator, Parameters, Preview } from '@storybook/react';
import React from 'react';
import { NovuiProvider } from '../src/components';
import { css } from '../styled-system/css';
import { darkTheme, lightTheme } from './NovuTheme';

// Bring in the Panda-generated stylesheets + CSS Layers
import '../src/index.css';

export const parameters: Parameters = {
  layout: 'fullscreen',
  docs: {
    // TODO: fix the container context
    // container: DocsContainer,
  },
  actions: { argTypesRegex: '^on[A-Z].*' },
  controls: {
    matchers: {
      color: /(background|color)$/i,
      date: /Date$/,
    },
  },
  darkMode: {
    // Override the default dark theme
    dark: darkTheme,
    // Override the default light theme
    light: lightTheme,
    darkClass: 'dark',
    stylePreview: true,
  },
};

const DEFAULT_COLOR_PALETTE = 'mode.cloud';

function ColorSchemeThemeWrapper({ children }) {
  // wraps the component preview in a full-page container with proper bg color
  return (
    <section
      className={css({
        padding: '250',
        bg: 'surface.page',
        colorPalette: DEFAULT_COLOR_PALETTE,
        minHeight: '[100vh]',
        height: 'full',
      })}
    >
      {children}
    </section>
  );
}

export const decorators: Decorator[] = [
  (renderStory) => (
    <ColorSchemeThemeWrapper>
      <NovuiProvider>
        <MantineThemeProvider>{renderStory()}</MantineThemeProvider>
      </NovuiProvider>
    </ColorSchemeThemeWrapper>
  ),
];

/** Global controls  */
export const preview: Preview = {
  // The default value of the theme arg for all stories
  argTypes: {
    colorPalette: {
      options: ['mode.cloud', 'mode.local'],
      control: { type: 'select' },
    },
  },
  args: {
    colorPalette: DEFAULT_COLOR_PALETTE,
  },
};

export default preview;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { MantineThemeProvider } from '@mantine/core';
import { Decorator, Parameters, Preview } from '@storybook/react';
import React from 'react';
import { NovuiProvider } from '../src/components';
import { css } from '../styled-system/css';
// Bring in the Panda-generated stylesheets + CSS Layers
// TODO: fix the container context
// container: DocsContainer,
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/.storybook/public/favicon.svg
Tamaño: 796 bytes
Lenguaje detectado: SVG

### CONTENIDO ORIGINAL ###

<svg width="2000" height="2000" viewBox="0 0 2000 2000" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path fill-rule="evenodd" clip-rule="evenodd" d="M1540 801.609C1540 855.379 1474.72 882.004 1437.11 843.57L667.229 56.7032C771.33 19.9793 883.332 0 1000 0C1198.91 0 1384.25 58.0733 1540 158.19V801.609ZM1820 427.485V801.609C1820 1106.31 1450.07 1257.18 1236.98 1039.39L409.055 193.205C161.022 375.186 0 668.789 0 1000C0 1212.94 66.5559 1410.33 180 1572.51V1200.39C180 895.692 549.933 744.819 763.025 962.612L1589.81 1807.63C1838.48 1625.71 2000 1331.72 2000 1000C2000 787.061 1933.44 589.667 1820 427.485ZM562.887 1158.43L1331.32 1943.81C1227.63 1980.21 1116.12 2000 1000 2000C801.093 2000 615.749 1941.93 460 1841.81V1200.39C460 1146.62 525.282 1120 562.887 1158.43Z" fill="black"/>
</svg>


### ANALISIS AUTOMATICO (ESPAÑOL) ###

<svg width="2000" height="2000" viewBox="0 0 2000 2000" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M1540 801.609C1540 855.379 1474.72 882.004 1437.11 843.57L667.229 56.7032C771.33 19.9793 883.332 0 1000 0C1198.91 0 1384.25 58.0733 1540 158.19V801.609ZM1820 427.485V801.609C1820 1106.31 1450.07 1257.18 1236.98 1039.39L409.055 193.205C161.022 375.186 0 668.789 0 1000C0 1212.94 66.5559 1410.33 180 1572.51V1200.39C180 895.692 549.933 744.819 763.025 962.612L1589.81 1807.63C1838.48 1625.71 2000 1331.72 2000 1000C2000 787.061 1933.44 589.667 1820 427.485ZM562.887 1158.43L1331.32 1943.81C1227.63 1980.21 1116.12 2000 1000 2000C801.093 2000 615.749 1941.93 460 1841.81V1200.39C460 1146.62 525.282 1120 562.887 1158.43Z" fill="black"/>
</svg>
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/.storybook/public/novu-logo-dark.svg
Tamaño: 5637 bytes
Lenguaje detectado: SVG

### CONTENIDO ORIGINAL ###

<svg width="1049" height="300" viewBox="0 0 1049 300" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M231 120.241C231 128.307 221.208 132.301 215.567 126.536L100.084 8.50548C115.699 2.9969 132.5 0 150 0C179.836 0 207.638 8.711 231 23.7285V120.241ZM273 64.1228V120.241C273 165.946 217.51 188.577 185.546 155.908L61.3582 28.9807C24.1534 56.2779 0 100.318 0 150C0 181.941 9.98339 211.55 27 235.877V180.059C27 134.354 82.4899 111.723 114.454 144.392L238.471 271.145C275.773 243.857 300 199.758 300 150C300 118.059 290.017 88.45 273 64.1228ZM84.433 173.764L199.697 291.571C184.144 297.031 167.419 300 150 300C120.164 300 92.3624 291.289 69 276.272V180.059C69 171.993 78.7923 167.999 84.433 173.764Z" fill="url(#paint0_linear_1199_1981)"/>
<path d="M487.303 223.326V140.944C487.303 126.727 483.892 115.918 477.07 108.517C470.248 101.116 459.527 97.4157 444.908 97.4157C434.967 97.4157 427.073 98.3895 421.225 100.337C415.378 102.09 411.674 103.356 410.115 104.135V223.326H380V84.8539C380.78 84.4644 382.924 83.588 386.432 82.2247C389.941 80.8614 394.619 79.4007 400.467 77.8427C406.314 76.2846 413.136 74.9213 420.933 73.7528C428.73 72.5843 437.306 72 446.662 72C457.383 72 467.129 73.4607 475.9 76.382C484.672 79.1086 492.079 83.1011 498.121 88.3596C504.359 93.618 509.134 99.9476 512.448 107.348C515.761 114.749 517.418 123.124 517.418 132.472V223.326H487.303Z" fill="white"/>
<path d="M713.257 150C713.257 161.101 711.308 171.423 707.41 180.966C703.706 190.509 698.444 198.787 691.621 205.798C684.799 212.614 676.613 218.067 667.061 222.157C657.51 226.052 646.985 228 635.485 228C623.984 228 613.361 226.052 603.615 222.157C594.064 218.067 585.878 212.614 579.055 205.798C572.233 198.787 566.873 190.509 562.975 180.966C559.271 171.423 557.419 161.101 557.419 150C557.419 138.899 559.271 128.577 562.975 119.034C566.873 109.491 572.233 101.311 579.055 94.4944C585.878 87.4831 594.064 82.03 603.615 78.1348C613.361 74.0449 623.984 72 635.485 72C646.985 72 657.51 74.0449 667.061 78.1348C676.613 82.03 684.799 87.4831 691.621 94.4944C698.444 101.311 703.706 109.491 707.41 119.034C711.308 128.577 713.257 138.899 713.257 150ZM681.973 150C681.973 142.21 680.901 135.101 678.757 128.674C676.613 122.052 673.494 116.404 669.401 111.73C665.502 106.861 660.629 103.161 654.782 100.629C649.129 97.9026 642.697 96.5393 635.485 96.5393C628.078 96.5393 621.45 97.9026 615.603 100.629C609.95 103.161 605.077 106.861 600.984 111.73C597.085 116.404 594.064 122.052 591.92 128.674C589.776 135.101 588.704 142.21 588.704 150C588.704 157.79 589.776 164.996 591.92 171.618C594.064 178.045 597.085 183.693 600.984 188.562C605.077 193.236 609.95 196.936 615.603 199.663C621.45 202.195 628.078 203.461 635.485 203.461C642.697 203.461 649.129 202.195 654.782 199.663C660.629 196.936 665.502 193.236 669.401 188.562C673.494 183.693 676.613 178.045 678.757 171.618C680.901 164.996 681.973 157.79 681.973 150Z" fill="white"/>
<path d="M888.255 83.1011C887.086 87.3858 885.039 93.1311 882.116 100.337C879.387 107.348 876.17 115.236 872.467 124C868.764 132.764 864.67 142.015 860.187 151.753C855.899 161.296 851.513 170.644 847.03 179.798C842.742 188.757 838.551 197.228 834.458 205.213C830.559 213.004 827.148 219.528 824.224 224.787H792.94C789.431 218.554 785.728 211.738 781.829 204.337C778.126 196.742 774.325 189.146 770.427 181.551C766.723 173.76 763.117 166.067 759.609 158.472C756.1 150.876 752.786 143.865 749.668 137.438C746.744 130.816 744.113 124.974 741.774 119.91C739.629 114.846 737.973 110.951 736.803 108.225C735.634 105.498 734.464 102.577 733.294 99.4607C732.125 96.3446 731.54 93.4232 731.54 90.6966C731.54 87.191 732.71 83.9775 735.049 81.0562C737.388 78.1348 741.384 76.6742 747.036 76.6742C750.935 76.6742 753.956 77.0637 756.1 77.8427C758.244 78.6217 759.414 79.1086 759.609 79.3034C762.922 88.4569 766.723 98.4869 771.011 109.393C775.495 120.3 779.978 131.109 784.461 141.82C789.139 152.337 793.622 162.464 797.91 172.202C802.199 181.745 805.999 189.828 809.313 196.449C811.652 191.97 814.673 185.64 818.377 177.461C822.275 169.086 826.271 159.933 830.364 150C834.653 140.067 838.941 129.843 843.229 119.326C847.517 108.809 851.318 99.1685 854.632 90.4045C856.191 86.1198 858.14 82.809 860.479 80.4719C862.818 77.9401 866.717 76.6742 872.175 76.6742C876.853 76.6742 880.556 77.5506 883.285 79.3034C886.209 81.0562 887.866 82.3221 888.255 83.1011Z" fill="white"/>
<path d="M1018.88 90.4045C1018.88 85.7303 1020.25 82.3221 1022.98 80.1798C1025.71 77.8427 1029.61 76.6742 1034.67 76.6742C1037.99 76.6742 1040.91 77.0637 1043.44 77.8427C1046.17 78.6217 1048.03 79.206 1049 79.5955V223.326C1047.64 223.715 1045.2 224.105 1041.69 224.494C1038.38 224.884 1034.28 225.273 1029.41 225.663C1024.54 226.247 1019.18 226.637 1013.33 226.831C1007.48 227.221 1001.54 227.416 995.495 227.416C977.757 227.416 963.333 225.273 952.223 220.989C941.307 216.704 932.633 210.472 926.201 202.292C918.209 191.97 914.213 178.24 914.213 161.101V90.4045C914.213 85.7303 915.578 82.3221 918.307 80.1798C921.035 77.8427 924.934 76.6742 930.002 76.6742C933.315 76.6742 936.239 77.0637 938.773 77.8427C941.502 78.6217 943.354 79.206 944.328 79.5955V157.888C944.328 172.689 948.032 183.79 955.439 191.191C963.041 198.592 975.808 202.292 993.74 202.292C1000.56 202.292 1006.02 202.097 1010.11 201.708C1014.4 201.124 1017.33 200.637 1018.88 200.247V90.4045Z" fill="white"/>
<defs>
<linearGradient id="paint0_linear_1199_1981" x1="300" y1="0" x2="3.57628e-05" y2="300" gradientUnits="userSpaceOnUse">
<stop offset="0.231667" stop-color="#FF884D"/>
<stop offset="0.801667" stop-color="#E300BD"/>
</linearGradient>
</defs>
</svg>


### ANALISIS AUTOMATICO (ESPAÑOL) ###

<svg width="1049" height="300" viewBox="0 0 1049 300" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M231 120.241C231 128.307 221.208 132.301 215.567 126.536L100.084 8.50548C115.699 2.9969 132.5 0 150 0C179.836 0 207.638 8.711 231 23.7285V120.241ZM273 64.1228V120.241C273 165.946 217.51 188.577 185.546 155.908L61.3582 28.9807C24.1534 56.2779 0 100.318 0 150C0 181.941 9.98339 211.55 27 235.877V180.059C27 134.354 82.4899 111.723 114.454 144.392L238.471 271.145C275.773 243.857 300 199.758 300 150C300 118.059 290.017 88.45 273 64.1228ZM84.433 173.764L199.697 291.571C184.144 297.031 167.419 300 150 300C120.164 300 92.3624 291.289 69 276.272V180.059C69 171.993 78.7923 167.999 84.433 173.764Z" fill="url(#paint0_linear_1199_1981)"/>
<path d="M487.303 223.326V140.944C487.303 126.727 483.892 115.918 477.07 108.517C470.248 101.116 459.527 97.4157 444.908 97.4157C434.967 97.4157 427.073 98.3895 421.225 100.337C415.378 102.09 411.674 103.356 410.115 104.135V223.326H380V84.8539C380.78 84.4644 382.924 83.588 386.432 82.2247C389.941 80.8614 394.619 79.4007 400.467 77.8427C406.314 76.2846 413.136 74.9213 420.933 73.7528C428.73 72.5843 437.306 72 446.662 72C457.383 72 467.129 73.4607 475.9 76.382C484.672 79.1086 492.079 83.1011 498.121 88.3596C504.359 93.618 509.134 99.9476 512.448 107.348C515.761 114.749 517.418 123.124 517.418 132.472V223.326H487.303Z" fill="white"/>
<path d="M713.257 150C713.257 161.101 711.308 171.423 707.41 180.966C703.706 190.509 698.444 198.787 691.621 205.798C684.799 212.614 676.613 218.067 667.061 222.157C657.51 226.052 646.985 228 635.485 228C623.984 228 613.361 226.052 603.615 222.157C594.064 218.067 585.878 212.614 579.055 205.798C572.233 198.787 566.873 190.509 562.975 180.966C559.271 171.423 557.419 161.101 557.419 150C557.419 138.899 559.271 128.577 562.975 119.034C566.873 109.491 572.233 101.311 579.055 94.4944C585.878 87.4831 594.064 82.03 603.615 78.1348C613.361 74.0449 623.984 72 635.485 72C646.985 72 657.51 74.0449 667.061 78.1348C676.613 82.03 684.799 87.4831 691.621 94.4944C698.444 101.311 703.706 109.491 707.41 119.034C711.308 128.577 713.257 138.899 713.257 150ZM681.973 150C681.973 142.21 680.901 135.101 678.757 128.674C676.613 122.052 673.494 116.404 669.401 111.73C665.502 106.861 660.629 103.161 654.782 100.629C649.129 97.9026 642.697 96.5393 635.485 96.5393C628.078 96.5393 621.45 97.9026 615.603 100.629C609.95 103.161 605.077 106.861 600.984 111.73C597.085 116.404 594.064 122.052 591.92 128.674C589.776 135.101 588.704 142.21 588.704 150C588.704 157.79 589.776 164.996 591.92 171.618C594.064 178.045 597.085 183.693 600.984 188.562C605.077 193.236 609.95 196.936 615.603 199.663C621.45 202.195 628.078 203.461 635.485 203.461C642.697 203.461 649.129 202.195 654.782 199.663C660.629 196.936 665.502 193.236 669.401 188.562C673.494 183.693 676.613 178.045 678.757 171.618C680.901 164.996 681.973 157.79 681.973 150Z" fill="white"/>
<path d="M888.255 83.1011C887.086 87.3858 885.039 93.1311 882.116 100.337C879.387 107.348 876.17 115.236 872.467 124C868.764 132.764 864.67 142.015 860.187 151.753C855.899 161.296 851.513 170.644 847.03 179.798C842.742 188.757 838.551 197.228 834.458 205.213C830.559 213.004 827.148 219.528 824.224 224.787H792.94C789.431 218.554 785.728 211.738 781.829 204.337C778.126 196.742 774.325 189.146 770.427 181.551C766.723 173.76 763.117 166.067 759.609 158.472C756.1 150.876 752.786 143.865 749.668 137.438C746.744 130.816 744.113 124.974 741.774 119.91C739.629 114.846 737.973 110.951 736.803 108.225C735.634 105.498 734.464 102.577 733.294 99.4607C732.125 96.3446 731.54 93.4232 731.54 90.6966C731.54 87.191 732.71 83.9775 735.049 81.0562C737.388 78.1348 741.384 76.6742 747.036 76.6742C750.935 76.6742 753.956 77.0637 756.1 77.8427C758.244 78.6217 759.414 79.1086 759.609 79.3034C762.922 88.4569 766.723 98.4869 771.011 109.393C775.495 120.3 779.978 131.109 784.461 141.82C789.139 152.337 793.622 162.464 797.91 172.202C802.199 181.745 805.999 189.828 809.313 196.449C811.652 191.97 814.673 185.64 818.377 177.461C822.275 169.086 826.271 159.933 830.364 150C834.653 140.067 838.941 129.843 843.229 119.326C847.517 108.809 851.318 99.1685 854.632 90.4045C856.191 86.1198 858.14 82.809 860.479 80.4719C862.818 77.9401 866.717 76.6742 872.175 76.6742C876.853 76.6742 880.556 77.5506 883.285 79.3034C886.209 81.0562 887.866 82.3221 888.255 83.1011Z" fill="white"/>
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/.storybook/public/novu-logo-light.svg
Tamaño: 5637 bytes
Lenguaje detectado: SVG

### CONTENIDO ORIGINAL ###

<svg width="1049" height="300" viewBox="0 0 1049 300" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M231 120.241C231 128.307 221.208 132.301 215.567 126.536L100.084 8.50548C115.699 2.9969 132.5 0 150 0C179.836 0 207.638 8.711 231 23.7285V120.241ZM273 64.1228V120.241C273 165.946 217.51 188.577 185.546 155.908L61.3582 28.9807C24.1534 56.2779 0 100.318 0 150C0 181.941 9.98339 211.55 27 235.877V180.059C27 134.354 82.4899 111.723 114.454 144.392L238.471 271.145C275.773 243.857 300 199.758 300 150C300 118.059 290.017 88.45 273 64.1228ZM84.433 173.764L199.697 291.571C184.144 297.031 167.419 300 150 300C120.164 300 92.3624 291.289 69 276.272V180.059C69 171.993 78.7923 167.999 84.433 173.764Z" fill="url(#paint0_linear_1301_3067)"/>
<path d="M487.303 223.326V140.944C487.303 126.727 483.892 115.918 477.07 108.517C470.248 101.116 459.527 97.4157 444.908 97.4157C434.967 97.4157 427.073 98.3895 421.225 100.337C415.378 102.09 411.674 103.356 410.115 104.135V223.326H380V84.8539C380.78 84.4644 382.924 83.588 386.432 82.2247C389.941 80.8614 394.619 79.4007 400.467 77.8427C406.314 76.2846 413.136 74.9213 420.933 73.7528C428.73 72.5843 437.306 72 446.662 72C457.383 72 467.129 73.4607 475.9 76.382C484.672 79.1086 492.079 83.1011 498.121 88.3596C504.359 93.618 509.134 99.9476 512.448 107.348C515.761 114.749 517.418 123.124 517.418 132.472V223.326H487.303Z" fill="black"/>
<path d="M713.257 150C713.257 161.101 711.308 171.423 707.41 180.966C703.706 190.509 698.444 198.787 691.621 205.798C684.799 212.614 676.613 218.067 667.061 222.157C657.51 226.052 646.985 228 635.485 228C623.984 228 613.361 226.052 603.615 222.157C594.064 218.067 585.878 212.614 579.055 205.798C572.233 198.787 566.873 190.509 562.975 180.966C559.271 171.423 557.419 161.101 557.419 150C557.419 138.899 559.271 128.577 562.975 119.034C566.873 109.491 572.233 101.311 579.055 94.4944C585.878 87.4831 594.064 82.03 603.615 78.1348C613.361 74.0449 623.984 72 635.485 72C646.985 72 657.51 74.0449 667.061 78.1348C676.613 82.03 684.799 87.4831 691.621 94.4944C698.444 101.311 703.706 109.491 707.41 119.034C711.308 128.577 713.257 138.899 713.257 150ZM681.973 150C681.973 142.21 680.901 135.101 678.757 128.674C676.613 122.052 673.494 116.404 669.401 111.73C665.502 106.861 660.629 103.161 654.782 100.629C649.129 97.9026 642.697 96.5393 635.485 96.5393C628.078 96.5393 621.45 97.9026 615.603 100.629C609.95 103.161 605.077 106.861 600.984 111.73C597.085 116.404 594.064 122.052 591.92 128.674C589.776 135.101 588.704 142.21 588.704 150C588.704 157.79 589.776 164.996 591.92 171.618C594.064 178.045 597.085 183.693 600.984 188.562C605.077 193.236 609.95 196.936 615.603 199.663C621.45 202.195 628.078 203.461 635.485 203.461C642.697 203.461 649.129 202.195 654.782 199.663C660.629 196.936 665.502 193.236 669.401 188.562C673.494 183.693 676.613 178.045 678.757 171.618C680.901 164.996 681.973 157.79 681.973 150Z" fill="black"/>
<path d="M888.255 83.1011C887.086 87.3858 885.039 93.1311 882.115 100.337C879.387 107.348 876.17 115.236 872.467 124C868.764 132.764 864.67 142.015 860.187 151.753C855.899 161.296 851.513 170.644 847.03 179.798C842.742 188.757 838.551 197.228 834.458 205.213C830.559 213.004 827.148 219.528 824.224 224.787H792.94C789.431 218.554 785.728 211.738 781.829 204.337C778.126 196.742 774.325 189.146 770.427 181.551C766.723 173.76 763.117 166.067 759.609 158.472C756.1 150.876 752.786 143.865 749.668 137.438C746.744 130.816 744.113 124.974 741.774 119.91C739.629 114.846 737.973 110.951 736.803 108.225C735.634 105.498 734.464 102.577 733.295 99.4607C732.125 96.3446 731.54 93.4232 731.54 90.6966C731.54 87.191 732.71 83.9775 735.049 81.0562C737.388 78.1348 741.384 76.6742 747.036 76.6742C750.935 76.6742 753.956 77.0637 756.1 77.8427C758.244 78.6217 759.414 79.1086 759.609 79.3034C762.922 88.4569 766.723 98.4869 771.011 109.393C775.495 120.3 779.978 131.109 784.461 141.82C789.139 152.337 793.622 162.464 797.91 172.202C802.199 181.745 805.999 189.828 809.313 196.449C811.652 191.97 814.673 185.64 818.377 177.461C822.275 169.086 826.271 159.933 830.364 150C834.653 140.067 838.941 129.843 843.229 119.326C847.517 108.809 851.318 99.1685 854.632 90.4045C856.191 86.1198 858.14 82.809 860.479 80.4719C862.818 77.9401 866.717 76.6742 872.175 76.6742C876.853 76.6742 880.556 77.5506 883.285 79.3034C886.209 81.0562 887.866 82.3221 888.255 83.1011Z" fill="black"/>
<path d="M1018.88 90.4045C1018.88 85.7303 1020.25 82.3221 1022.98 80.1798C1025.71 77.8427 1029.61 76.6742 1034.67 76.6742C1037.99 76.6742 1040.91 77.0637 1043.44 77.8427C1046.17 78.6217 1048.03 79.206 1049 79.5955V223.326C1047.64 223.715 1045.2 224.105 1041.69 224.494C1038.38 224.884 1034.28 225.273 1029.41 225.663C1024.54 226.247 1019.18 226.637 1013.33 226.831C1007.48 227.221 1001.54 227.416 995.495 227.416C977.757 227.416 963.333 225.273 952.223 220.989C941.307 216.704 932.633 210.472 926.201 202.292C918.209 191.97 914.213 178.24 914.213 161.101V90.4045C914.213 85.7303 915.578 82.3221 918.307 80.1798C921.035 77.8427 924.934 76.6742 930.002 76.6742C933.315 76.6742 936.239 77.0637 938.773 77.8427C941.502 78.6217 943.354 79.206 944.328 79.5955V157.888C944.328 172.689 948.032 183.79 955.439 191.191C963.041 198.592 975.808 202.292 993.74 202.292C1000.56 202.292 1006.02 202.097 1010.11 201.708C1014.4 201.124 1017.33 200.637 1018.88 200.247V90.4045Z" fill="black"/>
<defs>
<linearGradient id="paint0_linear_1301_3067" x1="300" y1="0" x2="3.57628e-05" y2="300" gradientUnits="userSpaceOnUse">
<stop offset="0.231667" stop-color="#FF884D"/>
<stop offset="0.801667" stop-color="#E300BD"/>
</linearGradient>
</defs>
</svg>


### ANALISIS AUTOMATICO (ESPAÑOL) ###

<svg width="1049" height="300" viewBox="0 0 1049 300" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M231 120.241C231 128.307 221.208 132.301 215.567 126.536L100.084 8.50548C115.699 2.9969 132.5 0 150 0C179.836 0 207.638 8.711 231 23.7285V120.241ZM273 64.1228V120.241C273 165.946 217.51 188.577 185.546 155.908L61.3582 28.9807C24.1534 56.2779 0 100.318 0 150C0 181.941 9.98339 211.55 27 235.877V180.059C27 134.354 82.4899 111.723 114.454 144.392L238.471 271.145C275.773 243.857 300 199.758 300 150C300 118.059 290.017 88.45 273 64.1228ZM84.433 173.764L199.697 291.571C184.144 297.031 167.419 300 150 300C120.164 300 92.3624 291.289 69 276.272V180.059C69 171.993 78.7923 167.999 84.433 173.764Z" fill="url(#paint0_linear_1301_3067)"/>
<path d="M487.303 223.326V140.944C487.303 126.727 483.892 115.918 477.07 108.517C470.248 101.116 459.527 97.4157 444.908 97.4157C434.967 97.4157 427.073 98.3895 421.225 100.337C415.378 102.09 411.674 103.356 410.115 104.135V223.326H380V84.8539C380.78 84.4644 382.924 83.588 386.432 82.2247C389.941 80.8614 394.619 79.4007 400.467 77.8427C406.314 76.2846 413.136 74.9213 420.933 73.7528C428.73 72.5843 437.306 72 446.662 72C457.383 72 467.129 73.4607 475.9 76.382C484.672 79.1086 492.079 83.1011 498.121 88.3596C504.359 93.618 509.134 99.9476 512.448 107.348C515.761 114.749 517.418 123.124 517.418 132.472V223.326H487.303Z" fill="black"/>
<path d="M713.257 150C713.257 161.101 711.308 171.423 707.41 180.966C703.706 190.509 698.444 198.787 691.621 205.798C684.799 212.614 676.613 218.067 667.061 222.157C657.51 226.052 646.985 228 635.485 228C623.984 228 613.361 226.052 603.615 222.157C594.064 218.067 585.878 212.614 579.055 205.798C572.233 198.787 566.873 190.509 562.975 180.966C559.271 171.423 557.419 161.101 557.419 150C557.419 138.899 559.271 128.577 562.975 119.034C566.873 109.491 572.233 101.311 579.055 94.4944C585.878 87.4831 594.064 82.03 603.615 78.1348C613.361 74.0449 623.984 72 635.485 72C646.985 72 657.51 74.0449 667.061 78.1348C676.613 82.03 684.799 87.4831 691.621 94.4944C698.444 101.311 703.706 109.491 707.41 119.034C711.308 128.577 713.257 138.899 713.257 150ZM681.973 150C681.973 142.21 680.901 135.101 678.757 128.674C676.613 122.052 673.494 116.404 669.401 111.73C665.502 106.861 660.629 103.161 654.782 100.629C649.129 97.9026 642.697 96.5393 635.485 96.5393C628.078 96.5393 621.45 97.9026 615.603 100.629C609.95 103.161 605.077 106.861 600.984 111.73C597.085 116.404 594.064 122.052 591.92 128.674C589.776 135.101 588.704 142.21 588.704 150C588.704 157.79 589.776 164.996 591.92 171.618C594.064 178.045 597.085 183.693 600.984 188.562C605.077 193.236 609.95 196.936 615.603 199.663C621.45 202.195 628.078 203.461 635.485 203.461C642.697 203.461 649.129 202.195 654.782 199.663C660.629 196.936 665.502 193.236 669.401 188.562C673.494 183.693 676.613 178.045 678.757 171.618C680.901 164.996 681.973 157.79 681.973 150Z" fill="black"/>
<path d="M888.255 83.1011C887.086 87.3858 885.039 93.1311 882.115 100.337C879.387 107.348 876.17 115.236 872.467 124C868.764 132.764 864.67 142.015 860.187 151.753C855.899 161.296 851.513 170.644 847.03 179.798C842.742 188.757 838.551 197.228 834.458 205.213C830.559 213.004 827.148 219.528 824.224 224.787H792.94C789.431 218.554 785.728 211.738 781.829 204.337C778.126 196.742 774.325 189.146 770.427 181.551C766.723 173.76 763.117 166.067 759.609 158.472C756.1 150.876 752.786 143.865 749.668 137.438C746.744 130.816 744.113 124.974 741.774 119.91C739.629 114.846 737.973 110.951 736.803 108.225C735.634 105.498 734.464 102.577 733.295 99.4607C732.125 96.3446 731.54 93.4232 731.54 90.6966C731.54 87.191 732.71 83.9775 735.049 81.0562C737.388 78.1348 741.384 76.6742 747.036 76.6742C750.935 76.6742 753.956 77.0637 756.1 77.8427C758.244 78.6217 759.414 79.1086 759.609 79.3034C762.922 88.4569 766.723 98.4869 771.011 109.393C775.495 120.3 779.978 131.109 784.461 141.82C789.139 152.337 793.622 162.464 797.91 172.202C802.199 181.745 805.999 189.828 809.313 196.449C811.652 191.97 814.673 185.64 818.377 177.461C822.275 169.086 826.271 159.933 830.364 150C834.653 140.067 838.941 129.843 843.229 119.326C847.517 108.809 851.318 99.1685 854.632 90.4045C856.191 86.1198 858.14 82.809 860.479 80.4719C862.818 77.9401 866.717 76.6742 872.175 76.6742C876.853 76.6742 880.556 77.5506 883.285 79.3034C886.209 81.0562 887.866 82.3221 888.255 83.1011Z" fill="black"/>
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/global.styles.ts
Tamaño: 1459 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { defineGlobalStyles } from '@pandacss/dev';

export const GLOBAL_CSS = defineGlobalStyles({
  body: {
    // text styles
    fontFamily: 'system',
    fontWeight: 'regular',
    letterSpacing: '0',
    fontSize: '88',
    textDecoration: 'none',
    color: 'typography.text.main',
    // this is for reverse compatibility with legacy global styles
    lineHeight: '[1.15]',

    backgroundColor: 'surface.page',
    overflow: 'hidden',
    scrollbarWidth: '{sizes.scrollbar.width}',
    scrollbarColor: '{colors.scrollbar.color}',
    /* SAFARI SCROLLBAR SUPPORT - remove after Safari supports `scrollbar-width` and `scrollbar-color` */
    '::-webkit-scrollbar': {
      width: '{sizes.scrollbar.track}',
      height: '{sizes.scrollbar.track}',
    },
    '::-webkit-scrollbar-thumb': {
      // For this calculation, see: https://stackoverflow.com/questions/11691718/css-webkit-scrollbar-and-safari
      border: `calc(({sizes.scrollbar.track} - {sizes.scrollbar.thumb}) / 2) solid {colors.scrollbar.track}`,
      borderRadius: '{sizes.scrollbar.thumb}',
      backgroundClip: 'padding-box',
      backgroundColor: '{colors.scrollbar.thumb}',
    },
    '::-webkit-scrollbar-track': {
      backgroundColor: '{colors.scrollbar.track}',
    },
    '::-webkit-scrollbar-corner': {
      backgroundColor: '{colors.scrollbar.track}',
    },
    /* END SAFARI SCROLLBAR SUPPORT */
  },
  a: {
    textDecoration: 'none',
    color: 'inherit',
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/index.css
Tamaño: 183 bytes
Lenguaje detectado: CSS

### CONTENIDO ORIGINAL ###

@layer reset, base, mantine, tokens, recipes, utilities;

@import "@mantine/core/styles.layer.css";
@import "@mantine/tiptap/styles.layer.css";
@import "../styled-system/styles.css";


### ANALISIS AUTOMATICO (ESPAÑOL) ###

@layer reset, base, mantine, tokens, recipes, utilities;
@import "@mantine/core/styles.layer.css";
@import "@mantine/tiptap/styles.layer.css";
@import "../styled-system/styles.css";
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/index.ts
Tamaño: 233 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './components';
export * from './global.styles';
export * from './hooks';
export * from './ingredients';
export * from './json-schema-components/JsonSchemaForm';
export * from './panda-preset';
export * from './types';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/panda-preset.ts
Tamaño: 4836 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { definePreset } from '@pandacss/dev';
import {
  BUTTON_RECIPE,
  CHECKBOX_RECIPE,
  CODE_BLOCK_RECIPE,
  INPUT_EDITOR_WIDGET_RECIPE,
  INPUT_RECIPE,
  JSON_SCHEMA_FORM_ARRAY_TOOLBAR_RECIPE,
  JSON_SCHEMA_FORM_SECTION_RECIPE,
  LOADING_OVERLAY_RECIPE,
  SELECT_RECIPE,
  TABS_RECIPE,
  TEXT_RECIPE,
  TITLE_RECIPE,
  VARIABLE_SUGGESTION_LIST_RECIPE,
} from './recipes';
import { BORDER_TOKENS, BORDER_WIDTH_TOKENS } from './tokens/borders.tokens';
import { COLOR_PALETTE_TOKENS, LEGACY_COLOR_TOKENS } from './tokens/colors.tokens';
import { GRADIENT_TOKENS, LEGACY_GRADIENT_TOKENS } from './tokens/gradients.tokens';
import { LEGACY_OPACITY_TOKENS, OPACITY_TOKENS } from './tokens/opacity.tokens';
import { LEGACY_RADIUS_TOKENS, RADIUS_TOKENS } from './tokens/radius.tokens';
import { COLOR_SEMANTIC_TOKENS, LEGACY_COLOR_SEMANTIC_TOKENS } from './tokens/semanticColors.tokens';
import { SEMANTIC_OPACITY_TOKENS } from './tokens/semanticOpacity.tokens';
import { SEMANTIC_RADIUS_TOKENS } from './tokens/semanticRadius.tokens';
import { SEMANTIC_SIZES_TOKENS } from './tokens/semanticSizes.tokens';
import { SEMANTIC_SPACING_TOKENS } from './tokens/semanticSpacing.tokens';
import { SEMANTIC_FONT_SIZE_TOKENS, SEMANTIC_LINE_HEIGHT_TOKENS } from './tokens/semanticTypography.tokens';
import { LEGACY_SHADOW_TOKENS } from './tokens/shadow.tokens';
import { SIZES_TOKENS } from './tokens/sizes.tokens';
import { SPACING_TOKENS } from './tokens/spacing.tokens';
import { TEXT_STYLES } from './tokens/textStyles.tokens';
import {
  FONT_FAMILY_TOKENS,
  FONT_SIZE_TOKENS,
  FONT_WEIGHT_TOKENS,
  LEGACY_FONT_FAMILY_TOKENS,
  LETTER_SPACING_TOKENS,
  LINE_HEIGHT_TOKENS,
} from './tokens/typography.tokens';
import { Z_INDEX_TOKENS } from './tokens/zIndex.tokens';

/**
 * This defines all Novu tokens into a single preset to be used in our various apps (and design-system).
 * https://panda-css.com/docs/customization/presets
 *
 * Future-looking note: this preset and any other associated files may be a good candidate for moving into
 * a standalone package depending on how we interface with Supernova (our design token tool), and if we want
 * the definitions to be separate from token definitions.
 */
export const novuPandaPreset = definePreset({
  theme: {
    tokens: {
      sizes: SIZES_TOKENS,
      spacing: SPACING_TOKENS,
      colors: {
        ...COLOR_PALETTE_TOKENS,
        ...LEGACY_COLOR_TOKENS,
      },
      // typography tokens
      fonts: {
        ...FONT_FAMILY_TOKENS,
        ...LEGACY_FONT_FAMILY_TOKENS,
      },
      fontSizes: FONT_SIZE_TOKENS,
      lineHeights: LINE_HEIGHT_TOKENS,
      fontWeights: FONT_WEIGHT_TOKENS,
      letterSpacings: LETTER_SPACING_TOKENS,
      radii: {
        ...RADIUS_TOKENS,
        ...LEGACY_RADIUS_TOKENS,
      },
      borderWidths: BORDER_WIDTH_TOKENS,
      borders: BORDER_TOKENS,
      zIndex: Z_INDEX_TOKENS,
      opacity: {
        ...OPACITY_TOKENS,
        ...LEGACY_OPACITY_TOKENS,
      },
    },
    semanticTokens: {
      sizes: SEMANTIC_SIZES_TOKENS,
      spacing: SEMANTIC_SPACING_TOKENS,
      colors: {
        ...COLOR_SEMANTIC_TOKENS,
        ...LEGACY_COLOR_SEMANTIC_TOKENS,
      },
      fontSizes: SEMANTIC_FONT_SIZE_TOKENS,
      lineHeights: SEMANTIC_LINE_HEIGHT_TOKENS,
      radii: SEMANTIC_RADIUS_TOKENS,
      shadows: LEGACY_SHADOW_TOKENS,
      gradients: {
        ...GRADIENT_TOKENS,
        ...LEGACY_GRADIENT_TOKENS,
      },
      opacity: SEMANTIC_OPACITY_TOKENS,
    },
    textStyles: TEXT_STYLES,
    extend: {
      recipes: {
        text: TEXT_RECIPE,
        title: TITLE_RECIPE,
        button: BUTTON_RECIPE,
        tabs: TABS_RECIPE,
        input: INPUT_RECIPE,
        select: SELECT_RECIPE,
        checkbox: CHECKBOX_RECIPE,
        codeBlock: CODE_BLOCK_RECIPE,
        loadingOverlay: LOADING_OVERLAY_RECIPE,
        jsonSchemaFormSection: JSON_SCHEMA_FORM_SECTION_RECIPE,
        jsonSchemaFormArrayToolbar: JSON_SCHEMA_FORM_ARRAY_TOOLBAR_RECIPE,
        variableSuggestionList: VARIABLE_SUGGESTION_LIST_RECIPE,
        inputEditorWidget: INPUT_EDITOR_WIDGET_RECIPE,
      },
    },
  },
  conditions: {
    extend: {
      // Mantine uses *-error.
      error: '&:is(:error, [data-error], [aria-error])',
      groupError: '.group:is(:error, [data-error], [aria-error]) &',
      /** Mantine uses hover*ed*, so extend the selector to support it */
      hover: '&:is(:hover, [data-hover], [data-hovered])',
      /** apply hover only when element or child is not disabled */
      hoverNotDisabled: '&:is(:hover, [data-hover], [data-hovered])&:not(:has(:disabled))',
    },
  },
  staticCss: {
    css: [
      {
        properties: {
          // Must generate color modes statically to ensure they're available
          colorPalette: ['mode.local', 'mode.cloud'],
        },
      },
    ],
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/component-audit/ComponentAuditTable.stories.tsx
Tamaño: 1116 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Meta, StoryFn } from '@storybook/react';
import React from 'react';
import { css } from '../../styled-system/css';
import { ComponentAuditTable } from './ComponentAuditTable';

import scanJson from './component-scans/scan.json';

export default {
  title: 'ComponentAudit',
  component: ComponentAuditTable,
  argTypes: {},
} as Meta<typeof ComponentAuditTable>;

const TableWrapper = ({ children }: { children: React.ReactNode }) => {
  return (
    <div
      className={css({
        overflowX: 'auto',
        maxWidth: '[100%]',
        overflowY: 'auto',
        maxHeight: '[95dvh]',
      })}
    >
      {children}
    </div>
  );
};

const Template: StoryFn<typeof ComponentAuditTable> = ({ ...args }) => (
  <>
    <h3 className={css({ color: 'typography.text.main' })}>
      If no data is appearing below, please run `pnpm audit-components` in your terminal in the `design-system`
      directory
    </h3>
    <br />
    <TableWrapper>
      <ComponentAuditTable data={scanJson ?? {}} />
    </TableWrapper>
  </>
);

export const ComponentAudit = Template.bind({});
ComponentAudit.args = {};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Meta, StoryFn } from '@storybook/react';
import React from 'react';
import { css } from '../../styled-system/css';
import { ComponentAuditTable } from './ComponentAuditTable';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/component-audit/ComponentAuditTable.tsx
Tamaño: 7157 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import React, { useMemo, useState } from 'react';
import { css } from '../../styled-system/css';

interface JsonData {
  [key: string]: {
    instances: number;
    props: {
      [key: string]: number | string[];
    };
    srcPkg: string;
  };
}

interface ComponentAuditTableProps {
  data: JsonData;
  className?: string;
}

type SortableKey = keyof Omit<JsonData[string], 'props'> | 'name';

export const ComponentAuditTable: React.FC<ComponentAuditTableProps> = ({ data: jsonData, className }) => {
  const [expandedRows, setExpandedRows] = useState<string[]>([]);
  const [sortColumn, setSortColumn] = useState<SortableKey | null>(null);
  const [sortOrder, setSortOrder] = useState<'asc' | 'desc' | null>(null);

  const data = useMemo(() => {
    return Object.entries(jsonData).map(([key, value]) => ({ ...value, name: key.split('/')[1] }));
  }, [jsonData]);

  const toggleRow = (name: string) => {
    setExpandedRows((prevState) =>
      prevState.includes(name) ? prevState.filter((row) => row !== name) : [...prevState, name]
    );
  };

  const sortData = (key: SortableKey) => {
    if (sortColumn === key) {
      setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc');
    } else {
      setSortColumn(key);
      setSortOrder('asc');
    }
  };

  const getSortIcon = (key: SortableKey) => {
    if (sortColumn !== key) return null;
    if (sortOrder === 'asc') return '⬆️';
    if (sortOrder === 'desc') return '⬇️';

    return null;
  };

  const sortedData = sortColumn
    ? data.sort((a, b) => {
        const aValue = a[sortColumn];
        const bValue = b[sortColumn];

        if (typeof aValue === 'string' && typeof bValue === 'string') {
          return sortOrder === 'asc' ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
        }

        if (typeof aValue === 'number' && typeof bValue === 'number') {
          return sortOrder === 'asc' ? aValue - bValue : bValue - aValue;
        }

        return 0;
      })
    : data;

  return (
    <table
      className={`${css({ width: '[100%]', borderCollapse: 'collapse', color: 'typography.text.main' })} ${
        className ?? ''
      }`}
    >
      <thead>
        <tr className={css({ bg: 'surface.popover', fontSize: '100', fontWeight: 'strong' })}>
          <th
            className={css({
              py: '[2]',
              px: '25',
              textAlign: 'left',
              borderBottom: 'solid',
              borderColor: 'typography.text.secondary',
              cursor: 'pointer',
            })}
            onClick={() => sortData('name')}
          >
            Name {getSortIcon('name')}
          </th>
          <th
            className={css({
              py: '[2]',
              px: '25',
              textAlign: 'left',
              borderBottom: 'solid',
              borderColor: 'typography.text.secondary',
              cursor: 'pointer',
            })}
            onClick={() => sortData('instances')}
          >
            Instance Count {getSortIcon('instances')}
          </th>
          <th
            className={css({
              py: '[2]',
              px: '25',
              textAlign: 'left',
              borderBottom: 'solid',
              borderColor: 'typography.text.secondary',
              cursor: 'pointer',
            })}
            onClick={() => sortData('srcPkg')}
          >
            Source {getSortIcon('srcPkg')}
          </th>
          <th
            className={css({
              py: '[2]',
              px: '25',
              textAlign: 'left',
              borderBottom: 'solid',
              borderColor: 'typography.text.secondary',
            })}
          >
            Props
          </th>
        </tr>
      </thead>
      <tbody>
        {sortedData.map(({ name, instances, props, srcPkg }) => (
          <React.Fragment key={`${srcPkg}-${name}`}>
            <tr className={css({ bg: 'surface.page', _even: { bg: { base: '[#DDDDDD]', _dark: '[#222233]' } } })}>
              <td
                className={css({
                  py: '[2]',
                  px: '25',
                  borderBottom: 'solid',
                  borderColor: 'typography.text.secondary',
                })}
              >
                {name}
              </td>
              <td
                className={css({
                  py: '[2]',
                  px: '25',
                  borderBottom: 'solid',
                  borderColor: 'typography.text.secondary',
                })}
              >
                {instances}
              </td>
              <td
                className={css({
                  py: '[2]',
                  px: '25',
                  borderBottom: 'solid',
                  borderColor: 'typography.text.secondary',
                })}
              >
                {srcPkg}
              </td>
              <td
                className={css({
                  py: '[2]',
                  px: '25',
                  borderBottom: 'solid',
                  borderColor: 'typography.text.secondary',
                  maxW: '[300px]',
                  textOverflow: 'ellipsis',
                })}
              >
                <span
                  className={css({
                    textDecoration: 'underline',
                    _hover: { color: 'typography.text.feedback.info' },
                    cursor: 'pointer',
                  })}
                  onClick={() => toggleRow(name)}
                >
                  {Object.entries(props)
                    .slice(0, 3)
                    .map(([prop, value]) => `${prop}: ${typeof value === 'number' ? value : value.join(', ')}`)
                    .join(', ')}
                  {Object.keys(props).length > 3 && '...'}
                </span>
              </td>
            </tr>
            {expandedRows.includes(name) && (
              <tr>
                <td colSpan={4} className={css({ py: '[2]', px: '25' })}>
                  <div
                    className={css({
                      display: 'grid',
                      gridTemplateColumns: '[repeat(auto-fit, minmax(150px, 1fr))]',
                      gap: '25',
                    })}
                  >
                    {Object.entries(props).map(([prop, value]) => (
                      <div
                        key={prop}
                        className={css({
                          bg: 'surface.popover',
                          px: '25',
                          py: '[2]',
                          display: 'grid',
                          gridTemplateColumns: '[max-content 1fr]',
                          alignItems: 'center',
                          gap: '25',
                        })}
                      >
                        <span className={css({ fontWeight: 'strong' })}>{prop}:</span>
                        <span>{typeof value === 'number' ? value : value.join(', ')}</span>
                      </div>
                    ))}
                  </div>
                </td>
              </tr>
            )}
          </React.Fragment>
        ))}
      </tbody>
    </table>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import React, { useMemo, useState } from 'react';
import { css } from '../../styled-system/css';
interface JsonData {
[key: string]: {
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/NovuiProvider.tsx
Tamaño: 504 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { MantineProvider } from '@mantine/core';
import { FC, PropsWithChildren } from 'react';
import { IconProvider } from '../icons/IconProvider';
import { MANTINE_THEME } from './mantine-theme.config';

type INovuiProviderProps = PropsWithChildren;

/** Used to export a v7 Mantine provider */
export const NovuiProvider: FC<INovuiProviderProps> = ({ children }) => {
  return (
    <MantineProvider theme={MANTINE_THEME}>
      <IconProvider>{children}</IconProvider>
    </MantineProvider>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { MantineProvider } from '@mantine/core';
import { FC, PropsWithChildren } from 'react';
import { IconProvider } from '../icons/IconProvider';
import { MANTINE_THEME } from './mantine-theme.config';
/** Used to export a v7 Mantine provider */
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/index.ts
Tamaño: 320 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './button';
export * from './checkbox';
export * from './code-block';
export * from './input';
export * from './loader';
export * from './NovuiProvider';
export * from './select';
export * from './table';
export * from './tabs';
export * from './text';
export * from './textarea';
export * from './title';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/components/mantine-theme.config.ts
Tamaño: 2843 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { MantineColorsTuple, MantineThemeOverride } from '@mantine/core';
import { Token, token } from '../../styled-system/tokens';
import { COLOR_PALETTE_TOKENS } from '../tokens/colors.tokens';

/**
 * Generates a Mantine color tuple for the given Panda color "family"
 */
const generateMantineColorTokens = (colorFamily: keyof typeof COLOR_PALETTE_TOKENS): MantineColorsTuple => {
  return Object.keys(COLOR_PALETTE_TOKENS[colorFamily]).map((paletteNumber) =>
    token(`colors.${colorFamily}.${paletteNumber}.dark` as Token)
  ) as unknown as MantineColorsTuple;
};

/** Maps Panda token values to a mantine theme config */
export const MANTINE_THEME: MantineThemeOverride = {
  // colors
  white: token('colors.legacy.white'),
  black: token('colors.legacy.black'),
  primaryColor: 'gradient',
  primaryShade: 6,
  colors: {
    gray: generateMantineColorTokens('mauve'),
    yellow: generateMantineColorTokens('amber'),
    blue: generateMantineColorTokens('blue'),
    green: generateMantineColorTokens('green'),
    red: generateMantineColorTokens('red'),
    // must have a tuple of 10 strings, but replace the value at primaryShade with our gradient
    gradient: ['', '', '', '', '', '', token('gradients.horizontal'), '', '', ''],
  },

  // typography
  fontFamily: token('fonts.system'),
  fontFamilyMonospace: token('fonts.mono'),
  lineHeights: {
    sm: token('lineHeights.100'),
    md: token('lineHeights.125'),
    lg: token('lineHeights.150'),
    // missing 175
    xl: token('lineHeights.200'),
  },
  headings: {
    fontFamily: token('fonts.system'),
    fontWeight: token('fontWeights.strong'),
    sizes: {
      // page title
      h1: {
        fontSize: token('fontSizes.150'),
        lineHeight: token('lineHeights.200'),
      },
      // section title
      h2: {
        fontSize: token('fontSizes.125'),
        lineHeight: token('lineHeights.175'),
      },
      // subsection title
      h3: {
        fontSize: token('fontSizes.100'),
        lineHeight: token('lineHeights.150'),
      },
    },
  },
  fontSizes: {
    xs: token('fontSizes.75'),
    sm: token('fontSizes.88'),
    md: token('fontSizes.100'),
    lg: token('fontSizes.125'),
    xl: token('fontSizes.150'),
  },

  // TODO: these are guesses for how they match up
  spacing: {
    xs: token('spacing.25'),
    sm: token('spacing.50'),
    md: token('spacing.100'),
    lg: token('spacing.150'),
    xl: token('spacing.200'),
    xxl: token('spacing.250'),
    xxxl: token('spacing.300'),
  },
  radius: {
    xs: token('radii.xs'),
    sm: token('radii.s'),
    md: token('radii.m'),
    lg: token('radii.l'),
  },
  defaultRadius: 'md',
  shadows: {
    // TODO: this makes no sense except for md
    sm: token('shadows.light'),
    md: token('shadows.medium'),
    lg: token('shadows.dark'),
    xl: token('shadows.color'),
  },
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - generateMantineColorTokens(colorFamily: keyof typeof COLOR_PALETTE_TOKENS): MantineColorsTuple)
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/components/button/Button.const.ts
Tamaño: 1019 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ButtonProps as ExternalButtonProps, ButtonVariant as ExternalButtonVariant } from '@mantine/core';
import { type ButtonVariant } from '../../../styled-system/recipes';
import { IconSize } from '../../icons';

export const BUTTON_SIZE_TO_ICON_SIZE: Record<ButtonVariant['size'], IconSize> = {
  xs: '16',
  sm: '20',
  md: '20',
  lg: '20',
};

// Note: for right now, these are equivalent, but we haven't agreed on our size tokens (caps, one letter, etc)
export const BUTTON_SIZE_TO_EXTERNAL_BUTTON_SIZE: Record<ButtonVariant['size'], ExternalButtonProps['size']> = {
  xs: 'xs',
  sm: 'sm',
  md: 'md',
  lg: 'lg',
};

// Note: for right now, these are identical, but we may adjust them later
export const BUTTON_VARIANT_TO_EXTERNAL_BUTTON_VARIANT: Record<ButtonVariant['variant'], ExternalButtonVariant> = {
  filled: 'filled',
  outline: 'outline',
  transparent: 'transparent',
};

export const DEFAULT_VARIANT: ButtonVariant['variant'] = 'filled';
export const DEFAULT_SIZE: ButtonVariant['size'] = 'md';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  const
- export  const
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/components/button/Button.stories.tsx
Tamaño: 4612 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Meta, StoryFn } from '@storybook/react';
import React from 'react';
import { Grid } from '../../../styled-system/jsx';
import { IconOutlineInfo, IconSettings } from '../../icons';
import { Title } from '../title';
import { Button } from './Button';

export default {
  title: 'Components/Button',
  component: Button,
  argTypes: {
    size: {
      options: ['xs', 'sm', 'md', 'lg'],
      control: { type: 'select' },
    },
    fullWidth: {
      type: 'boolean',
    },
  },
} as Meta<typeof Button>;

const Template: StoryFn<typeof Button> = ({ ...args }) => {
  return (
    <Grid gridTemplateColumns="5">
      <Title variant="subsection">Default</Title>
      <Button {...args}>Test</Button>
      <Button {...args} Icon={IconSettings}>
        Test
      </Button>
      <Button {...args} Icon={IconSettings} disabled>
        Test
      </Button>
      <Button {...args} Icon={IconSettings} loading>
        Test
      </Button>

      <Title variant="subsection">Filled</Title>
      <Button {...args} variant="filled">
        Test
      </Button>
      <Button {...args} Icon={IconSettings} variant="filled">
        Test
      </Button>
      <Button {...args} Icon={IconSettings} variant="filled" disabled>
        Test
      </Button>
      <Button {...args} Icon={IconSettings} variant="filled" loading>
        Test
      </Button>

      <Title variant="subsection">Transparent</Title>
      <Button {...args} variant="transparent">
        Test
      </Button>
      <Button {...args} Icon={IconSettings} variant="transparent">
        Test
      </Button>
      <Button {...args} Icon={IconSettings} variant="transparent" disabled>
        Test
      </Button>
      <Button {...args} Icon={IconSettings} variant="transparent" loading>
        Test
      </Button>

      <Title variant="subsection">Outline</Title>
      <Button {...args} variant="outline">
        Test
      </Button>
      <Button {...args} Icon={IconSettings} variant="outline">
        Test
      </Button>
      <Button {...args} Icon={IconSettings} variant="outline" disabled>
        Test
      </Button>
      <Button {...args} Icon={IconSettings} variant="outline" loading>
        Test
      </Button>
    </Grid>
  );
};

export const Default = Template.bind({});

const SizeTemplate: StoryFn<typeof Button> = ({ ...args }) => {
  return (
    <Grid gridTemplateColumns="5">
      <Title variant="subsection"></Title>
      <Title variant="subsection">xs</Title>
      <Title variant="subsection">sm</Title>
      <Title variant="subsection">md</Title>
      <Title variant="subsection">lg</Title>

      <Title variant="subsection">Default</Title>
      <Button {...args} Icon={IconOutlineInfo} size="xs">
        Button copy
      </Button>
      <Button {...args} Icon={IconOutlineInfo} size="sm">
        Button copy
      </Button>
      <Button {...args} Icon={IconOutlineInfo} size="md">
        Button copy
      </Button>
      <Button {...args} Icon={IconOutlineInfo} size="lg">
        Button copy
      </Button>

      <Title variant="subsection">Filled</Title>
      <Button {...args} Icon={IconOutlineInfo} size="xs" variant="filled">
        Button copy
      </Button>
      <Button {...args} Icon={IconOutlineInfo} size="sm" variant="filled">
        Button copy
      </Button>
      <Button {...args} Icon={IconOutlineInfo} size="md" variant="filled">
        Button copy
      </Button>
      <Button {...args} Icon={IconOutlineInfo} size="lg" variant="filled">
        Button copy
      </Button>

      <Title variant="subsection">Transparent</Title>
      <Button {...args} Icon={IconOutlineInfo} size="xs" variant="transparent">
        Button copy
      </Button>
      <Button {...args} Icon={IconOutlineInfo} size="sm" variant="transparent">
        Button copy
      </Button>
      <Button {...args} Icon={IconOutlineInfo} size="md" variant="transparent">
        Button copy
      </Button>
      <Button {...args} Icon={IconOutlineInfo} size="lg" variant="transparent">
        Button copy
      </Button>

      <Title variant="subsection">Outline</Title>
      <Button {...args} Icon={IconOutlineInfo} size="xs" variant="outline">
        Button copy
      </Button>
      <Button {...args} Icon={IconOutlineInfo} size="sm" variant="outline">
        Button copy
      </Button>
      <Button {...args} Icon={IconOutlineInfo} size="md" variant="outline">
        Button copy
      </Button>
      <Button {...args} Icon={IconOutlineInfo} size="lg" variant="outline">
        Button copy
      </Button>
    </Grid>
  );
};

export const Sizes = SizeTemplate.bind({});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Meta, StoryFn } from '@storybook/react';
import React from 'react';
import { Grid } from '../../../styled-system/jsx';
import { IconOutlineInfo, IconSettings } from '../../icons';
import { Title } from '../title';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/button/Button.tsx
Tamaño: 2565 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Button as ExternalButton, ButtonProps as ExternalButtonProps } from '@mantine/core';
import React from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { type ButtonVariant, button } from '../../../styled-system/recipes';
import { JsxStyleProps } from '../../../styled-system/types';
import { IconType } from '../../icons';
import { CoreProps, CorePropsWithChildren } from '../../types';
import { forwardRefWithAs, PolymorphicComponentPropWithRef, PolymorphicRef } from '../../types/props-helpers';
import {
  BUTTON_SIZE_TO_EXTERNAL_BUTTON_SIZE,
  BUTTON_SIZE_TO_ICON_SIZE,
  BUTTON_VARIANT_TO_EXTERNAL_BUTTON_VARIANT,
  DEFAULT_SIZE,
  DEFAULT_VARIANT,
} from './Button.const';

export interface ButtonCoreProps
  extends CorePropsWithChildren,
    React.ButtonHTMLAttributes<HTMLButtonElement>,
    Pick<ExternalButtonProps, 'loading'> {
  Icon?: IconType;
  loading?: boolean;
}

type ButtonDefaultElement = 'button';

export type ButtonProps<C extends React.ElementType = ButtonDefaultElement> = PolymorphicComponentPropWithRef<
  C,
  JsxStyleProps & Partial<ButtonVariant> & CoreProps & ButtonCoreProps
>;

type PolymorphicComponent = <C extends React.ElementType = ButtonDefaultElement>(
  props: ButtonProps<C>
) => JSX.Element | null;

export const Button: PolymorphicComponent = forwardRefWithAs<
  ButtonDefaultElement,
  JsxStyleProps & Partial<ButtonVariant> & CoreProps & ButtonCoreProps
>(
  <C extends React.ElementType = ButtonDefaultElement>(
    { variant = DEFAULT_VARIANT, size = DEFAULT_SIZE, ...props }: ButtonProps<C>,
    ref?: PolymorphicRef<C>
  ) => {
    const [variantProps, buttonProps] = button.splitVariantProps({ ...props, variant, size });
    const [cssProps, localProps] = splitCssProps(buttonProps);
    const { className, as, Icon, children, ...otherProps } = localProps;
    const styles = button(variantProps);

    return (
      <ExternalButton
        ref={ref}
        component={as ?? 'button'}
        size={BUTTON_SIZE_TO_EXTERNAL_BUTTON_SIZE[size]}
        variant={BUTTON_VARIANT_TO_EXTERNAL_BUTTON_VARIANT[variant]}
        leftSection={
          Icon ? (
            <Icon title="button-icon" size={variant === 'transparent' ? '20' : BUTTON_SIZE_TO_ICON_SIZE[size]} />
          ) : undefined
        }
        classNames={styles}
        className={cx(css(cssProps), className)}
        fullWidth={Boolean(variantProps.fullWidth)}
        {...otherProps}
      >
        {children}
      </ExternalButton>
    );
  }
);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Button as ExternalButton, ButtonProps as ExternalButtonProps } from '@mantine/core';
import React from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { type ButtonVariant, button } from '../../../styled-system/recipes';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/button/IconButton.stories.tsx
Tamaño: 1611 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Meta, StoryFn } from '@storybook/react';
import React from 'react';
import { Grid } from '../../../styled-system/jsx';
import { Icon123, IconSettings } from '../../icons';
import { Title } from '../title';
import { IconButton } from './IconButton';

export default {
  title: 'Components/IconButton',
  component: IconButton,
  argTypes: {},
} as Meta<typeof IconButton>;

const Template: StoryFn<typeof IconButton> = ({ ...args }) => {
  return (
    <Grid gridTemplateColumns="4">
      <Title variant="subsection">Default</Title>
      <IconButton {...args} Icon={IconSettings} />
      <IconButton {...args} Icon={IconSettings} disabled />
      <IconButton {...args} Icon={IconSettings} loading />

      <Title variant="subsection">Transparent</Title>
      <IconButton {...args} Icon={IconSettings} variant="transparent" />
      <IconButton {...args} Icon={IconSettings} variant="transparent" disabled />
      <IconButton {...args} Icon={IconSettings} variant="transparent" loading />

      <Title variant="subsection">Filled</Title>
      <IconButton {...args} Icon={IconSettings} variant="filled" />
      <IconButton {...args} Icon={IconSettings} variant="filled" disabled />
      <IconButton {...args} Icon={IconSettings} variant="filled" loading />

      <Title variant="subsection">Outline</Title>
      <IconButton {...args} Icon={IconSettings} variant="outline" />
      <IconButton {...args} Icon={IconSettings} variant="outline" disabled />
      <IconButton {...args} Icon={IconSettings} variant="outline" loading />
    </Grid>
  );
};
export const Default = Template.bind({});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Meta, StoryFn } from '@storybook/react';
import React from 'react';
import { Grid } from '../../../styled-system/jsx';
import { Icon123, IconSettings } from '../../icons';
import { Title } from '../title';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/button/IconButton.tsx
Tamaño: 2558 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { ActionIcon, ActionIconStylesNames, ButtonVariant as ExternalButtonVariant } from '@mantine/core';
import React from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { type ButtonVariant, button } from '../../../styled-system/recipes';
import { token } from '../../../styled-system/tokens';
import { JsxStyleProps } from '../../../styled-system/types';
import { IconType } from '../../icons';
import { CoreProps } from '../../types';
import { forwardRefWithAs, PolymorphicComponentPropWithRef, PolymorphicRef } from '../../types/props-helpers';
import { BUTTON_SIZE_TO_ICON_SIZE, DEFAULT_SIZE } from './Button.const';

interface IIconButtonProps {
  Icon: IconType;
  loading?: boolean;
}

type IconButtonDefaultElement = 'button';

export type IconButtonProps<C extends React.ElementType = IconButtonDefaultElement> = PolymorphicComponentPropWithRef<
  C,
  JsxStyleProps & Partial<ButtonVariant> & CoreProps & IIconButtonProps
>;

const DEFAULT_VARIANT: ButtonVariant['variant'] = 'transparent';

type PolymorphicComponent = <C extends React.ElementType = IconButtonDefaultElement>(
  props: IconButtonProps<C>
) => JSX.Element | null;

/**
 * A button with only an Icon.
 *
 * TODO: there are not specifications for these in the Design System, so this just follows the Button recipe.
 */
export const IconButton: PolymorphicComponent = forwardRefWithAs<
  IconButtonDefaultElement,
  JsxStyleProps & Partial<ButtonVariant> & CoreProps & IIconButtonProps
>(
  <C extends React.ElementType = IconButtonDefaultElement>(
    { variant = DEFAULT_VARIANT, ...props }: IconButtonProps<C>,
    ref?: PolymorphicRef<C>
  ) => {
    const [variantProps, buttonProps] = button.splitVariantProps({ ...props, variant });
    const [cssProps, localProps] = splitCssProps(buttonProps);
    const { className, as, loading, Icon, ...otherProps } = localProps;
    const styles = button(variantProps);

    return (
      <ActionIcon
        ref={ref}
        component={as ?? 'button'}
        classNames={styles}
        className={cx(css(cssProps), className)}
        variant={variantProps.variant as ExternalButtonVariant}
        loading={loading}
        {...otherProps}
      >
        <Icon
          title={props.title || 'action-icon'}
          color={variant === 'filled' ? token('colors.button.icon.filled') : undefined}
          size={BUTTON_SIZE_TO_ICON_SIZE[(variantProps.size as ButtonVariant['size']) ?? DEFAULT_SIZE]}
        />
      </ActionIcon>
    );
  }
);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { ActionIcon, ActionIconStylesNames, ButtonVariant as ExternalButtonVariant } from '@mantine/core';
import React from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { type ButtonVariant, button } from '../../../styled-system/recipes';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/button/index.ts
Tamaño: 56 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './Button';
export * from './IconButton';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/components/checkbox/Checkbox.stories.tsx
Tamaño: 881 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Group } from '@mantine/core';
import { Meta, StoryFn } from '@storybook/react';
import React from 'react';
import { Checkbox } from './Checkbox';

export default {
  title: 'Components/Checkbox',
  component: Checkbox,
  argTypes: {},
} as Meta<typeof Checkbox>;

const Template: StoryFn<typeof Checkbox> = ({ ...args }) => <Checkbox {...args} />;

export const Default = Template.bind({});
Default.args = {
  label: 'Checkbox Label',
};

export const States = () => (
  <Group style={{ display: 'flex', flexDirection: 'column', alignItems: 'unset' }}>
    <Checkbox label="Checked checkbox" defaultChecked />
  </Group>
);

export const Disabled = () => (
  <Group style={{ display: 'flex', flexDirection: 'column', alignItems: 'unset' }}>
    <Checkbox label="Checked checkbox" defaultChecked disabled />
    <Checkbox label="Checked checkbox" disabled />
  </Group>
);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Group } from '@mantine/core';
import { Meta, StoryFn } from '@storybook/react';
import React from 'react';
import { Checkbox } from './Checkbox';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/checkbox/Checkbox.tsx
Tamaño: 1420 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Checkbox as ExternalCheckbox } from '@mantine/core';
import { ChangeEventHandler, forwardRef } from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { checkbox } from '../../../styled-system/recipes';
import { JsxStyleProps } from '../../../styled-system/types';
import { CoreProps, LocalizedMessage, LocalizedString } from '../../types';
import { PolymorphicRef } from '../../types/props-helpers';

export type CheckboxProps = JsxStyleProps &
  CoreProps & {
    label?: LocalizedMessage;
    description?: LocalizedMessage;
    placeholder?: LocalizedString;
    error?: LocalizedMessage;

    required?: boolean;
    readOnly?: boolean;
    disabled?: boolean;

    checked?: boolean;
    defaultChecked?: boolean;
    onChange?: ChangeEventHandler<HTMLInputElement>;
  };

export const Checkbox = forwardRef(({ ...props }: CheckboxProps, ref?: PolymorphicRef<'input'>) => {
  const [variantProps, inputProps] = checkbox.splitVariantProps({ ...props });
  const [cssProps, localProps] = splitCssProps(inputProps);
  const { onChange, className, ...otherProps } = localProps;
  const classNames = checkbox(variantProps);

  return (
    <ExternalCheckbox
      ref={ref}
      classNames={classNames}
      className={cx(css(cssProps), className)}
      onChange={onChange}
      size="md"
      {...otherProps}
    />
  );
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Checkbox as ExternalCheckbox } from '@mantine/core';
import { ChangeEventHandler, forwardRef } from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { checkbox } from '../../../styled-system/recipes';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/checkbox/index.ts
Tamaño: 28 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './Checkbox';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/components/code-block/CodeBlock.stories.tsx
Tamaño: 886 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Meta, StoryFn } from '@storybook/react';
import React from 'react';
import { CodeBlock } from './CodeBlock';

export default {
  title: 'Components/CodeBlock',
  component: CodeBlock,
  argTypes: {},
} as Meta<typeof CodeBlock>;

const Template: StoryFn<typeof CodeBlock> = ({ ...args }) => <CodeBlock {...args} />;

const apiKey = 'TH!Si$ASup3RSeCreTAP!KEy';
const bridgeUrl = 'https://your-bridge-url';

export const PrimaryUse = Template.bind({});
PrimaryUse.args = {
  language: 'yaml',
  code: `name: Deploy Workflow State to Novu

  on:
    workflow_dispatch:
  
  jobs:
    deploy:
      runs-on: ubuntu-latest
      steps:
        - name: Checkout code
          uses: actions/checkout@v2
  
        - name: Sync State to Novu
          uses: novuhq/actions-novu-sync@v0.0.4
          with:
            novu-api-key: ${apiKey}
            bridge-url: ${bridgeUrl}`,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Meta, StoryFn } from '@storybook/react';
import React from 'react';
import { CodeBlock } from './CodeBlock';
export default {
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/code-block/CodeBlock.tsx
Tamaño: 2201 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { CodeHighlight as ExternalCode, CodeHighlightProps as ExternalCodeProps } from '@mantine/code-highlight';
import React from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { CodeBlockVariantProps, codeBlock } from '../../../styled-system/recipes';
import type { JsxStyleProps } from '../../../styled-system/types';
import { CoreProps } from '../../types';
import { forwardRefWithAs, PolymorphicComponentPropWithRef, PolymorphicRef } from '../../types/props-helpers';

// TODO: use @mantine/code-highlight/styles.layer.css instead
import '@mantine/code-highlight/styles.css';

export type CodeBlockCoreProps = Pick<ExternalCodeProps, 'language' | 'code' | 'withCopyButton'>;

type CodeBlockElement = 'div';

const DEFAULT_CODE_BLOCK_ELEMENT: CodeBlockElement = 'div';

export type CodeBlockProps<C extends React.ElementType> = PolymorphicComponentPropWithRef<
  C,
  JsxStyleProps & CodeBlockVariantProps & CoreProps & CodeBlockCoreProps
>;

type PolymorphicComponent = <C extends React.ElementType = CodeBlockElement>(
  props: CodeBlockProps<C>
) => JSX.Element | null;

/**
 * @deprecated This is not actually deprecated but needs more work to be styled properly and align with our use cases.
 *
 * Issues:
 * - switching between color modes and maintaining readable code
 * - no line numbers are built-in to Highlight JS
 *
 */
export const CodeBlock: PolymorphicComponent = forwardRefWithAs<
  CodeBlockElement,
  JsxStyleProps & CodeBlockVariantProps & CoreProps & CodeBlockCoreProps
>(<C extends React.ElementType = CodeBlockElement>(props: CodeBlockProps<C>, ref?: PolymorphicRef<C>) => {
  const [variantProps, codeBlockProps] = codeBlock.splitVariantProps(props);
  const [cssProps, localProps] = splitCssProps(codeBlockProps);
  const { className, as, code, ...otherProps } = localProps;
  const classNames = codeBlock(variantProps);
  const Component = props.as || DEFAULT_CODE_BLOCK_ELEMENT;

  return (
    <ExternalCode
      ref={ref}
      component={Component}
      classNames={classNames}
      className={cx(css(cssProps), className)}
      code={code}
      {...otherProps}
    />
  );
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { CodeHighlight as ExternalCode, CodeHighlightProps as ExternalCodeProps } from '@mantine/code-highlight';
import React from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { CodeBlockVariantProps, codeBlock } from '../../../styled-system/recipes';
// TODO: use @mantine/code-highlight/styles.layer.css instead
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/code-block/index.ts
Tamaño: 29 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './CodeBlock';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/components/input/Input.stories.tsx
Tamaño: 2330 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Meta, StoryFn } from '@storybook/react';
import React from 'react';
import { stack } from '../../../styled-system/patterns/stack';
import { IconContentCopy } from '../../icons';
import { Button } from '../button';
import { Input } from './Input';

export default {
  title: 'Components/Input',
  component: Input,
  argTypes: {
    value: {
      table: {
        disable: true,
      },
    },
    onChange: {
      table: {
        disable: true,
      },
    },
    error: {
      type: 'string',
    },
    variant: {
      options: ['preventLayoutShift', undefined],
      control: {
        type: 'select',
      },
    },
  },
} as Meta<typeof Input>;

const Template: StoryFn<typeof Input> = ({ ...args }) => <Input {...args} />;

export const PrimaryUse = Template.bind({});
PrimaryUse.args = {
  label: 'Notification Name',
  placeholder: 'Notification name goes here...',
  required: true,
};

export const Everything = Template.bind({});
Everything.args = {
  label: 'Notification Name',
  description: 'Will be used as identifier',
  placeholder: 'Notification name goes here...',
  rightSection: <IconContentCopy />,
  error: 'Not Good!',
};

export const Nothing = Template.bind({});
Nothing.args = {};

export const WithDescription = Template.bind({});
WithDescription.args = {
  label: 'Notification Name',
  description: 'Will be used as identifier',
  placeholder: 'Notification name goes here...',
};

export const WithIcon = Template.bind({});
WithIcon.args = {
  label: 'Notification Name',
  value: 'e297cdd6cf29ea8f566c06da18ccf151',
  rightSection: <IconContentCopy />,
};

export const Error = Template.bind({});
Error.args = {
  label: 'Your Email',
  value: 'NotGood@email.com',
  error: 'Not Good!',
};

const FormTemplate: StoryFn<typeof Input> = ({ ...args }) => {
  return (
    <form noValidate onSubmit={(event) => event.preventDefault()}>
      <Input variant="preventLayoutShift" {...args} />
      <Input variant="preventLayoutShift" {...args} />
      <Input variant="preventLayoutShift" {...args} placeholder="This won't have an error" error={undefined} />
      <Input variant="preventLayoutShift" {...args} />
      <Button type="submit">Submit</Button>
    </form>
  );
};

export const InForm = FormTemplate.bind({});
InForm.args = {
  label: 'Your Email',
  required: true,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Meta, StoryFn } from '@storybook/react';
import React from 'react';
import { stack } from '../../../styled-system/patterns/stack';
import { IconContentCopy } from '../../icons';
import { Button } from '../button';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/input/Input.tsx
Tamaño: 1988 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { TextInput as ExternalTextInput, type InputProps as ExternalTextInputProps } from '@mantine/core';
import { ChangeEventHandler, forwardRef } from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { InputVariant, input } from '../../../styled-system/recipes';
import { JsxStyleProps } from '../../../styled-system/types';
import { IconErrorOutline } from '../../icons';
import { CoreProps, LocalizedMessage, LocalizedString } from '../../types';
import { PolymorphicRef } from '../../types/props-helpers';

export type TextInputType = 'text' | 'password' | 'email' | 'search' | 'tel';
export const DEFAULT_TEXT_INPUT_TYPE: TextInputType = 'text';

export interface IInputProps
  extends JsxStyleProps,
    CoreProps,
    Pick<ExternalTextInputProps, 'rightSection'>,
    Partial<InputVariant> {
  label?: LocalizedMessage;
  description?: LocalizedMessage;
  placeholder?: LocalizedString;
  error?: LocalizedMessage;
  type?: TextInputType;

  required?: boolean;
  readOnly?: boolean;
  disabled?: boolean;

  value?: string;
  defaultValue?: string;
  onChange?: ChangeEventHandler<HTMLInputElement>;
}

export const Input = forwardRef(
  ({ type = DEFAULT_TEXT_INPUT_TYPE, ...props }: IInputProps, ref?: PolymorphicRef<'input'>) => {
    const [variantProps, inputProps] = input.splitVariantProps({ ...props, type });
    const [cssProps, localProps] = splitCssProps(inputProps);
    const { onChange, className, rightSection, ...otherProps } = localProps;
    const classNames = input(variantProps);

    return (
      <ExternalTextInput
        ref={ref}
        onChange={(event) => onChange?.(event)}
        autoComplete="off"
        classNames={classNames}
        className={cx(css(cssProps), className)}
        rightSection={otherProps.error ? <IconErrorOutline title="input error indicator" /> : rightSection}
        variant={undefined}
        {...otherProps}
      />
    );
  }
);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { TextInput as ExternalTextInput, type InputProps as ExternalTextInputProps } from '@mantine/core';
import { ChangeEventHandler, forwardRef } from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { InputVariant, input } from '../../../styled-system/recipes';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/input/index.ts
Tamaño: 25 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './Input';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/components/loader/LoadingOverlay.stories.tsx
Tamaño: 2197 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Meta, StoryFn } from '@storybook/react';
import React from 'react';
import { css } from '../../../styled-system/css';
import { Box } from '../../../styled-system/jsx';
import { stack } from '../../../styled-system/patterns/stack';
import { Button } from '../button';
import { Input } from '../input';
import { Text } from '../text';
import { Title } from '../title';
import { LoadingOverlay } from './LoadingOverlay';

export default {
  title: 'Components/LoadingOverlay',
  component: LoadingOverlay,
  argTypes: {
    type: {
      options: ['bars', 'oval', 'dots'],
      control: {
        type: 'radio',
      },
    },
  },
} as Meta<typeof LoadingOverlay>;

const Template: StoryFn<typeof LoadingOverlay> = ({ ...args }) => (
  <>
    <LoadingOverlay {...args} />{' '}
    <form noValidate onSubmit={(event) => event.preventDefault()} className={stack()}>
      <Title>Here is some text</Title>
      <Text>And some more!</Text>
      <Input />
      <Input />
      <Input placeholder="This won't have an error" error={undefined} />
      <Input />
      <Button type="submit">Submit</Button>
    </form>
  </>
);

export const FullPage = Template.bind({});
FullPage.args = {};

const InComponentTemplate: StoryFn<typeof LoadingOverlay> = ({ ...args }) => (
  <>
    <form
      noValidate
      onSubmit={(event) => event.preventDefault()}
      className={stack({
        maxWidth: '[500px]',
        border: 'solid',
        borderColor: 'input.border',
        padding: '150',
        borderRadius: '100',
        position: 'relative',
      })}
    >
      <LoadingOverlay {...args} />
      <Title>Here is some text</Title>
      <Text>And some more!</Text>
      <Input label="Input" />
      <Input label="Input" />
      <Input label="Input" placeholder="This won't have an error" error={undefined} />
      <Input label="Input" />
      <Button type="submit">Submit</Button>
    </form>
    <div className={stack({ mt: '150' })}>
      <Title>Here is some stuff outside the component!</Title>
      <Text>It should not be overlaid</Text>
      <Input label="Input" />
    </div>
  </>
);

export const InComponent = InComponentTemplate.bind({});
InComponent.args = {};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Meta, StoryFn } from '@storybook/react';
import React from 'react';
import { css } from '../../../styled-system/css';
import { Box } from '../../../styled-system/jsx';
import { stack } from '../../../styled-system/patterns/stack';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/loader/LoadingOverlay.tsx
Tamaño: 2803 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { LoaderProps as ExternalLoaderProps, LoadingOverlay as ExternalLoadingOverlay } from '@mantine/core';
import React from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { type LoadingOverlayVariant, loadingOverlay } from '../../../styled-system/recipes';
import { token, ZIndexToken } from '../../../styled-system/tokens';
import { JsxStyleProps } from '../../../styled-system/types';
import { IconSize } from '../../icons';
import { CoreProps } from '../../types';
import { forwardRefWithAs, PolymorphicComponentPropWithRef, PolymorphicRef } from '../../types/props-helpers';

export type LoaderSize = IconSize | '64';

const DEFAULT_SIZE: LoaderSize = '64';
const DEFAULT_Z_INDEX: ZIndexToken = 'overlay';

type LoadingOverlayCoreProps = {
  isVisible?: boolean;
  size?: LoaderSize;
  zIndex?: ZIndexToken;
} & Pick<ExternalLoaderProps, 'type'>;

type LoadingOverlayDefaultElement = 'div';
const DEFAULT_ELEMENT: LoadingOverlayDefaultElement = 'div';

export type LoadingOverlayProps<C extends React.ElementType = LoadingOverlayDefaultElement> =
  PolymorphicComponentPropWithRef<
    C,
    JsxStyleProps & Partial<LoadingOverlayVariant> & CoreProps & LoadingOverlayCoreProps
  >;

type PolymorphicComponent = <C extends React.ElementType = LoadingOverlayDefaultElement>(
  props: LoadingOverlayProps<C>
) => JSX.Element | null;

/**
 * Loader with overlay.
 *
 * TODO: Add support for container-scoped loader. For now, only full-page works.
 * To work around this, use position: relative in the parent component
 */
export const LoadingOverlay: PolymorphicComponent = forwardRefWithAs<
  LoadingOverlayDefaultElement,
  JsxStyleProps & Partial<LoadingOverlayVariant> & CoreProps & LoadingOverlayCoreProps
>(
  <C extends React.ElementType = LoadingOverlayDefaultElement>(
    { variant, isVisible = true, size = DEFAULT_SIZE, zIndex = DEFAULT_Z_INDEX, ...props }: LoadingOverlayProps<C>,
    ref?: PolymorphicRef<C>
  ) => {
    const [variantProps, loadingOverlayProps] = loadingOverlay.splitVariantProps({
      ...props,
      variant,
      isVisible,
      size,
      zIndex,
    });
    const [cssProps, localProps] = splitCssProps(loadingOverlayProps);
    const { className, as, type, ...otherProps } = localProps;
    const classNames = loadingOverlay(variantProps);

    if (!isVisible) {
      return null;
    }

    return (
      <ExternalLoadingOverlay
        ref={ref}
        component={as ?? DEFAULT_ELEMENT}
        classNames={classNames}
        className={cx(css(cssProps), className)}
        loading
        visible={isVisible}
        loaderProps={{ type, size }}
        // @ts-expect-error
        zIndex={token(`zIndex.${zIndex}`)}
        {...otherProps}
      />
    );
  }
);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { LoaderProps as ExternalLoaderProps, LoadingOverlay as ExternalLoadingOverlay } from '@mantine/core';
import React from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { type LoadingOverlayVariant, loadingOverlay } from '../../../styled-system/recipes';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/loader/index.ts
Tamaño: 34 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './LoadingOverlay';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/components/select/Select.stories.tsx
Tamaño: 1347 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Meta, StoryFn } from '@storybook/react';
import React from 'react';
import { IconBakeryDining, IconRamenDining } from '../../icons';
import { Select } from './Select';

export default {
  title: 'Components/Select',
  component: Select,
  argTypes: {},
} as Meta<typeof Select>;

const Template: StoryFn<typeof Select> = ({ ...args }) => <Select {...args} />;

const data = [
  { value: 'Arial', label: 'Arial' },
  { value: 'Helvetica', label: 'Helvetica' },
  { value: 'Verdana', label: 'Verdana' },
  { value: 'Optima', label: 'Optima' },
  { value: 'Lato', label: 'Lato' },
  { value: 'sans-serif', label: 'sans-serif' },
  { value: 'blitz', label: 'Blitz.js' },
];

export const PrimaryUse = Template.bind({});
PrimaryUse.args = {
  label: 'Font Family',
  data,
  placeholder: 'Select something',
};

export const WithIcon = Template.bind({});
WithIcon.args = {
  label: 'Font Family',
  data,
  description: 'Will be used as the main font-family in the in-app widget',
  placeholder: 'Select something',
  icon: <IconRamenDining size={'32'} />,
};

export const Everything = Template.bind({});
Everything.args = {
  label: 'Font Family',
  data,
  description: 'Will be used as the main font-family in the in-app widget',
  placeholder: 'Select something',
  error: 'There is a fire!',
  icon: <IconBakeryDining size={'32'} />,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Meta, StoryFn } from '@storybook/react';
import React from 'react';
import { IconBakeryDining, IconRamenDining } from '../../icons';
import { Select } from './Select';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/select/Select.tsx
Tamaño: 2305 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Select as ExternalSelect, Loader } from '@mantine/core';
import { forwardRef, ReactNode } from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { select } from '../../../styled-system/recipes';
import { token } from '../../../styled-system/tokens';
import { JsxStyleProps } from '../../../styled-system/types';
import { IconArrowDropDown } from '../../icons';
import { CoreProps, LocalizedMessage, LocalizedString } from '../../types';
import { PolymorphicRef } from '../../types/props-helpers';

export type SelectItem<TItem extends string = string> = {
  value: TItem;
  label: LocalizedString;
  selected?: boolean;
  disabled?: boolean;
};

export type SelectCoreProps<TItem extends string = string> = CoreProps & {
  data: SelectItem[];
  value?: TItem | null;
  defaultValue?: TItem | null;
  label?: LocalizedMessage;
  error?: LocalizedMessage;
  placeholder?: LocalizedString;
  description?: LocalizedMessage;

  onChange?: (value: TItem | null) => void;
  onDropdownOpen?: () => void;
  onDropdownClose?: () => void;

  disabled?: boolean;
  required?: boolean;
  readOnly?: boolean;
  loading?: boolean;
  allowDeselect?: boolean;
  withinPortal?: boolean;

  /** max number of options displayed -- defaults to Infinity */
  limit?: number;
  icon?: ReactNode;
};

export type SelectProps = JsxStyleProps & SelectCoreProps;

export const Select = forwardRef((props: SelectProps, ref?: PolymorphicRef<'input'>) => {
  const [variantProps, selectProps] = select.splitVariantProps(props);
  const [cssProps, localProps] = splitCssProps(selectProps);
  const { onChange, className, icon, loading, ...otherProps } = localProps;
  const selectClassNames = select(variantProps);

  const rightSection = loading ? (
    // TODO: replace with our own loader
    <Loader color={token('colors.icon.main')} size={'24'} />
  ) : (
    (icon ?? <IconArrowDropDown title="select-dropdown-icon" size="32" />)
  );

  return (
    <ExternalSelect
      ref={ref}
      onChange={(event) => onChange?.(event)}
      autoComplete="off"
      rightSection={rightSection}
      rightSectionWidth="auto"
      classNames={selectClassNames}
      className={cx(css(cssProps), className)}
      {...otherProps}
    />
  );
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Select as ExternalSelect, Loader } from '@mantine/core';
import { forwardRef, ReactNode } from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { select } from '../../../styled-system/recipes';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/select/index.ts
Tamaño: 26 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './Select';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/components/table/Table.stories.tsx
Tamaño: 1835 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Badge, Switch } from '@mantine/core';
import { Meta, StoryFn } from '@storybook/react';
import { ColumnDef } from '@tanstack/react-table';
import React, { useState } from 'react';
import { IconOutlineAdd } from '../../icons';
import { Button } from '../Button';
import { Table } from './Table';

export default {
  title: 'Components/Table',
  component: Table,
  argTypes: {
    data: {
      control: false,
    },
    columns: {
      control: false,
    },
  },
} as Meta<typeof Table>;

const SwitchCell = (props) => {
  const [status, setStatus] = useState(props.status);
  const switchHandler = () => {
    setStatus((prev) => (prev === 'Enabled' ? 'Disabled' : 'Enabled'));
  };

  return <Switch label={status} onChange={switchHandler} checked={status === 'Enabled'} />;
};

const BadgeCell = (props) => {
  return (
    <Badge variant="outline" size="md" radius="xs">
      {props.getValue()}
    </Badge>
  );
};

interface IExampleData {
  name: string;
  category: string;
  creationDate: string;
  status: string;
}

const columns: ColumnDef<IExampleData>[] = [
  { accessorKey: 'name', header: 'Name' },
  { accessorKey: 'category', header: 'Category', cell: BadgeCell },
  { accessorKey: 'creationDate', header: 'Date Created' },
  { accessorKey: 'status', header: 'Status', cell: SwitchCell },
];

const data: IExampleData[] = [
  { name: 'Great', category: 'Fun', status: 'Disabled', creationDate: '01/01/2021 16:36' },
  { name: 'Whats up?', category: 'Done', status: 'Enabled', creationDate: '01/01/2021 16:36' },
];

const Template: StoryFn<typeof Table> = ({ ...args }) => (
  <>
    <Button Icon={IconOutlineAdd} variant="transparent" py="50">
      Add row
    </Button>
    <Table columns={columns} data={data} {...args} />
  </>
);

export const PrimaryUse = Template.bind({});
PrimaryUse.args = {};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Badge, Switch } from '@mantine/core';
import { Meta, StoryFn } from '@storybook/react';
import { ColumnDef } from '@tanstack/react-table';
import React, { useState } from 'react';
import { IconOutlineAdd } from '../../icons';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/table/Table.styles.ts
Tamaño: 1528 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { type TableStylesNames } from '@mantine/core';
import { css } from '../../../styled-system/css';

const tableStyles: Partial<Record<TableStylesNames, string>> = {
  tr: css({
    '& td': {
      textOverflow: 'ellipsis',
    },
  }),
  table: css({
    borderCollapse: 'collapse',
    borderSpacingX: '125',
    textStyle: 'text.main',
    '& tr td:first-of-type': {
      pr: '200',
    },
    '& tr th:first-of-type': {
      pr: '200',
    },
    '& tr td:last-child': {
      pr: '200',
    },
    '& tr th:last-child': {
      pr: '200',
    },
    '& thead tr': {
      borderBottom: 'solid',
      borderColor: 'table.header.border',
    },
    '& thead tr th': {
      fontWeight: 'regular',
      textAlign: 'left',
      color: 'typography.text.tertiary',
      borderBottom: 'none',
      borderSpacing: '0',
      py: '75',
    },
    '& tbody tr td': {
      // TODO: replace with token value
      maxWidth: '[100px]',
      // TODO: replace with token value
      height: '[80px]',

      color: 'typography.text.main',
      borderBottom: 'solid',
      borderColor: 'table.row.border',
    },
    '& tbody tr[data-disabled="true"]:hover': {
      cursor: 'default',
    },
    '& tbody tr[data-disabled="false"]:hover': {
      cursor: 'pointer',
    },
    '& tbody tr:last-of-type td': {
      borderBottom: 'solid',
      borderColor: 'table.bottom.border',
    },
    _hover: {
      '& tbody tr:hover': {
        bg: 'table.row.surface.hover',
      },
    },
  }),
};

export default tableStyles;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export default  tableStyles

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/components/table/Table.tsx
Tamaño: 2822 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Table as ExternalTable } from '@mantine/core';
import {
  createColumnHelper as _createColumnHelper,
  CellContext,
  ColumnDefTemplate,
  flexRender,
  getCoreRowModel,
  Row,
  useReactTable,
} from '@tanstack/react-table';
import React, { useMemo } from 'react';
import { CoreProps } from '../../types';

import classes from './Table.styles';

export type IRow<TRow extends object = {}> = Row<TRow>;

/** Component used to render the contents of a cell */
export type CellRendererComponent<TRow, TCellValue> = ColumnDefTemplate<CellContext<TRow, TCellValue>>;

/** Helper for type-safe column definitions */
export const createColumnHelper = _createColumnHelper;

export interface ITableProps<TRow extends object> extends CoreProps {
  columns?: any[];
  data?: TRow[];
  isLoading?: boolean;
  pagination?: any;
  noDataPlaceholder?: React.ReactNode;
  loadingItems?: number;
  hasMore?: boolean;
  onRowClick?: (row: Row<TRow>) => void;
  onRowSelect?: (row: Row<TRow>) => void;
}

/**
 * Table component
 *
 */
export function Table<TRow extends object>({
  columns: userColumns,
  data: userData,
  isLoading = false,
  noDataPlaceholder,
  loadingItems = 10,
  onRowClick,
  onRowSelect,
  ...props
}: ITableProps<TRow>) {
  const columns = useMemo(() => userColumns?.map((col) => ({ ...col })), [userColumns]);
  const data = useMemo(() => (userData || [])?.map((row) => ({ ...row })), [userData]);
  const fakeData = useMemo(() => Array.from({ length: loadingItems }).map((_, index) => ({ index })), [loadingItems]);

  const table = useReactTable<TRow>({
    columns,
    data: isLoading ? (fakeData as TRow[]) : data,
    getCoreRowModel: getCoreRowModel(),
  });

  return (
    <ExternalTable classNames={classes} highlightOnHover {...props}>
      <thead>
        {table.getHeaderGroups().map((headerGroup, i) => {
          return (
            <tr key={headerGroup.id}>
              {headerGroup.headers.map((header) => {
                return <th key={header.id}>{flexRender(header.column.columnDef.header, header.getContext())}</th>;
              })}
            </tr>
          );
        })}
      </thead>
      <tbody>
        {table.getRowModel().rows.map((row) => {
          return (
            <tr
              key={row.id}
              onClick={(e) => {
                e.stopPropagation();
                if (!isLoading && onRowClick) {
                  onRowClick(row);
                }
              }}
              className={classes.tr}
              data-disabled={isLoading || !onRowClick}
            >
              {row.getVisibleCells().map((cell) => {
                return <td key={cell.id}>{flexRender(cell.column.columnDef.cell, cell.getContext())}</td>;
              })}
            </tr>
          );
        })}
      </tbody>
    </ExternalTable>
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Table as ExternalTable } from '@mantine/core';
import {
createColumnHelper as _createColumnHelper,
CellContext,
ColumnDefTemplate,
/** Component used to render the contents of a cell */
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/table/index.ts
Tamaño: 25 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './Table';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/components/tabs/Tabs.stories.tsx
Tamaño: 1540 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Meta, StoryFn } from '@storybook/react';
import React, { ReactNode } from 'react';
import { IconOutlineCode, IconOutlineMiscellaneousServices, IconOutlineVisibility } from '../../icons';
import { LocalizedMessage } from '../../types';

import { Tabs } from './Tabs';

export default {
  title: 'Components/Tabs',

  component: Tabs,

  argTypes: {
    colorPalette: {
      options: ['mode.cloud', 'mode.local'],
      control: { type: 'select' },
    },
  },
} as Meta<typeof Tabs>;

const Template: StoryFn<typeof Tabs> = ({ ...args }) => <Tabs {...args} />;

enum TestTabEnum {
  PREVIEW = 'preview',
  CODE = 'code',
  RANDOM = 'random',
}

const LABELS: Record<TestTabEnum, LocalizedMessage> = {
  [TestTabEnum.PREVIEW]: 'Preview',
  [TestTabEnum.CODE]: 'Code',
  [TestTabEnum.RANDOM]: 'Random',
};

const ICONS: Record<TestTabEnum, ReactNode> = {
  [TestTabEnum.PREVIEW]: <IconOutlineVisibility />,
  [TestTabEnum.CODE]: <IconOutlineCode />,
  [TestTabEnum.RANDOM]: <IconOutlineMiscellaneousServices />,
};

export const Default = Template.bind({});
Default.args = {
  tabConfigs: Object.values(TestTabEnum).map((value) => ({
    value,
    label: LABELS[value],
    content: LABELS[value],
  })),
  defaultValue: TestTabEnum.CODE,
};

export const HorizontalTabMenuWithIcon = Template.bind({});
HorizontalTabMenuWithIcon.args = {
  tabConfigs: Object.values(TestTabEnum).map((value) => ({
    value,
    label: LABELS[value],
    content: LABELS[value],
    icon: ICONS[value],
  })),
  defaultValue: TestTabEnum.RANDOM,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Meta, StoryFn } from '@storybook/react';
import React, { ReactNode } from 'react';
import { IconOutlineCode, IconOutlineMiscellaneousServices, IconOutlineVisibility } from '../../icons';
import { LocalizedMessage } from '../../types';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/tabs/Tabs.tsx
Tamaño: 2107 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Tabs as ExternalTabs, type TabsProps as ExternalTabsProps } from '@mantine/core';
import { forwardRef, ReactNode } from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { tabs } from '../../../styled-system/recipes';
import { JsxStyleProps } from '../../../styled-system/types';
import { CoreProps, LocalizedMessage } from '../../types';
import { PolymorphicRef } from '../../types/props-helpers';

interface ITabProps<TTabType extends string = string> {
  value: TTabType;
  label: LocalizedMessage;
  content?: ReactNode;
  icon?: ReactNode;
}

export interface ITabsProps<TTabType extends string = string>
  extends JsxStyleProps,
    CoreProps,
    Pick<ExternalTabsProps, 'keepMounted'> {
  value?: TTabType;
  defaultValue?: TTabType;
  onTabChange?: (tab: TTabType) => void;
  tabConfigs: ITabProps[];
}

export const Tabs = forwardRef(
  <TTabType extends string = string>(props: ITabsProps<TTabType>, ref?: PolymorphicRef<'div'>) => {
    const [variantProps, tabsProps] = tabs.splitVariantProps({ ...props });
    const [cssProps, localProps] = splitCssProps(tabsProps);
    const { onTabChange, className, tabConfigs, ...otherProps } = localProps;
    const styles = tabs(variantProps);

    return (
      <ExternalTabs
        ref={ref}
        onChange={(newTab: string) => onTabChange?.(newTab as TTabType)}
        orientation="horizontal"
        variant="default"
        classNames={styles}
        className={cx(css(cssProps), className)}
        {...otherProps}
      >
        <ExternalTabs.List>
          {tabConfigs.map((menuTab, i) => (
            <ExternalTabs.Tab value={menuTab.value} leftSection={menuTab.icon} key={`tab-${menuTab.value}`}>
              {menuTab.label}
            </ExternalTabs.Tab>
          ))}
        </ExternalTabs.List>
        {tabConfigs.map((menuTab, i) => (
          <ExternalTabs.Panel value={menuTab.value} key={`tab-panel-${menuTab.value}`}>
            {menuTab.content}
          </ExternalTabs.Panel>
        ))}
      </ExternalTabs>
    );
  }
);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Tabs as ExternalTabs, type TabsProps as ExternalTabsProps } from '@mantine/core';
import { forwardRef, ReactNode } from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { tabs } from '../../../styled-system/recipes';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/tabs/index.ts
Tamaño: 24 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './Tabs';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/components/text/Text.stories.tsx
Tamaño: 714 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Meta } from '@storybook/react';
import React from 'react';
import { Flex } from '../../../styled-system/jsx';
import { Text } from './Text';

export default {
  title: 'Components/Text',
  component: Text,
  argTypes: {},
} as Meta<typeof Text>;

export const all = () => (
  <Flex direction="column" gap="100">
    <Text>Default Body</Text>
    <Text as="span">Default Body as span</Text>
    <Text variant="main">Main text</Text>
    <Text variant="main" fontWeight={'strong'} color="typography.text.feedback.success">
      Success text
    </Text>
    <Text variant="secondary">Secondary text</Text>
    <Text variant="strong">Strong text</Text>
    <Text variant="mono">Mono text</Text>
  </Flex>
);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Meta } from '@storybook/react';
import React from 'react';
import { Flex } from '../../../styled-system/jsx';
import { Text } from './Text';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/text/Text.tsx
Tamaño: 1264 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import React from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { type TextVariantProps, text } from '../../../styled-system/recipes';
import type { JsxStyleProps } from '../../../styled-system/types';
import { CoreProps } from '../../types';
import { forwardRefWithAs, PolymorphicComponentPropWithRef, PolymorphicRef } from '../../types/props-helpers';

export type TextProps<C extends React.ElementType> = PolymorphicComponentPropWithRef<
  C,
  JsxStyleProps & TextVariantProps & CoreProps
>;

type PolymorphicComponent = <C extends React.ElementType = 'p'>(props: TextProps<C>) => JSX.Element | null;

export const Text: PolymorphicComponent = forwardRefWithAs<'p', JsxStyleProps & TextVariantProps & CoreProps>(
  <C extends React.ElementType = 'p'>(props: TextProps<C>, ref?: PolymorphicRef<C>) => {
    const [variantProps, textProps] = text.splitVariantProps(props);
    const [cssProps, localProps] = splitCssProps(textProps);
    const { className, as, ...otherProps } = localProps;
    const styles = text(variantProps);
    const Component = props.as || 'p';

    return <Component ref={ref} className={cx(styles, css(cssProps), className)} {...otherProps} />;
  }
);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import React from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { type TextVariantProps, text } from '../../../styled-system/recipes';
import type { JsxStyleProps } from '../../../styled-system/types';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/text/index.ts
Tamaño: 24 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './Text';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/components/textarea/Textarea.tsx
Tamaño: 1707 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Textarea as ExternalTextarea, type TextareaProps as ExternalTextareaProps } from '@mantine/core';
import { ChangeEventHandler, forwardRef } from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { InputVariant, input } from '../../../styled-system/recipes';
import { JsxStyleProps } from '../../../styled-system/types';
import { CoreProps, LocalizedMessage, LocalizedString } from '../../types';
import { PolymorphicRef } from '../../types/props-helpers';
import { DEFAULT_TEXT_INPUT_TYPE, TextInputType } from '../input';

export interface TextareaProps
  extends JsxStyleProps,
    CoreProps,
    Pick<ExternalTextareaProps, 'leftSection' | 'minRows' | 'maxRows'>,
    Partial<InputVariant> {
  label?: LocalizedMessage;
  description?: LocalizedMessage;
  placeholder?: LocalizedString;
  error?: LocalizedMessage;
  type?: TextInputType;

  required?: boolean;
  readOnly?: boolean;
  disabled?: boolean;

  value?: string;
  defaultValue?: string;
  onChange?: ChangeEventHandler<HTMLTextAreaElement>;
}

export const Textarea = forwardRef((props: TextareaProps, ref?: PolymorphicRef<'textarea'>) => {
  const [variantProps, inputProps] = input.splitVariantProps(props);
  const [cssProps, localProps] = splitCssProps(inputProps);
  const { onChange, className, ...otherProps } = localProps;
  const styles = input(variantProps);

  return (
    <ExternalTextarea
      ref={ref}
      onChange={(event) => onChange?.(event)}
      autoComplete="off"
      classNames={styles}
      className={cx(css(cssProps), className)}
      minRows={1}
      maxRows={4}
      autosize
      {...otherProps}
    />
  );
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Textarea as ExternalTextarea, type TextareaProps as ExternalTextareaProps } from '@mantine/core';
import { ChangeEventHandler, forwardRef } from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { InputVariant, input } from '../../../styled-system/recipes';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/textarea/index.ts
Tamaño: 28 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './Textarea';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/components/title/Title.stories.tsx
Tamaño: 680 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Meta } from '@storybook/react';
import React from 'react';
import { Flex } from '../../../styled-system/jsx';
import { Title } from './Title';

export default {
  title: 'Components/Title',
  component: Title,
  argTypes: {},
} as Meta<typeof Title>;

export const all = () => (
  <Flex direction="column" gap="100">
    <Title>Default title</Title>
    <Title variant="page">Page title</Title>
    <Title variant="section">Section title</Title>
    <Title variant="subsection">Subsection title</Title>
    <Title color="typography.text.feedback.success" textDecoration="underline">
      Styled Title
    </Title>
    <Title as="span">Title as span</Title>
  </Flex>
);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Meta } from '@storybook/react';
import React from 'react';
import { Flex } from '../../../styled-system/jsx';
import { Title } from './Title';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/title/Title.tsx
Tamaño: 1668 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import React, { type ElementType } from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { type TitleVariantProps, title } from '../../../styled-system/recipes';
import type { JsxStyleProps } from '../../../styled-system/types';
import { CoreProps, ExtractGeneric } from '../../types';
import { forwardRefWithAs, PolymorphicComponentPropWithRef, PolymorphicRef } from '../../types/props-helpers';

export type TitleProps<C extends React.ElementType> = PolymorphicComponentPropWithRef<
  C,
  JsxStyleProps & TitleVariantProps & CoreProps
>;

export type TitleVariant = ExtractGeneric<TitleVariantProps['variant']>;

const VARIANT_ELEMENT_LOOKUP: Record<TitleVariant, Extract<ElementType, 'h1' | 'h2' | 'h3'>> = {
  page: 'h1',
  section: 'h2',
  subsection: 'h3',
};

const DEFAULT_VARIANT: TitleVariant = 'page';

type PolymorphicComponent = <C extends React.ElementType = 'h1'>(props: TitleProps<C>) => JSX.Element | null;

export const Title: PolymorphicComponent = forwardRefWithAs<'h1', JsxStyleProps & TitleVariantProps & CoreProps>(
  <C extends React.ElementType = 'h1'>(props: TitleProps<C>, ref?: PolymorphicRef<C>) => {
    const [variantProps, titleProps] = title.splitVariantProps(props);
    const [cssProps, localProps] = splitCssProps(titleProps);
    const { className, as, ...otherProps } = localProps;
    const styles = title(variantProps);
    const Component = props.as || VARIANT_ELEMENT_LOOKUP[(variantProps.variant as TitleVariant) ?? DEFAULT_VARIANT];

    return <Component ref={ref} className={cx(styles, css(cssProps), className)} {...otherProps} />;
  }
);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import React, { type ElementType } from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { type TitleVariantProps, title } from '../../../styled-system/recipes';
import type { JsxStyleProps } from '../../../styled-system/types';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/components/title/index.ts
Tamaño: 25 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './Title';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/hooks/index.ts
Tamaño: 55 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export { useDebouncedCallback } from '@mantine/hooks';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/icons/Icon.const.ts
Tamaño: 114 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IconSize } from './Icon.types';

/**
 * Style Props
 */
export const DEFAULT_ICON_SIZE: IconSize = '20';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/icons/Icon.md
Tamaño: 525 bytes
Lenguaje detectado: Markdown

### CONTENIDO ORIGINAL ###

# Icon

## Background

This group of icons comes from the Material Icons by means of the [react-icons](https://react-icons.github.io/react-icons/icons/md/) package.

### A11y Context

`title` is mandatory to ensure that we are acknowledging a11y as a priority.

## Use

To use an Icon, simply use the [react-icons docs](https://react-icons.github.io/react-icons/icons/md/) for names with "Icon" as a prefix instead of "Md". Alternatively, you can refer to our Storybook!

E.g. instead of using `<Md10k />`, use `<Icon10k />`


### ANALISIS AUTOMATICO (ESPAÑOL) ###

# Icon
## Background
This group of icons comes from the Material Icons by means of the [react-icons](https://react-icons.github.io/react-icons/icons/md/) package.
### A11y Context
## Use
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/icons/Icon.stories.tsx
Tamaño: 1957 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { ActionIcon, Code, Grid, Group, Input } from '@mantine/core';
import { Meta, StoryFn } from '@storybook/react';
import React, { useState } from 'react';
import { styled, VStack } from '../../styled-system/jsx';
import { text } from '../../styled-system/recipes';
import { DEFAULT_ICON_SIZE } from './Icon.const';
import { IconSize, IIconProps } from './Icon.types';
import * as allIcons from './icon-registry';

export default {
  title: 'Icons/Icons',
  args: {
    size: DEFAULT_ICON_SIZE as IconSize,
    color: undefined,
  },
  argTypes: {
    color: { control: 'color' },
  },
} as Meta<IIconProps>;

const Text = styled('p', text);

const IconsWrapper = ({ color, size }: IIconProps) => {
  const [search, setSearch] = useState('');
  const [iconName, setIconName] = useState('IconName');

  return (
    <div style={{ width: '100%', height: '100%', margin: 'auto', overflowY: 'auto' }}>
      <Code block mb={20}>
        {`import { ${iconName} } from '@novu/novui'
     
<${iconName} /> `}
      </Code>
      <Input placeholder="Search" value={search} onChange={(e) => setSearch(e.target.value)} />
      <Grid align="center" gutter="xs" style={{ padding: '10px', paddingTop: '20px', paddingBottom: '20px' }}>
        {Object.entries(allIcons).map(([name, Icon]) => {
          if (name.includes(search.toLowerCase())) {
            return (
              <Grid.Col key={name} span={3}>
                <VStack gap={'75'}>
                  <ActionIcon variant="transparent" onClick={() => setIconName(name)}>
                    <Icon color={color} size={size} />
                  </ActionIcon>
                  <Text fontSize="75">{name}</Text>
                </VStack>
              </Grid.Col>
            );
          }

          return null;
        })}
      </Grid>
    </div>
  );
};

const Template: StoryFn<IIconProps> = ({ ...args }) => <IconsWrapper {...args} />;

export const Icons = Template.bind({});
Icons.args = {};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { ActionIcon, Code, Grid, Group, Input } from '@mantine/core';
import { Meta, StoryFn } from '@storybook/react';
import React, { useState } from 'react';
import { styled, VStack } from '../../styled-system/jsx';
import { text } from '../../styled-system/recipes';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/icons/Icon.types.ts
Tamaño: 943 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CSSProperties, SVGAttributes } from 'react';

/** Icon Size in pixels (to be replaced with values directly from Design System) */
export type IconSize = '16' | '20' | '24' | '32' | '40';

/** A temporary type that accepts a typical CSS color until we have our strict Design System types defined */
type UnsafeIconColor = CSSProperties['color'];

export interface IIconStyleProps {
  /**
   * Default: '20px'.
   *
   * The actual display size in pixels.
   */
  size?: IconSize;
  /**
   * Default: B60
   *
   * WARNING: this is only to be used with colors from the design system, and will later be enforced more strictly
   */
  color?: UnsafeIconColor;
}

export interface IIconProps extends Omit<SVGAttributes<SVGElement>, 'color'>, IIconStyleProps {
  /** Description for accessibility. This is mandatory so that we make a11y a priority with icons */
  title: string;
}
export type IconType = (props: IIconProps) => JSX.Element;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - IconType(props: IIconProps))
Declaraciones 'export' encontradas:
- export  type
- export  interface
- export  interface
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/icons/IconProvider.tsx
Tamaño: 550 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { PropsWithChildren } from 'react';
import { IconContext } from 'react-icons';
import { css } from '../../styled-system/css';
import { DEFAULT_ICON_SIZE } from './Icon.const';

const iconClassName = css({
  verticalAlign: 'middle',
  color: 'typography.text.secondary',
});

export const IconProvider: React.FC<PropsWithChildren<{}>> = ({ children }) => {
  return (
    <IconContext.Provider
      value={{
        size: DEFAULT_ICON_SIZE,
        className: iconClassName,
      }}
    >
      {children}
    </IconContext.Provider>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { PropsWithChildren } from 'react';
import { IconContext } from 'react-icons';
import { css } from '../../styled-system/css';
import { DEFAULT_ICON_SIZE } from './Icon.const';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/icons/icon-registry.ts
Tamaño: 280296 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###


### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/icons/react-icons.d.ts
Tamaño: 579 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { IconSize, IconType as NovuIconType, IIconProps } from './Icon.types';

/** Override Icon types */

declare module 'react-icons' {
  export type IconType = NovuIconType;

  // avoid declaration merging by using type instead of interface below
  export type IconBaseProps = IIconProps;
  export type IconContextProps = {
    color?: IconColor;
    size?: IconSize;
    className?: string;
    attr?: React.SVGAttributes<SVGElement>;
  };

  export declare const DefaultContext: IconContextProps;
  export declare const IconContext: React.Context<IconContextProps>;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  declare
- export  declare

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/ingredients/README.md
Tamaño: 625 bytes
Lenguaje detectado: Markdown

### CONTENIDO ORIGINAL ###

# Ingredients

An _ingredient_ is not a built-in concept in Panda, but rather our own. It represents a reusable piece of styling (especially within recipes) that may not be able to be used via other built-in approaches.

We generate Ingredients using `css.raw({ /* ... */ })` such that we get type-safe use of the token system while outputting raw JavaScript objects (in the form of `SystemStyleObject`) that can then be used in recipes or directly into a className with `css()`.

### Caveats

Ingredients **should not** have dynamic / conditional logic that prevents Panda from being able to generate the styles statically.


### ANALISIS AUTOMATICO (ESPAÑOL) ###

# Ingredients
An _ingredient_ is not a built-in concept in Panda, but rather our own. It represents a reusable piece of styling (especially within recipes) that may not be able to be used via other built-in approaches.
We generate Ingredients using `css.raw({ /* ... */ })` such that we get type-safe use of the token system while outputting raw JavaScript objects (in the form of `SystemStyleObject`) that can then be used in recipes or directly into a className with `css()`.
### Caveats
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/ingredients/colorPaletteGradient.ingredient.ts
Tamaño: 623 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { defineStyles } from '@pandacss/dev';

export const colorPaletteGradientHorizontal = defineStyles({
  bgGradient: `to-r !important`,
  gradientFrom: 'colorPalette.start !important',
  gradientTo: 'colorPalette.end !important',
});

export const colorPaletteGradientText = defineStyles({
  ...colorPaletteGradientHorizontal,
  backgroundClip: 'text',
  WebkitBackgroundClip: 'text',
  WebkitTextFillColor: 'transparent',
});

export const colorPaletteGradientVertical = defineStyles({
  bgGradient: `to-b !important`,
  gradientFrom: 'colorPalette.start !important',
  gradientTo: 'colorPalette.end !important',
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/ingredients/index.ts
Tamaño: 51 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './colorPaletteGradient.ingredient';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/JsonSchemaForm.stories.tsx
Tamaño: 5654 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { RJSFSchema } from '@rjsf/utils';
import { Meta, StoryFn } from '@storybook/react';
import React, { FormEventHandler } from 'react';
import { css } from '../../styled-system/css';
import { HStack } from '../../styled-system/jsx';
import { Button, Title } from '../components';
import { IconOutlineSave } from '../icons';
import { JsonSchemaForm } from './JsonSchemaForm';

export default {
  title: 'Components/JsonSchemaForm',
  component: JsonSchemaForm,
  argTypes: {},
} as Meta<typeof JsonSchemaForm>;

const VARIABLES = [
  'ctrl.a',
  'ctrl.b',
  'ctrl.c',
  'ctrl.d',
  'ctrl.e',
  'payload.var',
  'payload.obj.var',
  'fakeAutocomplete.foo',
  'fakeAutocomplete.bar',
  'fakeAutocomplete.fizz',
  'fakeAutocomplete.buzz',
  'fakeAutocomplete.croissants',
  'fakeAutocomplete.olympics',
  'fakeAutocomplete.aReallyLongStringThatShouldOverflowFromTheContainer',
];

const Template: StoryFn<typeof JsonSchemaForm> = ({ colorPalette, ...args }) => {
  const onSubmit: FormEventHandler<HTMLFormElement> = (event) => {
    event.preventDefault();
    alert('Saving! (but not actually...)');
  };

  return (
    <form onSubmit={onSubmit} className={css({ colorPalette })}>
      <HStack justifyContent="space-between" mb="50">
        <Title variant="subsection">Step controls</Title>
        <Button type="submit" size="sm" Icon={IconOutlineSave}>
          Save
        </Button>
      </HStack>
      <JsonSchemaForm {...args} variables={VARIABLES} />
    </form>
  );
};
export const ExampleForm = Template.bind({});

const schema: RJSFSchema = {
  type: 'object',
  title: 'Example form',
  definitions: {
    locations: {
      enum: ['New York', 'Amsterdam', 'Hong Kong'],
    },
  },
  properties: {
    checkbox: {
      type: 'boolean',
      title: 'Checkbox field',
      default: true,
    },
    text: {
      type: 'string',
      title: 'Text field',
      default: 'lorem ipsum',
    },
    stringFormats: {
      type: 'object',
      title: 'Simple object',
      properties: {
        country: {
          type: 'string',
          title: 'Country',
          default: `Hello {{${VARIABLES[0]}}}, my name is {{invalid}} yo`,
        },
        address: {
          type: 'string',
          title: 'Address',
        },
        location: {
          title: 'Location',
          $ref: '#/definitions/locations',
        },
        anotherObject: {
          type: 'object',
          title: 'Nested example',
          properties: {
            isResidential: {
              type: 'boolean',
              title: 'Is residential?',
            },
            addressType: {
              type: 'string',
              title: 'Address type',
            },
            doubleNestedArray: {
              title: 'Double nested array',
              description: 'An array nested twice',
              type: 'array',
              items: {
                type: 'string',
              },
              minItems: 1,
            },
          },
        },
      },
      required: ['address'],
    },
    strings: {
      type: 'array',
      title: 'Simple String Array',
      description: 'This is a simple string array',
      items: {
        type: 'string',
        default: 'a string indeed',
      },
      minItems: 1,
    },
    booleans: {
      type: 'array',
      title: 'Simple Boolean Array',
      description: 'This is a simple array',
      items: {
        type: 'boolean',
        default: true,
      },
      minItems: 1,
    },
    users: {
      type: 'array',
      title: 'Array of objects',
      items: {
        type: 'object',
        properties: {
          name: {
            type: 'string',
            title: 'Name',
            default: 'John Doe',
          },
          age: { type: 'integer', default: 22, title: 'Age' },
          birthday: {
            type: 'string',
            title: 'Birthday',
            pattern: '\\d{2}-\\d{1,2}',
          },
        },
        required: ['name'],
      },
      minItems: 1,
    },
  },
};

ExampleForm.args = {
  schema,
  formData: { money: 43 },
};

const MATCH_DESIGNS_SCHEMA: RJSFSchema = {
  type: 'object',
  title: 'Email content',
  properties: {
    TeamImage: {
      title: 'TeamImage',
      required: undefined,
      type: 'string',
      default: 'https://react-email-demo-bdj5iju9r-resend.vercel',
    },
    Text: {
      type: 'array',
      title: 'Text',
      minItems: 2,
      items: {
        title: 'InvitedByUsername',
        type: 'string',
      },
    },
    ShowFootage: {
      type: 'boolean',
      title: 'ShowFootage',
      default: true,
    },
  },
};

export const MatchDesigns = Template.bind({});
MatchDesigns.args = {
  schema: MATCH_DESIGNS_SCHEMA,
};

const ARRAY_DESIGNS_SCHEMA: RJSFSchema = {
  type: 'array',
  minItems: 2,
  items: {
    type: 'array',
    title: 'Phone numbers',
    minItems: 2,
    items: {
      type: 'object',
      title: 'Digits',
      properties: {
        strokes: {
          title: 'Strokes',
          type: 'array',
          minItems: 2,
          items: {
            type: 'integer',
          },
        },
      },
    },
  },
};

export const ArrayDesigns = Template.bind({});
ArrayDesigns.args = {
  schema: ARRAY_DESIGNS_SCHEMA,
};

const SIMPLE_AUTOCOMPLETE_SCHEMA: RJSFSchema = {
  type: 'object',
  title: 'Simple autocomplete',
  properties: {
    country: {
      type: 'string',
      title: 'Name',
      default: `Hello {{${VARIABLES[0]}}}, {{ ${VARIABLES[1]} | upcase }} {{invalidRef}} {{badSyntax`,
    },
  },
};

export const SimpleAutocomplete = Template.bind({});
SimpleAutocomplete.args = {
  schema: SIMPLE_AUTOCOMPLETE_SCHEMA,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { RJSFSchema } from '@rjsf/utils';
import { Meta, StoryFn } from '@storybook/react';
import React, { FormEventHandler } from 'react';
import { css } from '../../styled-system/css';
import { HStack } from '../../styled-system/jsx';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/JsonSchemaForm.tsx
Tamaño: 3085 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import Form, { FormProps } from '@rjsf/core';
import { RegistryWidgetsType, UiSchema } from '@rjsf/utils';
import validator from '@rjsf/validator-ajv8';
import { css, cx } from '../../styled-system/css';
import { splitCssProps } from '../../styled-system/jsx';
import { JsxStyleProps } from '../../styled-system/types';

import { CoreProps } from '../types';
import { JSON_SCHEMA_FORM_ID_DELIMITER } from './constants';
import { ArrayFieldItemTemplate, ArrayFieldTemplate, ArrayFieldTitleTemplate } from './templates/ArrayFieldTemplate';
import { AddButton, MoveDownButton, MoveUpButton, RemoveButton } from './templates/IconButton';
import { ObjectFieldTemplate } from './templates/ObjectFieldTemplate';
import { CheckboxWidget, InputEditorWidget, SelectWidget } from './widgets';
import { InputWidget } from './widgets/InputWidget';
import { TextareaWidget } from './widgets/TextareaWidget';

const WIDGETS: RegistryWidgetsType = {
  CheckboxWidget,
  SelectWidget,
  TextWidget: InputEditorWidget,
  URLWidget: InputEditorWidget,
  EmailWidget: InputEditorWidget,
};

/** @deprecated TODO: delete after Autocomplete is fully released */
const LEGACY_WIDGETS: RegistryWidgetsType = {
  CheckboxWidget,
  SelectWidget,
  TextWidget: TextareaWidget,
  URLWidget: InputWidget,
  EmailWidget: InputWidget,
};

const UI_SCHEMA: UiSchema = {
  'ui:globalOptions': { addable: true, copyable: false, label: true, orderable: true },
  'ui:options': {
    hideError: true,
    submitButtonOptions: {
      norender: true,
    },
  },
};

export type JsonSchemaFormProps<TFormData = any> = JsxStyleProps &
  CoreProps &
  Pick<FormProps<TFormData>, 'onChange' | 'onSubmit' | 'onBlur' | 'schema' | 'formData' | 'tagName'> & {
    variables?: string[];
  };

/**
 * Specialized form editor for data passed as JSON.
 */
export function JsonSchemaForm<TFormData = {}>(props: JsonSchemaFormProps<TFormData>) {
  const [cssProps, { className, variables, ...formProps }] = splitCssProps(props);

  const isAutocompleteEnabled = Boolean(variables && variables.length > 0);

  return (
    <Form
      tagName={'fieldset'}
      className={cx(
        css({
          // default elements to hide
          '& .control-label, & .field-description': {
            display: 'none',
          },
          // hide raw text errors
          '& .panel.panel-danger.errors': {
            display: 'none',
          },
        }),
        css(cssProps),
        className
      )}
      // @ts-expect-error
      uiSchema={UI_SCHEMA}
      widgets={isAutocompleteEnabled ? WIDGETS : LEGACY_WIDGETS}
      // @ts-expect-error
      validator={validator}
      liveValidate
      autoComplete={'false'}
      formContext={{ variables }}
      idSeparator={JSON_SCHEMA_FORM_ID_DELIMITER}
      templates={{
        // @ts-expect-error
        ArrayFieldTitleTemplate,
        ArrayFieldTemplate,
        ArrayFieldItemTemplate,
        ObjectFieldTemplate,
        // @ts-expect-error
        ButtonTemplates: { MoveDownButton, AddButton, RemoveButton, MoveUpButton },
      }}
      {...formProps}
    />
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import Form, { FormProps } from '@rjsf/core';
import { RegistryWidgetsType, UiSchema } from '@rjsf/utils';
import validator from '@rjsf/validator-ajv8';
import { css, cx } from '../../styled-system/css';
import { splitCssProps } from '../../styled-system/jsx';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/constants.ts
Tamaño: 1232 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export const JSON_SCHEMA_FORM_ID_DELIMITER = '~~~';

// Backwards compatibility, for allowing usage of variables without namespace (e.g. `{{name}}` instead of `{{payload.name}}`)
export const PAYLOAD_NAMESPACE = 'payload';

export const AUTOCOMPLETE_OPEN_TAG = '{{';
export const AUTOCOMPLETE_CLOSE_TAG = '}}';

export const LIQUID_FILTER_CHAR = '|';

export const VARIABLE_HTML_TAG_NAME = 'autocomplete-variable';

export const AUTOCOMPLETE_REGEX = new RegExp(`${AUTOCOMPLETE_OPEN_TAG}(.*?(.*?))${AUTOCOMPLETE_CLOSE_TAG}`, 'm');

export const VALID_VARIABLE_REGEX = new RegExp(`${AUTOCOMPLETE_OPEN_TAG}([^{}]*?)${AUTOCOMPLETE_CLOSE_TAG}`, 'g');

// To get initial invalid syntax of {{..} or {{..<space>
export const INVALID_VARIABLE_REGEX = new RegExp(
  `(${AUTOCOMPLETE_OPEN_TAG}[^{}|\\s]*[}|\\s](?!})|{{[^{}]*}(?!}})|{{[^{}]*$)`,
  'g'
);

export const VARIABLE_HTML_ERROR_STATE_REGEX = /data-error="([A-Z_])+"/gi;

export enum VariableErrorCode {
  INVALID_SYNTAX = 'INVALID_SYNTAX',
  INVALID_NAME = 'INVALID_NAME',
}

export const VARIABLE_ERROR_MESSAGES: Record<VariableErrorCode, string> = {
  [VariableErrorCode.INVALID_SYNTAX]: 'Incorrect variable syntax',
  [VariableErrorCode.INVALID_NAME]: 'Invalid variable name',
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  enum
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/context.ts
Tamaño: 431 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { createContextAndHook } from '../utils';

export type InputAutocompleteContextValue = { variablesSet: Set<string> };

const [InputAutocompleteContext, _useInputAutocompleteContext] =
  createContextAndHook<InputAutocompleteContextValue>('InputAutocompleteContext');

export const InputAutocompleteContextProvider = InputAutocompleteContext.Provider;
export const useInputAutocompleteContext = _useInputAutocompleteContext;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/shared.tsx
Tamaño: 2138 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { FC, MouseEventHandler } from 'react';
import { cva, cx } from '../../styled-system/css';
import { hstack } from '../../styled-system/patterns';
import { token } from '../../styled-system/tokens';
import { Title } from '../components';
import { IconExpandLess, IconExpandMore } from '../icons';
import { CoreProps, CorePropsWithChildren } from '../types';

export const FormGroupTitle: FC<CorePropsWithChildren> = ({ children, ...titleProps }) => {
  return (
    <Title variant="subsection" color="typography.text.secondary" {...titleProps}>
      {children}
    </Title>
  );
};

type SectionTitleToggleProps = CoreProps &
  Omit<React.ButtonHTMLAttributes<HTMLButtonElement>, 'onClick' | 'children' | 'title'> & {
    onToggle: () => void;
    isExpanded: boolean;
    sectionDepth: number;
    sectionTitle?: React.ReactNode;
  };

const toggleButtonRecipe = cva({
  base: {
    gap: 'margins.icons.Icon20-txt',

    cursor: 'pointer',
    _disabled: {
      cursor: 'default',
    },
    '&:hover:not(:disabled)': {
      opacity: 'hover',
    },
  },
  variants: {
    isExpanded: {
      true: { marginBottom: '100' },
      false: {},
    },
  },
});

export const SectionTitleToggle: FC<SectionTitleToggleProps> = ({
  onToggle,
  isExpanded,
  sectionDepth,
  sectionTitle,
  ...buttonProps
}) => {
  const handleToggle: MouseEventHandler<HTMLButtonElement> = (event) => {
    event.preventDefault();
    onToggle();
  };

  const shouldShowToggle = sectionDepth > 0;

  if (!sectionTitle && !shouldShowToggle) {
    return null;
  }

  return (
    <button
      onClick={handleToggle}
      disabled={!shouldShowToggle}
      className={cx(hstack(), toggleButtonRecipe({ isExpanded: isExpanded || !shouldShowToggle }))}
      {...buttonProps}
    >
      {!shouldShowToggle ? (
        sectionTitle
      ) : (
        <>
          {isExpanded ? (
            <IconExpandLess title="expand-less-section-icon" color={token('colors.typography.text.main')} />
          ) : (
            <IconExpandMore title="expand-more-section-icon" />
          )}
          {sectionTitle}
        </>
      )}
    </button>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { FC, MouseEventHandler } from 'react';
import { cva, cx } from '../../styled-system/css';
import { hstack } from '../../styled-system/patterns';
import { token } from '../../styled-system/tokens';
import { Title } from '../components';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/useExpandToggle.tsx
Tamaño: 259 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { useState } from 'react';

export const useExpandToggle = (defaultValue: boolean = true) => {
  const [isExpanded, setExpanded] = useState<boolean>(defaultValue);

  return [isExpanded, () => setExpanded((prevExpanded) => !prevExpanded)] as const;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { useState } from 'react';
export const useExpandToggle = (defaultValue: boolean = true) => {
const [isExpanded, setExpanded] = useState<boolean>(defaultValue);
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/utils.ts
Tamaño: 3028 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { JsonSchemaFormSectionVariant } from '../../styled-system/recipes';
import {
  AUTOCOMPLETE_CLOSE_TAG,
  AUTOCOMPLETE_OPEN_TAG,
  INVALID_VARIABLE_REGEX,
  JSON_SCHEMA_FORM_ID_DELIMITER,
  PAYLOAD_NAMESPACE,
  VALID_VARIABLE_REGEX,
  VARIABLE_HTML_ERROR_STATE_REGEX,
  VARIABLE_HTML_TAG_NAME,
  VariableErrorCode,
} from './constants';

/** determine the tree depth of a JsonSchemaForm section with the given sectionId */
export function calculateSectionDepth({ sectionId }: { sectionId: string }): number {
  return sectionId.split(JSON_SCHEMA_FORM_ID_DELIMITER).length - 1;
}

export function getVariantFromDepth(depth: number): JsonSchemaFormSectionVariant['depth'] {
  return depth % 2 === 0 ? 'even' : 'odd';
}

export const cleanVariableMatch = (variableMatch?: string): string => {
  if (!variableMatch) {
    return '';
  }

  return variableMatch.replace(AUTOCOMPLETE_OPEN_TAG, '').replace(AUTOCOMPLETE_CLOSE_TAG, '').split('|')[0].trim();
};

const VARIABLE_ERROR_CODE_SET = new Set(Object.values(VariableErrorCode));
export const checkIsValidVariableErrorCode = (input?: string) => {
  if (!input) {
    return false;
  }

  return VARIABLE_ERROR_CODE_SET.has(input as VariableErrorCode);
};

export const getInitContentWithVariableNodeView = (inputString: string, variablesSet: Set<string>) => {
  if (!inputString) {
    return inputString;
  }

  let result = inputString.toString().replace(VALID_VARIABLE_REGEX, (match, validContent) => {
    const cleanedMatch = cleanVariableMatch(match);
    const isValidVariable = variablesSet.has(cleanedMatch);

    return `<${VARIABLE_HTML_TAG_NAME} data-label="${validContent}" data-id="${validContent}" ${
      !isValidVariable ? `data-error="${VariableErrorCode.INVALID_NAME}"` : ''
    }></${VARIABLE_HTML_TAG_NAME}>`;
  });

  result = result?.replace(INVALID_VARIABLE_REGEX, (match) => {
    return `<${VARIABLE_HTML_TAG_NAME} data-label="${match}" data-id="${match}" data-error="${VariableErrorCode.INVALID_SYNTAX}"></${VARIABLE_HTML_TAG_NAME}>`;
  });

  return result;
};

/** Parse editor HTML and extract valid error codes from variable references (if any) */
export const extractErrorCodesFromHtmlContent = (htmlContent?: string): Set<string> | undefined => {
  if (!htmlContent) {
    return;
  }

  const errorCodes = htmlContent
    .match(VARIABLE_HTML_ERROR_STATE_REGEX)
    ?.map((str) => str.match(/"(.*?)"/i)?.[0]?.replaceAll('"', ''))
    ?.filter((code) => checkIsValidVariableErrorCode(code));

  return errorCodes ? new Set(errorCodes) : undefined;
};

// Backwards compatibility, for allowing usage of variables without namespace (e.g. `{{name}}` instead of `{{payload.name}}`)
export const getDeprecatedPayloadVariables = (variables: string[]): string[] => {
  return variables
    .filter((variable: string) => variable.startsWith(`${PAYLOAD_NAMESPACE}.`))
    .map(getVariableWithoutNamespace);
};

export const getVariableWithoutNamespace = (variableName: string): string => {
  return variableName.split('.').splice(1).join('.');
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - calculateSectionDepth({ sectionId }: { sectionId: string })
 - getVariantFromDepth(depth: number)
Asignaciones con arrow functions encontradas (posibles funciones):
 - cleanVariableMatch(variableMatch?: string): string)
 - checkIsValidVariableErrorCode(input?: string))
 - getInitContentWithVariableNodeView(inputString: string, variablesSet: Set<string>))
 - result(inputString.toString().replace(VALID_VARIABLE_REGEX, (match, validContent))
 - result(result?.replace(INVALID_VARIABLE_REGEX, (match))
 - extractErrorCodesFromHtmlContent(htmlContent?: string): Set<string> | undefined)
 - errorCodes(htmlContent
    .match(VARIABLE_HTML_ERROR_STATE_REGEX)
    ?.map((str))
 - getDeprecatedPayloadVariables(variables: string[]): string[])
 - getVariableWithoutNamespace(variableName: string): string)
Declaraciones 'export' encontradas:
- export function calculateSectionDepth
- export function getVariantFromDepth
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/templates/ArrayFieldTemplate.tsx
Tamaño: 3758 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import {
  ArrayFieldTemplateItemType,
  ArrayFieldTemplateProps,
  ArrayFieldTitleProps,
  getTemplate,
  getUiOptions,
} from '@rjsf/utils';
import { css } from '../../../styled-system/css';
import { Box } from '../../../styled-system/jsx';
import { jsonSchemaFormArrayToolbar, jsonSchemaFormSection } from '../../../styled-system/recipes';
import { FormGroupTitle, SectionTitleToggle } from '../shared';
import { useExpandToggle } from '../useExpandToggle';
import { calculateSectionDepth, getVariantFromDepth } from '../utils';

export function ArrayFieldTemplate(props: ArrayFieldTemplateProps) {
  const [isExpanded, toggleExpanded] = useExpandToggle();

  const { canAdd, disabled, idSchema, uiSchema, items, onAddClick, readonly, registry, required, title, schema } =
    props;
  const {
    ButtonTemplates: { AddButton },
  } = registry.templates;
  const uiOptions = getUiOptions(uiSchema);
  const ArrayFieldTitleTemplate = getTemplate('ArrayFieldTitleTemplate', registry, uiOptions);
  const ArrayFieldItemTemplate = getTemplate('ArrayFieldItemTemplate', registry, uiOptions);

  const sectionDepth = calculateSectionDepth({ sectionId: props.idSchema.$id });
  const depthVariant = getVariantFromDepth(sectionDepth);

  const sectionClassNames = jsonSchemaFormSection({
    depth: depthVariant,
  });

  return (
    <Box className={sectionClassNames.sectionRoot}>
      <SectionTitleToggle
        onToggle={toggleExpanded}
        isExpanded={isExpanded}
        sectionDepth={sectionDepth}
        sectionTitle={
          uiOptions.title || title ? (
            <ArrayFieldTitleTemplate
              idSchema={idSchema}
              title={uiOptions.title || title}
              schema={schema}
              uiSchema={uiSchema}
              required={required}
              registry={registry}
            />
          ) : undefined
        }
      />
      {isExpanded ? (
        <>
          {items.map(({ key, ...itemProps }) => {
            return <ArrayFieldItemTemplate key={key} {...itemProps} />;
          })}
          {canAdd && (
            <AddButton
              onClick={onAddClick}
              disabled={disabled || readonly}
              registry={registry}
              className={css({ mt: '150' })}
            />
          )}
        </>
      ) : null}
    </Box>
  );
}

export function ArrayFieldTitleTemplate({ title }: ArrayFieldTitleProps) {
  return <FormGroupTitle>{title}</FormGroupTitle>;
}

export function ArrayFieldItemTemplate(props: ArrayFieldTemplateItemType) {
  const {
    children,
    disabled,
    hasMoveDown,
    hasMoveUp,
    hasRemove,
    index,
    onDropIndexClick,
    onReorderClick,
    readonly,
    registry,
    schema,
  } = props;
  const { MoveDownButton, MoveUpButton, RemoveButton } = registry.templates.ButtonTemplates;

  const toolbarClassNames = jsonSchemaFormArrayToolbar({
    itemType: typeof schema.type === 'object' ? schema.type[0] : schema.type,
  });

  return (
    <div className={toolbarClassNames.toolbarWrapper}>
      {children}
      <div role="toolbar" className={toolbarClassNames.toolbar}>
        {(hasMoveUp || hasMoveDown) && (
          <MoveUpButton
            disabled={disabled || readonly || !hasMoveUp}
            onClick={onReorderClick(index, index - 1)}
            registry={registry}
          />
        )}
        {(hasMoveUp || hasMoveDown) && (
          <MoveDownButton
            disabled={disabled || readonly || !hasMoveDown}
            onClick={onReorderClick(index, index + 1)}
            registry={registry}
          />
        )}
        {hasRemove && (
          <RemoveButton disabled={disabled || readonly} onClick={onDropIndexClick(index)} registry={registry} />
        )}
      </div>
    </div>
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import {
ArrayFieldTemplateItemType,
ArrayFieldTemplateProps,
ArrayFieldTitleProps,
getTemplate,
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/templates/IconButton.tsx
Tamaño: 1140 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { IconButtonProps } from '@rjsf/utils';
import { css, cx } from '../../../styled-system/css';
import { Button, IconButton } from '../../components';
import { IconAdd, IconArrowDownward, IconArrowUpward, IconOutlineDeleteOutline } from '../../icons/icon-registry';

type Props = Omit<IconButtonProps, 'color' | 'translate' | 'iconType' | 'icon'>;

export function RemoveButton(props: Props) {
  return <IconButton {...props} Icon={IconOutlineDeleteOutline} title="remove" />;
}

export function MoveUpButton(props: Props) {
  return <IconButton {...props} Icon={IconArrowUpward} title="move-up" />;
}

export function MoveDownButton(props: Props) {
  return <IconButton {...props} Icon={IconArrowDownward} title="move-down" />;
}

export function AddButton({ className, ...props }: Props) {
  return (
    <Button
      {...props}
      variant={'transparent'}
      size="md"
      Icon={IconAdd}
      className={cx(
        css({
          '& span': {
            color: 'typography.text.main',
            WebkitTextFillColor: 'unset',
          },
        }),
        className
      )}
    >
      Add item
    </Button>
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { IconButtonProps } from '@rjsf/utils';
import { css, cx } from '../../../styled-system/css';
import { Button, IconButton } from '../../components';
import { IconAdd, IconArrowDownward, IconArrowUpward, IconOutlineDeleteOutline } from '../../icons/icon-registry';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/templates/ObjectFieldTemplate.tsx
Tamaño: 1238 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { ObjectFieldTemplateProps } from '@rjsf/utils';
import { Box } from '../../../styled-system/jsx';
import { jsonSchemaFormSection } from '../../../styled-system/recipes';
import { FormGroupTitle, SectionTitleToggle } from '../shared';
import { useExpandToggle } from '../useExpandToggle';
import { calculateSectionDepth, getVariantFromDepth } from '../utils';

export function ObjectFieldTemplate(props: ObjectFieldTemplateProps) {
  const [isExpanded, toggleExpanded] = useExpandToggle();

  const sectionDepth = calculateSectionDepth({ sectionId: props.idSchema.$id });
  const depthVariant = getVariantFromDepth(sectionDepth);

  const sectionClassNames = jsonSchemaFormSection({
    depth: depthVariant,
  });

  return (
    <Box className={sectionClassNames.sectionRoot}>
      <SectionTitleToggle
        onToggle={toggleExpanded}
        isExpanded={isExpanded}
        sectionDepth={sectionDepth}
        sectionTitle={props.title ? <FormGroupTitle>{props.title}</FormGroupTitle> : undefined}
      ></SectionTitleToggle>
      {isExpanded ? (
        <>
          {props.properties.map((element) => (
            <Box key={element.name}>{element.content}</Box>
          ))}
        </>
      ) : null}
    </Box>
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { ObjectFieldTemplateProps } from '@rjsf/utils';
import { Box } from '../../../styled-system/jsx';
import { jsonSchemaFormSection } from '../../../styled-system/recipes';
import { FormGroupTitle, SectionTitleToggle } from '../shared';
import { useExpandToggle } from '../useExpandToggle';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/widgets/CheckboxWidget.tsx
Tamaño: 443 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { WidgetProps } from '@rjsf/utils';
import { Checkbox } from '../../components/checkbox/Checkbox';

export const CheckboxWidget = (props: WidgetProps) => {
  return (
    <Checkbox
      checked={typeof props.value === 'undefined' ? false : props.value}
      description={props.schema.description}
      onChange={({ target }) => props.onChange(target.checked)}
      required={props.required}
      label={props.label}
    />
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { WidgetProps } from '@rjsf/utils';
import { Checkbox } from '../../components/checkbox/Checkbox';
export const CheckboxWidget = (props: WidgetProps) => {
return (
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/widgets/InputEditorWidget.tsx
Tamaño: 6033 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Input } from '@mantine/core';
import { RichTextEditor } from '@mantine/tiptap';
import { ErrorSchema, WidgetProps } from '@rjsf/utils';
import Document from '@tiptap/extension-document';
import HistoryExtension from '@tiptap/extension-history';
import Paragraph from '@tiptap/extension-paragraph';
import Text from '@tiptap/extension-text';
import { Editor, type Extensions, ReactRenderer, useEditor } from '@tiptap/react';
import { useEffect, useMemo, useRef } from 'react';
import { css, cx } from '../../../styled-system/css';
import { splitCssProps } from '../../../styled-system/jsx';
import { input, inputEditorWidget } from '../../../styled-system/recipes';
import { AUTOCOMPLETE_OPEN_TAG, VARIABLE_ERROR_MESSAGES } from '../constants';
import { InputAutocompleteContextProvider } from '../context';
import {
  extractErrorCodesFromHtmlContent,
  getDeprecatedPayloadVariables,
  getInitContentWithVariableNodeView,
} from '../utils';
import { CustomMention } from './customMentionExtension';
import { SuggestionListExtension, SuggestionListStorage } from './SuggestionListExtension';
import { SuggestionListRef, VariableItem, VariableSuggestionList } from './VariableSuggestionList';

const inputEditorClassNames = inputEditorWidget();

const DEFAULT_EDITOR_EXTENSIONS: Extensions = [Document, Paragraph, Text, HistoryExtension];

export const InputEditorWidget = (props: WidgetProps) => {
  const { value, label, formContext, onChange, required, readonly, rawErrors } = props;

  const [variantProps, inputProps] = input.splitVariantProps({});
  const [cssProps] = splitCssProps(inputProps);
  const classNames = input(variantProps);

  const reactRenderer = useRef<ReactRenderer<SuggestionListRef>>(null);

  const { variables = [] } = formContext;
  const [variablesList, variablesSet] = useMemo<[VariableItem[], Set<string>]>(() => {
    const variableDisplayList = variables?.map((variable: string) => {
      return { label: variable, id: variable };
    });

    return [variableDisplayList, new Set([...variables, ...getDeprecatedPayloadVariables(variables)])];
  }, [variables]);

  const extensions = useMemo(() => {
    if (!variablesList || variablesList.length === 0) {
      return DEFAULT_EDITOR_EXTENSIONS;
    }

    return DEFAULT_EDITOR_EXTENSIONS.concat([
      SuggestionListExtension,
      CustomMention().configure({
        suggestion: {
          items: ({ editor, query }) => {
            const { suggestions } = editor.storage.SuggestionListStorage as SuggestionListStorage;

            return suggestions?.filter((item) => item.label.toLowerCase().includes(query.toLowerCase().trim()));
          },
          char: AUTOCOMPLETE_OPEN_TAG,
          decorationTag: 'span',
          decorationClass: 'suggestion',
          allowSpaces: true,
          allowedPrefixes: null,
          render() {
            return {
              onStart: (onStartProps) => {
                reactRenderer.current = new ReactRenderer(VariableSuggestionList, {
                  props: onStartProps,
                  editor: onStartProps.editor,
                });
              },
              onUpdate(onUpdateProps) {
                reactRenderer.current?.updateProps(onUpdateProps);
              },
              onKeyDown(onKeyDownProps) {
                if (!reactRenderer.current?.ref) {
                  return false;
                }

                return reactRenderer.current?.ref.onKeyDown(onKeyDownProps);
              },
              onExit() {
                reactRenderer.current?.destroy();
              },
            };
          },
        },
      }),
    ]);
  }, [variablesList]);

  const handleEditorUpdateWithValidation = ({ editor }: { editor: Editor }) => {
    const content = editor.isEmpty ? undefined : editor.getText();
    const htmlContent = editor.isEmpty ? undefined : editor.getHTML();

    // extract error messages from HTML and convert to user-friendly messages
    const parsedErrorCodes = extractErrorCodesFromHtmlContent(htmlContent);

    const errorMessages: string[] | undefined =
      parsedErrorCodes && parsedErrorCodes.size > 0
        ? [...parsedErrorCodes.values()].map((code) => VARIABLE_ERROR_MESSAGES[code])
        : undefined;

    onChange(content, { __errors: errorMessages } as ErrorSchema);
  };

  const editor = useEditor({
    extensions,
    content: '',
    editable: !readonly,
    parseOptions: {},
    onFocus: () => {
      reactRenderer.current?.ref?.focus();
    },
    onBlur: () => {
      reactRenderer.current?.ref?.blur();
    },
    onUpdate: ({ editor: editorInstance }) => {
      handleEditorUpdateWithValidation({ editor: editorInstance });
    },
  });

  // keep the suggestion list popover synced with the component state
  useEffect(() => {
    if (editor) {
      editor.storage.SuggestionListStorage.suggestions = variablesList;
    }
  }, [variablesList, editor]);

  useEffect(() => {
    if (editor) {
      const output = getInitContentWithVariableNodeView(value?.toString(), variablesSet);

      // Set timeout is for a known tiptap error with setting content on initial render https://github.com/ueberdosis/tiptap/issues/3764
      const timeoutId = setTimeout(() => {
        editor.commands.setContent(output);
        // validate on initial render
        handleEditorUpdateWithValidation({ editor });
      });

      return () => {
        clearTimeout(timeoutId);
      };
    }
  }, [variablesSet]);

  return (
    <InputAutocompleteContextProvider value={{ value: { variablesSet } }}>
      <Input.Wrapper
        classNames={classNames}
        className={cx('group', css(cssProps))}
        required={required}
        label={label}
        description={props.schema.description}
        error={rawErrors?.length > 0 && rawErrors.join(', ')}
      >
        <RichTextEditor classNames={inputEditorClassNames} editor={editor} spellCheck={false}>
          <RichTextEditor.Content />
        </RichTextEditor>
      </Input.Wrapper>
    </InputAutocompleteContextProvider>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Input } from '@mantine/core';
import { RichTextEditor } from '@mantine/tiptap';
import { ErrorSchema, WidgetProps } from '@rjsf/utils';
import Document from '@tiptap/extension-document';
import HistoryExtension from '@tiptap/extension-history';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/widgets/InputWidget.tsx
Tamaño: 838 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { getInputProps, WidgetProps } from '@rjsf/utils';
import { Input, TextInputType } from '../../components/input/Input';

/**
 * @deprecated
 * Use `InputEditorWidget` instead
 */
export const InputWidget = (props: WidgetProps) => {
  const { type, value, label, schema, onChange, options, required, readonly, rawErrors, disabled } = props;
  const inputProps = getInputProps(schema, type, options);

  return (
    <Input
      description={props.schema.description}
      onChange={(event) => {
        event.preventDefault();
        onChange(event.target.value);
      }}
      value={value || value === 0 ? value : ''}
      required={required}
      label={label}
      type={inputProps.type as TextInputType}
      error={rawErrors?.length > 0 && rawErrors}
      readOnly={readonly}
      disabled={disabled}
    />
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { getInputProps, WidgetProps } from '@rjsf/utils';
import { Input, TextInputType } from '../../components/input/Input';
/**
* @deprecated
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/widgets/SelectWidget.tsx
Tamaño: 729 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { WidgetProps } from '@rjsf/utils';
import { Select } from '../../components';

export const SelectWidget = (props: WidgetProps) => {
  const { options, label, required, disabled, readonly, value, schema, onChange, rawErrors } = props;
  const data = options.enumOptions.map((option) => {
    return {
      label: option.label,
      value: String(option.value),
    };
  });

  return (
    <Select
      description={schema.description}
      onChange={onChange}
      value={typeof value === 'undefined' || !value ? null : String(value)}
      required={required}
      label={label}
      data={data}
      disabled={disabled}
      readOnly={readonly}
      error={rawErrors?.length > 0 && rawErrors}
    />
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { WidgetProps } from '@rjsf/utils';
import { Select } from '../../components';
export const SelectWidget = (props: WidgetProps) => {
const { options, label, required, disabled, readonly, value, schema, onChange, rawErrors } = props;
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/widgets/SuggestionListExtension.tsx
Tamaño: 361 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Extension } from '@tiptap/react';

import { VariableItem } from './VariableSuggestionList';

export type SuggestionListStorage = {
  suggestions: VariableItem[];
};
export const SuggestionListExtension = Extension.create<{}, SuggestionListStorage>({
  name: 'SuggestionListStorage',
  addStorage() {
    return {
      suggestions: [],
    };
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Extension } from '@tiptap/react';
import { VariableItem } from './VariableSuggestionList';
export type SuggestionListStorage = {
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/widgets/TextareaWidget.tsx
Tamaño: 835 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { getInputProps, WidgetProps } from '@rjsf/utils';
import { Textarea, TextInputType } from '../../components';

/**
 * @deprecated
 * Use `InputEditorWidget` instead
 */
export const TextareaWidget = (props: WidgetProps) => {
  const { type, value, label, schema, onChange, options, required, readonly, rawErrors, disabled } = props;
  const inputProps = getInputProps(schema, type, options);

  return (
    <Textarea
      description={props.schema.description}
      onChange={(event) => {
        event.preventDefault();
        onChange(event.target.value);
      }}
      value={value || value === 0 ? value : ''}
      required={required}
      label={label}
      type={inputProps.type as TextInputType}
      error={rawErrors?.length > 0 && rawErrors}
      readOnly={readonly}
      disabled={disabled}
    />
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { getInputProps, WidgetProps } from '@rjsf/utils';
import { Textarea, TextInputType } from '../../components';
/**
* @deprecated
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/widgets/Variable.tsx
Tamaño: 3056 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { NodeViewContent, NodeViewProps, NodeViewWrapper } from '@tiptap/react';
import { ChangeEvent, FocusEvent, useEffect, useState } from 'react';
import {
  AUTOCOMPLETE_CLOSE_TAG,
  AUTOCOMPLETE_OPEN_TAG,
  AUTOCOMPLETE_REGEX,
  LIQUID_FILTER_CHAR,
  VariableErrorCode,
} from '../constants';
import { useInputAutocompleteContext } from '../context';

export function Variable({ editor, node, updateAttributes, ...props }: NodeViewProps) {
  const [errorCode, setErrorCode] = useState<VariableErrorCode | undefined>();

  const { variablesSet } = useInputAutocompleteContext();

  const updateVariableAttributes = (label: string, newErrorCode?: VariableErrorCode) => {
    updateAttributes({ label, error: newErrorCode });
    setErrorCode(newErrorCode);
  };

  // Initialize error state after validating variable
  useEffect(() => {
    if (variablesSet && variablesSet.size > 0 && !getValidatedVariable(node.attrs.label, variablesSet)) {
      setErrorCode(VariableErrorCode.INVALID_NAME);
    }
  }, [node.attrs.label, variablesSet]);

  // In case of an invalid variable input, set content to be the label variable which will include the whole invalid variable
  const renderedNodeViewContent = !node.attrs.label.includes(AUTOCOMPLETE_OPEN_TAG)
    ? `${AUTOCOMPLETE_OPEN_TAG}${node.attrs.label}${AUTOCOMPLETE_CLOSE_TAG}`
    : `${node.attrs.label}`;

  return (
    <NodeViewWrapper as={'span'} contentEditable={'false'} suppressContentEditableWarning>
      <NodeViewContent
        as={'span'}
        className={'suggestion'}
        contentEditable
        suppressContentEditableWarning
        data-error={errorCode}
        onInput={(event: ChangeEvent<HTMLInputElement>) => {
          const text = event.target.innerText;
          const variable = getValidatedVariable(text, variablesSet);

          if (variable) {
            updateVariableAttributes(variable);

            return;
          }

          // remove empty node
          if (text.length === 0) {
            props.deleteNode();
            editor.commands.focus();
          }
        }}
        onBlur={(event: FocusEvent<HTMLInputElement>) => {
          const text = event.target.innerText;
          const variable = getValidatedVariable(text, variablesSet);

          if (variable) {
            updateVariableAttributes(variable);
          } else {
            updateVariableAttributes(text, VariableErrorCode.INVALID_NAME);
          }
        }}
      >
        {renderedNodeViewContent}
      </NodeViewContent>
    </NodeViewWrapper>
  );
}
/**
 * Get the variable name from input text if a valid reference exists. Otherwise, returns undefined.
 */
function getValidatedVariable(text: string = '', possibleVariables: Set<string>) {
  const variableContent = text.includes(AUTOCOMPLETE_OPEN_TAG) ? text.match(AUTOCOMPLETE_REGEX)?.[1] : text;

  if (!variableContent) {
    return;
  }

  const variableName = variableContent.split(LIQUID_FILTER_CHAR)[0].trim();

  if (!possibleVariables.has(variableName)) {
    return;
  }

  return variableContent;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { NodeViewContent, NodeViewProps, NodeViewWrapper } from '@tiptap/react';
import { ChangeEvent, FocusEvent, useEffect, useState } from 'react';
import {
AUTOCOMPLETE_CLOSE_TAG,
AUTOCOMPLETE_OPEN_TAG,
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/widgets/VariableSuggestionList.tsx
Tamaño: 4644 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Combobox, useCombobox, VisuallyHidden } from '@mantine/core';
import { SuggestionKeyDownProps, type SuggestionProps } from '@tiptap/suggestion';
import React, { forwardRef, useEffect, useImperativeHandle } from 'react';
import { createPortal } from 'react-dom';
import { variableSuggestionList } from '../../../styled-system/recipes';
import { Text } from '../../components';
import { AUTOCOMPLETE_CLOSE_TAG, AUTOCOMPLETE_OPEN_TAG, VariableErrorCode } from '../constants';
import { useInputAutocompleteContext } from '../context';
import { cleanVariableMatch } from '../utils';

export type VariableItem = {
  id: string;
  label: string;
};

export type SuggestionListRef = {
  onKeyDown: (props: SuggestionKeyDownProps) => boolean;
  focus: () => void;
  blur: () => void;
  close: () => void;
};

type SuggestionListProps = SuggestionProps<VariableItem>;

const suggestionListClassNames = variableSuggestionList();

export const VariableSuggestionList = forwardRef<SuggestionListRef, SuggestionListProps>(
  ({ clientRect, command, query, items }, ref) => {
    const combobox = useCombobox({
      defaultOpened: true,
      onDropdownOpen: () => combobox.selectFirstOption(),
    });

    const { variablesSet } = useInputAutocompleteContext();

    useEffect(() => {
      combobox.selectFirstOption();
    }, [items]);

    // called on entering the AUTOCOMPLETE_CLOSE_TAG or onBlur of the variable entry
    const customVariableLabel = () => {
      // ensure query has closing characters
      if (!query.endsWith(AUTOCOMPLETE_CLOSE_TAG)) {
        command({ label: `${AUTOCOMPLETE_OPEN_TAG}${query}`, id: '', error: VariableErrorCode.INVALID_SYNTAX });

        return;
      }

      // extract variable name without special closing characters
      const variableName = cleanVariableMatch(query);
      const cleanedQuery = query.slice(0, -AUTOCOMPLETE_CLOSE_TAG.length);

      // set error if the variable is not a valid reference
      if (!variablesSet.has(variableName)) {
        command({ label: cleanedQuery, id: '', error: VariableErrorCode.INVALID_NAME });

        return;
      }

      // happy path -- valid variable reference
      return command({ label: cleanedQuery, id: variableName });
    };

    const options = items?.map((item) => (
      <Combobox.Option value={item.id} key={item.id}>
        {item.label}
      </Combobox.Option>
    ));

    useImperativeHandle(ref, () => ({
      close: () => {
        combobox.closeDropdown();
      },
      focus: () => {
        combobox.openDropdown();
      },
      blur: () => {
        customVariableLabel();
      },
      onKeyDown: ({ event }) => {
        if (event.key === 'Escape') {
          combobox.closeDropdown();

          return true;
        }
        if (event.key === 'ArrowDown') {
          combobox.selectNextOption();

          return true;
        }
        if (event.key === 'ArrowRight') {
          customVariableLabel();

          return true;
        }
        if (event.code === 'Space') {
          // don't allow Space to close variable entry if the user hasn't typed the closing tag
          if (!query.endsWith(AUTOCOMPLETE_CLOSE_TAG)) {
            return false;
          }
          customVariableLabel();

          return true;
        }
        if (event.key === 'ArrowUp') {
          combobox.selectPreviousOption();

          return true;
        }

        if (event.key === 'Enter') {
          combobox.clickSelectedOption();

          return true;
        }

        return false;
      },
    }));

    const handleCommand = (id: string) => {
      const foundItem = items.find((item) => item.id === id);
      if (!foundItem) {
        return;
      }

      command(foundItem);
    };

    return createPortal(
      <Combobox
        store={combobox}
        classNames={suggestionListClassNames}
        withinPortal={false}
        onOptionSubmit={(suggestionId) => {
          handleCommand(suggestionId);
          combobox.closeDropdown();
        }}
      >
        <Combobox.DropdownTarget>
          <VisuallyHidden
            style={{
              position: 'absolute',
              top: clientRect?.()?.bottom,
              left: clientRect?.()?.left,
            }}
          />
        </Combobox.DropdownTarget>
        <Combobox.Dropdown>
          <Combobox.Options>
            {options.length > 0 ? (
              options
            ) : (
              <Combobox.Empty>
                <Text>Nothing found</Text>
              </Combobox.Empty>
            )}
          </Combobox.Options>
        </Combobox.Dropdown>
      </Combobox>,
      document.body
    );
  }
);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Combobox, useCombobox, VisuallyHidden } from '@mantine/core';
import { SuggestionKeyDownProps, type SuggestionProps } from '@tiptap/suggestion';
import React, { forwardRef, useEffect, useImperativeHandle } from 'react';
import { createPortal } from 'react-dom';
import { variableSuggestionList } from '../../../styled-system/recipes';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/widgets/customMentionExtension.tsx
Tamaño: 1946 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Mention as ExternalMention } from '@tiptap/extension-mention';
import { mergeAttributes, NodeViewProps, ReactNodeViewRenderer } from '@tiptap/react';
import { AUTOCOMPLETE_CLOSE_TAG, AUTOCOMPLETE_OPEN_TAG, VARIABLE_HTML_TAG_NAME } from '../constants';
import { checkIsValidVariableErrorCode } from '../utils';
import { Variable } from './Variable';

export const CustomMention = () => {
  return ExternalMention.extend({
    name: ExternalMention.name,
    content: 'text*',
    atom: false,
    inline: true,
    addAttributes() {
      return {
        ...this.parent?.(),
        error: {
          default: null,
          parseHTML: (element) => element.getAttribute('data-error'),
          renderHTML: (attributes) => {
            if (!attributes.error) {
              return {};
            }

            return {
              'data-error': attributes.error,
            };
          },
        },
      };
    },
    // called on attempting to add a mention
    addNodeView() {
      return ReactNodeViewRenderer(Variable, {
        attrs: { contentEditable: 'false' },
        update: () => {
          return true;
        },
      });
    },
    parseHTML() {
      return [
        {
          tag: VARIABLE_HTML_TAG_NAME,
        },
      ];
    },
    renderText({ node }) {
      return checkIfNodeHasError(node)
        ? node.attrs.label
        : `${AUTOCOMPLETE_OPEN_TAG}${node.attrs.label ?? node.attrs.id}${AUTOCOMPLETE_CLOSE_TAG}`;
    },
    renderHTML({ HTMLAttributes, node }) {
      const htmlOutput = checkIfNodeHasError(node)
        ? node.attrs.label
        : `${AUTOCOMPLETE_OPEN_TAG}${node.attrs.label ?? node.attrs.id}${AUTOCOMPLETE_CLOSE_TAG}`;

      return [VARIABLE_HTML_TAG_NAME, mergeAttributes(HTMLAttributes), htmlOutput];
    },
  });
};

function checkIfNodeHasError(node: NodeViewProps['node']): boolean {
  return node.attrs.error && checkIsValidVariableErrorCode(node.attrs.error);
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Mention as ExternalMention } from '@tiptap/extension-mention';
import { mergeAttributes, NodeViewProps, ReactNodeViewRenderer } from '@tiptap/react';
import { AUTOCOMPLETE_CLOSE_TAG, AUTOCOMPLETE_OPEN_TAG, VARIABLE_HTML_TAG_NAME } from '../constants';
import { checkIsValidVariableErrorCode } from '../utils';
import { Variable } from './Variable';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/json-schema-components/widgets/index.ts
Tamaño: 103 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './CheckboxWidget';
export * from './InputEditorWidget';
export * from './SelectWidget';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/panda-sandbox/css.stories.tsx
Tamaño: 1350 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Meta, StoryFn } from '@storybook/react/*';
import React from 'react';
import { css, cx } from '../../styled-system/css';

export default {
  title: 'Panda Sandbox/css',
} as Meta;

// css simply outputs a className string
const className = css({
  padding: '200',
  margin: '150',
  textAlign: 'center',
  borderRadius: '100',
  backgroundColor: 'surface.panel',
  fontFamily: 'system',
  fontSize: '225',
  fontWeight: 'strong',
  color: 'typography.text.feedback.success',

  _hover: {
    bg: 'button.secondary.background',
    cursor: 'crosshair',
    boxShadow: 'medium',
    // pink is not a valid token in our system, so we use [] as an escape syntax
    color: '[pink]',
  },
});

const StandardTemplate: StoryFn = ({ ...args }) => {
  return <div className={className}>Hello Panda 🐼! css()</div>;
};

export const Standard = StandardTemplate.bind({});
Standard.args = {};

/**
 * cx is a Panda-generated function for merging classNames. You can just concatenate strings, but cx is cleaner.
 * Like in normal css, later-defined properties take precedence.
 */
const CombinedTemplate: StoryFn = ({ ...args }) => {
  return <div className={cx(className, css({ color: 'typography.text.feedback.warning' }))}>Hello Panda 🐼! cx()</div>;
};

export const Combined = CombinedTemplate.bind({ title: 'HELLLLO!s' });
Combined.args = {};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Meta, StoryFn } from '@storybook/react/*';
import React from 'react';
import { css, cx } from '../../styled-system/css';
export default {
// css simply outputs a className string
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/panda-sandbox/recipes/cva.stories.tsx
Tamaño: 3119 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Meta, StoryFn } from '@storybook/react/*';
import React from 'react';
import { css, cva, cx } from '../../../styled-system/css';
import { Stack, styled, Wrap } from '../../../styled-system/jsx';

export default {
  title: 'Panda Sandbox/recipes/cva',
} as Meta;

/**
 * cva is a way to create Atomic Recipes with one or more variant.
 * We use cva when we need to define multiple states for a single atomic component.
 * https://panda-css.com/docs/concepts/recipes#atomic-recipe-or-cva
 *
 * An example is a status indicator where we have a mixture of shared styling
 * but also some status-specific (variant-specific) styling.
 */
const uploadStatusDotRecipe = cva({
  // styles that should be applied to all variants (and can be overridden) are defined in base
  base: {
    margin: '100',
    borderRadius: 'circle',
  },
  variants: {
    status: {
      SUCCESS: {
        bg: '[green]',
      },
      FAILURE: {
        bg: '[red]',
      },
      IN_PROGRESS: {
        bg: '[yellow]',
      },
    },
    size: {
      sm: {
        width: '150',
        height: '150',
      },
      lg: {
        width: '300',
        height: '300',
      },
    },
  },
  // define the default values for any variants if they are not specified
  defaultVariants: {
    size: 'sm',
  },
});

const StandardTemplate: StoryFn = ({ ...args }) => {
  return (
    <Stack gap="200" margin="150">
      <Wrap gap="100">
        <span className={uploadStatusDotRecipe({ status: 'IN_PROGRESS' })} />
        <span className={uploadStatusDotRecipe({ status: 'SUCCESS' })} />
        <span className={uploadStatusDotRecipe({ status: 'FAILURE' })} />
      </Wrap>
      <Wrap gap="100">
        <span className={uploadStatusDotRecipe({ size: 'lg', status: 'IN_PROGRESS' })} />
        <span className={uploadStatusDotRecipe({ size: 'lg', status: 'SUCCESS' })} />
        <span className={uploadStatusDotRecipe({ size: 'lg', status: 'FAILURE' })} />
      </Wrap>
    </Stack>
  );
};

export const ClassName = StandardTemplate.bind({});
ClassName.args = {};

/**
 * Here we're using the `styled` function from Panda to create a type-safe JSX element based on the same recipe!
 *
 * This provides a better DX when the component needs to be consumed in multiple places because we only need
 * to import the JSX component, rather than both the recipe and the component we'd like to apply styles to
 */
const UploadStatusDot = styled('span', uploadStatusDotRecipe);

/**
 * This example should look exactly the same as the one above, but uses the generated JSX elements.
 */
const JsxTemplate: StoryFn = ({ ...args }) => {
  return (
    <Stack gap="200" margin="150">
      <Wrap gap="100">
        <UploadStatusDot status="IN_PROGRESS" />
        <UploadStatusDot status="SUCCESS" />
        <UploadStatusDot status="FAILURE" />
      </Wrap>
      <Wrap gap="100">
        <UploadStatusDot size="lg" status="IN_PROGRESS" />
        <UploadStatusDot size="lg" status="SUCCESS" />
        <UploadStatusDot size="lg" status="FAILURE" />
      </Wrap>
    </Stack>
  );
};

export const Jsx = JsxTemplate.bind({});
Jsx.args = {};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Meta, StoryFn } from '@storybook/react/*';
import React from 'react';
import { css, cva, cx } from '../../../styled-system/css';
import { Stack, styled, Wrap } from '../../../styled-system/jsx';
/**
// styles that should be applied to all variants (and can be overridden) are defined in base
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/panda-sandbox/recipes/sva.stories.tsx
Tamaño: 3232 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Meta, StoryFn } from '@storybook/react/*';
import React, { FC } from 'react';
import { RecipeVariant, sva } from '../../../styled-system/css';
import { Stack } from '../../../styled-system/jsx';

export default {
  title: 'Panda Sandbox/recipes/sva',
} as Meta;

/**
 * sva is a function to create recipes that target specific named parts / elements ("slots")
 * of a component -- it returns an object of classNames.
 *
 * https://panda-css.com/docs/concepts/slot-recipes#atomic-slot-recipe-or-sva
 *
 * sva is similar to cva, but is typically used when we have a composition of components (i.e. a composite component)
 * that contains multiple atomic components that we would like to style independently. A good example of where we would
 * use sva is for a form input component recipe, where we have a label, text input, and helper text that each have
 * their own styles.
 */
const uploadStatusRecipe = sva({
  // specify the names of the different slots
  slots: ['root', 'label', 'indicator'],
  // styles that should be applied to all variants (and can be overridden) are defined in base
  base: {
    // scope the styles below exclusively to the "root" element.
    root: {
      border: 'solid',
      borderRadius: 'pill',
      display: 'flex',
      width: '[max-content]',
      alignItems: 'center',
      gap: '75',
      padding: '50',
      paddingX: '100',
    },
    label: {
      color: '[inherit]',
      fontWeight: 'strong',
      fontFamily: 'mono',
    },
    indicator: {
      width: '100',
      height: '100',
      borderRadius: 'circle',
    },
  },
  variants: {
    status: {
      SUCCESS: {
        // based on the variant, we can style each slot differently
        indicator: {
          bg: '[green]',
        },
        root: {
          borderColor: '[green]',
          color: '[green]',
        },
      },
      FAILURE: {
        indicator: {
          bg: '[red]',
        },
        root: {
          borderColor: '[red]',
          color: '[red]',
        },
      },
      IN_PROGRESS: {
        indicator: {
          bg: '[yellow]',
        },
        root: {
          borderColor: '[yellow]',
          color: '[yellow]',
        },
      },
    },
  },
});

type UploadStatusProps = RecipeVariant<typeof uploadStatusRecipe>;

const UPLOAD_STATUS_LABELS: Record<UploadStatusProps['status'], string> = {
  SUCCESS: 'Success',
  FAILURE: 'Failure',
  IN_PROGRESS: 'Pending',
};

const UploadStatus: FC<UploadStatusProps> = ({ status }) => {
  const classes = uploadStatusRecipe({ status });

  return (
    <div className={classes.root}>
      <p className={classes.label}>{UPLOAD_STATUS_LABELS[status]}</p>
      <span className={classes.indicator} />
    </div>
  );
};

const StandardTemplate: StoryFn = ({ ...args }) => {
  return (
    <Stack gap="200" margin="150">
      <UploadStatus status="IN_PROGRESS" />
      <UploadStatus status="FAILURE" />
      <UploadStatus status="SUCCESS" />
    </Stack>
  );
};

export const ClassName = StandardTemplate.bind({});
ClassName.args = {};

/**
 * Unlike the atomic recipe or cva, slot recipes are not meant to be used directly
 * in the styled factory since it returns an object of classes instead of a single class.
 */


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Meta, StoryFn } from '@storybook/react/*';
import React, { FC } from 'react';
import { RecipeVariant, sva } from '../../../styled-system/css';
import { Stack } from '../../../styled-system/jsx';
/**
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/novui/src/recipes/button.recipe.ts
Tamaño: 3855 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ButtonStylesNames } from '@mantine/core';
import { defineSlotRecipe } from '@pandacss/dev';
import { colorPaletteGradientHorizontal, colorPaletteGradientText } from '../ingredients';

const SLOTS: ButtonStylesNames[] = ['root', 'inner', 'label', 'loader', 'section'];

export const BUTTON_RECIPE = defineSlotRecipe({
  className: 'button',
  jsx: ['Button'],
  slots: SLOTS,
  base: {
    root: {
      height: 'max-content',
      _disabled: {
        opacity: 'disabled',
      },
      '&:hover:not(:disabled)': {
        opacity: 'hover',
      },

      minWidth: '[fit-content]',
    },
    label: {
      color: 'typography.text.main',
      minWidth: '[fit-content]',
      lineClamp: '1',
      lineHeight: 'md',
    },
    section: {
      marginRight: '25',
    },
  },
  defaultVariants: { size: 'md', variant: 'filled', fullWidth: false },
  variants: {
    size: {
      xs: {
        root: {
          '&:not([data-variant="transparent"])': {
            px: '50',
            pt: '25',
            pb: '25',
            fontSize: 'button.small',
          },
        },
        label: {
          lineHeight: 'sm',
        },
      },
      sm: {
        root: {
          '&:not([data-variant="transparent"])': {
            px: '75',
            pt: '25',
            pb: '25',
          },
        },

        label: {
          fontSize: 'button.small',
          lineHeight: 'md',
        },
      },
      md: {
        root: {
          '&:not([data-variant="transparent"])': {
            px: '100',
            pt: '50',
            pb: '50',
            borderRadius: '100',
          },
        },
        label: {
          fontSize: 'button',
        },
        section: {
          marginRight: '50',
        },
      },
      lg: {
        root: {
          '&:not([data-variant="transparent"])': {
            px: '150',
            pt: '75',
            pb: '75',
            borderRadius: '150',
          },
        },
        label: {
          fontSize: 'button',
        },
        section: {
          marginRight: '75',
        },
      },
    },
    variant: {
      filled: {
        root: { ...colorPaletteGradientHorizontal, border: '[none]' },
        label: {
          color: 'button.text.filled',
        },
        section: {
          '& svg': {
            color: 'button.text.filled !important',
          },
        },
      },
      outline: {
        root: {
          border: 'solid',
          borderColor: 'colorPalette.middle',
          bg: 'button.secondary.background',

          boxShadow: 'medium',
          _disabled: {
            bg: '[transparent]',
          },
          _loading: {},

          // icon button
          '& svg': {
            color: 'colorPalette.middle !important',
          },
        },
        label: {
          ...colorPaletteGradientText,
        },
        section: {
          color: 'colorPalette.middle',
          '& svg': {
            color: 'colorPalette.middle !important',
          },
        },
        loader: {
          color: 'colorPalette.start',
          borderColor: 'legacy.white',
        },
      },
      transparent: {
        root: {
          border: 'none',
          borderRadius: '0',
          bg: '[transparent]',
          px: '0',
        },
        label: {
          ...colorPaletteGradientText,
        },
        section: {
          ...colorPaletteGradientHorizontal,
          borderRadius: '50',
          // required to create adequate space around an icon
          padding: '[2px]',
          marginRight: '50',
          '& svg': {
            fill: 'button.icon.filled',
          },
        },
      },
    },
    fullWidth: {
      false: {
        root: {
          width: 'fit-content',
        },
      },
      true: {
        root: {
          width: 'full',
        },
      },
    },
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/recipes/checkbox.recipe.ts
Tamaño: 1254 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CheckboxStylesNames } from '@mantine/core';
import { defineSlotRecipe } from '@pandacss/dev';
import { colorPaletteGradientHorizontal } from '../ingredients';
import { INPUT_RECIPE } from './input.recipe';

// full enumeration of the component library's slots
const SLOTS: CheckboxStylesNames[] = [
  'root',
  'body',
  'input',
  'description',
  'error',
  'label',
  'icon',
  'inner',
  'labelWrapper',
];

export const CHECKBOX_RECIPE = defineSlotRecipe({
  className: 'checkbox',
  jsx: ['Checkbox'],
  slots: SLOTS,
  base: {
    ...INPUT_RECIPE.base,
    root: {
      _hoverNotDisabled: {
        opacity: 'hover',
        '& input, & label': {
          cursor: 'pointer',
        },
      },
    },
    icon: {
      color: 'button.icon.filled',
    },
    input: {
      border: 'solid',
      borderColor: 'input.border',
      borderRadius: '50',
      background: 'transparent',

      _checked: {
        ...colorPaletteGradientHorizontal,
        color: 'typography.text.main',
        border: 'transparent',
      },
      _disabled: {
        opacity: 'disabled',
      },
    },
    label: {
      ...INPUT_RECIPE.base.label,
      paddingLeft: '50',
      _disabled: {
        opacity: 'disabled',
      },
    },
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/recipes/code-block.recipe.ts
Tamaño: 632 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CodeHighlightStylesNames } from '@mantine/code-highlight';
import { defineSlotRecipe } from '@pandacss/dev';
import { BUTTON_RECIPE } from './button.recipe';

// full enumeration of the component library's slots
const SLOTS: CodeHighlightStylesNames[] = ['root', 'pre', 'code', 'copy'];

export const CODE_BLOCK_RECIPE = defineSlotRecipe({
  className: 'code-block',
  jsx: ['CodeBlock'],
  slots: SLOTS,
  base: {
    root: {
      bg: 'codeBlock.surface !important',
    },
    code: {
      color: 'codeBlock.text !important',
    },
    pre: {},
    copy: {
      ...BUTTON_RECIPE.variants.transparent,
    },
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/recipes/index.ts
Tamaño: 446 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './button.recipe';
export * from './checkbox.recipe';
export * from './code-block.recipe';
export * from './input.recipe';
export * from './input-editor-widget.recipe';
export * from './json-schema-form.recipe';
export * from './loading-overlay.recipe';
export * from './select.recipe';
export * from './tabs.recipe';
export * from './text.recipe';
export * from './title.recipe';
export * from './variable-suggestion-list.recipe';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/recipes/input-editor-widget.recipe.ts
Tamaño: 1859 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { RichTextEditorStylesNames } from '@mantine/tiptap';
import { defineSlotRecipe } from '@pandacss/dev';
import { INPUT_RECIPE } from './input.recipe';

// full enumeration of the component library's slots
const SLOTS: RichTextEditorStylesNames[] = [
  'linkEditorSave',
  'linkEditorDropdown',
  'root',
  'content',
  'typographyStylesProvider',
  'control',
  'controlsGroup',
  'toolbar',
  'linkEditor',
  'linkEditorInput',
  'linkEditorExternalControl',
];
export const INPUT_EDITOR_WIDGET_RECIPE = defineSlotRecipe({
  className: 'inputEditorWidget',
  jsx: ['InputEditorWidget'],
  slots: SLOTS,
  base: {
    root: {
      ...INPUT_RECIPE.base.input,
      _groupError: {
        borderColor: 'input.border.error',
      },
    },
    content: {
      bg: 'inherit',

      // override tiptap styles
      '& .tiptap': {
        p: '0',
      },
      // appearance of autocomplete suggestion after being selected and added inline to the input
      '& .suggestion': {
        color: 'variable.text',
        borderRadius: 'xs',
        background: 'variable.surface',
        px: '25',
        py: '[0.125rem]',
        lineHeight: '125',
        borderColor: 'variable.border',
        border: 'solid',

        '&:focus, &:focus-within, &:focus-visible': {
          outline: 'none',
          border: 'solid',
          borderColor: 'input.border.active',
        },

        _error: {
          color: 'input.border.error',
          border: 'none',
          background: 'none',
          textDecoration: 'underline',
          textDecorationStyle: 'wavy',
          textDecorationColor: 'input.border.error',
          // Panda doesn't use spacing tokens by default for offset
          textUnderlineOffset: 'var(--nv-spacing-25)',
          textDecorationThickness: 'from-font',
        },
      },
    },
  },
  staticCss: ['*'],
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/recipes/input.recipe.ts
Tamaño: 3128 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { InputStylesNames, InputWrapperStylesNames } from '@mantine/core';
import { defineSlotRecipe } from '@pandacss/dev';

// full enumeration of the component library's slots
const SLOTS: (InputStylesNames | InputWrapperStylesNames)[] = [
  'root',
  'input',
  'wrapper',
  'section',
  'description',
  'error',
  'required',
  'label',
];

export const INPUT_RECIPE = defineSlotRecipe({
  className: 'input',
  jsx: ['Input', 'Textarea'],
  slots: SLOTS,
  base: {
    root: {
      // add gap between label and description when both are present
      '& > label + p': {
        marginTop: '25',
      },
      // add gap between description or label and the input
      '& > p + div, & > label + div': {
        marginTop: 'margins.layout.Input.titleBottom',
      },
      border: 'none',
    },
    input: {
      background: 'input.surface',
      border: 'solid',
      borderColor: 'input.border',
      borderRadius: 'input',
      lineHeight: '125',

      '&, & svg': {
        color: 'typography.text.main',
      },

      paddingX: '75',
      paddingTop: '100',
      paddingBottom: '100',
      height: 'auto',

      _disabled: {
        '&, &:hover': {
          bg: 'input.surface.disabled',
        },
        borderColor: 'input.border.disabled',
      },

      _error: {
        '&, &:focus, &:focus-within': {
          border: 'solid',
          borderColor: 'input.border.error',
        },
      },

      '&:focus, &:focus-within': {
        outline: 'none',
        border: 'solid',
        borderColor: 'input.border.active',
      },

      _placeholder: {
        color: 'typography.text.secondary',
      },

      _hover: {
        background: 'none',
      },
    },
    label: {
      color: 'typography.text.main',
      fontWeight: 'strong',
      fontSize: '88',
    },
    error: {
      // TODO: figure out about the typography error token
      color: 'input.border.error',
      fontSize: '75',
      lineHeight: '100',
      paddingTop: 'margins.layout.Input.error.top',
    },
    section: {
      paddingRight: '75',
      '[data-error] &': {
        '&, & svg': {
          color: 'input.border.error !important',
        },
      },
    },
    description: {
      color: 'typography.text.tertiary',
      fontSize: '88',
    },
    required: {
      color: 'typography.text.feedback.required',
    },
    wrapper: {
      // prevent Mantine from injecting 2px margin that causes layout shift
      marginBottom: '0',
    },
  },
  variants: {
    variant: {
      // TODO: determine if we want this built-in! Prevents layout shift with error states
      preventLayoutShift: {
        root: {
          paddingBottom: `[calc(token(lineHeights.100) + token(spacing.margins.layout.Input.error.bottom)
             + token(spacing.margins.layout.Input.error.top))]`,

          _error: {
            // remove the bottom padding when occupied by an error message
            paddingBottom: '0',
          },
        },
        error: {
          paddingBottom: 'margins.layout.Input.error.bottom',
        },
      },
    },
  },
  defaultVariants: { variant: undefined },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/recipes/json-schema-form.recipe.ts
Tamaño: 2403 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { defineSlotRecipe } from '@pandacss/dev';

export const JSON_SCHEMA_FORM_SECTION_RECIPE = defineSlotRecipe({
  className: 'jsonSchemaFormSection',
  jsx: ['JsonSchemaFormSection'],
  slots: ['sectionRoot', 'sectionTitle'],
  base: {
    sectionRoot: {
      // default color palette
      colorPalette: 'mode.cloud',

      p: '75',
      borderRadius: '150',
      border: 'solid',
      // TODO: talk to Design Team about these colors
      borderColor: {
        base: 'legacy.BGLight',
        _dark: 'legacy.B30',
      },

      '& .form-group': {
        flex: 'auto',
      },

      '& .form-group:last-of-type': {
        marginBottom: '0',
      },

      // this is quite ugly, but it adds a gap between form-group wrappers
      '& div:has(div.form-group) + div:has(div.form-group)': {
        marginTop: '150',
      },

      // adds a gap between "sections" (AKA array and object fields)
      '& div:has(div.nv-jsonSchemaFormSection__sectionRoot) + div:has(div.nv-jsonSchemaFormSection__sectionRoot)': {
        marginTop: '75',
      },
    },
    sectionTitle: {
      textStyle: 'title.subsection',
      color: 'typography.text.secondary',
    },
  },
  variants: {
    depth: {
      even: {
        sectionRoot: {
          bg: 'surface.panelSection',
        },
      },
      odd: {
        sectionRoot: {
          bg: 'surface.panelSubsection',
        },
      },
    },
  },
  defaultVariants: {
    depth: 'even',
  },
  staticCss: [{ depth: ['*'] }],
});

export const JSON_SCHEMA_FORM_ARRAY_TOOLBAR_RECIPE = defineSlotRecipe({
  className: 'jsonSchemaFormArrayToolbar',
  jsx: ['JsonSchemaFormArrayToolbar'],
  slots: ['toolbar', 'toolbarWrapper'],
  base: {
    toolbar: {
      display: 'flex',
      alignItems: 'center',
      gap: '50',

      position: 'absolute',
      top: '0',
      right: '0',
    },
    toolbarWrapper: {
      position: 'relative',
    },
  },
  variants: {
    itemType: {
      // checkbox
      boolean: {},
      // inputs - the buttons are bigger
      string: { toolbar: { marginTop: '-25' } },
      number: { toolbar: { marginTop: '-25' } },
      integer: { toolbar: { marginTop: '-25' } },
      // sections
      object: { toolbar: { h: '300', right: '75' }, toolbarWrapper: {} },
      array: { toolbar: { h: '300', right: '75' }, toolbarWrapper: {} },
      null: {},
    },
  },
  staticCss: [{ itemType: ['*'] }],
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/recipes/loading-overlay.recipe.ts
Tamaño: 910 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { LoadingOverlayStylesNames } from '@mantine/core';
import { defineSlotRecipe } from '@pandacss/dev';
import { colorPaletteGradientHorizontal } from '../ingredients';

const SLOTS: LoadingOverlayStylesNames[] = ['root', 'overlay', 'loader'];

export const LOADING_OVERLAY_RECIPE = defineSlotRecipe({
  className: 'loadingOverlay',
  jsx: ['LoadingOverlay'],
  slots: SLOTS,
  base: {
    root: {
      // default color palette
      colorPalette: 'mode.cloud',
    },
    overlay: {
      background: 'loader.overlay',
      // TODO: use semantic token when available
      opacity: '40',
    },
    loader: {
      // Have to target children in external loaders
      '& span': {
        ...colorPaletteGradientHorizontal,
      },
      // Specifically needed for oval loader
      _after: {
        borderColor: 'colorPalette.middle',
        borderLeftColor: 'transparent',
      },
    },
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/recipes/select.recipe.ts
Tamaño: 1078 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SelectStylesNames } from '@mantine/core';
import { defineSlotRecipe } from '@pandacss/dev';
import { INPUT_RECIPE } from './input.recipe';

// full enumeration of the component library's slots
const SLOTS: SelectStylesNames[] = [
  'root',
  'input',
  'wrapper',
  'section',
  'description',
  'error',
  'required',
  'label',
  'dropdown',
  'empty',
  'group',
  'groupLabel',
  'option',
  'options',
];

export const SELECT_RECIPE = defineSlotRecipe({
  className: 'select',
  jsx: ['Select'],
  slots: SLOTS,
  base: {
    ...INPUT_RECIPE.base,
    dropdown: {
      bg: 'surface.popover',
      borderRadius: 'input',
      padding: '25',
      marginY: '25',
      border: 'none',
      boxShadow: 'medium',
      color: 'typography.text.main',
    },
    option: {
      padding: '50',
      marginY: '25',
      borderRadius: '50',
      color: 'typography.text.main',
      _hover: {
        bg: 'select.option.surface.hover',
      },
      _selected: {
        fontWeight: 'strong',
        bg: 'select.option.surface.selected',
      },
    },
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/recipes/tabs.recipe.ts
Tamaño: 1525 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { TabsStylesNames } from '@mantine/core';
import { defineSlotRecipe } from '@pandacss/dev';

const SLOTS: TabsStylesNames[] = ['root', 'list', 'panel', 'tab', 'tabLabel', 'tabSection'];

export const TABS_RECIPE = defineSlotRecipe({
  className: 'tabs',
  jsx: ['Tabs'],
  slots: SLOTS,
  base: {
    root: {
      // default color palette
      colorPalette: 'mode.cloud',
    },
    list: {
      color: 'typography.text.main',
      gap: 'margins.layout.tabs.tab-tab',
      _before: {
        borderBottom: 'solid',
        borderColor: 'tabs.border',
      },
      marginBottom: 'margins.layout.tabs.bottom',
    },
    tab: {
      gap: 'margins.icons.Icon20-txt',
      padding: '0',
      paddingBottom: '75',
      color: 'typography.text.secondary',
      '& svg': {
        color: 'typography.text.secondary',
      },

      _disabled: {
        opacity: 'disabled',
      },

      _active: {
        color: 'typography.text.main',
        '& svg': {
          color: 'typography.text.main !important',
        },
        borderBottom: 'double',
        borderColor: 'colorPalette.start',
      },

      '&:hover:not(:disabled)': {
        background: 'none',
        color: 'typography.text.main',
        '& svg': {
          color: 'typography.text.main !important',
        },
      },
    },
    tabLabel: {
      fontSize: '88',
      fontWeight: 'strong',
      lineClamp: 1,
    },
    panel: {
      color: 'typography.text.main',
      fontSize: '88',
      lineHeight: '125',
    },
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/recipes/text.recipe.ts
Tamaño: 631 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { defineRecipe } from '@pandacss/dev';

export const TEXT_RECIPE = defineRecipe({
  className: 'text',
  description: 'Styles for text including: body and labels',
  jsx: ['Text'],
  base: {
    color: 'typography.text.main',
  },
  variants: {
    variant: {
      main: { textStyle: 'text.main' },
      // color is not a permitted field in `textStyles`, so we do it in the recipe instead
      secondary: { textStyle: 'text.secondary', color: 'typography.text.secondary' },
      mono: { textStyle: 'text.mono' },
      strong: { textStyle: 'text.strong' },
    },
  },
  defaultVariants: {
    variant: 'main',
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/recipes/title.recipe.ts
Tamaño: 475 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { defineRecipe } from '@pandacss/dev';

export const TITLE_RECIPE = defineRecipe({
  className: 'title',
  description: 'Styles for title including: body and labels',
  jsx: ['Title'],
  base: {
    color: 'typography.text.main',
  },
  variants: {
    variant: {
      page: { textStyle: 'title.page' },
      section: { textStyle: 'title.section' },
      subsection: { textStyle: 'title.subsection' },
    },
  },
  defaultVariants: {
    variant: 'page',
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/recipes/variable-suggestion-list.recipe.ts
Tamaño: 1019 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ComboboxStylesNames } from '@mantine/core';
import { defineSlotRecipe } from '@pandacss/dev';
import { SELECT_RECIPE } from './select.recipe';

// full enumeration of the component library's slots
const SLOTS: ComboboxStylesNames[] = ['option', 'options', 'dropdown'];

export const VARIABLE_SUGGESTION_LIST_RECIPE = defineSlotRecipe({
  className: 'variableSuggestionList',
  jsx: ['VariableSuggestionList'],
  slots: SLOTS,
  base: {
    dropdown: {
      ...SELECT_RECIPE.base.dropdown,
      maxHeight: 'components.menu.height',
      width: 'components.menu.width !important',
      overflowY: 'auto',
    },

    option: {
      padding: '50',
      marginY: '25',
      borderRadius: '50',
      color: 'typography.text.main',
      overflowX: '[hidden] !important',
      textOverflow: 'ellipsis',
      whiteSpace: 'nowrap',

      _hover: {
        bg: 'select.option.surface.hover',
      },
      _selected: {
        bg: 'select.option.surface.hover',
      },
    },
  },
  staticCss: ['*'],
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/tokens/borders.tokens.ts
Tamaño: 626 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { defineTokens } from '@pandacss/dev';

export const BORDER_WIDTH_TOKENS = defineTokens.borderWidths({
  '0': {
    value: '0',
    type: 'borderWidth',
  },
  '100': {
    value: '1px',
    type: 'borderWidth',
  },
  '200': {
    value: '2px',
    type: 'borderWidth',
  },
});

export const BORDER_TOKENS = defineTokens.borders({
  none: {
    value: 'none',
    type: 'border',
  },
  solid: {
    value: '{borderWidths.100} solid',
    type: 'border',
  },
  double: {
    value: '{borderWidths.200} solid',
    type: 'border',
  },
  dashed: {
    value: '{borderWidths.100} dashed',
    type: 'border',
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/tokens/colors.tokens.ts
Tamaño: 7367 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { defineTokens } from '@pandacss/dev';

/**
 * @deprecated
 */
export const LEGACY_COLOR_TOKENS = defineTokens.colors({
  legacy: {
    white: { value: '#FFFFFF', description: '@deprecated', type: 'color' },
    black: { value: '#000000', description: '@deprecated', type: 'color' },
    BGLight: { value: '#EDF0F2', description: '@deprecated', type: 'color' },
    BGDark: { value: '#13131A', description: '@deprecated', type: 'color' },
    B98: { value: '#F5F8FA', description: '@deprecated', type: 'color' },
    B85: { value: '#D5D5D9', description: '@deprecated', type: 'color' },
    B80: { value: '#BEBECC', description: '@deprecated', type: 'color' },
    B70: { value: '#A1A1B2', description: '@deprecated', type: 'color' },
    B60: { value: '#828299', description: '@deprecated', type: 'color' },
    B40: { value: '#525266', description: '@deprecated', type: 'color' },
    B30: { value: '#3D3D4D', description: '@deprecated', type: 'color' },
    B20: { value: '#292933', description: '@deprecated', type: 'color' },
    B15: { value: '#1E1E26', description: '@deprecated', type: 'color' },
    B17: { value: '#23232B', description: '@deprecated', type: 'color' },
    gradientStart: { value: '#FF512F', description: '@deprecated', type: 'color' },
    gradientMiddle: { value: '#ef3f5a', description: '@deprecated', type: 'color' },
    gradientEnd: { value: '#DD2476', description: '@deprecated', type: 'color' },
    success: { value: '#4D9980', description: '@deprecated', type: 'color' },
    warning: { value: '#FF8000', description: '@deprecated', type: 'color' },
    error: { value: '#E54545', description: '@deprecated', type: 'color' },
  },
  transparent: {
    value: 'transparent',
    type: 'color',
  },
});

export const COLOR_PALETTE_TOKENS = defineTokens.colors({
  amber: {
    '10': {
      light: { value: '#4e2009ff' },
      dark: { value: '#fef3dd' },
    },
    '20': {
      light: { value: '#ad5700ff' },
      dark: { value: '#f1a10d' },
    },
    '30': {
      light: { value: '#ffa01cff' },
      dark: { value: '#ffcb47' },
    },
    '40': {
      light: { value: '#ffb224ff' },
      dark: { value: '#ffb224' },
    },
    '50': {
      light: { value: '#ee9d2bff' },
      dark: { value: '#824e00' },
    },
    '60': {
      light: { value: '#f3ba63ff' },
      dark: { value: '#693f05' },
    },
    '70': {
      light: { value: '#ffd386ff' },
      dark: { value: '#573300' },
    },
    '80': {
      light: { value: '#ffe3a2ff' },
      dark: { value: '#4a2900' },
    },
    '90': {
      light: { value: '#ffecbcff' },
      dark: { value: '#3f2200' },
    },
    '100': {
      light: { value: '#fff4d5ff' },
      dark: { value: '#341c00' },
    },
    '110': {
      light: { value: '#fff9edff' },
      dark: { value: '#271700' },
    },
    '120': {
      light: { value: '#fefdfbff' },
      dark: { value: '#1f1300' },
    },
  },
  blue: {
    '10': {
      light: { value: '#00254dff' },
      dark: { value: '#eaf6ff' },
    },
    '20': {
      light: { value: '#006adcff' },
      dark: { value: '#52a9ff' },
    },
    '30': {
      light: { value: '#0081f1ff' },
      dark: { value: '#369eff' },
    },
    '40': {
      light: { value: '#0077d4ff' },
      dark: { value: '#0077d4' },
    },
    '50': {
      light: { value: '#5eb0efff' },
      dark: { value: '#0954a5' },
    },
    '60': {
      light: { value: '#96c7f2ff' },
      dark: { value: '#0a4481' },
    },
    '70': {
      light: { value: '#b7d9f8ff' },
      dark: { value: '#0d3868' },
    },
    '80': {
      light: { value: '#cee7feff' },
      dark: { value: '#0f3058' },
    },
    '90': {
      light: { value: '#e1f0ffff' },
      dark: { value: '#102a4c' },
    },
    '100': {
      light: { value: '#edf6ffff' },
      dark: { value: '#10243e' },
    },
    '110': {
      light: { value: '#f5faffff' },
      dark: { value: '#0f1b2d' },
    },
    '120': {
      light: { value: '#fbfdffff' },
      dark: { value: '#0f1720' },
    },
  },
  green: {
    '10': {
      light: { value: '#153226ff' },
      dark: { value: '#e5fbeb' },
    },
    '20': {
      light: { value: '#18794eff' },
      dark: { value: '#4cc38a' },
    },
    '30': {
      light: { value: '#299764ff' },
      dark: { value: '#3cb179' },
    },
    '40': {
      light: { value: '#30a46cff' },
      dark: { value: '#30a46c' },
    },
    '50': {
      light: { value: '#5bb98cff' },
      dark: { value: '#236e4a' },
    },
    '60': {
      light: { value: '#92ceacff' },
      dark: { value: '#1b543a' },
    },
    '70': {
      light: { value: '#b4dfc4ff' },
      dark: { value: '#164430' },
    },
    '80': {
      light: { value: '#ccebd7ff' },
      dark: { value: '#133929' },
    },
    '90': {
      light: { value: '#ddf3e4ff' },
      dark: { value: '#113123' },
    },
    '100': {
      light: { value: '#e9f9eeff' },
      dark: { value: '#0f291e' },
    },
    '110': {
      light: { value: '#f2fcf5ff' },
      dark: { value: '#0c1f17' },
    },
    '120': {
      light: { value: '#fbfefcff' },
      dark: { value: '#0d1912' },
    },
  },
  mauve: {
    '10': {
      light: { value: '#1a1523ff' },
      dark: { value: '#ededef' },
    },
    '20': {
      light: { value: '#6f6e77ff' },
      dark: { value: '#a09fa6' },
    },
    '30': {
      light: { value: '#86848dff' },
      dark: { value: '#7e7d86' },
    },
    '40': {
      light: { value: '#908e96ff' },
      dark: { value: '#706f78' },
    },
    '50': {
      light: { value: '#c8c7cbff' },
      dark: { value: '#504f57' },
    },
    '60': {
      light: { value: '#dcdbddff' },
      dark: { value: '#3e3e44' },
    },
    '70': {
      light: { value: '#e4e2e4ff' },
      dark: { value: '#34343a' },
    },
    '80': {
      light: { value: '#e9e8eaff' },
      dark: { value: '#2e2e32' },
    },
    '90': {
      light: { value: '#eeedefff' },
      dark: { value: '#28282c' },
    },
    '100': {
      light: { value: '#f3f3f3ff' },
      dark: { value: '#232326' },
    },
    '110': {
      light: { value: '#f8f8f8ff' },
      dark: { value: '#1c1c1f' },
    },
    '120': {
      light: { value: '#fcfcfcff' },
      dark: { value: '#161618' },
    },
  },
  red: {
    '10': {
      light: { value: '#381316ff' },
      dark: { value: '#feecee' },
    },
    '20': {
      light: { value: '#cd2b31ff' },
      dark: { value: '#ff6369' },
    },
    '30': {
      light: { value: '#dc3d43ff' },
      dark: { value: '#f2555a' },
    },
    '40': {
      light: { value: '#e5484dff' },
      dark: { value: '#e5484d' },
    },
    '50': {
      light: { value: '#eb9091ff' },
      dark: { value: '#aa2429' },
    },
    '60': {
      light: { value: '#f3aeafff' },
      dark: { value: '#822025' },
    },
    '70': {
      light: { value: '#f9c6c6ff' },
      dark: { value: '#671e22' },
    },
    '80': {
      light: { value: '#fdd8d8ff' },
      dark: { value: '#541b1f' },
    },
    '90': {
      light: { value: '#ffe5e5ff' },
      dark: { value: '#481a1d' },
    },
    '100': {
      light: { value: '#ffefefff' },
      dark: { value: '#3c181a' },
    },
    '110': {
      light: { value: '#fff8f8ff' },
      dark: { value: '#291415' },
    },
    '120': {
      light: { value: '#fffcfcff' },
      dark: { value: '#1f1315' },
    },
  },
  transparent: {
    value: 'transparent',
    type: 'color',
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/tokens/gradients.tokens.ts
Tamaño: 779 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { defineSemanticTokens } from '@pandacss/dev';

export const GRADIENT_TOKENS = defineSemanticTokens.gradients({
  vertical: {
    value: `linear-gradient(0deg, {colors.legacy.gradientStart} 0%, {colors.legacy.gradientEnd} 100%)`,
    type: 'gradient',
  },
  horizontal: {
    value: `linear-gradient(99deg, {colors.legacy.gradientEnd} 0%, {colors.legacy.gradientStart} 100%)`,
    type: 'gradient',
  },
  disabled: {
    value: {
      base: 'linear-gradient(90deg, #F5C4D8 0%, #FFCBC1 100%)',
      _dark: 'linear-gradient(90deg, #58203E 0%, #612E29 100%)',
    },
    type: 'gradient',
  },
});

export const LEGACY_GRADIENT_TOKENS = defineSemanticTokens.gradients({
  darkDisabled: { value: 'linear-gradient(90deg, #58203E 0%, #612E29 100%)', type: 'gradient' },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/tokens/opacity.tokens.ts
Tamaño: 562 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { defineTokens } from '@pandacss/dev';

export const OPACITY_TOKENS = defineTokens.opacity({
  '0': {
    value: '0',
    type: 'opacity',
  },
  '40': {
    value: '0.4',
    type: 'opacity',
  },
  '80': {
    value: '0.8',
    type: 'opacity',
  },
  '100': {
    value: '1',
    type: 'opacity',
  },
});

/** @deprecated */
export const LEGACY_OPACITY_TOKENS = defineTokens.opacity({
  '20': {
    value: '0.2',
    type: 'opacity',
  },
  '50': {
    value: '0.5',
    type: 'opacity',
  },
  '60': {
    value: '0.6',
    type: 'opacity',
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/tokens/radius.tokens.ts
Tamaño: 774 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { defineTokens } from '@pandacss/dev';

/**
 * Represents the size of an element.
 *
 * Used for properties like width and height.
 */
export const RADIUS_TOKENS = defineTokens.radii({
  '0': {
    value: '0',
    type: 'radius',
  },
  '50': {
    value: '0.25rem',
    type: 'radius',
  },
  '75': {
    value: '0.375rem',
    type: 'radius',
  },
  '100': {
    value: '0.5rem',
    type: 'radius',
  },
  '150': {
    value: '0.75rem',
    type: 'radius',
  },
  circle: {
    value: '50%',
    type: 'radius',
  },
  pill: {
    value: '9999px',
    type: 'radius',
  },
});

/** @deprecated */
export const LEGACY_RADIUS_TOKENS = defineTokens.radii({
  '63': {
    value: '5px',
    type: 'radius',
  },
  '88': {
    value: '7px',
    type: 'radius',
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/tokens/semanticColors.tokens.ts
Tamaño: 10948 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { defineSemanticTokens } from '@pandacss/dev';

/** @deprecated */
export const LEGACY_COLOR_SEMANTIC_TOKENS = defineSemanticTokens.colors({
  surface: {
    page: {
      value: { base: '{colors.legacy.white}', _dark: '{colors.legacy.B15}' },
      type: 'color',
    },
    panel: {
      value: { base: '{colors.legacy.BGLight}', _dark: '{colors.legacy.BGDark}' },
      type: 'color',
    },
    panelSection: {
      value: { base: '{colors.legacy.B98}', _dark: '{colors.legacy.B20}' },
      type: 'color',
    },
    panelSubsection: {
      value: { base: '{colors.legacy.white}', _dark: '{colors.legacy.B17}' },
      type: 'color',
    },
    popover: {
      value: { base: '{colors.legacy.white}', _dark: '{colors.legacy.B20}' },
      type: 'color',
    },
  },
  typography: {
    text: {
      main: {
        value: { base: '{colors.legacy.B40}', _dark: '{colors.legacy.white}' },
        type: 'color',
      },
      secondary: {
        value: { base: '{colors.legacy.B60}', _dark: '{colors.legacy.B60}' },
        type: 'color',
      },
      tertiary: {
        value: { base: '{colors.legacy.B70}', _dark: '{colors.legacy.B40}' },
        type: 'color',
      },
      // not actually legacy, but makes the merging of the two easier for now.
      disabled: {
        value: { base: '{colors.mauve.30.light}', _dark: '{colors.mauve.30.dark}' },
        type: 'color',
      },
      feedback: {
        alert: {
          value: { base: '{colors.red.20.light}', _dark: '{colors.red.20.dark}' },
          type: 'color',
        },
        warning: {
          value: { base: '{colors.amber.30.light}', _dark: '{colors.amber.30.dark}' },
          type: 'color',
        },
        info: {
          value: { base: '{colors.blue.20.light}', _dark: '{colors.blue.20.dark}' },
          type: 'color',
        },
        success: {
          value: { base: '{colors.green.20.light}', _dark: '{colors.green.20.dark}' },
          type: 'color',
        },
        required: {
          value: { base: '{colors.red.20.light}', _dark: '{colors.red.20.dark}' },
          type: 'color',
        },
      },
    },
  },
  button: {
    text: {
      filled: {
        value: { base: '{colors.legacy.white}', _dark: '{colors.legacy.white}' },
        type: 'color',
      },
      outline: {
        value: { base: '{colors.legacy.gradientMiddle}', _dark: '{colors.legacy.white}' },
        type: 'color',
      },
    },
    icon: {
      filled: {
        value: { base: '{colors.legacy.white}', _dark: '{colors.legacy.white}' },
        type: 'color',
      },
    },
    secondary: {
      background: {
        value: { base: '{colors.legacy.white}', _dark: '{colors.legacy.B17}' },
        type: 'color',
      },
    },
  },
  table: {
    header: {
      border: {
        value: { base: '{colors.legacy.B98}', _dark: '{colors.legacy.B30}' },
        type: 'color',
      },
    },
    row: {
      border: {
        value: { base: '{colors.legacy.B98}', _dark: '{colors.legacy.B20}' },
        type: 'color',
      },
      surface: {
        hover: {
          value: { base: '{colors.legacy.B98}', _dark: '{colors.legacy.B20}' },
          type: 'color',
        },
      },
    },
    bottom: {
      border: {
        value: { base: '{colors.legacy.B98}', _dark: '{colors.legacy.B30}' },
        type: 'color',
      },
    },
  },
  tabs: {
    border: {
      value: { base: '{colors.legacy.B98}', _dark: '{colors.legacy.B30}' },
      type: 'color',
    },
  },
  badge: {
    border: {
      value: { base: '{colors.legacy.B80}', _dark: '{colors.legacy.B30}' },
      type: 'color',
    },
  },
  icon: {
    main: {
      value: { base: '{colors.legacy.B60}', _dark: '{colors.legacy.B60}' },
      type: 'color',
    },
    secondary: {
      value: { base: '{colors.legacy.B70}', _dark: '{colors.legacy.B40}' },
      type: 'color',
    },
  },
  status: {
    active: {
      value: { base: '{colors.legacy.success}', _dark: '{colors.legacy.success}' },
      type: 'color',
    },
    inactive: {
      value: { base: '{colors.legacy.B40}', _dark: '{colors.legacy.B40}' },
      type: 'color',
    },
  },
  input: {
    border: {
      DEFAULT: {
        value: { base: '{colors.legacy.B80}', _dark: '{colors.legacy.B30}' },
        type: 'color',
      },
      active: {
        value: { base: '{colors.legacy.B60}', _dark: '{colors.legacy.B60}' },
        type: 'color',
      },
      disabled: {
        value: { base: '{colors.legacy.BGLight}', _dark: '{colors.legacy.B30}' },
        type: 'color',
      },
      error: {
        value: { base: '{colors.legacy.error}', _dark: '{colors.legacy.error}' },
        type: 'color',
      },
    },
    surface: {
      DEFAULT: {
        value: { base: '{colors.transparent}', _dark: '{colors.transparent}' },
        type: 'color',
      },
      disabled: {
        value: { base: '{colors.legacy.B98}', _dark: '{colors.legacy.B20}' },
        type: 'color',
      },
    },
  },
  select: {
    option: {
      surface: {
        hover: {
          value: { base: '{colors.legacy.B98}', _dark: '{colors.legacy.B30}' },
          type: 'color',
        },
        selected: {
          value: { base: '{colors.legacy.BGLight}', _dark: '{colors.legacy.B40}' },
          type: 'color',
        },
      },
    },
  },
  codeBlock: {
    surface: {
      value: { base: '{colors.legacy.B80}', _dark: '{colors.legacy.B20}' },
      type: 'color',
    },
    text: {
      value: { base: '{colors.legacy.B40}', _dark: '{colors.legacy.white}' },
      type: 'color',
    },
  },
  variable: {
    surface: {
      value: { base: '{colors.legacy.BGLight}', _dark: '{colors.legacy.B20}' },
      type: 'color',
    },
    text: {
      // TODO: Design owes us base tokens / palette values to use here instead
      value: { base: '#B743FF', _dark: '#AD74FF' },
      type: 'color',
    },
    border: {
      value: { base: '{colors.legacy.B80}', _dark: '{colors.legacy.B30}' },
      type: 'color',
    },
  },
  loader: {
    overlay: {
      value: { base: '{colors.legacy.BGLight}', _dark: '{colors.legacy.BGDark}' },
      type: 'color',
    },
  },
  // color palette semantic testing
  mode: {
    cloud: {
      start: {
        value: { base: '{colors.legacy.gradientEnd}', _dark: '{colors.legacy.gradientEnd}' },
        type: 'color',
      },
      middle: {
        value: { base: '{colors.legacy.gradientMiddle}', _dark: '{colors.legacy.gradientMiddle}' },
        type: 'color',
      },
      end: {
        value: { base: '{colors.legacy.gradientStart}', _dark: '{colors.legacy.gradientStart}' },
        type: 'color',
      },
    },
    local: {
      start: {
        value: { base: '{colors.green.30.light}', _dark: '{colors.green.50.dark}' },
        type: 'color',
      },
      middle: {
        value: { base: '{colors.green.40.light}', _dark: '{colors.green.40.dark}' },
        type: 'color',
      },
      end: {
        value: { base: '{colors.green.50.light}', _dark: '{colors.green.30.dark}' },
        type: 'color',
      },
    },
  },
});

export const COLOR_SEMANTIC_TOKENS = defineSemanticTokens.colors({
  typography: {
    text: {
      feedback: {
        alert: {
          value: { base: '{colors.red.20.light}', _dark: '{colors.red.20.dark}' },
          type: 'color',
        },
        warning: {
          value: { base: '{colors.amber.30.light}', _dark: '{colors.amber.30.dark}' },
          type: 'color',
        },
        info: {
          value: { base: '{colors.blue.20.light}', _dark: '{colors.blue.20.dark}' },
          type: 'color',
        },
        success: {
          value: { base: '{colors.green.20.light}', _dark: '{colors.green.20.dark}' },
          type: 'color',
        },
      },
      main: {
        value: { base: '{colors.mauve.10.light}', _dark: '{colors.mauve.10.dark}' },
        type: 'color',
      },
      secondary: {
        value: { base: '{colors.mauve.20.light}', _dark: '{colors.mauve.20.dark}' },
        type: 'color',
      },
      disabled: {
        value: { base: '{colors.mauve.30.light}', _dark: '{colors.mauve.30.dark}' },
        type: 'color',
      },
      accent: {
        value: { base: '{colors.blue.20.light}', _dark: '{colors.blue.20.dark}' },
        type: 'color',
      },
    },
  },
  button: {
    hovered: {
      background: {
        value: { base: '{colors.blue.30.light}', _dark: '{colors.blue.30.dark}' },
        type: 'color',
      },
      border: {
        value: { base: '{colors.blue.30.light}', _dark: '{colors.blue.30.dark}' },
        type: 'color',
      },
      text: {
        value: { base: '{colors.blue.120.light}', _dark: '{colors.blue.120.dark}' },
        type: 'color',
      },
    },
    pressed: {
      background: {
        value: { base: '{colors.blue.20.light}', _dark: '{colors.blue.20.dark}' },
        type: 'color',
      },
      border: {
        value: { base: '{colors.blue.20.light}', _dark: '{colors.blue.20.dark}' },
        type: 'color',
      },
      text: {
        value: { base: '{colors.blue.120.light}', _dark: '{colors.blue.120.dark}' },
        type: 'color',
      },
    },
    disabled: {
      background: {
        value: { base: '{colors.mauve.10.light}', _dark: '{colors.mauve.10.dark}' },
        type: 'color',
      },
      border: {
        value: { base: '{colors.mauve.50.light}', _dark: '{colors.mauve.50.dark}' },
        type: 'color',
      },
      text: {
        // this was a self-referential token (referring to semantic.colors.typography.text.disabled)
        value: { base: '{colors.mauve.30.light}', _dark: '{colors.mauve.30.dark}' },
        type: 'color',
      },
    },
    background: {
      value: { base: '{colors.blue.40.light}', _dark: '{colors.blue.40.dark}' },
      type: 'color',
    },
    border: {
      value: { base: '{colors.blue.40.light}', _dark: '{colors.blue.40.dark}' },
      type: 'color',
    },
    text: {
      value: { base: '{colors.blue.120.light}', _dark: '{colors.blue.120.dark}' },
      type: 'color',
    },
  },
  surface: {
    page: {
      value: { base: '{colors.mauve.100.light}', _dark: '{colors.mauve.100.dark}' },
      type: 'color',
    },
    panel: {
      value: { base: '{colors.mauve.110.light}', _dark: '{colors.mauve.110.dark}' },
      type: 'color',
    },
    popover: {
      value: { base: '{colors.mauve.120.light}', _dark: '{colors.mauve.120.dark}' },
      type: 'color',
    },
  },
  icon: {
    main: {
      value: { base: '{colors.mauve.20.light}', _dark: '{colors.mauve.20.dark}' },
      type: 'color',
    },
  },
  scrollbar: {
    color: {
      value: '{colors.scrollbar.thumb} {colors.scrollbar.track}',
      type: 'color',
    },
    track: {
      value: { base: '{colors.transparent}', _dark: '{colors.transparent}' },
      type: 'color',
    },
    thumb: {
      value: { base: '{colors.legacy.B80}', _dark: '{colors.legacy.B30}' },
      type: 'color',
    },
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/tokens/semanticOpacity.tokens.ts
Tamaño: 260 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { defineSemanticTokens } from '@pandacss/dev';

export const SEMANTIC_OPACITY_TOKENS = defineSemanticTokens.opacity({
  disabled: {
    value: '{opacity.40}',
    type: 'opacity',
  },
  hover: {
    value: '{opacity.80}',
    type: 'opacity',
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/tokens/semanticRadius.tokens.ts
Tamaño: 514 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { defineSemanticTokens } from '@pandacss/dev';

/**
 * Represents the size of an element.
 *
 * Used for properties like width and height.
 */
export const SEMANTIC_RADIUS_TOKENS = defineSemanticTokens.radii({
  xs: {
    value: '{radii.50}',
    type: 'radius',
  },
  s: {
    value: '{radii.75}',
    type: 'radius',
  },
  m: {
    value: '{radii.100}',
    type: 'radius',
  },
  l: {
    value: '{radii.150}',
    type: 'radius',
  },
  input: {
    value: '{radii.100}',
    type: 'radius',
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/tokens/semanticSizes.tokens.ts
Tamaño: 1336 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { defineSemanticTokens } from '@pandacss/dev';

/**
 * Represents a dimension of an element.
 *
 * Used for properties like width and height.
 */
export const SEMANTIC_SIZES_TOKENS = defineSemanticTokens.sizes({
  components: {
    input: {
      height: {
        // TODO: this is a legacy value and can be replaced when a new value is determined.
        value: `50px`,
        type: 'sizes',
      },
    },
    menu: {
      height: {
        value: `25rem`,
        type: 'sizes',
      },
      width: {
        value: `18.75rem`,
        type: 'sizes',
      },
    },
  },
  icon: {
    '16': {
      value: '{sizes.100}',
      type: 'sizes',
    },
    '20': {
      value: '{sizes.125}',
      type: 'sizes',
    },
    '24': {
      value: '{sizes.150}',
      type: 'sizes',
    },
  },
  full: {
    value: '100%',
    type: 'sizes',
  },
  // From Figma
  s: {
    value: '{sizes.200}',
    type: 'sizes',
  },
  m: {
    value: '{sizes.250}',
    type: 'sizes',
  },
  l: {
    value: '{sizes.300}',
    type: 'sizes',
  },
  scrollbar: {
    width: {
      value: 'thin',
      type: 'sizes',
    },
    track: {
      value: '14px', // equivalent to `thin` scrollbar width
      type: 'sizes',
    },
    thumb: {
      value: '8px', // equivalent to `thin` scrollbar width
      type: 'sizes',
    },
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/tokens/semanticSpacing.tokens.ts
Tamaño: 6615 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { defineSemanticTokens } from '@pandacss/dev';

/**
 * Semantic uses of spacing. May target an individual component or spacing between components.
 */
export const SEMANTIC_SPACING_TOKENS = defineSemanticTokens.spacing({
  molecules: {
    form: {
      input: {
        button: {
          value: `{spacing.150}`,
          description: 'Distance between an input and its submit button',
          type: 'spacing',
        },
      },
    },
  },
  paddings: {
    page: {
      horizontal: {
        type: 'spacing',
        value: '{spacing.150}',
      },
      vertical: {
        type: 'spacing',
        value: '{spacing.150}',
      },
    },
    panel: {
      horizontal: {
        type: 'spacing',
        value: '{spacing.150}',
      },
      vertical: {
        type: 'spacing',
        value: '{spacing.150}',
      },
    },
    popover: {
      horizontal: {
        type: 'spacing',
        value: '{spacing.150}',
      },
      vertical: {
        type: 'spacing',
        value: '{spacing.150}',
      },
    },
    node: {
      horizontal: {
        type: 'spacing',
        value: '{spacing.150}',
      },
      vertical: {
        type: 'spacing',
        value: '{spacing.150}',
      },
    },
    nav: {
      menu: {
        horizontal: {
          type: 'spacing',
          value: '{spacing.100}',
        },
        vertical: {
          type: 'spacing',
          value: '{spacing.100}',
        },
      },
      header: {
        horizontal: {
          type: 'spacing',
          value: '{spacing.50}',
        },
        vertical: {
          type: 'spacing',
          value: '{spacing.50}',
        },
      },
      footer: {
        top: {
          type: 'spacing',
          value: '{spacing.50}',
        },
        bottom: {
          type: 'spacing',
          value: '{spacing.100}',
        },
      },
    },
    WF: {
      WFtop: {
        type: 'spacing',
        value: '{spacing.375}',
      },
      WFheaderHorizontal: {
        type: 'spacing',
        value: '{spacing.100}',
      },
      WFhorizontal: {
        type: 'spacing',
        value: '{spacing.50}',
      },
      MobPreviewTop: {
        type: 'spacing',
        value: '{spacing.250}',
      },
    },
    components: {
      code: {
        horizontal: {
          type: 'spacing',
          value: '{spacing.100}',
        },
        vertical: {
          type: 'spacing',
          value: '{spacing.25}',
        },
      },
      button: {
        horizontal: {
          l: {
            type: 'spacing',
            value: '{spacing.125}',
          },
          m: {
            type: 'spacing',
            value: '{spacing.100}',
          },
          s: {
            type: 'spacing',
            value: '{spacing.75}',
          },
          xs: {
            type: 'spacing',
            value: '{spacing.50}',
          },
        },
      },
      info: {
        spotlight: {
          horizontal: {
            type: 'spacing',
            value: '{spacing.75}',
          },
          vertical: {
            type: 'spacing',
            value: '{spacing.75}',
          },
        },
        hint: {
          horizontal: {
            type: 'spacing',
            value: '{spacing.100}',
          },
          vertical: {
            type: 'spacing',
            value: '{spacing.100}',
          },
        },
      },
      txtInput: {
        horizontal: {
          type: 'spacing',
          value: '{spacing.75}',
        },
      },
    },
  },
  margins: {
    icons: {
      'Icon40-txt': {
        type: 'spacing',
        value: '{spacing.50}',
      },
      'Icon32-txt': {
        type: 'spacing',
        value: '{spacing.50}',
      },
      'Icon20-txt': {
        type: 'spacing',
        value: '{spacing.50}',
      },
      'Icon16-txt': {
        type: 'spacing',
        value: '{spacing.25}',
      },
      'icon20-icon20': {
        type: 'spacing',
        value: '{spacing.50}',
      },
    },
    buttons: {
      'XS-XS': {
        type: 'spacing',
        value: '{spacing.25}',
      },
      WFchannels: {
        type: 'spacing',
        value: '{spacing.50}',
      },
      'XS-status': {
        type: 'spacing',
        value: '{spacing.100}',
      },
      'S-S': {
        type: 'spacing',
        value: '{spacing.100}',
      },
      'M-M': {
        type: 'spacing',
        value: '{spacing.125}',
      },
    },
    layout: {
      tabs: {
        'tab-tab': {
          type: 'spacing',
          value: '{spacing.150}',
        },
        bottom: {
          type: 'spacing',
          value: '{spacing.150}',
        },
      },
      text: {
        'title-body': {
          type: 'spacing',
          value: '{spacing.100}',
        },
        'sub-title-body': {
          type: 'spacing',
          value: '{spacing.50}',
        },
        paragraph: {
          type: 'spacing',
          value: '{spacing.100}',
        },
      },
      Input: {
        titleBottom: {
          type: 'spacing',
          value: '{spacing.50}',
        },
        'input-input': {
          type: 'spacing',
          value: '{spacing.200}',
        },
        error: {
          top: {
            description: "Padding from the top of the Input's error message if shown",
            type: 'spacing',
            value: '{spacing.25}',
          },
          bottom: {
            description: "Padding from the bottom of the Input's error message if shown",
            type: 'spacing',
            value: '{spacing.25}',
          },
        },
        bottom: {
          type: 'spacing',
          value: '{spacing.100}',
        },
      },
      guideSteps: {
        type: 'spacing',
        value: '{spacing.200}',
      },
      page: {
        titleBottom: {
          type: 'spacing',
          value: '{spacing.150}',
        },
        horizontal: {
          type: 'spacing',
          value: '{spacing.250}',
        },
        vertical: {
          type: 'spacing',
          value: '{spacing.200}',
        },
        section: {
          titleBottom: {
            type: 'spacing',
            value: '{spacing.150}',
          },
        },
        'sub-section': {
          titleBottom: {
            type: 'spacing',
            value: '{spacing.100}',
          },
        },
        'content-buttons': {
          type: 'spacing',
          value: '{spacing.150}',
        },
      },
    },
    menu: {
      'item-item': {
        type: 'spacing',
        value: '{spacing.25}',
      },
      'sec-sec': {
        type: 'spacing',
        value: '{spacing.100}',
      },
    },
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/tokens/semanticTypography.tokens.ts
Tamaño: 471 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { defineSemanticTokens } from '@pandacss/dev';

export const SEMANTIC_FONT_SIZE_TOKENS = defineSemanticTokens.fontSizes({
  button: {
    DEFAULT: { value: '{fontSizes.88}', type: 'fontSizes' },
    small: { value: '{fontSizes.75}', type: 'fontSizes' },
  },
});

export const SEMANTIC_LINE_HEIGHT_TOKENS = defineSemanticTokens.lineHeights({
  sm: { value: '{lineHeights.100}', type: 'lineHeights' },
  md: { value: '{lineHeights.125}', type: 'lineHeights' },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/tokens/shadow.tokens.ts
Tamaño: 483 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { defineSemanticTokens } from '@pandacss/dev';

/** @deprecated */
export const LEGACY_SHADOW_TOKENS = defineSemanticTokens.shadows({
  light: {
    value: '0px 5px 15px rgba(38, 68, 128, 0.05)',
  },
  medium: {
    value: {
      base: '0px 5px 15px rgba(122, 133, 153, 0.25)',
      _dark: '0px 5px 20px rgba(0, 0, 0, 0.2)',
    },
  },
  dark: {
    value: '0px 5px 20px rgba(0, 0, 0, 0.2)',
  },
  color: {
    value: '0px 5px 20px -5px rgba(233, 52, 94, 0.5)',
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/tokens/sizes.tokens.ts
Tamaño: 1083 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { defineTokens } from '@pandacss/dev';

/**
 * Represents the size of an element.
 *
 * Used for properties like width and height.
 */
export const SIZES_TOKENS = defineTokens.sizes({
  '0': {
    value: '0',
    type: 'sizes',
  },
  '25': {
    value: '0.25rem',
    type: 'sizes',
  },
  '50': {
    value: '0.5rem',
    type: 'sizes',
  },
  '75': {
    value: '0.75rem',
    type: 'sizes',
  },
  '100': {
    value: '1rem',
    type: 'sizes',
  },
  '125': {
    value: '1.25rem',
    type: 'sizes',
  },
  '150': {
    value: '1.5rem',
    type: 'sizes',
  },
  '175': {
    value: '1.75rem',
    type: 'sizes',
  },
  '200': {
    value: '2rem',
    type: 'sizes',
  },
  '225': {
    value: '2.25rem',
    type: 'sizes',
  },
  '250': {
    value: '2.5rem',
    type: 'sizes',
  },
  '275': {
    value: '2.75rem',
    type: 'sizes',
  },
  '300': {
    value: '3rem',
    type: 'sizes',
  },
  '325': {
    value: '3.25rem',
    type: 'sizes',
  },
  '350': {
    value: '3.5rem',
    type: 'sizes',
  },
  '375': {
    value: '3.75rem',
    type: 'sizes',
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/tokens/spacing.tokens.ts
Tamaño: 1125 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { defineTokens } from '@pandacss/dev';

/**
 * Determines distances between elements.
 *
 * Used for properties like margin and padding.
 */
export const SPACING_TOKENS = defineTokens.spacing({
  '0': {
    value: '0',
    type: 'spacing',
  },
  '25': {
    value: '0.25rem',
    type: 'spacing',
  },
  '50': {
    value: '0.5rem',
    type: 'spacing',
  },
  '75': {
    value: '0.75rem',
    type: 'spacing',
  },
  '100': {
    value: '1rem',
    type: 'spacing',
  },
  '125': {
    value: '1.25rem',
    type: 'spacing',
  },
  '150': {
    value: '1.5rem',
    type: 'spacing',
  },
  '175': {
    value: '1.75rem',
    type: 'spacing',
  },
  '200': {
    value: '2rem',
    type: 'spacing',
  },
  '225': {
    value: '2.25rem',
    type: 'spacing',
  },
  '250': {
    value: '2.5rem',
    type: 'spacing',
  },
  '275': {
    value: '2.75rem',
    type: 'spacing',
  },
  '300': {
    value: '3rem',
    type: 'spacing',
  },
  '325': {
    value: '3.25rem',
    type: 'spacing',
  },
  '350': {
    value: '3.5rem',
    type: 'spacing',
  },
  '375': {
    value: '3.75rem',
    type: 'spacing',
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/tokens/textStyles.tokens.ts
Tamaño: 1787 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { defineTextStyles } from '@pandacss/dev';

export const TEXT_STYLES = defineTextStyles({
  text: {
    main: {
      description: 'Main text',
      value: {
        fontFamily: 'system',
        fontWeight: 'regular',
        letterSpacing: '0',
        fontSize: '88',
        textDecoration: 'none',
        lineHeight: '125',
      },
    },
    secondary: {
      description: 'Secondary text',
      value: {
        fontFamily: 'system',
        fontWeight: 'regular',
        letterSpacing: '0',
        fontSize: '75',
        textDecoration: 'none',
        lineHeight: '100',
      },
    },
    mono: {
      description: 'Mono-spaced text',
      value: {
        fontFamily: 'mono',
        fontWeight: 'regular',
        letterSpacing: '0',
        fontSize: '88',
        textDecoration: 'none',
        lineHeight: '125',
      },
    },
    strong: {
      description: 'Strong text',
      value: {
        fontWeight: 'strong',
        letterSpacing: '0',
      },
    },
  },
  title: {
    page: {
      description: 'Page title',
      value: {
        fontFamily: 'system',
        fontWeight: 'strong',
        letterSpacing: '0',
        fontSize: '150',
        textDecoration: 'none',
        lineHeight: '200',
      },
    },
    section: {
      description: 'Section title',
      value: {
        fontFamily: 'system',
        fontWeight: 'strong',
        letterSpacing: '0',
        fontSize: '125',
        textDecoration: 'none',
        lineHeight: '175',
      },
    },
    subsection: {
      description: 'Subsection title',
      value: {
        fontFamily: 'system',
        fontWeight: 'strong',
        letterSpacing: '0',
        fontSize: '100',
        textDecoration: 'none',
        lineHeight: '150',
      },
    },
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/tokens/typography.tokens.ts
Tamaño: 1907 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { defineTokens } from '@pandacss/dev';

export const FONT_FAMILY_TOKENS = defineTokens.fonts({
  system: {
    type: 'fontFamilies',
    value: '-apple-system, "SF Pro Text", BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif',
  },
  mono: {
    type: 'fontFamilies',
    value: 'ui-monospace, "SFMono-Regular", "SF Mono", Menlo, Consolas, "Liberation Mono", monospace',
  },
});

/** @deprecated */
export const LEGACY_FONT_FAMILY_TOKENS = defineTokens.fonts({
  system: {
    type: 'fontFamilies',
    value: '"Lato", BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif',
  },
});

export const FONT_SIZE_TOKENS = defineTokens.fontSizes({
  '75': {
    type: 'fontSizes',
    value: '0.75rem',
  },
  '88': {
    type: 'fontSizes',
    value: '0.875rem',
  },
  '100': {
    type: 'fontSizes',
    value: '1rem',
  },
  '125': {
    type: 'fontSizes',
    value: '1.25rem',
  },
  '150': {
    type: 'fontSizes',
    value: '1.5rem',
  },
  '175': {
    type: 'fontSizes',
    value: '1.75rem',
  },
  '225': {
    type: 'fontSizes',
    value: '2.25rem',
  },
});

export const FONT_WEIGHT_TOKENS = defineTokens.fontWeights({
  regular: {
    type: 'fontWeights',
    value: '400',
  },
  strong: {
    type: 'fontWeights',
    value: '600',
  },
});

export const LETTER_SPACING_TOKENS = defineTokens.letterSpacings({
  '0': {
    type: 'letterSpacing',
    value: '0',
  },
});

export const LINE_HEIGHT_TOKENS = defineTokens.lineHeights({
  '100': {
    type: 'lineHeights',
    value: '1rem',
  },
  '125': {
    type: 'lineHeights',
    value: '1.25rem',
  },
  '150': {
    type: 'lineHeights',
    value: '1.5rem',
  },
  '175': {
    type: 'lineHeights',
    value: '1.75rem',
  },
  '200': {
    type: 'lineHeights',
    value: '2rem',
  },
  '225': {
    type: 'lineHeights',
    value: '2.25rem',
  },
  '300': {
    type: 'lineHeights',
    value: '3rem',
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/tokens/zIndex.tokens.ts
Tamaño: 1203 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { defineTokens } from '@pandacss/dev';

/**
 * Specifies the "depth" of UI elements.
 * Note: Z Indices are a little strange because the concept of base vs semantic token is blurred.
 *
 * Based on the system from ParkUI:
 * https://github.com/cschroeter/park-ui/blob/main/plugins/panda/src/theme/tokens/z-index.ts
 * It’s similar to the system from MUI as well: https://mui.com/material-ui/customization/z-index/
 */
export const Z_INDEX_TOKENS = defineTokens.zIndex({
  hide: {
    value: '-1',
    type: 'zIndex',
  },
  auto: {
    value: 'auto',
    type: 'zIndex',
  },
  base: {
    value: '0',
    type: 'zIndex',
  },
  docked: {
    value: '10',
    type: 'zIndex',
  },
  dropdown: {
    value: '1000',
    type: 'zIndex',
  },
  sticky: {
    value: '1100',
    type: 'zIndex',
  },
  banner: {
    value: '1200',
    type: 'zIndex',
  },
  overlay: {
    value: '1300',
    type: 'zIndex',
  },
  modal: {
    value: '1400',
    type: 'zIndex',
  },
  popover: {
    value: '1500',
    type: 'zIndex',
  },
  skipLink: {
    value: '1600',
    type: 'zIndex',
  },
  toast: {
    value: '1700',
    type: 'zIndex',
  },
  tooltip: {
    value: '1800',
    type: 'zIndex',
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/types/CoreProps.ts
Tamaño: 215 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/**
 * Defines the foundational props from which all Novu components should inherit.
 */
export interface CoreProps {
  className?: string;
}

export type CorePropsWithChildren = React.PropsWithChildren<CoreProps>;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  interface
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/types/ExtractGeneric.ts
Tamaño: 160 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

type TypeWithGeneric<T> = T[];

/** Extract the type 'T' from a generic type */
export type ExtractGeneric<T> = T extends TypeWithGeneric<infer X> ? X : never;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/types/LocalizedMessage.ts
Tamaño: 533 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/**
 * Indicates a string that is expect to already be localized before being passed as a parameter / prop.
 *
 * Note: this is forward-thinking to minimize accruing new tech debt when we implement i18n!
 */
export type LocalizedString = string;

/**
 * Indicates a message that is expect to already be localized before being passed as a parameter / prop.
 *
 * Note: this is forward-thinking to minimize accruing new tech debt when we implement i18n!
 */
export type LocalizedMessage = string | React.ReactNode | React.ReactNode[];


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/types/WithLoadingSkeleton.ts
Tamaño: 398 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { FC } from 'react';
import { CoreProps } from './CoreProps';

// TODO: consider props that may be universal for loading skeletons
export type LoadingDisplayComponent<TProps = CoreProps> = FC<TProps>;
export type LoadingDisplayProps<TProps = CoreProps> = { LoadingDisplay: LoadingDisplayComponent<TProps> };
export type WithLoadingSkeleton<T extends FC<any> = FC> = T & LoadingDisplayProps;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/types/index.ts
Tamaño: 160 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './CoreProps';
export type { ExtractGeneric } from './ExtractGeneric';
export * from './LocalizedMessage';
export * from './WithLoadingSkeleton';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export  type
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/types/props-helpers.ts
Tamaño: 1065 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import React from 'react';

export type PolymorphicRef<C extends React.ElementType> = React.ComponentPropsWithRef<C>['ref'];

export type AsProp<C extends React.ElementType> = {
  as?: C;
};

export type PropsToOmit<C extends React.ElementType, P> = keyof (AsProp<C> & P);

export type PolymorphicComponentProp<C extends React.ElementType, Props = {}> = React.PropsWithChildren<
  Props & AsProp<C>
> &
  Omit<React.ComponentPropsWithoutRef<C>, PropsToOmit<C, Props>>;

export type PolymorphicComponentPropWithRef<C extends React.ElementType, Props = {}> = PolymorphicComponentProp<
  C,
  Props
> & {
  ref?: PolymorphicRef<C>;
};

export function forwardRefWithAs<Component extends React.ElementType, Props = {}>(
  render: (
    props: React.PropsWithoutRef<PolymorphicComponentPropWithRef<Component, Props>>,
    ref: React.ForwardedRef<any>
  ) => React.ReactElement | null
) {
  return React.forwardRef(render) as unknown as <As extends React.ElementType = Component>(
    props: PolymorphicComponentPropWithRef<As, Props>
  ) => React.ReactElement | null;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - Props({}>(
  render: (
    props: React.PropsWithoutRef<PolymorphicComponentPropWithRef<Component, Props>>...)
 - ElementType(Component>(
    props: PolymorphicComponentPropWithRef<As, Props>
  ))
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  type
- export function forwardRefWithAs

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/utils/createContextAndHook.ts
Tamaño: 1616 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import React from 'react';

export function assertContextExists(contextVal: unknown, msgOrCtx: string | React.Context<any>): asserts contextVal {
  if (!contextVal) {
    throw typeof msgOrCtx === 'string' ? new Error(msgOrCtx) : new Error(`${msgOrCtx.displayName} not found`);
  }
}

type Options = { assertCtxFn?: (v: unknown, msg: string) => void };
type ContextOf<T> = React.Context<{ value: T } | undefined>;
type UseCtxFn<T> = () => T;

/**
 *
 * Nice little utility function from https://github.com/clerk/javascript/blob/main/packages/shared/src/react/hooks/createContextAndHook.ts
 *
 * Creates and returns a Context and two hooks that return the context value.
 * The Context type is derived from the type passed in by the user.
 * The first hook returned guarantees that the context exists so the returned value is always CtxValue
 * The second hook makes no guarantees, so the returned value can be CtxValue | undefined
 *
 */
export const createContextAndHook = <CtxVal>(
  displayName: string,
  options?: Options
): [ContextOf<CtxVal>, UseCtxFn<CtxVal>, UseCtxFn<CtxVal | Partial<CtxVal>>] => {
  const { assertCtxFn = assertContextExists } = options || {};
  const Ctx = React.createContext<{ value: CtxVal } | undefined>(undefined);
  Ctx.displayName = displayName;

  const useCtx = () => {
    const ctx = React.useContext(Ctx);
    assertCtxFn(ctx, `${displayName} not found`);

    return (ctx as any).value as CtxVal;
  };

  const useCtxWithoutGuarantee = () => {
    const ctx = React.useContext(Ctx);

    return ctx ? ctx.value : {};
  };

  return [Ctx, useCtx, useCtxWithoutGuarantee];
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - assertContextExists(contextVal: unknown, msgOrCtx: string | React.Context<any>)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Options({ assertCtxFn?: (v: unknown, msg: string))
 - createContextAndHook(<CtxVal>(
  displayName: string,
  options?: Options
): [ContextOf<CtxVal>, UseCtxFn<CtxVal>, UseCtx...)
 - useCtx())
 - useCtxWithoutGuarantee())
Declaraciones 'export' encontradas:
- export function assertContextExists
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/novui/src/utils/index.ts
Tamaño: 40 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './createContextAndHook';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/testing/.dockerignore
Tamaño: 13 bytes
Lenguaje detectado: DOCKERIGNORE

### CONTENIDO ORIGINAL ###

node_modules


### ANALISIS AUTOMATICO (ESPAÑOL) ###

node_modules
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/testing/.gitignore
Tamaño: 1885 bytes
Lenguaje detectado: GITIGNORE

### CONTENIDO ORIGINAL ###


### Node template
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage

# nyc test coverage
.nyc_output

# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# TypeScript v1 declaration files
typings/

# Optional npm cache directory
.npm

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env

# next.js build output
.next
### JetBrains template
# Covers JetBrains IDEs: IntelliJ, RubyMine, PhpStorm, AppCode, PyCharm, CLion, Android Studio and WebStorm
# Reference: https://intellij-support.jetbrains.com/hc/en-us/articles/206544839

# User-specific stuff
.idea


# Sensitive or high-churn files
.idea/**/dataSources/
.idea/**/dataSources.ids
.idea/**/dataSources.local.xml
.idea/**/sqlDataSources.xml
.idea/**/dynamic.xml
.idea/**/uiDesigner.xml
.idea/**/dbnavigator.xml

# Gradle
.idea/**/gradle.xml
.idea/**/libraries

# CMake
cmake-build-debug/
cmake-build-release/

# Mongo Explorer plugin
.idea/**/mongoSettings.xml

# File-based project format
*.iws

# IntelliJ
out/

# mpeltonen/sbt-idea plugin
.idea_modules/

# JIRA plugin
atlassian-ide-plugin.xml

# Cursive Clojure plugin
.idea/replstate.xml

# Crashlytics plugin (for Android Studio and IntelliJ)
com_crashlytics_export_strings.xml
crashlytics.properties
crashlytics-build.properties
fabric.properties

# Editor-based Rest Client
.idea/httpRequests


### ANALISIS AUTOMATICO (ESPAÑOL) ###

### Node template
# Logs
logs
*.log
# Runtime data
# Directory for instrumented libs generated by jscoverage/JSCover
# Coverage directory used by tools like istanbul
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/testing/package.json
Tamaño: 1594 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "name": "@novu/testing",
  "version": "2.0.5",
  "description": "",
  "private": true,
  "scripts": {
    "start": "npm run start:dev",
    "afterinstall": "pnpm build",
    "prebuild": "rimraf dist",
    "build": "cross-env node_modules/.bin/tsc -p tsconfig.build.json",
    "build:watch": "cross-env node_modules/.bin/tsc -p tsconfig.build.json -w --preserveWatchOutput",
    "start:dev": "pnpm build:watch",
    "precommit": "lint-staged",
    "check": "biome check .",
    "check:fix": "biome check --write .",
    "test": "echo \"no tests yet\"",
    "test:watch": ""
  },
  "author": "",
  "license": "ISC",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "dependencies": {
    "@clerk/backend": "1.25.2",
    "@clerk/types": "^4.6.1",
    "@faker-js/faker": "^6.0.0",
    "@novu/dal": "workspace:*",
    "@novu/shared": "workspace:*",
    "JSONStream": "^1.3.5",
    "async": "^3.2.0",
    "axios": "^1.9.0",
    "bcrypt": "~5.0.0",
    "bullmq": "^3.10.2",
    "class-transformer": "0.5.1",
    "cross-fetch": "^3.0.4",
    "event-stream": "^4.0.1",
    "fs-extra": "^9.0.0",
    "jsonfile": "^6.0.1",
    "jsonwebtoken": "9.0.0",
    "ng-intercom": "^8.0.2",
    "reflect-metadata": "0.2.2",
    "rimraf": "^3.0.2",
    "shortid": "^2.2.16",
    "superagent-defaults": "^0.1.14",
    "supertest": "^7.0.0",
    "uuid": "^8.3.0"
  },
  "devDependencies": {
    "@types/async": "^3.2.1",
    "@types/node": "^20.15.0",
    "@types/supertest": "^6.0.2",
    "apollo-boost": "0.4.9",
    "ts-node": "~10.9.1",
    "tsconfig-paths": "~4.1.0",
    "typescript": "5.6.2"
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"name": "@novu/testing",
"version": "2.0.5",
"description": "",
"private": true,
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/testing/project.json
Tamaño: 247 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "name": "@novu/testing",
  "sourceRoot": "libs/testing/src",
  "projectType": "library",
  "targets": {
    "lint": {
      "executor": "nx:run-commands",
      "options": {
        "command": "npx biome lint libs/testing"
      }
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"name": "@novu/testing",
"sourceRoot": "libs/testing/src",
"projectType": "library",
"targets": {
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/testing/tsconfig.build.json
Tamaño: 288 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "target": "es6",
    "declaration": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "esModuleInterop": true,
    "sourceMap": true,
    "types": ["node"]
  },
  "include": ["src/**/*"]
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"extends": "../../tsconfig.json",
"compilerOptions": {
"module": "commonjs",
"target": "es6",
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/testing/tsconfig.json
Tamaño: 171 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "strictNullChecks": true,
    "types": ["node"],
    "esModuleInterop": true,
    "sourceMap": true
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"extends": "../../tsconfig.json",
"compilerOptions": {
"strictNullChecks": true,
"types": ["node"],
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/testing/src/constants.ts
Tamaño: 48 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export const TEST_USER_PASSWORD = 'asd#Faf4fd';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/testing/src/create-notification-template.interface.ts
Tamaño: 1246 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { NotificationTemplateEntity, StepFilter } from '@novu/dal';
import {
  ActorTypeEnum,
  DelayTypeEnum,
  DigestTypeEnum,
  DigestUnitEnum,
  IEmailBlock,
  IPreferenceChannels,
  ITemplateVariable,
  StepTypeEnum,
} from '@novu/shared';

interface IVariant {
  cta?: {};
  uuid?: string;
  active?: boolean;
  subject?: string;
  title?: string;
  contentType?: 'editor' | 'customHtml';
  preheader?: string;
  filters?: StepFilter[];
  content: string | IEmailBlock[];
  variables?: ITemplateVariable[];
  name?: string;
  type: StepTypeEnum;
  replyCallback?: {
    active: boolean;
    url: string;
  };
  metadata?: {
    amount?: number;
    unit?: DigestUnitEnum;
    digestKey?: string;
    type: DigestTypeEnum | DelayTypeEnum;
    backoff?: boolean;
    delayPath?: string;
    backoffUnit?: DigestUnitEnum;
    backoffAmount?: number;
    updateMode?: boolean;
  };
  actor?: {
    type: ActorTypeEnum;
    data: string | null;
  };
}

interface IStep extends IVariant {
  variants?: IStep[];
}

export interface CreateTemplatePayload extends Omit<NotificationTemplateEntity, 'steps'> {
  noFeedId?: boolean;
  noLayoutId?: boolean;
  noGroupId?: boolean;
  preferenceSettingsOverride?: IPreferenceChannels;
  steps: IStep[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  interface

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/testing/src/environment.service.ts
Tamaño: 3154 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { faker } from '@faker-js/faker';
import { EnvironmentEntity, EnvironmentRepository } from '@novu/dal';
import { IApiRateLimitMaximum } from '@novu/shared';
import { createHash } from 'crypto';
import { v4 as uuid } from 'uuid';

enum EnvironmentsEnum {
  DEVELOPMENT = 'Development',
  PRODUCTION = 'Production',
}

export class EnvironmentService {
  private environmentRepository = new EnvironmentRepository();

  async createEnvironment(
    organizationId: string,
    userId: string,
    name?: string,
    parentId?: string
  ): Promise<EnvironmentEntity> {
    const key = uuid();
    const hashedApiKey = createHash('sha256').update(key).digest('hex');

    return await this.environmentRepository.create({
      identifier: uuid(),
      name: name ?? faker.name.jobTitle(),
      _organizationId: organizationId,
      ...(parentId && { _parentId: parentId }),
      apiKeys: [
        {
          key,
          _userId: userId,
          hash: hashedApiKey,
        },
      ],
    });
  }

  async createDevelopmentEnvironment(organizationId: string, userId: string): Promise<EnvironmentEntity> {
    return await this.createEnvironment(organizationId, userId, EnvironmentsEnum.DEVELOPMENT);
  }

  async createProductionEnvironment(
    organizationId: string,
    userId: string,
    parentId: string
  ): Promise<EnvironmentEntity> {
    return await this.createEnvironment(organizationId, userId, EnvironmentsEnum.PRODUCTION, parentId);
  }

  async enableEnvironmentHmac(environment: EnvironmentEntity) {
    return await this.environmentRepository.update(
      {
        _organizationId: environment._organizationId,
        _id: environment._id,
      },
      { $set: { 'widget.notificationCenterEncryption': true } }
    );
  }

  async getEnvironment(environmentId: string): Promise<EnvironmentEntity | undefined> {
    const environment = await this.environmentRepository.findOne({
      _id: environmentId,
    });

    if (!environment) {
      return;
    }

    return environment;
  }

  async getEnvironmentByNameAndOrganization(
    organizationId: string,
    name: string
  ): Promise<EnvironmentEntity | undefined> {
    const environment = await this.environmentRepository.findOne({
      name,
      _organizationId: organizationId,
    });

    if (!environment) {
      return;
    }

    return environment;
  }

  async getEnvironments(organizationId: string): Promise<EnvironmentEntity[]> {
    return await this.environmentRepository.findOrganizationEnvironments(organizationId);
  }

  async getDevelopmentEnvironment(organizationId: string): Promise<EnvironmentEntity | undefined> {
    return await this.getEnvironmentByNameAndOrganization(organizationId, EnvironmentsEnum.DEVELOPMENT);
  }

  async getProductionEnvironment(organizationId: string): Promise<EnvironmentEntity | undefined> {
    return await this.getEnvironmentByNameAndOrganization(organizationId, EnvironmentsEnum.PRODUCTION);
  }

  async updateApiRateLimits(environmentId: string, apiRateLimits: Partial<IApiRateLimitMaximum>) {
    return await this.environmentRepository.updateApiRateLimits(environmentId, apiRateLimits);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class EnvironmentService

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/testing/src/index.ts
Tamaño: 702 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './constants';
export * from './create-notification-template.interface';
export * from './ee/clerk-client.mock';
export * from './ee/clerk-mock-data';
export * from './ee/ee.repository.factory';
export * from './environment.service';
export * from './integration.service';
export * from './jobs.service';
export * from './notification-template.service';
export * from './notifications.service';
export * from './organization.service';
export * from './subscribers.service';
export * from './test-server.service';
export * from './testing-queue.service';
export * from './user.service';
export * from './user.session';
export * from './utils';
export * from './workflow-override.service';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/testing/src/integration.service.ts
Tamaño: 5106 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentRepository, IntegrationRepository } from '@novu/dal';
import {
  ChannelTypeEnum,
  ChatProviderIdEnum,
  EmailProviderIdEnum,
  InAppProviderIdEnum,
  ProvidersIdEnum,
  PushProviderIdEnum,
  SmsProviderIdEnum,
  slugify,
} from '@novu/shared';
import shortid from 'shortid';

export class IntegrationService {
  private integrationRepository = new IntegrationRepository();
  private environmentRepository = new EnvironmentRepository();

  async createIntegration({
    organizationId,
    environmentId,
    channel,
    providerId: providerIdArg,
    name: nameArg,
    active = true,
  }: {
    environmentId: string;
    organizationId: string;
    channel: ChannelTypeEnum;
    providerId?: ProvidersIdEnum;
    name?: string;
    active?: boolean;
  }) {
    let providerId = providerIdArg;
    if (!providerId) {
      switch (channel) {
        case ChannelTypeEnum.EMAIL:
          providerId = EmailProviderIdEnum.SendGrid;
          break;
        case ChannelTypeEnum.SMS:
          providerId = SmsProviderIdEnum.Twilio;
          break;
        case ChannelTypeEnum.CHAT:
          providerId = ChatProviderIdEnum.Slack;
          break;
        case ChannelTypeEnum.PUSH:
          providerId = PushProviderIdEnum.FCM;
          break;
        case ChannelTypeEnum.IN_APP:
          providerId = InAppProviderIdEnum.Novu;
          break;
        default:
          throw new Error('Invalid channel type');
      }
    }

    const name = nameArg ?? providerId;
    const payload = {
      _organizationId: organizationId,
      _environmentId: environmentId,
      name,
      providerId,
      channel,
      credentials: {},
      active,
      identifier: `${slugify(name)}-${shortid.generate()}`,
    };

    return await this.integrationRepository.create(payload);
  }

  async deleteAllForOrganization(organizationId: string) {
    const environments = await this.environmentRepository.find({ _organizationId: organizationId });

    for (const environment of environments) {
      await this.integrationRepository.deleteMany({
        _organizationId: organizationId,
        _environmentId: environment._id,
      });
    }
  }

  async createChannelIntegrations(environmentId: string, organizationId: string) {
    const novuMailPayload = {
      _environmentId: environmentId,
      _organizationId: organizationId,
      providerId: EmailProviderIdEnum.Novu,
      channel: ChannelTypeEnum.EMAIL,
      credentials: {},
      active: false,
      identifier: 'novu-email',
    };

    await this.integrationRepository.create(novuMailPayload);

    const novuSmsPayload = {
      _environmentId: environmentId,
      _organizationId: organizationId,
      providerId: SmsProviderIdEnum.Novu,
      channel: ChannelTypeEnum.SMS,
      credentials: {},
      active: false,
      identifier: 'novu-sms',
    };

    await this.integrationRepository.create(novuSmsPayload);

    const mailPayload = {
      _environmentId: environmentId,
      _organizationId: organizationId,
      providerId: 'sendgrid',
      channel: ChannelTypeEnum.EMAIL,
      credentials: { apiKey: 'SG.123', secretKey: 'abc' },
      active: true,
      primary: true,
      priority: 1,
      identifier: 'sendgrid',
    };

    await this.integrationRepository.create(mailPayload);

    const smsPayload = {
      _environmentId: environmentId,
      _organizationId: organizationId,
      providerId: 'twilio',
      channel: ChannelTypeEnum.SMS,
      credentials: { accountSid: 'AC123', token: '123', from: 'me' },
      active: true,
      primary: true,
      priority: 1,
      identifier: 'twilio',
    };
    await this.integrationRepository.create(smsPayload);

    const chatSlackPayload = {
      _environmentId: environmentId,
      _organizationId: organizationId,
      providerId: 'slack',
      channel: ChannelTypeEnum.CHAT,
      credentials: { applicationId: 'secret_123' },
      active: true,
      identifier: 'slack',
    };

    await this.integrationRepository.create(chatSlackPayload);

    const chatDiscordPayload = {
      _environmentId: environmentId,
      _organizationId: organizationId,
      providerId: 'discord',
      channel: ChannelTypeEnum.CHAT,
      credentials: { applicationId: 'secret_123' },
      active: true,
      identifier: 'discord',
    };

    await this.integrationRepository.create(chatDiscordPayload);

    const pushFcmPayload = {
      _environmentId: environmentId,
      _organizationId: organizationId,
      providerId: 'fcm',
      channel: ChannelTypeEnum.PUSH,
      credentials: { applicationId: 'secret_123', deviceTokens: ['test'] },
      active: true,
      identifier: 'fcm',
    };

    await this.integrationRepository.create(pushFcmPayload);

    const inAppPayload = {
      _environmentId: environmentId,
      _organizationId: organizationId,
      providerId: InAppProviderIdEnum.Novu,
      channel: ChannelTypeEnum.IN_APP,
      credentials: {
        hmac: false,
      },
      active: true,
      identifier: 'novu-in-app',
    };

    await this.integrationRepository.create(inAppPayload);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class IntegrationService

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/testing/src/jobs.service.ts
Tamaño: 9635 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { setTimeout } from 'node:timers/promises';
import { JobRepository, JobStatusEnum } from '@novu/dal';
import { JobTopicNameEnum } from '@novu/shared';
import { Queue } from 'bullmq';
import { TestingQueueService } from './testing-queue.service';

/**
 * This service is contains utilities to manage the jobs in the Redis queue and Mongo during testing.
 */
export class JobsService {
  public standardQueue: Queue = new TestingQueueService(JobTopicNameEnum.WORKFLOW).queue;
  public workflowQueue: Queue = new TestingQueueService(JobTopicNameEnum.STANDARD).queue;
  public subscriberProcessQueue: Queue = new TestingQueueService(JobTopicNameEnum.PROCESS_SUBSCRIBER).queue;

  constructor(private jobRepository: JobRepository = new JobRepository()) {}

  /**
   * Wait for all jobs to be completed from the Redis queue and Mongo
   *
   * @param templateId - The template ID to wait for (optional)
   * @param organizationId - The organization ID to wait for (optional)
   * @param maxWaitTime - Maximum time to wait in milliseconds (default: 30000)
   */
  public async waitForJobCompletion({
    templateId,
    organizationId,
    maxWaitTime = 10000,
  }: {
    templateId?: string | string[];
    organizationId?: string | string[];
    maxWaitTime?: number;
  }) {
    const workflowMatch = templateId ? { _templateId: { $in: [templateId].flat() } } : {};
    const organizationMatch = organizationId ? { _organizationId: { $in: [organizationId].flat() } } : {};

    const startTime = Date.now();
    let redisJobsCount = 0;
    let mongoJobsCount = 0;

    do {
      await setTimeout(100);

      if (Date.now() - startTime > maxWaitTime) {
        throw new Error(
          `waitForJobCompletion timed out after ${maxWaitTime}ms. Redis jobs: ${redisJobsCount}, Mongo jobs: ${mongoJobsCount}`
        );
      }

      const metrics = await this.getQueueMetrics();

      redisJobsCount = metrics.totalCount;

      mongoJobsCount = Math.max(
        // @ts-expect-error
        await this.jobRepository.count({
          ...workflowMatch,
          ...organizationMatch,
          status: {
            $in: [JobStatusEnum.PENDING, JobStatusEnum.QUEUED, JobStatusEnum.RUNNING],
          },
        }),
        0
      );
    } while (redisJobsCount > 0 || mongoJobsCount > 0);
  }

  /**
   * Wait for all jobs to be completed from the Redis queue and Mongo
   *
   * @param templateId - The template ID to wait for (optional)
   * @param organizationId - The organization ID to wait for (optional)
   * @param maxWaitTime - Maximum time to wait in milliseconds (default: 30000)
   */
  public async waitForDbJobCompletion({
    templateId,
    organizationId,
    maxWaitTime = 10000,
  }: {
    templateId?: string | string[];
    organizationId?: string | string[];
    maxWaitTime?: number;
  }) {
    const workflowMatch = templateId ? { _templateId: { $in: [templateId].flat() } } : {};
    const organizationMatch = organizationId ? { _organizationId: { $in: [organizationId].flat() } } : {};

    const startTime = Date.now();
    let mongoJobsCount = 0;

    do {
      await setTimeout(100);

      if (Date.now() - startTime > maxWaitTime) {
        throw new Error(`waitForDbJobCompletion timed out after ${maxWaitTime}ms. Mongo jobs: ${mongoJobsCount}`);
      }

      mongoJobsCount = Math.max(
        // @ts-expect-error
        await this.jobRepository.count({
          ...workflowMatch,
          ...organizationMatch,
          status: {
            $in: [JobStatusEnum.PENDING, JobStatusEnum.QUEUED, JobStatusEnum.RUNNING],
          },
        }),
        0
      );
    } while (mongoJobsCount > 0);
  }

  /**
   * Wait for all jobs to be completed from the workflow Redis queue
   *
   * |----------------|------------------|----------------|
   * | workflow queue > subscriber queue > standard queue |
   * |----------------|------------------|----------------|
   *
   * @remarks
   * This is useful in testing when you want the trigger to be asserted in specific parts of the execution.
   * For example, you can wait for the workflow queue to be completed and then assert that the trigger was sent to the subscriber queue.
   */
  public async waitForWorkflowQueueCompletion(maxWaitTime = 10000) {
    return this.waitQueueUntil(
      ({ activeWorkflowJobsCount, waitingWorkflowJobsCount }) => activeWorkflowJobsCount + waitingWorkflowJobsCount > 0,
      maxWaitTime
    );
  }

  /**
   * Wait for all jobs to be completed from the subscriber Redis queue.
   *
   * |----------------|------------------|----------------|
   * | workflow queue > subscriber queue > standard queue |
   * |----------------|------------------|----------------|
   *
   * @remarks
   * This is useful in testing when you want the trigger to be asserted in specific parts of the execution.
   * For example, you can wait for the subscriber queue to be completed and then assert that the trigger was sent to the standard queue.
   */
  public async waitForSubscriberQueueCompletion(maxWaitTime = 10000) {
    return this.waitQueueUntil(
      ({ activeSubscriberJobsCount, waitingSubscriberJobsCount }) =>
        activeSubscriberJobsCount + waitingSubscriberJobsCount > 0,
      maxWaitTime
    );
  }

  /**
   * Wait for all jobs to be completed from the standard Redis queue
   *
   * |----------------|------------------|----------------|
   * | workflow queue > subscriber queue > standard queue |
   * |----------------|------------------|----------------|
   *
   * @remarks
   * This is useful in testing when you want the trigger to be asserted in specific parts of the execution.
   * For example, you can wait for the standard queue to be completed and then assert against the stage of the job in Mongo
   */
  public async waitForStandardQueueCompletion(maxWaitTime = 10000) {
    return this.waitQueueUntil(
      ({ activeStandardJobsCount, waitingStandardJobsCount }) => activeStandardJobsCount + waitingStandardJobsCount > 0,
      maxWaitTime
    );
  }

  public async waitQueueUntil(
    cb: (metrics: Awaited<ReturnType<typeof this.getQueueMetrics>>) => boolean,
    maxWaitTime = 10000
  ) {
    const startTime = Date.now();

    let queueMetrics: Awaited<ReturnType<typeof this.getQueueMetrics>>;

    do {
      await setTimeout(100);
      queueMetrics = await this.getQueueMetrics();
    } while (cb(queueMetrics) && Date.now() - startTime < maxWaitTime);
  }

  public async runStandardQueueDelayedJobsImmediately() {
    const delayedJobs = await this.standardQueue.getDelayed();
    await Promise.all(delayedJobs.map((job) => job.promote()));
  }

  /**
   * Clean all Redis queues from any pending jobs (waiting, delayed)
   * This is useful for test isolation to ensure tests start with clean queues
   */
  public async clearAllQueues() {
    try {
      await Promise.all([this.standardQueue.drain(), this.workflowQueue.drain(), this.subscriberProcessQueue.drain()]);
    } catch (error) {
      console.warn('Failed to clear Redis queues, continuing with test setup:', error);
    }
  }

  /**
   * Completely obliterate all Redis queues and their contents
   * WARNING: This removes ALL jobs including completed and failed ones
   * Use with caution, mainly for test teardown
   */
  public async obliterateAllQueues() {
    try {
      await Promise.all([
        this.standardQueue.obliterate(),
        this.workflowQueue.obliterate(),
        this.subscriberProcessQueue.obliterate(),
      ]);
    } catch (error) {
      console.warn('Failed to obliterate Redis queues, continuing with test teardown:', error);
    }
  }

  private async getQueueMetrics() {
    const [
      activeWorkflowJobsCount,
      waitingWorkflowJobsCount,
      failedWorkflowJobsCount,
      completedWorkflowJobsCount,
      delayedWorkflowJobsCount,

      activeSubscriberJobsCount,
      waitingSubscriberJobsCount,
      failedSubscriberJobsCount,
      completedSubscriberJobsCount,
      delayedSubscriberJobsCount,

      activeStandardJobsCount,
      waitingStandardJobsCount,
      failedStandardJobsCount,
      completedStandardJobsCount,
      delayedStandardJobsCount,
    ] = await Promise.all([
      this.workflowQueue.getActiveCount(),
      this.workflowQueue.getWaitingCount(),
      this.workflowQueue.getFailedCount(),
      this.workflowQueue.getCompletedCount(),
      this.workflowQueue.getDelayedCount(),

      this.subscriberProcessQueue.getActiveCount(),
      this.subscriberProcessQueue.getWaitingCount(),
      this.subscriberProcessQueue.getFailedCount(),
      this.subscriberProcessQueue.getCompletedCount(),
      this.subscriberProcessQueue.getDelayedCount(),

      this.standardQueue.getActiveCount(),
      this.standardQueue.getWaitingCount(),
      this.standardQueue.getFailedCount(),
      this.standardQueue.getCompletedCount(),
      this.standardQueue.getDelayedCount(),
    ]);

    const totalCount =
      activeWorkflowJobsCount +
      waitingWorkflowJobsCount +
      activeSubscriberJobsCount +
      waitingSubscriberJobsCount +
      activeStandardJobsCount +
      waitingStandardJobsCount;

    return {
      totalCount,

      activeWorkflowJobsCount,
      waitingWorkflowJobsCount,
      failedWorkflowJobsCount,
      completedWorkflowJobsCount,
      delayedWorkflowJobsCount,

      activeSubscriberJobsCount,
      waitingSubscriberJobsCount,
      failedSubscriberJobsCount,
      completedSubscriberJobsCount,
      delayedSubscriberJobsCount,

      activeStandardJobsCount,
      waitingStandardJobsCount,
      failedStandardJobsCount,
      completedStandardJobsCount,
      delayedStandardJobsCount,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - maxWaitTime(10000) {
    return this.waitQueueUntil(
      ({ activeWorkflowJobsCount, waitingWorkflowJobsCount ...)
 - maxWaitTime(10000) {
    return this.waitQueueUntil(
      ({ activeSubscriberJobsCount, waitingSubscriberJobsCo...)
 - maxWaitTime(10000) {
    return this.waitQueueUntil(
      ({ activeStandardJobsCount, waitingStandardJobsCount ...)
 - delayedJobs(await this.standardQueue.getDelayed();
    await Promise.all(delayedJobs.map((job))
Declaraciones 'export' encontradas:
- export class JobsService

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/testing/src/notification-template.service.ts
Tamaño: 7219 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { faker } from '@faker-js/faker';
import {
  FeedRepository,
  LayoutRepository,
  MessageTemplateRepository,
  NotificationGroupRepository,
  NotificationStepEntity,
  NotificationTemplateEntity,
  NotificationTemplateRepository,
  PreferencesRepository,
} from '@novu/dal';
import {
  buildWorkflowPreferencesFromPreferenceChannels,
  ChannelCTATypeEnum,
  DEFAULT_WORKFLOW_PREFERENCES,
  EmailBlockTypeEnum,
  IWorkflowStepMetadata,
  PreferencesTypeEnum,
  StepTypeEnum,
  TemplateVariableTypeEnum,
} from '@novu/shared';
import { v4 as uuid } from 'uuid';

import { CreateTemplatePayload } from './create-notification-template.interface';

export class NotificationTemplateService {
  constructor(
    private userId: string,
    private organizationId: string,
    private environmentId: string
  ) {}

  private notificationTemplateRepository = new NotificationTemplateRepository();
  private notificationGroupRepository = new NotificationGroupRepository();
  private messageTemplateRepository = new MessageTemplateRepository();
  private preferenceRepository = new PreferencesRepository();
  private feedRepository = new FeedRepository();
  private layoutRepository = new LayoutRepository();

  async createTemplate(override: Partial<CreateTemplatePayload> = {}) {
    const groups = await this.notificationGroupRepository.find({
      _environmentId: this.environmentId,
    });
    const feeds = await this.feedRepository.find({
      _environmentId: this.environmentId,
    });
    const layouts = await this.layoutRepository.find({
      _environmentId: this.environmentId,
    });

    const steps: CreateTemplatePayload['steps'] = override?.steps ?? [
      {
        type: StepTypeEnum.IN_APP,
        content: 'Test content for <b>{{firstName}}</b>',
        cta: {
          type: ChannelCTATypeEnum.REDIRECT,
          data: {
            url: '/cypress/test-shell/example/test?test-param=true',
          },
        },
        variables: [
          {
            defaultValue: '',
            name: 'firstName',
            required: false,
            type: TemplateVariableTypeEnum.STRING,
          },
        ],
      },
      {
        type: StepTypeEnum.EMAIL,
        subject: 'Password reset',
        content: [
          {
            type: EmailBlockTypeEnum.TEXT,
            content: 'This are the text contents of the template for {{firstName}}',
          },
          {
            type: EmailBlockTypeEnum.BUTTON,
            content: 'SIGN UP',
            url: 'https://url-of-app.com/{{urlVariable}}',
          },
        ],
        variables: [
          {
            defaultValue: '',
            name: 'firstName',
            required: false,
            type: TemplateVariableTypeEnum.STRING,
          },
        ],
      },
    ];

    const templateSteps: NotificationStepEntity[] = [];

    for (const message of steps) {
      const savedMessageTemplate = await this.messageTemplateRepository.create({
        type: message.type,
        cta: message.cta,
        variables: message.variables,
        content: message.content,
        subject: message.subject,
        title: message.title,
        name: message.name,
        preheader: message.preheader,
        actor: message.actor,
        _feedId: override.noFeedId ? undefined : feeds[0]._id,
        _layoutId: override.noLayoutId ? undefined : layouts[0]._id,
        _creatorId: this.userId,
        _organizationId: this.organizationId,
        _environmentId: this.environmentId,
      });

      const variantSteps: NotificationStepEntity[] = [];

      if (message.variants?.length) {
        for (const variant of message.variants) {
          const savedVariant = await this.messageTemplateRepository.create({
            type: variant.type,
            cta: variant.cta,
            variables: variant.variables,
            content: variant.content,
            subject: variant.subject,
            title: variant.title,
            name: variant.name,
            preheader: variant.preheader,
            _feedId: override.noFeedId ? undefined : feeds[0]._id,
            _layoutId: override.noLayoutId ? undefined : layouts[0]._id,
            _creatorId: this.userId,
            _organizationId: this.organizationId,
            _environmentId: this.environmentId,
          });

          if (savedVariant?._id) {
            variantSteps.push({
              filters: variant.filters,
              _templateId: savedVariant._id,
              active: variant.active,
              metadata: variant.metadata as IWorkflowStepMetadata,
              replyCallback: variant.replyCallback,
              uuid: variant.uuid,
            });
          }
        }
      }

      if (savedMessageTemplate?._id) {
        templateSteps.push({
          variants: variantSteps,
          filters: message.filters,
          _templateId: savedMessageTemplate._id,
          active: message.active,
          metadata: message.metadata as IWorkflowStepMetadata,
          replyCallback: message.replyCallback,
          uuid: message.uuid ?? uuid(),
          name: message.name,
        });
      }
    }

    const data = {
      _notificationGroupId: override.noGroupId ? undefined : groups[0]._id,
      _environmentId: this.environmentId,
      name: override.name ?? faker.name.jobTitle(),
      _organizationId: this.organizationId,
      _creatorId: this.userId,
      active: true,
      preferenceSettings: override.preferenceSettingsOverride ?? undefined,
      draft: false,
      tags: override.tags ?? ['test-tag'],
      description: faker.commerce.productDescription().slice(0, 90),
      triggers: override.triggers ?? [
        {
          identifier: `test-event-${faker.datatype.uuid()}`,
          type: 'event',
          variables: [{ name: 'firstName' }, { name: 'lastName' }, { name: 'urlVariable' }],
        },
      ],
      ...override,
      steps: templateSteps,
    } as NotificationTemplateEntity;

    const notificationTemplate = await this.notificationTemplateRepository.create(data);

    await this.preferenceRepository.create({
      _templateId: notificationTemplate._id,
      _environmentId: this.environmentId,
      _organizationId: this.organizationId,
      _userId: this.userId,
      type: PreferencesTypeEnum.USER_WORKFLOW,
      preferences: buildWorkflowPreferencesFromPreferenceChannels(
        override.critical,
        override.preferenceSettingsOverride
      ),
    });

    await this.preferenceRepository.create({
      _templateId: notificationTemplate._id,
      _environmentId: this.environmentId,
      _organizationId: this.organizationId,
      _userId: this.userId,
      type: PreferencesTypeEnum.WORKFLOW_RESOURCE,
      preferences: DEFAULT_WORKFLOW_PREFERENCES,
    });

    return await this.notificationTemplateRepository.findById(
      notificationTemplate._id,
      notificationTemplate._environmentId
    );
  }

  async getBlueprintTemplates(organizationId: string, environmentId: string): Promise<NotificationTemplateEntity[]> {
    const blueprintTemplates = await this.notificationTemplateRepository.findBlueprintTemplates(
      organizationId,
      environmentId
    );

    return blueprintTemplates;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class NotificationTemplateService

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/testing/src/notifications.service.ts
Tamaño: 859 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import axios from 'axios';

export class NotificationsService {
  constructor(
    private token: string,
    private environmentId: string
  ) {}

  async triggerEvent(name: string, subscriberId: string, payload = {}) {
    await axios.post(
      'http://127.0.0.1:1336/v1/events/trigger',
      {
        name,
        to: subscriberId,
        payload,
      },
      {
        headers: {
          /*
           * TODO: In a more realistic testing scenario events/trigger is mostly called using the Novu secret key
           * in a machine-to-machine setup instead of a user bearer JWT.
           *
           * In future work, we should replace the JWT with an API key and simplify testing preparation.
           */
          Authorization: `Bearer ${this.token}`,
          'Novu-Environment-Id': this.environmentId,
        },
      }
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class NotificationsService

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/testing/src/organization.service.ts
Tamaño: 1401 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { faker } from '@faker-js/faker';
import { CommunityMemberRepository, CommunityOrganizationRepository, OrganizationRepository } from '@novu/dal';
import { ApiServiceLevelEnum, MemberRoleEnum, MemberStatusEnum } from '@novu/shared';

export class OrganizationService {
  private organizationRepository = new CommunityOrganizationRepository();
  private memberRepository = new CommunityMemberRepository();

  async createOrganization(options?: Parameters<OrganizationRepository['create']>[0]) {
    if (options) {
      return await this.organizationRepository.create({
        logo: faker.image.avatar(),
        name: faker.company.companyName(),
        ...options,
      });
    }

    return await this.organizationRepository.create({
      logo: faker.image.avatar(),
      name: faker.company.companyName(),
    });
  }

  async addMember(organizationId: string, userId: string) {
    await this.memberRepository.addMember(organizationId, {
      _userId: userId,
      roles: [MemberRoleEnum.OSS_ADMIN],
      memberStatus: MemberStatusEnum.ACTIVE,
    });
  }

  async getOrganization(organizationId: string) {
    return await this.organizationRepository.findById(organizationId);
  }

  async updateServiceLevel(organizationId: string, serviceLevel: ApiServiceLevelEnum) {
    await this.organizationRepository.update({ _id: organizationId }, { apiServiceLevel: serviceLevel });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class OrganizationService

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/testing/src/subscribers.service.ts
Tamaño: 1795 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { faker } from '@faker-js/faker';
import { IntegrationRepository, SubscriberEntity, SubscriberRepository } from '@novu/dal';
import { ChatProviderIdEnum, PushProviderIdEnum } from '@novu/shared';

export class SubscribersService {
  private subscriberRepository = new SubscriberRepository();
  private integrationRepository = new IntegrationRepository();

  constructor(
    private _organizationId: string,
    private _environmentId: string
  ) {}

  async createSubscriber(fields: Partial<SubscriberEntity> = {}) {
    const integrations = await this.integrationRepository.find({
      _environmentId: this._environmentId,
      _organizationId: this._organizationId,
    });

    const slackIntegration = integrations.find((integration) => integration.providerId === ChatProviderIdEnum.Slack);
    const fcmIntegration = integrations.find((integration) => integration.providerId === PushProviderIdEnum.FCM);
    const channels: SubscriberEntity['channels'] = [];
    if (slackIntegration) {
      channels.push({
        _integrationId: slackIntegration._id,
        providerId: ChatProviderIdEnum.Slack,
        credentials: { webhookUrl: 'webhookUrl' },
      });
    }

    if (fcmIntegration) {
      channels.push({
        _integrationId: fcmIntegration._id,
        providerId: PushProviderIdEnum.FCM,
        credentials: { deviceTokens: ['identifier'] },
      });
    }

    return await this.subscriberRepository.create({
      lastName: faker.name.lastName(),
      firstName: faker.name.firstName(),
      email: faker.internet.email(),
      phone: faker.phone.phoneNumber(),
      _environmentId: this._environmentId,
      _organizationId: this._organizationId,
      subscriberId: SubscriberRepository.createObjectId(),
      channels,
      ...fields,
    });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - slackIntegration(integrations.find((integration))
 - fcmIntegration(integrations.find((integration))
Declaraciones 'export' encontradas:
- export class SubscribersService

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/testing/src/test-server.service.ts
Tamaño: 915 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export class TestServer {
  private app;

  getHttpServer() {
    return this.app.getHttpServer();
  }

  getService(service) {
    return this.app.get(service);
  }

  async create(app) {
    this.app = app;
  }

  async teardown() {
    try {
      if (this.app) {
        await this.app.close();
      }
    } catch (error) {
      console.error('Error when closing TestServer', error.message);
    }
  }
}

export const testServer = new TestServer();

export class WsTestServer {
  private app;

  getHttpServer() {
    return this.app.getHttpServer();
  }

  getService(service) {
    return this.app.get(service);
  }

  async create(app) {
    this.app = app;
  }

  async teardown() {
    try {
      if (this.app) {
        await this.app.close();
      }
    } catch (error) {
      console.error('Error when closing WsServer', error.message);
    }
  }
}

export const wsTestServer = new WsTestServer();


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class TestServer
- export  const
- export class WsTestServer
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/testing/src/testing-queue.service.ts
Tamaño: 616 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Queue } from 'bullmq';
import { ConnectionOptions } from 'tls';

export class TestingQueueService {
  public queue: Queue;

  constructor(name: string) {
    this.queue = new Queue(name, {
      connection: {
        db: Number(process.env.REDIS_DB_INDEX || '1'),
        port: Number(process.env.REDIS_PORT || 6379),
        host: process.env.REDIS_HOST,
        password: process.env.REDIS_PASSWORD,
        connectTimeout: 50000,
        keepAlive: 30000,
        tls: process.env.REDIS_TLS as ConnectionOptions,
      },
      defaultJobOptions: {
        removeOnComplete: true,
      },
    });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class TestingQueueService

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/testing/src/user.service.ts
Tamaño: 2194 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { faker } from '@faker-js/faker';
import { CommunityUserRepository, UserEntity } from '@novu/dal';
import { normalizeEmail } from '@novu/shared';
import { hash } from 'bcrypt';
import { TEST_USER_PASSWORD } from './constants';
import { EnvironmentService } from './environment.service';
import { OrganizationService } from './organization.service';

export class UserService {
  private environmentService = new EnvironmentService();
  private organizationService = new OrganizationService();
  private userRepository = new CommunityUserRepository();

  async createTestUser(): Promise<UserEntity> {
    const user = await this.createUser({
      email: this.randomEmail(),
      firstName: faker.name.firstName(),
      lastName: faker.name.lastName(),
      password: this.testPassword(),
    });

    const organization = await this.organizationService.createOrganization();

    await this.organizationService.addMember(organization._id, user._id);

    await this.environmentService.createDevelopmentEnvironment(organization._id, user._id);

    return user;
  }

  async createUser(userEntity?: Partial<UserEntity>): Promise<UserEntity> {
    const password = userEntity?.password ?? faker.internet.password();
    const passwordHash = await hash(password, 10);

    const user = await this.userRepository.create({
      email: normalizeEmail(userEntity?.email ?? faker.internet.email()),
      firstName: userEntity?.firstName ?? faker.name.firstName(),
      lastName: userEntity?.lastName ?? faker.name.lastName(),
      password: passwordHash,
      profilePicture: `https://randomuser.me/api/portraits/men/${Math.floor(Math.random() * 60) + 1}.jpg`,
      tokens: [],
      showOnBoardingTour: userEntity?.showOnBoardingTour ?? 2,
    });

    return user;
  }

  async getUser(id: string): Promise<UserEntity> {
    const user = await this.userRepository.findById(id);

    if (!user) {
      throw new Error(`Test user with ${id} not found`);
    }

    return user;
  }

  randomEmail(): string {
    return faker.internet.email();
  }

  randomPassword(): string {
    return faker.internet.password();
  }

  testPassword(): string {
    return TEST_USER_PASSWORD;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UserService

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/testing/src/user.session.ts
Tamaño: 15332 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import 'cross-fetch/polyfill';
import { faker } from '@faker-js/faker';
import {
  ChangeEntity,
  ChangeRepository,
  CommunityOrganizationRepository,
  EnvironmentEntity,
  FeedRepository,
  LayoutRepository,
  NotificationGroupEntity,
  NotificationGroupRepository,
  OrganizationEntity,
  SubscriberRepository,
  UserEntity,
} from '@novu/dal';
import {
  ALL_PERMISSIONS,
  ApiServiceLevelEnum,
  EmailBlockTypeEnum,
  IApiRateLimitMaximum,
  IEmailBlock,
  isClerkEnabled,
  MemberRoleEnum,
  StepTypeEnum,
} from '@novu/shared';
import jwt from 'jsonwebtoken';
import superAgentDefaults from 'superagent-defaults';
import request, { SuperTest, Test } from 'supertest';
import { TEST_USER_PASSWORD } from './constants';
import { CreateTemplatePayload } from './create-notification-template.interface';
import { CLERK_ORGANIZATION_1, CLERK_USER_1 } from './ee/clerk-mock-data';
import { EEOrganizationService } from './ee/ee.organization.service';
import { EEUserService } from './ee/ee.user.service';
import { ClerkJwtPayload } from './ee/types';
import { EnvironmentService } from './environment.service';
import { IntegrationService } from './integration.service';
import { JobsService } from './jobs.service';
import { NotificationTemplateService } from './notification-template.service';
import { OrganizationService } from './organization.service';
import { TestServer, testServer } from './test-server.service';
import { UserService } from './user.service';

type UserSessionOptions = {
  noOrganization?: boolean;
  noEnvironment?: boolean;
  noWidgetSession?: boolean;
  showOnBoardingTour?: boolean;
  ee?: {
    userId: string;
    orgId: string;
  };
};

const EMAIL_BLOCK: IEmailBlock[] = [
  {
    type: EmailBlockTypeEnum.TEXT,
    content: 'Email Content',
  },
];

export class UserSession {
  private notificationGroupRepository = new NotificationGroupRepository();
  private feedRepository = new FeedRepository();
  private layoutRepository = new LayoutRepository();
  private changeRepository: ChangeRepository = new ChangeRepository();
  private environmentService: EnvironmentService = new EnvironmentService();
  private integrationService: IntegrationService = new IntegrationService();
  private jobsService: JobsService;

  token: string;

  subscriberToken: string;

  subscriberId: string;

  subscriberProfile: {
    _id: string;
  } | null = null;

  notificationGroups: NotificationGroupEntity[] = [];

  organization: OrganizationEntity;

  user: UserEntity;

  testAgent: SuperTest<Test>;

  environment: EnvironmentEntity;

  testServer: null | TestServer = testServer;

  apiKey: string;

  constructor(public serverUrl = `http://127.0.0.1:${process.env.PORT}`) {
    this.jobsService = new JobsService();
  }

  async initialize(options: UserSessionOptions = {}) {
    // Clear Redis queues from any previous test jobs to ensure test isolation
    await this.jobsService.clearAllQueues();

    if (isClerkEnabled()) {
      await this.initializeEE(options);
    } else {
      await this.initializeCommunity(options);
    }
  }

  private async initializeCommunity(options: UserSessionOptions = {}) {
    const card = {
      firstName: faker.name.firstName(),
      lastName: faker.name.lastName(),
    };

    const userService = new UserService();
    const userEntity: Partial<UserEntity> = {
      lastName: card.lastName,
      firstName: card.firstName,
      email: `${card.firstName}_${card.lastName}_${faker.datatype.uuid()}@gmail.com`.toLowerCase(),
      profilePicture: `https://randomuser.me/api/portraits/men/${Math.floor(Math.random() * 60) + 1}.jpg`,
      tokens: [],
      password: TEST_USER_PASSWORD,
      showOnBoarding: true,
      showOnBoardingTour: options.showOnBoardingTour ? 0 : 2,
    };

    this.user = await userService.createUser(userEntity);

    if (!options.noOrganization) {
      await this.addOrganizationCommunity();
    }

    if (!options.noOrganization && !options?.noEnvironment) {
      await this.createEnvironmentsAndFeeds();
    }

    await this.fetchJwtCommunity();

    if (!options.noOrganization) {
      if (!options?.noEnvironment) {
        await this.updateOrganizationDetails();
      }
    }

    if (!options.noOrganization && !options.noEnvironment && !options.noWidgetSession) {
      const { token, profile } = await this.initializeWidgetSession();
      this.subscriberToken = token;
      this.subscriberProfile = profile;
    }
  }

  private async initializeEE(options: UserSessionOptions) {
    const userService = new EEUserService();

    const externalUserId = options.ee?.userId || CLERK_USER_1.id;
    const externalOrgId = options.ee?.orgId || CLERK_ORGANIZATION_1.id;

    const user = await userService.getUser(externalUserId);

    if (!user._id) {
      // not linked in clerk
      this.user = await userService.createUser(externalUserId);
    } else {
      this.user = user;
    }

    if (!options.noOrganization) {
      await this.addOrganizationEE(externalOrgId);
    }

    await this.fetchJwtEE();

    if (!options.noOrganization && !options?.noEnvironment) {
      await this.createEnvironmentsAndFeeds();
    }

    await this.fetchJwtEE();

    if (!options.noOrganization) {
      if (!options?.noEnvironment) {
        await this.updateOrganizationDetails();
      }
    }

    if (!options.noOrganization && !options.noEnvironment && !options.noWidgetSession) {
      const { token, profile } = await this.initializeWidgetSession();
      this.subscriberToken = token;
      this.subscriberProfile = profile;
    }
  }

  private async initializeWidgetSession() {
    this.subscriberId = SubscriberRepository.createObjectId();

    const { body } = await this.testAgent
      .post('/v1/widgets/session/initialize')
      .send({
        applicationIdentifier: this.environment.identifier,
        subscriberId: this.subscriberId,
        firstName: 'Widget User',
        lastName: 'Test',
        email: 'test@example.com',
      })
      .expect(201);

    const { token, profile } = body.data;

    return { token, profile };
  }

  private shouldUseTestServer() {
    return this.testServer && !this.serverUrl;
  }

  private get requestEndpoint() {
    return this.shouldUseTestServer() ? this.testServer?.getHttpServer() : this.serverUrl;
  }

  async fetchJWT() {
    if (isClerkEnabled()) {
      await this.fetchJwtEE();
    } else {
      await this.fetchJwtCommunity();
    }
  }

  async addOrganization() {
    if (!isClerkEnabled()) {
      return await this.addOrganizationCommunity();
    } else {
      throw new Error('Not implemented');
    }
  }

  private async fetchJwtCommunity() {
    const response = await request(this.requestEndpoint).get(
      `/v1/auth/test/token/${this.user._id}?organizationId=${this.organization ? this.organization._id : ''}`
    );

    this.token = `Bearer ${response.body.data}`;
    this.testAgent = superAgentDefaults(request(this.requestEndpoint))
      .set('Authorization', this.token)
      .set('Novu-Environment-Id', this.environment ? this.environment._id : '');
  }

  private async fetchJwtEE() {
    await this.updateEETokenClaims({
      externalId: this.user ? this.user._id : '',
      externalOrgId: this.organization ? this.organization._id : '',
      org_role: MemberRoleEnum.OWNER,
      org_permissions: ALL_PERMISSIONS,
      _id: this.user ? this.user.externalId : 'does_not_matter',
      org_id: this.organization ? this.organization.externalId : 'does_not_matter',
    });
  }

  async updateEETokenClaims(claims: Partial<ClerkJwtPayload>) {
    try {
      const currentPayload = this.token ? jwt.decode(this.token.replace('Bearer ', '')) : null;

      const baseToken = process.env.CLERK_LONG_LIVED_TOKEN as string;
      const payload = {
        ...jwt.decode(baseToken),
        ...(currentPayload || {}),
        ...claims,
      };

      const encodedToken = jwt.sign(payload, process.env.CLERK_MOCK_JWT_PRIVATE_KEY, {
        algorithm: 'RS256',
      });

      this.token = `Bearer ${encodedToken}`;

      // Update test agent with new token and current environment
      this.testAgent = superAgentDefaults(request(this.requestEndpoint))
        .set('Authorization', this.token)
        .set('Novu-Environment-Id', this.environment?._id || '');
    } catch (error) {
      console.error('Error in updateEETokenClaims:', error);
      throw error;
    }
  }

  async createEnvironmentsAndFeeds(): Promise<void> {
    const development = await this.createEnvironment('Development');
    this.environment = development;
    const production = await this.createEnvironment('Production', development._id);
    this.apiKey = this.environment.apiKeys[0].key;

    await this.createIntegrations([development, production]);

    await this.createFeed();
    await this.createFeed('New');
  }

  async createEnvironment(name = 'Test environment', parentId?: string): Promise<EnvironmentEntity> {
    const environment = await this.environmentService.createEnvironment(
      this.organization._id,
      this.user._id,
      name,
      parentId
    );

    let parentGroup;
    if (parentId) {
      parentGroup = await this.notificationGroupRepository.findOne({
        _environmentId: parentId,
        _organizationId: this.organization._id,
      });
    }

    await this.notificationGroupRepository.create({
      name: 'General',
      _environmentId: environment._id,
      _organizationId: this.organization._id,
      _parentId: parentGroup?._id,
    });

    await this.layoutRepository.create({
      name: 'Default',
      identifier: 'default-layout',
      _environmentId: environment._id,
      _organizationId: this.organization._id,
      isDefault: true,
    });

    return environment;
  }

  async updateOrganizationDetails() {
    await this.testAgent
      .put('/v1/organizations/branding')
      .send({
        color: '#2a9d8f',
        logo: 'https://dashboard.novu.co/static/images/logo-light.png',
        fontColor: '#214e49',
        contentBackground: '#c2cbd2',
        fontFamily: 'Montserrat',
      })
      .expect(200);

    const groupsResponse = await this.testAgent.get('/v1/notification-groups');

    this.notificationGroups = groupsResponse.body.data;
  }

  async createTemplate(template?: Partial<CreateTemplatePayload>) {
    const service = new NotificationTemplateService(this.user._id, this.organization._id, this.environment._id);

    return await service.createTemplate(template);
  }

  async createIntegrations(environments: EnvironmentEntity[]): Promise<void> {
    for (const environment of environments) {
      await this.integrationService.createChannelIntegrations(environment._id, this.organization._id);
    }
  }

  async createChannelTemplate(channel: StepTypeEnum) {
    const service = new NotificationTemplateService(this.user._id, this.organization._id, this.environment._id);

    return await service.createTemplate({
      steps: [
        {
          type: channel,
          content: channel === StepTypeEnum.EMAIL ? EMAIL_BLOCK : 'Test notification content',
        },
      ],
    });
  }

  private async addOrganizationCommunity() {
    const organizationService = new OrganizationService();

    this.organization = await organizationService.createOrganization();
    await organizationService.addMember(this.organization._id, this.user._id);

    return this.organization;
  }

  private async addOrganizationEE(orgId: string) {
    const organizationService = new EEOrganizationService();

    try {
      // is not linked
      this.organization = await organizationService.createOrganization(orgId);
    } catch (e) {
      // is already linked
      this.organization = (await organizationService.getOrganization(orgId)) as OrganizationEntity;
    }

    return this.organization;
  }

  async switchToProdEnvironment() {
    const prodEnvironment = await this.environmentService.getProductionEnvironment(this.organization._id);
    if (prodEnvironment) {
      await this.switchEnvironment(prodEnvironment._id);
    }
  }

  // TODO: Replace with a getDevId
  async switchToDevEnvironment() {
    const devEnvironment = await this.environmentService.getDevelopmentEnvironment(this.organization._id);
    if (devEnvironment) {
      await this.switchEnvironment(devEnvironment._id);
    }
  }

  // TODO: create EE version
  async switchEnvironment(environmentId: string) {
    const environment = await this.environmentService.getEnvironment(environmentId);

    if (environment) {
      this.environment = environment;
      await this.testAgent.post(`/v1/auth/environments/${environmentId}/switch`);

      if (isClerkEnabled()) {
        await this.fetchJwtEE();
      } else {
        await this.fetchJwtCommunity();
      }
    }
  }

  async createFeed(name?: string) {
    name = name || 'Activities';
    const feed = await this.feedRepository.create({
      name,
      identifier: name,
      _environmentId: this.environment._id,
      _organizationId: this.organization._id,
    });

    return feed;
  }

  public async waitForJobCompletion(
    templateId?: string | string[],
    organizationId = this.organization._id,
    maxWaitTime?: number
  ) {
    return this.jobsService.waitForJobCompletion({
      templateId,
      organizationId,
      maxWaitTime,
    });
  }

  public async waitForDbJobCompletion({
    templateId,
    organizationId,
    maxWaitTime,
  }: {
    templateId?: string | string[];
    organizationId?: string | string[];
    maxWaitTime?: number;
  }) {
    return this.jobsService.waitForDbJobCompletion({ templateId, organizationId, maxWaitTime });
  }

  public async waitForWorkflowQueueCompletion(maxWaitTime?: number) {
    return this.jobsService.waitForWorkflowQueueCompletion(maxWaitTime);
  }

  public async waitForSubscriberQueueCompletion(maxWaitTime?: number) {
    return this.jobsService.waitForSubscriberQueueCompletion(maxWaitTime);
  }

  public async waitForStandardQueueCompletion(maxWaitTime?: number) {
    return this.jobsService.waitForStandardQueueCompletion(maxWaitTime);
  }

  public async runStandardQueueDelayedJobsImmediately() {
    return this.jobsService.runStandardQueueDelayedJobsImmediately();
  }

  public async clearAllQueues() {
    return this.jobsService.clearAllQueues();
  }

  public async obliterateAllQueues() {
    return this.jobsService.obliterateAllQueues();
  }

  public async applyChanges(where: Partial<ChangeEntity> = {}) {
    const changes = await this.changeRepository.find(
      {
        _environmentId: this.environment._id,
        _organizationId: this.organization._id,
        _parentId: { $exists: false, $eq: null },
        ...where,
      },
      '',
      {
        sort: { createdAt: 1 },
      }
    );

    for (const change of changes) {
      await this.testAgent.post(`/v1/changes/${change._id}/apply`);
    }
  }

  public async updateOrganizationServiceLevel(serviceLevel: ApiServiceLevelEnum) {
    const communityOrganizationRepository = new CommunityOrganizationRepository();

    await communityOrganizationRepository.update({ _id: this.organization._id }, { apiServiceLevel: serviceLevel });
  }

  public async updateEnvironmentApiRateLimits(apiRateLimits: Partial<IApiRateLimitMaximum>) {
    await this.environmentService.updateApiRateLimits(this.environment._id, apiRateLimits);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UserSession

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/testing/src/workflow-override.service.ts
Tamaño: 2335 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { faker } from '@faker-js/faker';
import {
  NotificationGroupRepository,
  NotificationTemplateRepository,
  TenantRepository,
  WorkflowOverrideEntity,
  WorkflowOverrideRepository,
} from '@novu/dal';
import { ICreateWorkflowOverrideRequestDto } from '@novu/shared';

export class WorkflowOverrideService {
  constructor(private config: { organizationId: string; environmentId: string }) {}

  private notificationTemplateRepository = new NotificationTemplateRepository();
  private notificationGroupRepository = new NotificationGroupRepository();
  private tenantRepository = new TenantRepository();
  private workflowOverrideRepository = new WorkflowOverrideRepository();

  async createWorkflowOverride(override: Partial<ICreateWorkflowOverrideRequestDto> = {}) {
    const { organizationId, environmentId } = this.config;
    const tenant = await this.tenantRepository.create({
      _organizationId: organizationId,
      _environmentId: environmentId,
      identifier: faker.datatype.uuid(),
      name: 'name_123',
      data: { test1: 'test value1', test2: 'test value2' },
    });

    const groups = await this.notificationGroupRepository.find({
      _environmentId: environmentId,
    });

    const workflowId = override.workflowId || (await this.createWorkflow(groups))._id;

    const payload: Partial<WorkflowOverrideEntity> = {
      _organizationId: organizationId,
      _environmentId: environmentId,
      _workflowId: workflowId,
      _tenantId: tenant._id,
    };

    if (override.active != null) {
      payload.active = override.active;
    }

    if (override.preferenceSettings != null) {
      payload.preferenceSettings = override.preferenceSettings;
    }

    const workflowOverride = await this.workflowOverrideRepository.create(payload as WorkflowOverrideEntity);

    return { tenant, workflowOverride };
  }

  private async createWorkflow(groups) {
    const { organizationId, environmentId } = this.config;

    return await this.notificationTemplateRepository.create({
      _organizationId: organizationId,
      _environmentId: environmentId,
      name: 'test api template',
      description: 'This is a test description',
      tags: ['test-tag-api'],
      notificationGroupId: groups[0]._id,
      steps: [],
      triggers: [{ identifier: 'test-trigger-api' }],
    });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class WorkflowOverrideService

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/testing/src/ee/clerk-client.mock.ts
Tamaño: 5989 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { Organization, OrganizationMembership, User } from '@clerk/backend';
import type { OrganizationAPI, UserAPI } from '@clerk/backend/dist/api/endpoints';
import {
  CLERK_ORGANIZATION_1,
  CLERK_ORGANIZATION_1_MEMBERSHIP_1,
  CLERK_ORGANIZATION_2,
  CLERK_USER_1,
  CLERK_USER_2,
} from './clerk-mock-data';

export class ClerkClientMock {
  private clerkUsers = new Map([
    [CLERK_USER_1.id, CLERK_USER_1],
    [CLERK_USER_2.id, CLERK_USER_2],
  ]);
  private clerkOrganizations = new Map([
    [CLERK_ORGANIZATION_1.id, CLERK_ORGANIZATION_1],
    [CLERK_ORGANIZATION_2.id, CLERK_ORGANIZATION_2],
  ]);

  private clerkOrganizationMemberships = [CLERK_ORGANIZATION_1_MEMBERSHIP_1];

  private getUserById(userId: string) {
    const user = this.clerkUsers.get(userId);

    if (!user) {
      throw new Error('User not found');
    }

    return user;
  }

  get users(): Partial<UserAPI> {
    const updateUser: UserAPI['updateUser'] = async (userId, params) => {
      const user = this.getUserById(userId);
      const updatedUser = { ...user, ...params } as User;
      this.clerkUsers.set(userId, updatedUser);

      return updatedUser;
    };

    const updateUserMetadata: UserAPI['updateUserMetadata'] = async (userId, params) => {
      const user = this.getUserById(userId);
      const newUser = {
        ...user,
        publicMetadata: { ...user.publicMetadata, ...params.publicMetadata },
        privateMetadata: { ...user.privateMetadata, ...params.privateMetadata },
      } as User;
      this.clerkUsers.set(userId, newUser);

      return newUser;
    };

    const getUser: UserAPI['getUser'] = async (userId) => {
      return this.getUserById(userId);
    };

    const getUserList: UserAPI['getUserList'] = async (params = {}) => {
      const users = Array.from(this.clerkUsers.values()).filter((user) => {
        if (params.emailAddress && params.emailAddress.length > 0) {
          return user.emailAddresses.some((emailAddress) => emailAddress.emailAddress === params.emailAddress?.[0]);
        }

        return true;
      });

      return {
        data: users,
        totalCount: users.length,
      };
    };

    const getOrganizationMembershipList: UserAPI['getOrganizationMembershipList'] = async (params) => {
      const users = Array.from(this.clerkOrganizationMemberships.values()).filter(
        (membership) => membership.organization.id === params.userId
      );

      return Promise.resolve({
        data: users,
        totalCount: users.length,
      });
    };

    const deleteUser: UserAPI['deleteUser'] = async (userId) => {
      const user = this.getUserById(userId);
      this.clerkUsers.delete(userId);

      return user;
    };

    return {
      updateUser,
      updateUserMetadata,
      getUser,
      getUserList,
      deleteUser,
      getOrganizationMembershipList,
    };
  }

  get organizations() {
    const getOrganization: OrganizationAPI['getOrganization'] = async (params) => {
      if ('organizationId' in params) {
        const org = this.clerkOrganizations.get(params.organizationId);
        if (!org) throw new Error(`Organization not found with id ${params.organizationId}`);

        return org;
      }

      if ('slug' in params) {
        const org = Array.from(this.clerkOrganizations.values()).find((_org) => _org.slug === params.slug);
        if (!org) throw new Error(`Organization not found with slug ${params.slug}`);

        return org;
      }

      throw new Error('Invalid parameters: must provide either organizationId or slug');
    };

    const getOrganizationMembershipList: OrganizationAPI['getOrganizationMembershipList'] = async (params) => {
      const memberships = Array.from(this.clerkOrganizationMemberships.values()).filter(
        (membership) => membership.organization.id === params.organizationId
      );

      return {
        data: memberships,
        totalCount: memberships.length,
      };
    };

    const createOrganizationMembership: OrganizationAPI['createOrganizationMembership'] = async (params) => {
      const newMembership = {
        ...params,
        createdAt: Date.now(),
        updatedAt: Date.now(),
        id: Date.now().toString(),
        publicMetadata: {},
        privateMetadata: {},
        organization: CLERK_ORGANIZATION_1,
      } as unknown as OrganizationMembership;
      this.clerkOrganizationMemberships.push(newMembership);

      return newMembership;
    };

    const updateOrganization: OrganizationAPI['updateOrganization'] = async (organizationId, params) => {
      const organization = this.clerkOrganizations.get(organizationId);
      if (!organization) throw new Error(`Organization not found with id ${organizationId}`);

      const updatedOrganization = { ...organization, ...params } as Organization;
      this.clerkOrganizations.set(organizationId, updatedOrganization);

      return updatedOrganization;
    };

    const updateOrganizationMetadata: OrganizationAPI['updateOrganizationMetadata'] = async (
      organizationId,
      params
    ) => {
      const organization = this.clerkOrganizations.get(organizationId);
      if (!organization) throw new Error(`Organization not found with id ${organizationId}`);

      const updatedOrganization = { ...organization, ...params } as Organization;
      this.clerkOrganizations.set(organizationId, updatedOrganization);

      return updatedOrganization;
    };

    const deleteOrganization: OrganizationAPI['deleteOrganization'] = async (organizationId) => {
      const organization = this.clerkOrganizations.get(organizationId);
      if (!organization) throw new Error(`Organization not found with id ${organizationId}`);

      this.clerkOrganizations.delete(organizationId);

      return organization;
    };

    return {
      getOrganization,
      getOrganizationMembershipList,
      createOrganizationMembership,
      updateOrganization,
      updateOrganizationMetadata,
      deleteOrganization,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - params({}))
 - users(Array.from(this.clerkUsers.values()).filter((user))
 - users(Array.from(this.clerkOrganizationMemberships.values()).filter(
        (membership))
 - org(Array.from(this.clerkOrganizations.values()).find((_org))
 - memberships(Array.from(this.clerkOrganizationMemberships.values()).filter(
        (membership))
Declaraciones 'export' encontradas:
- export class ClerkClientMock

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/testing/src/ee/clerk-mock-data.ts
Tamaño: 3088 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { Organization, OrganizationMembership, User } from '@clerk/backend';
import { JobTitleEnum } from '@novu/shared';

export const CLERK_USER_1 = {
  id: 'clerk_user_1',
  externalId: null,
  firstName: 'firstName',
  lastName: 'lastName',
  emailAddresses: [],
  username: 'username',
  fullName: null,
  imageUrl: 'https://example.com',
  hasImage: true,
  publicMetadata: {
    showOnBoarding: true,
    showOnBoardingTour: 2,
    servicesHashes: {},
    jobTitle: JobTitleEnum.ENGINEER,
  },
  privateMetadata: {},
  unsafeMetadata: {},
  banned: false,
  createdAt: 1,
  updatedAt: 1,
  primaryEmailAddressId: '1',
  primaryPhoneNumberId: '1',
  primaryWeb3WalletId: '1',
  lastSignInAt: 1,
  phoneNumbers: [],
  web3Wallets: [],
  externalAccounts: [],
  samlAccounts: [],
  lastActiveAt: 1,
  createOrganizationEnabled: true,
  primaryEmailAddress: {
    id: '1',
    emailAddress: 'emailAddress',
    verification: null,
    linkedTo: [],
  },
  primaryPhoneNumber: null,
  primaryWeb3Wallet: null,
  passwordEnabled: true,
  totpEnabled: true,
  backupCodeEnabled: true,
  twoFactorEnabled: true,
  locked: false,
  createOrganizationsLimit: 10,
  deleteSelfEnabled: true,
} as unknown as User;

export const CLERK_USER_2 = {
  ...CLERK_USER_1,
  id: 'clerk_user_2',
  externalId: null,
  firstName: 'firstName2',
  lastName: 'lastName2',
  emailAddresses: [],
  username: 'username2',
  fullName: null,
  imageUrl: 'https://example2.com',
  publicMetadata: {
    showOnBoarding: false,
    showOnBoardingTour: 2,
    servicesHashes: {},
    jobTitle: JobTitleEnum.ENGINEERING_MANAGER,
  },
  primaryEmailAddress: {
    id: '2',
    emailAddress: 'emailAddress',
    verification: null,
    linkedTo: [],
  },
  primaryPhoneNumber: null,
  primaryWeb3Wallet: null,
} as unknown as User;

export const CLERK_ORGANIZATION_1 = {
  id: 'clerk_org_1',
  name: 'Organization 1',
  slug: 'organization-1',
  imageUrl: 'https://example.com/organization-1.png',
  hasImage: true,
  createdBy: 'user_1',
  createdAt: 1_000_000,
  updatedAt: 1_000_000,
  publicMetadata: {},
  privateMetadata: {},
  maxAllowedMemberships: 10,
  adminDeleteEnabled: true,
  membersCount: 10,
} as unknown as Organization;

export const CLERK_ORGANIZATION_2 = {
  id: 'clerk_org_2',
  name: 'Organization 2',
  slug: 'organization-2',
  imageUrl: 'https://example.com/organization-2.png',
  hasImage: true,
  createdBy: 'user_1',
  createdAt: 1_000_000,
  updatedAt: 1_000_000,
  publicMetadata: {},
  privateMetadata: {},
  maxAllowedMemberships: 10,
  adminDeleteEnabled: true,
  membersCount: 10,
} as unknown as Organization;

export const CLERK_ORGANIZATION_1_MEMBERSHIP_1 = {
  id: 'clerk_membership_1',
  role: 'org:admin',
  publicMetadata: {},
  privateMetadata: {},
  createdAt: 1_000_000,
  updatedAt: 1_000_000,
  organization: CLERK_ORGANIZATION_1,
  publicUserData: {
    identifier: 'clerk_user_1',
    firstName: 'firstName',
    lastName: 'lastName',
    imageUrl: 'https://example.com',
    hasImage: true,
    userId: 'clerk_user_1',
  },
} as unknown as OrganizationMembership;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  const
- export  const
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/testing/src/ee/ee.organization.service.ts
Tamaño: 1349 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CommunityOrganizationRepository, OrganizationRepository } from '@novu/dal';
import { ApiServiceLevelEnum } from '@novu/shared';
import { getEERepository } from './ee.repository.factory';

export class EEOrganizationService {
  private organizationRepository = getEERepository<OrganizationRepository>('OrganizationRepository');
  private communityOrganizationRepository = new CommunityOrganizationRepository();

  async createOrganization(orgId: string) {
    //  if internal organization exists delete so we can re-create with same Clerk org id
    const org = await this.communityOrganizationRepository.findOne({ externalId: orgId });

    if (org) {
      await this.communityOrganizationRepository.delete({ _id: org._id });
    }

    const syncExternalOrg = {
      externalId: orgId,
    };

    /**
     * Links Clerk organization with internal organization collection
     * (!) this is without org creation side-effects
     */
    return this.organizationRepository.create(syncExternalOrg);
  }

  async getOrganization(organizationId: string) {
    return await this.organizationRepository.findById(organizationId);
  }

  async updateServiceLevel(organizationId: string, serviceLevel: ApiServiceLevelEnum) {
    await this.communityOrganizationRepository.update({ _id: organizationId }, { apiServiceLevel: serviceLevel });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class EEOrganizationService

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/testing/src/ee/ee.repository.factory.ts
Tamaño: 2063 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CommunityMemberRepository, CommunityOrganizationRepository, CommunityUserRepository } from '@novu/dal';
import { isClerkEnabled } from '@novu/shared';
import { ClerkClientMock } from './clerk-client.mock';

/**
 * We are using nx-ignore-next-line as a workaround here to avoid following circular dependency error:
 * @novu/application-generic:build --> @novu/testing:build --> @novu/ee-auth:build --> @novu/application-generic:build
 *
 * When revising EE testing, we should consider refactoring the code to potentially avoid this circular dependency.
 *
 */
export function getEERepository<T>(className: 'OrganizationRepository' | 'MemberRepository' | 'UserRepository'): T {
  if (isClerkEnabled()) {
    switch (className) {
      case 'OrganizationRepository':
        return getEEOrganizationRepository();
      case 'MemberRepository':
        return getEEMemberRepository();
      case 'UserRepository':
        return getEEUserRepository();
      default:
        throw new Error('Invalid repository name');
    }
  }

  switch (className) {
    case 'OrganizationRepository':
      return new CommunityOrganizationRepository() as T;
    case 'MemberRepository':
      return new CommunityMemberRepository() as T;
    case 'UserRepository':
      return new CommunityUserRepository() as T;
    default:
      throw new Error('Invalid repository name');
  }
}

const clerkClientMock = new ClerkClientMock();

function getEEUserRepository() {
  // nx-ignore-next-line
  const { EEUserRepository } = require('@novu/ee-auth');

  return new EEUserRepository(new CommunityUserRepository(), clerkClientMock);
}

function getEEOrganizationRepository() {
  // nx-ignore-next-line
  const { EEOrganizationRepository } = require('@novu/ee-auth');

  return new EEOrganizationRepository(new CommunityOrganizationRepository(), clerkClientMock);
}

function getEEMemberRepository() {
  // nx-ignore-next-line
  const { EEMemberRepository } = require('@novu/ee-auth');

  return new EEMemberRepository(new CommunityOrganizationRepository(), clerkClientMock);
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getEEUserRepository()
 - getEEOrganizationRepository()
 - getEEMemberRepository()
Declaraciones 'export' encontradas:
- export function getEERepository

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/testing/src/ee/ee.user.service.ts
Tamaño: 671 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserEntity, UserRepository } from '@novu/dal';

import { getEERepository } from './ee.repository.factory';

export class EEUserService {
  private userRepository = getEERepository<UserRepository>('UserRepository');

  async createUser(userId: string): Promise<UserEntity> {
    // link external user to newly created internal user
    const user = await this.userRepository.create({}, { linkOnly: true, externalId: userId });

    return user;
  }

  async getUser(id: string): Promise<UserEntity> {
    const user = await this.userRepository.findById(id);

    if (!user) {
      throw new Error(`Test user with ${id} not found`);
    }

    return user;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class EEUserService

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/testing/src/ee/types.ts
Tamaño: 240 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { JwtPayload } from '@clerk/types';

export type ClerkJwtPayload = JwtPayload & {
  _id: string;
  email: string;
  lastName: string;
  firstName: string;
  profilePicture: string;
  externalId?: string;
  externalOrgId?: string;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/testing/src/utils/index.ts
Tamaño: 54 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './processTestAgentExpectedStatusCode';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/testing/src/utils/processTestAgentExpectedStatusCode.ts
Tamaño: 834 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/**
 * Source: https://github.com/ladjs/supertest/issues/12#issuecomment-1081640817
 *
 * Usage: wait session.testAgent.put('/v1/your/route').send(payload).expect(processResult(200));
 */
export function processTestAgentExpectedStatusCode(statusCode: number) {
  const stackTrace = new Error().stack?.split('\n') ?? [];
  stackTrace.splice(1, 1);

  return (err, res: Response) => {
    if ((res?.status || err.status) !== statusCode) {
      const e = new Error(
        `Expected ${statusCode}, got ${res?.status || err.status} resp: ${
          res?.headers ? JSON.stringify(res.headers) : JSON.stringify(err, null, 2)
        }`
      );

      e.stack = e.stack
        ?.split('\n')
        .splice(0, 1)
        .concat(stackTrace) // Remove this line not to show stack trace
        .join('\n');

      throw e;
    }
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - processTestAgentExpectedStatusCode(statusCode: number)
Asignaciones con arrow functions encontradas (posibles funciones):
 - stackTrace(new Error().stack?.split('\n') ?? [];
  stackTrace.splice(1, 1);

  return (err, res: Response))
Declaraciones 'export' encontradas:
- export function processTestAgentExpectedStatusCode

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/add-inbox/.gitignore
Tamaño: 420 bytes
Lenguaje detectado: GITIGNORE

### CONTENIDO ORIGINAL ###

# Dependencies
node_modules/
/.pnp
.pnp.js

# Testing
/coverage

# Production
/build
/dist
/.next/
/out/

# Environment files
.env
.env.local
.env.development.local
.env.test.local
.env.production.local
.env*.local

# Debug logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# IDE and editor files
.idea/
.vscode/
*.swp
*.swo
.DS_Store

# TypeScript
*.tsbuildinfo
next-env.d.ts

# Cache
.cache/
.npm/


### ANALISIS AUTOMATICO (ESPAÑOL) ###

# Dependencies
node_modules/
/.pnp
.pnp.js
# Testing
# Production
# Environment files
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/add-inbox/README.md
Tamaño: 1729 bytes
Lenguaje detectado: Markdown

### CONTENIDO ORIGINAL ###

# Add Inbox

A CLI command to easily add Novu's notification inbox component to your React or Next.js project.

## Installation & Usage

You can use this tool without installing it by running:

```bash
npx add-inbox@latest
```

This will guide you through an interactive process to add the Novu Inbox component to your project.

## Features

- ✅ Interactive CLI prompts for selecting framework and TypeScript options
- ✅ Support for React and Next.js
- ✅ Support for Tailwind CSS styling
- ✅ Automatic dependency installation
- ✅ Component creation in your project's component directory
- ✅ Environment variable setup for Novu configuration
- ✅ Custom backend and socket URL configuration
- ✅ Region-based configuration (US/EU)

## Example Usage in Your App

```jsx
import NovuInbox from '@/components/ui/inbox/NovuInbox';

// Inside your component
return (
  <div>
    <header className="flex justify-between items-center">
      <h1>My App</h1>
      <NovuInbox />
    </header>
  </div>
);
```

## Configuration

Make sure to set up your Novu application ID:

For React:
```
NOVU_APP_ID=your_app_id_here
```

For Next.js:
```
NEXT_PUBLIC_NOVU_APP_ID=your_novu_app_id_here
```

## Custom Backend Configuration

When using custom backend and socket URLs, the generated component will include the appropriate props:

```jsx
<Inbox 
  applicationIdentifier={process.env.NEXT_PUBLIC_NOVU_APP_ID}
  subscriberId={subscriberId}
  backendUrl="https://api.my-novu-instance.com"
  socketUrl="wss://ws.my-novu-instance.com"
  // ... other props
/>
```

If no custom URLs are provided, the component will use Novu's default URLs or region-specific URLs (EU region uses `https://eu.api.novu.co` and `wss://eu.ws.novu.co`).


### ANALISIS AUTOMATICO (ESPAÑOL) ###

# Add Inbox
A CLI command to easily add Novu's notification inbox component to your React or Next.js project.
## Installation & Usage
## Features
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/add-inbox/package.json
Tamaño: 1262 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "name": "add-inbox",
  "version": "1.0.10",
  "description": "Add inbox notifications to your application with one command",
  "repository": {
    "type": "git",
    "url": "https://github.com/novu/novu.git"
  },
  "homepage": "https://novu.co",
  "bugs": {
    "url": "https://github.com/novu/novu/issues"
  },
  "license": "ISC",
  "author": "Novu",
  "type": "commonjs",
  "main": "index.js",
  "bin": {
    "add-inbox": "dist/src/cli/index.js"
  },
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "tsc",
    "start": "ts-node src/cli/index.ts",
    "prepublishOnly": "npm run build > /dev/null 2>&1"
  },
  "keywords": [
    "novu",
    "inbox",
    "notifications",
    "react",
    "nextjs",
    "cli"
  ],
  "dependencies": {
    "@segment/analytics-node": "^2.2.1",
    "chalk": "^4.1.2",
    "commander": "^11.1.0",
    "prompts": "^2.4.2",
    "uuid": "^9.0.0"
  },
  "engines": {
    "node": ">=14.0.0"
  },
  "files": [
    "dist",
    "package.json",
    "README.md",
    "LICENSE",
    "CHANGELOG.md"
  ],
  "preferGlobal": true,
  "devDependencies": {
    "@types/commander": "^2.12.5",
    "@types/prompts": "^2.4.9",
    "@types/uuid": "^9.0.0",
    "rimraf": "^5.0.10",
    "ts-node": "^10.9.1",
    "typescript": "^5.0.0"
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"name": "add-inbox",
"version": "1.0.10",
"description": "Add inbox notifications to your application with one command",
"repository": {
Menciona package.json.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/add-inbox/tsconfig.json
Tamaño: 443 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "outDir": "./dist",
    "rootDir": ".",
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "allowJs": true,
    "resolveJsonModule": true,
    "declaration": true,
    "sourceMap": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"compilerOptions": {
"target": "ES2020",
"module": "commonjs",
"moduleResolution": "node",
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/add-inbox/src/cli/index.ts
Tamaño: 21051 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

#!/usr/bin/env node

import { execSync } from 'node:child_process';
import { Command } from 'commander';
import prompts from 'prompts';
import { detectFramework, IFramework } from '../config/framework';
import { detectPackageManager } from '../config/package-manager';
import { FRAMEWORKS } from '../constants';
import { createComponentStructure } from '../generators/component';
import { setupEnvExampleNextJs, setupEnvExampleReact } from '../generators/env';
import { AnalyticsEventEnum, AnalyticsService } from '../utils/analytics';
import fileUtils from '../utils/file';
import logger from '../utils/logger';

interface IPackageManager {
  name: string;
  install: string;
}

interface IUserConfig {
  framework: IFramework;
  appId?: string;
  subscriberId?: string;
  region: string;
  backendUrl?: string;
  socketUrl?: string;
  packageManager: IPackageManager;
  overwriteComponents: boolean;
  updateEnvExample: boolean;
}

interface IPromptResponse {
  overwriteComponents?: boolean;
  updateEnvExample?: boolean;
}

interface IPackageJson {
  dependencies?: Record<string, string>;
  devDependencies?: Record<string, string>;
  name?: string;
}

async function promptUserConfiguration(): Promise<IUserConfig | null> {
  // Parse command line arguments
  const { appId, subscriberId, region, backendUrl, socketUrl } = parseCommandLineArgs();

  // Detect framework first
  const detectedFramework = detectFramework();

  // If no framework is detected or it's not React/Next.js, abort
  if (!detectedFramework) {
    logger.error('\n❌ No supported framework detected.');
    logger.warning('This tool only supports React and Next.js projects.');
    logger.gray('\nPlease ensure you are running this command in a React or Next.js project directory.');

    return null;
  }

  // Determine effective region and show warnings
  let effectiveRegion = region;
  if (backendUrl || socketUrl) {
    // When custom URLs are provided, region is not needed
    if (region !== 'us') {
      logger.warning('\n⚠️  Custom backend/socket URLs provided. Region parameter will be ignored.');
      logger.gray('   The custom URLs will take precedence over region-based configuration.');
    }
    effectiveRegion = 'us'; // Default to 'us' when custom URLs are provided
  }

  // Use detected framework directly without prompting
  const initialResponses: Partial<IUserConfig> = {
    framework: detectedFramework,
    appId,
    subscriberId,
    region: effectiveRegion,
    backendUrl,
    socketUrl,
  };

  // Detect package manager
  const packageManager = detectPackageManager();
  if (!packageManager) {
    logger.error('  ✗ Could not detect package manager. Please ensure you have a package.json file.');

    return null;
  }

  const additionalPrompts: prompts.PromptObject[] = [];
  const cwd = process.cwd();
  const srcDir = fileUtils.joinPaths(cwd, 'src');
  const appDir = fileUtils.joinPaths(cwd, 'app');

  // Determine the base directory for components
  let baseDir = cwd;
  if (fileUtils.exists(srcDir)) {
    baseDir = srcDir;
  } else if (fileUtils.exists(appDir)) {
    baseDir = appDir;
  }

  const inboxComponentPath = fileUtils.joinPaths(baseDir, 'components', 'ui', 'inbox');
  if (fileUtils.exists(inboxComponentPath)) {
    logger.warning('\n⚠️  The Novu Inbox component is already installed in your project.');
    logger.gray(`   Location: ${inboxComponentPath}`);
    logger.gray('   You can choose to overwrite the existing installation or cancel.\n');

    additionalPrompts.push({
      type: 'confirm',
      name: 'overwriteComponents',
      message: 'Would you like to overwrite the existing installation?',
      initial: false,
    });
  }

  const envExamplePath = fileUtils.joinPaths(process.cwd(), '.env.example');

  // Check if environment files exist and need updating
  if (fileUtils.exists(envExamplePath)) {
    const envExampleContent = fileUtils.readFile(envExamplePath);
    const envVarName =
      initialResponses.framework?.framework === FRAMEWORKS.NEXTJS ? 'NEXT_PUBLIC_NOVU_APP_ID' : 'VITE_NOVU_APP_ID';

    if (envExampleContent && !envExampleContent.includes(envVarName)) {
      additionalPrompts.push({
        type: 'confirm',
        name: 'updateEnvExample',
        message: '.env.example already exists. Append Novu variables?',
        initial: true,
      });
    } else {
      logger.blue('  i Novu variables seem to already exist in .env.example. Skipping prompt to update.');
      initialResponses.updateEnvExample = false;
    }
  }

  let additionalResponses: IPromptResponse = {};
  if (additionalPrompts.length > 0) {
    try {
      additionalResponses = await prompts(additionalPrompts);
      // If user cancels additional prompts
      if (Object.keys(additionalResponses).length === 0) {
        logger.yellow('\nInstallation cancelled by user.');

        return null;
      }

      // If user chose not to overwrite, exit immediately
      if (additionalResponses.overwriteComponents === false) {
        logger.yellow('\nInstallation cancelled. No changes were made.');

        return null;
      }
    } catch (_error) {
      logger.yellow('\nInstallation cancelled by user.');

      return null;
    }
  }

  return {
    ...initialResponses,
    ...additionalResponses,
    packageManager,
    // Set defaults if prompts were skipped or cancelled
    overwriteComponents:
      additionalResponses.overwriteComponents !== undefined ? additionalResponses.overwriteComponents : false,
    updateEnvExample:
      additionalResponses.updateEnvExample !== undefined
        ? additionalResponses.updateEnvExample
        : !fileUtils.exists(envExamplePath), // Default to true if file doesn't exist
  } as IUserConfig;
}

async function installDependencies(framework: IFramework, packageManager: IPackageManager): Promise<void> {
  logger.gray('• Installing required packages...');

  const packagesToInstall: string[] = [];

  // Always install latest version of Novu packages
  if (framework.framework === FRAMEWORKS.NEXTJS) {
    packagesToInstall.push('@novu/nextjs@latest');
  } else {
    packagesToInstall.push('@novu/react@latest');
  }

  if (packagesToInstall.length > 0) {
    try {
      // Create a backup of package.json before installation
      const packageJsonPath = fileUtils.joinPaths(process.cwd(), 'package.json');
      const backupPath = fileUtils.joinPaths(process.cwd(), 'package.json.backup');
      fileUtils.copyFile(packageJsonPath, backupPath);

      const command = `${packageManager.name} ${packageManager.install} ${packagesToInstall.join(' ')}`;
      logger.gray(`  $ ${command}`);

      // Execute the installation command
      execSync(command, {
        stdio: 'inherit',
        env: {
          ...process.env,
          // Add timeout to prevent hanging
          NPM_CONFIG_FETCH_TIMEOUT: '300000', // 5 minutes
          NPM_CONFIG_FETCH_RETRIES: '3',
        },
      });

      // Enhanced verification of package installation
      const packageJson = (await fileUtils.readJson(packageJsonPath)) as IPackageJson;
      const dependencies = {
        ...packageJson.dependencies,
        ...packageJson.devDependencies,
      };

      const missingPackages: string[] = [];
      const versionMismatches: string[] = [];

      for (const pkg of packagesToInstall) {
        // Correctly extract package name and version for scoped packages
        const atIndex = pkg.lastIndexOf('@');
        const pkgName = atIndex > 0 ? pkg.slice(0, atIndex) : pkg;
        const requestedVersion = atIndex > 0 ? pkg.slice(atIndex + 1) : undefined;

        // Check if package exists in package.json
        if (!dependencies[pkgName]) {
          missingPackages.push(pkgName);
          continue;
        }

        // For latest version, we just verify it exists
        if (requestedVersion === 'latest') {
          continue;
        }

        // For specific versions, verify version matches
        const installedVersion = dependencies[pkgName].replace(/^[\^~]/, '');
        if (installedVersion !== requestedVersion) {
          versionMismatches.push(`${pkgName} (requested: ${requestedVersion}, installed: ${installedVersion})`);
        }
      }

      if (missingPackages.length > 0 || versionMismatches.length > 0) {
        let errorMessage = 'Package installation verification failed:\n';
        if (missingPackages.length > 0) {
          errorMessage += `- Missing packages: ${missingPackages.join(', ')}\n`;
        }
        if (versionMismatches.length > 0) {
          errorMessage += `- Version mismatches: ${versionMismatches.join(', ')}`;
        }
        throw new Error(errorMessage);
      }

      // Verify package files exist in node_modules
      const nodeModulesPath = fileUtils.joinPaths(process.cwd(), 'node_modules');
      const missingFiles = packagesToInstall.filter((pkg) => {
        const atIndex = pkg.lastIndexOf('@');
        const pkgName = atIndex > 0 ? pkg.slice(0, atIndex) : pkg;
        const pkgPath = fileUtils.joinPaths(nodeModulesPath, pkgName);
        const pkgJsonPath = fileUtils.joinPaths(pkgPath, 'package.json');

        return !fileUtils.exists(pkgPath) || !fileUtils.exists(pkgJsonPath);
      });

      if (missingFiles.length > 0) {
        throw new Error(`Package files missing in node_modules: ${missingFiles.join(', ')}`);
      }

      logger.success('  ✓ Dependencies installed successfully');

      // Clean up backup if successful
      fileUtils.deleteFile(backupPath);
    } catch (error) {
      // Restore package.json from backup if it exists
      const backupPath = fileUtils.joinPaths(process.cwd(), 'package.json.backup');
      if (fileUtils.exists(backupPath)) {
        fileUtils.copyFile(backupPath, fileUtils.joinPaths(process.cwd(), 'package.json'));
        fileUtils.deleteFile(backupPath);
      }

      throw new Error(`Failed to install dependencies: ${error instanceof Error ? error.message : String(error)}`);
    }
  } else {
    logger.success('  ✓ All required dependencies are already installed');
  }
}

function displayNextSteps() {
  const componentImportPath = './components/ui/inbox/NovuInbox';

  logger.info(logger.blue('\n Next Steps'));
  logger.divider();

  logger.info(logger.blue('1. The Novu Inbox component has been created at:'));
  logger.info(logger.cyan(`   src/${componentImportPath}.tsx\n`));

  logger.info(logger.blue('2. Import the Inbox component in your app:'));
  logger.info(logger.cyan(`   import NovuInbox from '${componentImportPath}';\n`));

  logger.info(logger.blue('3. Use the component in your app:'));
  logger.info(logger.cyan('   <NovuInbox />\n'));

  logger.info(logger.blue('4. Get your Novu credentials:'));
  logger.gray('   • Visit https://web.novu.co to create an account and application.');
  logger.gray('   • Find your Application Identifier in the Novu dashboard.\n');

  logger.info(logger.blue('5. Customize your Inbox & learn more:'));
  logger.gray(`   • Styling:     ${logger.cyan('https://docs.novu.co/platform/inbox/configuration/styling')}`);
  logger.gray(`   • Hooks:       ${logger.cyan('https://docs.novu.co/platform/sdks/react/hooks/novu-provider')}`);
  logger.gray(`   • Localization:${logger.cyan('https://docs.novu.co/platform/inbox/advanced-concepts/localization')}`);
  logger.gray(`   • Production:  ${logger.cyan('https://docs.novu.co/platform/inbox/prepare-for-production\n')}`);

  logger.success("🎉 You're all set! Happy coding with Novu! 🎉\n");
}

// Add new utility functions at the top level
function validateAppId(appId: string | undefined): boolean {
  if (appId === undefined || appId === null) return true; // Optional
  if (typeof appId !== 'string' || appId.trim().length === 0) {
    logger.error('Invalid appId provided. It must be a non-empty string.');

    return false;
  }

  return true;
}

function validateSubscriberId(subscriberId: string | undefined): boolean {
  if (subscriberId === undefined || subscriberId === null) return true; // Optional
  if (typeof subscriberId !== 'string' || subscriberId.trim().length === 0) {
    logger.error('Invalid subscriberId provided. It must be a non-empty string.');

    return false;
  }

  return true;
}

function validateRegion(region: string): boolean {
  if (region !== 'eu' && region !== 'us') {
    logger.error('Invalid region provided. It must be either "eu" or "us".');

    return false;
  }

  return true;
}

function validateBackendUrl(backendUrl: string | undefined): boolean {
  if (backendUrl === undefined || backendUrl === null) return true; // Optional
  if (typeof backendUrl !== 'string' || backendUrl.trim().length === 0) {
    logger.error('Invalid backendUrl provided. It must be a non-empty string.');

    return false;
  }

  // URL validation with HTTP/HTTPS protocol enforcement
  try {
    const url = new URL(backendUrl);
    if (url.protocol !== 'http:' && url.protocol !== 'https:') {
      logger.error('Invalid backendUrl provided. Backend URL must use HTTP or HTTPS protocol.');

      return false;
    }
  } catch {
    logger.error('Invalid backendUrl provided. It must be a valid URL.');

    return false;
  }

  return true;
}

function validateSocketUrl(socketUrl: string | undefined): boolean {
  if (socketUrl === undefined || socketUrl === null) return true; // Optional
  if (typeof socketUrl !== 'string' || socketUrl.trim().length === 0) {
    logger.error('Invalid socketUrl provided. It must be a non-empty string.');

    return false;
  }

  // URL validation with WebSocket protocol enforcement
  try {
    const url = new URL(socketUrl);
    if (url.protocol !== 'ws:' && url.protocol !== 'wss:') {
      logger.error('Invalid socketUrl provided. WebSocket URL must use WS or WSS protocol.');

      return false;
    }
  } catch {
    logger.error('Invalid socketUrl provided. It must be a valid URL.');

    return false;
  }

  return true;
}

function parseCommandLineArgs() {
  const program = new Command();
  program
    .option('--appId <id>', 'Novu Application Identifier')
    .option('--subscriberId <id>', 'Novu Subscriber Identifier')
    .option('--region <region>', 'Novu Region (eu or us). Optional when using custom URLs.', 'us')
    .option('--backendUrl <url>', 'Custom backend URL for Novu API')
    .option('--socketUrl <url>', 'Custom socket URL for Novu WebSocket connection')
    .parse(process.argv);

  return {
    appId: program.opts().appId,
    subscriberId: program.opts().subscriberId,
    region: program.opts().region,
    backendUrl: program.opts().backendUrl,
    socketUrl: program.opts().socketUrl,
  };
}

function validateProjectStructure() {
  const packageJsonPath = fileUtils.joinPaths(process.cwd(), 'package.json');
  if (!fileUtils.exists(packageJsonPath)) {
    logger.error('\n❌ No project detected.');
    logger.warning('This tool must be run within a React or Next.js project directory.');
    logger.gray('\nPlease ensure you are in your project directory before running this command.');

    return false;
  }

  return true;
}

async function performInstallation(config: IUserConfig, analytics?: AnalyticsService) {
  const {
    framework,
    packageManager,
    overwriteComponents,
    updateEnvExample,
    appId,
    subscriberId,
    region,
    backendUrl,
    socketUrl,
  } = config;

  try {
    logger.step(1, 'Checking framework and package manager');
    logger.success(`  ✓ Detected framework: ${logger.bold(framework.framework)}`);
    logger.gray(`    Version: ${framework.version}`);
    logger.gray(`    Setup: ${framework.setup}`);
    logger.success(`  ✓ Detected package manager: ${logger.bold(packageManager.name)}`);
    logger.success(`  ✓ Region: ${logger.bold(region)}`);
    if (backendUrl) {
      logger.success(`  ✓ Custom backend URL: ${logger.bold(backendUrl)}`);
    }
    if (socketUrl) {
      logger.success(`  ✓ Custom socket URL: ${logger.bold(socketUrl)}`);
    }

    logger.step(2, 'Installing dependencies');
    await installDependencies(framework, packageManager);

    logger.step(3, 'Creating component structure');
    await createComponentStructure(
      framework,
      overwriteComponents,
      subscriberId || null,
      region as 'us' | 'eu' | undefined,
      backendUrl || null,
      socketUrl || null
    );

    if (updateEnvExample) {
      logger.step(4, 'Setting up environment variables');
      if (framework.framework === FRAMEWORKS.NEXTJS) {
        setupEnvExampleNextJs(updateEnvExample, appId || null);
      } else {
        setupEnvExampleReact(updateEnvExample, appId || null);
      }
    }

    logger.step(4, "What's next?");

    displayNextSteps();

    return true;
  } catch (error) {
    logger.error('\n❌ Installation failed:');
    logger.error(error instanceof Error ? error.message : String(error));
    logger.gray('\nPlease try again or contact support if the issue persists.');

    return false;
  }
}

function getAnalyticsContext(config?: IUserConfig) {
  if (!config) return {};

  return {
    framework: config.framework?.framework,
    frameworkVersion: config.framework?.version,
    packageManager: config.packageManager?.name,
    region: config.region,
    appId: config.appId,
    subscriberId: config.subscriberId,
  };
}

function trackCliError(
  analytics: AnalyticsService,
  error: unknown,
  config?: IUserConfig,
  context: Record<string, unknown> = {}
) {
  let errorMessage = '';
  let stack = '';

  if (error instanceof Error) {
    errorMessage = error.message;
    stack = error.stack || '';
  } else {
    errorMessage = String(error);
  }

  analytics.track({
    event: AnalyticsEventEnum.CLI_ERROR,
    data: {
      error: errorMessage,
      stack,
      ...getAnalyticsContext(config),
      ...context,
    },
  });
}

function trackCliCancelled(
  analytics: AnalyticsService,
  reason: string,
  config?: IUserConfig,
  context: Record<string, unknown> = {}
) {
  analytics.track({
    event: AnalyticsEventEnum.CLI_USER_CANCELLED,
    data: {
      reason,
      ...getAnalyticsContext(config),
      ...context,
    },
  });
}

function trackCliCompleted(analytics: AnalyticsService, config: IUserConfig, context: Record<string, unknown> = {}) {
  analytics.track({
    event: AnalyticsEventEnum.CLI_COMPLETED,
    data: {
      ...getAnalyticsContext(config),
      ...context,
    },
  });
}

async function init() {
  const { appId, subscriberId, region, backendUrl, socketUrl } = parseCommandLineArgs();
  const analytics = new AnalyticsService(subscriberId);
  let config: IUserConfig | null = null;
  let errorOrCancelled = false;

  try {
    logger.banner();
    analytics.track({ event: AnalyticsEventEnum.CLI_STARTED });

    // Parse and validate command line arguments
    const argsValid =
      validateAppId(appId) &&
      validateSubscriberId(subscriberId) &&
      validateRegion(region) &&
      validateBackendUrl(backendUrl) &&
      validateSocketUrl(socketUrl);
    if (!argsValid) {
      trackCliError(analytics, 'Invalid command line arguments', undefined, {
        step: 'validateArgs',
        appId,
        subscriberId,
        region,
        backendUrl,
        socketUrl,
      });
      errorOrCancelled = true;
      process.exit(1);
    }

    // Validate project structure
    const projectValid = validateProjectStructure();
    if (!projectValid) {
      trackCliError(analytics, 'Invalid project structure', undefined, { step: 'validateProjectStructure' });
      errorOrCancelled = true;
      process.exit(1);
    }

    // Get user configuration
    config = await promptUserConfiguration();
    if (!config) {
      // User cancellation
      trackCliCancelled(analytics, 'User cancelled during promptUserConfiguration', undefined);
      errorOrCancelled = true;

      return;
    }

    // Perform the installation
    const success = await performInstallation(config, analytics);
    if (!success) {
      trackCliError(analytics, 'Installation failed', config ?? undefined, {
        step: 'performInstallation',
      });
      errorOrCancelled = true;
      process.exit(1);
    }

    // Only track completed if not error/cancelled
    if (!errorOrCancelled) {
      trackCliCompleted(analytics, config);
    }
  } catch (error) {
    trackCliError(analytics, error, config ?? undefined, {
      step: 'init',
      appId,
      subscriberId,
      region,
      backendUrl,
      socketUrl,
    });
    logger.error('\n❌ An unexpected error occurred:');
    logger.error(error instanceof Error ? error.message : String(error));
    errorOrCancelled = true;
    process.exit(1);
  } finally {
    await analytics.flush();
  }
}

// --- Entry Point ---
if (typeof require !== 'undefined' && require.main === module) {
  init().catch((error) => {
    logger.error('\n❌ An unexpected error occurred:');
    logger.error(error);
    process.exit(1);
  });
}

export {
  init,
  parseCommandLineArgs,
  validateAppId,
  validateSubscriberId,
  validateProjectStructure,
  validateRegion,
  validateBackendUrl,
  validateSocketUrl,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - promptUserConfiguration()
 - installDependencies(framework: IFramework, packageManager: IPackageManager)
 - displayNextSteps()
 - validateAppId(appId: string | undefined)
 - validateSubscriberId(subscriberId: string | undefined)
 - validateRegion(region: string)
 - validateBackendUrl(backendUrl: string | undefined)
 - validateSocketUrl(socketUrl: string | undefined)
 - parseCommandLineArgs()
 - validateProjectStructure()
 - performInstallation(config: IUserConfig, analytics?: AnalyticsService)
 - getAnalyticsContext(config?: IUserConfig)
 - trackCliError(analytics: AnalyticsService,
  error: unknown,
  config?: IUserConfig,
  context: Record<string, unknown> = {})
 - trackCliCancelled(analytics: AnalyticsService,
  reason: string,
  config?: IUserConfig,
  context: Record<string, unknown> = {})
 - trackCliCompleted(analytics: AnalyticsService, config: IUserConfig, context: Record<string, unknown> = {})
 - init()
Asignaciones con arrow functions encontradas (posibles funciones):
 - missingFiles(packagesToInstall.filter((pkg))
Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/add-inbox/src/config/framework.ts
Tamaño: 3986 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import fs from 'fs';
import path from 'path';
import { FRAMEWORKS, FrameworkType } from '../constants';
import logger from '../utils/logger';

export interface IFramework {
  framework: FrameworkType;
  version: string;
  setup: string;
}

interface IPackageJson {
  dependencies?: Record<string, string>;
  devDependencies?: Record<string, string>;
}

/**
 * Configuration and Constants
 */
export const MIN_VERSIONS: Record<FrameworkType, number> = {
  [FRAMEWORKS.REACT]: 16,
  [FRAMEWORKS.NEXTJS]: 12,
};

export const FRAMEWORK_SETUPS: Record<FrameworkType, string> = {
  [FRAMEWORKS.NEXTJS]: 'App Router',
  [FRAMEWORKS.REACT]: 'Create React App',
};

/**
 * File System Operations
 */

/**
 * Reads and parses package.json
 * @returns {IPackageJson|null} The parsed package.json or null if not found/invalid
 */
function getPackageJson(): IPackageJson | null {
  try {
    const packageJsonPath = path.join(process.cwd(), 'package.json');
    if (!fs.existsSync(packageJsonPath)) {
      return null;
    }

    return JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
  } catch (error) {
    logger.warning('Failed to read package.json:', error instanceof Error ? error.message : String(error));

    return null;
  }
}

/**
 * Version Management
 */

/**
 * Extracts the version of a framework from package.json
 * @param {IPackageJson} packageJson - The parsed package.json
 * @param {string} framework - The framework to check
 * @returns {string|null} The framework version or null if not found
 */
function getFrameworkVersion(packageJson: IPackageJson, framework: string): string | null {
  const dependencies = {
    ...(packageJson.dependencies || {}),
    ...(packageJson.devDependencies || {}),
  };

  const version = dependencies?.[framework];
  if (!version) return null;

  // Remove any ^ or ~ from version
  return version.replace(/[\^~]/g, '');
}

/**
 * Validates if a framework version meets minimum requirements
 * @param {string} version - The version to validate
 * @param {FrameworkType} framework - The framework being validated
 * @returns {boolean} Whether the version is valid
 */
function validateFrameworkVersion(version: string | null, framework: FrameworkType): boolean {
  if (!version) return false;

  const versionParts = version.split('.');
  if (versionParts.length === 0) return false;

  const major = parseInt(versionParts[0], 10);
  if (Number.isNaN(major)) return false;

  return major >= MIN_VERSIONS[framework];
}

/**
 * Framework Detection
 */

/**
 * Detects the framework and its version from the project
 * @returns {IFramework|null} Framework information or null if not detected
 */
export function detectFramework(): IFramework | null {
  const packageJson = getPackageJson();
  if (!packageJson) {
    return null;
  }

  // Check for Next.js first
  const nextVersion = getFrameworkVersion(packageJson, 'next');
  if (nextVersion && validateFrameworkVersion(nextVersion, FRAMEWORKS.NEXTJS)) {
    return {
      framework: FRAMEWORKS.NEXTJS,
      version: nextVersion,
      setup: FRAMEWORK_SETUPS[FRAMEWORKS.NEXTJS],
    };
  }

  // Check for React
  const reactVersion = getFrameworkVersion(packageJson, 'react');
  if (reactVersion && validateFrameworkVersion(reactVersion, FRAMEWORKS.REACT)) {
    return {
      framework: FRAMEWORKS.REACT,
      version: reactVersion,
      setup: FRAMEWORK_SETUPS[FRAMEWORKS.REACT],
    };
  }

  // Additional checks for Next.js in case it's not in package.json
  try {
    const nextConfigPath = path.join(process.cwd(), 'next.config.js');
    if (fs.existsSync(nextConfigPath)) {
      return {
        framework: FRAMEWORKS.NEXTJS,
        version: 'latest', // We can't determine version without package.json
        setup: FRAMEWORK_SETUPS[FRAMEWORKS.NEXTJS],
      };
    }
  } catch (error) {
    logger.warning('Failed to check for next.config.js:', error instanceof Error ? error.message : String(error));
  }

  return null;
}

export { validateFrameworkVersion };


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getPackageJson()
 - getFrameworkVersion(packageJson: IPackageJson, framework: string)
 - validateFrameworkVersion(version: string | null, framework: FrameworkType)
 - detectFramework()
Declaraciones 'export' encontradas:
- export  interface
- export  const
- export  const
- export function detectFramework
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/add-inbox/src/config/package-manager.ts
Tamaño: 5073 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { execSync } from 'child_process';
import prompts from 'prompts';
import { PACKAGE_MANAGERS, PackageManagerType } from '../constants';
import fileUtils from '../utils/file';
import logger from '../utils/logger';

interface IPackageManager {
  name: PackageManagerType;
  install: string;
  init: string;
}

interface IPackageJson {
  packageManager?: string;
}

export function detectPackageManager(): IPackageManager {
  const cwd = process.cwd();

  // Check for lock files first
  if (fileUtils.exists(fileUtils.joinPaths(cwd, 'pnpm-lock.yaml'))) {
    return { name: PACKAGE_MANAGERS.PNPM, install: 'add', init: 'init' };
  }
  if (fileUtils.exists(fileUtils.joinPaths(cwd, 'yarn.lock'))) {
    return { name: PACKAGE_MANAGERS.YARN, install: 'add', init: 'init -y' };
  }
  if (fileUtils.exists(fileUtils.joinPaths(cwd, 'package-lock.json'))) {
    return { name: PACKAGE_MANAGERS.NPM, install: 'install', init: 'init -y' };
  }

  // If no lock file is found, check package.json for packageManager field
  try {
    const packageJsonPath = fileUtils.joinPaths(cwd, 'package.json');
    if (fileUtils.exists(packageJsonPath)) {
      let packageJson: IPackageJson | undefined;
      try {
        packageJson = fileUtils.readJson(packageJsonPath) as IPackageJson;
      } catch (readError) {
        logger.warning(
          `  • Failed to parse package.json: ${readError instanceof Error ? readError.message : String(readError)}`
        );

        return { name: PACKAGE_MANAGERS.NPM, install: 'install', init: 'init -y' };
      }
      if (packageJson && typeof packageJson.packageManager === 'string') {
        const split = packageJson.packageManager.split('@');
        if (split.length === 2) {
          const [name, version] = split;
          if (name && version && version.trim().length > 0) {
            if (name === PACKAGE_MANAGERS.NPM) {
              return { name: PACKAGE_MANAGERS.NPM, install: 'install', init: 'init -y' };
            } else if (name === PACKAGE_MANAGERS.YARN) {
              return { name: PACKAGE_MANAGERS.YARN, install: 'add', init: 'init -y' };
            } else if (name === PACKAGE_MANAGERS.PNPM) {
              return { name: PACKAGE_MANAGERS.PNPM, install: 'add', init: 'init' };
            }
          } else {
            logger.warning(
              `  • Invalid packageManager field in package.json: '${packageJson.packageManager}' (missing name or version)`
            );
          }
        } else {
          logger.warning(`  • Malformed packageManager field in package.json: '${packageJson.packageManager}'`);
        }
      }
    }
  } catch (error) {
    if (error instanceof SyntaxError) {
      logger.warning(`  • Syntax error in package.json: ${error.message}`);
    } else if (error instanceof Error) {
      logger.warning(`  • Error reading package.json: ${error.message}`);
    } else {
      logger.warning(`  • Unknown error reading package.json: ${String(error)}`);
    }
  }

  // If no package manager is detected, default to npm
  logger.warning('  • No package manager detected, defaulting to npm');

  return { name: PACKAGE_MANAGERS.NPM, install: 'install', init: 'init -y' };
}

export async function ensurePackageJson(packageManager: IPackageManager): Promise<boolean> {
  const packagePath = fileUtils.joinPaths(process.cwd(), 'package.json');
  if (!fileUtils.exists(packagePath)) {
    logger.warning('No package.json found.');
    const { confirm } = await prompts({
      type: 'confirm',
      name: 'confirm',
      message: `Initialize a new package.json using ${logger.cyan(`${packageManager.name} ${packageManager.init}`)}?`,
      initial: true,
    });

    if (confirm) {
      try {
        // Validate packageManager.name and packageManager.init
        const allowedNames = [PACKAGE_MANAGERS.NPM, PACKAGE_MANAGERS.YARN, PACKAGE_MANAGERS.PNPM];
        const allowedInits = ['init', 'init -y'];
        const isNameValid = allowedNames.includes(packageManager.name);
        const isInitValid = allowedInits.includes(packageManager.init);
        if (!isNameValid || !isInitValid) {
          logger.error(
            `  ✗ Unsafe or invalid package manager command: '${packageManager.name} ${packageManager.init}'`
          );
          logger.cyan('  Please initialize package.json manually and try again.');

          return false;
        }
        logger.gray(`  $ ${packageManager.name} ${packageManager.init}`);
        execSync(`${packageManager.name} ${packageManager.init}`, { stdio: 'inherit', timeout: 10000 });
        logger.success('  ✓ package.json initialized.');
      } catch (error) {
        logger.error('  ✗ Failed to initialize package.json:');
        logger.error(error instanceof Error ? error.message : String(error));
        logger.cyan('  Please initialize it manually and try again.');

        return false;
      }
    } else {
      logger.error('  Installation cannot proceed without a package.json.');

      return false;
    }
  }
  logger.success('  ✓ package.json is ready.');

  return true;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - detectPackageManager()
 - ensurePackageJson(packageManager: IPackageManager)
Declaraciones 'export' encontradas:
- export function detectPackageManager
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/add-inbox/src/constants/index.ts
Tamaño: 806 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export const FRAMEWORKS = {
  NEXTJS: 'nextjs',
  REACT: 'react',
} as const;

export type FrameworkType = (typeof FRAMEWORKS)[keyof typeof FRAMEWORKS];

export const PACKAGE_MANAGERS = {
  NPM: 'npm',
  YARN: 'yarn',
  PNPM: 'pnpm',
} as const;

export type PackageManagerType = (typeof PACKAGE_MANAGERS)[keyof typeof PACKAGE_MANAGERS];

export const ENV_VARIABLES = {
  NEXTJS: {
    APP_ID: 'NEXT_PUBLIC_NOVU_APP_ID',
  },
  REACT: {
    APP_ID: 'VITE_NOVU_APP_ID',
  },
} as const;

// segment analytics
export const ANALYTICS_ENABLED = process.env.ANALYTICS_ENABLED !== 'false';
export const SEGMENTS_WRITE_KEY = process.env.CLI_SEGMENT_WRITE_KEY || 'DkJoarwiEx8NAJ5lAkhaqe1v999ZevN9';

export default {
  FRAMEWORKS,
  PACKAGE_MANAGERS,
  ENV_VARIABLES,
  ANALYTICS_ENABLED,
  SEGMENTS_WRITE_KEY,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  type
- export  const
- export  const
- export  const
- export default

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/add-inbox/src/generators/component.ts
Tamaño: 2618 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IFramework } from '../config/framework';
import { FRAMEWORKS, FrameworkType } from '../constants';
import fileUtils from '../utils/file';
import logger from '../utils/logger';
import { generateNextJsComponent } from './frameworks/nextjs';
import { generateLegacyReactComponent, generateModernReactComponent } from './frameworks/react';
import { isModernReact } from './react-version';

export async function createComponentStructure(
  framework: IFramework,
  overwriteComponents: boolean,
  subscriberId: string | null | undefined,
  region: 'us' | 'eu' = 'us',
  backendUrl: string | null = null,
  socketUrl: string | null = null
): Promise<void> {
  logger.gray('• Creating component structure...');

  const cwd = process.cwd();
  const srcDir = fileUtils.joinPaths(cwd, 'src');
  const appDir = fileUtils.joinPaths(cwd, 'app');

  // Determine the base directory for components
  let baseDir = cwd;
  if (fileUtils.exists(srcDir)) {
    baseDir = srcDir;
  } else if (fileUtils.exists(appDir)) {
    baseDir = appDir;
  }

  const componentsDir = fileUtils.joinPaths(baseDir, 'components');
  const uiDir = fileUtils.joinPaths(componentsDir, 'ui');
  const inboxDir = fileUtils.joinPaths(uiDir, 'inbox');

  // Create directories if they don't exist
  fileUtils.createDirectory(componentsDir);
  fileUtils.createDirectory(uiDir);
  fileUtils.createDirectory(inboxDir);

  // Generate component code based on framework
  let componentCode: string;
  if (framework.framework === FRAMEWORKS.NEXTJS) {
    componentCode = generateNextJsComponent(subscriberId || null, region as 'us' | 'eu', backendUrl, socketUrl);
  } else if (isModernReact()) {
    componentCode = generateModernReactComponent(subscriberId || null, region, backendUrl, socketUrl);
  } else {
    componentCode = generateLegacyReactComponent(subscriberId || null, region, backendUrl, socketUrl);
  }

  // Write component file
  const componentPath = fileUtils.joinPaths(inboxDir, 'NovuInbox.tsx');

  const fileExists = fileUtils.exists(componentPath);
  if (fileExists && !overwriteComponents) {
    logger.warning(`Component already exists at ${componentPath}. Use --overwrite to replace it.`);

    return;
  }

  try {
    fileUtils.writeFile(componentPath, componentCode);
    logger.success('  ✓ Created Novu Inbox component');
    logger.gray(`    Location: ${componentPath}`);
  } catch (error: unknown) {
    if (error instanceof Error) {
      logger.error(`Failed to create component file: ${error.message}`);
    } else {
      logger.error('Failed to create component file: Unknown error');
    }
    throw error;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - createComponentStructure(framework: IFramework,
  overwriteComponents: boolean,
  subscriberId: string | null | undefined,
  region: 'us' | 'eu' = 'us',
  backendUrl: string | null = null,
  socketUrl: string | null = null)
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/add-inbox/src/generators/env.ts
Tamaño: 5708 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ENV_VARIABLES } from '../constants';
import fileUtils, { updateEnvVariable } from '../utils/file';
import logger from '../utils/logger';
import { getEnvironmentVariableName } from './react-version';

export function setupEnvExampleNextJs(updateExisting: boolean, appId: string | null = null): void {
  // Validate appId to prevent injection
  if (appId && (appId.includes('\n') || appId.includes('\r'))) {
    throw new Error('Invalid appId: cannot contain newline characters');
  }

  logger.gray('• Setting up environment configuration for Next.js...');
  const envExamplePath = fileUtils.joinPaths(process.cwd(), '.env.example');
  const envLocalPath = fileUtils.joinPaths(process.cwd(), '.env.local');

  // Validate appId: allow only alphanumeric and dashes
  const safeAppId = typeof appId === 'string' && /^[a-zA-Z0-9-]+$/.test(appId) ? appId : '';

  // For .env.example, always use empty value
  const envExampleContent = `\n# Novu configuration (added by Novu Inbox Installer)
${ENV_VARIABLES.NEXTJS.APP_ID}=
`;

  // For .env.local, use provided appId if available
  const envLocalContent = `\n# Novu configuration (added by Novu Inbox Installer)
${ENV_VARIABLES.NEXTJS.APP_ID}=${safeAppId}
`;

  // Handle .env.example
  if (fileUtils.exists(envExamplePath)) {
    const existingContent = fileUtils.readFile(envExamplePath);
    if (existingContent?.includes(ENV_VARIABLES.NEXTJS.APP_ID)) {
      logger.blue('  • Novu variables already detected in .env.example. No changes made.');
    } else if (updateExisting) {
      fileUtils.appendFile(envExamplePath, envExampleContent);
      logger.blue('  • Appended Novu configuration to existing .env.example');
    } else {
      logger.warning(
        '  • .env.example exists. Skipping modification as Novu variables were not found and appending was not confirmed.'
      );
      logger.cyan('    Please manually add Novu variables to your .env.example:');
      logger.cyan(`    ${ENV_VARIABLES.NEXTJS.APP_ID}=`);
    }
  } else {
    fileUtils.writeFile(envExamplePath, envExampleContent.trimStart());
    logger.blue('  • Created .env.example with Novu configuration');
  }

  // Handle .env.local
  if (fileUtils.exists(envLocalPath)) {
    const existingContent = fileUtils.readFile(envLocalPath);
    if (existingContent?.includes(ENV_VARIABLES.NEXTJS.APP_ID)) {
      // Update only the Novu variable, preserve other content
      const updatedContent = updateEnvVariable(existingContent, ENV_VARIABLES.NEXTJS.APP_ID, safeAppId);
      fileUtils.writeFile(envLocalPath, updatedContent);
      logger.blue('  • Updated Novu configuration in .env.local');
    } else {
      fileUtils.appendFile(envLocalPath, envLocalContent);
      logger.blue('  • Added Novu configuration to existing .env.local');
    }
  } else {
    fileUtils.writeFile(envLocalPath, envLocalContent.trimStart());
    logger.blue('  • Created .env.local with Novu configuration');
  }

  logger.gray('    Remember to fill in your Novu credentials in .env.local.');
  logger.gray('    Ensure .env.local is in your .gitignore file.');
}

export function setupEnvExampleReact(updateExisting: boolean, appId: string | null = null): void {
  logger.gray('• Setting up environment configuration for React...');
  const envPath = fileUtils.joinPaths(process.cwd(), '.env.example');
  const envLocalPath = fileUtils.joinPaths(process.cwd(), '.env');

  // Get the appropriate environment variable name based on React version
  const envVarName = getEnvironmentVariableName();

  // Validate appId: allow only alphanumeric and dashes
  const safeAppId = typeof appId === 'string' && /^[a-zA-Z0-9-]+$/.test(appId) ? appId : '';

  // For .env.example, always use empty value
  const envExampleContent = `\n# Novu configuration (added by Novu Inbox Installer)
${envVarName}=
`;

  // For .env, use provided appId if available
  const envContent = `\n# Novu configuration (added by Novu Inbox Installer)
${envVarName}=${safeAppId}
`;

  if (fileUtils.exists(envPath)) {
    const existingContent = fileUtils.readFile(envPath);
    if (existingContent?.includes(envVarName)) {
      logger.blue('  • Novu variables already detected in .env.example. No changes made.');
    } else if (updateExisting) {
      fileUtils.appendFile(envPath, envExampleContent);
      logger.blue('  • Appended Novu configuration to existing .env.example');
    } else {
      logger.warning(
        '  • .env.example exists. Skipping modification as Novu variables were not found and appending was not confirmed.'
      );
      logger.cyan('    Please manually add Novu variables to your .env.example:');
      logger.cyan(`    ${envVarName}=`);
    }
  } else {
    fileUtils.writeFile(envPath, envExampleContent.trimStart());
    logger.blue('  • Created .env.example with Novu configuration');
  }

  // Handle .env
  if (fileUtils.exists(envLocalPath)) {
    const existingContent = fileUtils.readFile(envLocalPath);
    if (existingContent?.includes(envVarName)) {
      // Update only the Novu variable, preserve other content
      const updatedContent = updateEnvVariable(existingContent, envVarName, safeAppId);
      fileUtils.writeFile(envLocalPath, updatedContent);
      logger.blue('  • Updated Novu configuration in .env');
    } else {
      fileUtils.appendFile(envLocalPath, envContent);
      logger.blue('  • Added Novu configuration to existing .env');
    }
  } else {
    fileUtils.writeFile(envLocalPath, envContent.trimStart());
    logger.blue('  • Created .env with Novu configuration');
  }

  logger.gray('    Remember to fill in your Novu credentials in .env.');
  logger.gray('    Ensure .env is in your .gitignore file.');
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - setupEnvExampleNextJs(updateExisting: boolean, appId: string | null = null)
 - setupEnvExampleReact(updateExisting: boolean, appId: string | null = null)
Declaraciones 'export' encontradas:
- export function setupEnvExampleNextJs
- export function setupEnvExampleReact

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/add-inbox/src/generators/react-version.ts
Tamaño: 2942 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import fs from 'fs';
import path from 'path';

/**
 * Utility functions for React version detection and compatibility checks
 */

/**
 * Gets the React version from the project's dependencies
 * @returns {string} The React version (e.g., '16.14.0', '17.0.2', '18.0.0')
 */
export function getReactVersion(): string {
  try {
    // First try to get React version from current project's package.json
    const projectPackageJsonPath = path.join(process.cwd(), 'package.json');
    if (fs.existsSync(projectPackageJsonPath)) {
      const projectPackageJson = JSON.parse(fs.readFileSync(projectPackageJsonPath, 'utf-8'));
      const reactVersion = projectPackageJson.dependencies?.react || projectPackageJson.devDependencies?.react;
      if (reactVersion) {
        return reactVersion.replace(/[^0-9.]/g, '');
      }
    }

    // Fallback to installed React package
    try {
      const reactPackageJsonPath = require.resolve('react/package.json', { paths: [process.cwd()] });
      const packageJson = JSON.parse(fs.readFileSync(reactPackageJsonPath, 'utf-8'));

      return packageJson.version;
    } catch {
      throw new Error('React package not found');
    }
  } catch (error) {
    console.warn('Could not detect React version, assuming 18.0.0');

    return '18.0.0';
  }
}

/**
 * Checks if the React version is modern (17 or higher)
 * @returns {boolean} True if React version is 17 or higher
 */
export function isModernReact(): boolean {
  const version = getReactVersion();
  if (!version || !/^\d+\.\d+\.\d+$/.test(version)) {
    return false;
  }
  const majorVersion = parseInt(version.split('.')[0], 10);

  return majorVersion >= 17;
}

/**
 * Checks if the React version is legacy (16.x)
 * @returns {boolean} True if React version is 16.x
 */
export function isLegacyReact(): boolean {
  const version = getReactVersion();
  if (!version || !/^\d+\.\d+\.\d+$/.test(version)) {
    return false;
  }
  const majorVersion = parseInt(version.split('.')[0], 10);

  return majorVersion === 16;
}

/**
 * Detects if the project is a Next.js project by checking dependencies
 * @returns {boolean} True if Next.js is a dependency
 */
export function isNextJsProject(): boolean {
  try {
    const projectPackageJsonPath = path.join(process.cwd(), 'package.json');
    if (fs.existsSync(projectPackageJsonPath)) {
      const projectPackageJson = JSON.parse(fs.readFileSync(projectPackageJsonPath, 'utf-8'));
      const dependencies = {
        ...projectPackageJson.dependencies,
        ...projectPackageJson.devDependencies,
      };

      return Boolean(dependencies.next);
    }
  } catch {
    // ignore
  }

  return false;
}

/**
 * Gets the appropriate environment variable name based on framework
 * @returns {string} The environment variable name to use
 */
export function getEnvironmentVariableName(): string {
  if (isNextJsProject()) {
    return 'NEXT_PUBLIC_NOVU_APP_ID';
  }

  return 'NOVU_APP_ID';
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getReactVersion()
 - isModernReact()
 - isLegacyReact()
 - isNextJsProject()
 - getEnvironmentVariableName()
Declaraciones 'export' encontradas:
- export function getReactVersion
- export function isModernReact
- export function isLegacyReact
- export function isNextJsProject
- export function getEnvironmentVariableName

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/add-inbox/src/generators/frameworks/index.ts
Tamaño: 102 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export { generateNextJsComponent } from './nextjs';
export { generateReactComponent } from './react';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/add-inbox/src/generators/frameworks/nextjs.ts
Tamaño: 4310 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

interface IFilterByTags {
  tags: string[];
}

interface IFilterByData {
  data: Record<string, unknown>;
}

interface IFilterByTagsAndData {
  tags: string[];
  data: Record<string, unknown>;
}

interface IRegionConfig {
  socketUrl: string;
  backendUrl: string;
}

interface IRegionConfigs {
  eu: IRegionConfig;
}

export function generateNextJsComponent(
  subscriberId: string | null = null,
  region: 'us' | 'eu' = 'us',
  backendUrl: string | null = null,
  socketUrl: string | null = null
): string {
  // Define common filter patterns
  const filterByTags = (tags: string[]): IFilterByTags => ({ tags });
  const filterByData = (data: Record<string, unknown>): IFilterByData => ({ data });
  const filterByTagsAndData = (tags: string[], data: Record<string, unknown>): IFilterByTagsAndData => ({ tags, data });

  // Define region-specific configuration
  const regionConfig: IRegionConfigs = {
    eu: {
      socketUrl: 'wss://eu.ws.novu.co',
      backendUrl: 'https://eu.api.novu.co',
    },
  };

  // Use custom URLs if provided, otherwise fall back to region-based URLs
  const finalBackendUrl = backendUrl || (region === 'eu' ? regionConfig.eu.backendUrl : null);
  const finalSocketUrl = socketUrl || (region === 'eu' ? regionConfig.eu.socketUrl : null);

  const escapeString = (str: string) =>
    str.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/`/g, '\\`').replace(/\$\{/g, '\\${');

  // Build URL props string
  let urlProps = '';
  if (finalBackendUrl || finalSocketUrl) {
    const props = [];
    if (finalBackendUrl) {
      props.push(`backendUrl="${escapeString(finalBackendUrl)}"`);
    }
    if (finalSocketUrl) {
      props.push(`socketUrl="${escapeString(finalSocketUrl)}"`);
    }
    urlProps = `\n    ${props.join(' ')}`;
  }

  const componentCode = `'use client';

// The Novu inbox component is a React component that allows you to display a notification inbox.
// Learn more: https://docs.novu.co/platform/inbox/overview

import { Inbox } from '@novu/nextjs';

// import { dark } from '@novu/nextjs/themes'; => To enable dark theme support, uncomment this line.

// Get the subscriber ID based on the auth provider
// const getSubscriberId = () => {};

export default function NovuInbox() {
  // Temporary subscriber ID - replace with your actual subscriber ID from your auth system
  const temporarySubscriberId = ${subscriberId ? `"${escapeString(subscriberId)}"` : '""'};

  const tabs = [
    // Basic tab with no filtering (shows all notifications)
    {
      label: 'All',
      filter: { tags: [] },
    },
    
    // Filter by tags - shows notifications from workflows tagged "promotions"
    {
      label: 'Promotions',
      filter: ${JSON.stringify(filterByTags(['promotions']))},
    },
    
    // Filter by multiple tags - shows notifications with either "security" OR "alert" tags
    {
      label: 'Security',
      filter: ${JSON.stringify(filterByTags(['security', 'alert']))},
    },
    
    // Filter by data attributes - shows notifications with priority="high" in payload
    {
      label: 'High Priority',
      filter: ${JSON.stringify(filterByData({ priority: 'high' }))},
    },
    
    // Combined filtering - shows notifications that:
    // 1. Come from workflows tagged "alert" AND
    // 2. Have priority="high" in their data payload
    {
      label: 'Critical Alerts',
      filter: ${JSON.stringify(filterByTagsAndData(['alert'], { priority: 'high' }))},
    },
  ];

  return <Inbox 
    applicationIdentifier={process.env.NEXT_PUBLIC_NOVU_APP_ID as string}
    subscriberId={temporarySubscriberId} 
    tabs={tabs}${urlProps}
    appearance={{
      // To enable dark theme support, uncomment the following line:
      // baseTheme: dark,
      variables: {
        // The \`variables\` object allows you to define global styling properties that can be reused throughout the inbox.
        // Learn more: https://docs.novu.co/platform/inbox/configuration/styling
      },
      elements: {
        // The \`elements\` object allows you to define styles for these components.
        // Learn more: https://docs.novu.co/platform/inbox/configuration/styling
      },
      icons: {
        // The \`icons\` object allows you to define custom icons for the inbox.
      },
    }} 
  />;
}`;

  return componentCode;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - generateNextJsComponent(subscriberId: string | null = null,
  region: 'us' | 'eu' = 'us',
  backendUrl: string | null = null,
  socketUrl: string | null = null)
 - NovuInbox()
Asignaciones con arrow functions encontradas (posibles funciones):
 - filterByTags(tags: string[]): IFilterByTags)
 - filterByData(data: Record<string, unknown>): IFilterByData)
 - filterByTagsAndData(tags: string[], data: Record<string, unknown>): IFilterByTagsAndData)
 - escapeString(str: string))
 - componentCode(`'use client';

// The Novu inbox component is a React component that allows you to display a notifi...)
 - getSubscriberId())
Declaraciones 'export' encontradas:
- export function generateNextJsComponent
- export default function NovuInbox

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/add-inbox/src/generators/frameworks/react.ts
Tamaño: 5124 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { getReactVersion } from '../react-version';

export function generateReactComponent(
  subscriberId: string | null = null,
  region: string = 'us',
  backendUrl: string | null = null,
  socketUrl: string | null = null
): string {
  const reactVersion = getReactVersion();
  const isModernReact = isReactVersionModern(reactVersion);

  return isModernReact
    ? generateModernReactComponent(subscriberId, region, backendUrl, socketUrl)
    : generateLegacyReactComponent(subscriberId, region, backendUrl, socketUrl);
}

function isReactVersionModern(version: string): boolean {
  try {
    // Remove any pre-release suffixes (e.g., "18.0.0-rc.0" -> "18.0.0")
    const cleanVersion = version.split('-')[0];
    const [majorStr, minorStr] = cleanVersion.split('.');
    const major = Number(majorStr);
    const minor = Number(minorStr);

    if (Number.isNaN(major) || Number.isNaN(minor)) {
      // If we can't parse the version, default to legacy React (not modern)
      return false;
    }

    if (major > 17) return true;
    if (major === 17 && minor >= 0) return true;

    return false;
  } catch (_error) {
    // If anything goes wrong, default to legacy React (not modern)
    return false;
  }
}

function generateSharedInboxCode(
  subscriberId: string | null,
  region: string = 'us',
  envAccessor: string,
  backendUrl: string | null = null,
  socketUrl: string | null = null
): string {
  // Use custom URLs if provided, otherwise fall back to region-based URLs
  const finalBackendUrl = backendUrl || (region === 'eu' ? 'https://eu.api.novu.co' : null);
  const finalSocketUrl = socketUrl || (region === 'eu' ? 'wss://eu.ws.novu.co' : null);

  const escapeString = (str: string) =>
    str.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/`/g, '\\`').replace(/\$\{/g, '\\${');

  // Build URL props string
  let urlProps = '';
  if (finalBackendUrl || finalSocketUrl) {
    const props = [];
    if (finalBackendUrl) {
      props.push(`backendUrl="${escapeString(finalBackendUrl)}"`);
    }
    if (finalSocketUrl) {
      props.push(`socketUrl="${escapeString(finalSocketUrl)}"`);
    }
    urlProps = `\n    ${props.join(' ')}`;
  }

  return `import { Inbox } from '@novu/react';

// import { dark } from '@novu/react/themes'; => To enable dark theme support, uncomment this line.

export function NovuInbox() {
 // ${subscriberId ? 'Using provided subscriber ID - replace with your actual subscriber ID from your auth system' : 'TODO: Replace with your actual subscriber ID from your auth system'}
 const temporarySubscriberId = ${subscriberId ? `"${escapeString(subscriberId)}"` : '""'};

  const tabs = [
    // Basic tab with no filtering (shows all notifications)
    {
      label: 'All',
      filter: { tags: [] },
    },
    
    // Filter by tags - shows notifications from workflows tagged "promotions"
    {
      label: 'Promotions',
      filter: { tags: ['promotions'] },
    },
    
    // Filter by multiple tags - shows notifications with either "security" OR "alert" tags
    {
      label: 'Security',
      filter: { tags: ['security', 'alert'] },
    },
    
    // Filter by data attributes - shows notifications with priority="high" in payload
    {
      label: 'High Priority',
      filter: {
        data: { priority: 'high' },
      },
    },
    
    // Combined filtering - shows notifications that:
    // 1. Come from workflows tagged "alert" AND
    // 2. Have priority="high" in their data payload
    {
      label: 'Critical Alerts',
      filter: { 
        tags: ['alert'],
        data: { priority: 'high' }
      },
    },
  ];

  return <Inbox 
    applicationIdentifier={${envAccessor}}
    subscriberId={temporarySubscriberId}${urlProps}
    tabs={tabs} appearance={{
      // To enable dark theme support, uncomment the following line:
      // baseTheme: dark,
      variables: {
        // The \`variables\` object allows you to define global styling properties that can be reused throughout the inbox.
        // Learn more: https://docs.novu.co/platform/inbox/configuration/styling
      },
      elements: {
        // The \`elements\` object allows you to define styles for these components.
        // Learn more: https://docs.novu.co/platform/inbox/configuration/styling
      },
      icons: {
        // The \`icons\` object allows you to define custom icons for the inbox.
      },
    }} 
  />;
}`;
}

export function generateModernReactComponent(
  subscriberId: string | null,
  region: string = 'us',
  backendUrl: string | null = null,
  socketUrl: string | null = null
): string {
  return generateSharedInboxCode(subscriberId, region, "import.meta.env.VITE_NOVU_APP_ID || ''", backendUrl, socketUrl);
}

export function generateLegacyReactComponent(
  subscriberId: string | null,
  region: string = 'us',
  backendUrl: string | null = null,
  socketUrl: string | null = null
): string {
  return `// Legacy React component (React 16.x)
// React import is required for JSX in React 16.x
import React from 'react';

${generateSharedInboxCode(subscriberId, region, "process.env.NOVU_APP_ID || ''", backendUrl, socketUrl)}`;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - generateReactComponent(subscriberId: string | null = null,
  region: string = 'us',
  backendUrl: string | null = null,
  socketUrl: string | null = null)
 - isReactVersionModern(version: string)
 - generateSharedInboxCode(subscriberId: string | null,
  region: string = 'us',
  envAccessor: string,
  backendUrl: string | null = null,
  socketUrl: string | null = null)
 - NovuInbox()
 - generateModernReactComponent(subscriberId: string | null,
  region: string = 'us',
  backendUrl: string | null = null,
  socketUrl: string | null = null)
 - generateLegacyReactComponent(subscriberId: string | null,
  region: string = 'us',
  backendUrl: string | null = null,
  socketUrl: string | null = null)
Asignaciones con arrow functions encontradas (posibles funciones):
 - escapeString(str: string))
 - urlProps(`\n    ${props.join(' ')}`;
  }

  return `import { Inbox } from '@novu/react';

// import { dark } ...)
Declaraciones 'export' encontradas:
- export function generateReactComponent
- export function NovuInbox
- export function generateModernReactComponent
- export function generateLegacyReactComponent

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/add-inbox/src/utils/analytics.ts
Tamaño: 2979 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import Analytics from '@segment/analytics-node';
import { v4 as uuidv4 } from 'uuid';
import { ANALYTICS_ENABLED, SEGMENTS_WRITE_KEY } from '../constants';

const ANALYTICS_SOURCE = '[CLI add-inbox]';

export enum AnalyticsEventEnum {
  CLI_STARTED = 'CLI add-inbox Started',
  CLI_USER_CANCELLED = 'CLI add-inbox User Cancelled',
  CLI_COMPLETED = 'CLI add-inbox Completed',
  CLI_ERROR = 'CLI add-inbox Error',
}

interface IAnalyticsIdentity {
  userId?: string;
  anonymousId?: string;
}

export class AnalyticsService {
  private _analytics?: Analytics;
  private _analyticsEnabled: boolean;
  private _anonymousId: string;

  constructor(subscriberId?: string) {
    this._analyticsEnabled = ANALYTICS_ENABLED;
    this._anonymousId = typeof subscriberId === 'string' && subscriberId ? subscriberId : uuidv4();

    if (this._analyticsEnabled && SEGMENTS_WRITE_KEY) {
      this._analytics = new Analytics({
        writeKey: SEGMENTS_WRITE_KEY,
      });
    }
  }

  track({
    event,
    data,
    identity,
  }: {
    event: AnalyticsEventEnum;
    data?: Record<string, unknown>;
    identity?: IAnalyticsIdentity;
  }) {
    if (!this.isAnalyticsEnabled()) {
      return;
    }

    try {
      const payload = {
        event: `${event} - ${ANALYTICS_SOURCE}`,
        anonymousId: identity?.anonymousId || this._anonymousId,
        userId: identity?.userId,
        properties: data || {},
      };

      this._analytics?.track(payload);
    } catch (error) {
      // Silently fail - we don't want analytics errors to affect the CLI
      console.error('Analytics error:', error);
    }
  }

  identify(user: {
    _id: string;
    email: string;
    firstName?: string;
    lastName?: string;
    profilePicture?: string;
    createdAt: string;
  }) {
    if (!this.isAnalyticsEnabled()) {
      return;
    }

    try {
      this._analytics?.identify({
        userId: user._id,
        traits: {
          email: user.email,
          name: `${user.firstName || ''} ${user.lastName || ''}`.trim(),
          firstName: user.firstName,
          lastName: user.lastName,
          avatar: user.profilePicture,
          createdAt: user.createdAt,
        },
      });
    } catch (error) {
      console.error('Analytics identify error:', error);
    }
  }

  alias({ previousId, userId }: { previousId: string; userId: string }) {
    if (!this.isAnalyticsEnabled()) {
      return;
    }

    try {
      this._analytics?.alias({
        previousId,
        userId,
      });
    } catch (error) {
      console.error('Analytics alias error:', error);
    }
  }

  async flush() {
    if (!this.isAnalyticsEnabled()) {
      return;
    }

    try {
      await this._analytics?.closeAndFlush();
    } catch (error) {
      // Silently fail - we don't want analytics errors to affect the CLI
      console.error('Analytics flush error:', error);
    }
  }

  private isAnalyticsEnabled() {
    return this._analyticsEnabled && !!SEGMENTS_WRITE_KEY;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  enum
- export class AnalyticsService

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/add-inbox/src/utils/file.ts
Tamaño: 6061 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import fs from 'fs';
import path from 'path';

interface IFileUtils {
  exists: (filePath: string) => boolean;
  readJson: <T = unknown>(filePath: string) => T | null;
  writeJson: <T = unknown>(filePath: string, data: T) => boolean;
  readFile: (filePath: string) => string | null;
  writeFile: (filePath: string, content: string) => boolean;
  appendFile: (filePath: string, content: string) => boolean;
  createDirectory: (dirPath: string) => boolean;
  removeDirectory: (dirPath: string) => boolean;
  joinPaths: (...paths: string[]) => string;
  copyFile: (sourcePath: string, targetPath: string) => boolean;
  deleteFile: (filePath: string) => boolean;
}

const fileUtils: IFileUtils = {
  exists: (filePath) => fs.existsSync(filePath),

  readJson: <T = unknown>(filePath: string): T | null => {
    if (!filePath || typeof filePath !== 'string') {
      throw new Error('Invalid file path provided');
    }

    // Prevent directory traversal attacks
    const resolvedPath = path.resolve(filePath);
    const basePath = process.cwd();
    if (!resolvedPath.startsWith(basePath)) {
      throw new Error('Access denied: Path outside working directory');
    }

    try {
      const content = fs.readFileSync(resolvedPath, 'utf-8');

      return JSON.parse(content) as T;
    } catch (error) {
      console.warn(`Failed to read JSON from ${resolvedPath}:`, error);

      return null;
    }
  },

  writeJson: <T = unknown>(filePath: string, data: T): boolean => {
    const resolvedPath = path.resolve(filePath);
    const basePath = process.cwd();
    if (!resolvedPath.startsWith(basePath)) {
      throw new Error('Access denied: Path outside working directory');
    }
    try {
      fs.writeFileSync(resolvedPath, JSON.stringify(data, null, 2));

      return true;
    } catch (error) {
      console.error(`Failed to write JSON to ${resolvedPath}:`, error);

      return false;
    }
  },

  readFile: (filePath) => {
    const resolvedPath = path.resolve(filePath);
    const basePath = process.cwd();
    if (!resolvedPath.startsWith(basePath)) {
      throw new Error('Access denied: Path outside working directory');
    }
    try {
      return fs.readFileSync(resolvedPath, 'utf-8');
    } catch (error) {
      return null;
    }
  },

  writeFile: (filePath, content) => {
    const resolvedPath = path.resolve(filePath);
    const basePath = process.cwd();
    if (!resolvedPath.startsWith(basePath)) {
      throw new Error('Access denied: Path outside working directory');
    }
    try {
      fs.writeFileSync(resolvedPath, content);

      return true;
    } catch (error) {
      console.error(`Failed to write file to ${resolvedPath}:`, error);

      return false;
    }
  },

  appendFile: (filePath, content) => {
    const resolvedPath = path.resolve(filePath);
    const basePath = process.cwd();
    if (!resolvedPath.startsWith(basePath)) {
      throw new Error('Access denied: Path outside working directory');
    }
    try {
      fs.appendFileSync(resolvedPath, content);

      return true;
    } catch (error) {
      console.error(`Failed to append to file ${resolvedPath}:`, error);

      return false;
    }
  },

  createDirectory: (dirPath) => {
    const resolvedPath = path.resolve(dirPath);
    const basePath = process.cwd();
    if (!resolvedPath.startsWith(basePath)) {
      throw new Error('Access denied: Path outside working directory');
    }
    try {
      fs.mkdirSync(resolvedPath, { recursive: true });

      return true;
    } catch (error) {
      console.error(`Failed to create directory ${resolvedPath}:`, error);

      return false;
    }
  },

  removeDirectory: (dirPath) => {
    const resolvedPath = path.resolve(dirPath);
    const basePath = process.cwd();
    if (!resolvedPath.startsWith(basePath)) {
      throw new Error('Access denied: Path outside working directory');
    }
    if (!fs.existsSync(resolvedPath)) {
      return false;
    }

    try {
      fs.rmSync(resolvedPath, { recursive: true, force: false });

      return true;
    } catch (error) {
      console.error(`Failed to remove directory ${resolvedPath}:`, error);

      return false;
    }
  },

  joinPaths: (...paths) => path.join(...paths),

  copyFile: (sourcePath, targetPath) => {
    const resolvedSource = path.resolve(sourcePath);
    const resolvedTarget = path.resolve(targetPath);
    const basePath = process.cwd();
    if (!resolvedSource.startsWith(basePath) || !resolvedTarget.startsWith(basePath)) {
      throw new Error('Access denied: Path outside working directory');
    }
    try {
      if (!fs.existsSync(resolvedSource)) {
        console.error(`Source file does not exist: ${resolvedSource}`);

        return false;
      }
      fs.copyFileSync(resolvedSource, resolvedTarget);

      return true;
    } catch (error) {
      console.error(`Failed to copy file from ${resolvedSource} to ${resolvedTarget}:`, error);

      return false;
    }
  },

  deleteFile: (filePath) => {
    const resolvedPath = path.resolve(filePath);
    const basePath = process.cwd();
    if (!resolvedPath.startsWith(basePath)) {
      throw new Error('Access denied: Path outside working directory');
    }
    try {
      if (fs.existsSync(resolvedPath)) {
        fs.unlinkSync(resolvedPath);

        return true;
      }

      return false;
    } catch (error) {
      console.error(`Failed to delete file ${resolvedPath}:`, error);

      return false;
    }
  },
};

/**
 * Updates or inserts an environment variable in the given file content.
 * If the variable exists, its value is replaced. If not, the variable is appended at the end.
 */
export function updateEnvVariable(content: string, variable: string, value: string): string {
  const regex = new RegExp(`^${variable}=.*$`, 'm');
  if (regex.test(content)) {
    return content.replace(regex, `${variable}=${value}`);
  }
  // Ensure file ends with a newline before appending
  const trimmed = content.endsWith('\n') ? content : `${content}\n`;

  return `${trimmed}${variable}=${value}\n`;
}

export default fileUtils;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - updateEnvVariable(content: string, variable: string, value: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - T(unknown>(filePath: string))
 - T(unknown>(filePath: string, data: T))
 - IFileUtils({
  exists: (filePath))
 - T(unknown>(filePath: string): T | null)
 - T(unknown>(filePath: string, data: T): boolean)
 - basePath(process.cwd();
    if (!resolvedPath.startsWith(basePath)) {
      throw new Error('Access denied: P...)
 - basePath(process.cwd();
    if (!resolvedPath.startsWith(basePath)) {
      throw new Error('Access denied: P...)
 - basePath(process.cwd();
    if (!resolvedPath.startsWith(basePath)) {
      throw new Error('Access denied: P...)
 - basePath(process.cwd();
    if (!resolvedPath.startsWith(basePath)) {
      throw new Error('Access denied: P...)
 - basePath(process.cwd();
    if (!resolvedPath.startsWith(basePath)) {
      throw new Error('Access denied: P...)
 - basePath(process.cwd();
    if (!resolvedPath.startsWith(basePath)) {
      throw new Error('Access denied: P...)
 - basePath(process.cwd();
    if (!resolvedSource.startsWith(basePath) || !resolvedTarget.startsWith(basePath))...)
Declaraciones 'export' encontradas:
- export function updateEnvVariable
- export default  fileUtils

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/add-inbox/src/utils/logger.ts
Tamaño: 2528 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import chalk from 'chalk';

interface ILogger {
  info: (message: string, ...args: unknown[]) => void;
  success: (message: string, ...args: unknown[]) => void;
  warning: (message: string, ...args: unknown[]) => void;
  error: (message: string, ...args: unknown[]) => void;
  gray: (message: string, ...args: unknown[]) => void;
  cyan: (message: string) => string;
  blue: (message: string) => string;
  yellow: (message: string) => string;
  bold: (message: string) => string;
  step: (number: number, title: string) => void;
  divider: () => void;
  banner: () => void;
}

const logger: ILogger = {
  info: (message, ...args) => console.log(chalk.blue(message), ...args),
  success: (message, ...args) => console.log(chalk.green(message), ...args),
  warning: (message, ...args) => console.log(chalk.yellow(message), ...args),
  error: (message, ...args) => console.error(chalk.red(message), ...args),
  gray: (message, ...args) => console.log(chalk.gray(message), ...args),
  cyan: (message) => chalk.cyan(message),
  blue: (message) => chalk.blue(message),
  yellow: (message) => chalk.yellow(message),
  bold: (message) => chalk.bold(message),

  step: (number, title) => {
    console.log(`\n${chalk.blue(`Step ${number}: ${title}`)}`);
  },

  divider: () => {
    console.log(chalk.gray('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n'));
  },

  banner: () => {
    console.log('\n');
    console.log('██╗███╗   ██╗██████╗  ██████╗ ██╗  ██╗');
    console.log('██║████╗  ██║██╔══██╗██╔═══██╗╚██╗██╔╝');
    console.log('██║██╔██╗ ██║██████╔╝██║   ██║ ╚███╔╝ ');
    console.log('██║██║╚██╗██║██╔══██╗██║   ██║ ██╔██╗ ');
    console.log('██║██║ ╚████║██████╔╝╚██████╔╝██╔╝ ██╗');
    console.log('╚═╝╚═╝  ╚═══╝╚═════╝  ╚═════╝ ╚═╝  ╚═╝');
    console.log(chalk.bold('by Novu\n'));
    console.log(chalk.gray('This installer will help you set up the Novu Inbox component in your project.\n'));
  },
};

export default logger;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - ILogger({
  info: (message, ...args))
Declaraciones 'export' encontradas:
- export default  logger

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/.gitignore
Tamaño: 117 bytes
Lenguaje detectado: GITIGNORE

### CONTENIDO ORIGINAL ###

# Distribution
dist
out
build
node_modules

# Logs
*.log*
logs

# Misc
.DS_Store

# Vitest
tsconfig.vitest-temp.json


### ANALISIS AUTOMATICO (ESPAÑOL) ###

# Distribution
dist
out
build
node_modules
# Logs
# Misc
# Vitest
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/framework/CHANGELOG.md
Tamaño: 11884 bytes
Lenguaje detectado: Markdown

### CONTENIDO ORIGINAL ###

## 2.6.6 (2025-02-25)

### 🚀 Features

- **api-service:** system limits & update pricing pages ([#7718](https://github.com/novuhq/novu/pull/7718))
- **root:** add no only github action ([#7692](https://github.com/novuhq/novu/pull/7692))

### 🩹 Fixes

- **root:** unhandled promise reject and undefined ff kind ([#7732](https://github.com/novuhq/novu/pull/7732))
- **api-service:** remove only on e2e ([#7691](https://github.com/novuhq/novu/pull/7691))

### ❤️ Thank You

- GalTidhar @tatarco
- George Djabarov @djabarovgeorge


## 2.6.5 (2025-02-07)

### 🚀 Features

- Update README.md ([bb63172dd](https://github.com/novuhq/novu/commit/bb63172dd))
- **readme:** Update README.md ([955cbeab0](https://github.com/novuhq/novu/commit/955cbeab0))
- **dashboard:** Digest liquid helper and popover handler ([#7439](https://github.com/novuhq/novu/pull/7439))
- quick start updates readme ([88b3b6628](https://github.com/novuhq/novu/commit/88b3b6628))
- **readme:** update readme ([e5ea61812](https://github.com/novuhq/novu/commit/e5ea61812))
- **api-service:** add internal sdk ([#7599](https://github.com/novuhq/novu/pull/7599))
- **dashboard:** step conditions editor ui ([#7502](https://github.com/novuhq/novu/pull/7502))
- **api:** add query parser ([#7267](https://github.com/novuhq/novu/pull/7267))
- **api:** Nv 5033 additional removal cycle found unneeded elements ([#7283](https://github.com/novuhq/novu/pull/7283))
- **api:** Nv 4966 e2e testing happy path - messages ([#7248](https://github.com/novuhq/novu/pull/7248))
- **dashboard:** Implement email step editor & mini preview ([#7129](https://github.com/novuhq/novu/pull/7129))
- **api:** converted bulk trigger to use SDK ([#7166](https://github.com/novuhq/novu/pull/7166))
- **application-generic:** add SUBSCRIBER_WIDGET_JWT_EXPIRATION_TIME env variable ([#7105](https://github.com/novuhq/novu/pull/7105))

### 🩹 Fixes

- **js:** Await read action in Inbox ([#7653](https://github.com/novuhq/novu/pull/7653))
- **api:** duplicated subscribers created due to race condition ([#7646](https://github.com/novuhq/novu/pull/7646))
- **api-service:** add missing environment variable ([#7553](https://github.com/novuhq/novu/pull/7553))
- **api:** Fix failing API e2e tests ([78c385ec7](https://github.com/novuhq/novu/commit/78c385ec7))
- **api-service:** E2E improvements ([#7461](https://github.com/novuhq/novu/pull/7461))
- **novu:** automatically create indexes on startup ([#7431](https://github.com/novuhq/novu/pull/7431))
- **api:** @novu/api -> @novu/api-service ([#7348](https://github.com/novuhq/novu/pull/7348))
- **framework:** Remove @novu/shared dependency temporarily ([#7337](https://github.com/novuhq/novu/pull/7337))

### ❤️ Thank You

- Aminul Islam @AminulBD
- Dima Grossman @scopsy
- GalTidhar @tatarco
- George Desipris @desiprisg
- George Djabarov @djabarovgeorge
- Lucky @L-U-C-K-Y
- Pawan Jain
- Paweł Tymczuk @LetItRock
- Sokratis Vidros @SokratisVidros


## 2.5.3 (2024-12-24)

### 🩹 Fixes

- **framework:** Remove @novu/shared dependency temporarily ([#7337](https://github.com/novuhq/novu/pull/7337))

### ❤️ Thank You

- GalTidhar @tatarco
- George Desipris @desiprisg
- George Djabarov @djabarovgeorge
- Pawan Jain
- Sokratis Vidros @SokratisVidros


## 2.5.2 (2024-11-26)

### 🚀 Features

- **dashboard:** Codemirror liquid filter support ([#7122](https://github.com/novuhq/novu/pull/7122))
- **root:** add support chat app ID to environment variables in d… ([#7120](https://github.com/novuhq/novu/pull/7120))
- **root:** Add base Dockerfile for GHCR with Node.js and dependencies ([#7100](https://github.com/novuhq/novu/pull/7100))

### 🩹 Fixes

- **api:** Migrate subscriber global preferences before workflow preferences ([#7118](https://github.com/novuhq/novu/pull/7118))
- **api, dal, framework:** fix the uneven and unused dependencies ([#7103](https://github.com/novuhq/novu/pull/7103))

### 🧱 Updated Dependencies

- Updated @novu/shared to 2.1.4

### ❤️  Thank You

- George Desipris @desiprisg
- Himanshu Garg @merrcury
- Richard Fontein @rifont

## 2.0.2 (2024-11-19)

### 🚀 Features

- **framework:** Expose `Workflow` resource type in public API ([#6983](https://github.com/novuhq/novu/pull/6983))
- **api:** Fix previous steps ([#6905](https://github.com/novuhq/novu/pull/6905))
- **api:** Billing alerts on usage emails ([#6883](https://github.com/novuhq/novu/pull/6883))
- **framework:** Support Next.js 15 with Turbopack dev server ([#6894](https://github.com/novuhq/novu/pull/6894))
- **api:** Add Error Handling 2XX issues ([#6884](https://github.com/novuhq/novu/pull/6884))
- **framework:** Add support for specifying mock results ([#6878](https://github.com/novuhq/novu/pull/6878))
- **framework:** CJS/ESM for framework ([#6707](https://github.com/novuhq/novu/pull/6707))
- **api:** Add preview endpoint ([#6648](https://github.com/novuhq/novu/pull/6648))
- **framework, web, application-generic:** Propagate Bridge server errors to Bridge client ([#6726](https://github.com/novuhq/novu/pull/6726))
- **framework, api, web, application-generic:** Add `name` and `description` to Framework workflow options ([#6708](https://github.com/novuhq/novu/pull/6708))
- **framework:** Add NestJS `serve` handler ([#6654](https://github.com/novuhq/novu/pull/6654))
- **framework:** Add `disableOutputSanitization` flag for channel step definitions ([#6521](https://github.com/novuhq/novu/pull/6521))
- **api:** create step-schemas module ([#6482](https://github.com/novuhq/novu/pull/6482))
- **shared, web, application-generic:** Create util for building preferences ([#6503](https://github.com/novuhq/novu/pull/6503))
- **framework:** Change framework capitalization: in_app -> inApp ([#6477](https://github.com/novuhq/novu/pull/6477))
- **framework:** cta support with target ([#6394](https://github.com/novuhq/novu/pull/6394))
- **framework:** Add `preferences` to `workflow` builder ([#6326](https://github.com/novuhq/novu/pull/6326))
- **framework,js:** expose the data property on the in-app step and notification object ([#6391](https://github.com/novuhq/novu/pull/6391))
- **novui, web, framework:** Step control autocomplete ([#6330](https://github.com/novuhq/novu/pull/6330))
- **api:** add usage of bridge provider options in send message usecases a… ([#6062](https://github.com/novuhq/novu/pull/6062))
- **framework:** Add new Inbox properties to `step.inApp` schema ([#6075](https://github.com/novuhq/novu/pull/6075))
- **framework, api, worker, application-generic, dal:** Support workflow tags in Framework ([#6195](https://github.com/novuhq/novu/pull/6195))
- **web,novui:** initial implementation of var autocomplete in controls ([#6097](https://github.com/novuhq/novu/pull/6097))
- **framework:** add sanitize html to step output ([#6082](https://github.com/novuhq/novu/pull/6082))
- **framework:** add lambda handler ([#6053](https://github.com/novuhq/novu/pull/6053))
- **framework:** add first five schemas for providers ([#6039](https://github.com/novuhq/novu/pull/6039))
- **framework:** add generic support for providers ([#6021](https://github.com/novuhq/novu/pull/6021))
- Enhance Vercel env handling and add test cases ([#5942](https://github.com/novuhq/novu/pull/5942))
- **framework:** Add trigger capability to defined workflows ([#5877](https://github.com/novuhq/novu/pull/5877))
- **web:** add controls to the preview ([#5884](https://github.com/novuhq/novu/pull/5884))
- **framework:** add trigger action ([#5839](https://github.com/novuhq/novu/pull/5839))
- **framework:** update novu framework headers ([#5837](https://github.com/novuhq/novu/pull/5837))
- **framework:** Set `strictAuthentication` to false when `process.env.NODE_ENV==='development'` ([#5813](https://github.com/novuhq/novu/pull/5813))
- **framework:** Add cron expression helper type ([#5811](https://github.com/novuhq/novu/pull/5811))
- **framework:** Add Zod support ([#5806](https://github.com/novuhq/novu/pull/5806))
- **framework:** add auto deterministic preview for required payload variables ([#5743](https://github.com/novuhq/novu/pull/5743))
- **framework,worker:** add digest parity ([#5765](https://github.com/novuhq/novu/pull/5765))
- **framework:** allow compiling for preview mode ([1e2403286](https://github.com/novuhq/novu/commit/1e2403286))

### 🩹 Fixes

- **framework:** Ensure missing schemas return unknown record type ([#6912](https://github.com/novuhq/novu/pull/6912))
- **framework:** Prevent adding duplicate workflows ([#6913](https://github.com/novuhq/novu/pull/6913))
- **framework:** Stop validating controls for non previewed step ([#6876](https://github.com/novuhq/novu/pull/6876))
- **framework:** Polish secretKey and apiUrl resolution ([#6819](https://github.com/novuhq/novu/pull/6819))
- **framework:** Explicitly exit workflow evaluation early after evaluating specified `stepId` ([#6808](https://github.com/novuhq/novu/pull/6808))
- **framework:** Resolve CJS issues this time with json-schema-faker ([#6766](https://github.com/novuhq/novu/pull/6766))
- **framework:** Experiement with importing json-schema-faker ([#6762](https://github.com/novuhq/novu/pull/6762))
- **framework:** Specify `zod-to-json-schema` as a dependency ([#6741](https://github.com/novuhq/novu/pull/6741))
- **framework:** Support json values in LiquidJS templates ([#6714](https://github.com/novuhq/novu/pull/6714))
- **framework:** Default to health action ([#6634](https://github.com/novuhq/novu/pull/6634))
- **root:** Build only public packages during preview deployments ([#6590](https://github.com/novuhq/novu/pull/6590))
- **framework,dal:** fix the default redirect behaviour, support absolute and relative paths ([#6443](https://github.com/novuhq/novu/pull/6443))
- **framework, node:** Make the `payload` property optional during trigger ([#6384](https://github.com/novuhq/novu/pull/6384))
- **framework:** Stop requiring default properties to be specified in outputs ([#6373](https://github.com/novuhq/novu/pull/6373))
- **framework:** Ensure steps after skipped steps are executed ([#6371](https://github.com/novuhq/novu/pull/6371))
- **framework:** add locale to subscriber ([#6165](https://github.com/novuhq/novu/pull/6165))
- **framework:** remove pnpm install enforcement ([#6215](https://github.com/novuhq/novu/pull/6215))
- **framework:** Remove only failing validation properties and simplify Slack schema ([#6160](https://github.com/novuhq/novu/pull/6160))
- **framework:** Make step channel output sanitization more permissive ([#6106](https://github.com/novuhq/novu/pull/6106))
- **framework:** twilio schema in framework ([#6065](https://github.com/novuhq/novu/pull/6065))
- **framework:** Add `OPTIONS` endpoint for Sveltekit, improve `serve` typedoc ([#5971](https://github.com/novuhq/novu/pull/5971))
- **framework:** Remove compile time secret key check ([#5932](https://github.com/novuhq/novu/pull/5932))
- **framework:** Add missing `peerDependencies` and fix dynamic imports ([#5883](https://github.com/novuhq/novu/pull/5883))
- **framework:** fetch bad request response ([#5881](https://github.com/novuhq/novu/pull/5881))
- add ability to specify api url ([c0ff212f4](https://github.com/novuhq/novu/commit/c0ff212f4))
- **framework:** add json parse ([#5853](https://github.com/novuhq/novu/pull/5853))
- update version of framework release ([7b2e41cd6](https://github.com/novuhq/novu/commit/7b2e41cd6))

### 🔥 Performance

- **framework:** Replace all computed property keys with static declarations ([#6926](https://github.com/novuhq/novu/pull/6926))

### ❤️  Thank You

- Biswajeet Das @BiswaViraj
- David Söderberg @davidsoderberg
- Denis Kralj @denis-kralj-novu
- Dima Grossman @scopsy
- Gali Ainouz Baum
- GalTidhar @tatarco
- George Djabarov @djabarovgeorge
- Joel Anton
- Lucky @L-U-C-K-Y
- Paweł Tymczuk @LetItRock
- Richard Fontein @rifont
- Sokratis Vidros @SokratisVidros

### ANALISIS AUTOMATICO (ESPAÑOL) ###

## 2.6.6 (2025-02-25)
### 🚀 Features
- **api-service:** system limits & update pricing pages ([#7718](https://github.com/novuhq/novu/pull/7718))
### 🩹 Fixes
### ❤️ Thank You
## 2.6.5 (2025-02-07)
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/framework/README.md
Tamaño: 2730 bytes
Lenguaje detectado: Markdown

### CONTENIDO ORIGINAL ###

<div align="center">
  <a href="https://novu.co?utm_source=github" target="_blank">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://user-images.githubusercontent.com/2233092/213641039-220ac15f-f367-4d13-9eaf-56e79433b8c1.png">
    <img alt="Novu Logo" src="https://user-images.githubusercontent.com/2233092/213641043-3bbb3f21-3c53-4e67-afe5-755aeb222159.png" width="280"/>
  </picture>
  </a>
</div>

# Code-First Notifications Workflow SDK

[![Version](https://img.shields.io/npm/v/@novu/framework.svg)](https://www.npmjs.org/package/@novu/framework)
[![Downloads](https://img.shields.io/npm/dm/@novu/framework.svg)](https://www.npmjs.com/package/@novu/framework)

Novu Framework allows you to write notification workflows in your codebase. Workflows are functions that execute business logic and use your preferred libraries for email, SMS, and chat generation. You can use Novu Framework with [React.Email](https://react.email/), [MJML](https://mjml.io/), or any other template generator.

Learn more about the Code-First Notifications Workflow SDK in our [docs](https://docs.novu.co/framework/quickstart).

## Installation

```bash
npm install @novu/framework
```

## Quickstart

```typescript
import { workflow, CronExpression } from '@novu/framework';
import { serve } from '@novu/framework/next';
import { z } from 'zod';

// Define your notification workflow
const weeklyComments = workflow(
  'comment-on-post',
  async ({ payload, step }) => {
    const inAppResponse = await step.inApp('new-comment', async () => ({
      body: `You have a new comment on your post ${payload.comment}`,
    }));

    const weeklyDigest = await step.digest('weekly-digest', () => ({
      cron: CronExpression.EVERY_WEEK,
    }));

    await step.email(
      'weekly-comments',
      async (controls) => ({
        subject: `${controls.prefix} - Weekly post comments (${weeklyDigest.events.length})`,
        body: `Weekly digest: ${weeklyDigest.events.map(({ payload }) => payload.comment).join(', ')}`,
      }),
      {
        // Skip the notification if the weekly digest is empty
        skip: () => weeklyDigest.events.length === 0,
        // Non-technical stakeholders can modify strongly-validated copy in Novu Cloud
        controlSchema: z.object({ prefix: z.string().describe('The prefix of the subject.').default('Hi!') }),
      }
    );
  },
  { payloadSchema: z.object({ comment: z.string().describe('The comment on the post.') }) }
);

// Use your favorite framework to serve your workflows
const { GET, POST, OPTIONS } = serve({ workflows: [weeklyComments] });

// Trigger your notification workflow
weeklyComments.trigger({ to: 'user:123', comment: 'This is a comment on a post' });
```


### ANALISIS AUTOMATICO (ESPAÑOL) ###

<div align="center">
<a href="https://novu.co?utm_source=github" target="_blank">
<picture>
<source media="(prefers-color-scheme: dark)" srcset="https://user-images.githubusercontent.com/2233092/213641039-220ac15f-f367-4d13-9eaf-56e79433b8c1.png">
<img alt="Novu Logo" src="https://user-images.githubusercontent.com/2233092/213641043-3bbb3f21-3c53-4e67-afe5-755aeb222159.png" width="280"/>
# Code-First Notifications Workflow SDK
## Installation
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/framework/package.json
Tamaño: 6216 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "name": "@novu/framework",
  "version": "2.7.0",
  "description": "The Code-First Notifications Workflow SDK.",
  "main": "./dist/cjs/index.cjs",
  "types": "./dist/cjs/index.d.cts",
  "module": "./dist/esm/index.js",
  "type": "module",
  "publishConfig": {
    "access": "public"
  },
  "private": false,
  "repository": {
    "type": "git",
    "url": "git+https://github.com/novuhq/novu.git"
  },
  "files": [
    "dist",
    "express",
    "h3",
    "internal",
    "lambda",
    "nest",
    "next",
    "nuxt",
    "remix",
    "sveltekit",
    "README.md"
  ],
  "scripts": {
    "test": "vitest --typecheck",
    "test:watch": "vitest --typecheck --watch",
    "check": "biome check .",
    "check:fix": "biome check --write .",
    "build": "NODE_ENV=production tsup",
    "debug": "NODE_ENV=production tsup --config tsup-debug.config.ts",
    "build:watch": "tsup --watch",
    "postbuild": "pnpm run check:exports && pnpm check:circulars",
    "check:exports": "attw --pack .",
    "check:circulars": "madge --circular --extensions ts ./src",
    "bump:prerelease": "npm version prerelease --preid=alpha & PID=$!; (sleep 1 && kill -9 $PID) & wait $PID",
    "release:alpha": "pnpm bump:prerelease || pnpm build && npm publish",
    "devtool": "tsx ./scripts/devtool.ts"
  },
  "keywords": [
    "novu",
    "code-first",
    "workflows",
    "durable",
    "sdk",
    "notifications",
    "email",
    "sms",
    "push",
    "webhooks",
    "next",
    "nuxt",
    "h3",
    "express"
  ],
  "author": "Novu Team <engineering@novu.co>",
  "license": "ISC",
  "exports": {
    ".": {
      "require": {
        "types": "./dist/cjs/index.d.cts",
        "default": "./dist/cjs/index.cjs"
      },
      "import": {
        "types": "./dist/esm/index.d.ts",
        "default": "./dist/esm/index.js"
      }
    },
    "./express": {
      "require": {
        "types": "./dist/cjs/servers/express.d.cts",
        "default": "./dist/cjs/servers/express.cjs"
      },
      "import": {
        "types": "./dist/esm/servers/express.d.ts",
        "default": "./dist/esm/servers/express.js"
      }
    },
    "./nest": {
      "require": {
        "types": "./dist/cjs/servers/nest.d.cts",
        "default": "./dist/cjs/servers/nest.cjs"
      },
      "import": {
        "types": "./dist/esm/servers/nest.d.ts",
        "default": "./dist/esm/servers/nest.js"
      }
    },
    "./next": {
      "require": {
        "types": "./dist/cjs/servers/next.d.cts",
        "default": "./dist/cjs/servers/next.cjs"
      },
      "import": {
        "types": "./dist/esm/servers/next.d.ts",
        "default": "./dist/esm/servers/next.js"
      }
    },
    "./nuxt": {
      "require": {
        "types": "./dist/cjs/servers/nuxt.d.cts",
        "default": "./dist/cjs/servers/nuxt.cjs"
      },
      "import": {
        "types": "./dist/esm/servers/nuxt.d.ts",
        "default": "./dist/esm/servers/nuxt.js"
      }
    },
    "./h3": {
      "require": {
        "types": "./dist/cjs/servers/h3.d.cts",
        "default": "./dist/cjs/servers/h3.cjs"
      },
      "import": {
        "types": "./dist/esm/servers/h3.d.ts",
        "default": "./dist/esm/servers/h3.js"
      }
    },
    "./lambda": {
      "require": {
        "types": "./dist/cjs/servers/lambda.d.cts",
        "default": "./dist/cjs/servers/lambda.cjs"
      },
      "import": {
        "types": "./dist/esm/servers/lambda.d.ts",
        "default": "./dist/esm/servers/lambda.js"
      }
    },
    "./sveltekit": {
      "require": {
        "types": "./dist/cjs/servers/sveltekit.d.cts",
        "default": "./dist/cjs/servers/sveltekit.cjs"
      },
      "import": {
        "types": "./dist/esm/servers/sveltekit.d.ts",
        "default": "./dist/esm/servers/sveltekit.js"
      }
    },
    "./remix": {
      "require": {
        "types": "./dist/cjs/servers/remix.d.cts",
        "default": "./dist/cjs/servers/remix.cjs"
      },
      "import": {
        "types": "./dist/esm/servers/remix.d.ts",
        "default": "./dist/esm/servers/remix.js"
      }
    },
    "./internal": {
      "require": {
        "types": "./dist/cjs/internal/index.d.cts",
        "default": "./dist/cjs/internal/index.cjs"
      },
      "import": {
        "types": "./dist/esm/internal/index.d.ts",
        "default": "./dist/esm/internal/index.js"
      }
    }
  },
  "peerDependencies": {
    "@nestjs/common": ">=10.0.0",
    "@sveltejs/kit": ">=1.27.3",
    "@vercel/node": ">=2.15.9",
    "aws-lambda": ">=1.0.7",
    "express": ">=4.19.2",
    "h3": ">=1.8.1",
    "next": ">=12.0.0",
    "zod": ">=3.0.0",
    "zod-to-json-schema": ">=3.0.0"
  },
  "peerDependenciesMeta": {
    "@nestjs/common": {
      "optional": true
    },
    "@sveltejs/kit": {
      "optional": true
    },
    "@vercel/node": {
      "optional": true
    },
    "express": {
      "optional": true
    },
    "fastify": {
      "optional": true
    },
    "h3": {
      "optional": true
    },
    "aws-lambda": {
      "optional": true
    },
    "next": {
      "optional": true
    },
    "zod": {
      "optional": true
    },
    "zod-to-json-schema": {
      "optional": true
    }
  },
  "devDependencies": {
    "@apidevtools/json-schema-ref-parser": "11.6.4",
    "@arethetypeswrong/cli": "^0.17.4",
    "@nestjs/common": "10.4.18",
    "@sveltejs/kit": "^1.27.3",
    "@types/aws-lambda": "^8.10.141",
    "@types/express": "^4.17.13",
    "@types/node": "^20.15.0",
    "@types/pluralize": "^0.0.33",
    "@types/sanitize-html": "2.11.0",
    "@vercel/node": "^2.15.9",
    "aws-lambda": "^1.0.7",
    "express": "^4.19.2",
    "h3": "^1.11.1",
    "madge": "^8.0.0",
    "next": "^13.5.4",
    "ts-node": "^10.9.2",
    "tsup": "^8.0.2",
    "tsx": "4.16.2",
    "typescript": "5.6.2",
    "vitest": "^1.2.1",
    "zod": "^3.23.8",
    "zod-to-json-schema": "^3.23.3"
  },
  "dependencies": {
    "ajv": "^8.12.0",
    "ajv-formats": "^2.1.1",
    "better-ajv-errors": "^1.2.0",
    "chalk": "^4.1.2",
    "cross-fetch": "^4.0.0",
    "json-schema-to-ts": "^3.0.0",
    "jsonrepair": "^3.13.1",
    "liquidjs": "^10.20.0",
    "pluralize": "^8.0.0",
    "sanitize-html": "^2.13.0"
  },
  "nx": {
    "tags": [
      "type:package"
    ]
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"name": "@novu/framework",
"version": "2.7.0",
"description": "The Code-First Notifications Workflow SDK.",
"main": "./dist/cjs/index.cjs",
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/framework/project.json
Tamaño: 261 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "name": "@novu/framework",
  "sourceRoot": "packages/framework/src",
  "projectType": "library",
  "targets": {
    "lint": {
      "executor": "nx:run-commands",
      "options": {
        "command": "npx biome lint packages/framework"
      }
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"name": "@novu/framework",
"sourceRoot": "packages/framework/src",
"projectType": "library",
"targets": {
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/framework/tsconfig.json
Tamaño: 547 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "compilerOptions": {
    "target": "ES2019",
    "module": "ES2020",
    "moduleResolution": "Bundler",
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "declaration": true,
    "declarationMap": true,
    "noImplicitAny": true,
    "sourceMap": true,
    "rootDir": ".",
    "outDir": "./dist",
    "experimentalDecorators": true,
    "allowJs": true,
    "strict": true
  },
  "include": ["./src/**/*", "scripts/devtool.ts"],
  "exclude": ["node_modules"]
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"compilerOptions": {
"target": "ES2019",
"module": "ES2020",
"moduleResolution": "Bundler",
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/framework/tsup-debug.config.ts
Tamaño: 472 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { defineConfig } from 'tsup';
import { cjsConfig, esmConfig } from './tsup.config';

export default defineConfig([
  {
    ...cjsConfig,
    sourcemap: true,
    minify: false,
    minifyWhitespace: false,
    minifyIdentifiers: false,
    minifySyntax: false,
    splitting: false,
  },
  {
    ...esmConfig,
    sourcemap: true,
    minify: false,
    minifyWhitespace: false,
    minifyIdentifiers: false,
    minifySyntax: false,
    splitting: false,
  },
]);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export default  defineConfig

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/tsup.config.ts
Tamaño: 901 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { defineConfig, type Options } from 'tsup';
import { version } from './package.json';
import { type SupportedFrameworkName } from './src/internal';

const frameworks: SupportedFrameworkName[] = ['h3', 'express', 'next', 'nuxt', 'sveltekit', 'remix', 'lambda', 'nest'];

const baseConfig: Options = {
  entry: ['src/index.ts', 'src/internal/index.ts', ...frameworks.map((framework) => `src/servers/${framework}.ts`)],
  sourcemap: false,
  clean: true,
  dts: true,
  minify: true,
  minifyWhitespace: true,
  minifyIdentifiers: true,
  minifySyntax: true,
  define: {
    SDK_VERSION: `"${version}"`,
    FRAMEWORK_VERSION: `"2024-06-26"`,
  },
};

export const cjsConfig: Options = {
  ...baseConfig,
  format: 'cjs',
  outDir: 'dist/cjs',
};

export const esmConfig: Options = {
  ...baseConfig,
  format: 'esm',
  outDir: 'dist/esm',
};

export default defineConfig([cjsConfig, esmConfig]);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - Options({
  entry: ['src/index.ts', 'src/internal/index.ts', ...frameworks.map((framework))
Declaraciones 'export' encontradas:
- export  const
- export  const
- export default  defineConfig

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/vitest.config.ts
Tamaño: 272 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/// <reference types="vitest" />

import { defineConfig } from 'vitest/config';
import { version } from './package.json';

export default defineConfig({
  esbuild: {
    define: {
      SDK_VERSION: `"${version}"`,
      FRAMEWORK_VERSION: `"2024-06-26"`,
    },
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export default  defineConfig

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/express/package.json
Tamaño: 48 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "main": "../dist/cjs/servers/express.cjs"
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"main": "../dist/cjs/servers/express.cjs"
}
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/framework/h3/package.json
Tamaño: 43 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "main": "../dist/cjs/servers/h3.cjs"
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"main": "../dist/cjs/servers/h3.cjs"
}
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/framework/internal/package.json
Tamaño: 47 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "main": "../dist/cjs/internal/index.cjs"
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"main": "../dist/cjs/internal/index.cjs"
}
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/framework/lambda/package.json
Tamaño: 47 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "main": "../dist/cjs/servers/lambda.cjs"
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"main": "../dist/cjs/servers/lambda.cjs"
}
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/framework/nest/package.json
Tamaño: 45 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "main": "../dist/cjs/servers/nest.cjs"
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"main": "../dist/cjs/servers/nest.cjs"
}
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/framework/next/package.json
Tamaño: 45 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "main": "../dist/cjs/servers/next.cjs"
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"main": "../dist/cjs/servers/next.cjs"
}
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/framework/nuxt/package.json
Tamaño: 45 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "main": "../dist/cjs/servers/nuxt.cjs"
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"main": "../dist/cjs/servers/nuxt.cjs"
}
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/framework/remix/package.json
Tamaño: 46 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "main": "../dist/cjs/servers/remix.cjs"
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"main": "../dist/cjs/servers/remix.cjs"
}
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/framework/scripts/INSTRUCTIONS.md
Tamaño: 359 bytes
Lenguaje detectado: Markdown

### CONTENIDO ORIGINAL ###

# Devtool

`devtool.ts`, `schema_output.json` and `schema_input.json` is meant to be used to extract json schema object from openapi json.
Put you openapi json in `schema_input.json` and change line 9 in `devtool.ts` to the path where the schema object you need are located. run `npm run devtool` and open `schema_output.json` and copy the result from there.


### ANALISIS AUTOMATICO (ESPAÑOL) ###

# Devtool
`devtool.ts`, `schema_output.json` and `schema_input.json` is meant to be used to extract json schema object from openapi json.
Put you openapi json in `schema_input.json` and change line 9 in `devtool.ts` to the path where the schema object you need are located. run `npm run devtool` and open `schema_output.json` and copy the result from there.
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/framework/scripts/devtool.ts
Tamaño: 643 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { writeFileSync } from 'node:fs';
import path from 'node:path';

import $RefParser from '@apidevtools/json-schema-ref-parser';

const main = async () => {
  const parser = new $RefParser();
  const schema = await parser.dereference(path.join(__dirname, 'schema_input.json'));
  // Edit this path to target the JSON schema that the send message endpoint uses
  // @ts-expect-error - components does not exist on the schema
  const body = schema.components.schemas['api.v2010.account.message'];
  writeFileSync(path.join(__dirname, 'schema_output.json'), JSON.stringify(body, null, 2));

  console.log('schema.json updated');
};

main();


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - main(async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/scripts/schema_input.json
Tamaño: 0 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###



### ANALISIS AUTOMATICO (ESPAÑOL) ###

Sin cabecera detectada en las primeras líneas.
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/framework/scripts/schema_output.json
Tamaño: 0 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###



### ANALISIS AUTOMATICO (ESPAÑOL) ###

Sin cabecera detectada en las primeras líneas.
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/framework/src/client.test.ts
Tamaño: 70510 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { beforeEach, describe, expect, it, vi } from 'vitest';

import { Client } from './client';
import { PostActionEnum } from './constants';
import {
  ExecutionEventPayloadInvalidError,
  ExecutionStateCorruptError,
  ProviderExecutionFailedError,
  StepExecutionFailedError,
  StepNotFoundError,
  WorkflowNotFoundError,
} from './errors';
import { workflow } from './resources';
import { Event, Step } from './types';

describe('Novu Client', () => {
  let client: Client;

  beforeEach(async () => {
    const newWorkflow = workflow('setup-workflow', async ({ step }) => {
      await step.email('send-email', async () => ({
        body: 'Test Body',
        subject: 'Subject',
      }));
    });

    client = new Client({ secretKey: 'some-secret-key' });
    await client.addWorkflows([newWorkflow]);
  });

  describe('client constructor', () => {
    it('should set secretKey to process.env.NOVU_SECRET_KEY by default', () => {
      const originalSecretKey = process.env.NOVU_SECRET_KEY;
      const testSecretKey = 'test-env-secret-key';
      process.env = { ...process.env, NOVU_SECRET_KEY: testSecretKey };
      const newClient = new Client();
      expect(newClient.secretKey).toBe(process.env.NOVU_SECRET_KEY);
      process.env = { ...process.env, NOVU_SECRET_KEY: originalSecretKey };
    });

    it('should set secretKey to provided secretKey', () => {
      const testSecretKey = 'test-provided-secret-key';
      const newClient = new Client({ secretKey: testSecretKey });
      expect(newClient.secretKey).toBe(testSecretKey);
    });

    it('should set apiUrl to provided apiUrl', () => {
      const testApiUrl = 'https://test.host';
      const newClient = new Client({ apiUrl: testApiUrl });
      expect(newClient.apiUrl).toBe(testApiUrl);
    });

    it('should set strictAuthentication to false when NODE_ENV is development', () => {
      const originalEnv = process.env.NODE_ENV;
      process.env = { ...process.env, NODE_ENV: 'development' };
      const newClient = new Client({ secretKey: 'some-secret-key' });
      expect(newClient.strictAuthentication).toBe(false);
      process.env = { ...process.env, NODE_ENV: originalEnv };
    });

    it('should set strictAuthentication to false when NODE_ENV is not defined', () => {
      const originalEnv = process.env.NODE_ENV;
      // @ts-expect-error - NODE_ENV should not be undefined
      process.env = { ...process.env, NODE_ENV: undefined };
      const newClient = new Client({ secretKey: 'some-secret-key' });
      expect(newClient.strictAuthentication).toBe(false);
      process.env = { ...process.env, NODE_ENV: originalEnv };
    });

    it('should set strictAuthentication to true when NODE_ENV is production', () => {
      const originalEnv = process.env.NODE_ENV;
      process.env = { ...process.env, NODE_ENV: 'production' };
      const newClient = new Client({ secretKey: 'some-secret-key' });
      expect(newClient.strictAuthentication).toBe(true);
      process.env = { ...process.env, NODE_ENV: originalEnv };
    });

    it('should set strictAuthentication to provided strictAuthentication', () => {
      const testStrictAuthentication = false;
      const newClient = new Client({ secretKey: 'some-secret-key', strictAuthentication: testStrictAuthentication });
      expect(newClient.strictAuthentication).toBe(testStrictAuthentication);
    });

    it('should set strictAuthentication to false when NOVU_STRICT_AUTHENTICATION_ENABLED is false', () => {
      const originalEnv = process.env.NOVU_STRICT_AUTHENTICATION_ENABLED;
      process.env = { ...process.env, NOVU_STRICT_AUTHENTICATION_ENABLED: 'false' };
      const newClient = new Client({ secretKey: 'some-secret-key' });
      expect(newClient.strictAuthentication).toBe(false);
      process.env = { ...process.env, NOVU_STRICT_AUTHENTICATION_ENABLED: originalEnv };
    });

    it('should set strictAuthentication to true when NOVU_STRICT_AUTHENTICATION_ENABLED is true', () => {
      const originalEnv = process.env.NOVU_STRICT_AUTHENTICATION_ENABLED;
      process.env = { ...process.env, NOVU_STRICT_AUTHENTICATION_ENABLED: 'true' };
      const newClient = new Client({ secretKey: 'some-secret-key' });
      expect(newClient.strictAuthentication).toBe(true);
      process.env = { ...process.env, NOVU_STRICT_AUTHENTICATION_ENABLED: originalEnv };
    });
  });

  describe('discover method', () => {
    it('should discover setup workflow', () => {
      const discovery = client.discover();
      expect(discovery.workflows).toHaveLength(1);
    });

    it('should discover a complex workflow with all supported step types', async () => {
      const workflowId = 'complex-workflow';

      const newWorkflow = workflow(workflowId, async ({ step }) => {
        await step.email('send-email', async () => ({
          body: 'Test Body',
          subject: 'Subject',
        }));

        const inAppRes = await step.inApp('send-in-app', async () => ({
          body: 'Test Body',
          subject: 'Subject',
        }));

        await step.chat('send-chat', async () => ({
          body: 'Test Body',
        }));

        await step.push('send-push', async () => ({
          body: 'Test Body',
          subject: 'Title',
        }));

        await step.custom(
          'send-custom',
          async (controls) => ({
            fooBoolean: inAppRes.read,
            fooString: controls.someString,
          }),
          {
            controlSchema: {
              type: 'object',
              properties: {
                someString: { type: 'string' },
              },
              required: ['someString'],
              additionalProperties: false,
            } as const,
            outputSchema: {
              type: 'object',
              properties: {
                fooBoolean: { type: 'boolean' },
                fooString: { type: 'string' },
              },
              required: ['fooBoolean', 'fooString'],
              additionalProperties: false,
            } as const,
          }
        );

        await step.sms('send-sms', async () => ({
          body: 'Test Body',
          to: '+1234567890',
        }));

        await step.digest('regular-digest', async () => ({
          amount: 1,
          unit: 'hours',
        }));

        await step.digest('regular-look-back-digest', async () => ({
          amount: 1,
          unit: 'hours',
          lookBackWindow: {
            amount: 1,
            unit: 'hours',
          },
        }));

        await step.digest('timed-digest', async () => ({
          cron: '0 0-23/1 * * *', // EVERY_HOUR
        }));

        await step.delay('delay', async () => ({
          type: 'regular',
          amount: 1,
          unit: 'hours',
        }));
      });

      await client.addWorkflows([newWorkflow]);

      // wait for discovery to finish
      await new Promise((resolve) => {
        setTimeout(resolve, 1);
      });

      const discovery = client.discover();
      expect(discovery.workflows).toHaveLength(2);

      const foundWorkflow = discovery.workflows.find((workflowX) => workflowX.workflowId === workflowId);

      const stepEmail = foundWorkflow?.steps.find((stepX) => stepX.stepId === 'send-email');
      expect(stepEmail).toBeDefined();
      if (stepEmail === undefined) throw new Error('stepEmail is undefined');
      expect(stepEmail.type).toBe('email');
      expect(stepEmail.code).toContain(`body: "Test Body"`);
      expect(stepEmail.code).toContain(`subject: "Subject"`);

      const stepInApp = foundWorkflow?.steps.find((stepX) => stepX.stepId === 'send-in-app');
      expect(stepInApp).toBeDefined();
      if (stepInApp === undefined) throw new Error('stepEmail is undefined');
      expect(stepInApp.type).toBe('in_app');
      expect(stepInApp.code).toContain(`body: "Test Body"`);
      expect(stepInApp.code).toContain(`subject: "Subject"`);

      const stepChat = foundWorkflow?.steps.find((stepX) => stepX.stepId === 'send-chat');
      expect(stepChat).toBeDefined();
      if (stepChat === undefined) throw new Error('stepEmail is undefined');
      expect(stepChat.type).toBe('chat');
      expect(stepChat.code).toContain(`body: "Test Body"`);

      const stepPush = foundWorkflow?.steps.find((stepX) => stepX.stepId === 'send-push');
      expect(stepPush).toBeDefined();
      if (stepPush === undefined) throw new Error('stepEmail is undefined');
      expect(stepPush.type).toBe('push');
      expect(stepPush.code).toContain(`body: "Test Body"`);
      expect(stepPush.code).toContain(`subject: "Title"`);

      const stepCustom = foundWorkflow?.steps.find((stepX) => stepX.stepId === 'send-custom');
      expect(stepCustom).toBeDefined();
      if (stepCustom === undefined) throw new Error('stepEmail is undefined');
      expect(stepCustom.type).toBe('custom');
      expect(stepCustom.code).toContain(`fooBoolean: inAppRes.read`);
      expect(stepCustom.code).toContain(`fooString: controls.someString`);

      const stepSms = foundWorkflow?.steps.find((stepX) => stepX.stepId === 'send-sms');
      expect(stepSms).toBeDefined();
      if (stepSms === undefined) throw new Error('stepEmail is undefined');
      expect(stepSms.type).toBe('sms');
      expect(stepSms.code).toContain(`body: "Test Body"`);
      expect(stepSms.code).toContain(`to: "+1234567890"`);

      const stepRegularDigest = foundWorkflow?.steps.find((stepX) => stepX.stepId === 'regular-digest');
      expect(stepRegularDigest).toBeDefined();
      if (stepRegularDigest === undefined) throw new Error('stepEmail is undefined');
      expect(stepRegularDigest.type).toBe('digest');
      expect(stepRegularDigest.code).toContain(`amount: 1`);
      expect(stepRegularDigest.code).toContain(`unit: "hours"`);

      const stepBackoffDigest = foundWorkflow?.steps.find((stepX) => stepX.stepId === 'regular-look-back-digest');
      expect(stepBackoffDigest).toBeDefined();
      if (stepBackoffDigest === undefined) throw new Error('stepEmail is undefined');
      expect(stepBackoffDigest.type).toBe('digest');
      expect(stepBackoffDigest.code).toContain(`amount: 1`);
      expect(stepBackoffDigest.code).toContain(`unit: "hours"`);
      expect(stepBackoffDigest.code.trim()).toContain(
        `lookBackWindow: {
            amount: 1,
            unit: "hours"
          }`.trim()
      );

      const stepTimedDigest = foundWorkflow?.steps.find((stepX) => stepX.stepId === 'timed-digest');
      expect(stepTimedDigest).toBeDefined();
      if (stepTimedDigest === undefined) throw new Error('stepEmail is undefined');
      expect(stepTimedDigest.type).toBe('digest');
      expect(stepTimedDigest.code).toContain(`cron: "0 0-23/1 * * *"`);

      const stepDelay = foundWorkflow?.steps.find((stepX) => stepX.stepId === 'delay');
      expect(stepDelay).toBeDefined();
      if (stepDelay === undefined) throw new Error('stepEmail is undefined');
      expect(stepDelay.type).toBe('delay');
      expect(stepDelay.code).toContain(`amount: 1`);
      expect(stepDelay.code).toContain(`unit: "hours"`);
    });

    it('should discover a slack provide with blocks', async () => {
      const workflowId = 'complex-workflow';

      const newWorkflow = workflow(workflowId, async ({ step }) => {
        await step.chat(
          'send-chat',
          async () => ({
            body: 'Test Body',
          }),
          {
            providers: {
              slack: async () => {
                return {
                  blocks: [
                    {
                      type: 'header',
                      text: {
                        type: 'plain_text',
                        text: 'Pretty Header',
                      },
                    },
                  ],
                };
              },
            },
          }
        );
      });

      await client.addWorkflows([newWorkflow]);

      const discovery = client.discover();
      expect(discovery.workflows).toHaveLength(2);

      const foundWorkflow = discovery.workflows.find((workflowX) => workflowX.workflowId === workflowId);

      const stepChat = foundWorkflow?.steps.find((stepX) => stepX.stepId === 'send-chat');
      expect(stepChat).toBeDefined();
      if (stepChat === undefined) throw new Error('stepEmail is undefined');
      expect(stepChat.type).toBe('chat');
      expect(stepChat.code).toContain(`body: "Test Body"`);
      expect(stepChat.providers[0].code).toContain(`type: "plain_text"`);
      expect(stepChat.providers[0].code).toContain(`text: "Pretty Header"`);
    });

    it('should not add duplicate workflows when adding the same workflow in parallel', async () => {
      const newWorkflow = workflow('test-workflow', async () => {});
      await Promise.all([client.addWorkflows([newWorkflow]), client.addWorkflows([newWorkflow])]);

      const discovery = client.discover();
      expect(discovery.workflows).toHaveLength(2);
    });
  });

  describe('previewWorkflow method', () => {
    it('should compile default control variables for preview', async () => {
      const newWorkflow = workflow(
        'test-workflow',
        async ({ step }) => {
          await step.email(
            'send-email',
            async (controls) => {
              return {
                subject: `body static prefix ${controls.name}`,
                body: controls.name,
              };
            },
            {
              controlSchema: {
                type: 'object',
                properties: {
                  name: { type: 'string', default: '{{payload.name}}' },
                },
                required: [],
                additionalProperties: false,
              } as const,
            }
          );
        },
        {
          payloadSchema: {
            type: 'object',
            properties: {
              name: { type: 'string' },
            },
            required: [],
            additionalProperties: false,
          } as const,
        }
      );

      await client.addWorkflows([newWorkflow]);

      const emailEvent: Event = {
        action: PostActionEnum.PREVIEW,
        payload: { name: 'John' },
        workflowId: 'test-workflow',
        stepId: 'send-email',
        subscriber: {
          lastName: "Smith's",
        },
        state: [],
        controls: {},
        context: {},
      };

      const emailExecutionResult = await client.executeWorkflow(emailEvent);

      expect(emailExecutionResult).toBeDefined();
      expect(emailExecutionResult.outputs).toBeDefined();
      if (!emailExecutionResult.outputs) throw new Error('executionResult.outputs is undefined');
      const { subject } = emailExecutionResult.outputs;
      expect(subject).toBe('body static prefix John');
    });

    it('should render step results in preview', async () => {
      const inAppStepId = 'in-app';
      const customStepId = 'fetch-user';
      const newWorkflow = workflow('test-workflow', async ({ step }) => {
        await step.inApp(inAppStepId, async () => ({
          body: 'In App Body',
        }));

        await step.custom(
          customStepId,
          async () => ({
            username: `my-db-user`,
          }),
          {
            outputSchema: {
              type: 'object',
              properties: {
                username: { type: 'string' },
              },
              required: ['username'],
              additionalProperties: false,
            } as const,
          }
        );

        await step.email(
          'send-email',
          async (controls) => {
            return {
              subject: 'Test Subject',
              body: controls.body,
            };
          },
          {
            controlSchema: {
              type: 'object',
              properties: {
                body: {
                  type: 'string',
                  default: `In app message was {{steps.${inAppStepId}.seen}}. Username is {{steps.${customStepId}.username}}.`,
                },
              },
              required: ['body'],
              additionalProperties: false,
            } as const,
          }
        );
      });

      await client.addWorkflows([newWorkflow]);

      const emailEvent: Event = {
        action: PostActionEnum.PREVIEW,
        payload: {},
        workflowId: 'test-workflow',
        stepId: 'send-email',
        subscriber: {},
        state: [
          {
            stepId: inAppStepId,
            outputs: {
              seen: true,
              read: true,
              lastSeenDate: new Date().toISOString(),
              lastReadDate: new Date().toISOString(),
            },
            state: {
              status: 'completed',
            },
          },
          {
            stepId: customStepId,
            outputs: {
              username: 'my-db-user',
            },
            state: {
              status: 'completed',
            },
          },
        ],
        controls: {},
        context: {},
      };

      const emailExecutionResult = await client.executeWorkflow(emailEvent);

      expect(emailExecutionResult).toBeDefined();
      expect(emailExecutionResult.outputs).toBeDefined();
      if (!emailExecutionResult.outputs) throw new Error('executionResult.outputs is undefined');
      expect(emailExecutionResult.outputs.body).toBe('In app message was true. Username is my-db-user.');
    });

    it('should sanitize the step result of all delivery channel step types', async () => {
      const script = `<script>alert('Hello there')</script>`;

      await client.addWorkflows([
        workflow('test-workflow', async ({ step }) => {
          await step.email('send-email', async () => ({
            body: `Start of body. ${script}`,
            subject: `Start of subject. ${script}`,
          }));
        }),
      ]);

      const event: Event = {
        action: PostActionEnum.PREVIEW,
        workflowId: 'test-workflow',
        stepId: 'send-email',
        subscriber: {},
        state: [],
        payload: {},
        controls: {},
        context: {},
      };

      const executionResult = await client.executeWorkflow(event);
      expect(executionResult.outputs).toBeDefined();
      expect(executionResult.outputs.body).toBe('Start of body. ');
      expect(executionResult.outputs.subject).toBe('Start of subject. ');
    });

    it('should not sanitize the step result of custom step type', async () => {
      const script = `<script>alert('Hello there')</script>`;

      await client.addWorkflows([
        workflow('test-workflow', async ({ step }) => {
          await step.custom(
            'send-email',
            async () => ({
              testVal: `Start of body. ${script}`,
            }),
            {
              outputSchema: {
                type: 'object',
                properties: {
                  testVal: { type: 'string' },
                },
                required: ['testVal'],
                additionalProperties: false,
              } as const,
            }
          );
        }),
      ]);

      const event: Event = {
        action: PostActionEnum.PREVIEW,
        workflowId: 'test-workflow',
        stepId: 'send-email',
        subscriber: {},
        state: [],
        payload: {},
        controls: {},
        context: {},
      };

      const executionResult = await client.executeWorkflow(event);
      expect(executionResult.outputs).toBeDefined();
      expect(executionResult.outputs.testVal).toBe(`Start of body. ${script}`);
    });
  });

  describe('executeWorkflow method', () => {
    it('should execute workflow successfully when action is execute and payload is provided', async () => {
      const delayConfiguration = { unit: 'seconds', amount: 1 } as const;
      const emailConfiguration = {
        body: 'Test Body',
        subject: 'Subject',
      } as const;
      const newWorkflow = workflow('test-workflow', async ({ step }) => {
        await step.email('send-email', async () => emailConfiguration);
        await step.delay('delay', async () => delayConfiguration);
      });

      const emailEvent: Event = {
        action: PostActionEnum.EXECUTE,
        payload: {},
        workflowId: 'test-workflow',
        stepId: 'send-email',
        subscriber: {},
        state: [],
        controls: {},
        context: {},
      };

      await client.addWorkflows([newWorkflow]);

      const emailExecutionResult = await client.executeWorkflow(emailEvent);

      expect(emailExecutionResult).toBeDefined();
      expect(emailExecutionResult.outputs).toBeDefined();
      if (!emailExecutionResult.outputs) throw new Error('executionResult.outputs is undefined');
      const { body } = emailExecutionResult.outputs;
      expect(body).toBe(emailConfiguration.body);
      const { subject } = emailExecutionResult.outputs;
      expect(subject).toBe(emailConfiguration.subject);
      expect(emailExecutionResult.providers).toEqual({});
      const { metadata } = emailExecutionResult;
      expect(metadata.status).toBe('success');
      expect(metadata.error).toBe(false);
      expect(metadata.duration).toEqual(expect.any(Number));

      const delayEvent: Event = {
        action: PostActionEnum.EXECUTE,
        payload: {},
        workflowId: 'test-workflow',
        stepId: 'delay',
        subscriber: {},
        state: [
          {
            stepId: 'send-email',
            outputs: {},
            state: {
              status: 'completed',
              error: undefined,
            },
          },
        ],
        controls: {},
        context: {},
      };

      const delayExecutionResult = await client.executeWorkflow(delayEvent);

      expect(delayExecutionResult).toBeDefined();
      expect(delayExecutionResult.outputs).toBeDefined();
      if (!delayExecutionResult.outputs) throw new Error('executionResult.outputs is undefined');
      const { unit } = delayExecutionResult.outputs;
      expect(unit).toBe(delayConfiguration.unit);
      const { amount } = delayExecutionResult.outputs;
      expect(amount).toBe(delayConfiguration.amount);
      expect(delayExecutionResult.providers).toEqual({});
    });

    it('should compile default control variable', async () => {
      const bodyTemplate = `
{% for element in payload.elements %}
  {{ element }}
{% endfor %}`;

      const newWorkflow = workflow(
        'test-workflow',
        async ({ step }) => {
          await step.email(
            'send-email',
            async (controls) => {
              return {
                subject: `body static prefix ${controls.name} ${controls.lastName} ${controls.role}`,
                body: controls.body,
              };
            },
            {
              controlSchema: {
                type: 'object',
                properties: {
                  name: { type: 'string', default: '{{payload.name}}' },
                  lastName: { type: 'string', default: '{{subscriber.lastName}}' },
                  role: { type: 'string', default: '{{payload.role}}' },
                  body: { type: 'string', default: bodyTemplate },
                },
                required: [],
                additionalProperties: false,
              } as const,
            }
          );
        },
        {
          payloadSchema: {
            type: 'object',
            properties: {
              name: { type: 'string', default: '`default_name`' },
              role: { type: 'string' },
              elements: { type: 'array' },
            },
            required: [],
            additionalProperties: false,
          } as const,
        }
      );

      await client.addWorkflows([newWorkflow]);

      const emailEvent: Event = {
        action: PostActionEnum.EXECUTE,
        payload: { role: 'product manager', elements: ['cat', 'dog'] },
        workflowId: 'test-workflow',
        stepId: 'send-email',
        subscriber: {
          lastName: "Smith's",
        },
        state: [],
        controls: {},
        context: {},
      };

      const emailExecutionResult = await client.executeWorkflow(emailEvent);

      expect(emailExecutionResult).toBeDefined();
      expect(emailExecutionResult.outputs).toBeDefined();
      if (!emailExecutionResult.outputs) throw new Error('executionResult.outputs is undefined');
      const { subject } = emailExecutionResult.outputs;
      expect(subject).toBe("body static prefix `default_name` Smith's product manager");
      const { body } = emailExecutionResult.outputs;
      expect(body).toContain('cat');
      expect(body).toContain('dog');
    });

    it('should compile array control variables to a string with single quotes', async () => {
      const newWorkflow = workflow(
        'test-workflow',
        async ({ step }) => {
          await step.email(
            'send-email',
            async (controls) => ({
              body: controls.body,
              subject: controls.subject,
            }),
            {
              controlSchema: {
                type: 'object',
                properties: {
                  body: { type: 'string' },
                  subject: { type: 'string' },
                },
                required: ['body', 'subject'],
                additionalProperties: false,
              } as const,
            }
          );
        },
        {
          payloadSchema: {
            type: 'object',
            properties: {
              comments: {
                type: 'array',
                items: {
                  type: 'object',
                  properties: { text: { type: 'string' } },
                  required: ['text'],
                },
              },
              subject: { type: 'string' },
            },
            required: ['comments', 'subject'],
            additionalProperties: false,
          } as const,
        }
      );

      await client.addWorkflows([newWorkflow]);

      const event: Event = {
        action: PostActionEnum.EXECUTE,
        payload: { comments: [{ text: 'cat' }, { text: 'dog' }], subject: 'Hello' },
        workflowId: 'test-workflow',
        stepId: 'send-email',
        subscriber: {},
        state: [],
        controls: {
          body: '{{payload.comments}}',
          subject: '{{payload.subject}}',
        },
        context: {},
      };

      const emailExecutionResult = await client.executeWorkflow(event);

      expect(emailExecutionResult.outputs).toEqual({
        body: "[{'text':'cat'},{'text':'dog'}]",
        subject: 'Hello',
      });
    });

    it('should compile array control variables to a string with single quotes when using json filter', async () => {
      const newWorkflow = workflow(
        'test-workflow',
        async ({ step }) => {
          await step.email(
            'send-email',
            async (controls) => ({
              body: controls.body,
              subject: controls.subject,
            }),
            {
              controlSchema: {
                type: 'object',
                properties: {
                  body: { type: 'string' },
                  subject: { type: 'string' },
                },
                required: ['body', 'subject'],
                additionalProperties: false,
              } as const,
            }
          );
        },
        {
          payloadSchema: {
            type: 'object',
            properties: {
              comments: {
                type: 'array',
                items: {
                  type: 'object',
                  properties: { text: { type: 'string' } },
                  required: ['text'],
                },
              },
              subject: { type: 'string' },
            },
            required: ['comments', 'subject'],
            additionalProperties: false,
          } as const,
        }
      );

      await client.addWorkflows([newWorkflow]);

      const event: Event = {
        action: PostActionEnum.EXECUTE,
        payload: { comments: [{ text: 'cat' }, { text: 'dog' }], subject: 'Hello' },
        workflowId: 'test-workflow',
        stepId: 'send-email',
        subscriber: {},
        state: [],
        controls: {
          body: '{{payload.comments | json}}',
          subject: '{{payload.subject}}',
        },
        context: {},
      };

      const emailExecutionResult = await client.executeWorkflow(event);

      expect(emailExecutionResult.outputs).toEqual({
        body: "[{'text':'cat'},{'text':'dog'}]",
        subject: 'Hello',
      });
    });

    it('should compile object control variables to a string with single quotes', async () => {
      const newWorkflow = workflow(
        'test-workflow',
        async ({ step }) => {
          await step.email(
            'send-email',
            async (controls) => ({
              body: controls.body,
              subject: controls.subject,
            }),
            {
              controlSchema: {
                type: 'object',
                properties: {
                  body: { type: 'string' },
                  subject: { type: 'string' },
                },
                required: ['body', 'subject'],
                additionalProperties: false,
              } as const,
            }
          );
        },
        {
          payloadSchema: {
            type: 'object',
            properties: {
              comment: {
                type: 'object',
                properties: { text: { type: 'string' } },
                required: ['text'],
              },
              subject: { type: 'string' },
            },
            required: ['comment', 'subject'],
            additionalProperties: false,
          } as const,
        }
      );

      await client.addWorkflows([newWorkflow]);

      const event: Event = {
        action: PostActionEnum.EXECUTE,
        payload: { comment: { text: 'cat' }, subject: 'Hello' },
        workflowId: 'test-workflow',
        stepId: 'send-email',
        subscriber: {},
        state: [],
        controls: {
          body: '{{payload.comment}}',
          subject: '{{payload.subject}}',
        },
        context: {},
      };

      const emailExecutionResult = await client.executeWorkflow(event);

      expect(emailExecutionResult.outputs).toEqual({
        body: "{'text':'cat'}",
        subject: 'Hello',
      });
    });

    it('should compile object control variables to a string with single quotes when using json filter', async () => {
      const newWorkflow = workflow(
        'test-workflow',
        async ({ step }) => {
          await step.email(
            'send-email',
            async (controls) => ({
              body: controls.body,
              subject: controls.subject,
            }),
            {
              controlSchema: {
                type: 'object',
                properties: {
                  body: { type: 'string' },
                  subject: { type: 'string' },
                },
                required: ['body', 'subject'],
                additionalProperties: false,
              } as const,
            }
          );
        },
        {
          payloadSchema: {
            type: 'object',
            properties: {
              comment: {
                type: 'object',
                properties: { text: { type: 'string' } },
                required: ['text'],
              },
              subject: { type: 'string' },
            },
            required: ['comment', 'subject'],
            additionalProperties: false,
          } as const,
        }
      );

      await client.addWorkflows([newWorkflow]);

      const event: Event = {
        action: PostActionEnum.EXECUTE,
        payload: { comment: { text: 'cat' }, subject: 'Hello' },
        workflowId: 'test-workflow',
        stepId: 'send-email',
        subscriber: {},
        state: [],
        controls: {
          body: '{{payload.comment | json}}',
          subject: '{{payload.subject}}',
        },
        context: {},
      };

      const emailExecutionResult = await client.executeWorkflow(event);

      expect(emailExecutionResult.outputs).toEqual({
        body: "{'text':'cat'}",
        subject: 'Hello',
      });
    });

    it('should respect the spaces option when using json filter', async () => {
      const newWorkflow = workflow(
        'test-workflow',
        async ({ step }) => {
          await step.email(
            'send-email',
            async (controls) => ({
              body: controls.body,
              subject: controls.subject,
            }),
            {
              controlSchema: {
                type: 'object',
                properties: {
                  body: { type: 'string' },
                  subject: { type: 'string' },
                },
                required: ['body', 'subject'],
                additionalProperties: false,
              } as const,
            }
          );
        },
        {
          payloadSchema: {
            type: 'object',
            properties: {
              comment: {
                type: 'object',
                properties: { text: { type: 'string' } },
                required: ['text'],
              },
              subject: { type: 'string' },
            },
            required: ['comment', 'subject'],
            additionalProperties: false,
          } as const,
        }
      );

      await client.addWorkflows([newWorkflow]);

      const event: Event = {
        action: PostActionEnum.EXECUTE,
        payload: { comment: { text: 'cat' }, subject: 'Hello' },
        workflowId: 'test-workflow',
        stepId: 'send-email',
        subscriber: {},
        state: [],
        controls: {
          body: '{{payload.comment | json: 2}}',
          subject: '{{payload.subject}}',
        },
        context: {},
      };

      const emailExecutionResult = await client.executeWorkflow(event);

      expect(emailExecutionResult.outputs).toEqual({
        body: `{
  'text': 'cat'
}`,
        subject: 'Hello',
      });
    });

    it('should gracefully compile control variables that are not present', async () => {
      const newWorkflow = workflow('test-workflow', async ({ step }) => {
        await step.email(
          'send-email',
          async (controls) => ({
            body: controls.body,
            subject: controls.subject,
          }),
          {
            controlSchema: {
              type: 'object',
              properties: {
                body: { type: 'string' },
                subject: { type: 'string' },
              },
              required: ['body', 'subject'],
              additionalProperties: false,
            } as const,
          }
        );
      });

      await client.addWorkflows([newWorkflow]);

      const event: Event = {
        action: PostActionEnum.EXECUTE,
        payload: {},
        workflowId: 'test-workflow',
        stepId: 'send-email',
        subscriber: {},
        state: [],
        controls: {
          body: 'Hi {{payload.does_not_exist}}',
          subject: 'Test subject',
        },
        context: {},
      };

      const emailExecutionResult = await client.executeWorkflow(event);

      expect(emailExecutionResult.outputs).toEqual({
        body: 'Hi ',
        subject: 'Test subject',
      });
    });

    // skipped until we implement support for control variables https://linear.app/novu/issue/NV-4248/support-for-controls-in-autocomplete
    it.skip('should compile control variables used in other control variables', async () => {
      const newWorkflow = workflow('test-workflow', async ({ step }) => {
        await step.email(
          'send-email',
          async (controls) => ({
            body: controls.body,
            subject: controls.subject,
          }),
          {
            controlSchema: {
              type: 'object',
              properties: {
                body: { type: 'string' },
                subject: { type: 'string' },
              },
              required: ['body', 'subject'],
              additionalProperties: false,
            } as const,
          }
        );
      });

      await client.addWorkflows([newWorkflow]);

      const emailEvent: Event = {
        action: PostActionEnum.EXECUTE,
        payload: {},
        workflowId: 'test-workflow',
        stepId: 'send-email',
        subscriber: {},
        state: [],
        controls: {
          body: 'body {{controls.subject}}',
          subject: 'subject',
        },
        context: {},
      };

      const emailExecutionResult = await client.executeWorkflow(emailEvent);

      expect(emailExecutionResult).toBeDefined();
      expect(emailExecutionResult.outputs).toBeDefined();
      if (!emailExecutionResult.outputs) throw new Error('executionResult.outputs is undefined');
      const { subject } = emailExecutionResult.outputs;
      expect(subject).toBe('subject');
      const { body } = emailExecutionResult.outputs;
      expect(body).toBe('body subject');
    });

    // skipped until we implement support for control variables https://linear.app/novu/issue/NV-4248/support-for-controls-in-autocomplete
    it.skip('should compile control variables nested in the same control variables', async () => {
      const newWorkflow = workflow('test-workflow', async ({ step }) => {
        await step.email(
          'send-email',
          async (controls) => ({
            body: controls.body,
            subject: controls.subject,
          }),
          {
            controlSchema: {
              type: 'object',
              properties: {
                body: { type: 'string' },
                subject: { type: 'string' },
              },
              required: ['body', 'subject'],
              additionalProperties: false,
            } as const,
          }
        );
      });

      await client.addWorkflows([newWorkflow]);

      const emailEvent: Event = {
        action: PostActionEnum.EXECUTE,
        payload: {},
        workflowId: 'test-workflow',
        stepId: 'send-email',
        subscriber: {},
        state: [],
        controls: {
          body: 'body',
          subject: 'subject {{controls.subject}}',
        },
        context: {},
      };

      const emailExecutionResult = await client.executeWorkflow(emailEvent);

      expect(emailExecutionResult).toBeDefined();
      expect(emailExecutionResult.outputs).toBeDefined();
      if (!emailExecutionResult.outputs) throw new Error('executionResult.outputs is undefined');
      const { subject } = emailExecutionResult.outputs;
      expect(subject).toBe('subject subject {{controls.subject}}');
      const { body } = emailExecutionResult.outputs;
      expect(body).toBe('body');
    });

    it('should not parse translation patterns as liquid variables', async () => {
      const newWorkflow = workflow(
        'test-workflow',
        async ({ step }) => {
          await step.email(
            'send-email',
            async (controls) => ({
              body: controls.body,
              subject: controls.subject,
            }),
            {
              controlSchema: {
                type: 'object',
                properties: {
                  body: { type: 'string' },
                  subject: { type: 'string' },
                },
                required: ['body', 'subject'],
                additionalProperties: false,
              } as const,
            }
          );
        },
        {
          payloadSchema: {
            type: 'object',
            properties: {
              name: { type: 'string' },
            },
            required: [],
            additionalProperties: false,
          } as const,
        }
      );

      await client.addWorkflows([newWorkflow]);

      const event: Event = {
        action: PostActionEnum.EXECUTE,
        payload: { name: 'John' },
        workflowId: 'test-workflow',
        stepId: 'send-email',
        subscriber: { email: 'test@example.com' },
        state: [],
        controls: {
          body: 'Hello body {{payload.name}}! {{t.single}} {{t.with-dash}} {{t.with_underscore}} {{t.123}} {{t.你好}}', // single, no nesting
          subject:
            'Hello subject {{payload.name}}! {{t.nested.single}} {{t.nested-with-dash.single}} {{t.nested_with_underscore.single}} {{t.123.single}} {{t.你好.single}}', // with nesting
        },
        context: {},
      };

      const emailExecutionResult = await client.executeWorkflow(event);

      // Translation patterns should be preserved when t.* values are undefined
      expect(emailExecutionResult.outputs).toEqual({
        body: 'Hello body John! {{t.single}} {{t.with-dash}} {{t.with_underscore}} {{t.123}} {{t.你好}}',
        subject:
          'Hello subject John! {{t.nested.single}} {{t.nested-with-dash.single}} {{t.nested_with_underscore.single}} {{t.123.single}} {{t.你好.single}}',
      });
    });

    it('should compile context variables correctly', async () => {
      const newWorkflow = workflow(
        'test-workflow',
        async ({ step }) => {
          await step.email(
            'send-email',
            async (controls) => ({
              body: controls.body,
              subject: controls.subject,
            }),
            {
              controlSchema: {
                type: 'object',
                properties: {
                  body: { type: 'string' },
                  subject: { type: 'string' },
                },
                required: ['body', 'subject'],
                additionalProperties: false,
              } as const,
            }
          );
        },
        {
          payloadSchema: {
            type: 'object',
            properties: {
              name: { type: 'string' },
            },
            required: [],
            additionalProperties: false,
          } as const,
        }
      );

      await client.addWorkflows([newWorkflow]);

      const event: Event = {
        action: PostActionEnum.EXECUTE,
        payload: { name: 'John' },
        workflowId: 'test-workflow',
        stepId: 'send-email',
        subscriber: {},
        state: [],
        controls: {
          body: 'Hello {{payload.name}} from {{context.app.id}}!',
          subject: 'Context test: {{context.tenant.id}} - {{context.app.id}}',
        },
        context: {
          tenant: {
            id: 'test-tenant',
            data: {
              name: 'Test Tenant',
            },
          },
          app: {
            id: 'test-app',
            data: {},
          },
        },
      };

      const emailExecutionResult = await client.executeWorkflow(event);

      expect(emailExecutionResult.outputs).toEqual({
        body: 'Hello John from test-app!',
        subject: 'Context test: test-tenant - test-app',
      });
    });

    it('should throw error on execute action without payload', async () => {
      const newWorkflow = workflow('test-workflow', async ({ step }) => {
        await step.email('send-email', async () => ({ body: 'Test Body', subject: 'Subject' }));
      });

      await client.addWorkflows([newWorkflow]);

      const event: Event = {
        action: PostActionEnum.EXECUTE,
        workflowId: 'test-workflow',
        stepId: 'send-email',
        subscriber: {},
        state: [],
        // @ts-expect-error - testing undefined data and payload
        payload: undefined,
        controls: {},
      };

      await expect(client.executeWorkflow(event)).rejects.toThrow(ExecutionEventPayloadInvalidError);
    });

    it('should pass the step controls and outputs to the provider execution', async () => {
      const newWorkflow = workflow('test-workflow', async ({ step }) => {
        await step.email('send-email', async () => ({ body: 'Test Body', subject: 'Subject' }), {
          controlSchema: {
            type: 'object',
            properties: {
              foo: { type: 'string' },
            },
            required: ['foo'],
            additionalProperties: false,
          } as const,
          providers: {
            sendgrid: async ({ controls, outputs }) => ({
              ipPoolName: `${controls.foo} ${outputs.subject}`,
              from: {
                email: 'test@example.com',
                name: 'Test',
              },
            }),
          },
        });
      });

      await client.addWorkflows([newWorkflow]);

      const event: Event = {
        action: PostActionEnum.EXECUTE,
        workflowId: 'test-workflow',
        stepId: 'send-email',
        subscriber: {},
        state: [],
        payload: {},
        controls: {
          foo: 'foo',
        },
        context: {},
      };

      const executionResult = await client.executeWorkflow(event);

      expect(executionResult.providers).toEqual({
        sendgrid: {
          ipPoolName: 'foo Subject',
          from: { email: 'test@example.com', name: 'Test' },
        },
      });
    });

    it('should support a passthrough object for the provider execution', async () => {
      const newWorkflow = workflow('test-workflow', async ({ step }) => {
        await step.email('send-email', async () => ({ body: 'Test Body', subject: 'Subject' }), {
          controlSchema: {
            type: 'object',
            properties: {
              foo: { type: 'string' },
            },
            required: ['foo'],
            additionalProperties: false,
          } as const,
          providers: {
            sendgrid: async () => ({
              _passthrough: {
                body: {
                  fooBody: 'barBody',
                },
                headers: {
                  'X-Custom-Header': 'test',
                },
                query: {
                  fooQuery: 'barQuery',
                },
              },
            }),
          },
        });
      });

      await client.addWorkflows([newWorkflow]);

      const event: Event = {
        action: PostActionEnum.EXECUTE,
        workflowId: 'test-workflow',
        stepId: 'send-email',
        subscriber: {},
        state: [],
        payload: {},
        controls: {
          foo: 'foo',
        },
        context: {},
      };

      const executionResult = await client.executeWorkflow(event);

      expect(executionResult.providers).toEqual({
        sendgrid: {
          _passthrough: {
            body: {
              fooBody: 'barBody',
            },
            headers: {
              'X-Custom-Header': 'test',
            },
            query: {
              fooQuery: 'barQuery',
            },
          },
        },
      });
    });

    it('should support providers with polymorphic properties', async () => {
      const newWorkflow = workflow('test-workflow', async ({ step }) => {
        await step.chat('send-slack', async () => ({ body: 'Test Body', subject: 'Subject' }), {
          providers: {
            slack: async () => ({
              text: 'Test Body',
              blocks: [
                {
                  type: 'image',
                  image_url: 'https://example.com/image.png',
                  alt_text: 'An image',
                },
                {
                  type: 'divider',
                },
              ],
            }),
          },
        });
      });

      await client.addWorkflows([newWorkflow]);

      const event: Event = {
        action: PostActionEnum.EXECUTE,
        workflowId: 'test-workflow',
        stepId: 'send-slack',
        subscriber: {},
        state: [],
        payload: {},
        controls: {},
        context: {},
      };

      const executionResult = await client.executeWorkflow(event);

      expect(executionResult.providers).toEqual({
        slack: {
          text: 'Test Body',
          blocks: [
            {
              type: 'image',
              image_url: 'https://example.com/image.png',
              alt_text: 'An image',
            },
            {
              type: 'divider',
            },
          ],
        },
      });
    });

    it('should evaluate code in the provided stepId', async () => {
      const mockFn = vi.fn();
      const newWorkflow = workflow('test-workflow', async ({ step }) => {
        await step.email('active-step-id', async () => {
          mockFn();

          return { body: 'Test Body', subject: 'Subject' };
        });
        await step.email('inactive-step-id', async () => ({ body: 'Test Body', subject: 'Subject' }));
      });

      await client.addWorkflows([newWorkflow]);

      const event: Event = {
        action: PostActionEnum.EXECUTE,
        workflowId: 'test-workflow',
        stepId: 'active-step-id',
        subscriber: {},
        state: [],
        payload: {},
        controls: {},
        context: {},
      };

      await client.executeWorkflow(event);

      expect(mockFn).toHaveBeenCalledTimes(1);
    });

    it('should NOT evaluate code in steps after the provided stepId', async () => {
      const mockFn = vi.fn();
      const newWorkflow = workflow('test-workflow', async ({ step }) => {
        await step.email('active-step-id', async () => ({ body: 'Test Body', subject: 'Subject' }));
        await step.email('inactive-step-id', async () => {
          mockFn();

          return { body: 'Test Body', subject: 'Subject' };
        });
      });

      await client.addWorkflows([newWorkflow]);

      const event: Event = {
        action: PostActionEnum.EXECUTE,
        workflowId: 'test-workflow',
        stepId: 'active-step-id',
        subscriber: {},
        state: [],
        payload: {},
        controls: {},
        context: {},
      };

      await client.executeWorkflow(event);

      expect(mockFn).toHaveBeenCalledTimes(0);
    });

    it('should NOT log anything after executing the provided stepId', async () => {
      const mockFn = vi.fn();
      const spyConsoleLog = vi.spyOn(console, 'log');
      const newWorkflow = workflow('test-workflow', async ({ step }) => {
        await step.email('active-step-id', async () => ({ body: 'Test Body', subject: 'Subject' }));
        await step.email('inactive-step-id', async () => {
          mockFn();

          return { body: 'Test Body', subject: 'Subject' };
        });
      });

      await client.addWorkflows([newWorkflow]);

      const event: Event = {
        action: PostActionEnum.EXECUTE,
        workflowId: 'test-workflow',
        stepId: 'active-step-id',
        subscriber: {},
        state: [],
        payload: {},
        controls: {},
        context: {},
      };

      await client.executeWorkflow(event);

      // Wait for the conclusion promise to resolve.
      await new Promise((resolve) => {
        setTimeout(resolve);
      });
      /*
       * Not the most robust test, but ensures that the last log call contains the duration,
       * which is the last expected log call.
       */
      expect(spyConsoleLog.mock.lastCall).toEqual([expect.stringContaining('duration:')]);
    });

    it('should evaluate code in steps after a skipped step', async () => {
      const mockFn = vi.fn();
      const newWorkflow = workflow('test-workflow', async ({ step }) => {
        await step.email('skipped-step-id', async () => ({ body: 'Test Body', subject: 'Subject' }), {
          skip: () => true,
        });
        await step.email('active-step-id', async () => {
          mockFn();

          return { body: 'Test Body', subject: 'Subject' };
        });
      });

      await client.addWorkflows([newWorkflow]);

      const event: Event = {
        action: PostActionEnum.EXECUTE,
        workflowId: 'test-workflow',
        stepId: 'active-step-id',
        subscriber: {},
        state: [
          {
            stepId: 'skipped-step-id',
            outputs: {},
            state: {
              status: 'success',
            },
          },
        ],
        payload: {},
        controls: {},
        context: {},
      };

      await client.executeWorkflow(event);

      expect(mockFn).toHaveBeenCalledTimes(1);
    });

    it('should preview with mocked payload during preview', async () => {
      const workflowMock = workflow(
        'mock-workflow',
        async ({ step, payload }) => {
          await step.email('send-email', async () => ({ body: `Test: ${payload.name}`, subject: 'Subject' }));
        },
        {
          payloadSchema: {
            type: 'object',
            properties: {
              name: { type: 'string' },
            },
            required: ['name'],
          } as const,
        }
      );

      await client.addWorkflows([workflowMock]);

      const event: Event = {
        action: PostActionEnum.PREVIEW,
        workflowId: 'mock-workflow',
        stepId: 'send-email',
        subscriber: {},
        state: [],
        payload: {},
        controls: {},
        context: {},
      };

      const executionResult = await client.executeWorkflow(event);
      expect(executionResult).toBeDefined();
      expect(executionResult.outputs).toBeDefined();

      expect(executionResult.outputs.body).toBe('Test: [placeholder]');
    });

    it('should preview workflow successfully when action is preview', async () => {
      const newWorkflow = workflow('test-workflow', async ({ step }) => {
        await step.email('send-email', async () => ({ body: 'Test Body', subject: 'Subject' }));
      });

      await client.addWorkflows([newWorkflow]);

      const event: Event = {
        action: PostActionEnum.PREVIEW,
        workflowId: 'test-workflow',
        stepId: 'send-email',
        subscriber: {},
        state: [],
        payload: {},
        controls: {},
        context: {},
      };

      const executionResult = await client.executeWorkflow(event);

      expect(executionResult).toBeDefined();
      expect(executionResult.outputs).toBeDefined();
      if (!executionResult.outputs) throw new Error('executionResult.outputs is undefined');

      const { body } = executionResult.outputs;
      expect(body).toBe('Test Body');

      const { subject } = executionResult.outputs;
      expect(subject).toBe('Subject');

      expect(executionResult.providers).toEqual({});

      const { metadata } = executionResult;
      expect(metadata.status).toBe('success');
      expect(metadata.error).toBe(false);
      expect(metadata.duration).toEqual(expect.any(Number));
    });

    it('should preview a non-first step in a workflow successfully when action is preview', async () => {
      const newWorkflow = workflow('test-workflow', async ({ step }) => {
        await step.delay(
          'delay-step',
          async (controls) => ({
            amount: controls.amount,
            unit: controls.unit,
          }),
          {
            controlSchema: {
              type: 'object',
              properties: {
                amount: { type: 'number' },
                unit: {
                  type: 'string',
                  enum: ['seconds', 'minutes', 'hours', 'days', 'weeks', 'months'],
                },
              },
              required: ['amount', 'unit'],
              additionalProperties: false,
            } as const,
          }
        );

        await step.inApp('send-in-app', async () => ({ body: 'Test Body', subject: 'Subject' }));
      });

      await client.addWorkflows([newWorkflow]);

      const event: Event = {
        action: PostActionEnum.PREVIEW,
        workflowId: 'test-workflow',
        stepId: 'send-in-app',
        subscriber: {},
        state: [],
        payload: {},
        controls: {},
        context: {},
      };

      const executionResult = await client.executeWorkflow(event);

      expect(executionResult).toBeDefined();
      expect(executionResult.outputs).toBeDefined();
      if (!executionResult.outputs) throw new Error('executionResult.outputs is undefined');

      const { body } = executionResult.outputs;
      expect(body).toBe('Test Body');

      const { subject } = executionResult.outputs;
      expect(subject).toBe('Subject');

      expect(executionResult.providers).toEqual({});

      const { metadata } = executionResult;
      expect(metadata.status).toBe('success');
      expect(metadata.error).toBe(false);
      expect(metadata.duration).toEqual(expect.any(Number));
    });

    it('should preview workflow successfully when action is preview and skipped', async () => {
      const newWorkflow = workflow('test-workflow', async ({ step }) => {
        await step.email('send-email', async () => ({ body: 'Test Body', subject: 'Subject' }), {
          skip: () => true,
        });
      });

      await client.addWorkflows([newWorkflow]);

      const event: Event = {
        action: PostActionEnum.PREVIEW,
        workflowId: 'test-workflow',
        stepId: 'send-email',
        subscriber: {},
        state: [],
        payload: {},
        controls: {},
        context: {},
      };

      const executionResult = await client.executeWorkflow(event);

      expect(executionResult).toBeDefined();
      expect(executionResult.outputs).toBeDefined();
      if (!executionResult.outputs) throw new Error('executionResult.outputs is undefined');

      const { body } = executionResult.outputs;
      expect(body).toBe('Test Body');

      const { subject } = executionResult.outputs;
      expect(subject).toBe('Subject');

      expect(executionResult.providers).toEqual({});

      const { metadata } = executionResult;
      expect(metadata.status).toBe('success');
      expect(metadata.error).toBe(false);
      expect(metadata.duration).toEqual(expect.any(Number));
    });

    it('should use the provided state to mock non previewed step outputs', async () => {
      const newWorkflow = workflow(
        'test-workflow',
        async ({ step }) => {
          const digestOutput = await step.digest('digest-output', async () => ({
            type: 'regular',
            amount: 1,
            unit: 'seconds',
          }));

          await step.inApp(
            'send-email',
            async () => ({
              body: digestOutput.events.map((event) => event.payload.comment).join(','),
            }),
            {
              skip: () => true,
            }
          );
        },
        {
          payloadSchema: {
            type: 'object',
            properties: {
              comment: { type: 'string' },
            },
            required: ['comment'],
          } as const,
        }
      );

      await client.addWorkflows([newWorkflow]);

      const event: Event = {
        action: PostActionEnum.PREVIEW,
        workflowId: 'test-workflow',
        stepId: 'send-email',
        subscriber: {},
        state: [
          {
            stepId: 'digest-output',
            state: {
              status: 'success',
            },
            outputs: {
              events: [
                {
                  id: '1',
                  time: '2024-01-01T00:00:00.000Z',
                  payload: {
                    comment: 'Hello',
                  },
                },
                {
                  id: '2',
                  time: '2024-01-01T00:00:00.000Z',
                  payload: {
                    comment: 'World',
                  },
                },
              ],
            },
          },
        ],
        payload: {},
        controls: {},
        context: {},
      };

      const executionResult = await client.executeWorkflow(event);

      expect(executionResult).toBeDefined();
      expect(executionResult.outputs).toBeDefined();
      if (!executionResult.outputs) throw new Error('executionResult.outputs is undefined');

      const { body } = executionResult.outputs;
      expect(body).toBe('Hello,World');

      expect(executionResult.providers).toEqual({});

      const { metadata } = executionResult;
      expect(metadata.status).toBe('success');
      expect(metadata.error).toBe(false);
      expect(metadata.duration).toEqual(expect.any(Number));
    });

    it('should throw an error when workflow ID is invalid', async () => {
      // non-existing workflow ID
      const event: Event = {
        action: PostActionEnum.EXECUTE,
        workflowId: 'non-existent-workflow',
        stepId: 'send-email',
        subscriber: {},
        state: [],
        payload: {},
        controls: {},
        context: {},
      };

      await expect(client.executeWorkflow(event)).rejects.toThrow(WorkflowNotFoundError);

      const newWorkflow = workflow('test-workflow2', async ({ step }) => {
        await step.email('send-email', async () => ({ body: 'Test Body', subject: 'Subject' }));
      });

      await client.addWorkflows([newWorkflow]);

      // @ts-expect-error - no workflow id
      const event2: Event = {
        action: PostActionEnum.EXECUTE,
        stepId: 'send-email',
        subscriber: {},
        state: [],
      };
      await expect(client.executeWorkflow(event2)).rejects.toThrow(WorkflowNotFoundError);
    });

    it('should throw and error when step ID is not found', async () => {
      const newWorkflow = workflow('test-workflow', async ({ step }) => {
        await step.email('send-email', async () => ({ body: 'Test Body', subject: 'Subject' }));
      });

      await client.addWorkflows([newWorkflow]);

      const event: Event = {
        action: PostActionEnum.EXECUTE,
        workflowId: 'test-workflow',
        stepId: 'non-existing-step',
        subscriber: {},
        state: [],
        payload: {},
        controls: {},
        context: {},
      };

      await expect(client.executeWorkflow(event)).rejects.toThrow(ExecutionStateCorruptError);
    });

    it('should throw an error when action is not provided', async () => {
      const newWorkflow = workflow('test-workflow', async ({ step }) => {
        await step.email('send-email', async () => ({ body: 'Test Body', subject: 'Subject' }));
      });

      await client.addWorkflows([newWorkflow]);

      // @ts-expect-error - no action
      const event: Event = {
        workflowId: 'test-workflow',
        stepId: 'send-email',
        subscriber: {},
        state: [],
        controls: {},
      };

      await expect(client.executeWorkflow(event)).rejects.toThrow(Error);
    });

    it('should throw a StepExecutionFailedError error when step execution fails', async () => {
      const newWorkflow = workflow('test-workflow', async ({ step }) => {
        await step.email('send-email', async () => {
          throw new Error('Step execution failed');
        });
      });

      await client.addWorkflows([newWorkflow]);

      const event: Event = {
        action: PostActionEnum.EXECUTE,
        workflowId: 'test-workflow',
        stepId: 'send-email',
        subscriber: {},
        state: [],
        payload: {},
        controls: {},
        context: {},
      };

      await expect(client.executeWorkflow(event)).rejects.toThrow(
        new StepExecutionFailedError('send-email', PostActionEnum.EXECUTE, new Error('Step execution failed'))
      );
    });

    it('should throw a ProviderExecutionFailed error when preview execution fails', async () => {
      const newWorkflow = workflow('test-workflow', async ({ step }) => {
        await step.email(
          'send-email',
          async () => {
            return {
              body: 'Test Body',
              subject: 'Subject',
            };
          },
          {
            providers: {
              sendgrid: () => {
                throw new Error('Preview execution failed');
              },
            },
          }
        );
      });

      await client.addWorkflows([newWorkflow]);

      const event: Event = {
        action: PostActionEnum.EXECUTE,
        workflowId: 'test-workflow',
        stepId: 'send-email',
        subscriber: {},
        state: [],
        payload: {},
        controls: {},
        context: {},
      };

      await expect(client.executeWorkflow(event)).rejects.toThrow(
        new ProviderExecutionFailedError('sendgrid', PostActionEnum.EXECUTE, new Error('Preview execution failed'))
      );
    });

    it('should sanitize the step output of all channel step types by default', async () => {
      const script = `<script>alert('Hello there')</script>`;

      await client.addWorkflows([
        workflow('test-workflow', async ({ step }) => {
          await step.email('send-email', async () => ({
            body: `Start of body. ${script}`,
            subject: `Start of subject. ${script}`,
          }));
        }),
      ]);

      const event: Event = {
        action: PostActionEnum.EXECUTE,
        workflowId: 'test-workflow',
        stepId: 'send-email',
        subscriber: {},
        state: [],
        payload: {},
        controls: {},
        context: {},
      };

      const executionResult = await client.executeWorkflow(event);
      expect(executionResult.outputs).toBeDefined();
      expect(executionResult.outputs.body).toBe('Start of body. ');
      expect(executionResult.outputs.subject).toBe('Start of subject. ');
    });

    it('should sanitize the step output of channel step types when `disableOutputSanitization: false`', async () => {
      const script = `<script>alert('Hello there')</script>`;

      await client.addWorkflows([
        workflow('test-workflow', async ({ step }) => {
          await step.email(
            'send-email',
            async () => ({
              body: `Start of body. ${script}`,
              subject: `Start of subject. ${script}`,
            }),
            {
              disableOutputSanitization: false,
            }
          );
        }),
      ]);

      const event: Event = {
        action: PostActionEnum.EXECUTE,
        workflowId: 'test-workflow',
        stepId: 'send-email',
        subscriber: {},
        state: [],
        payload: {},
        controls: {},
        context: {},
      };

      const executionResult = await client.executeWorkflow(event);
      expect(executionResult.outputs).toBeDefined();
      expect(executionResult.outputs.body).toBe('Start of body. ');
      expect(executionResult.outputs.subject).toBe('Start of subject. ');
    });

    it('should NOT sanitize the step output of channel step type when `disableOutputSanitization: true`', async () => {
      const link =
        '/pipeline/Oee4d54-ca52-4d70-86b3-cd10a67b6810/requirements?requirementId=dc25a578-ecf1-4835-9310-2236f8244bd&commentId=e259b16b-68f9-43af-b252-fce68bc7cb2f';

      await client.addWorkflows([
        workflow('test-workflow', async ({ step }) => {
          await step.inApp(
            'send-inapp',
            async () => ({
              body: `Start of body.`,
              data: {
                someVal: link,
              },
            }),
            {
              disableOutputSanitization: true,
            }
          );
        }),
      ]);

      const event: Event = {
        action: PostActionEnum.EXECUTE,
        workflowId: 'test-workflow',
        stepId: 'send-inapp',
        subscriber: {},
        state: [],
        payload: {},
        controls: {},
        context: {},
      };

      const executionResult = await client.executeWorkflow(event);
      expect(executionResult.outputs).toBeDefined();
      expect((executionResult.outputs.data as any).someVal).toBe(link);
    });

    it('should not sanitize the step result of custom step type', async () => {
      const script = `<script>alert('Hello there')</a>`;

      await client.addWorkflows([
        workflow('test-workflow', async ({ step }) => {
          await step.custom(
            'send-email',
            async () => ({
              testVal: `Start of body. ${script}`,
            }),
            {
              outputSchema: {
                type: 'object',
                properties: {
                  testVal: { type: 'string' },
                },
                required: ['testVal'],
                additionalProperties: false,
              } as const,
            }
          );
        }),
      ]);

      const event: Event = {
        action: PostActionEnum.EXECUTE,
        workflowId: 'test-workflow',
        stepId: 'send-email',
        subscriber: {},
        state: [],
        payload: {},
        controls: {},
        context: {},
      };

      const executionResult = await client.executeWorkflow(event);
      expect(executionResult.outputs).toBeDefined();
      expect(executionResult.outputs.testVal).toBe(`Start of body. ${script}`);
    });
  });

  describe('getCode method', () => {
    let getCodeClientInstance: Client;

    const stepExecuteFunc = async () => ({
      body: 'Test Body',
      subject: 'Subject',
    });

    const workflowExecuteFunc = async ({ step }: { step: Step }) => {
      await step.email('send-email', stepExecuteFunc);
    };

    beforeEach(async () => {
      getCodeClientInstance = new Client({ secretKey: 'some-secret-key' });

      const newWorkflow = workflow('setup-workflow', workflowExecuteFunc);

      await getCodeClientInstance.addWorkflows([newWorkflow]);
    });

    it('should throw an error when workflow ID is not found', () => {
      expect(() => getCodeClientInstance.getCode('non-existent-workflow')).toThrow(WorkflowNotFoundError);
    });

    it('should throw an error when step ID is provided but not found in the workflow', async () => {
      const newWorkflow = workflow('test-workflow', workflowExecuteFunc);

      await getCodeClientInstance.addWorkflows([newWorkflow]);

      expect(() => getCodeClientInstance.getCode('test-workflow', 'non-existent-step')).toThrow(StepNotFoundError);
    });

    it('should return code for the entire workflow when only workflow ID is provided', () => {
      const codeResult = getCodeClientInstance.getCode('setup-workflow');

      expect(codeResult.code).toEqual(workflowExecuteFunc.toString());
    });

    it('should return code for a specific step when both workflow ID and step ID are provided', async () => {
      const codeResult = getCodeClientInstance.getCode('setup-workflow', 'send-email');

      expect(codeResult.code).toEqual(stepExecuteFunc.toString());
    });
  });

  describe('healthCheck method', () => {
    it('should return expected data from healthCheck method', () => {
      const toCheck = client.healthCheck();

      expect(toCheck).toEqual({
        discovered: {
          steps: 1,
          workflows: 1,
        },
        frameworkVersion: FRAMEWORK_VERSION,
        sdkVersion: SDK_VERSION,
        status: 'ok',
      });
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - newWorkflow(workflow('setup-workflow', async ({ step }))
 - client(new Client({ secretKey: 'some-secret-key' });
    await client.addWorkflows([newWorkflow]);
  });

 ...)
 - env({ ...process.env, NOVU_SECRET_KEY: originalSecretKey };
    });

    it('should set secretKey to pro...)
 - newClient(new Client({ secretKey: testSecretKey });
      expect(newClient.secretKey).toBe(testSecretKey);
   ...)
 - newClient(new Client({ apiUrl: testApiUrl });
      expect(newClient.apiUrl).toBe(testApiUrl);
    });

    it...)
 - env({ ...process.env, NODE_ENV: originalEnv };
    });

    it('should set strictAuthentication to false...)
 - env({ ...process.env, NODE_ENV: originalEnv };
    });

    it('should set strictAuthentication to true ...)
 - env({ ...process.env, NODE_ENV: originalEnv };
    });

    it('should set strictAuthentication to provi...)
 - newClient(new Client({ secretKey: 'some-secret-key', strictAuthentication: testStrictAuthentication });
      ...)
 - env({ ...process.env, NOVU_STRICT_AUTHENTICATION_ENABLED: originalEnv };
    });

    it('should set str...)
 - env({ ...process.env, NOVU_STRICT_AUTHENTICATION_ENABLED: originalEnv };
    });
  });

  describe('disc...)
 - discovery(client.discover();
      expect(discovery.workflows).toHaveLength(1);
    });

    it('should discov...)
 - newWorkflow(workflow(workflowId, async ({ step }))
 - inAppRes(await step.inApp('send-in-app', async ())
 - foundWorkflow(discovery.workflows.find((workflowX))
 - stepEmail(foundWorkflow?.steps.find((stepX))
 - stepInApp(foundWorkflow?.steps.find((stepX))
 - stepChat(foundWorkflow?.steps.find((stepX))
 - stepPush(foundWorkflow?.steps.find((stepX))
 - stepCustom(foundWorkflow?.steps.find((stepX))
 - stepSms(foundWorkflow?.steps.find((stepX))
 - stepRegularDigest(foundWorkflow?.steps.find((stepX))
 - stepBackoffDigest(foundWorkflow?.steps.find((stepX))
 - stepTimedDigest(foundWorkflow?.steps.find((stepX))
 - stepDelay(foundWorkflow?.steps.find((stepX))
 - newWorkflow(workflow(workflowId, async ({ step }))
 - foundWorkflow(discovery.workflows.find((workflowX))
 - stepChat(foundWorkflow?.steps.find((stepX))
 - newWorkflow(workflow('test-workflow', async ())
 - discovery(client.discover();
      expect(discovery.workflows).toHaveLength(2);
    });
  });

  describe('pre...)
 - newWorkflow(workflow(
        'test-workflow',
        async ({ step }))
 - newWorkflow(workflow('test-workflow', async ({ step }))
 - emailExecutionResult(await client.executeWorkflow(emailEvent);

      expect(emailExecutionResult).toBeDefined();
      e...)
 - script(`<script>alert('Hello there')</script>`;

      await client.addWorkflows([
        workflow('test-w...)
 - executionResult(await client.executeWorkflow(event);
      expect(executionResult.outputs).toBeDefined();
      expe...)
 - script(`<script>alert('Hello there')</script>`;

      await client.addWorkflows([
        workflow('test-w...)
 - executionResult(await client.executeWorkflow(event);
      expect(executionResult.outputs).toBeDefined();
      expe...)
 - newWorkflow(workflow('test-workflow', async ({ step }))
 - newWorkflow(workflow(
        'test-workflow',
        async ({ step }))
 - newWorkflow(workflow(
        'test-workflow',
        async ({ step }))
 - emailExecutionResult(await client.executeWorkflow(event);

      expect(emailExecutionResult.outputs).toEqual({
        b...)
 - newWorkflow(workflow(
        'test-workflow',
        async ({ step }))
 - emailExecutionResult(await client.executeWorkflow(event);

      expect(emailExecutionResult.outputs).toEqual({
        b...)
 - newWorkflow(workflow(
        'test-workflow',
        async ({ step }))
 - emailExecutionResult(await client.executeWorkflow(event);

      expect(emailExecutionResult.outputs).toEqual({
        b...)
 - newWorkflow(workflow(
        'test-workflow',
        async ({ step }))
 - emailExecutionResult(await client.executeWorkflow(event);

      expect(emailExecutionResult.outputs).toEqual({
        b...)
 - newWorkflow(workflow(
        'test-workflow',
        async ({ step }))
 - emailExecutionResult(await client.executeWorkflow(event);

      expect(emailExecutionResult.outputs).toEqual({
        b...)
 - newWorkflow(workflow('test-workflow', async ({ step }))
 - emailExecutionResult(await client.executeWorkflow(event);

      expect(emailExecutionResult.outputs).toEqual({
        b...)
 - newWorkflow(workflow('test-workflow', async ({ step }))
 - newWorkflow(workflow('test-workflow', async ({ step }))
 - newWorkflow(workflow(
        'test-workflow',
        async ({ step }))
 - emailExecutionResult(await client.executeWorkflow(event);

      // Translation patterns should be preserved when t.* val...)
 - newWorkflow(workflow(
        'test-workflow',
        async ({ step }))
 - emailExecutionResult(await client.executeWorkflow(event);

      expect(emailExecutionResult.outputs).toEqual({
        b...)
 - newWorkflow(workflow('test-workflow', async ({ step }))
 - Event({
        action: PostActionEnum.EXECUTE,
        workflowId: 'test-workflow',
        stepId: 'send...)
 - newWorkflow(workflow('test-workflow', async ({ step }))
 - executionResult(await client.executeWorkflow(event);

      expect(executionResult.providers).toEqual({
        send...)
 - newWorkflow(workflow('test-workflow', async ({ step }))
 - executionResult(await client.executeWorkflow(event);

      expect(executionResult.providers).toEqual({
        send...)
 - newWorkflow(workflow('test-workflow', async ({ step }))
 - executionResult(await client.executeWorkflow(event);

      expect(executionResult.providers).toEqual({
        slac...)
 - newWorkflow(workflow('test-workflow', async ({ step }))
 - Event({
        action: PostActionEnum.EXECUTE,
        workflowId: 'test-workflow',
        stepId: 'acti...)
 - newWorkflow(workflow('test-workflow', async ({ step }))
 - Event({
        action: PostActionEnum.EXECUTE,
        workflowId: 'test-workflow',
        stepId: 'acti...)
 - newWorkflow(workflow('test-workflow', async ({ step }))
 - Event({
        action: PostActionEnum.EXECUTE,
        workflowId: 'test-workflow',
        stepId: 'acti...)
 - newWorkflow(workflow('test-workflow', async ({ step }))
 - Event({
        action: PostActionEnum.EXECUTE,
        workflowId: 'test-workflow',
        stepId: 'acti...)
 - workflowMock(workflow(
        'mock-workflow',
        async ({ step, payload }))
 - executionResult(await client.executeWorkflow(event);
      expect(executionResult).toBeDefined();
      expect(execu...)
 - newWorkflow(workflow('test-workflow', async ({ step }))
 - newWorkflow(workflow('test-workflow', async ({ step }))
 - newWorkflow(workflow('test-workflow', async ({ step }))
 - newWorkflow(workflow(
        'test-workflow',
        async ({ step }))
 - digestOutput(await step.digest('digest-output', async ())
 - newWorkflow(workflow('test-workflow2', async ({ step }))
 - Event({
        action: PostActionEnum.EXECUTE,
        stepId: 'send-email',
        subscriber: {},
    ...)
 - newWorkflow(workflow('test-workflow', async ({ step }))
 - Event({
        action: PostActionEnum.EXECUTE,
        workflowId: 'test-workflow',
        stepId: 'non-...)
 - newWorkflow(workflow('test-workflow', async ({ step }))
 - Event({
        workflowId: 'test-workflow',
        stepId: 'send-email',
        subscriber: {},
       ...)
 - newWorkflow(workflow('test-workflow', async ({ step }))
 - Event({
        action: PostActionEnum.EXECUTE,
        workflowId: 'test-workflow',
        stepId: 'send...)
 - newWorkflow(workflow('test-workflow', async ({ step }))
 - Event({
        action: PostActionEnum.EXECUTE,
        workflowId: 'test-workflow',
        stepId: 'send...)
 - script(`<script>alert('Hello there')</script>`;

      await client.addWorkflows([
        workflow('test-w...)
 - executionResult(await client.executeWorkflow(event);
      expect(executionResult.outputs).toBeDefined();
      expe...)
 - script(`<script>alert('Hello there')</script>`;

      await client.addWorkflows([
        workflow('test-w...)
 - executionResult(await client.executeWorkflow(event);
      expect(executionResult.outputs).toBeDefined();
      expe...)
 - commentId(e259b16b-68f9-43af-b252-fce68bc7cb2f';

      await client.addWorkflows([
        workflow('test-wor...)
 - executionResult(await client.executeWorkflow(event);
      expect(executionResult.outputs).toBeDefined();
      expe...)
 - script(`<script>alert('Hello there')</a>`;

      await client.addWorkflows([
        workflow('test-workfl...)
 - executionResult(await client.executeWorkflow(event);
      expect(executionResult.outputs).toBeDefined();
      expe...)
 - stepExecuteFunc(async ())
 - workflowExecuteFunc(async ({ step }: { step: Step }))
 - newWorkflow(workflow('setup-workflow', workflowExecuteFunc);

      await getCodeClientInstance.addWorkflows([ne...)
 - newWorkflow(workflow('test-workflow', workflowExecuteFunc);

      await getCodeClientInstance.addWorkflows([new...)
 - codeResult(getCodeClientInstance.getCode('setup-workflow');

      expect(codeResult.code).toEqual(workflowExec...)
 - codeResult(getCodeClientInstance.getCode('setup-workflow', 'send-email');

      expect(codeResult.code).toEqua...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/client.ts
Tamaño: 26976 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { jsonrepair } from 'jsonrepair';
import { Liquid } from 'liquidjs';

import { PostActionEnum } from './constants';
import {
  ExecutionEventControlsInvalidError,
  ExecutionEventPayloadInvalidError,
  ExecutionProviderOutputInvalidError,
  ExecutionStateControlsInvalidError,
  ExecutionStateCorruptError,
  ExecutionStateOutputInvalidError,
  ExecutionStateResultInvalidError,
  isFrameworkError,
  ProviderExecutionFailedError,
  ProviderNotFoundError,
  StepControlCompilationFailedError,
  StepExecutionFailedError,
  StepNotFoundError,
  WorkflowNotFoundError,
} from './errors';
import { mockSchema } from './jsonSchemaFaker';
import { prettyPrintDiscovery } from './resources/workflow/pretty-print-discovery';
import type {
  ActionStep,
  ClientOptions,
  CodeResult,
  DiscoverOutput,
  DiscoverProviderOutput,
  DiscoverStepOutput,
  DiscoverWorkflowOutput,
  Event,
  ExecuteOutput,
  HealthCheck,
  Schema,
  Skip,
  State,
  StepType,
  ValidationError,
  Workflow,
} from './types';
import { WithPassthrough } from './types/provider.types';
import { EMOJI, log, resolveApiUrl, resolveSecretKey, sanitizeHtmlInObject } from './utils';
import { createLiquidEngine } from './utils/liquid.utils';
import { deepMerge } from './utils/object.utils';
import { validateData } from './validators';

function isRuntimeInDevelopment() {
  return ['development', undefined, 'dev'].includes(process.env.NODE_ENV);
}

export class Client {
  private discoveredWorkflows = new Map<string, DiscoverWorkflowOutput>();
  private discoverWorkflowPromises = new Map<string, Promise<void>>();

  private templateEngine: Liquid;

  public secretKey: string;

  public apiUrl: string;

  public version: string = SDK_VERSION;

  public strictAuthentication: boolean;

  constructor(options?: ClientOptions) {
    const builtOpts = this.buildOptions(options);
    this.apiUrl = builtOpts.apiUrl;
    this.secretKey = builtOpts.secretKey;
    this.strictAuthentication = builtOpts.strictAuthentication;
    this.templateEngine = createLiquidEngine();
  }

  private buildOptions(providedOptions?: ClientOptions) {
    const builtConfiguration: Required<ClientOptions> = {
      apiUrl: resolveApiUrl(providedOptions?.apiUrl),
      secretKey: resolveSecretKey(providedOptions?.secretKey),
      strictAuthentication: !isRuntimeInDevelopment(),
    };

    if (providedOptions?.strictAuthentication !== undefined) {
      builtConfiguration.strictAuthentication = providedOptions.strictAuthentication;
    } else if (process.env.NOVU_STRICT_AUTHENTICATION_ENABLED !== undefined) {
      builtConfiguration.strictAuthentication = process.env.NOVU_STRICT_AUTHENTICATION_ENABLED === 'true';
    }

    return builtConfiguration;
  }

  /**
   * Adds workflows to the client.
   *
   * A locking mechanism is used to ensure that duplicate workflows are not added.
   *
   * @param workflows - The workflows to add.
   */
  public async addWorkflows(workflows: Array<Workflow>): Promise<void> {
    for (const workflow of workflows) {
      if (this.discoveredWorkflows.has(workflow.id)) {
        continue;
      }

      const existingPromise = this.discoverWorkflowPromises.get(workflow.id);
      if (existingPromise) {
        // Wait for the existing promise to resolve if the workflow is already being added
        await existingPromise;
        continue;
      }

      const workflowPromise = this.addWorkflow(workflow);
      this.discoverWorkflowPromises.set(workflow.id, workflowPromise);

      await workflowPromise;
    }
  }

  private async addWorkflow(workflow: Workflow): Promise<void> {
    try {
      const definition = await workflow.discover();
      prettyPrintDiscovery(definition);
      this.discoveredWorkflows.set(workflow.id, definition);
    } finally {
      this.discoverWorkflowPromises.delete(workflow.id);
    }
  }

  public healthCheck(): HealthCheck {
    const discoveredWorkflows = this.getRegisteredWorkflows();
    const workflowCount = discoveredWorkflows.length;
    const stepCount = discoveredWorkflows.reduce((acc, workflow) => acc + workflow.steps.length, 0);

    return {
      status: 'ok',
      sdkVersion: SDK_VERSION,
      frameworkVersion: FRAMEWORK_VERSION,
      discovered: {
        workflows: workflowCount,
        steps: stepCount,
      },
    };
  }

  private getWorkflow(workflowId: string): DiscoverWorkflowOutput {
    const foundWorkflow = this.discoveredWorkflows.get(workflowId);

    if (foundWorkflow) {
      return foundWorkflow;
    } else {
      throw new WorkflowNotFoundError(workflowId);
    }
  }

  private getStep(workflowId: string, stepId: string): DiscoverStepOutput {
    const workflow = this.getWorkflow(workflowId);

    const foundStep = workflow.steps.find((step) => step.stepId === stepId);

    if (foundStep) {
      return foundStep;
    } else {
      throw new StepNotFoundError(stepId);
    }
  }

  private getRegisteredWorkflows(): Array<DiscoverWorkflowOutput> {
    return Array.from(this.discoveredWorkflows.values());
  }

  public discover(): DiscoverOutput {
    return {
      workflows: this.getRegisteredWorkflows(),
    };
  }

  /**
   * Mocks data based on the given schema.
   * The `default` value in the schema is used as the base data.
   * If no `default` value is provided, the data is generated using JSONSchemaFaker.
   *
   * @param schema
   * @returns mocked data
   */
  private mock(schema: Schema): Record<string, unknown> {
    return mockSchema(schema) as Record<string, unknown>;
  }

  private async validate<T extends Record<string, unknown>>(
    data: T,
    schema: Schema,
    component: 'event' | 'step' | 'provider',
    dataType: 'controls' | 'output' | 'result' | 'payload',
    workflowId: string,
    stepId?: string,
    providerId?: string
  ): Promise<T> {
    const result = await validateData(schema, data);

    if (!result.success) {
      switch (component) {
        case 'event':
          this.throwInvalidEvent(dataType, workflowId, result.errors);

        case 'step':
          this.throwInvalidStep(stepId, dataType, workflowId, result.errors);

        case 'provider':
          this.throwInvalidProvider(stepId, providerId, dataType, workflowId, result.errors);

        default:
          throw new Error(`Invalid component: '${component}'`);
      }
    } else {
      return result.data as T;
    }
  }

  private throwInvalidProvider(
    stepId: string | undefined,
    providerId: string | undefined,
    payloadType: 'controls' | 'output' | 'result' | 'payload',
    workflowId: string,
    errors: Array<ValidationError>
  ) {
    if (!stepId) {
      throw new Error('stepId is required');
    }

    if (!providerId) {
      throw new Error('providerId is required');
    }

    switch (payloadType) {
      case 'output':
        throw new ExecutionProviderOutputInvalidError(workflowId, stepId, providerId, errors);

      default:
        throw new Error(`Invalid payload type: '${payloadType}'`);
    }
  }

  private throwInvalidStep(
    stepId: string | undefined,
    payloadType: 'controls' | 'output' | 'result' | 'payload',
    workflowId: string,
    errors: Array<ValidationError>
  ) {
    if (!stepId) {
      throw new Error('stepId is required');
    }

    switch (payloadType) {
      case 'output':
        throw new ExecutionStateOutputInvalidError(workflowId, stepId, errors);

      case 'result':
        throw new ExecutionStateResultInvalidError(workflowId, stepId, errors);

      case 'controls':
        throw new ExecutionStateControlsInvalidError(workflowId, stepId, errors);

      default:
        throw new Error(`Invalid payload type: '${payloadType}'`);
    }
  }

  private throwInvalidEvent(
    payloadType: 'controls' | 'output' | 'result' | 'payload',
    workflowId: string,
    errors: Array<ValidationError>
  ) {
    switch (payloadType) {
      case 'controls':
        throw new ExecutionEventControlsInvalidError(workflowId, errors);

      case 'payload':
        throw new ExecutionEventPayloadInvalidError(workflowId, errors);

      default:
        throw new Error(`Invalid payload type: '${payloadType}'`);
    }
  }

  private executeStepFactory<T_Outputs extends Record<string, unknown>, T_Result extends Record<string, unknown>>(
    event: Event,
    setResult: (result: Pick<ExecuteOutput, 'outputs' | 'providers' | 'options'>) => void,
    hasResult: () => boolean
  ): ActionStep<T_Outputs, T_Result> {
    return async (stepId, stepResolve, options) => {
      if (hasResult()) {
        /*
         * Exit the execution early if the result has already been set.
         * This is to ensure that we don't evaluate code in steps after the provided stepId.
         */
        return;
      }

      const step = this.getStep(event.workflowId, stepId);
      const isPreview = event.action === PostActionEnum.PREVIEW;

      // Only evaluate a skip condition when the step is the current step and not in preview mode.
      if (!isPreview && stepId === event.stepId) {
        const templateControls = await this.createStepControls(step, event);
        const controls = await this.compileControls(templateControls, event);
        const shouldSkip = await this.shouldSkip(options?.skip as typeof step.options.skip, controls);

        if (shouldSkip) {
          setResult({
            options: { skip: true },
            outputs: {},
            providers: {},
          });

          /*
           * Return an empty object for results when a step is skipped.
           * TODO: fix typings when `skip` is specified to return `Partial<T_Result>`
           */
          return {} as any;
        }
      }

      const previewStepHandler = this.previewStep.bind(this);
      const executeStepHandler = this.executeStep.bind(this);
      const handler = isPreview ? previewStepHandler : executeStepHandler;

      let stepResult = await handler(event, {
        ...step,
        providers: step.providers.map((provider) => {
          // TODO: Update return type to include ChannelStep and fix typings
          const providerResolve = (options as any)?.providers?.[provider.type] as typeof provider.resolve;

          if (!providerResolve) {
            throw new ProviderNotFoundError(provider.type);
          }

          return {
            ...provider,
            resolve: providerResolve,
          };
        }),
        resolve: stepResolve as typeof step.resolve,
      });

      if (this.shouldSanitize({ stepType: step.type, options })) {
        // Sanitize the outputs to avoid XSS attacks via Channel content.
        stepResult = {
          ...stepResult,
          outputs: sanitizeHtmlInObject(stepResult.outputs),
        };
      }

      if (stepId === event.stepId) {
        setResult({
          ...stepResult,
          options: {
            skip: false,
          },
        });
      }

      return stepResult.outputs;
    };
  }

  private shouldSanitize({ stepType, options }: { stepType: StepType; options: ChannelStepOption | undefined }) {
    if (options?.disableOutputSanitization === true) {
      return false;
    }

    return (['email', 'in_app'] as StepType[]).includes(stepType);
  }

  private async shouldSkip<T_Controls extends Record<string, unknown>>(
    skip: Skip<T_Controls> | undefined,
    controls: T_Controls
  ): Promise<boolean> {
    if (!skip) {
      return false;
    }

    return skip(controls);
  }

  public async executeWorkflow(event: Event): Promise<ExecuteOutput> {
    const actionMessages = {
      [PostActionEnum.EXECUTE]: 'Executing',
      [PostActionEnum.PREVIEW]: 'Previewing',
    } as const;

    const actionMessage = actionMessages[event.action];

    const actionMessageFormatted = `${actionMessage} workflowId:`;
    console.log(`\n${log.bold(log.underline(actionMessageFormatted))} '${event.workflowId}'`);
    const workflow = this.getWorkflow(event.workflowId);

    const startTime = process.hrtime();

    let result: Omit<ExecuteOutput, 'metadata'> = {
      outputs: {},
      providers: {},
      options: { skip: false },
    };

    let concludeExecution: (value?: unknown) => void;
    let hasConcludedExecution = false;
    const concludeExecutionPromise = new Promise((resolve) => {
      concludeExecution = resolve;
    });
    /**
     * Set the result of the workflow execution.
     *
     * In order to exit evaluation of the Workflow's `execute` method when the specified
     * `stepId` is reached, we need to `Promise.race` the `concludeExecutionPromise` with the
     * `workflow.execute` method. By resolving the `concludeExecutionPromise` when setting the result,
     * we can ensure that the `workflow.execute` method is not evaluated after the `stepId` is reached.
     *
     * @param stepResult The result of the workflow execution.
     */
    const setResult = (stepResult: Omit<ExecuteOutput, 'metadata'>): void => {
      if (hasConcludedExecution) {
        throw new Error('setResult can only be called once per workflow execution');
      }
      concludeExecution();
      hasConcludedExecution = true;

      result = stepResult;
    };

    const hasResult = (): boolean => hasConcludedExecution;

    let executionError: Error | undefined;
    try {
      if (
        event.action === PostActionEnum.EXECUTE && // TODO: move this validation to the handler layer
        !event.payload
      ) {
        throw new ExecutionEventPayloadInvalidError(event.workflowId, {
          message: 'Event `payload` is required',
        });
      }

      const executionData = await this.createExecutionPayload(event, workflow);
      const validatedEvent = {
        ...event,
        payload: executionData,
      };
      await Promise.race([
        concludeExecutionPromise,
        workflow.execute({
          payload: executionData,
          environment: {},
          controls: {},
          subscriber: event.subscriber,
          context: event.context,
          step: {
            email: this.executeStepFactory(validatedEvent, setResult, hasResult),
            sms: this.executeStepFactory(validatedEvent, setResult, hasResult),
            inApp: this.executeStepFactory(validatedEvent, setResult, hasResult),
            digest: this.executeStepFactory(validatedEvent, setResult, hasResult),
            delay: this.executeStepFactory(validatedEvent, setResult, hasResult),
            push: this.executeStepFactory(validatedEvent, setResult, hasResult),
            chat: this.executeStepFactory(validatedEvent, setResult, hasResult),
            custom: this.executeStepFactory(validatedEvent, setResult, hasResult),
            throttle: this.executeStepFactory(validatedEvent, setResult, hasResult),
          },
        }),
      ]);
    } catch (error) {
      executionError = error as Error;
    }
    const endTime = process.hrtime(startTime);

    const elapsedSeconds = endTime[0];
    const elapsedNanoseconds = endTime[1];
    const elapsedTimeInMilliseconds = elapsedSeconds * 1_000 + elapsedNanoseconds / 1_000_000;

    const emoji = executionError ? EMOJI.ERROR : EMOJI.SUCCESS;
    const resultMessages = {
      [PostActionEnum.EXECUTE]: 'Executed',
      [PostActionEnum.PREVIEW]: 'Previewed',
    } as const;
    const resultMessage = resultMessages[event.action];

    console.log(`${emoji} ${resultMessage} workflowId: \`${event.workflowId}\``);

    this.prettyPrintExecute(event, elapsedTimeInMilliseconds, executionError);

    if (executionError) {
      throw executionError;
    }

    return {
      outputs: result.outputs,
      providers: result.providers,
      options: result.options,
      metadata: {
        status: 'success',
        error: false,
        duration: elapsedTimeInMilliseconds,
      },
    };
  }

  private async createExecutionPayload(
    event: Event,
    workflow: DiscoverWorkflowOutput
  ): Promise<Record<string, unknown>> {
    let { payload } = event;
    if (event.action === PostActionEnum.PREVIEW) {
      const mockResult = this.mock(workflow.payload.schema);

      payload = Object.assign(mockResult, payload);
    }

    const validatedPayload = await this.validate(
      payload,
      workflow.payload.unknownSchema,
      'event',
      'payload',
      event.workflowId
    );

    return validatedPayload;
  }

  private prettyPrintExecute(event: Event, duration: number, error?: Error): void {
    const successPrefix = error ? EMOJI.ERROR : EMOJI.SUCCESS;
    const actionMessages = {
      [PostActionEnum.EXECUTE]: 'Executed',
      [PostActionEnum.PREVIEW]: 'Previewed',
    } as const;
    const actionMessage = actionMessages[event.action];
    const message = error ? 'Failed to execute' : actionMessage;
    const executionLog = error ? log.error : log.success;
    const logMessage = `${successPrefix} ${message} workflowId: '${event.workflowId}`;
    console.log(`\n  ${log.bold(executionLog(logMessage))}'`);
    console.log(`  ├ ${EMOJI.STEP} stepId: '${event.stepId}'`);
    console.log(`  ├ ${EMOJI.ACTION} action: '${event.action}'`);
    console.log(`  └ ${EMOJI.DURATION} duration: '${duration.toFixed(2)}ms'\n`);
  }

  private async executeProviders(
    event: Event,
    step: DiscoverStepOutput,
    outputs: Record<string, unknown>
  ): Promise<Record<string, WithPassthrough<Record<string, unknown>>>> {
    return step.providers.reduce(
      async (acc, provider) => {
        const result = await acc;
        const previewProviderHandler = this.previewProvider.bind(this);
        const executeProviderHandler = this.executeProvider.bind(this);
        const handler = event.action === PostActionEnum.PREVIEW ? previewProviderHandler : executeProviderHandler;

        const providerResult = await handler(event, step, provider, outputs);

        return {
          ...result,
          [provider.type]: providerResult,
        };
      },
      Promise.resolve({} as Record<string, WithPassthrough<Record<string, unknown>>>)
    );
  }

  private previewProvider(
    event: Event,
    step: DiscoverStepOutput,
    provider: DiscoverProviderOutput,

    outputs: Record<string, unknown>
  ): Record<string, unknown> {
    console.log(`  ${EMOJI.MOCK} Mocked provider: \`${provider.type}\``);
    const mockOutput = this.mock(provider.outputs.schema);

    return mockOutput;
  }

  private async executeProvider(
    event: Event,
    step: DiscoverStepOutput,
    provider: DiscoverProviderOutput,
    outputs: Record<string, unknown>
  ): Promise<WithPassthrough<Record<string, unknown>>> {
    try {
      if (event.stepId === step.stepId) {
        const controls = await this.createStepControls(step, event);
        const result = await provider.resolve({
          controls,
          outputs,
        });
        const validatedOutput = await this.validate(
          result,
          provider.outputs.unknownSchema,
          'step',
          'output',
          event.workflowId,
          step.stepId,
          provider.type
        );
        console.log(`  ${EMOJI.SUCCESS} Executed provider: \`${provider.type}\``);

        return {
          ...validatedOutput,
          _passthrough: result._passthrough,
        };
      } else {
        // No-op. We don't execute providers for hydrated steps
        console.log(`  ${EMOJI.HYDRATED} Hydrated provider: \`${provider.type}\``);

        return {};
      }
    } catch (error) {
      console.log(`  ${EMOJI.ERROR} Failed to execute provider: \`${provider.type}\``);

      throw new ProviderExecutionFailedError(provider.type, event.action, error);
    }
  }

  private async executeStep(
    event: Event,
    step: DiscoverStepOutput
  ): Promise<Pick<ExecuteOutput, 'outputs' | 'providers'>> {
    if (event.stepId === step.stepId) {
      try {
        const templateControls = await this.createStepControls(step, event);
        const controls = await this.compileControls(templateControls, event);
        const output = await step.resolve(controls);
        const validatedOutput = await this.validate(
          output,
          step.outputs.unknownSchema,
          'step',
          'output',
          event.workflowId,
          step.stepId
        );

        const providers = await this.executeProviders(event, step, validatedOutput);

        console.log(`  ${EMOJI.SUCCESS} Executed stepId: \`${step.stepId}\``);

        return {
          outputs: validatedOutput,
          providers,
        };
      } catch (error) {
        console.log(`  ${EMOJI.ERROR} Failed to execute stepId: \`${step.stepId}\``);
        if (isFrameworkError(error)) {
          throw error;
        } else {
          throw new StepExecutionFailedError(step.stepId, event.action, error);
        }
      }
    } else {
      try {
        const result = this.getStepState(event, step.stepId);

        if (result) {
          const validatedOutput = await this.validate(
            result.outputs,
            step.results.unknownSchema,
            'step',
            'result',
            event.workflowId,
            step.stepId
          );
          console.log(`  ${EMOJI.HYDRATED} Hydrated stepId: \`${step.stepId}\``);

          return {
            outputs: validatedOutput,
            providers: await this.executeProviders(event, step, validatedOutput),
          };
        } else {
          throw new ExecutionStateCorruptError(event.workflowId, step.stepId);
        }
      } catch (error) {
        console.log(`  ${EMOJI.ERROR} Failed to hydrate stepId: \`${step.stepId}\``);

        throw error;
      }
    }
  }

  private async compileControls(templateControls: Record<string, unknown>, event: Event) {
    try {
      const templateString = this.preprocessTranslationPatterns(JSON.stringify(templateControls));
      const parsedTemplate = this.templateEngine.parse(templateString);
      const discoveredWorkflow = this.getWorkflow(event.workflowId);

      const renderVariables = {
        workflow: {
          workflowId: discoveredWorkflow.workflowId,
          name: discoveredWorkflow.name,
          description: discoveredWorkflow.description,
          tags: discoveredWorkflow.tags,
          severity: discoveredWorkflow.severity,
        },
        payload: event.payload,
        subscriber: event.subscriber,
        context: event.context,
        steps: buildSteps(event.state),
        t: {}, // Empty object so t.* properties are undefined and trigger default filters
      };

      const compiledString = await this.templateEngine.render(parsedTemplate, renderVariables);
      // repair the string to fix invalid JSON, it could happen in the case when the control value
      // doesn't have escaped quotes like '"foo"' then compiled string '{"body":""foo""}' is not valid JSON and parse will fail
      const repairedString = jsonrepair(compiledString);
      return JSON.parse(repairedString);
    } catch (error) {
      throw new StepControlCompilationFailedError(event.workflowId, event.stepId, error);
    }
  }

  /**
   * Preprocesses translation patterns to preserve them when values are undefined.
   * Transforms {{t.key}} to {{t.key | default: "{{t.key}}"}}
   */
  private preprocessTranslationPatterns(template: string): string {
    return template.replace(/\{\{\s*t\.([\p{L}\p{N}_.-]+)\s*\}\}/gu, '{{ t.$1 | default: "{{t.$1}}" }}');
  }

  /**
   * Create the controls for a step, taking both the event controls and the default controls into account
   *
   * @param step The step to create the controls for
   * @param event The event that triggered the step
   * @returns The controls for the step
   */
  private async createStepControls(step: DiscoverStepOutput, event: Event): Promise<Record<string, unknown>> {
    const validatedControls = await this.validate(
      event.controls,
      step.controls.unknownSchema,
      'step',
      'controls',
      event.workflowId,
      step.stepId
    );

    return validatedControls;
  }

  private async previewStep(
    event: Event,
    step: DiscoverStepOutput
  ): Promise<Pick<ExecuteOutput, 'outputs' | 'providers'>> {
    try {
      return await this.constructStepForPreview(event, step);
    } catch (error) {
      console.log(`  ${EMOJI.ERROR} Failed to preview stepId: \`${step.stepId}\``);

      if (isFrameworkError(error)) {
        throw error;
      } else {
        throw new StepExecutionFailedError(step.stepId, event.action, error);
      }
    }
  }

  private async constructStepForPreview(event: Event, step: DiscoverStepOutput) {
    if (event.stepId === step.stepId) {
      return await this.previewRequiredStep(step, event);
    } else {
      return await this.extractMockDataForPreviousSteps(event, step);
    }
  }

  private async extractMockDataForPreviousSteps(event: Event, step: DiscoverStepOutput) {
    const outputs: Record<string, unknown> = {};
    const suppliedResult = this.getStepState(event, step.stepId);
    const mockedOutputs = this.mock(step.results.schema);

    const mergedOutput = deepMerge(mockedOutputs, suppliedResult?.outputs || {});

    return {
      outputs: mergedOutput,
      providers: await this.executeProviders(event, step, outputs),
    };
  }

  private async previewRequiredStep(step: DiscoverStepOutput, event: Event) {
    const templateControls = await this.createStepControls(step, event);
    const controls = await this.compileControls(templateControls, event);

    const previewOutput = await step.resolve(controls);
    const validatedOutput = await this.validate(
      previewOutput,
      step.outputs.unknownSchema,
      'step',
      'output',
      event.workflowId,
      step.stepId
    );

    console.log(`  ${EMOJI.MOCK} Mocked stepId: \`${step.stepId}\``);

    return {
      outputs: validatedOutput,
      providers: await this.executeProviders(event, step, validatedOutput),
    };
  }

  private getStepState(event: Event, stepId: string): State | undefined {
    return event.state.find((state) => state.stepId === stepId);
  }

  private getStepCode(workflowId: string, stepId: string): CodeResult {
    const step = this.getStep(workflowId, stepId);

    return {
      code: step.resolve.toString(),
    };
  }

  private getWorkflowCode(workflowId: string): CodeResult {
    const workflow = this.getWorkflow(workflowId);

    return {
      code: workflow.execute.toString(),
    };
  }

  public getCode(workflowId: string, stepId?: string): CodeResult {
    let getCodeResult: CodeResult;

    if (!workflowId) {
      throw new WorkflowNotFoundError(workflowId);
    } else if (stepId) {
      getCodeResult = this.getStepCode(workflowId, stepId);
    } else {
      getCodeResult = this.getWorkflowCode(workflowId);
    }

    return getCodeResult;
  }
}
function buildSteps(stateArray: State[]) {
  const result: Record<string, Record<string, unknown>> = {};

  for (const state of stateArray) {
    result[state.stepId] = state.outputs; // Map stepId to outputs
  }

  return result;
}

type ChannelStepOption = {
  disableOutputSanitization?: boolean;
  [key: string]: unknown;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - isRuntimeInDevelopment()
 - buildSteps(stateArray: State[])
Asignaciones con arrow functions encontradas (posibles funciones):
 - stepCount(discoveredWorkflows.reduce((acc, workflow))
 - foundStep(workflow.steps.find((step))
 - result(await validateData(schema, data);

    if (!result.success) {
      switch (component) {
        cas...)
 - stepResult(await handler(event, {
        ...step,
        providers: step.providers.map((provider))
 - concludeExecutionPromise(new Promise((resolve))
 - setResult(stepResult: Omit<ExecuteOutput, 'metadata'>): void)
 - hasResult(): boolean)
 - logMessage(`${successPrefix} ${message} workflowId: '${event.workflowId}`;
    console.log(`\n  ${log.bold(exec...)
 - validatedOutput(await this.validate(
      previewOutput,
      step.outputs.unknownSchema,
      'step',
      'out...)
Declaraciones 'export' encontradas:
- export class Client

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/client.validation.test.ts
Tamaño: 2524 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { beforeEach, describe, expect, it } from 'vitest';
import { Client } from './client';
import { PostActionEnum } from './constants';
import { ExecutionStateControlsInvalidError } from './errors';
import { workflow } from './resources/workflow';

describe('validation', () => {
  let client: Client;

  beforeEach(() => {
    client = new Client({ secretKey: 'some-secret-key' });
  });

  const jsonSchema = {
    type: 'object',
    properties: {
      foo: { type: 'string' },
      baz: { type: 'number' },
    },
    required: ['foo', 'baz'],
    additionalProperties: false,
  } as const;

  it('should transform a JSON schema to a valid schema during discovery', async () => {
    await client.addWorkflows([
      workflow('json-schema-validation', async ({ step }) => {
        await step.email(
          'json-schema-validation',
          async () => ({
            subject: 'Test subject',
            body: 'Test body',
          }),
          {
            controlSchema: jsonSchema,
          }
        );
      }),
    ]);

    const discoverResult = client.discover();
    const stepControlSchema = discoverResult.workflows[0].steps[0].controls.schema;

    expect(stepControlSchema).to.deep.include(jsonSchema);
  });

  it('should throw an error if a property is missing', async () => {
    await client.addWorkflows([
      workflow('json-schema-validation', async ({ step }) => {
        await step.email(
          'test-email',
          async () => ({
            subject: 'Test subject',
            body: 'Test body',
          }),
          {
            controlSchema: jsonSchema,
          }
        );
      }),
    ]);

    try {
      await client.executeWorkflow({
        action: PostActionEnum.EXECUTE,
        workflowId: 'json-schema-validation',
        controls: {
          foo: '341',
        },
        payload: {},
        stepId: 'test-email',
        state: [],
        subscriber: {},
        context: {},
      });
    } catch (error) {
      expect(error).to.be.instanceOf(ExecutionStateControlsInvalidError);
      expect((error as ExecutionStateControlsInvalidError).message).to.equal(
        'Workflow with id: `json-schema-validation` has an invalid state. Step with id: `test-email` has invalid `controls`. Please provide the correct step controls.'
      );
      expect((error as ExecutionStateControlsInvalidError).data).to.deep.equal([
        {
          message: "must have required property 'baz'",
          path: '',
        },
      ]);
    }
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - jsonSchema({
    type: 'object',
    properties: {
      foo: { type: 'string' },
      baz: { type: 'number' }...)
 - stepControlSchema(discoverResult.workflows[0].steps[0].controls.schema;

    expect(stepControlSchema).to.deep.include...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/globals.d.ts
Tamaño: 95 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export {};

declare global {
  const SDK_VERSION: string;
  const FRAMEWORK_VERSION: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/handler.test.ts
Tamaño: 2303 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { beforeEach, describe, expect, it, vi } from 'vitest';

import { Client } from './client';
import { NovuRequestHandler } from './handler';

describe('NovuRequestHandler', () => {
  let client: Client;

  beforeEach(() => {
    client = new Client({ secretKey: 'some-secret-key' });
  });

  describe('triggerAction', () => {
    it('should call global.fetch when triggerAction is invoked', async () => {
      const handlerOptions = {
        frameworkName: 'test-framework',
        workflows: [],
        handler: vi.fn(),
        client,
      };

      const requestHandler = new NovuRequestHandler(handlerOptions);

      const triggerEvent = {
        workflowId: 'test-workflow',
        to: 'test@example.com',
        payload: {},
        transactionId: 'test-transaction',
        overrides: {},
        actor: undefined,
        tenant: undefined,
        bridgeUrl: 'http://example.com',
      };

      const { workflowId, ...renamedWorkflowId } = { ...triggerEvent, name: triggerEvent.workflowId };

      const postMock = vi.fn().mockResolvedValueOnce({
        ok: true,
        json: () => {
          return Promise.resolve({ test: 'ok' });
        },
      });
      global.fetch = postMock;

      await requestHandler.triggerAction(triggerEvent)();

      const expectedBody = renamedWorkflowId;
      const expectedHeaders = {
        Authorization: 'ApiKey some-secret-key',
        'Content-Type': 'application/json',
      };
      const expectedMethod = 'POST';
      const expectedPayload = { body: expectedBody, headers: expectedHeaders, method: expectedMethod };

      const calledWithUrl = postMock.mock.calls[0][0];
      expect(calledWithUrl).toEqual('https://api.novu.co/v1/events/trigger');

      const calledWithBody = postMock.mock.calls[0][1].body;
      // we parse the body in order to compare the objects with more predictable results versus strings
      const parsedCalledBody = JSON.parse(calledWithBody);
      expect(parsedCalledBody).toEqual(expectedPayload.body);

      const calledWithMethod = postMock.mock.calls[0][1].method;
      expect(calledWithMethod).toEqual(expectedPayload.method);

      const calledWithHeaders = postMock.mock.calls[0][1].headers;
      expect(calledWithHeaders).toEqual(expectedPayload.headers);
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - client(new Client({ secretKey: 'some-secret-key' });
  });

  describe('triggerAction', ())
 - postMock(vi.fn().mockResolvedValueOnce({
        ok: true,
        json: ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/handler.ts
Tamaño: 10263 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Client } from './client';
import {
  GetActionEnum,
  HttpHeaderKeysEnum,
  HttpMethodEnum,
  HttpQueryKeysEnum,
  HttpStatusEnum,
  PostActionEnum,
  SIGNATURE_TIMESTAMP_TOLERANCE,
} from './constants';
import {
  BridgeError,
  FrameworkError,
  InvalidActionError,
  isFrameworkError,
  MethodNotAllowedError,
  SignatureExpiredError,
  SignatureInvalidError,
  SignatureMismatchError,
  SignatureNotFoundError,
  SigningKeyNotFoundError,
} from './errors';
import { isPlatformError } from './errors/guard.errors';
import type { Awaitable, EventTriggerParams, Workflow } from './types';
import { createHmacSubtle, initApiClient } from './utils';

export type ServeHandlerOptions = {
  client?: Client;
  workflows: Array<Workflow>;
};

export type INovuRequestHandlerOptions<Input extends any[] = any[], Output = any> = ServeHandlerOptions & {
  frameworkName: string;
  client?: Client;
  workflows: Array<Workflow>;
  handler: Handler<Input, Output>;
};

type Handler<Input extends any[] = any[], Output = any> = (...args: Input) => HandlerResponse<Output>;

type HandlerResponse<Output = any> = {
  body: () => Awaitable<any>;
  headers: (key: string) => Awaitable<string | null | undefined>;
  method: () => Awaitable<string>;
  queryString?: (key: string, url: URL) => Awaitable<string | null | undefined>;
  url: () => Awaitable<URL>;
  transformResponse: (res: IActionResponse<string>) => Output;
};

export type IActionResponse<TBody extends string = string> = {
  status: number;
  headers: Record<string, string>;
  body: TBody;
};

export class NovuRequestHandler<Input extends any[] = any[], Output = any> {
  public readonly frameworkName: string;

  public readonly handler: Handler<Input, Output>;

  public readonly client: Client;
  private readonly hmacEnabled: boolean;
  private readonly http;
  private readonly workflows: Array<Workflow>;

  constructor(options: INovuRequestHandlerOptions<Input, Output>) {
    this.handler = options.handler;
    this.client = options.client ? options.client : new Client();
    this.workflows = options.workflows;
    this.http = initApiClient(this.client.secretKey, this.client.apiUrl);
    this.frameworkName = options.frameworkName;
    this.hmacEnabled = this.client.strictAuthentication;
  }

  public createHandler(): (...args: Input) => Promise<Output> {
    return async (...args: Input) => {
      await this.client.addWorkflows(this.workflows);
      const actions = await this.handler(...args);
      const actionResponse = await this.handleAction({
        actions,
      });

      return actions.transformResponse(actionResponse);
    };
  }

  private getStaticHeaders(): Partial<Record<HttpHeaderKeysEnum, string>> {
    const sdkVersion = `novu-framework:v${this.client.version}`;

    return {
      [HttpHeaderKeysEnum.CONTENT_TYPE]: 'application/json',
      [HttpHeaderKeysEnum.ACCESS_CONTROL_ALLOW_ORIGIN]: '*',
      [HttpHeaderKeysEnum.ACCESS_CONTROL_ALLOW_METHODS]: 'GET, POST',
      [HttpHeaderKeysEnum.ACCESS_CONTROL_ALLOW_HEADERS]: '*',
      [HttpHeaderKeysEnum.ACCESS_CONTROL_MAX_AGE]: '604800',
      [HttpHeaderKeysEnum.NOVU_FRAMEWORK_VERSION]: FRAMEWORK_VERSION,
      [HttpHeaderKeysEnum.NOVU_FRAMEWORK_SDK]: SDK_VERSION,
      [HttpHeaderKeysEnum.NOVU_FRAMEWORK_SERVER]: this.frameworkName,
      [HttpHeaderKeysEnum.USER_AGENT]: sdkVersion,
    };
  }

  private createResponse<TBody extends string = string>(status: number, body: unknown): IActionResponse<TBody> {
    return {
      status,
      body: JSON.stringify(body) as TBody,
      headers: {
        ...this.getStaticHeaders(),
      },
    };
  }

  private createError<TBody extends string = string>(error: FrameworkError): IActionResponse<TBody> {
    return {
      status: error.statusCode,
      body: JSON.stringify({
        message: error.message,
        data: error.data,
        code: error.code,
      }) as TBody,
      headers: this.getStaticHeaders(),
    };
  }

  private async handleAction({ actions }: { actions: HandlerResponse<Output> }): Promise<IActionResponse> {
    const url = await actions.url();
    const method = await actions.method();
    const action = url.searchParams.get(HttpQueryKeysEnum.ACTION) || GetActionEnum.HEALTH_CHECK;
    const workflowId = url.searchParams.get(HttpQueryKeysEnum.WORKFLOW_ID) || '';
    const stepId = url.searchParams.get(HttpQueryKeysEnum.STEP_ID) || '';
    const signatureHeader = (await actions.headers(HttpHeaderKeysEnum.NOVU_SIGNATURE)) || '';

    let body: Record<string, unknown> = {};
    try {
      if (method === HttpMethodEnum.POST) {
        body = await actions.body();
      }
    } catch (error) {
      // NO-OP - body was not provided
    }

    try {
      if (action !== GetActionEnum.HEALTH_CHECK) {
        await this.validateHmac(body, signatureHeader);
      }

      const postActionMap = this.getPostActionMap(body, workflowId, stepId, action);
      const getActionMap = this.getGetActionMap(workflowId, stepId);

      if (method === HttpMethodEnum.POST) {
        return await this.handlePostAction(action, postActionMap);
      }

      if (method === HttpMethodEnum.GET) {
        return await this.handleGetAction(action, getActionMap);
      }

      if (method === HttpMethodEnum.OPTIONS) {
        return this.createResponse(HttpStatusEnum.OK, {});
      }
    } catch (error) {
      return this.handleError(error);
    }

    return this.createError(new MethodNotAllowedError(method));
  }

  private getPostActionMap(
    // TODO: add validation for body per action.
    body: any,
    workflowId: string,
    stepId: string,
    action: string
  ): Record<PostActionEnum, () => Promise<IActionResponse>> {
    return {
      [PostActionEnum.TRIGGER]: this.triggerAction({ workflowId, ...body }),
      [PostActionEnum.EXECUTE]: async () => {
        const result = await this.client.executeWorkflow({
          ...body,
          workflowId,
          stepId,
          action,
        });

        return this.createResponse(HttpStatusEnum.OK, result);
      },
      [PostActionEnum.PREVIEW]: async () => {
        const result = await this.client.executeWorkflow({
          ...body,
          workflowId,
          stepId,
          action,
        });

        return this.createResponse(HttpStatusEnum.OK, result);
      },
    };
  }

  public triggerAction(triggerEvent: EventTriggerParams) {
    return async () => {
      const requestPayload = {
        name: triggerEvent.workflowId,
        to: triggerEvent.to,
        payload: triggerEvent?.payload || {},
        transactionId: triggerEvent.transactionId,
        overrides: triggerEvent.overrides || {},
        ...(triggerEvent.actor && { actor: triggerEvent.actor }),
        ...(triggerEvent.bridgeUrl && { bridgeUrl: triggerEvent.bridgeUrl }),
        ...(triggerEvent.controls && { controls: triggerEvent.controls }),
        ...(triggerEvent.context && { context: triggerEvent.context }),
      };

      const result = await this.http.post('/events/trigger', requestPayload);

      return this.createResponse(HttpStatusEnum.OK, result);
    };
  }

  private getGetActionMap(workflowId: string, stepId: string): Record<GetActionEnum, () => Promise<IActionResponse>> {
    return {
      [GetActionEnum.DISCOVER]: async () => {
        const result = await this.client.discover();

        return this.createResponse(HttpStatusEnum.OK, result);
      },
      [GetActionEnum.HEALTH_CHECK]: async () => {
        const result = await this.client.healthCheck();

        return this.createResponse(HttpStatusEnum.OK, result);
      },
      [GetActionEnum.CODE]: async () => {
        const result = await this.client.getCode(workflowId, stepId);

        return this.createResponse(HttpStatusEnum.OK, result);
      },
    };
  }

  private async handlePostAction(
    action: string,
    postActionMap: Record<PostActionEnum, () => Promise<IActionResponse>>
  ): Promise<IActionResponse> {
    if (Object.values(PostActionEnum).includes(action as PostActionEnum)) {
      const actionFunction = postActionMap[action as PostActionEnum];

      return actionFunction();
    } else {
      throw new InvalidActionError(action, PostActionEnum);
    }
  }

  private async handleGetAction(
    action: string,
    getActionMap: Record<GetActionEnum, () => Promise<IActionResponse>>
  ): Promise<IActionResponse> {
    if (Object.values(GetActionEnum).includes(action as GetActionEnum)) {
      const actionFunction = getActionMap[action as GetActionEnum];

      return actionFunction();
    } else {
      throw new InvalidActionError(action, GetActionEnum);
    }
  }

  private handleError(error: unknown): IActionResponse {
    if (isFrameworkError(error)) {
      if (error.statusCode >= 500) {
        /*
         * Log bridge server errors to assist the Developer in debugging errors with their integration.
         * This path is reached when the Bridge application throws an error, ensuring they can see the error in their logs.
         */
        console.error(error);
      }

      return this.createError(error);
    } else if (isPlatformError(error)) {
      return this.createError(error);
    } else {
      const bridgeError = new BridgeError(error);
      console.error(bridgeError);

      return this.createError(bridgeError);
    }
  }

  private async validateHmac(payload: unknown, hmacHeader: string | null): Promise<void> {
    if (!this.hmacEnabled) return;
    if (!hmacHeader) {
      throw new SignatureNotFoundError();
    }

    if (!this.client.secretKey) {
      throw new SigningKeyNotFoundError();
    }

    const [timestampPart, signaturePart] = hmacHeader.split(',');
    if (!timestampPart || !signaturePart) {
      throw new SignatureInvalidError();
    }

    const [timestamp, timestampPayload] = timestampPart.split('=');

    const [signatureVersion, signaturePayload] = signaturePart.split('=');

    if (Number(timestamp) < Date.now() - SIGNATURE_TIMESTAMP_TOLERANCE) {
      throw new SignatureExpiredError();
    }

    const localHash = await createHmacSubtle(this.client.secretKey, `${timestampPayload}.${JSON.stringify(payload)}`);

    const isMatching = localHash === signaturePayload;

    if (!isMatching) {
      throw new SignatureMismatchError();
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - hmacEnabled(this.client.strictAuthentication;
  }

  public createHandler(): (...args: Input))
 - result(await this.client.executeWorkflow({
          ...body,
          workflowId,
          stepId,
     ...)
 - result(await this.client.executeWorkflow({
          ...body,
          workflowId,
          stepId,
     ...)
 - result(await this.http.post('/events/trigger', requestPayload);

      return this.createResponse(HttpStatu...)
 - result(await this.client.discover();

        return this.createResponse(HttpStatusEnum.OK, result);
      ...)
 - result(await this.client.healthCheck();

        return this.createResponse(HttpStatusEnum.OK, result);
   ...)
 - result(await this.client.getCode(workflowId, stepId);

        return this.createResponse(HttpStatusEnum.OK...)
 - actionFunction(postActionMap[action as PostActionEnum];

      return actionFunction();
    } else {
      throw ne...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export class NovuRequestHandler

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/index.ts
Tamaño: 295 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export { Client } from './client';
export { CronExpression } from './constants';
export { NovuRequestHandler, type ServeHandlerOptions } from './handler';
export { workflow } from './resources';
export { providerSchemas } from './schemas';
export { SeverityLevelEnum, Workflow } from './types';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/jsonSchemaFaker.js
Tamaño: 234446 bytes
Lenguaje detectado: JavaScript

### CONTENIDO ORIGINAL ###

/*
 * Json-schema-faker is causing big HMR and Webpack headaches when @novu/framework is used in Next.js.
 * To address the issue, we decided to go old-school and hardcode the IIFE version of the source code in our package.
 *
 * The code was copied for https://unpkg.com/browse/json-schema-faker@0.5.6/dist/main.iife.js.
 *
 * PLEASE NOTE THE CODE WAS SLIGHTLY MODIFIED TO MAKE IT WORK IN @novu/framework. See the end of this file.
 *
 * See https://github.com/json-schema-faker/json-schema-faker/issues/796#issuecomment-2433335751.
 */
const JSONSchemaFaker = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) =>
    function __init() {
      return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])((fn = 0))), res;
    };
  var __commonJS = (cb, mod) =>
    function __require() {
      return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
    };
  var __export = (target, all) => {
    for (var name in all) __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if ((from && typeof from === 'object') || typeof from === 'function') {
      for (const key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, {
            get: () => from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable,
          });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, '__esModule', { value: true }), mod);

  // src/shared.js
  var shared_exports = {};
  __export(shared_exports, {
    JSONSchemaFaker: () => JSONSchemaFaker,
    default: () => lib_default,
    setDependencies: () => setDependencies,
  });
  function optionAPI(nameOrOptionMap, optionalValue) {
    if (typeof nameOrOptionMap === 'string') {
      if (typeof optionalValue !== 'undefined') {
        return registry.register(nameOrOptionMap, optionalValue);
      }
      return registry.get(nameOrOptionMap);
    }
    return registry.registerMany(nameOrOptionMap);
  }
  function getRandomInteger(min, max) {
    min = typeof min === 'undefined' ? constants_default.MIN_INTEGER : min;
    max = typeof max === 'undefined' ? constants_default.MAX_INTEGER : max;
    return Math.floor(option_default('random')() * (max - min + 1)) + min;
  }
  function _randexp(value) {
    import_randexp.default.prototype.max = option_default('defaultRandExpMax');
    import_randexp.default.prototype.randInt = (a, b) => a + Math.floor(option_default('random')() * (1 + (b - a)));
    const re = new import_randexp.default(value);
    return re.gen();
  }
  function pick(collection) {
    return collection[Math.floor(option_default('random')() * collection.length)];
  }
  function shuffle(collection) {
    let tmp;
    let key;
    let length = collection.length;
    const copy = collection.slice();
    for (; length > 0; ) {
      key = Math.floor(option_default('random')() * length);
      length -= 1;
      tmp = copy[length];
      copy[length] = copy[key];
      copy[key] = tmp;
    }
    return copy;
  }
  function getRandom(min, max) {
    return option_default('random')() * (max - min) + min;
  }
  function number(min, max, defMin, defMax, hasPrecision = false) {
    defMin = typeof defMin === 'undefined' ? constants_default.MIN_NUMBER : defMin;
    defMax = typeof defMax === 'undefined' ? constants_default.MAX_NUMBER : defMax;
    min = typeof min === 'undefined' ? defMin : min;
    max = typeof max === 'undefined' ? defMax : max;
    if (max < min) {
      max += min;
    }
    if (hasPrecision) {
      return getRandom(min, max);
    }
    return getRandomInteger(min, max);
  }
  function by(type) {
    switch (type) {
      case 'seconds':
        return number(0, 60) * 60;
      case 'minutes':
        return number(15, 50) * 612;
      case 'hours':
        return number(12, 72) * 36123;
      case 'days':
        return number(7, 30) * 86412345;
      case 'weeks':
        return number(4, 52) * 604812345;
      case 'months':
        return number(2, 13) * 2592012345;
      case 'years':
        return number(1, 20) * 31104012345;
      default:
        break;
    }
  }
  function date(step) {
    if (step) {
      return by(step);
    }
    let earliest = option_default('minDateTime');
    let latest = option_default('maxDateTime');
    if (typeof earliest === 'string') {
      earliest = new Date(earliest);
    }
    if (typeof latest === 'string') {
      latest = new Date(latest);
    }
    const now = /* @__PURE__ */ new Date().getTime();
    if (typeof earliest === 'number') {
      earliest = new Date(now + earliest);
    }
    if (typeof latest === 'number') {
      latest = new Date(now + latest);
    }
    return new Date(getRandom(earliest.getTime(), latest.getTime()));
  }
  function getLocalRef(obj, path, refs) {
    path = decodeURIComponent(path);
    if (refs && refs[path]) return clone(refs[path]);
    const keyElements = path.replace('#/', '/').split('/');
    let schema = (obj.$ref && refs && refs[obj.$ref]) || obj;
    if (!schema && !keyElements[0]) {
      keyElements[0] = obj.$ref.split('#/')[0];
    }
    if (refs && path.includes('#/') && refs[keyElements[0]]) {
      schema = refs[keyElements.shift()];
    }
    if (!keyElements[0]) keyElements.shift();
    while (schema && keyElements.length > 0) {
      const prop = keyElements.shift();
      if (!schema[prop]) {
        throw new Error(`Prop not found: ${prop} (${path})`);
      }
      schema = schema[prop];
    }
    return schema;
  }
  function isNumeric(value) {
    return typeof value === 'string' && RE_NUMERIC.test(value);
  }
  function isScalar(value) {
    return ['number', 'boolean'].includes(typeof value);
  }
  function hasProperties(obj, ...properties) {
    return (
      properties.filter((key) => {
        return typeof obj[key] !== 'undefined';
      }).length > 0
    );
  }
  function clampDate(value) {
    if (value.includes(' ')) {
      return new Date(value).toISOString().substr(0, 10);
    }
    let [year, month, day] = value.split('T')[0].split('-');
    month = `0${Math.max(1, Math.min(12, month))}`.slice(-2);
    day = `0${Math.max(1, Math.min(31, day))}`.slice(-2);
    return `${year}-${month}-${day}`;
  }
  function clampDateTime(value) {
    if (value.includes(' ')) {
      return new Date(value).toISOString().substr(0, 10);
    }
    const [datePart, timePart] = value.split('T');
    let [year, month, day] = datePart.split('-');
    let [hour, minute, second] = timePart.substr(0, 8).split(':');
    month = `0${Math.max(1, Math.min(12, month))}`.slice(-2);
    day = `0${Math.max(1, Math.min(31, day))}`.slice(-2);
    hour = `0${Math.max(1, Math.min(23, hour))}`.slice(-2);
    minute = `0${Math.max(1, Math.min(59, minute))}`.slice(-2);
    second = `0${Math.max(1, Math.min(59, second))}`.slice(-2);
    return `${year}-${month}-${day}T${hour}:${minute}:${second}.000Z`;
  }
  function typecast(type, schema, callback) {
    const params = {};
    switch (type || schema.type) {
      case 'integer':
      case 'number':
        if (typeof schema.minimum !== 'undefined') {
          params.minimum = schema.minimum;
        }
        if (typeof schema.maximum !== 'undefined') {
          params.maximum = schema.maximum;
        }
        if (schema.enum) {
          let min = Math.max(params.minimum || 0, 0);
          let max = Math.min(params.maximum || Infinity, Infinity);
          if (schema.exclusiveMinimum && min === schema.minimum) {
            min += schema.multipleOf || 1;
          }
          if (schema.exclusiveMaximum && max === schema.maximum) {
            max -= schema.multipleOf || 1;
          }
          if (min || max !== Infinity) {
            schema.enum = schema.enum.filter((x) => {
              if (x >= min && x <= max) {
                return true;
              }
              return false;
            });
          }
        }
        break;
      case 'string': {
        params.minLength = option_default('minLength') || 0;
        params.maxLength = option_default('maxLength') || Number.MAX_SAFE_INTEGER;
        if (typeof schema.minLength !== 'undefined') {
          params.minLength = Math.max(params.minLength, schema.minLength);
        }
        if (typeof schema.maxLength !== 'undefined') {
          params.maxLength = Math.min(params.maxLength, schema.maxLength);
        }
        break;
      }
      default:
        break;
    }
    let value = callback(params);
    if (value === null || value === void 0) {
      return null;
    }
    switch (type || schema.type) {
      case 'number':
        value = isNumeric(value) ? parseFloat(value) : value;
        break;
      case 'integer':
        value = isNumeric(value) ? parseInt(value, 10) : value;
        break;
      case 'boolean':
        value = !!value;
        break;
      case 'string': {
        if (isScalar(value)) {
          return value;
        }
        value = String(value);
        const min = Math.max(params.minLength || 0, 0);
        const max = Math.min(params.maxLength || Infinity, Infinity);
        let prev;
        let noChangeCount = 0;
        while (value.length < min) {
          prev = value;
          if (!schema.pattern) {
            value += `${random_default.pick([' ', '/', '_', '-', '+', '=', '@', '^'])}${value}`;
          } else {
            value += random_default.randexp(schema.pattern);
          }
          if (value === prev) {
            noChangeCount += 1;
            if (noChangeCount === 3) {
              break;
            }
          } else {
            noChangeCount = 0;
          }
        }
        if (value.length > max) {
          value = value.substr(0, max);
        }
        switch (schema.format) {
          case 'date-time':
          case 'datetime':
            value = new Date(clampDateTime(value)).toISOString().replace(/([0-9])0+Z$/, '$1Z');
            break;
          case 'full-date':
          case 'date':
            value = new Date(clampDate(value)).toISOString().substr(0, 10);
            break;
          case 'time':
            value = /* @__PURE__ */ new Date(`1969-01-01 ${value}`)
              .toISOString()
              .substr(11);
            break;
          default:
            break;
        }
        break;
      }
      default:
        break;
    }
    return value;
  }
  function merge(a, b) {
    Object.keys(b).forEach((key) => {
      if (typeof b[key] !== 'object' || b[key] === null) {
        a[key] = b[key];
      } else if (Array.isArray(b[key])) {
        a[key] = a[key] || [];
        b[key].forEach((value, i) => {
          if (a.type === 'array' && b.type === 'array') {
            a[key][i] = merge(a[key][i] || {}, value, true);
          } else if (Array.isArray(a[key]) && a[key].indexOf(value) === -1) {
            a[key].push(value);
          }
        });
      } else if (typeof a[key] !== 'object' || a[key] === null || Array.isArray(a[key])) {
        a[key] = merge({}, b[key]);
      } else {
        a[key] = merge(a[key], b[key]);
      }
    });
    return a;
  }
  function clone(obj, cache = /* @__PURE__ */ new Map()) {
    if (!obj || typeof obj !== 'object') {
      return obj;
    }
    if (cache.has(obj)) {
      return cache.get(obj);
    }
    if (Array.isArray(obj)) {
      const arr = [];
      cache.set(obj, arr);
      arr.push(...obj.map((x) => clone(x, cache)));
      return arr;
    }
    const clonedObj = {};
    cache.set(obj, clonedObj);
    return Object.keys(obj).reduce((prev, cur) => {
      prev[cur] = clone(obj[cur], cache);
      return prev;
    }, clonedObj);
  }
  function short(schema) {
    const s = JSON.stringify(schema);
    const l = JSON.stringify(schema, null, 2);
    return s.length > 400 ? `${l.substr(0, 400)}...` : l;
  }
  function anyValue() {
    return random_default.pick([
      false,
      true,
      null,
      -1,
      NaN,
      Math.PI,
      Infinity,
      void 0,
      [],
      {},
      // FIXME: use built-in random?
      Math.random(),
      Math.random().toString(36).substr(2),
    ]);
  }
  function hasValue(schema, value) {
    if (schema.enum) return schema.enum.includes(value);
    if (schema.const) return schema.const === value;
  }
  function notValue(schema, parent) {
    const copy = merge({}, parent);
    if (typeof schema.minimum !== 'undefined') {
      copy.maximum = schema.minimum;
      copy.exclusiveMaximum = true;
    }
    if (typeof schema.maximum !== 'undefined') {
      copy.minimum = schema.maximum > copy.maximum ? 0 : schema.maximum;
      copy.exclusiveMinimum = true;
    }
    if (typeof schema.minLength !== 'undefined') {
      copy.maxLength = schema.minLength;
    }
    if (typeof schema.maxLength !== 'undefined') {
      copy.minLength = schema.maxLength > copy.maxLength ? 0 : schema.maxLength;
    }
    if (schema.type) {
      copy.type = random_default.pick(
        constants_default.SCALAR_TYPES.filter((x) => {
          const types2 = Array.isArray(schema.type) ? schema.type : [schema.type];
          return types2.every((type) => {
            if (x === 'number' || x === 'integer') {
              return type !== 'number' && type !== 'integer';
            }
            return x !== type;
          });
        })
      );
    } else if (schema.enum) {
      let value;
      do {
        value = anyValue();
      } while (schema.enum.indexOf(value) !== -1);
      copy.enum = [value];
    }
    if (schema.required && copy.properties) {
      schema.required.forEach((prop) => {
        delete copy.properties[prop];
      });
    }
    return copy;
  }
  function validateValueForSchema(value, schema) {
    const schemaHasMin = schema.minimum !== void 0;
    const schemaHasMax = schema.maximum !== void 0;
    return (
      (schemaHasMin || schemaHasMax) &&
      (!schemaHasMin || value >= schema.minimum) &&
      (!schemaHasMax || value <= schema.maximum)
    );
  }
  function validate(value, schemas) {
    return !schemas.every((schema) => validateValueForSchema(value, schema));
  }
  function validateValueForOneOf(value, oneOf) {
    const validCount = oneOf.reduce((count, schema) => count + (validateValueForSchema(value, schema) ? 1 : 0), 0);
    return validCount === 1;
  }
  function isKey(prop) {
    return ['enum', 'const', 'default', 'examples', 'required', 'definitions', 'items', 'properties'].includes(prop);
  }
  function omitProps(obj, props) {
    return Object.keys(obj)
      .filter((key) => !props.includes(key))
      .reduce((copy, k) => {
        if (Array.isArray(obj[k])) {
          copy[k] = obj[k].slice();
        } else {
          copy[k] = obj[k] instanceof Object ? merge({}, obj[k]) : obj[k];
        }
        return copy;
      }, {});
  }
  function template(value, schema) {
    if (Array.isArray(value)) {
      return value.map((x) => template(x, schema));
    }
    if (typeof value === 'string') {
      value = value.replace(/#\{([\w.-]+)\}/g, (_, $1) => schema[$1]);
    }
    return value;
  }
  function isEmpty(value) {
    return Object.prototype.toString.call(value) === '[object Object]' && !Object.keys(value).length;
  }
  function shouldClean(key, schema) {
    schema = schema.items || schema;
    const alwaysFakeOptionals = option_default('alwaysFakeOptionals');
    const isRequired = (Array.isArray(schema.required) && schema.required.includes(key)) || alwaysFakeOptionals;
    const wasCleaned =
      typeof schema.thunk === 'function' ||
      (schema.additionalProperties && typeof schema.additionalProperties.thunk === 'function');
    return !isRequired && !wasCleaned;
  }
  function clean(obj, schema, isArray = false) {
    if (!obj || typeof obj !== 'object') {
      return obj;
    }
    if (Array.isArray(obj)) {
      return obj.map((value) => clean(value, schema, true)).filter((value) => typeof value !== 'undefined');
    }
    Object.keys(obj).forEach((k) => {
      if (isEmpty(obj[k])) {
        if (shouldClean(k, schema)) {
          delete obj[k];
        }
      } else {
        let subSchema = schema;
        if (schema && schema.properties && schema.properties[k]) {
          subSchema = schema.properties[k];
        }
        const value = clean(obj[k], subSchema);
        if (!isEmpty(value)) {
          obj[k] = value;
        }
      }
      if (typeof obj[k] === 'undefined') {
        delete obj[k];
      }
    });
    if (!Object.keys(obj).length && isArray) {
      return void 0;
    }
    return obj;
  }
  function proxy(gen) {
    return (value, schema, property, rootSchema) => {
      let fn = value;
      let args = [];
      if (typeof value === 'object') {
        fn = Object.keys(value)[0];
        if (Array.isArray(value[fn])) {
          args = value[fn];
        } else {
          args.push(value[fn]);
        }
      }
      const props = fn.split('.');
      let ctx = gen();
      while (props.length > 1) {
        ctx = ctx[props.shift()];
      }
      value = typeof ctx === 'object' ? ctx[props[0]] : ctx;
      if (typeof value === 'function') {
        value = value.apply(
          ctx,
          args.map((x) => utils_default.template(x, rootSchema))
        );
      }
      if (Object.prototype.toString.call(value) === '[object Object]') {
        Object.keys(value).forEach((key) => {
          if (typeof value[key] === 'function') {
            throw new Error(`Cannot resolve value for '${property}: ${fn}', given: ${value}`);
          }
        });
      }
      return value;
    };
  }
  function formatAPI(nameOrFormatMap, callback) {
    if (typeof nameOrFormatMap === 'undefined') {
      return registry2.list();
    }
    if (typeof nameOrFormatMap === 'string') {
      if (typeof callback === 'function') {
        registry2.register(nameOrFormatMap, callback);
      } else if (callback === null || callback === false) {
        registry2.unregister(nameOrFormatMap);
      } else {
        return registry2.get(nameOrFormatMap);
      }
    } else {
      registry2.registerMany(nameOrFormatMap);
    }
  }
  function matchesType(obj, lastElementInPath, inferredTypeProperties) {
    return (
      Object.keys(obj).filter((prop) => {
        const isSubschema = subschemaProperties.indexOf(lastElementInPath) > -1;
        const inferredPropertyFound = inferredTypeProperties.indexOf(prop) > -1;
        if (inferredPropertyFound && !isSubschema) {
          return true;
        }
        return false;
      }).length > 0
    );
  }
  function inferType(obj, schemaPath) {
    const keys = Object.keys(inferredProperties);
    for (let i = 0; i < keys.length; i += 1) {
      const typeName = keys[i];
      const lastElementInPath = schemaPath[schemaPath.length - 1];
      if (matchesType(obj, lastElementInPath, inferredProperties[typeName])) {
        return typeName;
      }
    }
  }
  function booleanGenerator() {
    return option_default('random')() > 0.5;
  }
  function nullGenerator() {
    return null;
  }
  function unique(path, items, value, sample, resolve2, traverseCallback) {
    const tmp = [];
    const seen = [];
    function walk(obj) {
      const json = JSON.stringify(obj.value);
      if (seen.indexOf(json) === -1) {
        seen.push(json);
        tmp.push(obj);
        return true;
      }
      return false;
    }
    items.forEach(walk);
    let limit = 100;
    while (tmp.length !== items.length) {
      if (!walk(traverseCallback(value.items || sample, path, resolve2))) {
        limit -= 1;
      }
      if (!limit) {
        break;
      }
    }
    return tmp;
  }
  function arrayType(value, path, resolve2, traverseCallback) {
    const items = [];
    if (!(value.items || value.additionalItems)) {
      if (utils_default.hasProperties(value, 'minItems', 'maxItems', 'uniqueItems')) {
        if (value.minItems !== 0 || value.maxItems !== 0) {
          throw new error_default(`missing items for ${utils_default.short(value)}`, path);
        }
      }
      return items;
    }
    if (Array.isArray(value.items)) {
      return value.items.map((item, key) => {
        const itemSubpath = path.concat(['items', key]);
        return traverseCallback(item, itemSubpath, resolve2);
      });
    }
    let minItems = value.minItems;
    let maxItems = value.maxItems;
    const defaultMinItems = option_default('minItems');
    const defaultMaxItems = option_default('maxItems');
    if (defaultMinItems) {
      minItems = typeof minItems === 'undefined' ? defaultMinItems : Math.min(defaultMinItems, minItems);
    }
    if (defaultMaxItems) {
      maxItems = typeof maxItems === 'undefined' ? defaultMaxItems : Math.min(defaultMaxItems, maxItems);
      if (maxItems && maxItems > defaultMaxItems) {
        maxItems = defaultMaxItems;
      }
      if (minItems && minItems > defaultMaxItems) {
        minItems = maxItems;
      }
    }
    const optionalsProbability =
      option_default('alwaysFakeOptionals') === true ? 1 : option_default('optionalsProbability');
    const fixedProbabilities = option_default('alwaysFakeOptionals') || option_default('fixedProbabilities') || false;
    let length = random_default.number(minItems, maxItems, 1, 5);
    if (optionalsProbability !== null) {
      length = Math.max(
        fixedProbabilities
          ? Math.round((maxItems || length) * optionalsProbability)
          : Math.abs(random_default.number(minItems, maxItems) * optionalsProbability),
        minItems || 0
      );
    }
    const sample = typeof value.additionalItems === 'object' ? value.additionalItems : {};
    for (let current = items.length; current < length; current += 1) {
      const itemSubpath = path.concat(['items', current]);
      const element = traverseCallback(value.items || sample, itemSubpath, resolve2);
      items.push(element);
    }
    if (value.contains && length > 0) {
      const idx = random_default.number(0, length - 1);
      items[idx] = traverseCallback(value.contains, path.concat(['items', idx]), resolve2);
    }
    if (value.uniqueItems) {
      return unique(path.concat(['items']), items, value, sample, resolve2, traverseCallback);
    }
    return items;
  }
  function numberType(value) {
    let min =
      typeof value.minimum === 'undefined' || value.minimum === -Number.MAX_VALUE
        ? constants_default.MIN_INTEGER
        : value.minimum;
    let max =
      typeof value.maximum === 'undefined' || value.maximum === Number.MAX_VALUE
        ? constants_default.MAX_INTEGER
        : value.maximum;
    const multipleOf = value.multipleOf;
    const decimals = multipleOf && String(multipleOf).match(/e-(\d)|\.(\d+)$/);
    if (decimals) {
      const number2 = (Math.random() * random_default.number(0, 10) + 1) * multipleOf;
      const truncate = decimals[1] || decimals[2].length;
      const result = parseFloat(number2.toFixed(truncate));
      const base = random_default.number(min, max - 1);
      if (!String(result).includes('.')) {
        return (base + result).toExponential();
      }
      return base + result;
    }
    if (multipleOf) {
      max = Math.floor(max / multipleOf) * multipleOf;
      min = Math.ceil(min / multipleOf) * multipleOf;
    }
    if (value.exclusiveMinimum && min === value.minimum) {
      min += multipleOf || 1;
    }
    if (value.exclusiveMaximum && max === value.maximum) {
      max -= multipleOf || 1;
    }
    if (min > max) {
      return NaN;
    }
    if (multipleOf) {
      let base = random_default.number(Math.floor(min / multipleOf), Math.floor(max / multipleOf)) * multipleOf;
      while (base < min) {
        base += multipleOf;
      }
      return base;
    }
    return random_default.number(min, max, void 0, void 0, value.type !== 'integer');
  }
  function integerType(value) {
    return Math.floor(number_default({ ...value }));
  }
  function wordsGenerator(length) {
    const words = random_default.shuffle(LIPSUM_WORDS);
    return words.slice(0, length);
  }
  function objectType(value, path, resolve2, traverseCallback) {
    const props = {};
    const properties = value.properties || {};
    const patternProperties = value.patternProperties || {};
    const requiredProperties = typeof value.required === 'boolean' ? [] : (value.required || []).slice();
    const allowsAdditional = value.additionalProperties !== false;
    const propertyKeys = Object.keys(properties);
    const patternPropertyKeys = Object.keys(patternProperties);
    const optionalProperties = propertyKeys.concat(patternPropertyKeys).reduce((_response, _key) => {
      if (requiredProperties.indexOf(_key) === -1) _response.push(_key);
      return _response;
    }, []);
    const allProperties = requiredProperties.concat(optionalProperties);
    const additionalProperties = allowsAdditional
      ? value.additionalProperties === true
        ? anyType
        : value.additionalProperties
      : value.additionalProperties;
    if (
      !allowsAdditional &&
      propertyKeys.length === 0 &&
      patternPropertyKeys.length === 0 &&
      utils_default.hasProperties(value, 'minProperties', 'maxProperties', 'dependencies', 'required')
    ) {
      return null;
    }
    if (option_default('requiredOnly') === true) {
      requiredProperties.forEach((key) => {
        if (properties[key]) {
          props[key] = properties[key];
        }
      });
      return traverseCallback(props, path.concat(['properties']), resolve2, value);
    }
    const optionalsProbability =
      option_default('alwaysFakeOptionals') === true ? 1 : option_default('optionalsProbability');
    const fixedProbabilities = option_default('alwaysFakeOptionals') || option_default('fixedProbabilities') || false;
    const ignoreProperties = option_default('ignoreProperties') || [];
    const reuseProps = option_default('reuseProperties');
    const fillProps = option_default('fillProperties');
    const max = value.maxProperties || allProperties.length + (allowsAdditional ? random_default.number(1, 5) : 0);
    let min = Math.max(value.minProperties || 0, requiredProperties.length);
    let neededExtras = Math.max(0, allProperties.length - min);
    if (allProperties.length === 1 && !requiredProperties.length) {
      min = Math.max(random_default.number(fillProps ? 1 : 0, max), min);
    }
    if (optionalsProbability !== null) {
      if (fixedProbabilities === true) {
        neededExtras = Math.round(
          min - requiredProperties.length + optionalsProbability * (allProperties.length - min)
        );
      } else {
        neededExtras = random_default.number(
          min - requiredProperties.length,
          optionalsProbability * (allProperties.length - min)
        );
      }
    }
    const extraPropertiesRandomOrder = random_default.shuffle(optionalProperties).slice(0, neededExtras);
    const extraProperties = optionalProperties.filter((_item) => {
      return extraPropertiesRandomOrder.indexOf(_item) !== -1;
    });
    const _limit =
      optionalsProbability !== null || requiredProperties.length === max ? max : random_default.number(0, max);
    const _props = requiredProperties.concat(random_default.shuffle(extraProperties).slice(0, _limit)).slice(0, max);
    const _defns = [];
    const _deps = [];
    if (value.dependencies) {
      Object.keys(value.dependencies).forEach((prop) => {
        const _required = value.dependencies[prop];
        if (_props.indexOf(prop) !== -1) {
          if (Array.isArray(_required)) {
            _required.forEach((sub) => {
              if (_props.indexOf(sub) === -1) {
                _props.push(sub);
              }
            });
          } else if (Array.isArray(_required.oneOf || _required.anyOf)) {
            const values = _required.oneOf || _required.anyOf;
            _deps.push({ prop, values });
          } else {
            _defns.push(_required);
          }
        }
      });
      if (_defns.length) {
        delete value.dependencies;
        return traverseCallback(
          {
            allOf: _defns.concat(value),
          },
          path.concat(['properties']),
          resolve2,
          value
        );
      }
    }
    const skipped = [];
    const missing = [];
    _props.forEach((key) => {
      if (properties[key] && ['{}', 'true'].includes(JSON.stringify(properties[key].not))) {
        return;
      }
      for (let i = 0; i < ignoreProperties.length; i += 1) {
        if (
          (ignoreProperties[i] instanceof RegExp && ignoreProperties[i].test(key)) ||
          (typeof ignoreProperties[i] === 'string' && ignoreProperties[i] === key) ||
          (typeof ignoreProperties[i] === 'function' && ignoreProperties[i](properties[key], key))
        ) {
          skipped.push(key);
          return;
        }
      }
      if (additionalProperties === false) {
        if (requiredProperties.indexOf(key) !== -1) {
          props[key] = properties[key];
        }
      }
      if (properties[key]) {
        props[key] = properties[key];
      }
      let found;
      patternPropertyKeys.forEach((_key) => {
        if (key.match(new RegExp(_key))) {
          found = true;
          if (props[key]) {
            utils_default.merge(props[key], patternProperties[_key]);
          } else {
            props[random_default.randexp(key)] = patternProperties[_key];
          }
        }
      });
      if (!found) {
        const subschema = patternProperties[key] || additionalProperties;
        if (subschema && additionalProperties !== false) {
          props[patternProperties[key] ? random_default.randexp(key) : key] = properties[key] || subschema;
        } else {
          missing.push(key);
        }
      }
    });
    let current = Object.keys(props).length + (fillProps ? 0 : skipped.length);
    const hash = (suffix) => random_default.randexp(`_?[_a-f\\d]{1,3}${suffix ? '\\$?' : ''}`);
    function get(from) {
      let one;
      do {
        if (!from.length) break;
        one = from.shift();
      } while (props[one]);
      return one;
    }
    let minProps = min;
    if (allowsAdditional && !requiredProperties.length) {
      minProps = Math.max(
        optionalsProbability === null || additionalProperties ? random_default.number(fillProps ? 1 : 0, max) : 0,
        min
      );
    }
    if (!extraProperties.length && !neededExtras && allowsAdditional && fixedProbabilities === true && fillProps) {
      const limit = random_default.number(0, max);
      for (let i = 0; i < limit; i += 1) {
        props[words_default(1) + hash(limit[i])] = additionalProperties || anyType;
      }
    }
    while (fillProps) {
      if (!(patternPropertyKeys.length || allowsAdditional)) {
        break;
      }
      if (current >= minProps) {
        break;
      }
      if (allowsAdditional) {
        if (reuseProps && propertyKeys.length - current > minProps) {
          let count = 0;
          let key;
          do {
            count += 1;
            if (count > 1e3) {
              break;
            }
            key = get(requiredProperties) || random_default.pick(propertyKeys);
          } while (typeof props[key] !== 'undefined');
          if (typeof props[key] === 'undefined') {
            props[key] = properties[key];
            current += 1;
          }
        } else if (patternPropertyKeys.length && !additionalProperties) {
          const prop = random_default.pick(patternPropertyKeys);
          const word = random_default.randexp(prop);
          if (!props[word]) {
            props[word] = patternProperties[prop];
            current += 1;
          }
        } else {
          const word = get(requiredProperties) || words_default(1) + hash();
          if (!props[word]) {
            props[word] = additionalProperties || anyType;
            current += 1;
          }
        }
      }
      for (let i = 0; current < min && i < patternPropertyKeys.length; i += 1) {
        const _key = patternPropertyKeys[i];
        const word = random_default.randexp(_key);
        if (!props[word]) {
          props[word] = patternProperties[_key];
          current += 1;
        }
      }
    }
    if (requiredProperties.length === 0 && (!allowsAdditional || optionalsProbability === false)) {
      const maximum = random_default.number(min, max);
      for (; current < maximum; ) {
        const word = get(propertyKeys);
        if (word) {
          props[word] = properties[word];
        }
        current += 1;
      }
    }
    let sortedObj = props;
    if (option_default('sortProperties') !== null) {
      const originalKeys = Object.keys(properties);
      const sortedKeys = Object.keys(props).sort((a, b) => {
        return option_default('sortProperties')
          ? a.localeCompare(b)
          : originalKeys.indexOf(a) - originalKeys.indexOf(b);
      });
      sortedObj = sortedKeys.reduce((memo, key) => {
        memo[key] = props[key];
        return memo;
      }, {});
    }
    const result = traverseCallback(sortedObj, path.concat(['properties']), resolve2, value);
    _deps.forEach((dep) => {
      for (const sub of dep.values) {
        if (utils_default.hasValue(sub.properties[dep.prop], result.value[dep.prop])) {
          Object.keys(sub.properties).forEach((next) => {
            if (next !== dep.prop) {
              utils_default.merge(
                result.value,
                traverseCallback(sub.properties, path.concat(['properties']), resolve2, value).value
              );
            }
          });
          break;
        }
      }
    });
    return result;
  }
  function produce() {
    const length = random_default.number(1, 5);
    return words_default(length).join(' ');
  }
  function thunkGenerator(min = 0, max = 140) {
    const _min = Math.max(0, min);
    const _max = random_default.number(_min, max);
    let result = produce();
    while (result.length < _min) {
      result += produce();
    }
    if (result.length > _max) {
      result = result.substr(0, _max);
    }
    return result;
  }
  function ipv4Generator() {
    return [0, 0, 0, 0]
      .map(() => {
        return random_default.number(0, 255);
      })
      .join('.');
  }
  function dateTimeGenerator() {
    return random_default.date().toISOString();
  }
  function dateGenerator() {
    return dateTime_default().slice(0, 10);
  }
  function timeGenerator() {
    return dateTime_default().slice(11);
  }
  function coreFormatGenerator(coreFormat) {
    return random_default.randexp(regexps[coreFormat]).replace(ALLOWED_FORMATS, (match, key) => {
      return random_default.randexp(regexps[key]);
    });
  }
  function generateFormat(value, invalid) {
    const callback = format_default(value.format);
    if (typeof callback === 'function') {
      return callback(value);
    }
    switch (value.format) {
      case 'date-time':
      case 'datetime':
        return dateTime_default();
      case 'date':
        return date_default();
      case 'time':
        return time_default();
      case 'ipv4':
        return ipv4_default();
      case 'regex':
        return '.+?';
      case 'email':
      case 'hostname':
      case 'ipv6':
      case 'uri':
      case 'uri-reference':
      case 'iri':
      case 'iri-reference':
      case 'idn-email':
      case 'idn-hostname':
      case 'json-pointer':
      case 'slug':
      case 'uri-template':
      case 'uuid':
      case 'duration':
        return coreFormat_default(value.format);
      default:
        if (typeof callback === 'undefined') {
          if (option_default('failOnInvalidFormat')) {
            throw new Error(`unknown registry key ${utils_default.short(value.format)}`);
          } else {
            return invalid();
          }
        }
        throw new Error(`unsupported format '${value.format}'`);
    }
  }
  function stringType(value) {
    const output = utils_default.typecast('string', value, (opts) => {
      if (value.format) {
        return generateFormat(value, () => thunk_default(opts.minLength, opts.maxLength));
      }
      if (value.pattern) {
        return random_default.randexp(value.pattern);
      }
      return thunk_default(opts.minLength, opts.maxLength);
    });
    return output;
  }
  function getMeta({ $comment: comment, title, description }) {
    return Object.entries({ comment, title, description })
      .filter(([, value]) => value)
      .reduce((memo, [k, v]) => {
        memo[k] = v;
        return memo;
      }, {});
  }
  function traverse(schema, path, resolve2, rootSchema) {
    schema = resolve2(schema, null, path);
    if (schema && (schema.oneOf || schema.anyOf || schema.allOf)) {
      schema = resolve2(schema, null, path);
    }
    if (!schema) {
      throw new Error(`Cannot traverse at '${path.join('.')}', given '${JSON.stringify(rootSchema)}'`);
    }
    const context = {
      ...getMeta(schema),
      schemaPath: path,
    };
    if (path[path.length - 1] !== 'properties') {
      if (option_default('useExamplesValue') && Array.isArray(schema.examples)) {
        const fixedExamples = schema.examples.concat('default' in schema ? [schema.default] : []);
        return { value: utils_default.typecast(null, schema, () => random_default.pick(fixedExamples)), context };
      }
      if (option_default('useExamplesValue') && typeof schema.example !== 'undefined') {
        return { value: utils_default.typecast(null, schema, () => schema.example), context };
      }
      if (option_default('useDefaultValue') && 'default' in schema) {
        if (schema.default !== '' || !option_default('replaceEmptyByRandomValue')) {
          return { value: schema.default, context };
        }
      }
      if ('template' in schema) {
        return { value: utils_default.template(schema.template, rootSchema), context };
      }
      if ('const' in schema) {
        return { value: schema.const, context };
      }
    }
    if (schema.not && typeof schema.not === 'object') {
      schema = utils_default.notValue(schema.not, utils_default.omitProps(schema, ['not']));
      if (schema.type && schema.type === 'object') {
        const { value, context: innerContext } = traverse(schema, path.concat(['not']), resolve2, rootSchema);
        return { value: utils_default.clean(value, schema, false), context: { ...context, items: innerContext } };
      }
    }
    if (typeof schema.thunk === 'function') {
      const { value, context: innerContext } = traverse(schema.thunk(rootSchema), path, resolve2);
      return { value, context: { ...context, items: innerContext } };
    }
    if (schema.jsonPath) {
      return { value: schema, context };
    }
    let type = schema.type;
    if (Array.isArray(type)) {
      type = random_default.pick(type);
    } else if (typeof type === 'undefined') {
      type = infer_default(schema, path) || type;
      if (type) {
        schema.type = type;
      }
    }
    if (typeof schema.generate === 'function') {
      const retVal = utils_default.typecast(null, schema, () => schema.generate(rootSchema, path));
      const retType = retVal === null ? 'null' : typeof retVal;
      if (
        retType === type ||
        (retType === 'number' && type === 'integer') ||
        (Array.isArray(retVal) && type === 'array')
      ) {
        return { value: retVal, context };
      }
    }
    if (typeof schema.pattern === 'string') {
      return { value: utils_default.typecast('string', schema, () => random_default.randexp(schema.pattern)), context };
    }
    if (Array.isArray(schema.enum)) {
      return { value: utils_default.typecast(null, schema, () => random_default.pick(schema.enum)), context };
    }
    if (typeof type === 'string') {
      if (!types_default[type]) {
        if (option_default('failOnInvalidTypes')) {
          throw new error_default(`unknown primitive ${utils_default.short(type)}`, path.concat(['type']));
        } else {
          const value = option_default('defaultInvalidTypeProduct');
          if (typeof value === 'string' && types_default[value]) {
            return { value: types_default[value](schema, path, resolve2, traverse), context };
          }
          return { value, context };
        }
      } else {
        try {
          const innerResult = types_default[type](schema, path, resolve2, traverse);
          if (type === 'array') {
            return {
              value: innerResult.map(({ value }) => value),
              context: {
                ...context,
                items: innerResult.map(
                  Array.isArray(schema.items)
                    ? ({ context: c }) => c
                    : ({ context: c }) => ({
                        ...c,
                        // we have to remove the index from the path to get the real schema path
                        schemaPath: c.schemaPath.slice(0, -1),
                      })
                ),
              },
            };
          }
          if (type === 'object') {
            return innerResult !== null
              ? { value: innerResult.value, context: { ...context, items: innerResult.context } }
              : { value: {}, context };
          }
          return { value: innerResult, context };
        } catch (e) {
          if (typeof e.path === 'undefined') {
            throw new error_default(e.stack, path);
          }
          throw e;
        }
      }
    }
    let valueCopy = {};
    const contextCopy = { ...context };
    if (Array.isArray(schema)) {
      valueCopy = [];
    }
    const pruneProperties = option_default('pruneProperties') || [];
    Object.keys(schema).forEach((prop) => {
      if (pruneProperties.includes(prop)) return;
      if (schema[prop] === null) return;
      if (typeof schema[prop] === 'object' && prop !== 'definitions') {
        const { value, context: innerContext } = traverse(schema[prop], path.concat([prop]), resolve2, valueCopy);
        valueCopy[prop] = utils_default.clean(value, schema[prop], false);
        contextCopy[prop] = innerContext;
        if (valueCopy[prop] === null && option_default('omitNulls')) {
          delete valueCopy[prop];
          delete contextCopy[prop];
        }
      } else {
        valueCopy[prop] = schema[prop];
      }
    });
    return { value: valueCopy, context: contextCopy };
  }
  function pick2(data) {
    return Array.isArray(data) ? random_default.pick(data) : data;
  }
  function cycle(data, reverse) {
    if (!Array.isArray(data)) {
      return data;
    }
    const value = reverse ? data.pop() : data.shift();
    if (reverse) {
      data.unshift(value);
    } else {
      data.push(value);
    }
    return value;
  }
  function resolve(obj, data, values, property) {
    if (!obj || typeof obj !== 'object') {
      return obj;
    }
    if (!values) {
      values = {};
    }
    if (!data) {
      data = obj;
    }
    if (Array.isArray(obj)) {
      return obj.map((x) => resolve(x, data, values, property));
    }
    if (obj.jsonPath) {
      const { JSONPath: JSONPath2 } = getDependencies();
      const params = typeof obj.jsonPath !== 'object' ? { path: obj.jsonPath } : obj.jsonPath;
      params.group = obj.group || params.group || property;
      params.cycle = obj.cycle || params.cycle || false;
      params.reverse = obj.reverse || params.reverse || false;
      params.count = obj.count || params.count || 1;
      const key = `${params.group}__${params.path}`;
      if (!values[key]) {
        if (params.count > 1) {
          values[key] = JSONPath2(params.path, data).slice(0, params.count);
        } else {
          values[key] = JSONPath2(params.path, data);
        }
      }
      if (params.cycle || params.reverse) {
        return cycle(values[key], params.reverse);
      }
      return pick2(values[key]);
    }
    Object.keys(obj).forEach((k) => {
      obj[k] = resolve(obj[k], data, values, k);
    });
    return obj;
  }
  function run(refs, schema, container2, synchronous) {
    if (Object.prototype.toString.call(schema) !== '[object Object]') {
      throw new Error(`Invalid input, expecting object but given ${typeof schema}`);
    }
    const refDepthMin = option_default('refDepthMin') || 0;
    const refDepthMax = option_default('refDepthMax') || 3;
    try {
      const { resolveSchema } = buildResolveSchema_default({
        refs,
        schema,
        container: container2,
        synchronous,
        refDepthMin,
        refDepthMax,
      });
      const result = traverse_default(utils_default.clone(schema), [], resolveSchema);
      if (option_default('resolveJsonPath')) {
        return {
          value: resolve(result.value),
          context: result.context,
        };
      }
      return result;
    } catch (e) {
      if (e.path) {
        throw new Error(`${e.message} in /${e.path.join('/')}`);
      } else {
        throw e;
      }
    }
  }
  function renderJS(res) {
    return res.value;
  }
  function getIn(obj, path) {
    return path.reduce((v, k) => (k in v ? v[k] : {}), obj);
  }
  function addComments(context, path, commentNode, iterNode = commentNode) {
    const { title, description, comment } = getIn(context, path);
    const lines = [];
    if (option_default('renderTitle') && title) {
      lines.push(` ${title}`, '');
    }
    if (option_default('renderDescription') && description) {
      lines.push(` ${description}`);
    }
    if (option_default('renderComment') && comment) {
      lines.push(` ${comment}`);
    }
    commentNode.commentBefore = lines.join('\n');
    if (iterNode instanceof YAMLMap) {
      iterNode.items.forEach((n) => {
        addComments(context, [...path, 'items', n.key.value], n.key, n.value);
      });
    } else if (iterNode instanceof YAMLSeq) {
      iterNode.items.forEach((n, i) => {
        addComments(context, [...path, 'items', i], n);
      });
    }
  }
  function renderYAML({ value, context }) {
    const nodes = yaml_default.createNode(value);
    addComments(context, [], nodes);
    const doc = new yaml_default.Document();
    doc.contents = nodes;
    return doc.toString();
  }
  function setupKeywords() {
    container.define('autoIncrement', function autoIncrement(value, schema) {
      if (!this.offset) {
        const min = schema.minimum || 1;
        const max = min + constants_default.MAX_NUMBER;
        const offset = value.initialOffset || schema.initialOffset;
        this.offset = offset || random_default.number(min, max);
      }
      if (value) {
        return this.offset++;
      }
      return schema;
    });
    container.define('sequentialDate', function sequentialDate(value, schema) {
      if (!this.now) {
        this.now = random_default.date();
      }
      if (value) {
        schema = this.now.toISOString();
        value = value === true ? 'days' : value;
        if (['seconds', 'minutes', 'hours', 'days', 'weeks', 'months', 'years'].indexOf(value) === -1) {
          throw new Error(`Unsupported increment by ${utils_default.short(value)}`);
        }
        this.now.setTime(this.now.getTime() + random_default.date(value));
      }
      return schema;
    });
  }
  function getRefs(refs, schema) {
    let $refs = {};
    if (Array.isArray(refs)) {
      refs.forEach((_schema) => {
        $refs[_schema.$id || _schema.id] = _schema;
      });
    } else {
      $refs = refs || {};
    }
    function walk(obj) {
      if (!obj || typeof obj !== 'object') return;
      if (Array.isArray(obj)) return obj.forEach(walk);
      const _id = obj.$id || obj.id;
      if (typeof _id === 'string' && !$refs[_id]) {
        $refs[_id] = obj;
      }
      Object.keys(obj).forEach((key) => {
        walk(obj[key]);
      });
    }
    walk(refs);
    walk(schema);
    return $refs;
  }
  var __create,
    __defProp2,
    __getOwnPropDesc2,
    __getOwnPropNames2,
    __getProtoOf,
    __hasOwnProp2,
    __commonJS2,
    __copyProps2,
    __toESM,
    require_types,
    require_sets,
    require_util,
    require_positions,
    require_lib,
    require_lib2,
    require_randexp,
    require_PlainValue_ec8e588e,
    require_resolveSeq_d03cb037,
    require_warnings_1000a372,
    require_Schema_88e323a7,
    require_types2,
    DEPENDENCIES,
    getDependencies,
    setDependencies,
    Registry,
    Registry_default,
    defaults,
    defaults_default,
    OptionRegistry,
    OptionRegistry_default,
    registry,
    option_default,
    ALLOWED_TYPES,
    SCALAR_TYPES,
    ALL_TYPES,
    MOST_NEAR_DATETIME,
    MIN_INTEGER,
    MAX_INTEGER,
    MIN_NUMBER,
    MAX_NUMBER,
    constants_default,
    import_randexp,
    random_default,
    RE_NUMERIC,
    utils_default,
    Container,
    Container_default,
    registry2,
    format_default,
    ParseError,
    error_default,
    inferredProperties,
    subschemaProperties,
    infer_default,
    boolean_default,
    booleanType,
    boolean_default2,
    null_default,
    nullType,
    null_default2,
    array_default,
    number_default,
    integer_default,
    LIPSUM_WORDS,
    words_default,
    anyType,
    object_default,
    thunk_default,
    ipv4_default,
    dateTime_default,
    date_default,
    time_default,
    FRAGMENT,
    URI_PATTERN,
    PARAM_PATTERN,
    regexps,
    ALLOWED_FORMATS,
    coreFormat_default,
    string_default,
    typeMap,
    types_default,
    traverse_default,
    buildResolveSchema,
    buildResolveSchema_default,
    run_default,
    js_default,
    import_types2,
    binaryOptions,
    boolOptions,
    intOptions,
    nullOptions,
    strOptions,
    Schema,
    Alias,
    Collection,
    Merge,
    Node,
    Pair,
    Scalar,
    YAMLMap,
    YAMLSeq,
    yaml_default,
    container,
    jsf,
    JSONSchemaFaker,
    lib_default;
  var init_shared = __esm({
    'src/shared.js'() {
      __create = Object.create;
      __defProp2 = Object.defineProperty;
      __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      __getOwnPropNames2 = Object.getOwnPropertyNames;
      __getProtoOf = Object.getPrototypeOf;
      __hasOwnProp2 = Object.prototype.hasOwnProperty;
      __commonJS2 = (cb, mod) =>
        function __require() {
          return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
        };
      __copyProps2 = (to, from, except, desc) => {
        if ((from && typeof from === 'object') || typeof from === 'function') {
          for (const key of __getOwnPropNames2(from))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, {
                get: () => from[key],
                enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable,
              });
        }
        return to;
      };
      __toESM = (mod, isNodeMode, target) => (
        (target = mod != null ? __create(__getProtoOf(mod)) : {}),
        __copyProps2(
          // If the importer is in node compatibility mode or this is not an ESM
          // file that has been converted to a CommonJS file using a Babel-
          // compatible transform (i.e. "__esModule" has not been set), then set
          // "default" to the CommonJS "module.exports" for node compatibility.
          isNodeMode || !mod || !mod.__esModule
            ? __defProp2(target, 'default', { value: mod, enumerable: true })
            : target,
          mod
        )
      );
      require_types = __commonJS2({
        'node_modules/ret/lib/types.js'(exports, module) {
          module.exports = {
            ROOT: 0,
            GROUP: 1,
            POSITION: 2,
            SET: 3,
            RANGE: 4,
            REPETITION: 5,
            REFERENCE: 6,
            CHAR: 7,
          };
        },
      });
      require_sets = __commonJS2({
        'node_modules/ret/lib/sets.js'(exports) {
          var types2 = require_types();
          var INTS = () => [{ type: types2.RANGE, from: 48, to: 57 }];
          var WORDS = () => {
            return [
              { type: types2.CHAR, value: 95 },
              { type: types2.RANGE, from: 97, to: 122 },
              { type: types2.RANGE, from: 65, to: 90 },
            ].concat(INTS());
          };
          var WHITESPACE = () => {
            return [
              { type: types2.CHAR, value: 9 },
              { type: types2.CHAR, value: 10 },
              { type: types2.CHAR, value: 11 },
              { type: types2.CHAR, value: 12 },
              { type: types2.CHAR, value: 13 },
              { type: types2.CHAR, value: 32 },
              { type: types2.CHAR, value: 160 },
              { type: types2.CHAR, value: 5760 },
              { type: types2.RANGE, from: 8192, to: 8202 },
              { type: types2.CHAR, value: 8232 },
              { type: types2.CHAR, value: 8233 },
              { type: types2.CHAR, value: 8239 },
              { type: types2.CHAR, value: 8287 },
              { type: types2.CHAR, value: 12288 },
              { type: types2.CHAR, value: 65279 },
            ];
          };
          var NOTANYCHAR = () => {
            return [
              { type: types2.CHAR, value: 10 },
              { type: types2.CHAR, value: 13 },
              { type: types2.CHAR, value: 8232 },
              { type: types2.CHAR, value: 8233 },
            ];
          };
          exports.words = () => ({ type: types2.SET, set: WORDS(), not: false });
          exports.notWords = () => ({ type: types2.SET, set: WORDS(), not: true });
          exports.ints = () => ({ type: types2.SET, set: INTS(), not: false });
          exports.notInts = () => ({ type: types2.SET, set: INTS(), not: true });
          exports.whitespace = () => ({ type: types2.SET, set: WHITESPACE(), not: false });
          exports.notWhitespace = () => ({ type: types2.SET, set: WHITESPACE(), not: true });
          exports.anyChar = () => ({ type: types2.SET, set: NOTANYCHAR(), not: true });
        },
      });
      require_util = __commonJS2({
        'node_modules/ret/lib/util.js'(exports) {
          var types2 = require_types();
          var sets = require_sets();
          var CTRL = '@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?';
          var SLSH = { 0: 0, t: 9, n: 10, v: 11, f: 12, r: 13 };
          exports.strToChars = (str) => {
            var chars_regex =
              /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z[\\\]^?])|([0tnvfr]))/g;
            str = str.replace(chars_regex, (s, b, lbs, a16, b16, c8, dctrl, eslsh) => {
              if (lbs) {
                return s;
              }
              var code = b
                ? 8
                : a16
                  ? parseInt(a16, 16)
                  : b16
                    ? parseInt(b16, 16)
                    : c8
                      ? parseInt(c8, 8)
                      : dctrl
                        ? CTRL.indexOf(dctrl)
                        : SLSH[eslsh];
              var c = String.fromCharCode(code);
              if (/[[\]{}^$.|?*+()]/.test(c)) {
                c = '\\' + c;
              }
              return c;
            });
            return str;
          };
          exports.tokenizeClass = (str, regexpStr) => {
            var tokens = [];
            var regexp = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(?:\\)?([^\]]))|(\])|(?:\\)?([^])/g;
            var rs, c;
            while ((rs = regexp.exec(str)) != null) {
              if (rs[1]) {
                tokens.push(sets.words());
              } else if (rs[2]) {
                tokens.push(sets.ints());
              } else if (rs[3]) {
                tokens.push(sets.whitespace());
              } else if (rs[4]) {
                tokens.push(sets.notWords());
              } else if (rs[5]) {
                tokens.push(sets.notInts());
              } else if (rs[6]) {
                tokens.push(sets.notWhitespace());
              } else if (rs[7]) {
                tokens.push({
                  type: types2.RANGE,
                  from: (rs[8] || rs[9]).charCodeAt(0),
                  to: rs[10].charCodeAt(0),
                });
              } else if ((c = rs[12])) {
                tokens.push({
                  type: types2.CHAR,
                  value: c.charCodeAt(0),
                });
              } else {
                return [tokens, regexp.lastIndex];
              }
            }
            exports.error(regexpStr, 'Unterminated character class');
          };
          exports.error = (regexp, msg) => {
            throw new SyntaxError('Invalid regular expression: /' + regexp + '/: ' + msg);
          };
        },
      });
      require_positions = __commonJS2({
        'node_modules/ret/lib/positions.js'(exports) {
          var types2 = require_types();
          exports.wordBoundary = () => ({ type: types2.POSITION, value: 'b' });
          exports.nonWordBoundary = () => ({ type: types2.POSITION, value: 'B' });
          exports.begin = () => ({ type: types2.POSITION, value: '^' });
          exports.end = () => ({ type: types2.POSITION, value: '$' });
        },
      });
      require_lib = __commonJS2({
        'node_modules/ret/lib/index.js'(exports, module) {
          var util = require_util();
          var types2 = require_types();
          var sets = require_sets();
          var positions = require_positions();
          module.exports = (regexpStr) => {
            var i = 0,
              l,
              c,
              start = { type: types2.ROOT, stack: [] },
              lastGroup = start,
              last = start.stack,
              groupStack = [];
            var repeatErr = (i2) => {
              util.error(regexpStr, `Nothing to repeat at column ${i2 - 1}`);
            };
            var str = util.strToChars(regexpStr);
            l = str.length;
            while (i < l) {
              c = str[i++];
              switch (c) {
                case '\\':
                  c = str[i++];
                  switch (c) {
                    case 'b':
                      last.push(positions.wordBoundary());
                      break;
                    case 'B':
                      last.push(positions.nonWordBoundary());
                      break;
                    case 'w':
                      last.push(sets.words());
                      break;
                    case 'W':
                      last.push(sets.notWords());
                      break;
                    case 'd':
                      last.push(sets.ints());
                      break;
                    case 'D':
                      last.push(sets.notInts());
                      break;
                    case 's':
                      last.push(sets.whitespace());
                      break;
                    case 'S':
                      last.push(sets.notWhitespace());
                      break;
                    default:
                      if (/\d/.test(c)) {
                        last.push({ type: types2.REFERENCE, value: parseInt(c, 10) });
                      } else {
                        last.push({ type: types2.CHAR, value: c.charCodeAt(0) });
                      }
                  }
                  break;
                case '^':
                  last.push(positions.begin());
                  break;
                case '$':
                  last.push(positions.end());
                  break;
                case '[': {
                  var not;
                  if (str[i] === '^') {
                    not = true;
                    i++;
                  } else {
                    not = false;
                  }
                  var classTokens = util.tokenizeClass(str.slice(i), regexpStr);
                  i += classTokens[1];
                  last.push({
                    type: types2.SET,
                    set: classTokens[0],
                    not,
                  });
                  break;
                }
                case '.':
                  last.push(sets.anyChar());
                  break;
                case '(': {
                  var group = {
                    type: types2.GROUP,
                    stack: [],
                    remember: true,
                  };
                  c = str[i];
                  if (c === '?') {
                    c = str[i + 1];
                    i += 2;
                    if (c === '=') {
                      group.followedBy = true;
                    } else if (c === '!') {
                      group.notFollowedBy = true;
                    } else if (c !== ':') {
                      util.error(regexpStr, `Invalid group, character '${c}' after '?' at column ${i - 1}`);
                    }
                    group.remember = false;
                  }
                  last.push(group);
                  groupStack.push(lastGroup);
                  lastGroup = group;
                  last = group.stack;
                  break;
                }
                case ')':
                  if (groupStack.length === 0) {
                    util.error(regexpStr, `Unmatched ) at column ${i - 1}`);
                  }
                  lastGroup = groupStack.pop();
                  last = lastGroup.options ? lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;
                  break;
                case '|': {
                  if (!lastGroup.options) {
                    lastGroup.options = [lastGroup.stack];
                    delete lastGroup.stack;
                  }
                  var stack = [];
                  lastGroup.options.push(stack);
                  last = stack;
                  break;
                }
                case '{': {
                  var rs = /^(\d+)(,(\d+)?)?\}/.exec(str.slice(i)),
                    min,
                    max;
                  if (rs !== null) {
                    if (last.length === 0) {
                      repeatErr(i);
                    }
                    min = parseInt(rs[1], 10);
                    max = rs[2] ? (rs[3] ? parseInt(rs[3], 10) : Infinity) : min;
                    i += rs[0].length;
                    last.push({
                      type: types2.REPETITION,
                      min,
                      max,
                      value: last.pop(),
                    });
                  } else {
                    last.push({
                      type: types2.CHAR,
                      value: 123,
                    });
                  }
                  break;
                }
                case '?':
                  if (last.length === 0) {
                    repeatErr(i);
                  }
                  last.push({
                    type: types2.REPETITION,
                    min: 0,
                    max: 1,
                    value: last.pop(),
                  });
                  break;
                case '+':
                  if (last.length === 0) {
                    repeatErr(i);
                  }
                  last.push({
                    type: types2.REPETITION,
                    min: 1,
                    max: Infinity,
                    value: last.pop(),
                  });
                  break;
                case '*':
                  if (last.length === 0) {
                    repeatErr(i);
                  }
                  last.push({
                    type: types2.REPETITION,
                    min: 0,
                    max: Infinity,
                    value: last.pop(),
                  });
                  break;
                default:
                  last.push({
                    type: types2.CHAR,
                    value: c.charCodeAt(0),
                  });
              }
            }
            if (groupStack.length !== 0) {
              util.error(regexpStr, 'Unterminated group');
            }
            return start;
          };
          module.exports.types = types2;
        },
      });
      require_lib2 = __commonJS2({
        'node_modules/drange/lib/index.js'(exports, module) {
          var SubRange = class _SubRange {
            constructor(low, high) {
              this.low = low;
              this.high = high;
              this.length = 1 + high - low;
            }
            overlaps(range) {
              return !(this.high < range.low || this.low > range.high);
            }
            touches(range) {
              return !(this.high + 1 < range.low || this.low - 1 > range.high);
            }
            // Returns inclusive combination of SubRanges as a SubRange.
            add(range) {
              return new _SubRange(Math.min(this.low, range.low), Math.max(this.high, range.high));
            }
            // Returns subtraction of SubRanges as an array of SubRanges.
            // (There's a case where subtraction divides it in 2)
            subtract(range) {
              if (range.low <= this.low && range.high >= this.high) {
                return [];
              } else if (range.low > this.low && range.high < this.high) {
                return [new _SubRange(this.low, range.low - 1), new _SubRange(range.high + 1, this.high)];
              } else if (range.low <= this.low) {
                return [new _SubRange(range.high + 1, this.high)];
              } else {
                return [new _SubRange(this.low, range.low - 1)];
              }
            }
            toString() {
              return this.low == this.high ? this.low.toString() : this.low + '-' + this.high;
            }
          };
          var DRange = class _DRange {
            constructor(a, b) {
              this.ranges = [];
              this.length = 0;
              if (a != null) this.add(a, b);
            }
            _update_length() {
              this.length = this.ranges.reduce((previous, range) => {
                return previous + range.length;
              }, 0);
            }
            add(a, b) {
              var _add = (subrange) => {
                var i = 0;
                while (i < this.ranges.length && !subrange.touches(this.ranges[i])) {
                  i++;
                }
                var newRanges = this.ranges.slice(0, i);
                while (i < this.ranges.length && subrange.touches(this.ranges[i])) {
                  subrange = subrange.add(this.ranges[i]);
                  i++;
                }
                newRanges.push(subrange);
                this.ranges = newRanges.concat(this.ranges.slice(i));
                this._update_length();
              };
              if (a instanceof _DRange) {
                a.ranges.forEach(_add);
              } else {
                if (b == null) b = a;
                _add(new SubRange(a, b));
              }
              return this;
            }
            subtract(a, b) {
              var _subtract = (subrange) => {
                var i = 0;
                while (i < this.ranges.length && !subrange.overlaps(this.ranges[i])) {
                  i++;
                }
                var newRanges = this.ranges.slice(0, i);
                while (i < this.ranges.length && subrange.overlaps(this.ranges[i])) {
                  newRanges = newRanges.concat(this.ranges[i].subtract(subrange));
                  i++;
                }
                this.ranges = newRanges.concat(this.ranges.slice(i));
                this._update_length();
              };
              if (a instanceof _DRange) {
                a.ranges.forEach(_subtract);
              } else {
                if (b == null) b = a;
                _subtract(new SubRange(a, b));
              }
              return this;
            }
            intersect(a, b) {
              var newRanges = [];
              var _intersect = (subrange) => {
                var i = 0;
                while (i < this.ranges.length && !subrange.overlaps(this.ranges[i])) {
                  i++;
                }
                while (i < this.ranges.length && subrange.overlaps(this.ranges[i])) {
                  var low = Math.max(this.ranges[i].low, subrange.low);
                  var high = Math.min(this.ranges[i].high, subrange.high);
                  newRanges.push(new SubRange(low, high));
                  i++;
                }
              };
              if (a instanceof _DRange) {
                a.ranges.forEach(_intersect);
              } else {
                if (b == null) b = a;
                _intersect(new SubRange(a, b));
              }
              this.ranges = newRanges;
              this._update_length();
              return this;
            }
            index(index) {
              var i = 0;
              while (i < this.ranges.length && this.ranges[i].length <= index) {
                index -= this.ranges[i].length;
                i++;
              }
              return this.ranges[i].low + index;
            }
            toString() {
              return '[ ' + this.ranges.join(', ') + ' ]';
            }
            clone() {
              return new _DRange(this);
            }
            numbers() {
              return this.ranges.reduce((result, subrange) => {
                var i = subrange.low;
                while (i <= subrange.high) {
                  result.push(i);
                  i++;
                }
                return result;
              }, []);
            }
            subranges() {
              return this.ranges.map((subrange) => ({
                low: subrange.low,
                high: subrange.high,
                length: 1 + subrange.high - subrange.low,
              }));
            }
          };
          module.exports = DRange;
        },
      });
      require_randexp = __commonJS2({
        'node_modules/randexp/lib/randexp.js'(exports, module) {
          var ret = require_lib();
          var DRange = require_lib2();
          var types2 = ret.types;
          module.exports = class RandExp2 {
            /**
             * @constructor
             * @param {RegExp|String} regexp
             * @param {String} m
             */
            constructor(regexp, m) {
              this._setDefaults(regexp);
              if (regexp instanceof RegExp) {
                this.ignoreCase = regexp.ignoreCase;
                this.multiline = regexp.multiline;
                regexp = regexp.source;
              } else if (typeof regexp === 'string') {
                this.ignoreCase = m && m.indexOf('i') !== -1;
                this.multiline = m && m.indexOf('m') !== -1;
              } else {
                throw new Error('Expected a regexp or string');
              }
              this.tokens = ret(regexp);
            }
            /**
             * Checks if some custom properties have been set for this regexp.
             *
             * @param {RandExp} randexp
             * @param {RegExp} regexp
             */
            _setDefaults(regexp) {
              this.max =
                regexp.max != null ? regexp.max : RandExp2.prototype.max != null ? RandExp2.prototype.max : 100;
              this.defaultRange = regexp.defaultRange ? regexp.defaultRange : this.defaultRange.clone();
              if (regexp.randInt) {
                this.randInt = regexp.randInt;
              }
            }
            /**
             * Generates the random string.
             *
             * @return {String}
             */
            gen() {
              return this._gen(this.tokens, []);
            }
            /**
             * Generate random string modeled after given tokens.
             *
             * @param {Object} token
             * @param {Array.<String>} groups
             * @return {String}
             */
            _gen(token, groups) {
              var stack, str, n, i, l;
              switch (token.type) {
                case types2.ROOT:
                case types2.GROUP:
                  if (token.followedBy || token.notFollowedBy) {
                    return '';
                  }
                  if (token.remember && token.groupNumber === void 0) {
                    token.groupNumber = groups.push(null) - 1;
                  }
                  stack = token.options ? this._randSelect(token.options) : token.stack;
                  str = '';
                  for (i = 0, l = stack.length; i < l; i++) {
                    str += this._gen(stack[i], groups);
                  }
                  if (token.remember) {
                    groups[token.groupNumber] = str;
                  }
                  return str;
                case types2.POSITION:
                  return '';
                case types2.SET: {
                  var expandedSet = this._expand(token);
                  if (!expandedSet.length) {
                    return '';
                  }
                  return String.fromCharCode(this._randSelect(expandedSet));
                }
                case types2.REPETITION:
                  n = this.randInt(token.min, token.max === Infinity ? token.min + this.max : token.max);
                  str = '';
                  for (i = 0; i < n; i++) {
                    str += this._gen(token.value, groups);
                  }
                  return str;
                case types2.REFERENCE:
                  return groups[token.value - 1] || '';
                case types2.CHAR: {
                  var code = this.ignoreCase && this._randBool() ? this._toOtherCase(token.value) : token.value;
                  return String.fromCharCode(code);
                }
              }
            }
            /**
             * If code is alphabetic, converts to other case.
             * If not alphabetic, returns back code.
             *
             * @param {Number} code
             * @return {Number}
             */
            _toOtherCase(code) {
              return code + (97 <= code && code <= 122 ? -32 : 65 <= code && code <= 90 ? 32 : 0);
            }
            /**
             * Randomly returns a true or false value.
             *
             * @return {Boolean}
             */
            _randBool() {
              return !this.randInt(0, 1);
            }
            /**
             * Randomly selects and returns a value from the array.
             *
             * @param {Array.<Object>} arr
             * @return {Object}
             */
            _randSelect(arr) {
              if (arr instanceof DRange) {
                return arr.index(this.randInt(0, arr.length - 1));
              }
              return arr[this.randInt(0, arr.length - 1)];
            }
            /**
             * expands a token to a DiscontinuousRange of characters which has a
             * length and an index function (for random selecting)
             *
             * @param {Object} token
             * @return {DiscontinuousRange}
             */
            _expand(token) {
              if (token.type === ret.types.CHAR) {
                return new DRange(token.value);
              } else if (token.type === ret.types.RANGE) {
                return new DRange(token.from, token.to);
              } else {
                const drange = new DRange();
                for (let i = 0; i < token.set.length; i++) {
                  const subrange = this._expand(token.set[i]);
                  drange.add(subrange);
                  if (this.ignoreCase) {
                    for (let j = 0; j < subrange.length; j++) {
                      const code = subrange.index(j);
                      const otherCaseCode = this._toOtherCase(code);
                      if (code !== otherCaseCode) {
                        drange.add(otherCaseCode);
                      }
                    }
                  }
                }
                if (token.not) {
                  return this.defaultRange.clone().subtract(drange);
                } else {
                  return this.defaultRange.clone().intersect(drange);
                }
              }
            }
            /**
             * Randomly generates and returns a number between a and b (inclusive).
             *
             * @param {Number} a
             * @param {Number} b
             * @return {Number}
             */
            randInt(a, b) {
              return a + Math.floor(Math.random() * (1 + b - a));
            }
            /**
             * Default range of characters to generate from.
             */
            get defaultRange() {
              return (this._range = this._range || new DRange(32, 126));
            }
            set defaultRange(range) {
              this._range = range;
            }
            /**
             *
             * Enables use of randexp with a shorter call.
             *
             * @param {RegExp|String| regexp}
             * @param {String} m
             * @return {String}
             */
            static randexp(regexp, m) {
              var randexp;
              if (typeof regexp === 'string') {
                regexp = new RegExp(regexp, m);
              }
              if (regexp._randexp === void 0) {
                randexp = new RandExp2(regexp, m);
                regexp._randexp = randexp;
              } else {
                randexp = regexp._randexp;
                randexp._setDefaults(regexp);
              }
              return randexp.gen();
            }
            /**
             * Enables sugary /regexp/.gen syntax.
             */
            static sugar() {
              RegExp.prototype.gen = function () {
                return RandExp2.randexp(this);
              };
            }
          };
        },
      });
      require_PlainValue_ec8e588e = __commonJS2({
        'node_modules/yaml/dist/PlainValue-ec8e588e.js'(exports) {
          var Char = {
            ANCHOR: '&',
            COMMENT: '#',
            TAG: '!',
            DIRECTIVES_END: '-',
            DOCUMENT_END: '.',
          };
          var Type = {
            ALIAS: 'ALIAS',
            BLANK_LINE: 'BLANK_LINE',
            BLOCK_FOLDED: 'BLOCK_FOLDED',
            BLOCK_LITERAL: 'BLOCK_LITERAL',
            COMMENT: 'COMMENT',
            DIRECTIVE: 'DIRECTIVE',
            DOCUMENT: 'DOCUMENT',
            FLOW_MAP: 'FLOW_MAP',
            FLOW_SEQ: 'FLOW_SEQ',
            MAP: 'MAP',
            MAP_KEY: 'MAP_KEY',
            MAP_VALUE: 'MAP_VALUE',
            PLAIN: 'PLAIN',
            QUOTE_DOUBLE: 'QUOTE_DOUBLE',
            QUOTE_SINGLE: 'QUOTE_SINGLE',
            SEQ: 'SEQ',
            SEQ_ITEM: 'SEQ_ITEM',
          };
          var defaultTagPrefix = 'tag:yaml.org,2002:';
          var defaultTags = {
            MAP: 'tag:yaml.org,2002:map',
            SEQ: 'tag:yaml.org,2002:seq',
            STR: 'tag:yaml.org,2002:str',
          };
          function findLineStarts(src) {
            const ls = [0];
            let offset = src.indexOf('\n');
            while (offset !== -1) {
              offset += 1;
              ls.push(offset);
              offset = src.indexOf('\n', offset);
            }
            return ls;
          }
          function getSrcInfo(cst) {
            let lineStarts, src;
            if (typeof cst === 'string') {
              lineStarts = findLineStarts(cst);
              src = cst;
            } else {
              if (Array.isArray(cst)) cst = cst[0];
              if (cst && cst.context) {
                if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);
                lineStarts = cst.lineStarts;
                src = cst.context.src;
              }
            }
            return {
              lineStarts,
              src,
            };
          }
          function getLinePos(offset, cst) {
            if (typeof offset !== 'number' || offset < 0) return null;
            const { lineStarts, src } = getSrcInfo(cst);
            if (!lineStarts || !src || offset > src.length) return null;
            for (let i = 0; i < lineStarts.length; ++i) {
              const start = lineStarts[i];
              if (offset < start) {
                return {
                  line: i,
                  col: offset - lineStarts[i - 1] + 1,
                };
              }
              if (offset === start)
                return {
                  line: i + 1,
                  col: 1,
                };
            }
            const line = lineStarts.length;
            return {
              line,
              col: offset - lineStarts[line - 1] + 1,
            };
          }
          function getLine(line, cst) {
            const { lineStarts, src } = getSrcInfo(cst);
            if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;
            const start = lineStarts[line - 1];
            let end = lineStarts[line];
            while (end && end > start && src[end - 1] === '\n') --end;
            return src.slice(start, end);
          }
          function getPrettyContext({ start, end }, cst, maxWidth = 80) {
            let src = getLine(start.line, cst);
            if (!src) return null;
            let { col } = start;
            if (src.length > maxWidth) {
              if (col <= maxWidth - 10) {
                src = src.substr(0, maxWidth - 1) + '\u2026';
              } else {
                const halfWidth = Math.round(maxWidth / 2);
                if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + '\u2026';
                col -= src.length - maxWidth;
                src = '\u2026' + src.substr(1 - maxWidth);
              }
            }
            let errLen = 1;
            let errEnd = '';
            if (end) {
              if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {
                errLen = end.col - start.col;
              } else {
                errLen = Math.min(src.length + 1, maxWidth) - col;
                errEnd = '\u2026';
              }
            }
            const offset = col > 1 ? ' '.repeat(col - 1) : '';
            const err = '^'.repeat(errLen);
            return `${src}
${offset}${err}${errEnd}`;
          }
          var Range = class _Range {
            static copy(orig) {
              return new _Range(orig.start, orig.end);
            }
            constructor(start, end) {
              this.start = start;
              this.end = end || start;
            }
            isEmpty() {
              return typeof this.start !== 'number' || !this.end || this.end <= this.start;
            }
            /**
             * Set `origStart` and `origEnd` to point to the original source range for
             * this node, which may differ due to dropped CR characters.
             *
             * @param {number[]} cr - Positions of dropped CR characters
             * @param {number} offset - Starting index of `cr` from the last call
             * @returns {number} - The next offset, matching the one found for `origStart`
             */
            setOrigRange(cr, offset) {
              const { start, end } = this;
              if (cr.length === 0 || end <= cr[0]) {
                this.origStart = start;
                this.origEnd = end;
                return offset;
              }
              let i = offset;
              while (i < cr.length) {
                if (cr[i] > start) break;
                else ++i;
              }
              this.origStart = start + i;
              const nextOffset = i;
              while (i < cr.length) {
                if (cr[i] >= end) break;
                else ++i;
              }
              this.origEnd = end + i;
              return nextOffset;
            }
          };
          var Node2 = class _Node {
            static addStringTerminator(src, offset, str) {
              if (str[str.length - 1] === '\n') return str;
              const next = _Node.endOfWhiteSpace(src, offset);
              return next >= src.length || src[next] === '\n' ? str + '\n' : str;
            }
            // ^(---|...)
            static atDocumentBoundary(src, offset, sep) {
              const ch0 = src[offset];
              if (!ch0) return true;
              const prev = src[offset - 1];
              if (prev && prev !== '\n') return false;
              if (sep) {
                if (ch0 !== sep) return false;
              } else {
                if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END) return false;
              }
              const ch1 = src[offset + 1];
              const ch2 = src[offset + 2];
              if (ch1 !== ch0 || ch2 !== ch0) return false;
              const ch3 = src[offset + 3];
              return !ch3 || ch3 === '\n' || ch3 === '	' || ch3 === ' ';
            }
            static endOfIdentifier(src, offset) {
              let ch = src[offset];
              const isVerbatim = ch === '<';
              const notOk = isVerbatim ? ['\n', '	', ' ', '>'] : ['\n', '	', ' ', '[', ']', '{', '}', ','];
              while (ch && notOk.indexOf(ch) === -1) ch = src[(offset += 1)];
              if (isVerbatim && ch === '>') offset += 1;
              return offset;
            }
            static endOfIndent(src, offset) {
              let ch = src[offset];
              while (ch === ' ') ch = src[(offset += 1)];
              return offset;
            }
            static endOfLine(src, offset) {
              let ch = src[offset];
              while (ch && ch !== '\n') ch = src[(offset += 1)];
              return offset;
            }
            static endOfWhiteSpace(src, offset) {
              let ch = src[offset];
              while (ch === '	' || ch === ' ') ch = src[(offset += 1)];
              return offset;
            }
            static startOfLine(src, offset) {
              let ch = src[offset - 1];
              if (ch === '\n') return offset;
              while (ch && ch !== '\n') ch = src[(offset -= 1)];
              return offset + 1;
            }
            /**
             * End of indentation, or null if the line's indent level is not more
             * than `indent`
             *
             * @param {string} src
             * @param {number} indent
             * @param {number} lineStart
             * @returns {?number}
             */
            static endOfBlockIndent(src, indent, lineStart) {
              const inEnd = _Node.endOfIndent(src, lineStart);
              if (inEnd > lineStart + indent) {
                return inEnd;
              } else {
                const wsEnd = _Node.endOfWhiteSpace(src, inEnd);
                const ch = src[wsEnd];
                if (!ch || ch === '\n') return wsEnd;
              }
              return null;
            }
            static atBlank(src, offset, endAsBlank) {
              const ch = src[offset];
              return ch === '\n' || ch === '	' || ch === ' ' || (endAsBlank && !ch);
            }
            static nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {
              if (!ch || indentDiff < 0) return false;
              if (indentDiff > 0) return true;
              return indicatorAsIndent && ch === '-';
            }
            // should be at line or string end, or at next non-whitespace char
            static normalizeOffset(src, offset) {
              const ch = src[offset];
              return !ch
                ? offset
                : ch !== '\n' && src[offset - 1] === '\n'
                  ? offset - 1
                  : _Node.endOfWhiteSpace(src, offset);
            }
            // fold single newline into space, multiple newlines to N - 1 newlines
            // presumes src[offset] === '\n'
            static foldNewline(src, offset, indent) {
              let inCount = 0;
              let error = false;
              let fold = '';
              let ch = src[offset + 1];
              while (ch === ' ' || ch === '	' || ch === '\n') {
                switch (ch) {
                  case '\n':
                    inCount = 0;
                    offset += 1;
                    fold += '\n';
                    break;
                  case '	':
                    if (inCount <= indent) error = true;
                    offset = _Node.endOfWhiteSpace(src, offset + 2) - 1;
                    break;
                  case ' ':
                    inCount += 1;
                    offset += 1;
                    break;
                }
                ch = src[offset + 1];
              }
              if (!fold) fold = ' ';
              if (ch && inCount <= indent) error = true;
              return {
                fold,
                offset,
                error,
              };
            }
            constructor(type, props, context) {
              Object.defineProperty(this, 'context', {
                value: context || null,
                writable: true,
              });
              this.error = null;
              this.range = null;
              this.valueRange = null;
              this.props = props || [];
              this.type = type;
              this.value = null;
            }
            getPropValue(idx, key, skipKey) {
              if (!this.context) return null;
              const { src } = this.context;
              const prop = this.props[idx];
              return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;
            }
            get anchor() {
              for (let i = 0; i < this.props.length; ++i) {
                const anchor = this.getPropValue(i, Char.ANCHOR, true);
                if (anchor != null) return anchor;
              }
              return null;
            }
            get comment() {
              const comments = [];
              for (let i = 0; i < this.props.length; ++i) {
                const comment = this.getPropValue(i, Char.COMMENT, true);
                if (comment != null) comments.push(comment);
              }
              return comments.length > 0 ? comments.join('\n') : null;
            }
            commentHasRequiredWhitespace(start) {
              const { src } = this.context;
              if (this.header && start === this.header.end) return false;
              if (!this.valueRange) return false;
              const { end } = this.valueRange;
              return start !== end || _Node.atBlank(src, end - 1);
            }
            get hasComment() {
              if (this.context) {
                const { src } = this.context;
                for (let i = 0; i < this.props.length; ++i) {
                  if (src[this.props[i].start] === Char.COMMENT) return true;
                }
              }
              return false;
            }
            get hasProps() {
              if (this.context) {
                const { src } = this.context;
                for (let i = 0; i < this.props.length; ++i) {
                  if (src[this.props[i].start] !== Char.COMMENT) return true;
                }
              }
              return false;
            }
            get includesTrailingLines() {
              return false;
            }
            get jsonLike() {
              const jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];
              return jsonLikeTypes.indexOf(this.type) !== -1;
            }
            get rangeAsLinePos() {
              if (!this.range || !this.context) return void 0;
              const start = getLinePos(this.range.start, this.context.root);
              if (!start) return void 0;
              const end = getLinePos(this.range.end, this.context.root);
              return {
                start,
                end,
              };
            }
            get rawValue() {
              if (!this.valueRange || !this.context) return null;
              const { start, end } = this.valueRange;
              return this.context.src.slice(start, end);
            }
            get tag() {
              for (let i = 0; i < this.props.length; ++i) {
                const tag = this.getPropValue(i, Char.TAG, false);
                if (tag != null) {
                  if (tag[1] === '<') {
                    return {
                      verbatim: tag.slice(2, -1),
                    };
                  } else {
                    const [_, handle, suffix] = tag.match(/^(.*!)([^!]*)$/);
                    return {
                      handle,
                      suffix,
                    };
                  }
                }
              }
              return null;
            }
            get valueRangeContainsNewline() {
              if (!this.valueRange || !this.context) return false;
              const { start, end } = this.valueRange;
              const { src } = this.context;
              for (let i = start; i < end; ++i) {
                if (src[i] === '\n') return true;
              }
              return false;
            }
            parseComment(start) {
              const { src } = this.context;
              if (src[start] === Char.COMMENT) {
                const end = _Node.endOfLine(src, start + 1);
                const commentRange = new Range(start, end);
                this.props.push(commentRange);
                return end;
              }
              return start;
            }
            /**
             * Populates the `origStart` and `origEnd` values of all ranges for this
             * node. Extended by child classes to handle descendant nodes.
             *
             * @param {number[]} cr - Positions of dropped CR characters
             * @param {number} offset - Starting index of `cr` from the last call
             * @returns {number} - The next offset, matching the one found for `origStart`
             */
            setOrigRanges(cr, offset) {
              if (this.range) offset = this.range.setOrigRange(cr, offset);
              if (this.valueRange) this.valueRange.setOrigRange(cr, offset);
              this.props.forEach((prop) => prop.setOrigRange(cr, offset));
              return offset;
            }
            toString() {
              const {
                context: { src },
                range,
                value,
              } = this;
              if (value != null) return value;
              const str = src.slice(range.start, range.end);
              return _Node.addStringTerminator(src, range.end, str);
            }
          };
          var YAMLError = class extends Error {
            constructor(name, source, message) {
              if (!message || !(source instanceof Node2)) throw new Error(`Invalid arguments for new ${name}`);
              super();
              this.name = name;
              this.message = message;
              this.source = source;
            }
            makePretty() {
              if (!this.source) return;
              this.nodeType = this.source.type;
              const cst = this.source.context && this.source.context.root;
              if (typeof this.offset === 'number') {
                this.range = new Range(this.offset, this.offset + 1);
                const start = cst && getLinePos(this.offset, cst);
                if (start) {
                  const end = {
                    line: start.line,
                    col: start.col + 1,
                  };
                  this.linePos = {
                    start,
                    end,
                  };
                }
                delete this.offset;
              } else {
                this.range = this.source.range;
                this.linePos = this.source.rangeAsLinePos;
              }
              if (this.linePos) {
                const { line, col } = this.linePos.start;
                this.message += ` at line ${line}, column ${col}`;
                const ctx = cst && getPrettyContext(this.linePos, cst);
                if (ctx)
                  this.message += `:

${ctx}
`;
              }
              delete this.source;
            }
          };
          var YAMLReferenceError = class extends YAMLError {
            constructor(source, message) {
              super('YAMLReferenceError', source, message);
            }
          };
          var YAMLSemanticError = class extends YAMLError {
            constructor(source, message) {
              super('YAMLSemanticError', source, message);
            }
          };
          var YAMLSyntaxError = class extends YAMLError {
            constructor(source, message) {
              super('YAMLSyntaxError', source, message);
            }
          };
          var YAMLWarning = class extends YAMLError {
            constructor(source, message) {
              super('YAMLWarning', source, message);
            }
          };
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value,
                enumerable: true,
                configurable: true,
                writable: true,
              });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var PlainValue = class _PlainValue extends Node2 {
            static endOfLine(src, start, inFlow) {
              let ch = src[start];
              let offset = start;
              while (ch && ch !== '\n') {
                if (inFlow && (ch === '[' || ch === ']' || ch === '{' || ch === '}' || ch === ',')) break;
                const next = src[offset + 1];
                if (ch === ':' && (!next || next === '\n' || next === '	' || next === ' ' || (inFlow && next === ',')))
                  break;
                if ((ch === ' ' || ch === '	') && next === '#') break;
                offset += 1;
                ch = next;
              }
              return offset;
            }
            get strValue() {
              if (!this.valueRange || !this.context) return null;
              let { start, end } = this.valueRange;
              const { src } = this.context;
              let ch = src[end - 1];
              while (start < end && (ch === '\n' || ch === '	' || ch === ' ')) ch = src[--end - 1];
              let str = '';
              for (let i = start; i < end; ++i) {
                const ch2 = src[i];
                if (ch2 === '\n') {
                  const { fold, offset } = Node2.foldNewline(src, i, -1);
                  str += fold;
                  i = offset;
                } else if (ch2 === ' ' || ch2 === '	') {
                  const wsStart = i;
                  let next = src[i + 1];
                  while (i < end && (next === ' ' || next === '	')) {
                    i += 1;
                    next = src[i + 1];
                  }
                  if (next !== '\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch2;
                } else {
                  str += ch2;
                }
              }
              const ch0 = src[start];
              switch (ch0) {
                case '	': {
                  const msg = 'Plain value cannot start with a tab character';
                  const errors = [new YAMLSemanticError(this, msg)];
                  return {
                    errors,
                    str,
                  };
                }
                case '@':
                case '`': {
                  const msg = `Plain value cannot start with reserved character ${ch0}`;
                  const errors = [new YAMLSemanticError(this, msg)];
                  return {
                    errors,
                    str,
                  };
                }
                default:
                  return str;
              }
            }
            parseBlockValue(start) {
              const { indent, inFlow, src } = this.context;
              let offset = start;
              let valueEnd = start;
              for (let ch = src[offset]; ch === '\n'; ch = src[offset]) {
                if (Node2.atDocumentBoundary(src, offset + 1)) break;
                const end = Node2.endOfBlockIndent(src, indent, offset + 1);
                if (end === null || src[end] === '#') break;
                if (src[end] === '\n') {
                  offset = end;
                } else {
                  valueEnd = _PlainValue.endOfLine(src, end, inFlow);
                  offset = valueEnd;
                }
              }
              if (this.valueRange.isEmpty()) this.valueRange.start = start;
              this.valueRange.end = valueEnd;
              return valueEnd;
            }
            /**
             * Parses a plain value from the source
             *
             * Accepted forms are:
             * ```
             * #comment
             *
             * first line
             *
             * first line #comment
             *
             * first line
             * block
             * lines
             *
             * #comment
             * block
             * lines
             * ```
             * where block lines are empty or have an indent level greater than `indent`.
             *
             * @param {ParseContext} context
             * @param {number} start - Index of first character
             * @returns {number} - Index of the character after this scalar, may be `\n`
             */
            parse(context, start) {
              this.context = context;
              const { inFlow, src } = context;
              let offset = start;
              const ch = src[offset];
              if (ch && ch !== '#' && ch !== '\n') {
                offset = _PlainValue.endOfLine(src, start, inFlow);
              }
              this.valueRange = new Range(start, offset);
              offset = Node2.endOfWhiteSpace(src, offset);
              offset = this.parseComment(offset);
              if (!this.hasComment || this.valueRange.isEmpty()) {
                offset = this.parseBlockValue(offset);
              }
              return offset;
            }
          };
          exports.Char = Char;
          exports.Node = Node2;
          exports.PlainValue = PlainValue;
          exports.Range = Range;
          exports.Type = Type;
          exports.YAMLError = YAMLError;
          exports.YAMLReferenceError = YAMLReferenceError;
          exports.YAMLSemanticError = YAMLSemanticError;
          exports.YAMLSyntaxError = YAMLSyntaxError;
          exports.YAMLWarning = YAMLWarning;
          exports._defineProperty = _defineProperty;
          exports.defaultTagPrefix = defaultTagPrefix;
          exports.defaultTags = defaultTags;
        },
      });
      require_resolveSeq_d03cb037 = __commonJS2({
        'node_modules/yaml/dist/resolveSeq-d03cb037.js'(exports) {
          var PlainValue = require_PlainValue_ec8e588e();
          function addCommentBefore(str, indent, comment) {
            if (!comment) return str;
            const cc = comment.replace(/[\s\S]^/gm, `$&${indent}#`);
            return `#${cc}
${indent}${str}`;
          }
          function addComment(str, indent, comment) {
            return !comment
              ? str
              : comment.indexOf('\n') === -1
                ? `${str} #${comment}`
                : `${str}
` + comment.replace(/^/gm, `${indent || ''}#`);
          }
          var Node2 = class {};
          function toJSON(value, arg, ctx) {
            if (Array.isArray(value)) return value.map((v, i) => toJSON(v, String(i), ctx));
            if (value && typeof value.toJSON === 'function') {
              const anchor = ctx && ctx.anchors && ctx.anchors.get(value);
              if (anchor)
                ctx.onCreate = (res2) => {
                  anchor.res = res2;
                  delete ctx.onCreate;
                };
              const res = value.toJSON(arg, ctx);
              if (anchor && ctx.onCreate) ctx.onCreate(res);
              return res;
            }
            if ((!ctx || !ctx.keep) && typeof value === 'bigint') return Number(value);
            return value;
          }
          var Scalar2 = class extends Node2 {
            constructor(value) {
              super();
              this.value = value;
            }
            toJSON(arg, ctx) {
              return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);
            }
            toString() {
              return String(this.value);
            }
          };
          function collectionFromPath(schema, path, value) {
            let v = value;
            for (let i = path.length - 1; i >= 0; --i) {
              const k = path[i];
              if (Number.isInteger(k) && k >= 0) {
                const a = [];
                a[k] = v;
                v = a;
              } else {
                const o = {};
                Object.defineProperty(o, k, {
                  value: v,
                  writable: true,
                  enumerable: true,
                  configurable: true,
                });
                v = o;
              }
            }
            return schema.createNode(v, false);
          }
          var isEmptyPath = (path) => path == null || (typeof path === 'object' && path[Symbol.iterator]().next().done);
          var Collection2 = class _Collection extends Node2 {
            constructor(schema) {
              super();
              PlainValue._defineProperty(this, 'items', []);
              this.schema = schema;
            }
            addIn(path, value) {
              if (isEmptyPath(path)) this.add(value);
              else {
                const [key, ...rest] = path;
                const node = this.get(key, true);
                if (node instanceof _Collection) node.addIn(rest, value);
                else if (node === void 0 && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));
                else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
              }
            }
            deleteIn([key, ...rest]) {
              if (rest.length === 0) return this.delete(key);
              const node = this.get(key, true);
              if (node instanceof _Collection) return node.deleteIn(rest);
              else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
            }
            getIn([key, ...rest], keepScalar) {
              const node = this.get(key, true);
              if (rest.length === 0) return !keepScalar && node instanceof Scalar2 ? node.value : node;
              else return node instanceof _Collection ? node.getIn(rest, keepScalar) : void 0;
            }
            hasAllNullValues() {
              return this.items.every((node) => {
                if (!node || node.type !== 'PAIR') return false;
                const n = node.value;
                return (
                  n == null || (n instanceof Scalar2 && n.value == null && !n.commentBefore && !n.comment && !n.tag)
                );
              });
            }
            hasIn([key, ...rest]) {
              if (rest.length === 0) return this.has(key);
              const node = this.get(key, true);
              return node instanceof _Collection ? node.hasIn(rest) : false;
            }
            setIn([key, ...rest], value) {
              if (rest.length === 0) {
                this.set(key, value);
              } else {
                const node = this.get(key, true);
                if (node instanceof _Collection) node.setIn(rest, value);
                else if (node === void 0 && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));
                else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
              }
            }
            // overridden in implementations
            /* istanbul ignore next */
            toJSON() {
              return null;
            }
            toString(ctx, { blockItem, flowChars, isMap, itemIndent }, onComment, onChompKeep) {
              const { indent, indentStep, stringify } = ctx;
              const inFlow =
                this.type === PlainValue.Type.FLOW_MAP || this.type === PlainValue.Type.FLOW_SEQ || ctx.inFlow;
              if (inFlow) itemIndent += indentStep;
              const allNullValues = isMap && this.hasAllNullValues();
              ctx = Object.assign({}, ctx, {
                allNullValues,
                indent: itemIndent,
                inFlow,
                type: null,
              });
              let chompKeep = false;
              let hasItemWithNewLine = false;
              const nodes = this.items.reduce((nodes2, item, i) => {
                let comment;
                if (item) {
                  if (!chompKeep && item.spaceBefore)
                    nodes2.push({
                      type: 'comment',
                      str: '',
                    });
                  if (item.commentBefore)
                    item.commentBefore.match(/^.*$/gm).forEach((line) => {
                      nodes2.push({
                        type: 'comment',
                        str: `#${line}`,
                      });
                    });
                  if (item.comment) comment = item.comment;
                  if (
                    inFlow &&
                    ((!chompKeep && item.spaceBefore) ||
                      item.commentBefore ||
                      item.comment ||
                      (item.key && (item.key.commentBefore || item.key.comment)) ||
                      (item.value && (item.value.commentBefore || item.value.comment)))
                  )
                    hasItemWithNewLine = true;
                }
                chompKeep = false;
                let str2 = stringify(
                  item,
                  ctx,
                  () => (comment = null),
                  () => (chompKeep = true)
                );
                if (inFlow && !hasItemWithNewLine && str2.includes('\n')) hasItemWithNewLine = true;
                if (inFlow && i < this.items.length - 1) str2 += ',';
                str2 = addComment(str2, itemIndent, comment);
                if (chompKeep && (comment || inFlow)) chompKeep = false;
                nodes2.push({
                  type: 'item',
                  str: str2,
                });
                return nodes2;
              }, []);
              let str;
              if (nodes.length === 0) {
                str = flowChars.start + flowChars.end;
              } else if (inFlow) {
                const { start, end } = flowChars;
                const strings = nodes.map((n) => n.str);
                if (
                  hasItemWithNewLine ||
                  strings.reduce((sum, str2) => sum + str2.length + 2, 2) > _Collection.maxFlowStringSingleLineLength
                ) {
                  str = start;
                  for (const s of strings) {
                    str += s
                      ? `
${indentStep}${indent}${s}`
                      : '\n';
                  }
                  str += `
${indent}${end}`;
                } else {
                  str = `${start} ${strings.join(' ')} ${end}`;
                }
              } else {
                const strings = nodes.map(blockItem);
                str = strings.shift();
                for (const s of strings)
                  str += s
                    ? `
${indent}${s}`
                    : '\n';
              }
              if (this.comment) {
                str += '\n' + this.comment.replace(/^/gm, `${indent}#`);
                if (onComment) onComment();
              } else if (chompKeep && onChompKeep) onChompKeep();
              return str;
            }
          };
          PlainValue._defineProperty(Collection2, 'maxFlowStringSingleLineLength', 60);
          function asItemIndex(key) {
            let idx = key instanceof Scalar2 ? key.value : key;
            if (idx && typeof idx === 'string') idx = Number(idx);
            return Number.isInteger(idx) && idx >= 0 ? idx : null;
          }
          var YAMLSeq2 = class extends Collection2 {
            add(value) {
              this.items.push(value);
            }
            delete(key) {
              const idx = asItemIndex(key);
              if (typeof idx !== 'number') return false;
              const del = this.items.splice(idx, 1);
              return del.length > 0;
            }
            get(key, keepScalar) {
              const idx = asItemIndex(key);
              if (typeof idx !== 'number') return void 0;
              const it = this.items[idx];
              return !keepScalar && it instanceof Scalar2 ? it.value : it;
            }
            has(key) {
              const idx = asItemIndex(key);
              return typeof idx === 'number' && idx < this.items.length;
            }
            set(key, value) {
              const idx = asItemIndex(key);
              if (typeof idx !== 'number') throw new Error(`Expected a valid index, not ${key}.`);
              this.items[idx] = value;
            }
            toJSON(_, ctx) {
              const seq = [];
              if (ctx && ctx.onCreate) ctx.onCreate(seq);
              let i = 0;
              for (const item of this.items) seq.push(toJSON(item, String(i++), ctx));
              return seq;
            }
            toString(ctx, onComment, onChompKeep) {
              if (!ctx) return JSON.stringify(this);
              return super.toString(
                ctx,
                {
                  blockItem: (n) => (n.type === 'comment' ? n.str : `- ${n.str}`),
                  flowChars: {
                    start: '[',
                    end: ']',
                  },
                  isMap: false,
                  itemIndent: (ctx.indent || '') + '  ',
                },
                onComment,
                onChompKeep
              );
            }
          };
          var stringifyKey = (key, jsKey, ctx) => {
            if (jsKey === null) return '';
            if (typeof jsKey !== 'object') return String(jsKey);
            if (key instanceof Node2 && ctx && ctx.doc)
              return key.toString({
                anchors: /* @__PURE__ */ Object.create(null),
                doc: ctx.doc,
                indent: '',
                indentStep: ctx.indentStep,
                inFlow: true,
                inStringifyKey: true,
                stringify: ctx.stringify,
              });
            return JSON.stringify(jsKey);
          };
          var Pair2 = class _Pair extends Node2 {
            constructor(key, value = null) {
              super();
              this.key = key;
              this.value = value;
              this.type = _Pair.Type.PAIR;
            }
            get commentBefore() {
              return this.key instanceof Node2 ? this.key.commentBefore : void 0;
            }
            set commentBefore(cb) {
              if (this.key == null) this.key = new Scalar2(null);
              if (this.key instanceof Node2) this.key.commentBefore = cb;
              else {
                const msg =
                  'Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.';
                throw new Error(msg);
              }
            }
            addToJSMap(ctx, map) {
              const key = toJSON(this.key, '', ctx);
              if (map instanceof Map) {
                const value = toJSON(this.value, key, ctx);
                map.set(key, value);
              } else if (map instanceof Set) {
                map.add(key);
              } else {
                const stringKey = stringifyKey(this.key, key, ctx);
                const value = toJSON(this.value, stringKey, ctx);
                if (stringKey in map)
                  Object.defineProperty(map, stringKey, {
                    value,
                    writable: true,
                    enumerable: true,
                    configurable: true,
                  });
                else map[stringKey] = value;
              }
              return map;
            }
            toJSON(_, ctx) {
              const pair = ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
              return this.addToJSMap(ctx, pair);
            }
            toString(ctx, onComment, onChompKeep) {
              if (!ctx || !ctx.doc) return JSON.stringify(this);
              const { indent: indentSize, indentSeq, simpleKeys } = ctx.doc.options;
              let { key, value } = this;
              let keyComment = key instanceof Node2 && key.comment;
              if (simpleKeys) {
                if (keyComment) {
                  throw new Error('With simple keys, key nodes cannot have comments');
                }
                if (key instanceof Collection2) {
                  const msg = 'With simple keys, collection cannot be used as a key value';
                  throw new Error(msg);
                }
              }
              let explicitKey =
                !simpleKeys &&
                (!key ||
                  keyComment ||
                  (key instanceof Node2
                    ? key instanceof Collection2 ||
                      key.type === PlainValue.Type.BLOCK_FOLDED ||
                      key.type === PlainValue.Type.BLOCK_LITERAL
                    : typeof key === 'object'));
              const { doc, indent, indentStep, stringify } = ctx;
              ctx = Object.assign({}, ctx, {
                implicitKey: !explicitKey,
                indent: indent + indentStep,
              });
              let chompKeep = false;
              let str = stringify(
                key,
                ctx,
                () => (keyComment = null),
                () => (chompKeep = true)
              );
              str = addComment(str, ctx.indent, keyComment);
              if (!explicitKey && str.length > 1024) {
                if (simpleKeys)
                  throw new Error('With simple keys, single line scalar must not span more than 1024 characters');
                explicitKey = true;
              }
              if (ctx.allNullValues && !simpleKeys) {
                if (this.comment) {
                  str = addComment(str, ctx.indent, this.comment);
                  if (onComment) onComment();
                } else if (chompKeep && !keyComment && onChompKeep) onChompKeep();
                return ctx.inFlow && !explicitKey ? str : `? ${str}`;
              }
              str = explicitKey
                ? `? ${str}
${indent}:`
                : `${str}:`;
              if (this.comment) {
                str = addComment(str, ctx.indent, this.comment);
                if (onComment) onComment();
              }
              let vcb = '';
              let valueComment = null;
              if (value instanceof Node2) {
                if (value.spaceBefore) vcb = '\n';
                if (value.commentBefore) {
                  const cs = value.commentBefore.replace(/^/gm, `${ctx.indent}#`);
                  vcb += `
${cs}`;
                }
                valueComment = value.comment;
              } else if (value && typeof value === 'object') {
                value = doc.schema.createNode(value, true);
              }
              ctx.implicitKey = false;
              if (!explicitKey && !this.comment && value instanceof Scalar2) ctx.indentAtStart = str.length + 1;
              chompKeep = false;
              if (
                !indentSeq &&
                indentSize >= 2 &&
                !ctx.inFlow &&
                !explicitKey &&
                value instanceof YAMLSeq2 &&
                value.type !== PlainValue.Type.FLOW_SEQ &&
                !value.tag &&
                !doc.anchors.getName(value)
              ) {
                ctx.indent = ctx.indent.substr(2);
              }
              const valueStr = stringify(
                value,
                ctx,
                () => (valueComment = null),
                () => (chompKeep = true)
              );
              let ws = ' ';
              if (vcb || this.comment) {
                ws = `${vcb}
${ctx.indent}`;
              } else if (!explicitKey && value instanceof Collection2) {
                const flow = valueStr[0] === '[' || valueStr[0] === '{';
                if (!flow || valueStr.includes('\n'))
                  ws = `
${ctx.indent}`;
              } else if (valueStr[0] === '\n') ws = '';
              if (chompKeep && !valueComment && onChompKeep) onChompKeep();
              return addComment(str + ws + valueStr, ctx.indent, valueComment);
            }
          };
          PlainValue._defineProperty(Pair2, 'Type', {
            PAIR: 'PAIR',
            MERGE_PAIR: 'MERGE_PAIR',
          });
          var getAliasCount = (node, anchors) => {
            if (node instanceof Alias2) {
              const anchor = anchors.get(node.source);
              return anchor.count * anchor.aliasCount;
            } else if (node instanceof Collection2) {
              let count = 0;
              for (const item of node.items) {
                const c = getAliasCount(item, anchors);
                if (c > count) count = c;
              }
              return count;
            } else if (node instanceof Pair2) {
              const kc = getAliasCount(node.key, anchors);
              const vc = getAliasCount(node.value, anchors);
              return Math.max(kc, vc);
            }
            return 1;
          };
          var Alias2 = class _Alias extends Node2 {
            static stringify({ range, source }, { anchors, doc, implicitKey, inStringifyKey }) {
              let anchor = Object.keys(anchors).find((a) => anchors[a] === source);
              if (!anchor && inStringifyKey) anchor = doc.anchors.getName(source) || doc.anchors.newName();
              if (anchor) return `*${anchor}${implicitKey ? ' ' : ''}`;
              const msg = doc.anchors.getName(source)
                ? 'Alias node must be after source node'
                : 'Source node not found for alias node';
              throw new Error(`${msg} [${range}]`);
            }
            constructor(source) {
              super();
              this.source = source;
              this.type = PlainValue.Type.ALIAS;
            }
            set tag(t) {
              throw new Error('Alias nodes cannot have tags');
            }
            toJSON(arg, ctx) {
              if (!ctx) return toJSON(this.source, arg, ctx);
              const { anchors, maxAliasCount } = ctx;
              const anchor = anchors.get(this.source);
              if (!anchor || anchor.res === void 0) {
                const msg = 'This should not happen: Alias anchor was not resolved?';
                if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);
                else throw new ReferenceError(msg);
              }
              if (maxAliasCount >= 0) {
                anchor.count += 1;
                if (anchor.aliasCount === 0) anchor.aliasCount = getAliasCount(this.source, anchors);
                if (anchor.count * anchor.aliasCount > maxAliasCount) {
                  const msg = 'Excessive alias count indicates a resource exhaustion attack';
                  if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);
                  else throw new ReferenceError(msg);
                }
              }
              return anchor.res;
            }
            // Only called when stringifying an alias mapping key while constructing
            // Object output.
            toString(ctx) {
              return _Alias.stringify(this, ctx);
            }
          };
          PlainValue._defineProperty(Alias2, 'default', true);
          function findPair(items, key) {
            const k = key instanceof Scalar2 ? key.value : key;
            for (const it of items) {
              if (it instanceof Pair2) {
                if (it.key === key || it.key === k) return it;
                if (it.key && it.key.value === k) return it;
              }
            }
            return void 0;
          }
          var YAMLMap2 = class extends Collection2 {
            add(pair, overwrite) {
              if (!pair) pair = new Pair2(pair);
              else if (!(pair instanceof Pair2)) pair = new Pair2(pair.key || pair, pair.value);
              const prev = findPair(this.items, pair.key);
              const sortEntries = this.schema && this.schema.sortMapEntries;
              if (prev) {
                if (overwrite) prev.value = pair.value;
                else throw new Error(`Key ${pair.key} already set`);
              } else if (sortEntries) {
                const i = this.items.findIndex((item) => sortEntries(pair, item) < 0);
                if (i === -1) this.items.push(pair);
                else this.items.splice(i, 0, pair);
              } else {
                this.items.push(pair);
              }
            }
            delete(key) {
              const it = findPair(this.items, key);
              if (!it) return false;
              const del = this.items.splice(this.items.indexOf(it), 1);
              return del.length > 0;
            }
            get(key, keepScalar) {
              const it = findPair(this.items, key);
              const node = it && it.value;
              return !keepScalar && node instanceof Scalar2 ? node.value : node;
            }
            has(key) {
              return !!findPair(this.items, key);
            }
            set(key, value) {
              this.add(new Pair2(key, value), true);
            }
            /**
             * @param {*} arg ignored
             * @param {*} ctx Conversion context, originally set in Document#toJSON()
             * @param {Class} Type If set, forces the returned collection type
             * @returns {*} Instance of Type, Map, or Object
             */
            toJSON(_, ctx, Type) {
              const map = Type ? new Type() : ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
              if (ctx && ctx.onCreate) ctx.onCreate(map);
              for (const item of this.items) item.addToJSMap(ctx, map);
              return map;
            }
            toString(ctx, onComment, onChompKeep) {
              if (!ctx) return JSON.stringify(this);
              for (const item of this.items) {
                if (!(item instanceof Pair2))
                  throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
              }
              return super.toString(
                ctx,
                {
                  blockItem: (n) => n.str,
                  flowChars: {
                    start: '{',
                    end: '}',
                  },
                  isMap: true,
                  itemIndent: ctx.indent || '',
                },
                onComment,
                onChompKeep
              );
            }
          };
          var MERGE_KEY = '<<';
          var Merge2 = class extends Pair2 {
            constructor(pair) {
              if (pair instanceof Pair2) {
                let seq = pair.value;
                if (!(seq instanceof YAMLSeq2)) {
                  seq = new YAMLSeq2();
                  seq.items.push(pair.value);
                  seq.range = pair.value.range;
                }
                super(pair.key, seq);
                this.range = pair.range;
              } else {
                super(new Scalar2(MERGE_KEY), new YAMLSeq2());
              }
              this.type = Pair2.Type.MERGE_PAIR;
            }
            // If the value associated with a merge key is a single mapping node, each of
            // its key/value pairs is inserted into the current mapping, unless the key
            // already exists in it. If the value associated with the merge key is a
            // sequence, then this sequence is expected to contain mapping nodes and each
            // of these nodes is merged in turn according to its order in the sequence.
            // Keys in mapping nodes earlier in the sequence override keys specified in
            // later mapping nodes. -- http://yaml.org/type/merge.html
            addToJSMap(ctx, map) {
              for (const { source } of this.value.items) {
                if (!(source instanceof YAMLMap2)) throw new Error('Merge sources must be maps');
                const srcMap = source.toJSON(null, ctx, Map);
                for (const [key, value] of srcMap) {
                  if (map instanceof Map) {
                    if (!map.has(key)) map.set(key, value);
                  } else if (map instanceof Set) {
                    map.add(key);
                  } else if (!Object.prototype.hasOwnProperty.call(map, key)) {
                    Object.defineProperty(map, key, {
                      value,
                      writable: true,
                      enumerable: true,
                      configurable: true,
                    });
                  }
                }
              }
              return map;
            }
            toString(ctx, onComment) {
              const seq = this.value;
              if (seq.items.length > 1) return super.toString(ctx, onComment);
              this.value = seq.items[0];
              const str = super.toString(ctx, onComment);
              this.value = seq;
              return str;
            }
          };
          var binaryOptions2 = {
            defaultType: PlainValue.Type.BLOCK_LITERAL,
            lineWidth: 76,
          };
          var boolOptions2 = {
            trueStr: 'true',
            falseStr: 'false',
          };
          var intOptions2 = {
            asBigInt: false,
          };
          var nullOptions2 = {
            nullStr: 'null',
          };
          var strOptions2 = {
            defaultType: PlainValue.Type.PLAIN,
            doubleQuoted: {
              jsonEncoding: false,
              minMultiLineLength: 40,
            },
            fold: {
              lineWidth: 80,
              minContentWidth: 20,
            },
          };
          function resolveScalar(str, tags, scalarFallback) {
            for (const { format, test, resolve: resolve2 } of tags) {
              if (test) {
                const match = str.match(test);
                if (match) {
                  let res = resolve2.apply(null, match);
                  if (!(res instanceof Scalar2)) res = new Scalar2(res);
                  if (format) res.format = format;
                  return res;
                }
              }
            }
            if (scalarFallback) str = scalarFallback(str);
            return new Scalar2(str);
          }
          var FOLD_FLOW = 'flow';
          var FOLD_BLOCK = 'block';
          var FOLD_QUOTED = 'quoted';
          var consumeMoreIndentedLines = (text, i) => {
            let ch = text[i + 1];
            while (ch === ' ' || ch === '	') {
              do {
                ch = text[(i += 1)];
              } while (ch && ch !== '\n');
              ch = text[i + 1];
            }
            return i;
          };
          function foldFlowLines(
            text,
            indent,
            mode,
            { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow }
          ) {
            if (!lineWidth || lineWidth < 0) return text;
            const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
            if (text.length <= endStep) return text;
            const folds = [];
            const escapedFolds = {};
            let end = lineWidth - indent.length;
            if (typeof indentAtStart === 'number') {
              if (indentAtStart > lineWidth - Math.max(2, minContentWidth)) folds.push(0);
              else end = lineWidth - indentAtStart;
            }
            let split = void 0;
            let prev = void 0;
            let overflow = false;
            let i = -1;
            let escStart = -1;
            let escEnd = -1;
            if (mode === FOLD_BLOCK) {
              i = consumeMoreIndentedLines(text, i);
              if (i !== -1) end = i + endStep;
            }
            for (let ch; (ch = text[(i += 1)]); ) {
              if (mode === FOLD_QUOTED && ch === '\\') {
                escStart = i;
                switch (text[i + 1]) {
                  case 'x':
                    i += 3;
                    break;
                  case 'u':
                    i += 5;
                    break;
                  case 'U':
                    i += 9;
                    break;
                  default:
                    i += 1;
                }
                escEnd = i;
              }
              if (ch === '\n') {
                if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i);
                end = i + endStep;
                split = void 0;
              } else {
                if (ch === ' ' && prev && prev !== ' ' && prev !== '\n' && prev !== '	') {
                  const next = text[i + 1];
                  if (next && next !== ' ' && next !== '\n' && next !== '	') split = i;
                }
                if (i >= end) {
                  if (split) {
                    folds.push(split);
                    end = split + endStep;
                    split = void 0;
                  } else if (mode === FOLD_QUOTED) {
                    while (prev === ' ' || prev === '	') {
                      prev = ch;
                      ch = text[(i += 1)];
                      overflow = true;
                    }
                    const j = i > escEnd + 1 ? i - 2 : escStart - 1;
                    if (escapedFolds[j]) return text;
                    folds.push(j);
                    escapedFolds[j] = true;
                    end = j + endStep;
                    split = void 0;
                  } else {
                    overflow = true;
                  }
                }
              }
              prev = ch;
            }
            if (overflow && onOverflow) onOverflow();
            if (folds.length === 0) return text;
            if (onFold) onFold();
            let res = text.slice(0, folds[0]);
            for (let i2 = 0; i2 < folds.length; ++i2) {
              const fold = folds[i2];
              const end2 = folds[i2 + 1] || text.length;
              if (fold === 0)
                res = `
${indent}${text.slice(0, end2)}`;
              else {
                if (mode === FOLD_QUOTED && escapedFolds[fold]) res += `${text[fold]}\\`;
                res += `
${indent}${text.slice(fold + 1, end2)}`;
              }
            }
            return res;
          }
          var getFoldOptions = ({ indentAtStart }) =>
            indentAtStart
              ? Object.assign(
                  {
                    indentAtStart,
                  },
                  strOptions2.fold
                )
              : strOptions2.fold;
          var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
          function lineLengthOverLimit(str, lineWidth, indentLength) {
            if (!lineWidth || lineWidth < 0) return false;
            const limit = lineWidth - indentLength;
            const strLen = str.length;
            if (strLen <= limit) return false;
            for (let i = 0, start = 0; i < strLen; ++i) {
              if (str[i] === '\n') {
                if (i - start > limit) return true;
                start = i + 1;
                if (strLen - start <= limit) return false;
              }
            }
            return true;
          }
          function doubleQuotedString(value, ctx) {
            const { implicitKey } = ctx;
            const { jsonEncoding, minMultiLineLength } = strOptions2.doubleQuoted;
            const json = JSON.stringify(value);
            if (jsonEncoding) return json;
            const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
            let str = '';
            let start = 0;
            for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
              if (ch === ' ' && json[i + 1] === '\\' && json[i + 2] === 'n') {
                str += json.slice(start, i) + '\\ ';
                i += 1;
                start = i;
                ch = '\\';
              }
              if (ch === '\\')
                switch (json[i + 1]) {
                  case 'u':
                    {
                      str += json.slice(start, i);
                      const code = json.substr(i + 2, 4);
                      switch (code) {
                        case '0000':
                          str += '\\0';
                          break;
                        case '0007':
                          str += '\\a';
                          break;
                        case '000b':
                          str += '\\v';
                          break;
                        case '001b':
                          str += '\\e';
                          break;
                        case '0085':
                          str += '\\N';
                          break;
                        case '00a0':
                          str += '\\_';
                          break;
                        case '2028':
                          str += '\\L';
                          break;
                        case '2029':
                          str += '\\P';
                          break;
                        default:
                          if (code.substr(0, 2) === '00') str += '\\x' + code.substr(2);
                          else str += json.substr(i, 6);
                      }
                      i += 5;
                      start = i + 1;
                    }
                    break;
                  case 'n':
                    if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
                      i += 1;
                    } else {
                      str += json.slice(start, i) + '\n\n';
                      while (json[i + 2] === '\\' && json[i + 3] === 'n' && json[i + 4] !== '"') {
                        str += '\n';
                        i += 2;
                      }
                      str += indent;
                      if (json[i + 2] === ' ') str += '\\';
                      i += 1;
                      start = i + 1;
                    }
                    break;
                  default:
                    i += 1;
                }
            }
            str = start ? str + json.slice(start) : json;
            return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));
          }
          function singleQuotedString(value, ctx) {
            if (ctx.implicitKey) {
              if (/\n/.test(value)) return doubleQuotedString(value, ctx);
            } else {
              if (/[ \t]\n|\n[ \t]/.test(value)) return doubleQuotedString(value, ctx);
            }
            const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
            const res =
              "'" +
              value.replace(/'/g, "''").replace(
                /\n+/g,
                `$&
${indent}`
              ) +
              "'";
            return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));
          }
          function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
            if (/\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
              return doubleQuotedString(value, ctx);
            }
            const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');
            const indentSize = indent ? '2' : '1';
            const literal =
              type === PlainValue.Type.BLOCK_FOLDED
                ? false
                : type === PlainValue.Type.BLOCK_LITERAL
                  ? true
                  : !lineLengthOverLimit(value, strOptions2.fold.lineWidth, indent.length);
            let header = literal ? '|' : '>';
            if (!value) return header + '\n';
            let wsStart = '';
            let wsEnd = '';
            value = value
              .replace(/[\n\t ]*$/, (ws) => {
                const n = ws.indexOf('\n');
                if (n === -1) {
                  header += '-';
                } else if (value === ws || n !== ws.length - 1) {
                  header += '+';
                  if (onChompKeep) onChompKeep();
                }
                wsEnd = ws.replace(/\n$/, '');
                return '';
              })
              .replace(/^[\n ]*/, (ws) => {
                if (ws.indexOf(' ') !== -1) header += indentSize;
                const m = ws.match(/ +$/);
                if (m) {
                  wsStart = ws.slice(0, -m[0].length);
                  return m[0];
                } else {
                  wsStart = ws;
                  return '';
                }
              });
            if (wsEnd) wsEnd = wsEnd.replace(/\n+(?!\n|$)/g, `$&${indent}`);
            if (wsStart) wsStart = wsStart.replace(/\n+/g, `$&${indent}`);
            if (comment) {
              header += ' #' + comment.replace(/ ?[\r\n]+/g, ' ');
              if (onComment) onComment();
            }
            if (!value)
              return `${header}${indentSize}
${indent}${wsEnd}`;
            if (literal) {
              value = value.replace(/\n+/g, `$&${indent}`);
              return `${header}
${indent}${wsStart}${value}${wsEnd}`;
            }
            value = value
              .replace(/\n+/g, '\n$&')
              .replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, '$1$2')
              .replace(/\n+/g, `$&${indent}`);
            const body = foldFlowLines(`${wsStart}${value}${wsEnd}`, indent, FOLD_BLOCK, strOptions2.fold);
            return `${header}
${indent}${body}`;
          }
          function plainString(item, ctx, onComment, onChompKeep) {
            const { comment, type, value } = item;
            const { actualString, implicitKey, indent, inFlow } = ctx;
            if ((implicitKey && /[\n[\]{},]/.test(value)) || (inFlow && /[[\]{},]/.test(value))) {
              return doubleQuotedString(value, ctx);
            }
            if (
              !value ||
              /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)
            ) {
              return implicitKey || inFlow || value.indexOf('\n') === -1
                ? value.indexOf('"') !== -1 && value.indexOf("'") === -1
                  ? singleQuotedString(value, ctx)
                  : doubleQuotedString(value, ctx)
                : blockString(item, ctx, onComment, onChompKeep);
            }
            if (!implicitKey && !inFlow && type !== PlainValue.Type.PLAIN && value.indexOf('\n') !== -1) {
              return blockString(item, ctx, onComment, onChompKeep);
            }
            if (indent === '' && containsDocumentMarker(value)) {
              ctx.forceBlockIndent = true;
              return blockString(item, ctx, onComment, onChompKeep);
            }
            const str = value.replace(
              /\n+/g,
              `$&
${indent}`
            );
            if (actualString) {
              const { tags } = ctx.doc.schema;
              const resolved = resolveScalar(str, tags, tags.scalarFallback).value;
              if (typeof resolved !== 'string') return doubleQuotedString(value, ctx);
            }
            const body = implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));
            if (comment && !inFlow && (body.indexOf('\n') !== -1 || comment.indexOf('\n') !== -1)) {
              if (onComment) onComment();
              return addCommentBefore(body, indent, comment);
            }
            return body;
          }
          function stringifyString(item, ctx, onComment, onChompKeep) {
            const { defaultType } = strOptions2;
            const { implicitKey, inFlow } = ctx;
            let { type, value } = item;
            if (typeof value !== 'string') {
              value = String(value);
              item = Object.assign({}, item, {
                value,
              });
            }
            const _stringify = (_type) => {
              switch (_type) {
                case PlainValue.Type.BLOCK_FOLDED:
                case PlainValue.Type.BLOCK_LITERAL:
                  return blockString(item, ctx, onComment, onChompKeep);
                case PlainValue.Type.QUOTE_DOUBLE:
                  return doubleQuotedString(value, ctx);
                case PlainValue.Type.QUOTE_SINGLE:
                  return singleQuotedString(value, ctx);
                case PlainValue.Type.PLAIN:
                  return plainString(item, ctx, onComment, onChompKeep);
                default:
                  return null;
              }
            };
            if (type !== PlainValue.Type.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(value)) {
              type = PlainValue.Type.QUOTE_DOUBLE;
            } else if (
              (implicitKey || inFlow) &&
              (type === PlainValue.Type.BLOCK_FOLDED || type === PlainValue.Type.BLOCK_LITERAL)
            ) {
              type = PlainValue.Type.QUOTE_DOUBLE;
            }
            let res = _stringify(type);
            if (res === null) {
              res = _stringify(defaultType);
              if (res === null) throw new Error(`Unsupported default string type ${defaultType}`);
            }
            return res;
          }
          function stringifyNumber({ format, minFractionDigits, tag, value }) {
            if (typeof value === 'bigint') return String(value);
            if (!isFinite(value)) return isNaN(value) ? '.nan' : value < 0 ? '-.inf' : '.inf';
            let n = JSON.stringify(value);
            if (!format && minFractionDigits && (!tag || tag === 'tag:yaml.org,2002:float') && /^\d/.test(n)) {
              let i = n.indexOf('.');
              if (i < 0) {
                i = n.length;
                n += '.';
              }
              let d = minFractionDigits - (n.length - i - 1);
              while (d-- > 0) n += '0';
            }
            return n;
          }
          function checkFlowCollectionEnd(errors, cst) {
            let char, name;
            switch (cst.type) {
              case PlainValue.Type.FLOW_MAP:
                char = '}';
                name = 'flow map';
                break;
              case PlainValue.Type.FLOW_SEQ:
                char = ']';
                name = 'flow sequence';
                break;
              default:
                errors.push(new PlainValue.YAMLSemanticError(cst, 'Not a flow collection!?'));
                return;
            }
            let lastItem;
            for (let i = cst.items.length - 1; i >= 0; --i) {
              const item = cst.items[i];
              if (!item || item.type !== PlainValue.Type.COMMENT) {
                lastItem = item;
                break;
              }
            }
            if (lastItem && lastItem.char !== char) {
              const msg = `Expected ${name} to end with ${char}`;
              let err;
              if (typeof lastItem.offset === 'number') {
                err = new PlainValue.YAMLSemanticError(cst, msg);
                err.offset = lastItem.offset + 1;
              } else {
                err = new PlainValue.YAMLSemanticError(lastItem, msg);
                if (lastItem.range && lastItem.range.end) err.offset = lastItem.range.end - lastItem.range.start;
              }
              errors.push(err);
            }
          }
          function checkFlowCommentSpace(errors, comment) {
            const prev = comment.context.src[comment.range.start - 1];
            if (prev !== '\n' && prev !== '	' && prev !== ' ') {
              const msg = 'Comments must be separated from other tokens by white space characters';
              errors.push(new PlainValue.YAMLSemanticError(comment, msg));
            }
          }
          function getLongKeyError(source, key) {
            const sk = String(key);
            const k = sk.substr(0, 8) + '...' + sk.substr(-8);
            return new PlainValue.YAMLSemanticError(source, `The "${k}" key is too long`);
          }
          function resolveComments(collection, comments) {
            for (const { afterKey, before, comment } of comments) {
              let item = collection.items[before];
              if (!item) {
                if (comment !== void 0) {
                  if (collection.comment) collection.comment += '\n' + comment;
                  else collection.comment = comment;
                }
              } else {
                if (afterKey && item.value) item = item.value;
                if (comment === void 0) {
                  if (afterKey || !item.commentBefore) item.spaceBefore = true;
                } else {
                  if (item.commentBefore) item.commentBefore += '\n' + comment;
                  else item.commentBefore = comment;
                }
              }
            }
          }
          function resolveString(doc, node) {
            const res = node.strValue;
            if (!res) return '';
            if (typeof res === 'string') return res;
            res.errors.forEach((error) => {
              if (!error.source) error.source = node;
              doc.errors.push(error);
            });
            return res.str;
          }
          function resolveTagHandle(doc, node) {
            const { handle, suffix } = node.tag;
            let prefix = doc.tagPrefixes.find((p) => p.handle === handle);
            if (!prefix) {
              const dtp = doc.getDefaults().tagPrefixes;
              if (dtp) prefix = dtp.find((p) => p.handle === handle);
              if (!prefix)
                throw new PlainValue.YAMLSemanticError(
                  node,
                  `The ${handle} tag handle is non-default and was not declared.`
                );
            }
            if (!suffix) throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag has no suffix.`);
            if (handle === '!' && (doc.version || doc.options.version) === '1.0') {
              if (suffix[0] === '^') {
                doc.warnings.push(new PlainValue.YAMLWarning(node, 'YAML 1.0 ^ tag expansion is not supported'));
                return suffix;
              }
              if (/[:/]/.test(suffix)) {
                const vocab = suffix.match(/^([a-z0-9-]+)\/(.*)/i);
                return vocab ? `tag:${vocab[1]}.yaml.org,2002:${vocab[2]}` : `tag:${suffix}`;
              }
            }
            return prefix.prefix + decodeURIComponent(suffix);
          }
          function resolveTagName(doc, node) {
            const { tag, type } = node;
            let nonSpecific = false;
            if (tag) {
              const { handle, suffix, verbatim } = tag;
              if (verbatim) {
                if (verbatim !== '!' && verbatim !== '!!') return verbatim;
                const msg = `Verbatim tags aren't resolved, so ${verbatim} is invalid.`;
                doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));
              } else if (handle === '!' && !suffix) {
                nonSpecific = true;
              } else {
                try {
                  return resolveTagHandle(doc, node);
                } catch (error) {
                  doc.errors.push(error);
                }
              }
            }
            switch (type) {
              case PlainValue.Type.BLOCK_FOLDED:
              case PlainValue.Type.BLOCK_LITERAL:
              case PlainValue.Type.QUOTE_DOUBLE:
              case PlainValue.Type.QUOTE_SINGLE:
                return PlainValue.defaultTags.STR;
              case PlainValue.Type.FLOW_MAP:
              case PlainValue.Type.MAP:
                return PlainValue.defaultTags.MAP;
              case PlainValue.Type.FLOW_SEQ:
              case PlainValue.Type.SEQ:
                return PlainValue.defaultTags.SEQ;
              case PlainValue.Type.PLAIN:
                return nonSpecific ? PlainValue.defaultTags.STR : null;
              default:
                return null;
            }
          }
          function resolveByTagName(doc, node, tagName) {
            const { tags } = doc.schema;
            const matchWithTest = [];
            for (const tag of tags) {
              if (tag.tag === tagName) {
                if (tag.test) matchWithTest.push(tag);
                else {
                  const res = tag.resolve(doc, node);
                  return res instanceof Collection2 ? res : new Scalar2(res);
                }
              }
            }
            const str = resolveString(doc, node);
            if (typeof str === 'string' && matchWithTest.length > 0)
              return resolveScalar(str, matchWithTest, tags.scalarFallback);
            return null;
          }
          function getFallbackTagName({ type }) {
            switch (type) {
              case PlainValue.Type.FLOW_MAP:
              case PlainValue.Type.MAP:
                return PlainValue.defaultTags.MAP;
              case PlainValue.Type.FLOW_SEQ:
              case PlainValue.Type.SEQ:
                return PlainValue.defaultTags.SEQ;
              default:
                return PlainValue.defaultTags.STR;
            }
          }
          function resolveTag(doc, node, tagName) {
            try {
              const res = resolveByTagName(doc, node, tagName);
              if (res) {
                if (tagName && node.tag) res.tag = tagName;
                return res;
              }
            } catch (error) {
              if (!error.source) error.source = node;
              doc.errors.push(error);
              return null;
            }
            try {
              const fallback = getFallbackTagName(node);
              if (!fallback) throw new Error(`The tag ${tagName} is unavailable`);
              const msg = `The tag ${tagName} is unavailable, falling back to ${fallback}`;
              doc.warnings.push(new PlainValue.YAMLWarning(node, msg));
              const res = resolveByTagName(doc, node, fallback);
              res.tag = tagName;
              return res;
            } catch (error) {
              const refError = new PlainValue.YAMLReferenceError(node, error.message);
              refError.stack = error.stack;
              doc.errors.push(refError);
              return null;
            }
          }
          var isCollectionItem = (node) => {
            if (!node) return false;
            const { type } = node;
            return (
              type === PlainValue.Type.MAP_KEY ||
              type === PlainValue.Type.MAP_VALUE ||
              type === PlainValue.Type.SEQ_ITEM
            );
          };
          function resolveNodeProps(errors, node) {
            const comments = {
              before: [],
              after: [],
            };
            let hasAnchor = false;
            let hasTag = false;
            const props = isCollectionItem(node.context.parent)
              ? node.context.parent.props.concat(node.props)
              : node.props;
            for (const { start, end } of props) {
              switch (node.context.src[start]) {
                case PlainValue.Char.COMMENT: {
                  if (!node.commentHasRequiredWhitespace(start)) {
                    const msg = 'Comments must be separated from other tokens by white space characters';
                    errors.push(new PlainValue.YAMLSemanticError(node, msg));
                  }
                  const { header, valueRange } = node;
                  const cc =
                    valueRange && (start > valueRange.start || (header && start > header.start))
                      ? comments.after
                      : comments.before;
                  cc.push(node.context.src.slice(start + 1, end));
                  break;
                }
                case PlainValue.Char.ANCHOR:
                  if (hasAnchor) {
                    const msg = 'A node can have at most one anchor';
                    errors.push(new PlainValue.YAMLSemanticError(node, msg));
                  }
                  hasAnchor = true;
                  break;
                case PlainValue.Char.TAG:
                  if (hasTag) {
                    const msg = 'A node can have at most one tag';
                    errors.push(new PlainValue.YAMLSemanticError(node, msg));
                  }
                  hasTag = true;
                  break;
              }
            }
            return {
              comments,
              hasAnchor,
              hasTag,
            };
          }
          function resolveNodeValue(doc, node) {
            const { anchors, errors, schema } = doc;
            if (node.type === PlainValue.Type.ALIAS) {
              const name = node.rawValue;
              const src = anchors.getNode(name);
              if (!src) {
                const msg = `Aliased anchor not found: ${name}`;
                errors.push(new PlainValue.YAMLReferenceError(node, msg));
                return null;
              }
              const res = new Alias2(src);
              anchors._cstAliases.push(res);
              return res;
            }
            const tagName = resolveTagName(doc, node);
            if (tagName) return resolveTag(doc, node, tagName);
            if (node.type !== PlainValue.Type.PLAIN) {
              const msg = `Failed to resolve ${node.type} node here`;
              errors.push(new PlainValue.YAMLSyntaxError(node, msg));
              return null;
            }
            try {
              const str = resolveString(doc, node);
              return resolveScalar(str, schema.tags, schema.tags.scalarFallback);
            } catch (error) {
              if (!error.source) error.source = node;
              errors.push(error);
              return null;
            }
          }
          function resolveNode(doc, node) {
            if (!node) return null;
            if (node.error) doc.errors.push(node.error);
            const { comments, hasAnchor, hasTag } = resolveNodeProps(doc.errors, node);
            if (hasAnchor) {
              const { anchors } = doc;
              const name = node.anchor;
              const prev = anchors.getNode(name);
              if (prev) anchors.map[anchors.newName(name)] = prev;
              anchors.map[name] = node;
            }
            if (node.type === PlainValue.Type.ALIAS && (hasAnchor || hasTag)) {
              const msg = 'An alias node must not specify any properties';
              doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));
            }
            const res = resolveNodeValue(doc, node);
            if (res) {
              res.range = [node.range.start, node.range.end];
              if (doc.options.keepCstNodes) res.cstNode = node;
              if (doc.options.keepNodeTypes) res.type = node.type;
              const cb = comments.before.join('\n');
              if (cb) {
                res.commentBefore = res.commentBefore
                  ? `${res.commentBefore}
${cb}`
                  : cb;
              }
              const ca = comments.after.join('\n');
              if (ca)
                res.comment = res.comment
                  ? `${res.comment}
${ca}`
                  : ca;
            }
            return (node.resolved = res);
          }
          function resolveMap(doc, cst) {
            if (cst.type !== PlainValue.Type.MAP && cst.type !== PlainValue.Type.FLOW_MAP) {
              const msg = `A ${cst.type} node cannot be resolved as a mapping`;
              doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));
              return null;
            }
            const { comments, items } =
              cst.type === PlainValue.Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst);
            const map = new YAMLMap2();
            map.items = items;
            resolveComments(map, comments);
            let hasCollectionKey = false;
            for (let i = 0; i < items.length; ++i) {
              const { key: iKey } = items[i];
              if (iKey instanceof Collection2) hasCollectionKey = true;
              if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {
                items[i] = new Merge2(items[i]);
                const sources = items[i].value.items;
                let error = null;
                sources.some((node) => {
                  if (node instanceof Alias2) {
                    const { type } = node.source;
                    if (type === PlainValue.Type.MAP || type === PlainValue.Type.FLOW_MAP) return false;
                    return (error = 'Merge nodes aliases can only point to maps');
                  }
                  return (error = 'Merge nodes can only have Alias nodes as values');
                });
                if (error) doc.errors.push(new PlainValue.YAMLSemanticError(cst, error));
              } else {
                for (let j = i + 1; j < items.length; ++j) {
                  const { key: jKey } = items[j];
                  if (
                    iKey === jKey ||
                    (iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, 'value') && iKey.value === jKey.value)
                  ) {
                    const msg = `Map keys must be unique; "${iKey}" is repeated`;
                    doc.errors.push(new PlainValue.YAMLSemanticError(cst, msg));
                    break;
                  }
                }
              }
            }
            if (hasCollectionKey && !doc.options.mapAsMap) {
              const warn =
                'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';
              doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));
            }
            cst.resolved = map;
            return map;
          }
          var valueHasPairComment = ({ context: { lineStart, node, src }, props }) => {
            if (props.length === 0) return false;
            const { start } = props[0];
            if (node && start > node.valueRange.start) return false;
            if (src[start] !== PlainValue.Char.COMMENT) return false;
            for (let i = lineStart; i < start; ++i) if (src[i] === '\n') return false;
            return true;
          };
          function resolvePairComment(item, pair) {
            if (!valueHasPairComment(item)) return;
            const comment = item.getPropValue(0, PlainValue.Char.COMMENT, true);
            let found = false;
            const cb = pair.value.commentBefore;
            if (cb && cb.startsWith(comment)) {
              pair.value.commentBefore = cb.substr(comment.length + 1);
              found = true;
            } else {
              const cc = pair.value.comment;
              if (!item.node && cc && cc.startsWith(comment)) {
                pair.value.comment = cc.substr(comment.length + 1);
                found = true;
              }
            }
            if (found) pair.comment = comment;
          }
          function resolveBlockMapItems(doc, cst) {
            const comments = [];
            const items = [];
            let key = void 0;
            let keyStart = null;
            for (let i = 0; i < cst.items.length; ++i) {
              const item = cst.items[i];
              switch (item.type) {
                case PlainValue.Type.BLANK_LINE:
                  comments.push({
                    afterKey: !!key,
                    before: items.length,
                  });
                  break;
                case PlainValue.Type.COMMENT:
                  comments.push({
                    afterKey: !!key,
                    before: items.length,
                    comment: item.comment,
                  });
                  break;
                case PlainValue.Type.MAP_KEY:
                  if (key !== void 0) items.push(new Pair2(key));
                  if (item.error) doc.errors.push(item.error);
                  key = resolveNode(doc, item.node);
                  keyStart = null;
                  break;
                case PlainValue.Type.MAP_VALUE:
                  {
                    if (key === void 0) key = null;
                    if (item.error) doc.errors.push(item.error);
                    if (
                      !item.context.atLineStart &&
                      item.node &&
                      item.node.type === PlainValue.Type.MAP &&
                      !item.node.context.atLineStart
                    ) {
                      const msg = 'Nested mappings are not allowed in compact mappings';
                      doc.errors.push(new PlainValue.YAMLSemanticError(item.node, msg));
                    }
                    let valueNode = item.node;
                    if (!valueNode && item.props.length > 0) {
                      valueNode = new PlainValue.PlainValue(PlainValue.Type.PLAIN, []);
                      valueNode.context = {
                        parent: item,
                        src: item.context.src,
                      };
                      const pos = item.range.start + 1;
                      valueNode.range = {
                        start: pos,
                        end: pos,
                      };
                      valueNode.valueRange = {
                        start: pos,
                        end: pos,
                      };
                      if (typeof item.range.origStart === 'number') {
                        const origPos = item.range.origStart + 1;
                        valueNode.range.origStart = valueNode.range.origEnd = origPos;
                        valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;
                      }
                    }
                    const pair = new Pair2(key, resolveNode(doc, valueNode));
                    resolvePairComment(item, pair);
                    items.push(pair);
                    if (key && typeof keyStart === 'number') {
                      if (item.range.start > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));
                    }
                    key = void 0;
                    keyStart = null;
                  }
                  break;
                default:
                  if (key !== void 0) items.push(new Pair2(key));
                  key = resolveNode(doc, item);
                  keyStart = item.range.start;
                  if (item.error) doc.errors.push(item.error);
                  next: for (let j = i + 1; ; ++j) {
                    const nextItem = cst.items[j];
                    switch (nextItem && nextItem.type) {
                      case PlainValue.Type.BLANK_LINE:
                      case PlainValue.Type.COMMENT:
                        continue next;
                      case PlainValue.Type.MAP_VALUE:
                        break next;
                      default: {
                        const msg = 'Implicit map keys need to be followed by map values';
                        doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
                        break next;
                      }
                    }
                  }
                  if (item.valueRangeContainsNewline) {
                    const msg = 'Implicit map keys need to be on a single line';
                    doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
                  }
              }
            }
            if (key !== void 0) items.push(new Pair2(key));
            return {
              comments,
              items,
            };
          }
          function resolveFlowMapItems(doc, cst) {
            const comments = [];
            const items = [];
            let key = void 0;
            let explicitKey = false;
            let next = '{';
            for (let i = 0; i < cst.items.length; ++i) {
              const item = cst.items[i];
              if (typeof item.char === 'string') {
                const { char, offset } = item;
                if (char === '?' && key === void 0 && !explicitKey) {
                  explicitKey = true;
                  next = ':';
                  continue;
                }
                if (char === ':') {
                  if (key === void 0) key = null;
                  if (next === ':') {
                    next = ',';
                    continue;
                  }
                } else {
                  if (explicitKey) {
                    if (key === void 0 && char !== ',') key = null;
                    explicitKey = false;
                  }
                  if (key !== void 0) {
                    items.push(new Pair2(key));
                    key = void 0;
                    if (char === ',') {
                      next = ':';
                      continue;
                    }
                  }
                }
                if (char === '}') {
                  if (i === cst.items.length - 1) continue;
                } else if (char === next) {
                  next = ':';
                  continue;
                }
                const msg = `Flow map contains an unexpected ${char}`;
                const err = new PlainValue.YAMLSyntaxError(cst, msg);
                err.offset = offset;
                doc.errors.push(err);
              } else if (item.type === PlainValue.Type.BLANK_LINE) {
                comments.push({
                  afterKey: !!key,
                  before: items.length,
                });
              } else if (item.type === PlainValue.Type.COMMENT) {
                checkFlowCommentSpace(doc.errors, item);
                comments.push({
                  afterKey: !!key,
                  before: items.length,
                  comment: item.comment,
                });
              } else if (key === void 0) {
                if (next === ',')
                  doc.errors.push(new PlainValue.YAMLSemanticError(item, 'Separator , missing in flow map'));
                key = resolveNode(doc, item);
              } else {
                if (next !== ',')
                  doc.errors.push(new PlainValue.YAMLSemanticError(item, 'Indicator : missing in flow map entry'));
                items.push(new Pair2(key, resolveNode(doc, item)));
                key = void 0;
                explicitKey = false;
              }
            }
            checkFlowCollectionEnd(doc.errors, cst);
            if (key !== void 0) items.push(new Pair2(key));
            return {
              comments,
              items,
            };
          }
          function resolveSeq(doc, cst) {
            if (cst.type !== PlainValue.Type.SEQ && cst.type !== PlainValue.Type.FLOW_SEQ) {
              const msg = `A ${cst.type} node cannot be resolved as a sequence`;
              doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));
              return null;
            }
            const { comments, items } =
              cst.type === PlainValue.Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst);
            const seq = new YAMLSeq2();
            seq.items = items;
            resolveComments(seq, comments);
            if (!doc.options.mapAsMap && items.some((it) => it instanceof Pair2 && it.key instanceof Collection2)) {
              const warn =
                'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';
              doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));
            }
            cst.resolved = seq;
            return seq;
          }
          function resolveBlockSeqItems(doc, cst) {
            const comments = [];
            const items = [];
            for (let i = 0; i < cst.items.length; ++i) {
              const item = cst.items[i];
              switch (item.type) {
                case PlainValue.Type.BLANK_LINE:
                  comments.push({
                    before: items.length,
                  });
                  break;
                case PlainValue.Type.COMMENT:
                  comments.push({
                    comment: item.comment,
                    before: items.length,
                  });
                  break;
                case PlainValue.Type.SEQ_ITEM:
                  if (item.error) doc.errors.push(item.error);
                  items.push(resolveNode(doc, item.node));
                  if (item.hasProps) {
                    const msg = 'Sequence items cannot have tags or anchors before the - indicator';
                    doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
                  }
                  break;
                default:
                  if (item.error) doc.errors.push(item.error);
                  doc.errors.push(new PlainValue.YAMLSyntaxError(item, `Unexpected ${item.type} node in sequence`));
              }
            }
            return {
              comments,
              items,
            };
          }
          function resolveFlowSeqItems(doc, cst) {
            const comments = [];
            const items = [];
            let explicitKey = false;
            let key = void 0;
            let keyStart = null;
            let next = '[';
            let prevItem = null;
            for (let i = 0; i < cst.items.length; ++i) {
              const item = cst.items[i];
              if (typeof item.char === 'string') {
                const { char, offset } = item;
                if (char !== ':' && (explicitKey || key !== void 0)) {
                  if (explicitKey && key === void 0) key = next ? items.pop() : null;
                  items.push(new Pair2(key));
                  explicitKey = false;
                  key = void 0;
                  keyStart = null;
                }
                if (char === next) {
                  next = null;
                } else if (!next && char === '?') {
                  explicitKey = true;
                } else if (next !== '[' && char === ':' && key === void 0) {
                  if (next === ',') {
                    key = items.pop();
                    if (key instanceof Pair2) {
                      const msg = 'Chaining flow sequence pairs is invalid';
                      const err = new PlainValue.YAMLSemanticError(cst, msg);
                      err.offset = offset;
                      doc.errors.push(err);
                    }
                    if (!explicitKey && typeof keyStart === 'number') {
                      const keyEnd = item.range ? item.range.start : item.offset;
                      if (keyEnd > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));
                      const { src } = prevItem.context;
                      for (let i2 = keyStart; i2 < keyEnd; ++i2)
                        if (src[i2] === '\n') {
                          const msg = 'Implicit keys of flow sequence pairs need to be on a single line';
                          doc.errors.push(new PlainValue.YAMLSemanticError(prevItem, msg));
                          break;
                        }
                    }
                  } else {
                    key = null;
                  }
                  keyStart = null;
                  explicitKey = false;
                  next = null;
                } else if (next === '[' || char !== ']' || i < cst.items.length - 1) {
                  const msg = `Flow sequence contains an unexpected ${char}`;
                  const err = new PlainValue.YAMLSyntaxError(cst, msg);
                  err.offset = offset;
                  doc.errors.push(err);
                }
              } else if (item.type === PlainValue.Type.BLANK_LINE) {
                comments.push({
                  before: items.length,
                });
              } else if (item.type === PlainValue.Type.COMMENT) {
                checkFlowCommentSpace(doc.errors, item);
                comments.push({
                  comment: item.comment,
                  before: items.length,
                });
              } else {
                if (next) {
                  const msg = `Expected a ${next} in flow sequence`;
                  doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
                }
                const value = resolveNode(doc, item);
                if (key === void 0) {
                  items.push(value);
                  prevItem = item;
                } else {
                  items.push(new Pair2(key, value));
                  key = void 0;
                }
                keyStart = item.range.start;
                next = ',';
              }
            }
            checkFlowCollectionEnd(doc.errors, cst);
            if (key !== void 0) items.push(new Pair2(key));
            return {
              comments,
              items,
            };
          }
          exports.Alias = Alias2;
          exports.Collection = Collection2;
          exports.Merge = Merge2;
          exports.Node = Node2;
          exports.Pair = Pair2;
          exports.Scalar = Scalar2;
          exports.YAMLMap = YAMLMap2;
          exports.YAMLSeq = YAMLSeq2;
          exports.addComment = addComment;
          exports.binaryOptions = binaryOptions2;
          exports.boolOptions = boolOptions2;
          exports.findPair = findPair;
          exports.intOptions = intOptions2;
          exports.isEmptyPath = isEmptyPath;
          exports.nullOptions = nullOptions2;
          exports.resolveMap = resolveMap;
          exports.resolveNode = resolveNode;
          exports.resolveSeq = resolveSeq;
          exports.resolveString = resolveString;
          exports.strOptions = strOptions2;
          exports.stringifyNumber = stringifyNumber;
          exports.stringifyString = stringifyString;
          exports.toJSON = toJSON;
        },
      });
      require_warnings_1000a372 = __commonJS2({
        'node_modules/yaml/dist/warnings-1000a372.js'(exports) {
          var PlainValue = require_PlainValue_ec8e588e();
          var resolveSeq = require_resolveSeq_d03cb037();
          var binary = {
            identify: (value) => value instanceof Uint8Array,
            // Buffer inherits from Uint8Array
            default: false,
            tag: 'tag:yaml.org,2002:binary',
            /**
             * Returns a Buffer in node and an Uint8Array in browsers
             *
             * To use the resulting buffer as an image, you'll want to do something like:
             *
             *   const blob = new Blob([buffer], { type: 'image/jpeg' })
             *   document.querySelector('#photo').src = URL.createObjectURL(blob)
             */
            resolve: (doc, node) => {
              const src = resolveSeq.resolveString(doc, node);
              if (typeof Buffer === 'function') {
                return Buffer.from(src, 'base64');
              } else if (typeof atob === 'function') {
                const str = atob(src.replace(/[\n\r]/g, ''));
                const buffer = new Uint8Array(str.length);
                for (let i = 0; i < str.length; ++i) buffer[i] = str.charCodeAt(i);
                return buffer;
              } else {
                const msg = 'This environment does not support reading binary tags; either Buffer or atob is required';
                doc.errors.push(new PlainValue.YAMLReferenceError(node, msg));
                return null;
              }
            },
            options: resolveSeq.binaryOptions,
            stringify: ({ comment, type, value }, ctx, onComment, onChompKeep) => {
              let src;
              if (typeof Buffer === 'function') {
                src = value instanceof Buffer ? value.toString('base64') : Buffer.from(value.buffer).toString('base64');
              } else if (typeof btoa === 'function') {
                let s = '';
                for (let i = 0; i < value.length; ++i) s += String.fromCharCode(value[i]);
                src = btoa(s);
              } else {
                throw new Error(
                  'This environment does not support writing binary tags; either Buffer or btoa is required'
                );
              }
              if (!type) type = resolveSeq.binaryOptions.defaultType;
              if (type === PlainValue.Type.QUOTE_DOUBLE) {
                value = src;
              } else {
                const { lineWidth } = resolveSeq.binaryOptions;
                const n = Math.ceil(src.length / lineWidth);
                const lines = new Array(n);
                for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
                  lines[i] = src.substr(o, lineWidth);
                }
                value = lines.join(type === PlainValue.Type.BLOCK_LITERAL ? '\n' : ' ');
              }
              return resolveSeq.stringifyString(
                {
                  comment,
                  type,
                  value,
                },
                ctx,
                onComment,
                onChompKeep
              );
            },
          };
          function parsePairs(doc, cst) {
            const seq = resolveSeq.resolveSeq(doc, cst);
            for (let i = 0; i < seq.items.length; ++i) {
              let item = seq.items[i];
              if (item instanceof resolveSeq.Pair) continue;
              else if (item instanceof resolveSeq.YAMLMap) {
                if (item.items.length > 1) {
                  const msg = 'Each pair must have its own sequence indicator';
                  throw new PlainValue.YAMLSemanticError(cst, msg);
                }
                const pair = item.items[0] || new resolveSeq.Pair();
                if (item.commentBefore)
                  pair.commentBefore = pair.commentBefore
                    ? `${item.commentBefore}
${pair.commentBefore}`
                    : item.commentBefore;
                if (item.comment)
                  pair.comment = pair.comment
                    ? `${item.comment}
${pair.comment}`
                    : item.comment;
                item = pair;
              }
              seq.items[i] = item instanceof resolveSeq.Pair ? item : new resolveSeq.Pair(item);
            }
            return seq;
          }
          function createPairs(schema, iterable, ctx) {
            const pairs2 = new resolveSeq.YAMLSeq(schema);
            pairs2.tag = 'tag:yaml.org,2002:pairs';
            for (const it of iterable) {
              let key, value;
              if (Array.isArray(it)) {
                if (it.length === 2) {
                  key = it[0];
                  value = it[1];
                } else throw new TypeError(`Expected [key, value] tuple: ${it}`);
              } else if (it && it instanceof Object) {
                const keys = Object.keys(it);
                if (keys.length === 1) {
                  key = keys[0];
                  value = it[key];
                } else throw new TypeError(`Expected { key: value } tuple: ${it}`);
              } else {
                key = it;
              }
              const pair = schema.createPair(key, value, ctx);
              pairs2.items.push(pair);
            }
            return pairs2;
          }
          var pairs = {
            default: false,
            tag: 'tag:yaml.org,2002:pairs',
            resolve: parsePairs,
            createNode: createPairs,
          };
          var YAMLOMap = class _YAMLOMap extends resolveSeq.YAMLSeq {
            constructor() {
              super();
              PlainValue._defineProperty(this, 'add', resolveSeq.YAMLMap.prototype.add.bind(this));
              PlainValue._defineProperty(this, 'delete', resolveSeq.YAMLMap.prototype.delete.bind(this));
              PlainValue._defineProperty(this, 'get', resolveSeq.YAMLMap.prototype.get.bind(this));
              PlainValue._defineProperty(this, 'has', resolveSeq.YAMLMap.prototype.has.bind(this));
              PlainValue._defineProperty(this, 'set', resolveSeq.YAMLMap.prototype.set.bind(this));
              this.tag = _YAMLOMap.tag;
            }
            toJSON(_, ctx) {
              const map = /* @__PURE__ */ new Map();
              if (ctx && ctx.onCreate) ctx.onCreate(map);
              for (const pair of this.items) {
                let key, value;
                if (pair instanceof resolveSeq.Pair) {
                  key = resolveSeq.toJSON(pair.key, '', ctx);
                  value = resolveSeq.toJSON(pair.value, key, ctx);
                } else {
                  key = resolveSeq.toJSON(pair, '', ctx);
                }
                if (map.has(key)) throw new Error('Ordered maps must not include duplicate keys');
                map.set(key, value);
              }
              return map;
            }
          };
          PlainValue._defineProperty(YAMLOMap, 'tag', 'tag:yaml.org,2002:omap');
          function parseOMap(doc, cst) {
            const pairs2 = parsePairs(doc, cst);
            const seenKeys = [];
            for (const { key } of pairs2.items) {
              if (key instanceof resolveSeq.Scalar) {
                if (seenKeys.includes(key.value)) {
                  const msg = 'Ordered maps must not include duplicate keys';
                  throw new PlainValue.YAMLSemanticError(cst, msg);
                } else {
                  seenKeys.push(key.value);
                }
              }
            }
            return Object.assign(new YAMLOMap(), pairs2);
          }
          function createOMap(schema, iterable, ctx) {
            const pairs2 = createPairs(schema, iterable, ctx);
            const omap2 = new YAMLOMap();
            omap2.items = pairs2.items;
            return omap2;
          }
          var omap = {
            identify: (value) => value instanceof Map,
            nodeClass: YAMLOMap,
            default: false,
            tag: 'tag:yaml.org,2002:omap',
            resolve: parseOMap,
            createNode: createOMap,
          };
          var YAMLSet = class _YAMLSet extends resolveSeq.YAMLMap {
            constructor() {
              super();
              this.tag = _YAMLSet.tag;
            }
            add(key) {
              const pair = key instanceof resolveSeq.Pair ? key : new resolveSeq.Pair(key);
              const prev = resolveSeq.findPair(this.items, pair.key);
              if (!prev) this.items.push(pair);
            }
            get(key, keepPair) {
              const pair = resolveSeq.findPair(this.items, key);
              return !keepPair && pair instanceof resolveSeq.Pair
                ? pair.key instanceof resolveSeq.Scalar
                  ? pair.key.value
                  : pair.key
                : pair;
            }
            set(key, value) {
              if (typeof value !== 'boolean')
                throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
              const prev = resolveSeq.findPair(this.items, key);
              if (prev && !value) {
                this.items.splice(this.items.indexOf(prev), 1);
              } else if (!prev && value) {
                this.items.push(new resolveSeq.Pair(key));
              }
            }
            toJSON(_, ctx) {
              return super.toJSON(_, ctx, Set);
            }
            toString(ctx, onComment, onChompKeep) {
              if (!ctx) return JSON.stringify(this);
              if (this.hasAllNullValues()) return super.toString(ctx, onComment, onChompKeep);
              else throw new Error('Set items must all have null values');
            }
          };
          PlainValue._defineProperty(YAMLSet, 'tag', 'tag:yaml.org,2002:set');
          function parseSet(doc, cst) {
            const map = resolveSeq.resolveMap(doc, cst);
            if (!map.hasAllNullValues())
              throw new PlainValue.YAMLSemanticError(cst, 'Set items must all have null values');
            return Object.assign(new YAMLSet(), map);
          }
          function createSet(schema, iterable, ctx) {
            const set2 = new YAMLSet();
            for (const value of iterable) set2.items.push(schema.createPair(value, null, ctx));
            return set2;
          }
          var set = {
            identify: (value) => value instanceof Set,
            nodeClass: YAMLSet,
            default: false,
            tag: 'tag:yaml.org,2002:set',
            resolve: parseSet,
            createNode: createSet,
          };
          var parseSexagesimal = (sign, parts) => {
            const n = parts.split(':').reduce((n2, p) => n2 * 60 + Number(p), 0);
            return sign === '-' ? -n : n;
          };
          var stringifySexagesimal = ({ value }) => {
            if (isNaN(value) || !isFinite(value)) return resolveSeq.stringifyNumber(value);
            let sign = '';
            if (value < 0) {
              sign = '-';
              value = Math.abs(value);
            }
            const parts = [value % 60];
            if (value < 60) {
              parts.unshift(0);
            } else {
              value = Math.round((value - parts[0]) / 60);
              parts.unshift(value % 60);
              if (value >= 60) {
                value = Math.round((value - parts[0]) / 60);
                parts.unshift(value);
              }
            }
            return (
              sign +
              parts
                .map((n) => (n < 10 ? '0' + String(n) : String(n)))
                .join(':')
                .replace(/000000\d*$/, '')
            );
          };
          var intTime = {
            identify: (value) => typeof value === 'number',
            default: true,
            tag: 'tag:yaml.org,2002:int',
            format: 'TIME',
            test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,
            resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, '')),
            stringify: stringifySexagesimal,
          };
          var floatTime = {
            identify: (value) => typeof value === 'number',
            default: true,
            tag: 'tag:yaml.org,2002:float',
            format: 'TIME',
            test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/,
            resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, '')),
            stringify: stringifySexagesimal,
          };
          var timestamp = {
            identify: (value) => value instanceof Date,
            default: true,
            tag: 'tag:yaml.org,2002:timestamp',
            // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
            // may be omitted altogether, resulting in a date format. In such a case, the time part is
            // assumed to be 00:00:00Z (start of day, UTC).
            test: /^(?:([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\.[0-9]+)?)(?:[ \t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?)$/,
            resolve: (str, year, month, day, hour, minute, second, millisec, tz) => {
              if (millisec) millisec = (millisec + '00').substr(1, 3);
              let date2 = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);
              if (tz && tz !== 'Z') {
                let d = parseSexagesimal(tz[0], tz.slice(1));
                if (Math.abs(d) < 30) d *= 60;
                date2 -= 6e4 * d;
              }
              return new Date(date2);
            },
            stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, ''),
          };
          function shouldWarn(deprecation) {
            const env = (typeof process !== 'undefined' && process.env) || {};
            if (deprecation) {
              if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== 'undefined') return !YAML_SILENCE_DEPRECATION_WARNINGS;
              return !env.YAML_SILENCE_DEPRECATION_WARNINGS;
            }
            if (typeof YAML_SILENCE_WARNINGS !== 'undefined') return !YAML_SILENCE_WARNINGS;
            return !env.YAML_SILENCE_WARNINGS;
          }
          function warn(warning, type) {
            if (shouldWarn(false)) {
              const emit = typeof process !== 'undefined' && process.emitWarning;
              if (emit) emit(warning, type);
              else {
                console.warn(type ? `${type}: ${warning}` : warning);
              }
            }
          }
          function warnFileDeprecation(filename) {
            if (shouldWarn(true)) {
              const path = filename
                .replace(/.*yaml[/\\]/i, '')
                .replace(/\.js$/, '')
                .replace(/\\/g, '/');
              warn(`The endpoint 'yaml/${path}' will be removed in a future release.`, 'DeprecationWarning');
            }
          }
          var warned = {};
          function warnOptionDeprecation(name, alternative) {
            if (!warned[name] && shouldWarn(true)) {
              warned[name] = true;
              let msg = `The option '${name}' will be removed in a future release`;
              msg += alternative ? `, use '${alternative}' instead.` : '.';
              warn(msg, 'DeprecationWarning');
            }
          }
          exports.binary = binary;
          exports.floatTime = floatTime;
          exports.intTime = intTime;
          exports.omap = omap;
          exports.pairs = pairs;
          exports.set = set;
          exports.timestamp = timestamp;
          exports.warn = warn;
          exports.warnFileDeprecation = warnFileDeprecation;
          exports.warnOptionDeprecation = warnOptionDeprecation;
        },
      });
      require_Schema_88e323a7 = __commonJS2({
        'node_modules/yaml/dist/Schema-88e323a7.js'(exports) {
          var PlainValue = require_PlainValue_ec8e588e();
          var resolveSeq = require_resolveSeq_d03cb037();
          var warnings = require_warnings_1000a372();
          function createMap(schema, obj, ctx) {
            const map2 = new resolveSeq.YAMLMap(schema);
            if (obj instanceof Map) {
              for (const [key, value] of obj) map2.items.push(schema.createPair(key, value, ctx));
            } else if (obj && typeof obj === 'object') {
              for (const key of Object.keys(obj)) map2.items.push(schema.createPair(key, obj[key], ctx));
            }
            if (typeof schema.sortMapEntries === 'function') {
              map2.items.sort(schema.sortMapEntries);
            }
            return map2;
          }
          var map = {
            createNode: createMap,
            default: true,
            nodeClass: resolveSeq.YAMLMap,
            tag: 'tag:yaml.org,2002:map',
            resolve: resolveSeq.resolveMap,
          };
          function createSeq(schema, obj, ctx) {
            const seq2 = new resolveSeq.YAMLSeq(schema);
            if (obj && obj[Symbol.iterator]) {
              for (const it of obj) {
                const v = schema.createNode(it, ctx.wrapScalars, null, ctx);
                seq2.items.push(v);
              }
            }
            return seq2;
          }
          var seq = {
            createNode: createSeq,
            default: true,
            nodeClass: resolveSeq.YAMLSeq,
            tag: 'tag:yaml.org,2002:seq',
            resolve: resolveSeq.resolveSeq,
          };
          var string = {
            identify: (value) => typeof value === 'string',
            default: true,
            tag: 'tag:yaml.org,2002:str',
            resolve: resolveSeq.resolveString,
            stringify(item, ctx, onComment, onChompKeep) {
              ctx = Object.assign(
                {
                  actualString: true,
                },
                ctx
              );
              return resolveSeq.stringifyString(item, ctx, onComment, onChompKeep);
            },
            options: resolveSeq.strOptions,
          };
          var failsafe = [map, seq, string];
          var intIdentify$2 = (value) => typeof value === 'bigint' || Number.isInteger(value);
          var intResolve$1 = (src, part, radix) =>
            resolveSeq.intOptions.asBigInt ? BigInt(src) : parseInt(part, radix);
          function intStringify$1(node, radix, prefix) {
            const { value } = node;
            if (intIdentify$2(value) && value >= 0) return prefix + value.toString(radix);
            return resolveSeq.stringifyNumber(node);
          }
          var nullObj = {
            identify: (value) => value == null,
            createNode: (schema, value, ctx) => (ctx.wrapScalars ? new resolveSeq.Scalar(null) : null),
            default: true,
            tag: 'tag:yaml.org,2002:null',
            test: /^(?:~|[Nn]ull|NULL)?$/,
            resolve: () => null,
            options: resolveSeq.nullOptions,
            stringify: () => resolveSeq.nullOptions.nullStr,
          };
          var boolObj = {
            identify: (value) => typeof value === 'boolean',
            default: true,
            tag: 'tag:yaml.org,2002:bool',
            test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
            resolve: (str) => str[0] === 't' || str[0] === 'T',
            options: resolveSeq.boolOptions,
            stringify: ({ value }) => (value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr),
          };
          var octObj = {
            identify: (value) => intIdentify$2(value) && value >= 0,
            default: true,
            tag: 'tag:yaml.org,2002:int',
            format: 'OCT',
            test: /^0o([0-7]+)$/,
            resolve: (str, oct) => intResolve$1(str, oct, 8),
            options: resolveSeq.intOptions,
            stringify: (node) => intStringify$1(node, 8, '0o'),
          };
          var intObj = {
            identify: intIdentify$2,
            default: true,
            tag: 'tag:yaml.org,2002:int',
            test: /^[-+]?[0-9]+$/,
            resolve: (str) => intResolve$1(str, str, 10),
            options: resolveSeq.intOptions,
            stringify: resolveSeq.stringifyNumber,
          };
          var hexObj = {
            identify: (value) => intIdentify$2(value) && value >= 0,
            default: true,
            tag: 'tag:yaml.org,2002:int',
            format: 'HEX',
            test: /^0x([0-9a-fA-F]+)$/,
            resolve: (str, hex) => intResolve$1(str, hex, 16),
            options: resolveSeq.intOptions,
            stringify: (node) => intStringify$1(node, 16, '0x'),
          };
          var nanObj = {
            identify: (value) => typeof value === 'number',
            default: true,
            tag: 'tag:yaml.org,2002:float',
            test: /^(?:[-+]?\.inf|(\.nan))$/i,
            resolve: (str, nan) => (nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY),
            stringify: resolveSeq.stringifyNumber,
          };
          var expObj = {
            identify: (value) => typeof value === 'number',
            default: true,
            tag: 'tag:yaml.org,2002:float',
            format: 'EXP',
            test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
            resolve: (str) => parseFloat(str),
            stringify: ({ value }) => Number(value).toExponential(),
          };
          var floatObj = {
            identify: (value) => typeof value === 'number',
            default: true,
            tag: 'tag:yaml.org,2002:float',
            test: /^[-+]?(?:\.([0-9]+)|[0-9]+\.([0-9]*))$/,
            resolve(str, frac1, frac2) {
              const frac = frac1 || frac2;
              const node = new resolveSeq.Scalar(parseFloat(str));
              if (frac && frac[frac.length - 1] === '0') node.minFractionDigits = frac.length;
              return node;
            },
            stringify: resolveSeq.stringifyNumber,
          };
          var core = failsafe.concat([nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj]);
          var intIdentify$1 = (value) => typeof value === 'bigint' || Number.isInteger(value);
          var stringifyJSON = ({ value }) => JSON.stringify(value);
          var json = [
            map,
            seq,
            {
              identify: (value) => typeof value === 'string',
              default: true,
              tag: 'tag:yaml.org,2002:str',
              resolve: resolveSeq.resolveString,
              stringify: stringifyJSON,
            },
            {
              identify: (value) => value == null,
              createNode: (schema, value, ctx) => (ctx.wrapScalars ? new resolveSeq.Scalar(null) : null),
              default: true,
              tag: 'tag:yaml.org,2002:null',
              test: /^null$/,
              resolve: () => null,
              stringify: stringifyJSON,
            },
            {
              identify: (value) => typeof value === 'boolean',
              default: true,
              tag: 'tag:yaml.org,2002:bool',
              test: /^true|false$/,
              resolve: (str) => str === 'true',
              stringify: stringifyJSON,
            },
            {
              identify: intIdentify$1,
              default: true,
              tag: 'tag:yaml.org,2002:int',
              test: /^-?(?:0|[1-9][0-9]*)$/,
              resolve: (str) => (resolveSeq.intOptions.asBigInt ? BigInt(str) : parseInt(str, 10)),
              stringify: ({ value }) => (intIdentify$1(value) ? value.toString() : JSON.stringify(value)),
            },
            {
              identify: (value) => typeof value === 'number',
              default: true,
              tag: 'tag:yaml.org,2002:float',
              test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
              resolve: (str) => parseFloat(str),
              stringify: stringifyJSON,
            },
          ];
          json.scalarFallback = (str) => {
            throw new SyntaxError(`Unresolved plain scalar ${JSON.stringify(str)}`);
          };
          var boolStringify = ({ value }) => (value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr);
          var intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);
          function intResolve(sign, src, radix) {
            let str = src.replace(/_/g, '');
            if (resolveSeq.intOptions.asBigInt) {
              switch (radix) {
                case 2:
                  str = `0b${str}`;
                  break;
                case 8:
                  str = `0o${str}`;
                  break;
                case 16:
                  str = `0x${str}`;
                  break;
              }
              const n2 = BigInt(str);
              return sign === '-' ? BigInt(-1) * n2 : n2;
            }
            const n = parseInt(str, radix);
            return sign === '-' ? -1 * n : n;
          }
          function intStringify(node, radix, prefix) {
            const { value } = node;
            if (intIdentify(value)) {
              const str = value.toString(radix);
              return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;
            }
            return resolveSeq.stringifyNumber(node);
          }
          var yaml11 = failsafe.concat(
            [
              {
                identify: (value) => value == null,
                createNode: (schema, value, ctx) => (ctx.wrapScalars ? new resolveSeq.Scalar(null) : null),
                default: true,
                tag: 'tag:yaml.org,2002:null',
                test: /^(?:~|[Nn]ull|NULL)?$/,
                resolve: () => null,
                options: resolveSeq.nullOptions,
                stringify: () => resolveSeq.nullOptions.nullStr,
              },
              {
                identify: (value) => typeof value === 'boolean',
                default: true,
                tag: 'tag:yaml.org,2002:bool',
                test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
                resolve: () => true,
                options: resolveSeq.boolOptions,
                stringify: boolStringify,
              },
              {
                identify: (value) => typeof value === 'boolean',
                default: true,
                tag: 'tag:yaml.org,2002:bool',
                test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
                resolve: () => false,
                options: resolveSeq.boolOptions,
                stringify: boolStringify,
              },
              {
                identify: intIdentify,
                default: true,
                tag: 'tag:yaml.org,2002:int',
                format: 'BIN',
                test: /^([-+]?)0b([0-1_]+)$/,
                resolve: (str, sign, bin) => intResolve(sign, bin, 2),
                stringify: (node) => intStringify(node, 2, '0b'),
              },
              {
                identify: intIdentify,
                default: true,
                tag: 'tag:yaml.org,2002:int',
                format: 'OCT',
                test: /^([-+]?)0([0-7_]+)$/,
                resolve: (str, sign, oct) => intResolve(sign, oct, 8),
                stringify: (node) => intStringify(node, 8, '0'),
              },
              {
                identify: intIdentify,
                default: true,
                tag: 'tag:yaml.org,2002:int',
                test: /^([-+]?)([0-9][0-9_]*)$/,
                resolve: (str, sign, abs) => intResolve(sign, abs, 10),
                stringify: resolveSeq.stringifyNumber,
              },
              {
                identify: intIdentify,
                default: true,
                tag: 'tag:yaml.org,2002:int',
                format: 'HEX',
                test: /^([-+]?)0x([0-9a-fA-F_]+)$/,
                resolve: (str, sign, hex) => intResolve(sign, hex, 16),
                stringify: (node) => intStringify(node, 16, '0x'),
              },
              {
                identify: (value) => typeof value === 'number',
                default: true,
                tag: 'tag:yaml.org,2002:float',
                test: /^(?:[-+]?\.inf|(\.nan))$/i,
                resolve: (str, nan) =>
                  nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
                stringify: resolveSeq.stringifyNumber,
              },
              {
                identify: (value) => typeof value === 'number',
                default: true,
                tag: 'tag:yaml.org,2002:float',
                format: 'EXP',
                test: /^[-+]?([0-9][0-9_]*)?(\.[0-9_]*)?[eE][-+]?[0-9]+$/,
                resolve: (str) => parseFloat(str.replace(/_/g, '')),
                stringify: ({ value }) => Number(value).toExponential(),
              },
              {
                identify: (value) => typeof value === 'number',
                default: true,
                tag: 'tag:yaml.org,2002:float',
                test: /^[-+]?(?:[0-9][0-9_]*)?\.([0-9_]*)$/,
                resolve(str, frac) {
                  const node = new resolveSeq.Scalar(parseFloat(str.replace(/_/g, '')));
                  if (frac) {
                    const f = frac.replace(/_/g, '');
                    if (f[f.length - 1] === '0') node.minFractionDigits = f.length;
                  }
                  return node;
                },
                stringify: resolveSeq.stringifyNumber,
              },
            ],
            warnings.binary,
            warnings.omap,
            warnings.pairs,
            warnings.set,
            warnings.intTime,
            warnings.floatTime,
            warnings.timestamp
          );
          var schemas = {
            core,
            failsafe,
            json,
            yaml11,
          };
          var tags = {
            binary: warnings.binary,
            bool: boolObj,
            float: floatObj,
            floatExp: expObj,
            floatNaN: nanObj,
            floatTime: warnings.floatTime,
            int: intObj,
            intHex: hexObj,
            intOct: octObj,
            intTime: warnings.intTime,
            map,
            null: nullObj,
            omap: warnings.omap,
            pairs: warnings.pairs,
            seq,
            set: warnings.set,
            timestamp: warnings.timestamp,
          };
          function findTagObject(value, tagName, tags2) {
            if (tagName) {
              const match = tags2.filter((t) => t.tag === tagName);
              const tagObj = match.find((t) => !t.format) || match[0];
              if (!tagObj) throw new Error(`Tag ${tagName} not found`);
              return tagObj;
            }
            return tags2.find(
              (t) => ((t.identify && t.identify(value)) || (t.class && value instanceof t.class)) && !t.format
            );
          }
          function createNode(value, tagName, ctx) {
            if (value instanceof resolveSeq.Node) return value;
            const { defaultPrefix, onTagObj, prevObjects, schema, wrapScalars } = ctx;
            if (tagName && tagName.startsWith('!!')) tagName = defaultPrefix + tagName.slice(2);
            let tagObj = findTagObject(value, tagName, schema.tags);
            if (!tagObj) {
              if (typeof value.toJSON === 'function') value = value.toJSON();
              if (!value || typeof value !== 'object') return wrapScalars ? new resolveSeq.Scalar(value) : value;
              tagObj = value instanceof Map ? map : value[Symbol.iterator] ? seq : map;
            }
            if (onTagObj) {
              onTagObj(tagObj);
              delete ctx.onTagObj;
            }
            const obj = {
              value: void 0,
              node: void 0,
            };
            if (value && typeof value === 'object' && prevObjects) {
              const prev = prevObjects.get(value);
              if (prev) {
                const alias = new resolveSeq.Alias(prev);
                ctx.aliasNodes.push(alias);
                return alias;
              }
              obj.value = value;
              prevObjects.set(value, obj);
            }
            obj.node = tagObj.createNode
              ? tagObj.createNode(ctx.schema, value, ctx)
              : wrapScalars
                ? new resolveSeq.Scalar(value)
                : value;
            if (tagName && obj.node instanceof resolveSeq.Node) obj.node.tag = tagName;
            return obj.node;
          }
          function getSchemaTags(schemas2, knownTags, customTags, schemaId) {
            let tags2 = schemas2[schemaId.replace(/\W/g, '')];
            if (!tags2) {
              const keys = Object.keys(schemas2)
                .map((key) => JSON.stringify(key))
                .join(', ');
              throw new Error(`Unknown schema "${schemaId}"; use one of ${keys}`);
            }
            if (Array.isArray(customTags)) {
              for (const tag of customTags) tags2 = tags2.concat(tag);
            } else if (typeof customTags === 'function') {
              tags2 = customTags(tags2.slice());
            }
            for (let i = 0; i < tags2.length; ++i) {
              const tag = tags2[i];
              if (typeof tag === 'string') {
                const tagObj = knownTags[tag];
                if (!tagObj) {
                  const keys = Object.keys(knownTags)
                    .map((key) => JSON.stringify(key))
                    .join(', ');
                  throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
                }
                tags2[i] = tagObj;
              }
            }
            return tags2;
          }
          var sortMapEntriesByKey = (a, b) => (a.key < b.key ? -1 : a.key > b.key ? 1 : 0);
          var Schema2 = class _Schema {
            // TODO: remove in v2
            // TODO: remove in v2
            constructor({ customTags, merge: merge2, schema, sortMapEntries, tags: deprecatedCustomTags }) {
              this.merge = !!merge2;
              this.name = schema;
              this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;
              if (!customTags && deprecatedCustomTags) warnings.warnOptionDeprecation('tags', 'customTags');
              this.tags = getSchemaTags(schemas, tags, customTags || deprecatedCustomTags, schema);
            }
            createNode(value, wrapScalars, tagName, ctx) {
              const baseCtx = {
                defaultPrefix: _Schema.defaultPrefix,
                schema: this,
                wrapScalars,
              };
              const createCtx = ctx ? Object.assign(ctx, baseCtx) : baseCtx;
              return createNode(value, tagName, createCtx);
            }
            createPair(key, value, ctx) {
              if (!ctx)
                ctx = {
                  wrapScalars: true,
                };
              const k = this.createNode(key, ctx.wrapScalars, null, ctx);
              const v = this.createNode(value, ctx.wrapScalars, null, ctx);
              return new resolveSeq.Pair(k, v);
            }
          };
          PlainValue._defineProperty(Schema2, 'defaultPrefix', PlainValue.defaultTagPrefix);
          PlainValue._defineProperty(Schema2, 'defaultTags', PlainValue.defaultTags);
          exports.Schema = Schema2;
        },
      });
      require_types2 = __commonJS2({
        'node_modules/yaml/dist/types.js'(exports) {
          var resolveSeq = require_resolveSeq_d03cb037();
          var Schema2 = require_Schema_88e323a7();
          require_PlainValue_ec8e588e();
          require_warnings_1000a372();
          exports.Alias = resolveSeq.Alias;
          exports.Collection = resolveSeq.Collection;
          exports.Merge = resolveSeq.Merge;
          exports.Node = resolveSeq.Node;
          exports.Pair = resolveSeq.Pair;
          exports.Scalar = resolveSeq.Scalar;
          exports.YAMLMap = resolveSeq.YAMLMap;
          exports.YAMLSeq = resolveSeq.YAMLSeq;
          exports.binaryOptions = resolveSeq.binaryOptions;
          exports.boolOptions = resolveSeq.boolOptions;
          exports.intOptions = resolveSeq.intOptions;
          exports.nullOptions = resolveSeq.nullOptions;
          exports.strOptions = resolveSeq.strOptions;
          exports.Schema = Schema2.Schema;
        },
      });
      DEPENDENCIES = {};
      getDependencies = () => {
        return DEPENDENCIES;
      };
      setDependencies = (value) => {
        Object.assign(DEPENDENCIES, value);
      };
      Registry = class {
        constructor() {
          this.data = {};
        }
        /**
         * Unregisters custom format(s)
         * @param name
         */
        unregister(name) {
          if (!name) {
            this.data = {};
          } else {
            delete this.data[name];
          }
        }
        /**
         * Registers custom format
         */
        register(name, callback) {
          this.data[name] = callback;
        }
        /**
         * Register many formats at one shot
         */
        registerMany(formats) {
          Object.keys(formats).forEach((name) => {
            this.data[name] = formats[name];
          });
        }
        /**
         * Returns element by registry key
         */
        get(name) {
          const format = this.data[name];
          return format;
        }
        /**
         * Returns the whole registry content
         */
        list() {
          return this.data;
        }
      };
      Registry_default = Registry;
      defaults = {};
      defaults_default = defaults;
      defaults.defaultInvalidTypeProduct = void 0;
      defaults.defaultRandExpMax = 10;
      defaults.pruneProperties = [];
      defaults.ignoreProperties = [];
      defaults.ignoreMissingRefs = false;
      defaults.failOnInvalidTypes = true;
      defaults.failOnInvalidFormat = true;
      defaults.alwaysFakeOptionals = false;
      defaults.optionalsProbability = null;
      defaults.fixedProbabilities = false;
      defaults.useExamplesValue = false;
      defaults.useDefaultValue = false;
      defaults.requiredOnly = false;
      defaults.omitNulls = false;
      defaults.minItems = 0;
      defaults.maxItems = null;
      defaults.minLength = 0;
      defaults.maxLength = null;
      defaults.resolveJsonPath = false;
      defaults.reuseProperties = false;
      defaults.fillProperties = true;
      defaults.sortProperties = false;
      defaults.replaceEmptyByRandomValue = false;
      defaults.random = Math.random;
      defaults.minDateTime = /* @__PURE__ */ new Date('1889-12-31T00:00:00.000Z');
      defaults.maxDateTime = /* @__PURE__ */ new Date('1970-01-01T00:00:01.000Z');
      defaults.renderTitle = true;
      defaults.renderDescription = true;
      defaults.renderComment = false;
      OptionRegistry = class extends Registry_default {
        constructor() {
          super();
          this.data = { ...defaults_default };
          this._defaults = defaults_default;
        }
        get defaults() {
          return { ...this._defaults };
        }
      };
      OptionRegistry_default = OptionRegistry;
      registry = new OptionRegistry_default();
      optionAPI.getDefaults = () => registry.defaults;
      option_default = optionAPI;
      ALLOWED_TYPES = ['integer', 'number', 'string', 'boolean'];
      SCALAR_TYPES = ALLOWED_TYPES.concat(['null']);
      ALL_TYPES = ['array', 'object'].concat(SCALAR_TYPES);
      MOST_NEAR_DATETIME = 2524608e6;
      MIN_INTEGER = -1e8;
      MAX_INTEGER = 1e8;
      MIN_NUMBER = -100;
      MAX_NUMBER = 100;
      constants_default = {
        ALLOWED_TYPES,
        SCALAR_TYPES,
        ALL_TYPES,
        MIN_NUMBER,
        MAX_NUMBER,
        MIN_INTEGER,
        MAX_INTEGER,
        MOST_NEAR_DATETIME,
      };
      import_randexp = __toESM(require_randexp(), 1);
      random_default = {
        pick,
        date,
        shuffle,
        number,
        randexp: _randexp,
      };
      RE_NUMERIC = /^(0|[1-9][0-9]*)$/;
      utils_default = {
        hasProperties,
        getLocalRef,
        omitProps,
        typecast,
        merge,
        clone,
        short,
        hasValue,
        notValue,
        anyValue,
        validate,
        validateValueForSchema,
        validateValueForOneOf,
        isKey,
        template,
        shouldClean,
        clean,
        isEmpty,
        clampDate,
      };
      Container = class {
        constructor() {
          this.registry = {};
          this.support = {};
        }
        /**
         * Unregister extensions
         * @param name
         */
        reset(name) {
          if (!name) {
            this.registry = {};
            this.support = {};
          } else {
            delete this.registry[name];
            delete this.support[name];
          }
        }
        /**
         * Override dependency given by name
         * @param name
         * @param callback
         */
        extend(name, callback) {
          this.registry[name] = callback(this.registry[name]);
          if (!this.support[name]) {
            this.support[name] = proxy(() => this.registry[name]);
          }
        }
        /**
         * Set keyword support by name
         * @param name
         * @param callback
         */
        define(name, callback) {
          this.support[name] = callback;
        }
        /**
         * Returns dependency given by name
         * @param name
         * @returns {Dependency}
         */
        get(name) {
          if (typeof this.registry[name] === 'undefined') {
            throw new ReferenceError(`'${name}' dependency doesn't exist.`);
          }
          return this.registry[name];
        }
        /**
         * Apply a custom keyword
         * @param schema
         */
        wrap(schema) {
          if (!('generate' in schema)) {
            const keys = Object.keys(schema);
            const context = {};
            let length = keys.length;
            while (length--) {
              const fn = keys[length].replace(/^x-/, '');
              const gen = this.support[fn];
              if (typeof gen === 'function') {
                Object.defineProperty(schema, 'generate', {
                  configurable: false,
                  enumerable: false,
                  writable: false,
                  value: (rootSchema, key) =>
                    gen.call(context, schema[keys[length]], schema, keys[length], rootSchema, key.slice()),
                });
                break;
              }
            }
          }
          return schema;
        }
      };
      Container_default = Container;
      registry2 = new Registry_default();
      format_default = formatAPI;
      ParseError = class extends Error {
        constructor(message, path) {
          super();
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          }
          this.name = 'ParseError';
          this.message = message;
          this.path = path;
        }
      };
      error_default = ParseError;
      inferredProperties = {
        array: ['additionalItems', 'items', 'maxItems', 'minItems', 'uniqueItems'],
        integer: ['exclusiveMaximum', 'exclusiveMinimum', 'maximum', 'minimum', 'multipleOf'],
        object: [
          'additionalProperties',
          'dependencies',
          'maxProperties',
          'minProperties',
          'patternProperties',
          'properties',
          'required',
        ],
        string: ['maxLength', 'minLength', 'pattern', 'format'],
      };
      inferredProperties.number = inferredProperties.integer;
      subschemaProperties = [
        'additionalItems',
        'items',
        'additionalProperties',
        'dependencies',
        'patternProperties',
        'properties',
      ];
      infer_default = inferType;
      boolean_default = booleanGenerator;
      booleanType = boolean_default;
      boolean_default2 = booleanType;
      null_default = nullGenerator;
      nullType = null_default;
      null_default2 = nullType;
      array_default = arrayType;
      number_default = numberType;
      integer_default = integerType;
      LIPSUM_WORDS = `Lorem ipsum dolor sit amet consectetur adipisicing elit sed do eiusmod tempor incididunt ut labore
et dolore magna aliqua Ut enim ad minim veniam quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea
commodo consequat Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla
pariatur Excepteur sint occaecat cupidatat non proident sunt in culpa qui officia deserunt mollit anim id est
laborum`.split(/\W/);
      words_default = wordsGenerator;
      anyType = { type: constants_default.ALLOWED_TYPES };
      object_default = objectType;
      thunk_default = thunkGenerator;
      ipv4_default = ipv4Generator;
      dateTime_default = dateTimeGenerator;
      date_default = dateGenerator;
      time_default = timeGenerator;
      FRAGMENT = '[a-zA-Z][a-zA-Z0-9+-.]*';
      URI_PATTERN = `https?://{hostname}(?:${FRAGMENT})+`;
      PARAM_PATTERN = '(?:\\?([a-z]{1,7}(=\\w{1,5})?&){0,3})?';
      regexps = {
        email: '[a-zA-Z\\d][a-zA-Z\\d-]{1,13}[a-zA-Z\\d]@{hostname}',
        hostname: '[a-zA-Z]{1,33}\\.[a-z]{2,4}',
        ipv6: '[a-f\\d]{4}(:[a-f\\d]{4}){7}',
        uri: URI_PATTERN,
        slug: '[a-zA-Z\\d_-]+',
        // types from draft-0[67] (?)
        'uri-reference': `${URI_PATTERN}${PARAM_PATTERN}`,
        'uri-template': URI_PATTERN.replace('(?:', '(?:/\\{[a-z][:a-zA-Z0-9-]*\\}|'),
        'json-pointer': `(/(?:${FRAGMENT.replace(']*', '/]*')}|~[01]))+`,
        // some types from https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.1.md#data-types (?)
        uuid: '^[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$',
        duration: '^P(?!$)((\\d+Y)?(\\d+M)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?|(\\d+W)?)$',
      };
      regexps.iri = regexps['uri-reference'];
      regexps['iri-reference'] = regexps['uri-reference'];
      regexps['idn-email'] = regexps.email;
      regexps['idn-hostname'] = regexps.hostname;
      ALLOWED_FORMATS = new RegExp(`\\{(${Object.keys(regexps).join('|')})\\}`);
      coreFormat_default = coreFormatGenerator;
      string_default = stringType;
      typeMap = {
        boolean: boolean_default2,
        null: null_default2,
        array: array_default,
        integer: integer_default,
        number: number_default,
        object: object_default,
        string: string_default,
      };
      types_default = typeMap;
      traverse_default = traverse;
      buildResolveSchema = ({ refs, schema, container: container2, synchronous, refDepthMax, refDepthMin }) => {
        const recursiveUtil = {};
        const seenRefs = {};
        let depth = 0;
        let lastRef;
        let lastPath;
        recursiveUtil.resolveSchema = (sub, index, rootPath) => {
          if (sub === null || sub === void 0) {
            return null;
          }
          if (typeof sub.generate === 'function') {
            return sub;
          }
          const _id = sub.$id || sub.id;
          if (typeof _id === 'string') {
            delete sub.id;
            delete sub.$id;
            delete sub.$schema;
          }
          if (typeof sub.$ref === 'string') {
            const maxDepth = Math.max(refDepthMin, refDepthMax) - 1;
            if (sub.$ref === '#' || seenRefs[sub.$ref] < 0 || (lastRef === sub.$ref && ++depth > maxDepth)) {
              if (sub.$ref !== '#' && lastPath && lastPath.length === rootPath.length) {
                return utils_default.getLocalRef(schema, sub.$ref, synchronous && refs);
              }
              delete sub.$ref;
              return sub;
            }
            if (typeof seenRefs[sub.$ref] === 'undefined') {
              seenRefs[sub.$ref] = random_default.number(refDepthMin, refDepthMax) - 1;
            }
            lastPath = rootPath;
            lastRef = sub.$ref;
            let ref;
            if (sub.$ref.indexOf('#/') === -1) {
              ref = refs[sub.$ref] || null;
            } else {
              ref = utils_default.getLocalRef(schema, sub.$ref, synchronous && refs) || null;
            }
            let fixed;
            if (typeof ref !== 'undefined') {
              if (!ref && option_default('ignoreMissingRefs') !== true) {
                throw new Error(`Reference not found: ${sub.$ref}`);
              }
              seenRefs[sub.$ref] -= 1;
              utils_default.merge(sub, ref || {});
              fixed = synchronous && ref && ref.$ref;
            }
            if (!fixed) delete sub.$ref;
            return sub;
          }
          if (Array.isArray(sub.allOf)) {
            const schemas = sub.allOf;
            delete sub.allOf;
            schemas.forEach((subSchema) => {
              const _sub = recursiveUtil.resolveSchema(subSchema, null, rootPath);
              utils_default.merge(sub, typeof _sub.thunk === 'function' ? _sub.thunk(sub) : _sub);
              if (Array.isArray(sub.allOf)) {
                recursiveUtil.resolveSchema(sub, index, rootPath);
              }
            });
          }
          if (Array.isArray(sub.oneOf || sub.anyOf) && rootPath[rootPath.length - 2] !== 'dependencies') {
            const mix = sub.oneOf || sub.anyOf;
            if (sub.enum && sub.oneOf) {
              sub.enum = sub.enum.filter((x) => utils_default.validate(x, mix));
            }
            return {
              thunk(rootSchema) {
                const copy = utils_default.omitProps(sub, ['anyOf', 'oneOf']);
                const fixed = random_default.pick(mix);
                utils_default.merge(copy, fixed);
                mix.forEach((omit) => {
                  if (omit.required && omit !== fixed) {
                    omit.required.forEach((key) => {
                      if (fixed.required && fixed.required.includes(key)) {
                        return;
                      }
                      const includesKey = copy.required && copy.required.includes(key);
                      if (copy.properties && !includesKey) {
                        delete copy.properties[key];
                      }
                      if (rootSchema && rootSchema.properties) {
                        delete rootSchema.properties[key];
                      }
                    });
                  }
                });
                return copy;
              },
            };
          }
          Object.keys(sub).forEach((prop) => {
            if ((Array.isArray(sub[prop]) || typeof sub[prop] === 'object') && !utils_default.isKey(prop)) {
              sub[prop] = recursiveUtil.resolveSchema(sub[prop], prop, rootPath.concat(prop));
            }
          });
          if (rootPath) {
            const lastProp = rootPath[rootPath.length - 1];
            if (lastProp === 'properties' || lastProp === 'items') {
              return sub;
            }
          }
          return container2.wrap(sub);
        };
        return recursiveUtil;
      };
      buildResolveSchema_default = buildResolveSchema;
      run_default = run;
      js_default = renderJS;
      import_types2 = __toESM(require_types2(), 1);
      binaryOptions = import_types2.default.binaryOptions;
      boolOptions = import_types2.default.boolOptions;
      intOptions = import_types2.default.intOptions;
      nullOptions = import_types2.default.nullOptions;
      strOptions = import_types2.default.strOptions;
      Schema = import_types2.default.Schema;
      Alias = import_types2.default.Alias;
      Collection = import_types2.default.Collection;
      Merge = import_types2.default.Merge;
      Node = import_types2.default.Node;
      Pair = import_types2.default.Pair;
      Scalar = import_types2.default.Scalar;
      YAMLMap = import_types2.default.YAMLMap;
      YAMLSeq = import_types2.default.YAMLSeq;
      yaml_default = renderYAML;
      container = new Container_default();
      jsf = (schema, refs, cwd) => {
        console.debug(
          '[json-schema-faker] calling JSONSchemaFaker() is deprecated, call either .generate() or .resolve()'
        );
        if (cwd) {
          console.debug('[json-schema-faker] local references are only supported by calling .resolve()');
        }
        return jsf.generate(schema, refs);
      };
      jsf.generateWithContext = (schema, refs) => {
        const $refs = getRefs(refs, schema);
        return run_default($refs, schema, container, true);
      };
      jsf.generate = (schema, refs) => js_default(jsf.generateWithContext(schema, refs));
      jsf.generateYAML = (schema, refs) => yaml_default(jsf.generateWithContext(schema, refs));
      jsf.resolveWithContext = (schema, refs, cwd) => {
        if (typeof refs === 'string') {
          cwd = refs;
          refs = {};
        }
        cwd = cwd || (typeof process !== 'undefined' && typeof process.cwd === 'function' ? process.cwd() : '');
        cwd = `${cwd.replace(/\/+$/, '')}/`;
        const $refs = getRefs(refs, schema);
        const fixedRefs = {
          order: 1,
          canRead(file) {
            const key = file.url.replace('/:', ':');
            return $refs[key] || $refs[key.split('/').pop()];
          },
          read(file, callback) {
            try {
              callback(null, this.canRead(file));
            } catch (e) {
              callback(e);
            }
          },
        };
        const { $RefParser: $RefParser2 } = getDependencies();
        return $RefParser2
          .bundle(cwd, schema, {
            resolve: {
              file: { order: 100 },
              http: { order: 200 },
              fixedRefs,
            },
            dereference: {
              circular: 'ignore',
            },
          })
          .then((sub) => run_default($refs, sub, container))
          .catch((e) => {
            throw new Error(`Error while resolving schema (${e.message})`);
          });
      };
      jsf.resolve = (schema, refs, cwd) => jsf.resolveWithContext(schema, refs, cwd).then(js_default);
      jsf.resolveYAML = (schema, refs, cwd) => jsf.resolveWithContext(schema, refs, cwd).then(yaml_default);
      setupKeywords();
      jsf.format = format_default;
      jsf.option = option_default;
      jsf.random = random_default;
      jsf.extend = (name, cb) => {
        container.extend(name, cb);
        return jsf;
      };
      jsf.define = (name, cb) => {
        container.define(name, cb);
        return jsf;
      };
      jsf.reset = (name) => {
        container.reset(name);
        setupKeywords();
        return jsf;
      };
      jsf.locate = (name) => {
        return container.get(name);
      };
      jsf.VERSION = '0.5.5';
      JSONSchemaFaker = { ...jsf };
      lib_default = jsf;
    },
  });

  // src/src/main.iife.js
  var require_main_iife = __commonJS({
    'src/src/main.iife.js'(exports, module) {
      var jsf2 = (init_shared(), __toCommonJS(shared_exports));
      if (typeof $RefParser !== 'undefined' && typeof JSONPath !== 'undefined') {
        jsf2.setDependencies({ ...JSONPath, $RefParser });
      }
      if (typeof window !== 'undefined') {
        window.JSONSchemaFaker = jsf2.default;
      }
      module.exports = jsf2.default;
      module.exports.JSONSchemaFaker = jsf2.JSONSchemaFaker;
    },
  });
  return require_main_iife();
})();
((root, factory) => {
  root.JSONSchemaFaker = factory();
})(typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : globalThis, () => JSONSchemaFaker);

/*
 * *******************************************************************
 * | The following code are Novu required additions to the IIFE code |
 * *******************************************************************
 */
JSONSchemaFaker.random.shuffle = function shuffle() {
  return ['[placeholder]'];
};

JSONSchemaFaker.option({
  useDefaultValue: true,
  alwaysFakeOptionals: true,
});

export function mockSchema(schema) {
  return JSONSchemaFaker.generate(schema);
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - __init()
 - __require()
 - optionAPI(nameOrOptionMap, optionalValue)
 - getRandomInteger(min, max)
 - _randexp(value)
 - pick(collection)
 - shuffle(collection)
 - getRandom(min, max)
 - number(min, max, defMin, defMax, hasPrecision = false)
 - by(type)
 - date(step)
 - getLocalRef(obj, path, refs)
 - isNumeric(value)
 - isScalar(value)
 - hasProperties(obj, ...properties)
 - clampDate(value)
 - clampDateTime(value)
 - typecast(type, schema, callback)
 - merge(a, b)
 - clone(obj, cache = /* @__PURE__ */ new Map()
 - short(schema)
 - anyValue()
 - hasValue(schema, value)
 - notValue(schema, parent)
 - validateValueForSchema(value, schema)
 - validate(value, schemas)
 - validateValueForOneOf(value, oneOf)
 - isKey(prop)
 - omitProps(obj, props)
 - template(value, schema)
 - isEmpty(value)
 - shouldClean(key, schema)
 - clean(obj, schema, isArray = false)
 - proxy(gen)
 - formatAPI(nameOrFormatMap, callback)
 - matchesType(obj, lastElementInPath, inferredTypeProperties)
 - inferType(obj, schemaPath)
 - booleanGenerator()
 - nullGenerator()
 - unique(path, items, value, sample, resolve2, traverseCallback)
 - walk(obj)
 - arrayType(value, path, resolve2, traverseCallback)
 - numberType(value)
 - integerType(value)
 - wordsGenerator(length)
 - objectType(value, path, resolve2, traverseCallback)
 - get(from)
 - produce()
 - thunkGenerator(min = 0, max = 140)
 - ipv4Generator()
 - dateTimeGenerator()
 - dateGenerator()
 - timeGenerator()
 - coreFormatGenerator(coreFormat)
 - generateFormat(value, invalid)
 - stringType(value)
 - getMeta({ $comment: comment, title, description })
 - traverse(schema, path, resolve2, rootSchema)
 - pick2(data)
 - cycle(data, reverse)
 - resolve(obj, data, values, property)
 - run(refs, schema, container2, synchronous)
 - renderJS(res)
 - getIn(obj, path)
 - addComments(context, path, commentNode, iterNode = commentNode)
 - renderYAML({ value, context })
 - setupKeywords()
 - autoIncrement(value, schema)
 - sequentialDate(value, schema)
 - getRefs(refs, schema)
 - walk(obj)
 - __require()
 - findLineStarts(src)
 - getSrcInfo(cst)
 - getLinePos(offset, cst)
 - getLine(line, cst)
 - getPrettyContext({ start, end }, cst, maxWidth = 80)
 - _defineProperty(obj, key, value)
 - addCommentBefore(str, indent, comment)
 - addComment(str, indent, comment)
 - toJSON(value, arg, ctx)
 - collectionFromPath(schema, path, value)
 - asItemIndex(key)
 - findPair(items, key)
 - resolveScalar(str, tags, scalarFallback)
 - foldFlowLines(text,
            indent,
            mode,
            { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow })
 - lineLengthOverLimit(str, lineWidth, indentLength)
 - doubleQuotedString(value, ctx)
 - singleQuotedString(value, ctx)
 - blockString({ comment, type, value }, ctx, onComment, onChompKeep)
 - plainString(item, ctx, onComment, onChompKeep)
 - stringifyString(item, ctx, onComment, onChompKeep)
 - stringifyNumber({ format, minFractionDigits, tag, value })
 - checkFlowCollectionEnd(errors, cst)
 - checkFlowCommentSpace(errors, comment)
 - getLongKeyError(source, key)
 - resolveComments(collection, comments)
 - resolveString(doc, node)
 - resolveTagHandle(doc, node)
 - resolveTagName(doc, node)
 - resolveByTagName(doc, node, tagName)
 - getFallbackTagName({ type })
 - resolveTag(doc, node, tagName)
 - resolveNodeProps(errors, node)
 - resolveNodeValue(doc, node)
 - resolveNode(doc, node)
 - resolveMap(doc, cst)
 - resolvePairComment(item, pair)
 - resolveBlockMapItems(doc, cst)
 - resolveFlowMapItems(doc, cst)
 - resolveSeq(doc, cst)
 - resolveBlockSeqItems(doc, cst)
 - resolveFlowSeqItems(doc, cst)
 - parsePairs(doc, cst)
 - createPairs(schema, iterable, ctx)
 - parseOMap(doc, cst)
 - createOMap(schema, iterable, ctx)
 - parseSet(doc, cst)
 - createSet(schema, iterable, ctx)
 - shouldWarn(deprecation)
 - warn(warning, type)
 - warnFileDeprecation(filename)
 - warnOptionDeprecation(name, alternative)
 - createMap(schema, obj, ctx)
 - createSeq(schema, obj, ctx)
 - intStringify$1(node, radix, prefix)
 - intResolve(sign, src, radix)
 - intStringify(node, radix, prefix)
 - findTagObject(value, tagName, tags2)
 - createNode(value, tagName, ctx)
 - getSchemaTags(schemas2, knownTags, customTags, schemaId)
 - shuffle()
 - mockSchema(schema)
Asignaciones con arrow functions encontradas (posibles funciones):
 - JSONSchemaFaker(())
 - __esm(fn, res))
 - __commonJS(cb, mod))
 - __export(target, all))
 - __copyProps(to, from, except, desc))
 - __toCommonJS(mod))
 - shared_exports({};
  __export(shared_exports, {
    JSONSchemaFaker: ())
 - randInt(a, b))
 - enum(schema.enum.filter((x))
 - value(/* @__PURE__ */ new Date(`1969-01-01 ${value}`)
              .toISOString()
              .substr(1...)
 - arr([];
      cache.set(obj, arr);
      arr.push(...obj.map((x))
 - clonedObj({};
    cache.set(obj, clonedObj);
    return Object.keys(obj).reduce((prev, cur))
 - type(random_default.pick(
        constants_default.SCALAR_TYPES.filter((x))
 - types2(Array.isArray(schema.type) ? schema.type : [schema.type];
          return types2.every((type))
 - enum([value];
    }
    if (schema.required && copy.properties) {
      schema.required.forEach((prop))
 - validCount(oneOf.reduce((count, schema))
 - value(value.replace(/#\{([\w.-]+)\}/g, (_, $1))
 - value(value.apply(
          ctx,
          args.map((x))
 - optionalProperties(propertyKeys.concat(patternPropertyKeys).reduce((_response, _key))
 - extraProperties(optionalProperties.filter((_item))
 - _deps([];
    if (value.dependencies) {
      Object.keys(value.dependencies).forEach((prop))
 - missing([];
    _props.forEach((key))
 - hash(suffix))
 - sortedKeys(Object.keys(props).sort((a, b))
 - sortedObj(sortedKeys.reduce((memo, key))
 - result(traverseCallback(sortedObj, path.concat(['properties']), resolve2, value);
    _deps.forEach((dep))
 - result(result.substr(0, _max);
    }
    return result;
  }
  function ipv4Generator() {
    return [0, 0, ...)
 - output(utils_default.typecast('string', value, (opts))
 - fixedExamples(schema.examples.concat('default' in schema ? [schema.default] : []);
        return { value: utils_d...)
 - retVal(utils_default.typecast(null, schema, ())
 - pruneProperties(option_default('pruneProperties') || [];
    Object.keys(schema).forEach((prop))
 - data(obj;
    }
    if (Array.isArray(obj)) {
      return obj.map((x))
 - result(traverse_default(utils_default.clone(schema), [], resolveSchema);
      if (option_default('resolveJ...)
 - commentBefore(lines.join('\n');
    if (iterNode instanceof YAMLMap) {
      iterNode.items.forEach((n))
 - $refs({};
    if (Array.isArray(refs)) {
      refs.forEach((_schema))
 - __commonJS2(cb, mod))
 - __copyProps2(to, from, except, desc))
 - __toESM(mod, isNodeMode, target))
 - INTS())
 - WORDS())
 - WHITESPACE())
 - NOTANYCHAR())
 - words())
 - notWords())
 - ints())
 - notInts())
 - whitespace())
 - notWhitespace())
 - anyChar())
 - strToChars(str))
 - str(str.replace(chars_regex, (s, b, lbs, a16, b16, c8, dctrl, eslsh))
 - tokenizeClass(str, regexpStr))
 - error(regexp, msg))
 - wordBoundary())
 - nonWordBoundary())
 - begin())
 - end())
 - exports(regexpStr))
 - repeatErr(i2))
 - length(this.ranges.reduce((previous, range))
 - _add(subrange))
 - _subtract(subrange))
 - _intersect(subrange))
 - offset(this.range.setOrigRange(cr, offset);
              if (this.valueRange) this.valueRange.setOrigRange...)
 - Node2(class {};
          function toJSON(value, arg, ctx) {
            if (Array.isArray(value)) return ...)
 - onCreate(res2))
 - isEmptyPath(path))
 - nodes(this.items.reduce((nodes2, item, i))
 - str2(stringify(
                  item,
                  ctx,
                  ())
 - comment(null),
                  ())
 - strings(nodes.map((n))
 - i(0;
              for (const item of this.items) seq.push(toJSON(item, String(i++), ctx));
          ...)
 - stringifyKey(key, jsKey, ctx))
 - str(stringify(
                key,
                ctx,
                ())
 - keyComment(null),
                ())
 - valueStr(stringify(
                value,
                ctx,
                ())
 - valueComment(null),
                ())
 - getAliasCount(node, anchors))
 - anchor(Object.keys(anchors).find((a))
 - i(this.items.findIndex((item))
 - map(Type ? new Type() : ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
              if (ctx && c...)
 - consumeMoreIndentedLines(text, i))
 - getFoldOptions({ indentAtStart }))
 - containsDocumentMarker(str))
 - value(value
              .replace(/[\n\t ]*$/, (ws))
 - wsEnd(ws.replace(/\n$/, '');
                return '';
              })
              .replace(/^[\n ]*/,...)
 - _stringify(_type))
 - prefix(doc.tagPrefixes.find((p))
 - prefix(dtp.find((p))
 - isCollectionItem(node))
 - error(null;
                sources.some((node))
 - valueHasPairComment({ context: { lineStart, node, src }, props }))
 - items(items;
            resolveComments(seq, comments);
            if (!doc.options.mapAsMap && items.so...)
 - binary({
            identify: (value))
 - src(URL.createObjectURL(blob)
             */
            resolve: (doc, node))
 - msg('This environment does not support reading binary tags; either Buffer or atob is required';
        ...)
 - omap({
            identify: (value))
 - set({
            identify: (value))
 - parseSexagesimal(sign, parts))
 - n(parts.split(':').reduce((n2, p))
 - stringifySexagesimal({ value }))
 - value(Math.round((value - parts[0]) / 60);
                parts.unshift(value);
              }
         ...)
 - intTime({
            identify: (value))
 - floatTime({
            identify: (value))
 - timestamp({
            identify: (value))
 - string({
            identify: (value))
 - intIdentify$2(value))
 - intResolve$1(src, part, radix))
 - nullObj({
            identify: (value))
 - boolObj({
            identify: (value))
 - octObj({
            identify: (value))
 - intObj({
            identify: intIdentify$2,
            default: true,
            tag: 'tag:yaml.org,200...)
 - hexObj({
            identify: (value))
 - nanObj({
            identify: (value))
 - expObj({
            identify: (value))
 - floatObj({
            identify: (value))
 - intIdentify$1(value))
 - stringifyJSON({ value }))
 - json([
            map,
            seq,
            {
              identify: (value))
 - scalarFallback(str))
 - boolStringify({ value }))
 - intIdentify(value))
 - yaml11(failsafe.concat(
            [
              {
                identify: (value))
 - match(tags2.filter((t))
 - tagObj(match.find((t))
 - keys(Object.keys(schemas2)
                .map((key))
 - keys(Object.keys(knownTags)
                    .map((key))
 - sortMapEntriesByKey(a, b))
 - getDependencies())
 - setDependencies(value))
 - getDefaults())
 - buildResolveSchema({ refs, schema, container: container2, synchronous, refDepthMax, refDepthMin }))
 - resolveSchema(sub, index, rootPath))
 - schemas(sub.allOf;
            delete sub.allOf;
            schemas.forEach((subSchema))
 - enum(sub.enum.filter((x))
 - fixed(random_default.pick(mix);
                utils_default.merge(copy, fixed);
                mix.forE...)
 - includesKey(copy.required && copy.required.includes(key);
                      if (copy.properties && !includes...)
 - jsf(schema, refs, cwd))
 - generateWithContext(schema, refs))
 - generate(schema, refs))
 - generateYAML(schema, refs))
 - resolveWithContext(schema, refs, cwd))
 - resolve(schema, refs, cwd))
 - resolveYAML(schema, refs, cwd))
 - extend(name, cb))
 - define(name, cb))
 - reset(name))
 - locate(name))
 - JSONSchemaFaker(jsf2.JSONSchemaFaker;
    },
  });
  return require_main_iife();
})();
((root, factory))
Declaraciones 'export' encontradas:
- export
- export function mockSchema

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/shared.ts
Tamaño: 6326 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/**
 * ==========
 * | NOTICE |
 * ==========
 *
 * This file contains copied code from @novu/shared in order to temporarily eliminate the dependency of
 * framework on the shared package.
 *
 * The shared package, doesn't support ESM/CJS with strict TS yet.
 * So we sacrificed a bit code duplication in order to address ESM/CJS issues reported on the @novu/framework
 * caused by its @novu/shared dependency.
 *
 * Treat this as a temporary solution until the shared package is updated with the above.
 *
 */

export interface IResponseError {
  error: string;
  message: string;
  statusCode: number;
}

/**
 * Validate (type-guard) that an error response matches our IResponseError interface.
 */
export function checkIsResponseError(err: unknown): err is IResponseError {
  return !!err && typeof err === 'object' && 'error' in err && 'message' in err && 'statusCode' in err;
}

export enum ChannelTypeEnum {
  IN_APP = 'in_app',
  EMAIL = 'email',
  SMS = 'sms',
  CHAT = 'chat',
  PUSH = 'push',
}

export interface IAttachmentOptions {
  mime: string;
  file: Buffer;
  name?: string;
  channels?: ChannelTypeEnum[];
  cid?: string;
  disposition?: string;
}

export interface ITriggerPayload {
  attachments?: IAttachmentOptions[];
  [key: string]:
    | string
    | string[]
    | boolean
    | number
    | undefined
    | IAttachmentOptions
    | IAttachmentOptions[]
    | Record<string, unknown>;
}

export interface ISubscriberPayload {
  subscriberId: string;
  firstName?: string;
  lastName?: string;
  email?: string;
  phone?: string;
  avatar?: string;
  locale?: string;
  data?: Record<string, unknown>;
  channels?: ISubscriberChannel[];
}

export interface ISubscriberChannel {
  providerId: ChatProviderIdEnum | PushProviderIdEnum;
  integrationIdentifier?: string;
  credentials: IChannelCredentials;
}

export interface IChannelCredentials {
  webhookUrl?: string;
  deviceTokens?: string[];
}

export interface ITopic {
  type: 'Topic';
  topicKey: string;
  exclude?: string[];
}

export type TriggerRecipientsPayload = string | ISubscriberPayload | ITopic | ISubscriberPayload[] | ITopic[];

export enum TriggerEventStatusEnum {
  ERROR = 'error',
  NOT_ACTIVE = 'trigger_not_active',
  NO_WORKFLOW_ACTIVE_STEPS = 'no_workflow_active_steps_defined',
  NO_WORKFLOW_STEPS = 'no_workflow_steps_defined',
  PROCESSED = 'processed',
  // TODO: Seems not used. Remove.
  SUBSCRIBER_MISSING = 'subscriber_id_missing',
  TENANT_MISSING = 'no_tenant_found',
}

export enum EmailProviderIdEnum {
  EmailJS = 'emailjs',
  Mailgun = 'mailgun',
  Mailjet = 'mailjet',
  Mandrill = 'mandrill',
  CustomSMTP = 'nodemailer',
  Postmark = 'postmark',
  SendGrid = 'sendgrid',
  Sendinblue = 'sendinblue',
  SES = 'ses',
  NetCore = 'netcore',
  Infobip = 'infobip-email',
  Resend = 'resend',
  Plunk = 'plunk',
  MailerSend = 'mailersend',
  Mailtrap = 'mailtrap',
  Clickatell = 'clickatell',
  Outlook365 = 'outlook365',
  Novu = 'novu-email',
  SparkPost = 'sparkpost',
  EmailWebhook = 'email-webhook',
  Braze = 'braze',
}

export enum SmsProviderIdEnum {
  Nexmo = 'nexmo',
  Plivo = 'plivo',
  Sms77 = 'sms77',
  SmsCentral = 'sms-central',
  SNS = 'sns',
  Telnyx = 'telnyx',
  Twilio = 'twilio',
  Gupshup = 'gupshup',
  Firetext = 'firetext',
  Infobip = 'infobip-sms',
  BurstSms = 'burst-sms',
  BulkSms = 'bulk-sms',
  ISendSms = 'isend-sms',
  Clickatell = 'clickatell',
  FortySixElks = 'forty-six-elks',
  Kannel = 'kannel',
  Maqsam = 'maqsam',
  Termii = 'termii',
  AfricasTalking = 'africas-talking',
  Novu = 'novu-sms',
  Sendchamp = 'sendchamp',
  GenericSms = 'generic-sms',
  Clicksend = 'clicksend',
  Bandwidth = 'bandwidth',
  MessageBird = 'messagebird',
  Simpletexting = 'simpletexting',
  AzureSms = 'azure-sms',
  RingCentral = 'ring-central',
  BrevoSms = 'brevo-sms',
  EazySms = 'eazy-sms',
  Mobishastra = 'mobishastra',
  AfroSms = 'afro-message',
  Unifonic = 'unifonic',
  Smsmode = 'smsmode',
  IMedia = 'imedia',
  Sinch = 'sinch',
}

export enum ChatProviderIdEnum {
  Slack = 'slack',
  Discord = 'discord',
  MsTeams = 'msteams',
  Mattermost = 'mattermost',
  Ryver = 'ryver',
  Zulip = 'zulip',
  GrafanaOnCall = 'grafana-on-call',
  GetStream = 'getstream',
  RocketChat = 'rocket-chat',
  WhatsAppBusiness = 'whatsapp-business',
  ChatWebhook = 'chat-webhook',
}

export enum PushProviderIdEnum {
  FCM = 'fcm',
  APNS = 'apns',
  EXPO = 'expo',
  OneSignal = 'one-signal',
  Pushpad = 'pushpad',
  PushWebhook = 'push-webhook',
  PusherBeams = 'pusher-beams',
}

export enum InAppProviderIdEnum {
  Novu = 'novu',
}

/**
 * A preference for a notification delivery workflow.
 *
 * This provides a shortcut to setting all channels to the same preference.
 */
export type WorkflowPreference = {
  /**
   * A flag specifying if notification delivery is enabled for the workflow.
   *
   * If `true`, notification delivery is enabled by default for all channels.
   *
   * This setting can be overridden by the channel preferences.
   *
   * @default true
   */
  enabled: boolean;
  /**
   * A flag specifying if the preference is read-only.
   *
   * If `true`, the preference cannot be changed by the Subscriber.
   *
   * @default false
   */
  readOnly: boolean;
};

/** A preference for a notification delivery channel. */
export type ChannelPreference = {
  /**
   * A flag specifying if notification delivery is enabled for the channel.
   *
   * If `true`, notification delivery is enabled.
   *
   * @default true
   */
  enabled: boolean;
};

export type WorkflowPreferences = {
  /**
   * A preference for the workflow.
   *
   * The values specified here will be used if no preference is specified for a channel.
   */
  all: WorkflowPreference;
  /**
   * A preference for each notification delivery channel.
   *
   * If no preference is specified for a channel, the `all` preference will be used.
   */
  channels: Record<ChannelTypeEnum, ChannelPreference>;
};

/**
 * Recursively make all properties of type `T` optional.
 */
// TODO: This utility also exists in src/types/util.types.ts. They should be consolidated.
export type DeepPartial<T> = T extends object
  ? {
      [P in keyof T]?: DeepPartial<T[P]>;
    }
  : T;

/** A partial set of workflow preferences. */
export type WorkflowPreferencesPartial = DeepPartial<WorkflowPreferences>;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - checkIsResponseError(err: unknown)
Declaraciones 'export' encontradas:
- export  interface
- export function checkIsResponseError
- export  enum
- export  interface
- export  interface
- export  interface
- export  interface
- export  interface
- export  interface
- export  type
- export  enum
- export  enum
- export  enum
- export  enum
- export  enum
- export  enum
- export  type
- export  type
- export  type
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/constants/action.constants.ts
Tamaño: 206 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export enum PostActionEnum {
  TRIGGER = 'trigger',
  EXECUTE = 'execute',
  PREVIEW = 'preview',
}

export enum GetActionEnum {
  DISCOVER = 'discover',
  HEALTH_CHECK = 'health-check',
  CODE = 'code',
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  enum
- export  enum

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/constants/api.constants.ts
Tamaño: 256 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export enum NovuApiEndpointsEnum {
  SYNC = '/v1/bridge/sync',
  DIFF = '/v1/bridge/diff',
}

export const SIGNATURE_TIMESTAMP_TOLERANCE_MINUTES = 5;
export const SIGNATURE_TIMESTAMP_TOLERANCE = SIGNATURE_TIMESTAMP_TOLERANCE_MINUTES * 60 * 5; // 5 minutes


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  enum
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/constants/cron.constants.ts
Tamaño: 3415 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/**
 * Cron expression helper.
 */
export enum CronExpression {
  EVERY_SECOND = '* * * * * *',
  EVERY_5_SECONDS = '*/5 * * * * *',
  EVERY_10_SECONDS = '*/10 * * * * *',
  EVERY_30_SECONDS = '*/30 * * * * *',
  EVERY_MINUTE = '*/1 * * * *',
  EVERY_5_MINUTES = '0 */5 * * * *',
  EVERY_10_MINUTES = '0 */10 * * * *',
  EVERY_30_MINUTES = '0 */30 * * * *',
  EVERY_HOUR = '0 0-23/1 * * *',
  EVERY_2_HOURS = '0 0-23/2 * * *',
  EVERY_3_HOURS = '0 0-23/3 * * *',
  EVERY_4_HOURS = '0 0-23/4 * * *',
  EVERY_5_HOURS = '0 0-23/5 * * *',
  EVERY_6_HOURS = '0 0-23/6 * * *',
  EVERY_7_HOURS = '0 0-23/7 * * *',
  EVERY_8_HOURS = '0 0-23/8 * * *',
  EVERY_9_HOURS = '0 0-23/9 * * *',
  EVERY_10_HOURS = '0 0-23/10 * * *',
  EVERY_11_HOURS = '0 0-23/11 * * *',
  EVERY_12_HOURS = '0 0-23/12 * * *',
  EVERY_DAY_AT_1AM = '0 01 * * *',
  EVERY_DAY_AT_2AM = '0 02 * * *',
  EVERY_DAY_AT_3AM = '0 03 * * *',
  EVERY_DAY_AT_4AM = '0 04 * * *',
  EVERY_DAY_AT_5AM = '0 05 * * *',
  EVERY_DAY_AT_6AM = '0 06 * * *',
  EVERY_DAY_AT_7AM = '0 07 * * *',
  EVERY_DAY_AT_8AM = '0 08 * * *',
  EVERY_DAY_AT_9AM = '0 09 * * *',
  EVERY_DAY_AT_10AM = '0 10 * * *',
  EVERY_DAY_AT_11AM = '0 11 * * *',
  EVERY_DAY_AT_NOON = '0 12 * * *',
  EVERY_DAY_AT_1PM = '0 13 * * *',
  EVERY_DAY_AT_2PM = '0 14 * * *',
  EVERY_DAY_AT_3PM = '0 15 * * *',
  EVERY_DAY_AT_4PM = '0 16 * * *',
  EVERY_DAY_AT_5PM = '0 17 * * *',
  EVERY_DAY_AT_6PM = '0 18 * * *',
  EVERY_DAY_AT_7PM = '0 19 * * *',
  EVERY_DAY_AT_8PM = '0 20 * * *',
  EVERY_DAY_AT_9PM = '0 21 * * *',
  EVERY_DAY_AT_10PM = '0 22 * * *',
  EVERY_DAY_AT_11PM = '0 23 * * *',
  EVERY_DAY_AT_MIDNIGHT = '0 0 * * *',
  EVERY_WEEK = '0 0 * * 0',
  EVERY_WEEKDAY = '0 0 * * 1-5',
  EVERY_WEEKEND = '0 0 * * 6,0',
  EVERY_1ST_DAY_OF_MONTH_AT_MIDNIGHT = '0 0 1 * *',
  EVERY_1ST_DAY_OF_MONTH_AT_NOON = '0 12 1 * *',
  EVERY_2ND_HOUR = '0 */2 * * *',
  EVERY_2ND_HOUR_FROM_1AM_THROUGH_11PM = '0 1-23/2 * * *',
  EVERY_2ND_MONTH = '0 0 1 */2 *',
  EVERY_QUARTER = '0 0 1 */3 *',
  EVERY_6_MONTHS = '0 0 1 */6 *',
  EVERY_YEAR = '0 0 1 0 *',
  EVERY_30_MINUTES_BETWEEN_9AM_AND_5PM = '0 */30 9-17 * * *',
  EVERY_30_MINUTES_BETWEEN_9AM_AND_6PM = '0 */30 9-18 * * *',
  EVERY_30_MINUTES_BETWEEN_10AM_AND_7PM = '0 */30 10-19 * * *',
  MONDAY_TO_FRIDAY_AT_1AM = '0 0 01 * * 1-5',
  MONDAY_TO_FRIDAY_AT_2AM = '0 0 02 * * 1-5',
  MONDAY_TO_FRIDAY_AT_3AM = '0 0 03 * * 1-5',
  MONDAY_TO_FRIDAY_AT_4AM = '0 0 04 * * 1-5',
  MONDAY_TO_FRIDAY_AT_5AM = '0 0 05 * * 1-5',
  MONDAY_TO_FRIDAY_AT_6AM = '0 0 06 * * 1-5',
  MONDAY_TO_FRIDAY_AT_7AM = '0 0 07 * * 1-5',
  MONDAY_TO_FRIDAY_AT_8AM = '0 0 08 * * 1-5',
  MONDAY_TO_FRIDAY_AT_9AM = '0 0 09 * * 1-5',
  MONDAY_TO_FRIDAY_AT_09_30AM = '0 30 09 * * 1-5',
  MONDAY_TO_FRIDAY_AT_10AM = '0 0 10 * * 1-5',
  MONDAY_TO_FRIDAY_AT_11AM = '0 0 11 * * 1-5',
  MONDAY_TO_FRIDAY_AT_11_30AM = '0 30 11 * * 1-5',
  MONDAY_TO_FRIDAY_AT_12PM = '0 0 12 * * 1-5',
  MONDAY_TO_FRIDAY_AT_1PM = '0 0 13 * * 1-5',
  MONDAY_TO_FRIDAY_AT_2PM = '0 0 14 * * 1-5',
  MONDAY_TO_FRIDAY_AT_3PM = '0 0 15 * * 1-5',
  MONDAY_TO_FRIDAY_AT_4PM = '0 0 16 * * 1-5',
  MONDAY_TO_FRIDAY_AT_5PM = '0 0 17 * * 1-5',
  MONDAY_TO_FRIDAY_AT_6PM = '0 0 18 * * 1-5',
  MONDAY_TO_FRIDAY_AT_7PM = '0 0 19 * * 1-5',
  MONDAY_TO_FRIDAY_AT_8PM = '0 0 20 * * 1-5',
  MONDAY_TO_FRIDAY_AT_9PM = '0 0 21 * * 1-5',
  MONDAY_TO_FRIDAY_AT_10PM = '0 0 22 * * 1-5',
  MONDAY_TO_FRIDAY_AT_11PM = '0 0 23 * * 1-5',
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  enum

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/constants/error.constants.ts
Tamaño: 1811 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { testErrorCodeEnumValidity } from '../types/error.types';

export enum ErrorCodeEnum {
  BRIDGE_ERROR = 'BridgeError',
  EXECUTION_EVENT_CONTROL_INVALID_ERROR = 'ExecutionEventControlInvalidError',
  EXECUTION_EVENT_PAYLOAD_INVALID_ERROR = 'ExecutionEventPayloadInvalidError',
  EXECUTION_PROVIDER_OUTPUT_INVALID_ERROR = 'ExecutionProviderOutputInvalidError',
  EXECUTION_STATE_CONTROL_INVALID_ERROR = 'ExecutionStateControlInvalidError',
  EXECUTION_STATE_CORRUPT_ERROR = 'ExecutionStateCorruptError',
  EXECUTION_STATE_OUTPUT_INVALID_ERROR = 'ExecutionStateOutputInvalidError',
  EXECUTION_STATE_RESULT_INVALID_ERROR = 'ExecutionStateResultInvalidError',
  INVALID_ACTION_ERROR = 'InvalidActionError',
  METHOD_NOT_ALLOWED_ERROR = 'MethodNotAllowedError',
  MISSING_DEPENDENCY_ERROR = 'MissingDependencyError',
  MISSING_SECRET_KEY_ERROR = 'MissingSecretKeyError',
  PROVIDER_EXECUTION_FAILED_ERROR = 'ProviderExecutionFailedError',
  PROVIDER_NOT_FOUND_ERROR = 'ProviderNotFoundError',
  SIGNATURE_EXPIRED_ERROR = 'SignatureExpiredError',
  SIGNATURE_INVALID_ERROR = 'SignatureInvalidError',
  SIGNATURE_MISMATCH_ERROR = 'SignatureMismatchError',
  SIGNATURE_NOT_FOUND_ERROR = 'SignatureNotFoundError',
  SIGNATURE_VERSION_INVALID_ERROR = 'SignatureVersionInvalidError',
  SIGNING_KEY_NOT_FOUND_ERROR = 'SigningKeyNotFoundError',
  STEP_ALREADY_EXISTS_ERROR = 'StepAlreadyExistsError',
  STEP_CONTROL_COMPILATION_FAILED_ERROR = 'StepControlCompilationFailedError',
  STEP_EXECUTION_FAILED_ERROR = 'StepExecutionFailedError',
  STEP_NOT_FOUND_ERROR = 'StepNotFoundError',
  WORKFLOW_ALREADY_EXISTS_ERROR = 'WorkflowAlreadyExistsError',
  WORKFLOW_NOT_FOUND_ERROR = 'WorkflowNotFoundError',
  WORKFLOW_PAYLOAD_INVALID_ERROR = 'WorkflowPayloadInvalidError',
}

testErrorCodeEnumValidity(ErrorCodeEnum);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  enum

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/constants/http-headers.constants.ts
Tamaño: 566 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export enum HttpHeaderKeysEnum {
  NOVU_SIGNATURE = 'novu-signature',
  NOVU_ANONYMOUS = 'novu-anonymous',
  NOVU_FRAMEWORK_SDK = 'novu-framework-sdk',
  NOVU_FRAMEWORK_SERVER = 'novu-framework-server',
  NOVU_FRAMEWORK_VERSION = 'novu-framework-version',
  USER_AGENT = 'user-agent',
  CONTENT_TYPE = 'content-type',
  ACCESS_CONTROL_ALLOW_ORIGIN = 'access-control-allow-origin',
  ACCESS_CONTROL_ALLOW_METHODS = 'access-control-allow-methods',
  ACCESS_CONTROL_ALLOW_HEADERS = 'access-control-allow-headers',
  ACCESS_CONTROL_MAX_AGE = 'access-control-max-age',
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  enum

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/constants/http-methods.constants.ts
Tamaño: 86 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export enum HttpMethodEnum {
  POST = 'POST',
  GET = 'GET',
  OPTIONS = 'OPTIONS',
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  enum

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/constants/http-query.constants.ts
Tamaño: 128 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export enum HttpQueryKeysEnum {
  WORKFLOW_ID = 'workflowId',
  STEP_ID = 'stepId',
  ACTION = 'action',
  SOURCE = 'source',
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  enum

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/constants/http-status.constants.ts
Tamaño: 1215 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export enum HttpStatusEnum {
  CONTINUE = 100,
  SWITCHING_PROTOCOLS = 101,
  PROCESSING = 102,
  EARLYHINTS = 103,
  OK = 200,
  CREATED = 201,
  ACCEPTED = 202,
  NON_AUTHORITATIVE_INFORMATION = 203,
  NO_CONTENT = 204,
  RESET_CONTENT = 205,
  PARTIAL_CONTENT = 206,
  AMBIGUOUS = 300,
  MOVED_PERMANENTLY = 301,
  FOUND = 302,
  SEE_OTHER = 303,
  NOT_MODIFIED = 304,
  TEMPORARY_REDIRECT = 307,
  PERMANENT_REDIRECT = 308,
  BAD_REQUEST = 400,
  UNAUTHORIZED = 401,
  PAYMENT_REQUIRED = 402,
  FORBIDDEN = 403,
  NOT_FOUND = 404,
  METHOD_NOT_ALLOWED = 405,
  NOT_ACCEPTABLE = 406,
  PROXY_AUTHENTICATION_REQUIRED = 407,
  REQUEST_TIMEOUT = 408,
  CONFLICT = 409,
  GONE = 410,
  LENGTH_REQUIRED = 411,
  PRECONDITION_FAILED = 412,
  PAYLOAD_TOO_LARGE = 413,
  URI_TOO_LONG = 414,
  UNSUPPORTED_MEDIA_TYPE = 415,
  REQUESTED_RANGE_NOT_SATISFIABLE = 416,
  EXPECTATION_FAILED = 417,
  I_AM_A_TEAPOT = 418,
  MISDIRECTED = 421,
  UNPROCESSABLE_ENTITY = 422,
  FAILED_DEPENDENCY = 424,
  PRECONDITION_REQUIRED = 428,
  TOO_MANY_REQUESTS = 429,
  INTERNAL_SERVER_ERROR = 500,
  NOT_IMPLEMENTED = 501,
  BAD_GATEWAY = 502,
  SERVICE_UNAVAILABLE = 503,
  GATEWAY_TIMEOUT = 504,
  HTTP_VERSION_NOT_SUPPORTED = 505,
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  enum

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/constants/index.ts
Tamaño: 413 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './action.constants';
export * from './api.constants';
export * from './cron.constants';
export * from './error.constants';
export * from './http-headers.constants';
export * from './http-methods.constants';
export * from './http-query.constants';
export * from './http-status.constants';
export * from './resource.constants';
export * from './step.constants';
export * from './workflow.constants';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/constants/resource.constants.ts
Tamaño: 96 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export enum ResourceEnum {
  WORKFLOW = 'workflow',
  PROVIDER = 'provider',
  STEP = 'step',
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  enum

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/constants/step.constants.ts
Tamaño: 239 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export enum ChannelStepEnum {
  EMAIL = 'email',
  SMS = 'sms',
  PUSH = 'push',
  CHAT = 'chat',
  IN_APP = 'in_app',
}

export enum ActionStepEnum {
  DIGEST = 'digest',
  DELAY = 'delay',
  THROTTLE = 'throttle',
  CUSTOM = 'custom',
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  enum
- export  enum

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/constants/workflow.constants.ts
Tamaño: 349 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/**
 * A developer-friendly variant of ChannelTypeEnum, utilizing camelCase instead of snake_case
 * to use consistent casing throughout the Framework.
 */
export enum WorkflowChannelEnum {
  EMAIL = 'email',
  SMS = 'sms',
  PUSH = 'push',
  CHAT = 'chat',
  /** Differs from ChannelTypeEnum in capitalization / snake_case */
  IN_APP = 'inApp',
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  enum

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/errors/base.errors.ts
Tamaño: 2204 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { HttpStatusEnum } from '../constants';
import { ErrorCodeEnum } from '../constants/error.constants';

/**
 * Check if the object is a native error.
 *
 * This method relies on `Object.prototype.toString()` behavior. It is possible to obtain
 * an incorrect result when the object argument has a non `Error`-suffixed `name` property.
 *
 * @param object - The object to check.
 * @returns `true` if the object is a native error, `false` otherwise.
 */
export const isNativeError = (object: unknown): object is Error => {
  if (typeof object !== 'object' || object === null) {
    return false;
  }

  const proto = Object.getPrototypeOf(object);

  return proto?.constructor?.name.endsWith('Error') ?? false;
};

/**
 * Base error class.
 */
export abstract class FrameworkError extends Error {
  /**
   * HTTP status code.
   */
  public abstract readonly statusCode: HttpStatusEnum;

  /**
   * Additional data that can be used to provide more information about the error.
   */
  public data?: unknown;

  /**
   * The error code, which is used to identify the error type.
   */
  public abstract readonly code: ErrorCodeEnum;
}

export abstract class NotFoundError extends FrameworkError {
  statusCode = HttpStatusEnum.NOT_FOUND;
}

export abstract class BadRequestError extends FrameworkError {
  statusCode = HttpStatusEnum.BAD_REQUEST;
}

export abstract class UnauthorizedError extends FrameworkError {
  statusCode = HttpStatusEnum.UNAUTHORIZED;
}

export abstract class ServerError extends FrameworkError {
  data: {
    /**
     * The stack trace of the error.
     */
    stack: string;
  };

  constructor(message: string, { cause }: Partial<{ cause: unknown }> = {}) {
    if (isNativeError(cause)) {
      super(`${message}: ${cause.message}`);
      this.data = {
        stack: cause.stack ?? message,
      };
    } else {
      super(`${message}${cause ? `: ${JSON.stringify(cause, null, 2)}` : ''}`);
      this.data = {
        stack: message,
      };
    }
  }
}

export abstract class ConflictError extends FrameworkError {
  statusCode = HttpStatusEnum.CONFLICT;
}

export abstract class ForbiddenError extends FrameworkError {
  statusCode = HttpStatusEnum.FORBIDDEN;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - isNativeError(object: unknown): object is Error)
Declaraciones 'export' encontradas:
- export  const
- export  abstract
- export  abstract
- export  abstract
- export  abstract
- export  abstract
- export  abstract
- export  abstract

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/errors/bridge.errors.ts
Tamaño: 571 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ErrorCodeEnum, HttpStatusEnum } from '../constants';
import { ServerError } from './base.errors';

/**
 * A `BridgeError` is an unexpected error that occurs within the Bridge application.
 *
 * This error is used to wrap unknown errors that occur within the Bridge application,
 * such as errors due to unsupported runtime environments.
 */
export class BridgeError extends ServerError {
  statusCode = HttpStatusEnum.INTERNAL_SERVER_ERROR;
  code = ErrorCodeEnum.BRIDGE_ERROR;

  constructor(cause: unknown) {
    super(`Unknown BridgeError`, { cause });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class BridgeError

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/errors/execution.errors.ts
Tamaño: 3538 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ErrorCodeEnum } from '../constants';
import { BadRequestError } from './base.errors';

export class ExecutionStateCorruptError extends BadRequestError {
  code = ErrorCodeEnum.EXECUTION_STATE_CORRUPT_ERROR;

  constructor(workflowId: string, stepId: string) {
    super(
      `Workflow with id: \`${workflowId}\` has a corrupt state. Step with id: \`${stepId}\` does not exist. Please provide the missing state.`
    );
    this.data = { workflowId, stepId };
  }
}

export class ExecutionEventPayloadInvalidError extends BadRequestError {
  code = ErrorCodeEnum.EXECUTION_EVENT_PAYLOAD_INVALID_ERROR;

  constructor(workflowId: string, data: unknown) {
    super(`Workflow with id: \`${workflowId}\` has invalid \`payload\`. Please provide the correct event payload.`);
    this.data = data;
  }
}

export class ExecutionEventControlsInvalidError extends BadRequestError {
  code = ErrorCodeEnum.EXECUTION_EVENT_CONTROL_INVALID_ERROR;

  constructor(workflowId: string, data: unknown) {
    super(`Workflow with id: \`${workflowId}\` has invalid \`controls\`. Please provide the correct event controls.`);
    this.data = data;
  }
}

export class ExecutionStateControlsInvalidError extends BadRequestError {
  code = ErrorCodeEnum.EXECUTION_STATE_CONTROL_INVALID_ERROR;

  constructor(workflowId: string, stepId: string, data: unknown) {
    super(
      `Workflow with id: \`${workflowId}\` has an invalid state. Step with id: \`${stepId}\` has invalid \`controls\`. Please provide the correct step controls.`
    );
    this.data = data;
  }
}

export class ExecutionStateOutputInvalidError extends BadRequestError {
  code = ErrorCodeEnum.EXECUTION_STATE_OUTPUT_INVALID_ERROR;

  constructor(workflowId: string, stepId: string, data: unknown) {
    super(
      `Workflow with id: \`${workflowId}\` has an invalid state. Step with id: \`${stepId}\` has invalid output. Please provide the correct step output.`
    );
    this.data = data;
  }
}

export class ExecutionStateResultInvalidError extends BadRequestError {
  code = ErrorCodeEnum.EXECUTION_STATE_RESULT_INVALID_ERROR;

  constructor(workflowId: string, stepId: string, data: unknown) {
    super(
      `Workflow with id: \`${workflowId}\` has an invalid state. Step with id: \`${stepId}\` has invalid result. Please provide the correct step result.`
    );
    this.data = data;
  }
}

export class StepControlCompilationFailedError extends BadRequestError {
  code = ErrorCodeEnum.STEP_CONTROL_COMPILATION_FAILED_ERROR;

  constructor(workflowId: string, stepId: string, data: unknown) {
    super(
      `Workflow with id: \`${workflowId}\` has invalid controls syntax in step with id: \`${stepId}\`. Please correct step control syntax.`
    );
    this.data = data;
  }
}

export class ExecutionProviderOutputInvalidError extends BadRequestError {
  code = ErrorCodeEnum.EXECUTION_PROVIDER_OUTPUT_INVALID_ERROR;

  constructor(workflowId: string, stepId: string, providerId: string, data: unknown) {
    super(
      `Workflow with id: \`${workflowId}\` has an invalid state. Step with id: \`${stepId}\` and provider with id: \`${providerId}\` has invalid output. Please provide the correct provider output.`
    );
    this.data = data;
  }
}

export class WorkflowPayloadInvalidError extends BadRequestError {
  code = ErrorCodeEnum.WORKFLOW_PAYLOAD_INVALID_ERROR;

  constructor(workflowId: string, data: unknown) {
    super(`Workflow with id: \`${workflowId}\` has invalid \`payload\`. Please provide the correct payload.`);
    this.data = data;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ExecutionStateCorruptError
- export class ExecutionEventPayloadInvalidError
- export class ExecutionEventControlsInvalidError
- export class ExecutionStateControlsInvalidError
- export class ExecutionStateOutputInvalidError
- export class ExecutionStateResultInvalidError
- export class StepControlCompilationFailedError
- export class ExecutionProviderOutputInvalidError
- export class WorkflowPayloadInvalidError

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/errors/guard.errors.test.ts
Tamaño: 2291 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { describe, expect, it } from 'vitest';
import { ErrorCodeEnum, HttpStatusEnum } from '../constants';
import { FrameworkError, isNativeError } from './base.errors';
import { BridgeError } from './bridge.errors';
import { isFrameworkError, isPlatformError } from './guard.errors';
import { PlatformError } from './platform.errors';

class TestFrameworkError extends FrameworkError {
  statusCode = HttpStatusEnum.BAD_REQUEST;
  code = ErrorCodeEnum.WORKFLOW_NOT_FOUND_ERROR;
}

describe('error utils', () => {
  describe('isNativeError', () => {
    it('should return true for native errors', () => {
      expect(isNativeError(new Error('Test error'))).toBe(true);
    });

    it('should return true for framework errors', () => {
      expect(isNativeError(new TestFrameworkError('Unable to find the workflow'))).toBe(true);
    });

    const falseCases = [{}, null, undefined, 'Test error', 123, true, [], () => {}, Symbol('test')];

    falseCases.forEach((value) => {
      it(`should return false for ${typeof value}`, () => {
        expect(isNativeError(value)).toBe(false);
      });
    });
  });

  describe('isFrameworkError', () => {
    it('should return true for framework errors', () => {
      expect(isFrameworkError(new TestFrameworkError('Unable to find the workflow'))).toBe(true);
    });

    it('should return false for platform errors', () => {
      expect(isFrameworkError(new PlatformError(HttpStatusEnum.BAD_REQUEST, 'BAD_REQUEST', 'Workflow not found'))).toBe(
        false
      );
    });

    it('should return true for bridge errors', () => {
      expect(isFrameworkError(new BridgeError('Unable to find the runtime environment'))).toBe(true);
    });
  });

  describe('isPlatformError', () => {
    it('should return true for platform errors', () => {
      expect(isPlatformError(new PlatformError(HttpStatusEnum.BAD_REQUEST, 'BAD_REQUEST', 'Workflow not found'))).toBe(
        true
      );
    });

    it('should return false for framework errors', () => {
      expect(isPlatformError(new TestFrameworkError('Unable to find the workflow'))).toBe(false);
    });

    it('should return false for bridge errors', () => {
      expect(isPlatformError(new BridgeError('Unable to find the runtime environment'))).toBe(false);
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - code(ErrorCodeEnum.WORKFLOW_NOT_FOUND_ERROR;
}

describe('error utils', ())
 - falseCases([{}, null, undefined, 'Test error', 123, true, [], ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/errors/guard.errors.ts
Tamaño: 1149 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ErrorCodeEnum } from '../constants';
import { FrameworkError } from './base.errors';
import { PlatformError } from './platform.errors';

/**
 * Check if the error is a `FrameworkError`.
 *
 * A `FrameworkError` is an error thrown by the Framework.
 *
 * @param error - The error to check.
 * @returns `true` if the error is a `FrameworkError`, `false` otherwise.
 */
export const isFrameworkError = (error: unknown): error is FrameworkError => {
  return Object.values(ErrorCodeEnum).includes((error as FrameworkError)?.code as ErrorCodeEnum);
};

/**
 * Check if the error is a `PlatformError`.
 *
 * A `PlatformError` is a server error that is thrown by the Platform,
 * where the Bridge application acts as a proxy to the Platform.
 *
 * @param error - The error to check.
 * @returns `true` if the error is a `PlatformError`, `false` otherwise.
 */
export const isPlatformError = (error: unknown): error is PlatformError => {
  return (
    !isFrameworkError(error) &&
    typeof (error as PlatformError).statusCode === 'number' &&
    (error as PlatformError).statusCode >= 400 &&
    (error as PlatformError).statusCode < 500
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - isFrameworkError(error: unknown): error is FrameworkError)
 - isPlatformError(error: unknown): error is PlatformError)
Declaraciones 'export' encontradas:
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/errors/handler.errors.ts
Tamaño: 1015 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ErrorCodeEnum, HttpMethodEnum, HttpStatusEnum } from '../constants';
import { enumToPrettyString } from '../utils/string.utils';
import { BadRequestError, FrameworkError } from './base.errors';

export class MethodNotAllowedError extends FrameworkError {
  code = ErrorCodeEnum.METHOD_NOT_ALLOWED_ERROR;

  statusCode = HttpStatusEnum.METHOD_NOT_ALLOWED;

  message = `Method not allowed. Please use one of ${enumToPrettyString(HttpMethodEnum)}`;
}

export class InvalidActionError extends BadRequestError {
  code = ErrorCodeEnum.INVALID_ACTION_ERROR;

  constructor(action: string, allowedActions: Object) {
    super(`Invalid query string: \`action\`=\`${action}\`. Please use one of ${enumToPrettyString(allowedActions)}`);
  }
}

export class MissingSecretKeyError extends BadRequestError {
  code = ErrorCodeEnum.MISSING_SECRET_KEY_ERROR;

  constructor() {
    super(
      'Missing secret key. Set the `NOVU_SECRET_KEY` environment variable or pass `secretKey` to the client options.'
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class MethodNotAllowedError
- export class InvalidActionError
- export class MissingSecretKeyError

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/errors/import.errors.ts
Tamaño: 644 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ErrorCodeEnum, HttpStatusEnum } from '../constants';
import { ServerError } from './base.errors';

export class MissingDependencyError extends ServerError {
  statusCode = HttpStatusEnum.INTERNAL_SERVER_ERROR;
  code = ErrorCodeEnum.MISSING_DEPENDENCY_ERROR;

  constructor(usageReason: string, missingDependencies: string[]) {
    const pronoun = missingDependencies.length === 1 ? 'it' : 'them';
    super(
      `Tried to use a ${usageReason} in @novu/framework without ${missingDependencies.join(
        ', '
      )} installed. Please install ${pronoun} by running \`npm install ${missingDependencies.join(' ')}\`.`
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class MissingDependencyError

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/errors/index.ts
Tamaño: 392 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './base.errors';
export * from './bridge.errors';
export * from './execution.errors';
export { isFrameworkError } from './guard.errors';
export * from './handler.errors';
export * from './platform.errors';
export * from './provider.errors';
export * from './resource.errors';
export * from './signature.errors';
export * from './step.errors';
export * from './workflow.errors';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/errors/platform.errors.ts
Tamaño: 579 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ErrorCodeEnum, HttpStatusEnum } from '../constants';

export class PlatformError extends Error {
  /**
   * HTTP status code.
   */
  public statusCode: HttpStatusEnum;

  /**
   * Additional data that can be used to provide more information about the error.
   */
  public data: unknown;

  public code: ErrorCodeEnum;

  constructor(statusCode: HttpStatusEnum, code: string, message: string) {
    super();
    this.data = { message };
    this.statusCode = statusCode;
    this.code = code as ErrorCodeEnum; // TODO: replace with ErrorCode types from Platform.
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class PlatformError

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/errors/provider.errors.ts
Tamaño: 611 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ErrorCodeEnum, PostActionEnum, ResourceEnum } from '../constants';
import { ResourceExecutionFailed, ResourceNotFoundError } from './resource.errors';

export class ProviderNotFoundError extends ResourceNotFoundError {
  code = ErrorCodeEnum.PROVIDER_NOT_FOUND_ERROR;

  constructor(id: string) {
    super(ResourceEnum.PROVIDER, id);
  }
}

export class ProviderExecutionFailedError extends ResourceExecutionFailed {
  code = ErrorCodeEnum.PROVIDER_EXECUTION_FAILED_ERROR;

  constructor(id: string, action: PostActionEnum, cause: unknown) {
    super(ResourceEnum.PROVIDER, id, action, cause);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ProviderNotFoundError
- export class ProviderExecutionFailedError

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/errors/resource.errors.ts
Tamaño: 964 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { HttpStatusEnum, PostActionEnum, ResourceEnum } from '../constants';
import { toPascalCase } from '../utils/string.utils';
import { ConflictError, NotFoundError, ServerError } from './base.errors';

export abstract class ResourceConflictError extends ConflictError {
  constructor(resource: ResourceEnum, id: string) {
    super(`${toPascalCase(resource)} with id: \`${id}\` already exists. Please use a different id.`);
  }
}

export abstract class ResourceNotFoundError extends NotFoundError {
  constructor(resource: ResourceEnum, id: string) {
    super(`${toPascalCase(resource)} with id: \`${id}\` does not exist. Please provide a valid id.`);
  }
}

export abstract class ResourceExecutionFailed extends ServerError {
  statusCode = HttpStatusEnum.BAD_GATEWAY;
  constructor(resource: ResourceEnum, id: string, action: PostActionEnum, cause: unknown) {
    super(`Failed to ${action} ${toPascalCase(resource)} with id: \`${id}\``, { cause });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  abstract
- export  abstract
- export  abstract

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/errors/signature.errors.ts
Tamaño: 1934 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ErrorCodeEnum, HttpHeaderKeysEnum, SIGNATURE_TIMESTAMP_TOLERANCE_MINUTES } from '../constants';
import { UnauthorizedError } from './base.errors';

export class SignatureMismatchError extends UnauthorizedError {
  code = ErrorCodeEnum.SIGNATURE_MISMATCH_ERROR;

  constructor() {
    super(
      `Signature does not match the expected signature. Please ensure the signature provided in the \`${HttpHeaderKeysEnum.NOVU_SIGNATURE}\` header is correct and try again.`
    );
  }
}

export class SignatureNotFoundError extends UnauthorizedError {
  code = ErrorCodeEnum.SIGNATURE_NOT_FOUND_ERROR;

  constructor() {
    super(`Signature not found. Please provide a signature in the \`${HttpHeaderKeysEnum.NOVU_SIGNATURE}\` header`);
  }
}

export class SignatureInvalidError extends UnauthorizedError {
  code = ErrorCodeEnum.SIGNATURE_INVALID_ERROR;

  constructor() {
    super(
      `Signature is invalid. Please provide a valid signature in the \`${HttpHeaderKeysEnum.NOVU_SIGNATURE}\` header`
    );
  }
}

export class SignatureExpiredError extends UnauthorizedError {
  code = ErrorCodeEnum.SIGNATURE_EXPIRED_ERROR;

  constructor() {
    super(
      `Signature expired. Please provide a signature with a timestamp no older than ${SIGNATURE_TIMESTAMP_TOLERANCE_MINUTES} minutes in the \`${HttpHeaderKeysEnum.NOVU_SIGNATURE}\` header`
    );
  }
}

export class SigningKeyNotFoundError extends UnauthorizedError {
  code = ErrorCodeEnum.SIGNING_KEY_NOT_FOUND_ERROR;

  constructor() {
    super('Signature key not found. Please provide a valid key in the Client constructor `config.secretKey`');
  }
}

export class SignatureVersionInvalidError extends UnauthorizedError {
  code = ErrorCodeEnum.SIGNATURE_VERSION_INVALID_ERROR;

  constructor() {
    super(
      `Signature version is invalid. Please provide a signature version with version \`v1\` in the \`${HttpHeaderKeysEnum.NOVU_SIGNATURE}\` header`
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SignatureMismatchError
- export class SignatureNotFoundError
- export class SignatureInvalidError
- export class SignatureExpiredError
- export class SigningKeyNotFoundError
- export class SignatureVersionInvalidError

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/errors/step.errors.ts
Tamaño: 798 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ErrorCodeEnum, PostActionEnum, ResourceEnum } from '../constants';
import { ResourceConflictError, ResourceExecutionFailed, ResourceNotFoundError } from './resource.errors';

export class StepNotFoundError extends ResourceNotFoundError {
  code = ErrorCodeEnum.STEP_NOT_FOUND_ERROR;

  constructor(id: string) {
    super(ResourceEnum.STEP, id);
  }
}

export class StepAlreadyExistsError extends ResourceConflictError {
  code = ErrorCodeEnum.STEP_ALREADY_EXISTS_ERROR;

  constructor(id: string) {
    super(ResourceEnum.STEP, id);
  }
}

export class StepExecutionFailedError extends ResourceExecutionFailed {
  code = ErrorCodeEnum.STEP_EXECUTION_FAILED_ERROR;

  constructor(id: string, action: PostActionEnum, cause: unknown) {
    super(ResourceEnum.STEP, id, action, cause);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class StepNotFoundError
- export class StepAlreadyExistsError
- export class StepExecutionFailedError

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/errors/workflow.errors.ts
Tamaño: 532 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ErrorCodeEnum, ResourceEnum } from '../constants';
import { ResourceConflictError, ResourceNotFoundError } from './resource.errors';

export class WorkflowNotFoundError extends ResourceNotFoundError {
  code = ErrorCodeEnum.WORKFLOW_NOT_FOUND_ERROR;

  constructor(id: string) {
    super(ResourceEnum.WORKFLOW, id);
  }
}

export class WorkflowAlreadyExistsError extends ResourceConflictError {
  code = ErrorCodeEnum.WORKFLOW_ALREADY_EXISTS_ERROR;

  constructor(id: string) {
    super(ResourceEnum.WORKFLOW, id);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class WorkflowNotFoundError
- export class WorkflowAlreadyExistsError

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/filters/digest.ts
Tamaño: 1778 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { getNestedValue } from '../utils/object.utils';

type NestedObject = Record<string, unknown>;

/**
 * Format a list of items for digest notifications with configurable behavior
 * Default formatting:
 * - 1 item: "John"
 * - 2 items: "John and Josh"
 * - 3 items: "John, Josh and Sarah"
 * - 4+ items: "John, Josh and 2 others"
 *
 * @param array The array of items to format
 * @param maxNames Maximum names to show before using "others"
 * @param keyPath Path to extract from objects (e.g., "name" or "profile.name")
 * @param separator Custom separator between names (default: ", ")
 * @returns Formatted string
 *
 * Examples:
 * {{ actors | digest }} => "John, Josh and 2 others"
 * {{ actors | digest: 2 }} => "John, Josh and 3 others"
 * {{ users | digest: 2, "name" }} => For array of {name: string}
 * {{ users | digest: 2, "profile.name", "•" }} => "John • Josh and 3 others"
 */
export function digest(array: unknown, maxNames = 2, keyPath?: string, separator = ', '): string {
  if (!Array.isArray(array) || array.length === 0) return '';

  const values = keyPath
    ? array.map((item) => {
        if (typeof item !== 'object' || !item) return '';

        return getNestedValue(item as NestedObject, keyPath);
      })
    : array;

  if (values.length === 1) return values[0];
  if (values.length === 2) return `${values[0]} and ${values[1]}`;

  if (values.length === 3 && maxNames >= 3) {
    return `${values[0]}, ${separator}${values[1]} and ${values[2]}`;
  }

  // Use "others" format for 4+ items or when maxNames is less than array length
  const shownItems = values.slice(0, maxNames);
  const othersCount = values.length - maxNames;

  return `${shownItems.join(separator)} and ${othersCount} ${othersCount === 1 ? 'other' : 'others'}`;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - digest(array: unknown, maxNames = 2, keyPath?: string, separator = ', ')
Asignaciones con arrow functions encontradas (posibles funciones):
 - NestedObject(Record<string, unknown>;

/**
 * Format a list of items for digest notifications with configurable b...)
 - values(keyPath
    ? array.map((item))
Declaraciones 'export' encontradas:
- export function digest

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/filters/index.ts
Tamaño: 141 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './digest';
export * from './pluralize';
export * from './to-sentence';
export * from './types';
export * from './validators';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/filters/pluralize.test.ts
Tamaño: 5391 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { describe, expect, it } from 'vitest';
import { pluralize } from './pluralize';

describe('pluralize', () => {
  it('should return empty string for falsy values', () => {
    expect(pluralize(null)).toBe('');
    expect(pluralize(undefined)).toBe('');
  });

  it('should handle arrays and count their length', () => {
    expect(pluralize([], 'item')).toBe('');
    expect(pluralize(['a'], 'item')).toBe('1 item');
    expect(pluralize(['a', 'b'], 'item')).toBe('2 items');
    expect(pluralize(['a', 'b', 'c'], 'item')).toBe('3 items');
  });

  it('should handle objects and count their keys', () => {
    expect(pluralize({}, 'property')).toBe('');
    expect(pluralize({ a: 1 }, 'property')).toBe('1 property');
    expect(pluralize({ a: 1, b: 2 }, 'property')).toBe('2 properties');
  });

  it('should convert string numbers to numeric values', () => {
    expect(pluralize('0', 'item')).toBe('');
    expect(pluralize('1', 'item')).toBe('1 item');
    expect(pluralize('2', 'item')).toBe('2 items');
    expect(pluralize('10', 'item')).toBe('10 items');
    expect(pluralize('asdf', 'item')).toBe('');
  });

  it('should handle numeric values directly', () => {
    expect(pluralize(0, 'item')).toBe('');
    expect(pluralize(1, 'item')).toBe('1 item');
    expect(pluralize(2, 'item')).toBe('2 items');
    expect(pluralize(10, 'item')).toBe('10 items');
  });

  it('should handle other values by converting them to numbers', () => {
    expect(pluralize(true, 'item')).toBe('1 item');
    expect(pluralize(false, 'item')).toBe('');
  });

  it('should handle NaN values by returning empty string', () => {
    expect(pluralize(NaN, 'item')).toBe('');
  });

  it('should handle custom plural forms when provided', () => {
    expect(pluralize(0, 'child', 'children')).toBe('');
    expect(pluralize(1, 'child', 'children')).toBe('1 child');
    expect(pluralize(2, 'child', 'children')).toBe('2 children');

    expect(pluralize(0, 'person', 'people')).toBe('');
    expect(pluralize(1, 'person', 'people')).toBe('1 person');
    expect(pluralize(2, 'person', 'people')).toBe('2 people');
  });

  it('should use plur library for automatic pluralization when no custom plural is provided', () => {
    // Regular pluralization (adding 's')
    expect(pluralize(0, 'apple')).toBe('');
    expect(pluralize(1, 'apple')).toBe('1 apple');
    expect(pluralize(2, 'apple')).toBe('2 apples');

    // Words ending in 'y'
    expect(pluralize(0, 'berry')).toBe('');
    expect(pluralize(1, 'berry')).toBe('1 berry');
    expect(pluralize(2, 'berry')).toBe('2 berries');

    // Words ending in 'f' or 'fe'
    expect(pluralize(0, 'leaf')).toBe('');
    expect(pluralize(1, 'leaf')).toBe('1 leaf');
    expect(pluralize(2, 'leaf')).toBe('2 leaves');

    // Irregular plurals
    expect(pluralize(0, 'child')).toBe('');
    expect(pluralize(1, 'child')).toBe('1 child');
    expect(pluralize(2, 'child')).toBe('2 children');

    expect(pluralize(0, 'person')).toBe('');
    expect(pluralize(1, 'person')).toBe('1 person');
    expect(pluralize(2, 'person')).toBe('2 people');
  });

  it('should handle decimal numbers', () => {
    expect(pluralize(1.5, 'apple')).toBe('1.5 apples');
    expect(pluralize(0.5, 'portion')).toBe('0.5 portions');
  });

  it('should handle negative numbers by returning empty string', () => {
    expect(pluralize(-1, 'item')).toBe('');
    expect(pluralize(-2, 'item')).toBe('');
  });

  it('should return empty string for count <= 0', () => {
    expect(pluralize(0, 'item')).toBe('');
    expect(pluralize(-1, 'item')).toBe('');
    expect(pluralize(-10, 'item')).toBe('');
    expect(pluralize('0', 'item')).toBe('');
    expect(pluralize('-5', 'item')).toBe('');
    expect(pluralize([], 'item')).toBe('');
    expect(pluralize({}, 'property')).toBe('');
    expect(pluralize(false, 'item')).toBe('');
    expect(pluralize(NaN, 'item')).toBe('');
    expect(pluralize('invalid', 'item')).toBe('');
  });

  it('should support hiding count when showCount is false', () => {
    expect(pluralize(1, 'item', '', 'false')).toBe('item');
    expect(pluralize(2, 'item', '', 'false')).toBe('items');
    expect(pluralize(1, 'child', 'children', 'false')).toBe('child');
    expect(pluralize(2, 'child', 'children', 'false')).toBe('children');
    expect(pluralize(1, 'apple', '', 'false')).toBe('apple');
    expect(pluralize(2, 'apple', '', 'false')).toBe('apples');
  });

  it('should show count by default when showCount is not specified', () => {
    expect(pluralize(1, 'item')).toBe('1 item');
    expect(pluralize(2, 'item')).toBe('2 items');
    expect(pluralize(1, 'child', 'children')).toBe('1 child');
    expect(pluralize(2, 'child', 'children')).toBe('2 children');
  });

  it('should show count when showCount is explicitly true', () => {
    expect(pluralize(1, 'item', '', 'true')).toBe('1 item');
    expect(pluralize(2, 'item', '', 'true')).toBe('2 items');
    expect(pluralize(1, 'child', 'children', 'true')).toBe('1 child');
    expect(pluralize(2, 'child', 'children', 'true')).toBe('2 children');
  });

  it('should return empty string for count <= 0 regardless of showCount', () => {
    expect(pluralize(0, 'item', '', 'false')).toBe('');
    expect(pluralize(-1, 'item', '', 'false')).toBe('');
    expect(pluralize(0, 'item', '', 'true')).toBe('');
    expect(pluralize(-1, 'item', '', 'true')).toBe('');
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

No se detectaron funciones/exportaciones con heurística JS/TS.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/filters/pluralize.ts
Tamaño: 1345 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import plur from 'pluralize';

/**
 * Creates a pluralized string based on the count of the item.
 * Example:
 * - 0, "event" -> ""
 * - 1, "event" -> 1 event
 * - 2, "event" -> 2 events
 * - 1, "event", "", false -> event
 * - 2, "event", "", false -> events
 *
 * @param item The item to pluralize
 * @param singular The singular form of the word
 * @param plural The plural form of the word
 * @param showCount Whether to include the count in the output (default: true)
 */
export function pluralize(
  item: unknown,
  singular: string = '',
  plural: string = '',
  showCount: 'true' | 'false' = 'true'
): string {
  if (item === null || item === undefined) {
    return '';
  }

  let count = 0;
  if (Array.isArray(item)) {
    count = item.length;
  } else if (typeof item === 'object') {
    count = Object.keys(item).length;
  } else if (typeof item === 'string') {
    count = +item;
  } else if (typeof item === 'number') {
    count = item;
  } else {
    count = Number(item);
  }

  if (Number.isNaN(count)) {
    count = 0;
  }

  if (count <= 0) {
    return '';
  }

  let word: string;
  if (plural) {
    word = count === 1 ? singular : plural;
  } else {
    // if no plural is provided we assume the english language rules
    word = plur(singular, count);
  }

  return showCount === 'true' ? `${count} ${word}` : word;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - pluralize(item: unknown,
  singular: string = '',
  plural: string = '',
  showCount: 'true' | 'false' = 'true')
Declaraciones 'export' encontradas:
- export function pluralize

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/filters/to-sentence.test.ts
Tamaño: 2932 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { describe, expect, it } from 'vitest';
import { toSentence } from './to-sentence';

describe('toSentence', () => {
  it('should return empty string for empty array', () => {
    expect(toSentence([])).toBe('');
  });

  it('should return empty string for non-array input', () => {
    expect(toSentence('not an array')).toBe('');
    expect(toSentence(null)).toBe('');
    expect(toSentence(undefined)).toBe('');
    expect(toSentence(123)).toBe('');
    expect(toSentence({})).toBe('');
  });

  it('should handle single item arrays', () => {
    expect(toSentence(['John'])).toBe('John');
  });

  it('should format two items with default connector', () => {
    expect(toSentence(['John', 'Josh'])).toBe('John and Josh');
  });

  it('should format three items with limit of 3 or more', () => {
    expect(toSentence(['John', 'Josh', 'Sarah'], '', 3)).toBe('John, Josh, and Sarah');
  });

  it('should use overflow suffix for arrays longer than the limit', () => {
    expect(toSentence(['John', 'Josh', 'Sarah', 'Alex'])).toBe('John, Josh, and 2 others');
    expect(toSentence(['John', 'Josh', 'Sarah', 'Alex', 'Emma'])).toBe('John, Josh, and 3 others');
  });

  it('should pluralize overflow suffix correctly', () => {
    expect(toSentence(['John', 'Josh', 'Sarah'], '', 2, 'other')).toBe('John, Josh, and 1 other');
    expect(toSentence(['John', 'Josh', 'Sarah', 'Alex'], '', 2, 'other')).toBe('John, Josh, and 2 others');
  });

  it('should use custom connectors when provided', () => {
    expect(toSentence(['John', 'Josh'], '', 2, 'other', ' + ', ' or ', ' & ')).toBe('John or Josh');
    expect(toSentence(['John', 'Josh', 'Sarah'], '', 2, 'other', ' + ', ' or ', ' & ')).toBe('John + Josh & 1 other');
  });

  it('should handle object arrays with keyPath', () => {
    const users = [
      { name: 'John', id: 1 },
      { name: 'Josh', id: 2 },
      { name: 'Sarah', id: 3 },
    ];

    expect(toSentence(users, 'name', 3)).toBe('John, Josh, and Sarah');
    expect(toSentence(users, 'id', 3)).toBe('1, 2, and 3');
  });

  it('should handle nested object properties via keyPath', () => {
    const users = [
      { profile: { name: 'John' }, id: 1 },
      { profile: { name: 'Josh' }, id: 2 },
      { profile: { name: 'Sarah' }, id: 3 },
    ];

    expect(toSentence(users, 'profile.name', 3)).toBe('John, Josh, and Sarah');
  });

  it('should return empty strings for invalid object properties', () => {
    const users = [{ name: 'John' }, { name: null }, { noName: 'Sarah' }];

    expect(toSentence(users, 'name', 3)).toBe('John, , and ');
  });

  it('should handle custom limit values', () => {
    const names = ['John', 'Josh', 'Sarah', 'Alex', 'Emma'];

    expect(toSentence(names, '', 1)).toBe('John and 4 others');
    expect(toSentence(names, '', 3)).toBe('John, Josh, Sarah, and 2 others');
    expect(toSentence(names, '', 5)).toBe('John, Josh, Sarah, Alex, and Emma');
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - users([
      { name: 'John', id: 1 },
      { name: 'Josh', id: 2 },
      { name: 'Sarah', id: 3 },
    ...)
 - users([
      { profile: { name: 'John' }, id: 1 },
      { profile: { name: 'Josh' }, id: 2 },
      { pr...)
 - users([{ name: 'John' }, { name: null }, { noName: 'Sarah' }];

    expect(toSentence(users, 'name', 3)).t...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/filters/to-sentence.ts
Tamaño: 5509 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Filter, TokenKind } from 'liquidjs';
import { NumberToken, QuotedToken } from 'liquidjs/dist/tokens';
import pluralize from 'pluralize';
import { z } from 'zod';
import { getNestedValue } from '../utils/object.utils';
import { LiquidFilterIssue } from './types';

const DEFAULT_KEY_PATH = '';
const DEFAULT_LIMIT = 2;
const DEFAULT_OVERFLOW_SUFFIX = 'other';
const DEFAULT_WORDS_CONNECTOR = ', ';
const DEFAULT_TWO_WORDS_CONNECTOR = ' and ';
const DEFAULT_LAST_WORD_CONNECTOR = ', and ';

const ARG_INDEX_TO_ARG_NAME: Record<number, string> = {
  0: 'keyPath',
  1: 'limit',
  2: 'overflowSuffix',
  3: 'wordsConnector',
  4: 'twoWordsConnector',
  5: 'lastWordConnector',
};

/**
 * Format a list of items for digest notifications with configurable behavior
 * Default formatting:
 * - 1 item: "John"
 * - 2 items: "John and Josh"
 * - 3 items: "John, Josh, and Sarah"
 * - 4+ items: "John, Josh, and 2 others"
 *
 * @param array The array of items to format
 * @param keyPath Path to the property to extract from objects (e.g., "name" or "profile.name")
 * @param limit Maximum number of words to show before the "overflowSuffix"
 * @param overflowSuffix The word to use for the items above the limit, e.g. "other"
 * @param wordsConnector The separator between words (default: ", ")
 * @param twoWordsConnector The separator for 2 words (default: " and ")
 * @param lastWordConnector The separator for 3+ words (default: ", and ")
 * @returns Formatted string, for example: "John, Josh and 2 others"
 */
export function toSentence(
  array: unknown,
  keyPath = DEFAULT_KEY_PATH,
  limit = DEFAULT_LIMIT,
  overflowSuffix = DEFAULT_OVERFLOW_SUFFIX,
  wordsConnector = DEFAULT_WORDS_CONNECTOR,
  twoWordsConnector = DEFAULT_TWO_WORDS_CONNECTOR,
  lastWordConnector = DEFAULT_LAST_WORD_CONNECTOR
): string {
  if (!Array.isArray(array) || array.length === 0) return '';

  const values = keyPath
    ? array.map((item) => {
        if (typeof item !== 'object' || !item) return '';

        return getNestedValue(item as Record<string, unknown>, keyPath);
      })
    : array;

  const wordsLength = values.length;
  if (wordsLength === 1) return values[0];
  if (wordsLength === 2) return `${values[0]}${twoWordsConnector}${values[1]}`;

  // If limit is greater than or equal to array length, show all items
  if (limit >= wordsLength) {
    const allButLast = values.slice(0, wordsLength - 1);
    const last = values[wordsLength - 1];

    return `${allButLast.join(wordsConnector)}${lastWordConnector}${last}`;
  }

  const shownItems = values.slice(0, limit);
  const moreCount = wordsLength - limit;

  // Use twoWordsConnector when showing only 1 item before overflow
  const connector = limit === 1 ? twoWordsConnector : lastWordConnector;

  return `${shownItems.join(wordsConnector)}${connector}${moreCount} ${pluralize(overflowSuffix, moreCount)}`;
}

/**
 * Validate the arguments for the toSentence filter
 * @param options Options for validation. Can include requireKeyPath to make keyPath required.
 * @param args The arguments for the toSentence filter
 * @returns An array of issues with the validation errors
 */
export function toSentenceArgsValidator(
  options: { requireKeyPath?: boolean } = {},
  ...args: Filter['args']
): LiquidFilterIssue[] {
  const { requireKeyPath = false } = options;
  const issues: LiquidFilterIssue[] = [];
  if (args.length < 1) {
    issues.push({
      message: 'Expected at least 1 argument',
      begin: 0,
      end: 0,
      value: '',
    });

    return issues;
  }

  const argsSchema = z.object({
    keyPath: requireKeyPath ? z.string().min(1, 'must be non-empty') : z.string().optional().default(DEFAULT_KEY_PATH),
    limit: z
      .number()
      .optional()
      .default(DEFAULT_LIMIT)
      .refine((val) => {
        return val >= 0;
      }, 'must be greater than or equal to 0'),
    overflowSuffix: z.string().optional().default(DEFAULT_OVERFLOW_SUFFIX),
    wordsConnector: z.string().optional().default(DEFAULT_WORDS_CONNECTOR),
    twoWordsConnector: z.string().optional().default(DEFAULT_TWO_WORDS_CONNECTOR),
    lastWordConnector: z.string().optional().default(DEFAULT_LAST_WORD_CONNECTOR),
  });

  const argsObject: Record<string, number | string> = {};
  args.forEach((arg, index) => {
    if (!Array.isArray(arg)) {
      let value: string | number = arg.getText();
      if (arg.kind === TokenKind.Quoted) {
        value = (arg as QuotedToken).content;
      } else if (arg.kind === TokenKind.Number) {
        value = (arg as NumberToken).content;
      }
      const argName = ARG_INDEX_TO_ARG_NAME[index];
      argsObject[argName] = value;
    }
  });

  const result = argsSchema.safeParse(argsObject);

  if (!result.success) {
    for (const error of result.error.issues) {
      let type = 'string';
      if ('type' in error) {
        type = error.type;
      }

      const path = error.path[0];
      const argIndexToArgName = Object.entries(ARG_INDEX_TO_ARG_NAME).find(([_, argName]) => argName === path);
      const argIndex = argIndexToArgName ? parseInt(argIndexToArgName[0], 10) : null;
      const token = typeof argIndex === 'number' ? args[argIndex] : null;

      if (token && !Array.isArray(token)) {
        issues.push({
          message: `"toSentence" expects a ${type}${error.message ? ` that ${error.message}` : ''} for argument "${path}"`,
          begin: token.begin,
          end: token.end,
          value: token.getText(),
        });
      }
    }
  }

  return issues;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - toSentence(array: unknown,
  keyPath = DEFAULT_KEY_PATH,
  limit = DEFAULT_LIMIT,
  overflowSuffix = DEFAULT_OVERFLOW_SUFFIX,
  wordsConnector = DEFAULT_WORDS_CONNECTOR,
  twoWordsConnector = DEFAULT_TWO_WORDS_CONNECTOR,
  lastWordConnector = DEFAULT_LAST_WORD_CONNECTOR)
 - toSentenceArgsValidator(options: { requireKeyPath?: boolean } = {},
  ...args: Filter['args'])
Asignaciones con arrow functions encontradas (posibles funciones):
 - values(keyPath
    ? array.map((item))
 - argsSchema(z.object({
    keyPath: requireKeyPath ? z.string().min(1, 'must be non-empty') : z.string().optiona...)
 - argIndexToArgName(Object.entries(ARG_INDEX_TO_ARG_NAME).find(([_, argName]))
Declaraciones 'export' encontradas:
- export function toSentence
- export function toSentenceArgsValidator

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/filters/types.ts
Tamaño: 105 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export type LiquidFilterIssue = {
  message: string;
  begin: number;
  end: number;
  value: string;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/filters/validators.ts
Tamaño: 286 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { toSentenceArgsValidator } from './to-sentence';
import { LiquidFilterIssue } from './types';

type FilterValidators = {
  [key: string]: (...args: any[]) => LiquidFilterIssue[];
};

export const FILTER_VALIDATORS: FilterValidators = {
  toSentence: toSentenceArgsValidator,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - FilterValidators({
  [key: string]: (...args: any[]))
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/internal/index.ts
Tamaño: 239 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from '../constants';
export * from '../errors';
export * from '../filters';
export { actionStepSchemas, channelStepSchemas } from '../schemas';
export * from '../types';
export { createLiquidEngine } from '../utils/liquid.utils';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/resources/index.ts
Tamaño: 46 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './workflow/workflow.resource';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/resources/workflow/discover-action-step-factory.ts
Tamaño: 1503 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ActionStepEnum } from '../../constants';
import { emptySchema } from '../../schemas';
import type { ActionStep, Awaitable, DiscoverWorkflowOutput, FromSchema, Schema, StepOptions } from '../../types';
import { transformSchema } from '../../validators';
import { discoverStep } from './discover-step';

export async function discoverActionStepFactory(
  targetWorkflow: DiscoverWorkflowOutput,
  type: ActionStepEnum,
  outputSchema: Schema,
  resultSchema: Schema
  // TODO: fix typing for `resolve` to use generic typings
): Promise<ActionStep<any, any>> {
  return async (stepId, resolve, options = {}) => {
    const controlSchema = options?.controlSchema || emptySchema;

    await discoverStep(targetWorkflow, stepId, {
      stepId,
      type,
      controls: {
        schema: await transformSchema(controlSchema),
        unknownSchema: controlSchema,
      },
      outputs: {
        schema: await transformSchema(outputSchema),
        unknownSchema: outputSchema,
      },
      results: {
        schema: await transformSchema(resultSchema),
        unknownSchema: resultSchema,
      },
      resolve: resolve as (controls: Record<string, unknown>) => Awaitable<Record<string, unknown>>,
      code: resolve.toString(),
      options: options as StepOptions<Schema, FromSchema<Schema>>,
      providers: [],
    });

    return {
      _ctx: {
        timestamp: Date.now(),
        state: {
          status: 'pending',
          error: false,
        },
      },
    };
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - discoverActionStepFactory(targetWorkflow: DiscoverWorkflowOutput,
  type: ActionStepEnum,
  outputSchema: Schema,
  resultSchema: Schema
  // TODO: fix typing for `resolve` to use generic typings)
Asignaciones con arrow functions encontradas (posibles funciones):
 - options({}))
 - controlSchema(options?.controlSchema || emptySchema;

    await discoverStep(targetWorkflow, stepId, {
      stepI...)
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/resources/workflow/discover-channel-step-factory.ts
Tamaño: 1756 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChannelStepEnum } from '../../constants';
import { emptySchema } from '../../schemas';
import type {
  Awaitable,
  ChannelStep,
  DiscoverStepOutput,
  DiscoverWorkflowOutput,
  FromSchema,
  Schema,
  StepOptions,
} from '../../types';
import { transformSchema } from '../../validators';
import { discoverProviders } from './discover-providers';
import { discoverStep } from './discover-step';

export async function discoverChannelStepFactory(
  targetWorkflow: DiscoverWorkflowOutput,
  type: ChannelStepEnum,
  outputSchema: Schema,
  resultSchema: Schema
): Promise<ChannelStep<ChannelStepEnum, any, any>> {
  return async (stepId, resolve, options = {}) => {
    const controlSchema = options?.controlSchema || emptySchema;

    const step: DiscoverStepOutput = {
      stepId,
      type,
      controls: {
        schema: await transformSchema(controlSchema),
        unknownSchema: controlSchema,
      },
      outputs: {
        schema: await transformSchema(outputSchema),
        unknownSchema: outputSchema,
      },
      results: {
        schema: await transformSchema(resultSchema),
        unknownSchema: resultSchema,
      },
      resolve: resolve as (controls: Record<string, unknown>) => Awaitable<Record<string, unknown>>,
      code: resolve.toString(),
      options: options as StepOptions<Schema, FromSchema<Schema>>,
      providers: [],
    };

    await discoverStep(targetWorkflow, stepId, step);

    if (Object.keys(options.providers || {}).length > 0) {
      await discoverProviders(step, type as ChannelStepEnum, options.providers || {});
    }

    return {
      _ctx: {
        timestamp: Date.now(),
        state: {
          status: 'pending',
          error: false,
        },
      },
    };
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - discoverChannelStepFactory(targetWorkflow: DiscoverWorkflowOutput,
  type: ChannelStepEnum,
  outputSchema: Schema,
  resultSchema: Schema)
Asignaciones con arrow functions encontradas (posibles funciones):
 - options({}))
 - DiscoverStepOutput({
      stepId,
      type,
      controls: {
        schema: await transformSchema(controlSchema),
...)
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/resources/workflow/discover-custom-step-factory.ts
Tamaño: 1646 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { emptySchema } from '../../schemas';
import type {
  Awaitable,
  CustomStep,
  DiscoverWorkflowOutput,
  Schema,
  StepOptions,
  StepOutput,
  StepType,
} from '../../types';
import { transformSchema } from '../../validators';
import { discoverStep } from './discover-step';

export async function discoverCustomStepFactory(
  targetWorkflow: DiscoverWorkflowOutput,
  type: StepType
): Promise<CustomStep> {
  return async (stepId, resolve, options = {}) => {
    const controlSchema = options?.controlSchema || emptySchema;
    const outputSchema = options?.outputSchema || emptySchema;

    const [transformedControlSchema, transformedOutputSchema] = await Promise.all([
      transformSchema(controlSchema),
      transformSchema(outputSchema),
    ]);

    await discoverStep(targetWorkflow, stepId, {
      stepId,
      type,
      controls: {
        schema: transformedControlSchema,
        unknownSchema: controlSchema,
      },
      outputs: {
        schema: transformedOutputSchema,
        unknownSchema: outputSchema,
      },
      results: {
        schema: transformedOutputSchema,
        unknownSchema: outputSchema,
      },
      resolve: resolve as (controls: Record<string, unknown>) => Awaitable<Record<string, unknown>>,
      code: resolve.toString(),
      options: options as StepOptions<Schema, Record<string, unknown>>,
      providers: [],
    });

    return {
      _ctx: {
        timestamp: Date.now(),
        state: {
          status: 'pending',
          error: false,
        },
      },
      // TODO: fix typing for `resolve` to use generic typings
    } as Awaited<StepOutput<any>>;
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - discoverCustomStepFactory(targetWorkflow: DiscoverWorkflowOutput,
  type: StepType)
Asignaciones con arrow functions encontradas (posibles funciones):
 - options({}))
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/resources/workflow/discover-providers.ts
Tamaño: 1297 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChannelStepEnum } from '../../constants';
import { providerSchemas } from '../../schemas';
import type { Awaitable, DiscoverStepOutput } from '../../types';
import { WithPassthrough } from '../../types/provider.types';
import { transformSchema } from '../../validators';

export async function discoverProviders(
  step: DiscoverStepOutput,
  channelType: ChannelStepEnum,
  providers: Record<
    string,
    ({
      controls,
      outputs,
    }: {
      controls: Record<string, unknown>;
      outputs: Record<string, unknown>;
    }) => Awaitable<WithPassthrough<Record<string, unknown>>>
  >
): Promise<void> {
  const channelSchemas = providerSchemas[channelType];

  const providerPromises = Object.entries(providers).map(async ([type, resolve]) => {
    // TODO: fix the typing for `type` to use the keyof providerSchema[channelType]
    // @ts-expect-error - Element implicitly has an 'any' type because expression of type 'string' can't be used to index type
    const schemas = channelSchemas[type];

    return {
      type,
      code: resolve.toString(),
      resolve,
      outputs: {
        schema: await transformSchema(schemas.output),
        unknownSchema: schemas.output,
      },
    };
  });

  step.providers.push(...(await Promise.all(providerPromises)));
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - discoverProviders(step: DiscoverStepOutput,
  channelType: ChannelStepEnum,
  providers: Record<
    string,
    ({
      controls,
      outputs,
    }: {
      controls: Record<string, unknown>;
      outputs: Record<string, unknown>;
    })
Asignaciones con arrow functions encontradas (posibles funciones):
 - providerPromises(Object.entries(providers).map(async ([type, resolve]))
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/resources/workflow/discover-step.ts
Tamaño: 462 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { StepAlreadyExistsError } from '../../errors';
import type { DiscoverStepOutput, DiscoverWorkflowOutput } from '../../types';

export async function discoverStep(
  targetWorkflow: DiscoverWorkflowOutput,
  stepId: string,
  step: DiscoverStepOutput
): Promise<void> {
  if (targetWorkflow.steps.some((workflowStep) => workflowStep.stepId === stepId)) {
    throw new StepAlreadyExistsError(stepId);
  } else {
    targetWorkflow.steps.push(step);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - discoverStep(targetWorkflow: DiscoverWorkflowOutput,
  stepId: string,
  step: DiscoverStepOutput)
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/resources/workflow/index.ts
Tamaño: 37 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './workflow.resource';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/resources/workflow/map-preferences.test.ts
Tamaño: 1398 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { describe, expect, it } from 'vitest';
import { mapPreferences } from './map-preferences';

describe('mapPreferences', () => {
  it('should return an empty object for undefined input', () => {
    const result = mapPreferences();

    expect(result).to.deep.equal({});
  });

  it('should return an empty object when an empty object is passed', () => {
    const result = mapPreferences({});

    expect(result).to.deep.equal({});
  });

  it('should return the mapped object for a partial object', () => {
    const result = mapPreferences({
      channels: {
        inApp: { enabled: false },
      },
    });

    expect(result).to.deep.equal({
      channels: {
        in_app: { enabled: false },
      },
    });
  });

  it('should return the the mapped equivalent of a full preference object', () => {
    const result = mapPreferences({
      all: { enabled: true, readOnly: false },
      channels: {
        email: { enabled: true },
        sms: { enabled: true },
        push: { enabled: true },
        inApp: { enabled: true },
        chat: { enabled: true },
      },
    });

    expect(result).to.deep.equal({
      all: { enabled: true, readOnly: false },
      channels: {
        email: { enabled: true },
        sms: { enabled: true },
        push: { enabled: true },
        in_app: { enabled: true },
        chat: { enabled: true },
      },
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - result(mapPreferences();

    expect(result).to.deep.equal({});
  });

  it('should return an empty object ...)
 - result(mapPreferences({});

    expect(result).to.deep.equal({});
  });

  it('should return the mapped obj...)
 - result(mapPreferences({
      channels: {
        inApp: { enabled: false },
      },
    });

    expect(r...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/resources/workflow/map-preferences.ts
Tamaño: 1462 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { WorkflowChannelEnum } from '../../constants';
import { ChannelTypeEnum, WorkflowPreferencesPartial } from '../../shared';
import { WorkflowPreferences } from '../../types';

/** Correlate user-friendly channels to system-friendly channels */
const CHANNEL_TYPE_FROM_WORKFLOW_CHANNEL: Record<WorkflowChannelEnum, ChannelTypeEnum> = {
  [WorkflowChannelEnum.EMAIL]: ChannelTypeEnum.EMAIL,
  [WorkflowChannelEnum.SMS]: ChannelTypeEnum.SMS,
  [WorkflowChannelEnum.PUSH]: ChannelTypeEnum.PUSH,
  [WorkflowChannelEnum.IN_APP]: ChannelTypeEnum.IN_APP,
  [WorkflowChannelEnum.CHAT]: ChannelTypeEnum.CHAT,
};

/** Map preferences between user-friendly and system-friendly values / keys */
export function mapPreferences(preferences?: WorkflowPreferences): WorkflowPreferencesPartial {
  if (!preferences) {
    return {};
  }

  const output: WorkflowPreferencesPartial = {};

  if (preferences.all) {
    output.all = preferences.all;
  }

  // map between framework user-friendly enum (with camelCasing) to shared ChannelTypeEnum if the entry exists
  Object.entries(preferences.channels || {}).forEach(([developerFriendlyChannel, channelLevelPreference]) => {
    const systemChannel = CHANNEL_TYPE_FROM_WORKFLOW_CHANNEL[developerFriendlyChannel as WorkflowChannelEnum];
    if (systemChannel) {
      if (!output.channels) {
        output.channels = {};
      }
      output.channels[systemChannel] = channelLevelPreference;
    }
  });

  return output;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - mapPreferences(preferences?: WorkflowPreferences)
Asignaciones con arrow functions encontradas (posibles funciones):
 - all(preferences.all;
  }

  // map between framework user-friendly enum (with camelCasing) to shared Cha...)
Declaraciones 'export' encontradas:
- export function mapPreferences

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/resources/workflow/pretty-print-discovery.ts
Tamaño: 936 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { DiscoverWorkflowOutput } from '../../types';
import { EMOJI, log } from '../../utils';

export function prettyPrintDiscovery(discoveredWorkflow: DiscoverWorkflowOutput): void {
  console.log(`\n${log.bold(log.underline('Discovered workflowId:'))} '${discoveredWorkflow.workflowId}'`);
  discoveredWorkflow.steps.forEach((step, i) => {
    const isLastStep = i === discoveredWorkflow.steps.length - 1;
    const prefix = isLastStep ? '└' : '├';
    console.log(`${prefix} ${EMOJI.STEP} Discovered stepId: '${step.stepId}'\tType: '${step.type}'`);
    step.providers.forEach((provider, providerIndex) => {
      const isLastProvider = providerIndex === step.providers.length - 1;
      const stepPrefix = isLastStep ? ' ' : '│';
      const providerPrefix = isLastProvider ? '└' : '├';
      console.log(`${stepPrefix} ${providerPrefix} ${EMOJI.PROVIDER} Discovered provider: '${provider.type}'`);
    });
  });
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - prettyPrintDiscovery(discoveredWorkflow: DiscoverWorkflowOutput)
Asignaciones con arrow functions encontradas (posibles funciones):
 - prefix(isLastStep ? '└' : '├';
    console.log(`${prefix} ${EMOJI.STEP} Discovered stepId: '${step.stepId}'...)
Declaraciones 'export' encontradas:
- export function prettyPrintDiscovery

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/resources/workflow/workflow.resource.test-d.ts
Tamaño: 7029 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { describe, expectTypeOf } from 'vitest';
import { Subscriber } from '../../types';
import { workflow } from '.';

describe('workflow function types', () => {
  describe('event types', () => {
    it('should have the expected subscriber type', () => {
      workflow('without-schema', async ({ subscriber }) => {
        expectTypeOf(subscriber).toEqualTypeOf<Subscriber>();
      });
    });

    it('should have the expected step functions', () => {
      workflow('without-schema', async ({ step }) => {
        expectTypeOf(step).toMatchTypeOf<{
          email: unknown;
          sms: unknown;
          push: unknown;
          chat: unknown;
          inApp: unknown;
          digest: unknown;
          delay: unknown;
          custom: unknown;
        }>();
      });
    });
  });

  describe('without schema', () => {
    it('should infer an unknown record type in the step controls', async () => {
      workflow('without-schema', async ({ step }) => {
        await step.email(
          'without-schema',
          async (controls) => {
            expectTypeOf(controls).toEqualTypeOf<Record<string, unknown>>();

            return {
              subject: 'Test subject',
              body: 'Test body',
            };
          },
          {
            skip: (controls) => {
              expectTypeOf(controls).toEqualTypeOf<Record<string, unknown>>();

              return true;
            },
            providers: {
              sendgrid: async ({ controls }) => {
                expectTypeOf(controls).toEqualTypeOf<Record<string, unknown>>();

                return {
                  ipPoolName: 'test',
                };
              },
            },
          }
        );
      });
    });

    it('should infer an unknown record type in the workflow event payload', async () => {
      workflow('without-schema', async ({ step, payload }) => {
        await step.email('without-schema', async () => {
          expectTypeOf(payload).toEqualTypeOf<Record<string, unknown>>();

          return {
            subject: 'Test subject',
            body: 'Test body',
          };
        });
      });
    });

    it('should infer an unknown record type in the workflow event controls', async () => {
      workflow('without-schema', async ({ step, controls }) => {
        await step.email('without-schema', async () => {
          expectTypeOf(controls).toEqualTypeOf<Record<string, unknown>>();

          return {
            subject: 'Test subject',
            body: 'Test body',
          };
        });
      });
    });

    it('should infer an unknown record type in the custom step results', async () => {
      workflow('without-schema', async ({ step }) => {
        const result = await step.custom('without-schema', async () => {
          return {
            foo: 'bar',
          };
        });

        expectTypeOf(result).toMatchTypeOf<Record<string, unknown>>();
      });
    });
  });

  describe('json-schema', () => {
    const jsonSchema = {
      type: 'object',
      properties: {
        foo: { type: 'string' },
        baz: { type: 'number' },
      },
      required: ['foo'],
      additionalProperties: false,
    } as const;

    it('should infer an unknown record type when the provided schema is for a primitive type', () => {
      const primitiveSchema = { type: 'string' } as const;
      workflow('without-schema', async ({ step }) => {
        await step.email(
          'without-schema',
          async (controls) => {
            expectTypeOf(controls).toEqualTypeOf<Record<string, unknown>>();

            return {
              subject: 'Test subject',
              body: 'Test body',
            };
          },
          {
            // @ts-expect-error - schema is for a primitive type
            controlSchema: primitiveSchema,
          }
        );
      });
    });

    it('should infer correct types in the step controls', async () => {
      workflow('json-schema', async ({ step }) => {
        await step.email(
          'json-schema',
          async (controls) => {
            expectTypeOf(controls).toEqualTypeOf<{ foo: string; baz?: number }>();

            return {
              subject: 'Test subject',
              body: 'Test body',
            };
          },
          {
            controlSchema: jsonSchema,
            skip: (controls) => {
              expectTypeOf(controls).toEqualTypeOf<{ foo: string; baz?: number }>();

              return true;
            },
            providers: {
              sendgrid: async ({ controls }) => {
                expectTypeOf(controls).toEqualTypeOf<{ foo: string; baz?: number }>();

                return {
                  ipPoolName: 'test',
                };
              },
            },
          }
        );
      });

      it('should infer correct types in the workflow event payload', async () => {
        workflow(
          'json-schema-validation',
          async ({ step, payload }) => {
            await step.email('json-schema-validation', async () => {
              expectTypeOf(payload).toEqualTypeOf<{ foo: string; baz?: number }>();

              return {
                subject: 'Test subject',
                body: 'Test body',
              };
            });
          },
          {
            payloadSchema: jsonSchema,
          }
        );
      });

      it('should infer correct types in the workflow event controls', async () => {
        workflow(
          'json-schema-validation',
          async ({ step, controls }) => {
            await step.email('json-schema-validation', async () => {
              expectTypeOf(controls).toEqualTypeOf<{ foo: string; baz?: number }>();

              return {
                subject: 'Test subject',
                body: 'Test body',
              };
            });
          },
          {
            controlSchema: jsonSchema,
          }
        );
      });

      it('should infer correct types in the workflow event controls', async () => {
        workflow(
          'json-schema-validation',
          async ({ step, controls }) => {
            await step.email('json-schema-validation', async () => {
              expectTypeOf(controls).toEqualTypeOf<{ foo: string; baz?: number }>();

              return {
                subject: 'Test subject',
                body: 'Test body',
              };
            });
          },
          {
            controlSchema: jsonSchema,
          }
        );
      });

      it('should infer the correct types in the custom step results', async () => {
        workflow('without-schema', async ({ step }) => {
          const result = await step.custom(
            'without-schema',
            async () => {
              return {
                foo: 'bar',
              };
            },
            {
              outputSchema: jsonSchema,
            }
          );

          expectTypeOf(result).toMatchTypeOf<{ foo: string; baz?: number }>();
        });
      });
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - result(await step.custom('without-schema', async ())
 - jsonSchema({
      type: 'object',
      properties: {
        foo: { type: 'string' },
        baz: { type: 'n...)
 - primitiveSchema({ type: 'string' } as const;
      workflow('without-schema', async ({ step }))
 - result(await step.custom(
            'without-schema',
            async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/resources/workflow/workflow.resource.ts
Tamaño: 5939 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ActionStepEnum, ChannelStepEnum } from '../../constants';
import { WorkflowPayloadInvalidError } from '../../errors';
import {
  channelStepSchemas,
  delayActionSchemas,
  digestActionSchemas,
  emptySchema,
  throttleActionSchemas,
} from '../../schemas';
import {
  type CancelEventTriggerResponse,
  type DiscoverWorkflowOutput,
  type EventTriggerResponse,
  type Execute,
  type FromSchema,
  type FromSchemaUnvalidated,
  type Schema,
  SeverityLevelEnum,
  type Workflow,
  type WorkflowOptions,
} from '../../types';
import { getBridgeUrl, initApiClient, resolveApiUrl, resolveSecretKey } from '../../utils';
import { transformSchema, validateData } from '../../validators';
import { discoverActionStepFactory } from './discover-action-step-factory';
import { discoverChannelStepFactory } from './discover-channel-step-factory';
import { discoverCustomStepFactory } from './discover-custom-step-factory';
import { mapPreferences } from './map-preferences';

/**
 * Define a new notification workflow.
 */
export function workflow<
  T_PayloadSchema extends Schema,
  T_ControlSchema extends Schema,
  T_PayloadValidated extends Record<string, unknown> = FromSchema<T_PayloadSchema>,
  T_PayloadUnvalidated extends Record<string, unknown> = FromSchemaUnvalidated<T_PayloadSchema>,
  T_Controls extends Record<string, unknown> = FromSchema<T_ControlSchema>,
>(
  workflowId: string,
  execute: Execute<T_PayloadValidated, T_Controls>,
  workflowOptions?: WorkflowOptions<T_PayloadSchema, T_ControlSchema>
): Workflow<T_PayloadUnvalidated> {
  const options = workflowOptions || {};

  const trigger: Workflow<T_PayloadUnvalidated>['trigger'] = async (event) => {
    const apiClient = initApiClient(resolveSecretKey(event.secretKey), resolveApiUrl(event.apiUrl));

    const unvalidatedData = (event.payload || {}) as T_PayloadUnvalidated;
    let validatedData: T_PayloadValidated;
    if (options.payloadSchema) {
      const validationResult = await validateData(options.payloadSchema, unvalidatedData);
      if (validationResult.success === false) {
        throw new WorkflowPayloadInvalidError(workflowId, validationResult.errors);
      }
      validatedData = validationResult.data as T_PayloadValidated;
    } else {
      // This type coercion provides support to trigger Workflows without a payload schema
      validatedData = event.payload as unknown as T_PayloadValidated;
    }
    const bridgeUrl = await getBridgeUrl();

    const requestPayload = {
      name: workflowId,
      to: event.to,
      payload: {
        ...validatedData,
      },
      ...(event.transactionId && { transactionId: event.transactionId }),
      ...(event.overrides && { overrides: event.overrides }),
      ...(event.actor && { actor: event.actor }),
      ...(event.context && { context: event.context }),
      ...(bridgeUrl && { bridgeUrl }),
    };

    const result = await apiClient.post<EventTriggerResponse>('/events/trigger', requestPayload);

    const cancel = async () => {
      return apiClient.delete<CancelEventTriggerResponse>(`/events/trigger/${result.transactionId}`);
    };

    return {
      cancel,
      data: result,
    };
  };

  const discover = async (): Promise<DiscoverWorkflowOutput> => {
    const newWorkflow: DiscoverWorkflowOutput = {
      workflowId,
      severity: options.severity ?? SeverityLevelEnum.NONE,
      steps: [],
      code: execute.toString(),
      payload: {
        schema: await transformSchema(options.payloadSchema || emptySchema),
        unknownSchema: options.payloadSchema || emptySchema,
      },
      controls: {
        schema: await transformSchema(options.controlSchema || emptySchema),
        unknownSchema: options.controlSchema || emptySchema,
      },
      tags: options.tags || [],
      preferences: mapPreferences(options.preferences),
      name: options.name,
      description: options.description,
      execute: execute as Execute<Record<string, unknown>, Record<string, unknown>>,
    };

    await execute({
      payload: {} as T_PayloadValidated,
      subscriber: {},
      environment: {},
      controls: {} as T_Controls,
      context: {},
      step: {
        push: await discoverChannelStepFactory(
          newWorkflow,
          ChannelStepEnum.PUSH,
          channelStepSchemas.push.output,
          channelStepSchemas.push.result
        ),
        chat: await discoverChannelStepFactory(
          newWorkflow,
          ChannelStepEnum.CHAT,
          channelStepSchemas.chat.output,
          channelStepSchemas.chat.result
        ),
        email: await discoverChannelStepFactory(
          newWorkflow,
          ChannelStepEnum.EMAIL,
          channelStepSchemas.email.output,
          channelStepSchemas.email.result
        ),
        sms: await discoverChannelStepFactory(
          newWorkflow,
          ChannelStepEnum.SMS,
          channelStepSchemas.sms.output,
          channelStepSchemas.sms.result
        ),
        inApp: await discoverChannelStepFactory(
          newWorkflow,
          ChannelStepEnum.IN_APP,
          channelStepSchemas.in_app.output,
          channelStepSchemas.in_app.result
        ),
        digest: await discoverActionStepFactory(
          newWorkflow,
          ActionStepEnum.DIGEST,
          digestActionSchemas.output,
          digestActionSchemas.result
        ),
        delay: await discoverActionStepFactory(
          newWorkflow,
          ActionStepEnum.DELAY,
          delayActionSchemas.output,
          delayActionSchemas.result
        ),
        throttle: await discoverActionStepFactory(
          newWorkflow,
          ActionStepEnum.THROTTLE,
          throttleActionSchemas.output,
          throttleActionSchemas.result
        ),
        custom: await discoverCustomStepFactory(newWorkflow, ActionStepEnum.CUSTOM),
      } as never,
    });

    return newWorkflow;
  };

  return {
    id: workflowId,
    trigger,
    discover,
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - cancel(async ())
 - discover(async (): Promise<DiscoverWorkflowOutput>)
Declaraciones 'export' encontradas:
- export function workflow

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/resources/workflow/workflow.test.ts
Tamaño: 16753 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import { MissingSecretKeyError } from '../../errors';
import { workflow } from './workflow.resource';

describe('workflow function', () => {
  describe('Type tests', () => {
    it('should not compile when the channel output is incorrect', async () => {
      workflow('setup-workflow', async ({ step }) => {
        // @ts-expect-error - email subject is missing from the output
        await step.email('send-email', async () => ({
          body: 'Test Body',
        }));
      });
    });

    it('should not compile when the custom output is incorrect', async () => {
      workflow('custom-test', async ({ step }) => {
        await step.custom(
          'custom',
          // @ts-expect-error - foo is a number
          async () => ({
            foo: 'bar',
            bar: 'baz',
          }),
          {
            outputSchema: {
              type: 'object',
              properties: {
                foo: { type: 'number' },
                bar: { type: 'string', default: 'baz' },
              },
              required: ['foo', 'bar'],
              additionalProperties: false,
            } as const,
          }
        );
      });
    });

    it('should not compile when the custom result is compared incorrectly', async () => {
      workflow('custom-test-something', async ({ step }) => {
        const result = await step.custom(
          'custom',
          async () => ({
            foo: 1,
            bar: 'baz',
          }),
          {
            outputSchema: {
              type: 'object',
              properties: {
                foo: { type: 'number' },
                bar: { type: 'string' },
              },
              required: ['foo', 'bar'],
              additionalProperties: false,
            } as const,
          }
        );

        // @ts-expect-error - result is a string
        result?.foo === 'custom';
      });
    });

    it('should compile when returning undefined for a built-in step property that has a default value', async () => {
      const delayType = undefined;
      workflow('built-in-default-test', async ({ step }) => {
        await step.delay('custom', async () => ({
          type: delayType,
          amount: 1,
          unit: 'seconds',
        }));
      });
    });

    it('should compile when returning undefined for a custom step property that has a default value', async () => {
      workflow('custom-default-test', async ({ step }) => {
        await step.custom(
          'custom',
          async () => ({
            withDefault: undefined,
            withoutDefault: 'bar',
          }),
          {
            outputSchema: {
              type: 'object',
              properties: {
                withDefault: { type: 'string', default: 'bar' },
                withoutDefault: { type: 'string' },
              },
              required: ['withoutDefault'],
              additionalProperties: false,
            } as const,
          }
        );
      });
    });
  });

  it('should include the defined preferences', async () => {
    const { discover } = workflow(
      'setup-workflow',
      async ({ step }) => {
        await step.email('send-email', async () => ({
          subject: 'Test Subject',
          body: 'Test Body',
        }));
      },
      {
        preferences: {
          channels: {
            email: { enabled: true },
          },
        },
      }
    );

    const definition = await discover();

    expect(definition.preferences).to.deep.equal({
      channels: {
        email: { enabled: true },
      },
    });
  });

  it('should include the defined name', async () => {
    const { discover } = workflow(
      'workflow-with-name',
      async ({ step }) => {
        await step.email('send-email', async () => ({
          subject: 'Test Subject',
          body: 'Test Body',
        }));
      },
      {
        name: 'My Workflow',
      }
    );

    const definition = await discover();

    expect(definition.name).to.equal('My Workflow');
  });

  it('should include the defined description', async () => {
    const { discover } = workflow(
      'workflow-with-description',
      async ({ step }) => {
        await step.email('send-email', async () => ({
          subject: 'Test Subject',
          body: 'Test Body',
        }));
      },
      {
        description: 'My Workflow Description',
      }
    );

    const definition = await discover();

    expect(definition.description).to.equal('My Workflow Description');
  });

  describe('trigger', () => {
    beforeEach(() => {
      process.env.NOVU_SECRET_KEY = 'test';
    });

    afterEach(() => {
      delete process.env.NOVU_SECRET_KEY;
    });

    const testPayloadSchema = {
      type: 'object',
      properties: {
        foo: { type: 'string' },
      },
      required: ['foo'],
      additionalProperties: false,
    } as const;

    it('should not compile when payload typings are incorrect', async () => {
      const testWorkflow = workflow(
        'test-workflow',
        async ({ step }) => {
          await step.custom('custom', async () => ({
            foo: 'bar',
          }));
        },
        {
          payloadSchema: testPayloadSchema,
        }
      );

      // Capture in a test function to avoid throwing execution errors

      const testFn = () =>
        testWorkflow.trigger({
          // @ts-expect-error - foo is missing from the payload
          payload: {},
          to: 'test@test.com',
        });
    });

    it('should compile when returning undefined for a payload property that has a default value', async () => {
      const testWorkflow = workflow(
        'test-workflow',
        async ({ step }) => {
          await step.custom('custom', async () => ({
            foo: 'bar',
          }));
        },
        {
          payloadSchema: {
            type: 'object',
            properties: {
              withDefault: { type: 'string', default: 'bar' },
              withoutDefault: { type: 'string' },
            },
            required: ['withoutDefault'],
            additionalProperties: false,
          } as const,
        }
      );

      // Capture in a test function to avoid throwing execution errors

      const testFn = () =>
        testWorkflow.trigger({
          payload: {
            withDefault: undefined,
            withoutDefault: 'bar',
          },
          to: 'test@test.com',
        });
    });

    it('should not compile when the payload is not specified and the payloadSchema declares required properties', async () => {
      const testWorkflow = workflow(
        'test-workflow',
        async ({ step }) => {
          await step.custom('custom', async () => ({
            foo: 'bar',
          }));
        },
        {
          payloadSchema: {
            type: 'object',
            properties: {
              foo: { type: 'string' },
            },
            required: ['foo'],
            additionalProperties: false,
          } as const,
        }
      );

      // Capture in a test function to avoid throwing execution errors

      const testFn = () =>
        testWorkflow.trigger({
          // @ts-expect-error - payload is missing from the trigger
          payload: undefined,
          to: 'test@test.com',
        });
    });

    it('should compile when the payload is not specified and the payloadSchema does not declare required properties', async () => {
      const testWorkflow = workflow(
        'test-workflow',
        async ({ step }) => {
          await step.custom('custom', async () => ({
            foo: 'bar',
          }));
        },
        {
          payloadSchema: {
            type: 'object',
            properties: {
              foo: { type: 'string' },
            },
            additionalProperties: false,
          } as const,
        }
      );

      // Capture in a test function to avoid throwing execution errors

      const testFn = () =>
        testWorkflow.trigger({
          to: 'test@test.com',
        });
    });

    it('should compile when the payload is not specified and the payloadSchema is not specified', async () => {
      const testWorkflow = workflow('test-workflow', async ({ step }) => {
        await step.custom('custom', async () => ({
          foo: 'bar',
        }));
      });

      // Capture in a test function to avoid throwing execution errors

      const testFn = () =>
        testWorkflow.trigger({
          to: 'test@test.com',
        });
    });

    it('should throw an error when the NOVU_SECRET_KEY is not set', async () => {
      const originalEnv = process.env.NOVU_SECRET_KEY;
      delete process.env.NOVU_SECRET_KEY;

      const testWorkflow = workflow('test-workflow', async ({ step }) => {
        await step.custom('custom', async () => ({
          foo: 'bar',
        }));
      });

      await expect(
        testWorkflow.trigger({
          payload: {},
          to: 'test@test.com',
        })
      ).rejects.toThrow(MissingSecretKeyError);

      process.env.NOVU_SECRET_KEY = originalEnv;
    });

    it('should throw an error when the incorrect payload is provided', async () => {
      const testWorkflow = workflow(
        'test-workflow',
        async ({ step }) => {
          await step.custom('custom', async () => ({
            foo: 'bar',
          }));
        },
        {
          payloadSchema: testPayloadSchema,
        }
      );

      await expect(
        testWorkflow.trigger({
          // @ts-expect-error - foo is missing from the payload
          payload: {},
          to: 'test@test.com',
        })
      ).rejects.toThrow(
        `Workflow with id: \`test-workflow\` has invalid \`payload\`. Please provide the correct payload`
      );
    });

    it('should make an API call without validating when the payloaSchema is not provided', async () => {
      const testWorkflow = workflow('test-workflow', async ({ step }) => {
        await step.custom('custom', async () => ({
          foo: 'bar',
        }));
      });

      const fetchMock = vi.fn().mockResolvedValueOnce({
        ok: true,
        json: () => {
          return Promise.resolve({
            transactionId: '123',
          });
        },
      });
      global.fetch = fetchMock;

      await testWorkflow.trigger({
        to: 'test@test.com',
        payload: {
          free: 'field',
        },
      });

      expect(fetchMock).toHaveBeenCalledWith(
        expect.stringMatching('/events/trigger'),
        expect.objectContaining({
          body: JSON.stringify({
            name: 'test-workflow',
            to: 'test@test.com',
            payload: {
              free: 'field',
            },
          }),
          headers: {
            'Content-Type': 'application/json',
            Authorization: `ApiKey ${process.env.NOVU_SECRET_KEY}`,
          },
          method: 'POST',
        })
      );
    });

    it('should make an API call when provided with a valid payload', async () => {
      const testWorkflow = workflow(
        'test-workflow',
        async ({ step }) => {
          await step.custom('custom', async () => ({
            foo: 'bar',
          }));
        },
        {
          payloadSchema: testPayloadSchema,
        }
      );

      const fetchMock = vi.fn().mockResolvedValueOnce({
        ok: true,
        json: () => {
          return Promise.resolve({
            transactionId: '123',
          });
        },
      });
      global.fetch = fetchMock;

      const result = await testWorkflow.trigger({
        payload: {
          foo: 'bar',
        },
        to: 'test@test.com',
      });

      expect(fetchMock).toHaveBeenCalledWith(
        expect.stringMatching('/events/trigger'),
        expect.objectContaining({
          body: JSON.stringify({
            name: 'test-workflow',
            to: 'test@test.com',
            payload: {
              foo: 'bar',
            },
          }),
          headers: {
            'Content-Type': 'application/json',
            Authorization: `ApiKey ${process.env.NOVU_SECRET_KEY}`,
          },
          method: 'POST',
        })
      );

      expect(result.data).toEqual({
        transactionId: '123',
      });
    });

    it('should call the correct API endpoint when the trigger is cancelled', async () => {
      const testWorkflow = workflow('test-workflow', async ({ step }) => {
        await step.custom('custom', async () => ({
          foo: 'bar',
        }));
      });

      const mockCancelResult = true;
      const mockTransactionId = '123';
      const fetchMock = vi.fn().mockImplementation((input: string) => {
        if (input.endsWith(`/events/trigger/${mockTransactionId}`)) {
          return Promise.resolve({
            ok: true,
            json: () => Promise.resolve(mockCancelResult),
          });
        } else if (input.endsWith('/events/trigger')) {
          return Promise.resolve({
            ok: true,
            json: () => Promise.resolve({ transactionId: mockTransactionId }),
          });
        } else {
          throw new Error('Invalid fetch call');
        }
      });
      global.fetch = fetchMock;

      const triggerResult = await testWorkflow.trigger({
        payload: {
          foo: 'bar',
        },
        to: 'test@test.com',
      });

      const test = await triggerResult.cancel();

      expect(test).toBe(mockCancelResult);
      expect(fetchMock).toHaveBeenCalledWith(
        expect.stringMatching(`/events/trigger/${mockTransactionId}`),
        expect.objectContaining({
          headers: {
            'Content-Type': 'application/json',
            Authorization: `ApiKey ${process.env.NOVU_SECRET_KEY}`,
          },
          method: 'DELETE',
        })
      );
    });

    it('should handle various context payload formats', async () => {
      const testWorkflow = workflow('test-workflow', async ({ step }) => {
        await step.custom('custom', async () => ({
          foo: 'bar',
        }));
      });

      const fetchMock = vi.fn().mockResolvedValueOnce({
        ok: true,
        json: () => {
          return Promise.resolve({
            transactionId: '123',
          });
        },
      });
      global.fetch = fetchMock;

      await testWorkflow.trigger({
        to: 'test@test.com',
        payload: {
          name: 'John',
        },
        context: {
          // Simple string value
          user: 'john-doe',

          // Rich object with full data
          tenant: {
            id: 'org-acme',
            data: { name: 'Acme Corp', plan: 'enterprise', region: 'us-east' },
          },
          // Rich object without data field
          app: {
            id: 'jira',
          },
        },
      });

      expect(fetchMock).toHaveBeenCalledWith(
        expect.stringMatching('/events/trigger'),
        expect.objectContaining({
          body: JSON.stringify({
            name: 'test-workflow',
            to: 'test@test.com',
            payload: {
              name: 'John',
            },
            context: {
              user: 'john-doe',
              tenant: {
                id: 'org-acme',
                data: { name: 'Acme Corp', plan: 'enterprise', region: 'us-east' },
              },
              app: {
                id: 'jira',
              },
            },
          }),
          headers: {
            'Content-Type': 'application/json',
            Authorization: `ApiKey ${process.env.NOVU_SECRET_KEY}`,
          },
          method: 'POST',
        })
      );
    });

    it('should work without context properties', async () => {
      const testWorkflow = workflow('test-workflow', async ({ step }) => {
        await step.custom('custom', async () => ({
          foo: 'bar',
        }));
      });

      const fetchMock = vi.fn().mockResolvedValueOnce({
        ok: true,
        json: () => {
          return Promise.resolve({
            transactionId: '123',
          });
        },
      });
      global.fetch = fetchMock;

      await testWorkflow.trigger({
        to: 'test@test.com',
        payload: {
          name: 'John',
        },
      });

      expect(fetchMock).toHaveBeenCalledWith(
        expect.stringMatching('/events/trigger'),
        expect.objectContaining({
          body: JSON.stringify({
            name: 'test-workflow',
            to: 'test@test.com',
            payload: {
              name: 'John',
            },
          }),
          headers: {
            'Content-Type': 'application/json',
            Authorization: `ApiKey ${process.env.NOVU_SECRET_KEY}`,
          },
          method: 'POST',
        })
      );
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - result(await step.custom(
          'custom',
          async ())
 - delayType(undefined;
      workflow('built-in-default-test', async ({ step }))
 - definition(await discover();

    expect(definition.preferences).to.deep.equal({
      channels: {
        emai...)
 - definition(await discover();

    expect(definition.name).to.equal('My Workflow');
  });

  it('should include ...)
 - definition(await discover();

    expect(definition.description).to.equal('My Workflow Description');
  });

  ...)
 - NOVU_SECRET_KEY('test';
    });

    afterEach(())
 - testPayloadSchema({
      type: 'object',
      properties: {
        foo: { type: 'string' },
      },
      required...)
 - testWorkflow(workflow(
        'test-workflow',
        async ({ step }))
 - testFn())
 - testWorkflow(workflow(
        'test-workflow',
        async ({ step }))
 - testFn())
 - testWorkflow(workflow(
        'test-workflow',
        async ({ step }))
 - testFn())
 - testWorkflow(workflow(
        'test-workflow',
        async ({ step }))
 - testFn())
 - testWorkflow(workflow('test-workflow', async ({ step }))
 - testFn())
 - testWorkflow(workflow('test-workflow', async ({ step }))
 - NOVU_SECRET_KEY(originalEnv;
    });

    it('should throw an error when the incorrect payload is provided', async (...)
 - testWorkflow(workflow(
        'test-workflow',
        async ({ step }))
 - testWorkflow(workflow('test-workflow', async ({ step }))
 - fetchMock(vi.fn().mockResolvedValueOnce({
        ok: true,
        json: ())
 - fetch(fetchMock;

      await testWorkflow.trigger({
        to: 'test@test.com',
        payload: {
     ...)
 - testWorkflow(workflow(
        'test-workflow',
        async ({ step }))
 - fetchMock(vi.fn().mockResolvedValueOnce({
        ok: true,
        json: ())
 - result(await testWorkflow.trigger({
        payload: {
          foo: 'bar',
        },
        to: 'test@t...)
 - testWorkflow(workflow('test-workflow', async ({ step }))
 - fetchMock(vi.fn().mockImplementation((input: string))
 - test(await triggerResult.cancel();

      expect(test).toBe(mockCancelResult);
      expect(fetchMock).to...)
 - testWorkflow(workflow('test-workflow', async ({ step }))
 - fetchMock(vi.fn().mockResolvedValueOnce({
        ok: true,
        json: ())
 - fetch(fetchMock;

      await testWorkflow.trigger({
        to: 'test@test.com',
        payload: {
     ...)
 - testWorkflow(workflow('test-workflow', async ({ step }))
 - fetchMock(vi.fn().mockResolvedValueOnce({
        ok: true,
        json: ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/index.ts
Tamaño: 54 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './providers';
export * from './steps';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/providers/generic.schema.ts
Tamaño: 522 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { JsonSchema } from '../../types/schema.types';

/**
 * A permissive schema for untyped providers to use.
 *
 * This schema is used to allow providers to return any output without
 * having to define a schema for each provider.
 *
 * Over time, this schema will be replaced with a more strict schema per provider.
 */
export const genericProviderSchemas = {
  output: {
    type: 'object',
    properties: {},
    required: [],
    additionalProperties: true,
  } as const,
} satisfies { output: JsonSchema };


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/providers/index.ts
Tamaño: 611 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChannelStepEnum } from '../../constants';
import type { JsonSchema } from '../../types/schema.types';
import { chatProviderSchemas } from './chat';
import { emailProviderSchemas } from './email';
import { inAppProviderSchemas } from './inApp';
import { pushProviderSchemas } from './push';
import { smsProviderSchemas } from './sms';

export const providerSchemas = {
  chat: chatProviderSchemas,
  sms: smsProviderSchemas,
  email: emailProviderSchemas,
  push: pushProviderSchemas,
  in_app: inAppProviderSchemas,
} as const satisfies Record<ChannelStepEnum, Record<string, { output: JsonSchema }>>;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/providers/chat/index.ts
Tamaño: 760 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChatProviderIdEnum } from '../../../shared';
import type { JsonSchema } from '../../../types/schema.types';
import { genericProviderSchemas } from '../generic.schema';
import { slackProviderSchemas } from './slack.schema';

export const chatProviderSchemas = {
  'chat-webhook': genericProviderSchemas,
  discord: genericProviderSchemas,
  getstream: genericProviderSchemas,
  'grafana-on-call': genericProviderSchemas,
  mattermost: genericProviderSchemas,
  msteams: genericProviderSchemas,
  'rocket-chat': genericProviderSchemas,
  ryver: genericProviderSchemas,
  slack: slackProviderSchemas,
  'whatsapp-business': genericProviderSchemas,
  zulip: genericProviderSchemas,
} as const satisfies Record<ChatProviderIdEnum, { output: JsonSchema }>;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/providers/chat/slack.schema.ts
Tamaño: 970 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { JsonSchema } from '../../../types/schema.types';

/**
 * Slack message payload schema
 *
 * @see https://api.slack.com/reference/messaging/payload
 */
const slackOutputSchema = {
  type: 'object',
  properties: {
    webhookUrl: {
      type: 'string',
      format: 'uri',
    },
    text: {
      type: 'string',
    },
    blocks: {
      type: 'array',
      items: {
        type: 'object',
        properties: {
          type: {
            enum: [
              'image',
              'context',
              'actions',
              'divider',
              'section',
              'input',
              'file',
              'header',
              'video',
              'rich_text',
            ],
          },
        },
        required: ['type'],
        additionalProperties: true,
      },
    },
  },
  additionalProperties: true,
} as const satisfies JsonSchema;

export const slackProviderSchemas = {
  output: slackOutputSchema,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/providers/email/index.ts
Tamaño: 1373 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EmailProviderIdEnum } from '../../../shared';
import type { JsonSchema } from '../../../types/schema.types';
import { genericProviderSchemas } from '../generic.schema';
import { mailgunProviderSchemas } from './mailgun.schema';
import { mailjetProviderSchemas } from './mailjet.schema';
import { nodemailerProviderSchemas } from './nodemailer.schema';
import { novuEmailProviderSchemas } from './novu-email.schema';
import { sendgridProviderSchemas } from './sendgrid.schema';

export const emailProviderSchemas = {
  braze: genericProviderSchemas,
  clickatell: genericProviderSchemas,
  nodemailer: nodemailerProviderSchemas,
  emailjs: genericProviderSchemas,
  'email-webhook': genericProviderSchemas,
  'infobip-email': genericProviderSchemas,
  mailersend: genericProviderSchemas,
  mailgun: mailgunProviderSchemas,
  mailjet: mailjetProviderSchemas,
  mailtrap: genericProviderSchemas,
  mandrill: genericProviderSchemas,
  netcore: genericProviderSchemas,
  'novu-email': novuEmailProviderSchemas,
  outlook365: genericProviderSchemas,
  plunk: genericProviderSchemas,
  postmark: genericProviderSchemas,
  resend: genericProviderSchemas,
  sendgrid: sendgridProviderSchemas,
  sendinblue: genericProviderSchemas,
  ses: genericProviderSchemas,
  sparkpost: genericProviderSchemas,
} as const satisfies Record<EmailProviderIdEnum, { output: JsonSchema }>;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/providers/email/mailgun.schema.ts
Tamaño: 3430 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { JsonSchema } from '../../../types/schema.types';

/**
 * Mailgun `POST /messages` schema
 *
 * @see https://documentation.mailgun.com/en/latest/api-sending.html#sending
 */
const mailgunOutputSchema = {
  type: 'object',
  properties: {
    to: {
      anyOf: [{ type: 'string' }, { type: 'array', items: { type: 'string' } }],
      description: `Email address of the recipient(s). Example: "Bob bob@host.com". You can use commas to separate multiple recipients (e.g.: "test@example.com,test@example.com" or ["test@example.com", "test@example.com"]).`,
    },
    from: { type: 'string' },
    subject: { type: 'string', description: `Subject of the message.` },
    text: { type: 'string', description: `Text version of the message.` },
    html: { type: 'string', description: `HTML version of the message.` },
    message: {
      type: 'string',
      description: `MIME string of the message. Make sure to use multipart/form-data to send this as a file upload.`,
    },
    cc: {
      anyOf: [{ type: 'string' }, { type: 'array', items: { type: 'string' } }],
      description: `Same as To but for carbon copy`,
    },
    bcc: {
      anyOf: [{ type: 'string' }, { type: 'array', items: { type: 'string' } }],
      description: `Same as To but for blind carbon copy`,
    },
    ampHtml: { type: 'string' },
    tVersion: { type: 'string' },
    tText: {
      anyOf: [{ type: 'string', enum: ['yes', 'no'] }, { type: 'boolean' }],
    },
    oTag: {
      anyOf: [{ type: 'string' }, { type: 'array', items: { type: 'string' } }],
      description: `Tag string. See Tagging for more information.`,
    },
    oDkim: {
      anyOf: [{ type: 'string', enum: ['yes', 'no'] }, { type: 'boolean' }],
      description: `Enables/disabled DKIM signatures on per-message basis. Pass yes or no`,
    },
    oDeliverytime: {
      type: 'string',
      description: `Desired time of delivery. See Date Format. Note: Messages can be scheduled for a maximum of 3 days in the future.`,
    },
    oDeliverytimeOptimizePeriod: { type: 'string' },
    oTimeZoneLocalize: { type: 'string' },
    oTestmode: {
      anyOf: [{ type: 'string', enum: ['yes', 'no'] }, { type: 'boolean' }],
      description: `Enables sending in test mode. Pass yes if needed. See Sending in Test Mode`,
    },
    oTracking: {
      anyOf: [{ type: 'string', enum: ['yes', 'no'] }, { type: 'boolean' }],
      description: `Toggles tracking on a per-message basis, see Tracking Messages for details. Pass yes or no.`,
    },
    oTrackingClicks: {
      anyOf: [{ type: 'string', enum: ['yes', 'no', 'htmlonly'] }, { type: 'boolean' }],
      description: `Toggles clicks tracking on a per-message basis. Has higher priority than domain-level setting. Pass yes, no or htmlonly.`,
    },
    oTrackingOpens: {
      anyOf: [{ type: 'string', enum: ['yes', 'no'] }, { type: 'boolean' }],
      description: `Toggles opens tracking on a per-message basis. Has higher priority than domain-level setting. Pass yes or no.`,
    },
    oRequireTls: {
      anyOf: [{ type: 'string', enum: ['yes', 'no'] }, { type: 'boolean' }],
    },
    oSkipVerification: {
      anyOf: [{ type: 'string', enum: ['yes', 'no'] }, { type: 'boolean' }],
    },
    recipientVariables: { type: 'string' },
  },
  required: [],
  additionalProperties: true,
} as const satisfies JsonSchema;

export const mailgunProviderSchemas = {
  output: mailgunOutputSchema,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/providers/email/mailjet.schema.ts
Tamaño: 3544 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { JsonSchema } from '../../../types/schema.types';

const address = {
  type: 'object',
  properties: {
    name: { type: 'string' },
    email: { type: 'string' },
  },
  description: `JSON object, containing 2 properties: Name and Email address of a previously validated and active sender. Including the Name property in the JSON is optional. This property is not mandatory in case you use TemplateID and you specified a From address for the template. Format : { "Email":"value", "Name":"value" }.`,
  required: ['Email'],
  additionalProperties: true,
} satisfies JsonSchema;

const attachment = {
  type: 'object',
  properties: {
    contentType: { type: 'string' },
    filename: { type: 'string' },
    base64Content: { type: 'string' },
  },
  required: ['ContentType', 'Filename', 'Base64Content'],
  additionalProperties: true,
} satisfies JsonSchema;

const inlineAttatchment = {
  type: 'object',
  properties: {
    filename: { type: 'string' },
    contentType: { type: 'string' },
    contentId: { type: 'string' },
    base64Content: { type: 'string' },
  },
  required: ['ContentType', 'Filename', 'Base64Content'],
  additionalProperties: true,
} satisfies JsonSchema;

/**
 * Mailjet `POST /send` schema
 *
 * @see https://dev.mailjet.com/email/reference/send-emails
 */
const mailjetOutputSchema = {
  type: 'object',
  properties: {
    from: address,
    sender: address,
    to: {
      type: 'array',
      items: address,
    },
    cc: {
      type: 'array',
      items: address,
    },
    bcc: {
      type: 'array',
      items: address,
    },
    replyTo: address,
    subject: { type: 'string' },
    textPart: {
      type: 'string',
      description: `Content of the message, sent in Text and/or HTML format. At least one of these content types needs to be specified. When the HTML part is the only part provided, Mailjet will not generate a Text-part from the HTML version. The property can't be set when you use TemplateID`,
    },
    htmlPart: {
      type: 'string',
      description: `Content of the message, sent in Text and/or HTML format. At least one of these content types needs to be specified. When the HTML part is the only part provided, Mailjet will not generate a Text-part from the HTML version. The property can't be set when you use TemplateID`,
    },
    templateId: {
      type: 'number',
      description: `an ID for a template that is previously created and stored in Mailjet's system. It is mandatory when From and TextPart and/or HtmlPart are not provided. `,
    },
    templateLanguage: { type: 'boolean' },
    templateErrorReporting: address,
    templateErrorDeliver: { type: 'boolean' },
    attachments: {
      type: 'array',
      items: attachment,
    },
    inlineAttachments: {
      type: 'array',
      items: inlineAttatchment,
    },
    priority: { type: 'number' },
    customCampaign: { type: 'string' },
    deduplicateCampaign: { type: 'boolean' },
    trackOpens: {
      type: 'string',
      enum: ['account_default', 'disabled', 'enabled'],
    },
    trackClicks: {
      type: 'string',
      enum: ['account_default', 'disabled', 'enabled'],
    },
    customId: { type: 'string' },
    eventPayload: { type: 'string' },
    urlTags: { type: 'string' },
    headers: { type: 'object', additionalProperties: true },
    variables: { type: 'object', additionalProperties: true },
  },
  required: [],
  additionalProperties: true,
} as const satisfies JsonSchema;

export const mailjetProviderSchemas = {
  output: mailjetOutputSchema,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/providers/email/nodemailer.schema.ts
Tamaño: 3096 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { JsonSchema } from '../../../types/schema.types';

const address = {
  type: 'object',
  properties: {
    address: { type: 'string' },
    name: { type: 'string' },
  },
  additionalProperties: true,
} as const satisfies JsonSchema;

const attachmentLike = {
  type: 'object',
  properties: {
    content: { type: 'string' },
    path: { type: 'string' },
  },
  additionalProperties: true,
} as const satisfies JsonSchema;

/**
 * Nodemailer `sendMail` schema
 *
 * @see https://nodemailer.com/message/
 */
const nodemailerOutputSchema = {
  type: 'object',
  properties: {
    from: { anyOf: [{ type: 'string' }, address] },
    sender: { anyOf: [{ type: 'string' }, address] },
    to: { anyOf: [{ type: 'string' }, address, { type: 'array', items: address }] },
    cc: { anyOf: [{ type: 'string' }, address, { type: 'array', items: address }] },
    bcc: { anyOf: [{ type: 'string' }, address, { type: 'array', items: address }] },
    replyTo: { anyOf: [{ type: 'string' }, address, { type: 'array', items: address }] },
    inReplyTo: { anyOf: [{ type: 'string' }, address] },
    references: { anyOf: [{ type: 'string' }, { type: 'array', items: { type: 'string' } }] },
    subject: { type: 'string' },
    text: { anyOf: [{ type: 'string' }, attachmentLike] },
    html: { anyOf: [{ type: 'string' }, attachmentLike] },
    watchHtml: { anyOf: [{ type: 'string' }, attachmentLike] },
    amp: {
      anyOf: [
        { type: 'string' },
        {
          type: 'object',
          properties: {
            content: { type: 'string' },
            path: { type: 'string' },
            href: { type: 'string' },
            encoding: { type: 'string' },
            contentType: { type: 'string' },
            raw: { anyOf: [{ type: 'string' }, attachmentLike] },
          },
        },
      ],
    },
    icalEvent: {
      anyOf: [
        { type: 'string' },
        {
          type: 'object',
          properties: {
            content: { type: 'string' },
            path: { type: 'string' },
            method: { type: 'string' },
            filename: { anyOf: [{ type: 'string' }, { type: 'boolean' }] },
            href: { type: 'string' },
            encoding: { type: 'string' },
          },
        },
      ],
    },
    headers: {
      anyOf: [
        { type: 'object', additionalProperties: true },
        {
          type: 'array',
          items: {
            type: 'object',
            additionalProperties: true,
          },
        },
      ],
    },
    list: {
      anyOf: [
        { type: 'string' },
        {
          type: 'array',
          items: {
            type: 'string',
          },
        },
      ],
    },
    attachments: {
      type: 'array',
      items: {
        type: 'object',
        properties: {
          content: { type: 'string' },
          path: { type: 'string' },
        },
        additionalProperties: true,
      },
    },
  },
  required: [],
  additionalProperties: true,
} as const satisfies JsonSchema;

export const nodemailerProviderSchemas = {
  output: nodemailerOutputSchema,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/providers/email/novu-email.schema.ts
Tamaño: 320 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { JsonSchema } from '../../../types/schema.types';

/**
 * Novu email schema
 */
const novuEmailOutputSchema = {
  type: 'object',
  properties: {},
  required: [],
  additionalProperties: false,
} as const satisfies JsonSchema;

export const novuEmailProviderSchemas = {
  output: novuEmailOutputSchema,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/providers/email/sendgrid.schema.ts
Tamaño: 22355 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { JsonSchema } from '../../../types/schema.types';

/**
 * Sendgrid `POST /v3/mail/send` schema
 *
 * @see https://www.twilio.com/docs/sendgrid/api-reference/mail-send
 */
const sendgridOutputSchema = {
  type: 'object',
  properties: {
    personalizations: {
      type: 'array',
      description:
        'An array of messages and their metadata. Each object within personalizations can be thought of as an envelope - it defines who should receive an individual message and how that message should be handled. See our [Personalizations documentation](https://sendgrid.com/docs/for-developers/sending-email/personalizations/) for examples.',
      uniqueItems: false,
      maxItems: 1000,
      items: {
        type: 'object',
        properties: {
          from: {
            title: 'From Email Object',
            type: 'object',
            properties: {
              email: {
                type: 'string',
                format: 'email',
                description:
                  "The 'From' email address used to deliver the message. This address should be a verified sender in your Twilio SendGrid account.",
              },
              name: {
                type: 'string',
                description: 'A name or title associated with the sending email address.',
              },
            },
            required: ['email'],
          },
          to: {
            title: 'To Email Array',
            type: 'array',
            items: {
              type: 'object',
              properties: {
                email: {
                  type: 'string',
                  format: 'email',
                  description: "The intended recipient's email address.",
                },
                name: {
                  type: 'string',
                  description: "The intended recipient's name.",
                },
              },
              required: ['email'],
            },
          },
          cc: {
            type: 'array',
            description:
              "An array of recipients who will receive a copy of your email. Each object in this array must contain the recipient's email address. Each object in the array may optionally contain the recipient's name.",
            maxItems: 1000,
            items: {
              title: 'CC BCC Email Object',
              type: 'object',
              properties: {
                email: {
                  type: 'string',
                  format: 'email',
                  description: "The intended recipient's email address.",
                },
                name: {
                  type: 'string',
                  description: "The intended recipient's name.",
                },
              },
              required: ['email'],
            },
          },
          bcc: {
            type: 'array',
            description:
              "An array of recipients who will receive a blind carbon copy of your email. Each object in this array must contain the recipient's email address. Each object in the array may optionally contain the recipient's name.",
            maxItems: 1000,
            items: {
              title: 'CC BCC Email Object',
              type: 'object',
              properties: {
                email: {
                  type: 'string',
                  format: 'email',
                  description: "The intended recipient's email address.",
                },
                name: {
                  type: 'string',
                  description: "The intended recipient's name.",
                },
              },
              required: ['email'],
            },
          },
          subject: {
            type: 'string',
            description:
              'The subject of your email. See character length requirements according to [RFC 2822](http://stackoverflow.com/questions/1592291/what-is-the-email-subject-length-limit#answer-1592310).',
            minLength: 1,
          },
          headers: {
            type: 'object',
            description:
              'A collection of JSON key/value pairs allowing you to specify handling instructions for your email. You may not overwrite the following headers: `x-sg-id`, `x-sg-eid`, `received`, `dkim-signature`, `Content-Type`, `Content-Transfer-Encoding`, `To`, `From`, `Subject`, `Reply-To`, `CC`, `BCC`',
          },
          substitutions: {
            type: 'object',
            description:
              'Substitutions allow you to insert data without using Dynamic Transactional Templates. This field should **not** be used in combination with a Dynamic Transactional Template, which can be identified by a `templateId` starting with `d-`. This field is a collection of key/value pairs following the pattern "substitutionTag":"value to substitute". The key/value pairs must be strings. These substitutions will apply to the text and html content of the body of your email, in addition to the `subject` and `reply-to` parameters. The total collective size of your substitutions may not exceed 10,000 bytes per personalization object.',
            maxProperties: 10000,
          },
          dynamicTemplateData: {
            type: 'object',
            description:
              'Dynamic template data is available using Handlebars syntax in Dynamic Transactional Templates. This field should be used in combination with a Dynamic Transactional Template, which can be identified by a `templateId` starting with `d-`. This field is a collection of key/value pairs following the pattern "variable_name":"value to insert".',
          },
          customArgs: {
            type: 'object',
            description:
              'Values that are specific to this personalization that will be carried along with the email and its activity data. Substitutions will not be made on custom arguments, so any string that is entered into this parameter will be assumed to be the custom argument that you would like to be used. This field may not exceed 10,000 bytes.',
            maxProperties: 10000,
          },
          sendAt: {
            type: 'integer',
            description:
              'A unix timestamp allowing you to specify when your email should be delivered. Scheduling delivery more than 72 hours in advance is forbidden.',
          },
        },
        required: ['to'],
      },
    },
    from: {
      title: 'From Email Object',
      type: 'object',
      properties: {
        email: {
          type: 'string',
          format: 'email',
          description:
            "The 'From' email address used to deliver the message. This address should be a verified sender in your Twilio SendGrid account.",
        },
        name: {
          type: 'string',
          description: 'A name or title associated with the sending email address.',
        },
      },
      required: ['email'],
    },
    replyTo: {
      title: 'Reply_to Email Object',
      type: 'object',
      properties: {
        email: {
          type: 'string',
          format: 'email',
          description: 'The email address where any replies or bounces will be returned.',
        },
        name: {
          type: 'string',
          description: 'A name or title associated with the `replyTo` email address.',
        },
      },
      required: ['email'],
    },
    replyToList: {
      type: 'array',
      description:
        "An array of recipients who will receive replies and/or bounces. Each object in this array must contain the recipient's email address. Each object in the array may optionally contain the recipient's name. You can either choose to use “replyTo” field or “replyToList” but not both.",
      uniqueItems: true,
      maxItems: 1000,
      items: {
        type: 'object',
        properties: {
          email: {
            type: 'string',
            description: 'The email address where any replies or bounces will be returned.',
            format: 'email',
          },
          name: {
            type: 'string',
            description: 'A name or title associated with the `replyToList` email address.',
          },
        },
        required: ['email'],
      },
    },
    subject: {
      type: 'string',
      description:
        "The global or 'message level' subject of your email. This may be overridden by subject lines set in personalizations.",
      minLength: 1,
    },
    content: {
      type: 'array',
      description:
        'An array where you can specify the content of your email. You can include multiple [MIME types](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types) of content, but you must specify at least one MIME type. To include more than one MIME type, add another object to the array containing the `type` and `value` parameters.',
      items: {
        type: 'object',
        properties: {
          type: {
            type: 'string',
            description:
              'The MIME type of the content you are including in your email (e.g., `“text/plain”` or `“text/html”`).',
            minLength: 1,
          },
          value: {
            type: 'string',
            description: 'The actual content of the specified MIME type that you are including in your email.',
            minLength: 1,
          },
        },
        required: ['type', 'value'],
      },
    },
    attachments: {
      type: 'array',
      description: 'An array of objects where you can specify any attachments you want to include.',
      items: {
        type: 'object',
        properties: {
          content: {
            type: 'string',
            description: 'The Base64 encoded content of the attachment.',
            minLength: 1,
          },
          type: {
            type: 'string',
            description: 'The MIME type of the content you are attaching (e.g., `“text/plain”` or `“text/html”`).',
            minLength: 1,
          },
          filename: {
            type: 'string',
            description: "The attachment's filename.",
          },
          disposition: {
            type: 'string',
            default: 'attachment',
            description:
              "The attachment's content-disposition, specifying how you would like the attachment to be displayed. For example, `“inline”` results in the attached file are displayed automatically within the message while `“attachment”` results in the attached file require some action to be taken before it is displayed, such as opening or downloading the file.",
            enum: ['inline', 'attachment'],
          },
          contentId: {
            type: 'string',
            description:
              "The attachment's content ID. This is used when the disposition is set to `“inline”` and the attachment is an image, allowing the file to be displayed within the body of your email.",
          },
        },
        required: ['content', 'filename'],
      },
    },
    templateId: {
      type: 'string',
      description:
        'An email template ID. A template that contains a subject and content — either text or html — will override any subject and content values specified at the personalizations or message level.',
    },
    headers: {
      description:
        'An object containing key/value pairs of header names and the value to substitute for them. The key/value pairs must be strings. You must ensure these are properly encoded if they contain unicode characters. These headers cannot be one of the reserved headers.',
      type: 'object',
    },
    categories: {
      type: 'array',
      description: 'An array of category names for this message. Each category name may not exceed 255 characters. ',
      uniqueItems: true,
      maxItems: 10,
      items: {
        type: 'string',
        maxLength: 255,
      },
    },
    customArgs: {
      description:
        'Values that are specific to the entire send that will be carried along with the email and its activity data.  Key/value pairs must be strings. Substitutions will not be made on custom arguments, so any string that is entered into this parameter will be assumed to be the custom argument that you would like to be used. This parameter is overridden by `customArgs` set at the personalizations level. Total `customArgs` size may not exceed 10,000 bytes.',
      type: 'string',
    },
    sendAt: {
      type: 'integer',
      description:
        "A unix timestamp allowing you to specify when you want your email to be delivered. This may be overridden by the `sendAt` parameter set at the personalizations level. Delivery cannot be scheduled more than 72 hours in advance. If you have the flexibility, it's better to schedule mail for off-peak times. Most emails are scheduled and sent at the top of the hour or half hour. Scheduling email to avoid peak times — for example, scheduling at 10:53 — can result in lower deferral rates due to the reduced traffic during off-peak times.",
    },
    batchId: {
      type: 'string',
      description:
        'An ID representing a batch of emails to be sent at the same time. Including a `batchId` in your request allows you include this email in that batch. It also enables you to cancel or pause the delivery of that batch. For more information, see the [Cancel Scheduled Sends API](https://sendgrid.com/docs/api-reference/).',
    },
    asm: {
      type: 'object',
      description: 'An object allowing you to specify how to handle unsubscribes.',
      properties: {
        groupId: {
          type: 'integer',
          description: 'The unsubscribe group to associate with this email.',
        },
        groupsToDisplay: {
          type: 'array',
          description:
            'An array containing the unsubscribe groups that you would like to be displayed on the unsubscribe preferences page.',
          maxItems: 25,
          items: {
            type: 'integer',
          },
        },
      },
      required: ['groupId'],
    },
    ipPoolName: {
      type: 'string',
      description: 'The IP Pool that you would like to send this email from.',
      minLength: 2,
      maxLength: 64,
    },
    mailSettings: {
      type: 'object',
      description:
        'A collection of different mail settings that you can use to specify how you would like this email to be handled.',
      properties: {
        bypassListManagement: {
          type: 'object',
          description:
            'Allows you to bypass all unsubscribe groups and suppressions to ensure that the email is delivered to every single recipient. This should only be used in emergencies when it is absolutely necessary that every recipient receives your email. This filter cannot be combined with any other bypass filters. See our [documentation](https://sendgrid.com/docs/ui/sending-email/index-suppressions/#bypass-suppressions) for more about bypass filters.',
          properties: {
            enable: {
              type: 'boolean',
              description: 'Indicates if this setting is enabled.',
            },
          },
        },
        bypassSpamManagement: {
          type: 'object',
          description:
            'Allows you to bypass the spam report list to ensure that the email is delivered to recipients. Bounce and unsubscribe lists will still be checked; addresses on these other lists will not receive the message. This filter cannot be combined with the `bypassListManagement` filter. See our [documentation](https://sendgrid.com/docs/ui/sending-email/index-suppressions/#bypass-suppressions) for more about bypass filters.',
          properties: {
            enable: {
              type: 'boolean',
              description: 'Indicates if this setting is enabled.',
            },
          },
        },
        bypassBounceManagement: {
          type: 'object',
          description:
            'Allows you to bypass the bounce list to ensure that the email is delivered to recipients. Spam report and unsubscribe lists will still be checked; addresses on these other lists will not receive the message. This filter cannot be combined with the `bypassListManagement` filter. See our [documentation](https://sendgrid.com/docs/ui/sending-email/index-suppressions/#bypass-suppressions) for more about bypass filters.',
          properties: {
            enable: {
              type: 'boolean',
              description: 'Indicates if this setting is enabled.',
            },
          },
        },
        bypassUnsubscribeManagement: {
          type: 'object',
          description:
            'Allows you to bypass the global unsubscribe list to ensure that the email is delivered to recipients. Bounce and spam report lists will still be checked; addresses on these other lists will not receive the message. This filter applies only to global unsubscribes and will not bypass group unsubscribes. This filter cannot be combined with the `bypassListManagement` filter. See our [documentation](https://sendgrid.com/docs/ui/sending-email/index-suppressions/#bypass-suppressions) for more about bypass filters.',
          properties: {
            enable: {
              type: 'boolean',
              description: 'Indicates if this setting is enabled.',
            },
          },
        },
        footer: {
          type: 'object',
          description: 'The default footer that you would like included on every email.',
          properties: {
            enable: {
              type: 'boolean',
              description: 'Indicates if this setting is enabled.',
            },
            text: {
              type: 'string',
              description: 'The plain text content of your footer.',
            },
            html: {
              type: 'string',
              description: 'The HTML content of your footer.',
            },
          },
        },
        sandboxMode: {
          type: 'object',
          description:
            'Sandbox Mode allows you to send a test email to ensure that your request body is valid and formatted correctly.',
          properties: {
            enable: {
              type: 'boolean',
              description: 'Indicates if this setting is enabled.',
            },
          },
        },
      },
    },
    trackingSettings: {
      type: 'object',
      description:
        'Settings to determine how you would like to track the metrics of how your recipients interact with your email.',
      properties: {
        clickTracking: {
          type: 'object',
          description: 'Allows you to track if a recipient clicked a link in your email.',
          properties: {
            enable: {
              type: 'boolean',
              description: 'Indicates if this setting is enabled.',
            },
            enableText: {
              type: 'boolean',
              description: 'Indicates if this setting should be included in the `text/plain` portion of your email.',
            },
          },
        },
        openTracking: {
          type: 'object',
          description:
            'Allows you to track if the email was opened by including a single pixel image in the body of the content. When the pixel is loaded, Twilio SendGrid can log that the email was opened.',
          properties: {
            enable: {
              type: 'boolean',
              description: 'Indicates if this setting is enabled.',
            },
            substitutionTag: {
              type: 'string',
              description:
                'Allows you to specify a substitution tag that you can insert in the body of your email at a location that you desire. This tag will be replaced by the open tracking pixel.',
            },
          },
        },
        subscriptionTracking: {
          type: 'object',
          description:
            'Allows you to insert a subscription management link at the bottom of the text and HTML bodies of your email. If you would like to specify the location of the link within your email, you may use the `substitutionTag`.',
          properties: {
            enable: {
              type: 'boolean',
              description: 'Indicates if this setting is enabled.',
            },
            text: {
              type: 'string',
              description:
                'Text to be appended to the email with the subscription tracking link. You may control where the link is by using the tag <% %>',
            },
            html: {
              type: 'string',
              description:
                'HTML to be appended to the email with the subscription tracking link. You may control where the link is by using the tag <% %>',
            },
            substitutionTag: {
              type: 'string',
              description:
                'A tag that will be replaced with the unsubscribe URL. for example: `[unsubscribe_url]`. If this parameter is used, it will override both the `text` and `html` parameters. The URL of the link will be placed at the substitution tag’s location with no additional formatting.',
            },
          },
        },
        ganalytics: {
          type: 'object',
          description: 'Allows you to enable tracking provided by Google Analytics.',
          properties: {
            enable: {
              type: 'boolean',
              description: 'Indicates if this setting is enabled.',
            },
            utmSource: {
              type: 'string',
              description: 'Name of the referrer source. (e.g. Google, SomeDomain.com, or Marketing Email)',
            },
            utmMedium: {
              type: 'string',
              description: 'Name of the marketing medium. (e.g. Email)',
            },
            utmTerm: {
              type: 'string',
              description: 'Used to identify any paid keywords.',
            },
            utmContent: {
              type: 'string',
              description: 'Used to differentiate your campaign from advertisements.',
            },
            utmCampaign: {
              type: 'string',
              description: 'The name of the campaign.',
            },
          },
        },
      },
    },
  },
  required: [],
  additionalProperties: false,
} as const satisfies JsonSchema;

export const sendgridProviderSchemas = {
  output: sendgridOutputSchema,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/providers/inApp/index.ts
Tamaño: 329 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { InAppProviderIdEnum } from '../../../shared';
import type { JsonSchema } from '../../../types/schema.types';
import { novuInAppProviderSchemas } from './novu-inapp.schema';

export const inAppProviderSchemas = {
  novu: novuInAppProviderSchemas,
} as const satisfies Record<InAppProviderIdEnum, { output: JsonSchema }>;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/providers/inApp/novu-inapp.schema.ts
Tamaño: 321 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { JsonSchema } from '../../../types/schema.types';

/**
 * Novu in-app schema
 */
const novuInAppOutputSchema = {
  type: 'object',
  properties: {},
  required: [],
  additionalProperties: false,
} as const satisfies JsonSchema;

export const novuInAppProviderSchemas = {
  output: novuInAppOutputSchema,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/providers/push/apns.schema.ts
Tamaño: 4072 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { JsonSchema } from '../../../types/schema.types';

const sound = {
  anyOf: [
    { type: 'string' },
    {
      type: 'object',
      additionalProperties: true,
      properties: { name: { type: 'string' }, volume: { type: 'number' }, critical: { type: 'number' } },
      required: ['name', 'volume', 'critical'],
    },
  ],
} satisfies JsonSchema;

/**
 * APNS `POST /3/device/{device_token}` schema
 *
 * @see https://developer.apple.com/documentation/usernotifications/sending-notification-requests-to-apns
 */
const apnsOutputSchema = {
  type: 'object',
  properties: {
    topic: { type: 'string', description: `The destination topic for the notification.` },
    id: {
      type: 'string',
      description: `A UUID to identify the notification with APNS. If an id is not supplied, APNS will generate one automatically. If an error occurs the response will contain the id. This property populates the apns-id header.`,
    },
    expiry: {
      type: 'number',
      description: `A UNIX timestamp when the notification should expire. If the notification cannot be delivered to the device, APNS will retry until it expires. An expiry of 0 indicates that the notification expires immediately, therefore no retries will be attempted.`,
    },
    priority: {
      type: 'number',
      description: `Provide one of the following values:

10 - The push notification is sent to the device immediately. (Default)
The push notification must trigger an alert, sound, or badge on the device. It is an error to use this priority for a push notification that contains only the content-available key.

5 - The push message is sent at a time that conserves power on the device receiving it.`,
    },
    collapseId: { type: 'string' },
    pushType: {
      type: 'string',
      enum: ['background', 'alert', 'voip'],
      description: `The type of the notification. The value of this header is alert or background. Specify alert when the delivery of your notification displays an alert, plays a sound, or badges your app's icon. Specify background for silent notifications that do not interact with the user.

The value of this header must accurately reflect the contents of your notification's payload. If there is a mismatch, or if the header is missing on required systems, APNs may delay the delivery of the notification or drop it altogether.`,
    },
    threadId: { type: 'string' },
    payload: { type: 'object', additionalProperties: true },
    aps: {
      type: 'object',
      additionalProperties: true,
      properties: {
        badge: { type: 'number' },
        sound,
        category: { type: 'string' },
        contentAvailable: { type: 'number' },
        launchImage: { type: 'number' },
        mutableContent: { type: 'number' },
        urlArgs: { type: 'array', items: { type: 'string' } },
      },
    },
    rawPayload: { type: 'object', additionalProperties: true },
    badge: { type: 'number' },
    sound,
    alert: {
      anyOf: [
        { type: 'string' },
        {
          type: 'object',
          additionalProperties: true,
          properties: {
            title: { type: 'string' },
            body: { type: 'string' },
            subtitle: { type: 'string' },
            titleLocKey: { type: 'string' },
            titleLocArgs: { type: 'array', items: { type: 'string' } },
            actionLocKey: { type: 'string' },
            locKey: { type: 'string' },
            locArgs: { type: 'array', items: { type: 'string' } },
            launchImage: { type: 'string' },
          },
          required: ['body'],
        },
      ],
    },
    contentAvailable: { type: 'boolean' },
    mutableContent: { type: 'boolean' },
    mdm: {
      anyOf: [
        { type: 'string' },
        {
          type: 'object',
          additionalProperties: true,
        },
      ],
    },
    urlArgs: { type: 'array', items: { type: 'string' } },
  },
  required: [],
  additionalProperties: true,
} as const satisfies JsonSchema;

export const apnsProviderSchemas = {
  output: apnsOutputSchema,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/providers/push/expo.schema.ts
Tamaño: 3544 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { JsonSchema } from '../../../types/schema.types';

/**
 * Expo `POST /v2/push/send` schema
 *
 * @see https://docs.expo.dev/push-notifications/sending-notifications/
 */
const expoOutputSchema = {
  type: 'object',
  properties: {
    to: {
      anyOf: [{ type: 'string' }, { type: 'array', items: { type: 'string' } }],
      description: `An Expo push token or an array of Expo push tokens specifying the recipient(s) of this message.`,
    },
    data: {
      type: 'object',
      additionalProperties: true,
      description: `A JSON object delivered to your app. It may be up to about 4KiB; the total notification payload sent to Apple and Google must be at most 4KiB or else you will get a "Message Too Big" error.`,
    },
    title: {
      type: 'string',
      description: `The title to display in the notification. Often displayed above the notification body.`,
    },
    subtitle: { type: 'string', description: `The subtitle to display in the notification below the title.` },
    body: { type: 'string', description: `The message to display in the notification.` },
    sound: {
      anyOf: [
        { type: 'string' },
        { type: 'null' },
        {
          type: 'object',
          properties: {
            name: { anyOf: [{ type: 'string', enum: ['default'] }, { type: 'null' }] },
            volume: { type: 'number' },
            critical: { type: 'boolean' },
          },
          additionalProperties: true,
        },
      ],
      description: `Play a sound when the recipient receives this notification. Specify default to play the device's default notification sound, or omit this field to play no sound. Custom sounds are not supported.`,
    },
    ttl: {
      type: 'number',
      description: `Time to Live: the number of seconds for which the message may be kept around for redelivery if it hasn't been delivered yet. Defaults to undefined to use the respective defaults of each provider (2419200 (4 weeks) for Android/FCM and 0 for iOS/APNs).`,
    },
    expiration: {
      type: 'number',
      description: `Timestamp since the Unix epoch specifying when the message expires. Same effect as ttl (ttl takes precedence over expiration).`,
    },
    priority: {
      type: 'string',
      enum: ['default', 'normal', 'high'],
      description: `The delivery priority of the message. Specify default or omit this field to use the default priority on each platform ("normal" on Android and "high" on iOS).`,
    },
    badge: {
      type: 'number',
      description: `Number to display in the badge on the app icon. Specify zero to clear the badge.`,
    },
    channelId: {
      type: 'string',
      description: `ID of the Notification Channel through which to display this notification. If an ID is specified but the corresponding channel does not exist on the device (that has not yet been created by your app), the notification will not be displayed to the user.`,
    },
    categoryId: {
      type: 'string',
      description: `ID of the notification category that this notification is associated with.`,
    },
    mutableContent: {
      type: 'boolean',
      description: `Specifies whether this notification can be intercepted by the client app. In Expo Go, this defaults to true, and if you change that to false, you may experience issues. In standalone and bare apps, this defaults to false.`,
    },
  },
  required: [],
  additionalProperties: true,
} as const satisfies JsonSchema;

export const expoProviderSchemas = {
  output: expoOutputSchema,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/providers/push/fcm.schema.ts
Tamaño: 9995 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { JsonSchema } from '../../../types/schema.types';

/**
 * FCM `send` schema
 *
 * @see https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages/send
 */
const fcmOutputSchema = {
  type: 'object',
  properties: {
    to: {
      description:
        'This parameter specifies the recipient of a message.\nThe value must be a registration token, notification key, or topic. Do not set this field when sending to multiple topics. See **condition**.\n',
      type: 'string',
    },
    registrationIds: {
      description:
        'This parameter specifies a list of devices (registration tokens, or IDs) receiving a multicast message. It must contain at least 1 and at most 1000 registration tokens.\nUse this parameter only for multicast messaging, not for single recipients. Multicast messages (sending to more than 1 registration tokens) are allowed using HTTP JSON format only.\n',
      type: 'array',
      items: {
        type: 'string',
      },
    },
    condition: {
      description:
        'This parameter specifies a logical expression of conditions that determine the message target.\nSupported condition: Topic, formatted as yourTopic in topics. This value is case-insensitive.\nSupported operators: &&, ||. Maximum two operators per topic message supported.\n',
      type: 'string',
    },
    notificationKey: {
      description:
        'This parameter is deprecated. Instead, use **to** to specify message recipients. For more information on how to send messages to multiple devices using **to**, see [Device Group Messaging](https://firebase.google.com/docs/cloud-messaging/notifications).\n',
      type: 'string',
    },
    collapseKey: {
      description:
        'This parameter identifies a group of messages (e.g., with ```"collapseKey": "Updates Available"```) that can be collapsed, so that only the last message gets sent when delivery can be resumed. This is intended to avoid sending too many of the same messages when the device comes back online or becomes active (see **delayWhileIdle**).\nNote that there is no guarantee of the order in which messages get sent.\nNote: A maximum of 4 different collapse keys is allowed at any given time. This means a FCM connection server can simultaneously store 4 different send-to-sync messages per client app. If you exceed this number, there is no guarantee which 4 collapse keys the FCM connection server will keep.\n',
      type: 'string',
    },
    priority: {
      description:
        "Sets the priority of the message. Valid values are normal and high. On iOS, these correspond to APNs priorities 5 and 10.\nBy default, messages are sent with normal priority. Normal priority optimizes the client app's battery consumption and should be used unless immediate delivery is required. For messages with normal priority, the app may receive the message with unspecified delay.\nWhen a message is sent with high priority, it is sent immediately, and the app can wake a sleeping device and open a network connection to your server.For more information, see [Setting the priority of a message](https://firebase.google.com/docs/cloud-messaging/concept-options#setting-the-priority-of-a-message).\n",
      type: 'string',
      enum: ['normal', 'high'],
    },
    contentAvailable: {
      description:
        'On iOS, use this field to represent **content-available** in the APNS payload. When a notification or message is sent and this is set to ```true```, an inactive client app is awoken. On Android, data messages wake the app by default. On Chrome, currently not supported.\n',
      type: 'boolean',
    },
    mutableContent: {
      description:
        'Currently for iOS 10+ devices only. On iOS, use this field to represent mutable-content in the APNS payload. When a notification is sent and this is set to true, the content of the notification can be modified before it is displayed, using a [Notification Service app extension](https://developer.apple.com/reference/usernotifications/unnotificationserviceextension). This parameter will be ignored for Android and web.\n',
      type: 'boolean',
    },
    delayWhileIdle: {
      description:
        'When this parameter is set to ```true```, it indicates that the message should not be sent until the device becomes active.\nThe default value is ```false```.\n',
      type: 'boolean',
    },
    timeToLive: {
      description:
        'This parameter specifies how long (in seconds) the message should be kept in FCM storage if the device is offline. The maximum time to live supported is 4 weeks, and the default value is 4 weeks. For more information, see [Setting the lifespan of a message](https://firebase.google.com/docs/cloud-messaging/concept-options#ttl).\n',
      type: 'number',
    },
    restrictedPackageName: {
      description:
        'This parameter specifies the package name of the application where the registration tokens must match in order to receive the message.\n',
      type: 'string',
    },
    dryRun: {
      description:
        'This parameter, when set to ```true```, allows developers to test a request without actually sending a message.\nThe default value is ```false```.\n',
      type: 'boolean',
    },
    data: {
      description:
        'This parameter specifies the custom key-value pairs of the message\'s payload.\nFor example, with ```"data":{"score":"3x1"}```:\nOn iOS, if the message is sent via APNS, it represents the custom data fields. If it is sent via FCM connection server, it would be represented as key value dictionary in ```AppDelegate application:didReceiveRemoteNotification:```.\nOn Android, this would result in an intent extra named **score** with the string value **3x1**.\nThe key should not be a reserved word ("from" or any word starting with "google" or "gcm"). Do not use any of the words defined in this table (such as **collapseKey**).\n',
      type: 'object',
      additionalProperties: {
        type: 'string',
      },
    },
    notification: {
      description:
        'Notification payload. For more information about notification message and data message options, see [Payload](https://firebase.google.com/docs/cloud-messaging/concept-options#notifications_and_data_messages).\n',
      type: 'object',
      properties: {
        title: {
          description:
            'Indicates notification title. This field is not visible on iOS phones and tablets. Field is required for android.',
          type: 'string',
        },
        body: {
          description: 'Indicates notification body text.',
          type: 'string',
        },
        icon: {
          description:
            'android: Indicates notification icon. Sets value to **myicon** for drawable resource **myicon**.',
          type: 'string',
        },
        sound: {
          description:
            "Indicates a sound to play when the device receives a notification.\n* iOS: Sound files can be in the main bundle of the client app or in the Library/Sounds folder of the app's data container. See the [iOS Developer Library](https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/IPhoneOSClientImp.html#//apple_ref/doc/uid/TP40008194-CH103-SW6) for more information).\n* android: Supports default or the filename of a sound resource bundled in the app. Sound files must reside in /res/raw/.\n",
          type: 'string',
        },
        badge: {
          description: 'iOS: Indicates the badge on the client app home icon.',
          type: 'string',
        },
        tag: {
          description:
            'android: Indicates whether each notification results in a new entry in the notification drawer.\nIf not set, each request creates a new notification.\nIf set, and a notification with the same tag is already being shown, the new notification replaces the existing one in the notification drawer.\n',
          type: 'string',
        },
        color: {
          description: 'android: Indicates color of the icon, expressed in #rrggbb format',
          type: 'string',
        },
        clickAction: {
          description:
            'Indicates the action associated with a user click on the notification.\n* iOS:  Corresponds to category in the APNs payload.\n* android: When this is set, an activity with a matching intent filter is launched when user clicks the notification.\n',
          type: 'string',
        },
        bodyLocKey: {
          description:
            'Indicates the key to the body string for localization.\n* iOS: Corresponds to "loc-key" in the APNs payload.\n* android: Use the key in the app\'s string resources when populating this value.\n',
          type: 'string',
        },
        bodyLocArgs: {
          description:
            'Indicates the string value to replace format specifiers in the body string for localization.\n* iOS: Corresponds to "loc-args" in the APNs payload.\n* android:  See [Formatting and Styling](https://developer.android.com/guide/topics/resources/string-resource.html#FormattingAndStyling).\n',
          type: 'string',
        },
        titleLocKey: {
          description:
            'Indicates the key to the title string for localization.\n* iOS: Corresponds to "title-loc-key" in the APNs payload.\n* android:  Use the key in the app\'s string resources when populating this value.\n',
          type: 'string',
        },
        titleLocArgs: {
          description:
            'Indicates the string value to replace format specifiers in the title string for localization.\n* iOS: Corresponds to "title-loc-args" in the APNs payload.\n* android: See [Formatting strings](https://developer.android.com/guide/topics/resources/string-resource.html#FormattingAndStyling).\n',
          type: 'string',
        },
      },
    },
  },
  required: [],
  additionalProperties: true,
} as const satisfies JsonSchema;

export const fcmProviderSchemas = {
  output: fcmOutputSchema,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/providers/push/index.ts
Tamaño: 753 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { PushProviderIdEnum } from '../../../shared';
import type { JsonSchema } from '../../../types/schema.types';
import { genericProviderSchemas } from '../generic.schema';
import { apnsProviderSchemas } from './apns.schema';
import { expoProviderSchemas } from './expo.schema';
import { fcmProviderSchemas } from './fcm.schema';
import { oneSignalProviderSchema } from './one-signal.schema';

export const pushProviderSchemas = {
  apns: apnsProviderSchemas,
  expo: expoProviderSchemas,
  fcm: fcmProviderSchemas,
  'one-signal': oneSignalProviderSchema,
  'pusher-beams': genericProviderSchemas,
  pushpad: genericProviderSchemas,
  'push-webhook': genericProviderSchemas,
} as const satisfies Record<PushProviderIdEnum, { output: JsonSchema }>;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/providers/push/one-signal.schema.ts
Tamaño: 68597 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { JsonSchema } from '../../../types/schema.types';

/**
 * OneSignal `POST /notifications` schema
 *
 * @see https://documentation.onesignal.com/reference/create-notification
 */
const oneSignalOutputSchema = {
  allOf: [
    {
      allOf: [
        {
          anyOf: [
            {
              type: 'object',
              properties: {
                includedSegments: {
                  type: 'array',
                  description:
                    'The segment names you want to target. Users in these segments will receive a notification. This targeting parameter is only compatible with excludedSegments.\nExample: ["Active Users", "Inactive Users"]\n',
                  items: {
                    type: 'string',
                  },
                },
                excludedSegments: {
                  type: 'array',
                  description:
                    'Segment that will be excluded when sending. Users in these segments will not receive a notification, even if they were included in includedSegments. This targeting parameter is only compatible with includedSegments.\nExample: ["Active Users", "Inactive Users"]\n',
                  items: {
                    type: 'string',
                  },
                },
              },
            },
            {
              type: 'object',
              properties: {
                includePlayerIds: {
                  type: 'array',
                  description:
                    'Specific playerids to send your notification to. _Does not require API Auth Key.\nDo not combine with other targeting parameters. Not compatible with any other targeting parameters.\nExample: ["1dd608f2-c6a1-11e3-851d-000c2940e62c"]\nLimit of 2,000 entries per REST API call\n',
                  items: {
                    type: 'string',
                  },
                  nullable: true,
                },
                includeExternalUserIds: {
                  type: 'array',
                  description:
                    'Target specific devices by custom user IDs assigned via API.\nNot compatible with any other targeting parameters\nExample: ["custom-id-assigned-by-api"]\nREQUIRED: REST API Key Authentication\nLimit of 2,000 entries per REST API call.\nNote: If targeting push, email, or sms subscribers with same ids, use with channelForExternalUserIds to indicate you are sending a push or email or sms.\n',
                  items: {
                    type: 'string',
                  },
                  nullable: true,
                },
                includeEmailTokens: {
                  type: 'array',
                  description:
                    'Recommended for Sending Emails - Target specific email addresses.\nIf an email does not correspond to an existing user, a new user will be created.\nExample: nick@catfac.ts\nLimit of 2,000 entries per REST API call\n',
                  items: {
                    type: 'string',
                  },
                },
                includePhoneNumbers: {
                  type: 'array',
                  description:
                    'Recommended for Sending SMS - Target specific phone numbers. The phone number should be in the E.164 format. Phone number should be an existing subscriber on OneSignal. Refer our docs to learn how to add phone numbers to OneSignal.\nExample phone number: +1999999999\nLimit of 2,000 entries per REST API call\n',
                  items: {
                    type: 'string',
                  },
                },
                includeIosTokens: {
                  type: 'array',
                  description:
                    'Not Recommended: Please consider using includePlayerIds or includeExternalUserIds instead.\nTarget using iOS device tokens.\nWarning: Only works with Production tokens.\nAll non-alphanumeric characters must be removed from each token. If a token does not correspond to an existing user, a new user will be created.\nExample: ce777617da7f548fe7a9ab6febb56cf39fba6d38203...\nLimit of 2,000 entries per REST API call\n',
                  items: {
                    type: 'string',
                  },
                },
                includeWpWnsUris: {
                  type: 'array',
                  description:
                    'Not Recommended: Please consider using includePlayerIds or includeExternalUserIds instead.\nTarget using Windows URIs. If a token does not correspond to an existing user, a new user will be created.\nExample: http://s.notify.live.net/u/1/bn1/HmQAAACPaLDr-...\nLimit of 2,000 entries per REST API call\n',
                  items: {
                    type: 'string',
                  },
                },
                includeAmazonRegIds: {
                  type: 'array',
                  description:
                    'Not Recommended: Please consider using includePlayerIds or includeExternalUserIds instead.\nTarget using Amazon ADM registration IDs. If a token does not correspond to an existing user, a new user will be created.\nExample: amzn1.adm-registration.v1.XpvSSUk0Rc3hTVVV...\nLimit of 2,000 entries per REST API call\n',
                  items: {
                    type: 'string',
                  },
                },
                includeChromeRegIds: {
                  type: 'array',
                  description:
                    'Not Recommended: Please consider using includePlayerIds or includeExternalUserIds instead.\nTarget using Chrome App registration IDs. If a token does not correspond to an existing user, a new user will be created.\nExample: APA91bEeiUeSukAAUdnw3O2RB45FWlSpgJ7Ji_...\nLimit of 2,000 entries per REST API call\n',
                  items: {
                    type: 'string',
                  },
                },
                includeChromeWebRegIds: {
                  type: 'array',
                  description:
                    'Not Recommended: Please consider using includePlayerIds or includeExternalUserIds instead.\nTarget using Chrome Web Push registration IDs. If a token does not correspond to an existing user, a new user will be created.\nExample: APA91bEeiUeSukAAUdnw3O2RB45FWlSpgJ7Ji_...\nLimit of 2,000 entries per REST API call\n',
                  items: {
                    type: 'string',
                  },
                },
                includeAndroidRegIds: {
                  type: 'array',
                  description:
                    'Not Recommended: Please consider using includePlayerIds or includeExternalUserIds instead.\nTarget using Android device registration IDs. If a token does not correspond to an existing user, a new user will be created.\nExample: APA91bEeiUeSukAAUdnw3O2RB45FWlSpgJ7Ji_...\nLimit of 2,000 entries per REST API call\n',
                  items: {
                    type: 'string',
                  },
                },
                includeAliases: {
                  type: 'object',
                  properties: {
                    aliasLabel: {
                      type: 'array',
                      items: {
                        type: 'string',
                      },
                    },
                  },
                  nullable: true,
                },
                targetChannel: {
                  type: 'string',
                  enum: ['push', 'email', 'sms'],
                },
              },
            },
          ],
        },
        {
          type: 'object',
          properties: {
            id: {
              type: 'string',
            },
            value: {
              type: 'integer',
              readOnly: true,
            },
            name: {
              type: 'string',
              description:
                'Required for SMS Messages.\nAn identifier for tracking message within the OneSignal dashboard or export analytics.\nNot shown to end user.',
              writeOnly: true,
              nullable: true,
            },
            aggregation: {
              type: 'string',
              enum: ['sum', 'count'],
              readOnly: true,
            },
            isIos: {
              type: 'boolean',
              description: "Indicates whether to send to all devices registered under your app's Apple iOS platform.",
              writeOnly: true,
              nullable: true,
            },
            isAndroid: {
              type: 'boolean',
              description:
                "Indicates whether to send to all devices registered under your app's Google Android platform.",
              writeOnly: true,
              nullable: true,
            },
            isHuawei: {
              type: 'boolean',
              description:
                "Indicates whether to send to all devices registered under your app's Huawei Android platform.",
              writeOnly: true,
              nullable: true,
            },
            isAnyWeb: {
              type: 'boolean',
              description:
                'Indicates whether to send to all subscribed web browser users, including Chrome, Firefox, and Safari.\nYou may use this instead as a combined flag instead of separately enabling isChromeWeb, isFirefox, and isSafari, though the three options are equivalent to this one.\n',
              writeOnly: true,
              nullable: true,
            },
            isChromeWeb: {
              type: 'boolean',
              writeOnly: true,
              nullable: true,
              description:
                'Indicates whether to send to all Google Chrome, Chrome on Android, and Mozilla Firefox users registered under your Chrome & Firefox web push platform.',
            },
            isFirefox: {
              type: 'boolean',
              writeOnly: true,
              nullable: true,
              description:
                'Indicates whether to send to all Mozilla Firefox desktop users registered under your Firefox web push platform.',
            },
            isSafari: {
              type: 'boolean',
              writeOnly: true,
              nullable: true,
              description:
                "Does not support iOS Safari. Indicates whether to send to all Apple's Safari desktop users registered under your Safari web push platform. Read more iOS Safari",
            },
            isWpWns: {
              type: 'boolean',
              writeOnly: true,
              nullable: true,
              description: "Indicates whether to send to all devices registered under your app's Windows platform.",
            },
            isAdm: {
              type: 'boolean',
              writeOnly: true,
              nullable: true,
              description: "Indicates whether to send to all devices registered under your app's Amazon Fire platform.",
            },
            isChrome: {
              type: 'boolean',
              writeOnly: true,
              nullable: true,
              description:
                "This flag is not used for web push Please see isChromeWeb for sending to web push users. This flag only applies to Google Chrome Apps & Extensions.\nIndicates whether to send to all devices registered under your app's Google Chrome Apps & Extension platform.\n",
            },
            channelForExternalUserIds: {
              type: 'string',
              writeOnly: true,
              description:
                'Indicates if the message type when targeting with includeExternalUserIds for cases where an email, sms, and/or push subscribers have the same external user id.\nExample: Use the string "push" to indicate you are sending a push notification or the string "email"for sending emails or "sms"for sending SMS.\n',
            },
            appId: {
              type: 'string',
              description:
                'Required: Your OneSignal Application ID, which can be found in Keys & IDs.\nIt is a UUID and looks similar to 8250eaf6-1a58-489e-b136-7c74a864b434.\n',
              writeOnly: true,
            },
            externalId: {
              type: 'string',
              description:
                "Correlation and idempotency key.\nA request received with this parameter will first look for another notification with the same externalId. If one exists, a notification will not be sent, and result of the previous operation will instead be returned. Therefore, if you plan on using this feature, it's important to use a good source of randomness to generate the UUID passed here.\nThis key is only idempotent for 30 days. After 30 days, the notification could be removed from our system and a notification with the same externalId will be sent again.\n  See Idempotent Notification Requests for more details\nwriteOnly: true\n",
              nullable: true,
            },
            contents: {
              allOf: [
                {
                  type: 'object',
                  properties: {
                    en: {
                      type: 'string',
                      description: 'Text in English.  Will be used as a fallback',
                    },
                    ar: {
                      type: 'string',
                      description: 'Text in Arabic.',
                    },
                    bs: {
                      type: 'string',
                      description: 'Text in Bosnian.',
                    },
                    bg: {
                      type: 'string',
                      description: 'Text in Bulgarian.',
                    },
                    ca: {
                      type: 'string',
                      description: 'Text in Catalan.',
                    },
                    'zh-Hans': {
                      type: 'string',
                      description: 'Text in Chinese (Simplified).',
                    },
                    'zh-Hant': {
                      type: 'string',
                      description: 'Text in Chinese (Traditional).',
                    },
                    zh: {
                      type: 'string',
                      description: 'Alias for zh-Hans.',
                    },
                    hr: {
                      type: 'string',
                      description: 'Text in Croatian.',
                    },
                    cs: {
                      type: 'string',
                      description: 'Text in Czech.',
                    },
                    da: {
                      type: 'string',
                      description: 'Text in Danish.',
                    },
                    nl: {
                      type: 'string',
                      description: 'Text in Dutch.',
                    },
                    et: {
                      type: 'string',
                      description: 'Text in Estonian.',
                    },
                    fi: {
                      type: 'string',
                      description: 'Text in Finnish.',
                    },
                    fr: {
                      type: 'string',
                      description: 'Text in French.',
                    },
                    ka: {
                      type: 'string',
                      description: 'Text in Georgian.',
                    },
                    de: {
                      type: 'string',
                      description: 'Text in German.',
                    },
                    el: {
                      type: 'string',
                      description: 'Text in Greek.',
                    },
                    hi: {
                      type: 'string',
                      description: 'Text in Hindi.',
                    },
                    he: {
                      type: 'string',
                      description: 'Text in Hebrew.',
                    },
                    hu: {
                      type: 'string',
                      description: 'Text in Hungarian.',
                    },
                    id: {
                      type: 'string',
                      description: 'Text in Indonesian.',
                    },
                    it: {
                      type: 'string',
                      description: 'Text in Italian.',
                    },
                    ja: {
                      type: 'string',
                      description: 'Text in Japanese.',
                    },
                    ko: {
                      type: 'string',
                      description: 'Text in Korean.',
                    },
                    lv: {
                      type: 'string',
                      description: 'Text in Latvian.',
                    },
                    lt: {
                      type: 'string',
                      description: 'Text in Lithuanian.',
                    },
                    ms: {
                      type: 'string',
                      description: 'Text in Malay.',
                    },
                    nb: {
                      type: 'string',
                      description: 'Text in Norwegian.',
                    },
                    pl: {
                      type: 'string',
                      description: 'Text in Polish.',
                    },
                    fa: {
                      type: 'string',
                      description: 'Text in Persian.',
                    },
                    pt: {
                      type: 'string',
                      description: 'Text in Portuguese.',
                    },
                    pa: {
                      type: 'string',
                      description: 'Text in Punjabi.',
                    },
                    ro: {
                      type: 'string',
                      description: 'Text in Romanian.',
                    },
                    ru: {
                      type: 'string',
                      description: 'Text in Russian.',
                    },
                    sr: {
                      type: 'string',
                      description: 'Text in Serbian.',
                    },
                    sk: {
                      type: 'string',
                      description: 'Text in Slovak.',
                    },
                    es: {
                      type: 'string',
                      description: 'Text in Spanish.',
                    },
                    sv: {
                      type: 'string',
                      description: 'Text in Swedish.',
                    },
                    th: {
                      type: 'string',
                      description: 'Text in Thai.',
                    },
                    tr: {
                      type: 'string',
                      description: 'Text in Turkish.',
                    },
                    uk: {
                      type: 'string',
                      description: 'Text in Ukrainian.',
                    },
                    vi: {
                      type: 'string',
                      description: 'Text in Vietnamese.',
                    },
                  },
                },
                {
                  description:
                    'Required unless contentAvailable=true or templateId is set.\nThe message\'s content (excluding the title), a map of language codes to text for each language.\nEach hash must have a language code string for a key, mapped to the localized text you would like users to receive for that language.\nThis field supports inline substitutions.\nEnglish must be included in the hash.\nExample: {"en": "English Message", "es": "Spanish Message"}\n',
                  writeOnly: true,
                },
              ],
            },
            headings: {
              allOf: [
                {
                  type: 'object',
                  properties: {
                    en: {
                      type: 'string',
                      description: 'Text in English.  Will be used as a fallback',
                    },
                    ar: {
                      type: 'string',
                      description: 'Text in Arabic.',
                    },
                    bs: {
                      type: 'string',
                      description: 'Text in Bosnian.',
                    },
                    bg: {
                      type: 'string',
                      description: 'Text in Bulgarian.',
                    },
                    ca: {
                      type: 'string',
                      description: 'Text in Catalan.',
                    },
                    'zh-Hans': {
                      type: 'string',
                      description: 'Text in Chinese (Simplified).',
                    },
                    'zh-Hant': {
                      type: 'string',
                      description: 'Text in Chinese (Traditional).',
                    },
                    zh: {
                      type: 'string',
                      description: 'Alias for zh-Hans.',
                    },
                    hr: {
                      type: 'string',
                      description: 'Text in Croatian.',
                    },
                    cs: {
                      type: 'string',
                      description: 'Text in Czech.',
                    },
                    da: {
                      type: 'string',
                      description: 'Text in Danish.',
                    },
                    nl: {
                      type: 'string',
                      description: 'Text in Dutch.',
                    },
                    et: {
                      type: 'string',
                      description: 'Text in Estonian.',
                    },
                    fi: {
                      type: 'string',
                      description: 'Text in Finnish.',
                    },
                    fr: {
                      type: 'string',
                      description: 'Text in French.',
                    },
                    ka: {
                      type: 'string',
                      description: 'Text in Georgian.',
                    },
                    de: {
                      type: 'string',
                      description: 'Text in German.',
                    },
                    el: {
                      type: 'string',
                      description: 'Text in Greek.',
                    },
                    hi: {
                      type: 'string',
                      description: 'Text in Hindi.',
                    },
                    he: {
                      type: 'string',
                      description: 'Text in Hebrew.',
                    },
                    hu: {
                      type: 'string',
                      description: 'Text in Hungarian.',
                    },
                    id: {
                      type: 'string',
                      description: 'Text in Indonesian.',
                    },
                    it: {
                      type: 'string',
                      description: 'Text in Italian.',
                    },
                    ja: {
                      type: 'string',
                      description: 'Text in Japanese.',
                    },
                    ko: {
                      type: 'string',
                      description: 'Text in Korean.',
                    },
                    lv: {
                      type: 'string',
                      description: 'Text in Latvian.',
                    },
                    lt: {
                      type: 'string',
                      description: 'Text in Lithuanian.',
                    },
                    ms: {
                      type: 'string',
                      description: 'Text in Malay.',
                    },
                    nb: {
                      type: 'string',
                      description: 'Text in Norwegian.',
                    },
                    pl: {
                      type: 'string',
                      description: 'Text in Polish.',
                    },
                    fa: {
                      type: 'string',
                      description: 'Text in Persian.',
                    },
                    pt: {
                      type: 'string',
                      description: 'Text in Portuguese.',
                    },
                    pa: {
                      type: 'string',
                      description: 'Text in Punjabi.',
                    },
                    ro: {
                      type: 'string',
                      description: 'Text in Romanian.',
                    },
                    ru: {
                      type: 'string',
                      description: 'Text in Russian.',
                    },
                    sr: {
                      type: 'string',
                      description: 'Text in Serbian.',
                    },
                    sk: {
                      type: 'string',
                      description: 'Text in Slovak.',
                    },
                    es: {
                      type: 'string',
                      description: 'Text in Spanish.',
                    },
                    sv: {
                      type: 'string',
                      description: 'Text in Swedish.',
                    },
                    th: {
                      type: 'string',
                      description: 'Text in Thai.',
                    },
                    tr: {
                      type: 'string',
                      description: 'Text in Turkish.',
                    },
                    uk: {
                      type: 'string',
                      description: 'Text in Ukrainian.',
                    },
                    vi: {
                      type: 'string',
                      description: 'Text in Vietnamese.',
                    },
                  },
                },
                {
                  description:
                    'The message\'s title, a map of language codes to text for each language. Each hash must have a language code string for a key, mapped to the localized text you would like users to receive for that language.\nThis field supports inline substitutions.\nExample: {"en": "English Title", "es": "Spanish Title"}\n',
                  writeOnly: true,
                },
              ],
            },
            subtitle: {
              allOf: [
                {
                  type: 'object',
                  properties: {
                    en: {
                      type: 'string',
                      description: 'Text in English.  Will be used as a fallback',
                    },
                    ar: {
                      type: 'string',
                      description: 'Text in Arabic.',
                    },
                    bs: {
                      type: 'string',
                      description: 'Text in Bosnian.',
                    },
                    bg: {
                      type: 'string',
                      description: 'Text in Bulgarian.',
                    },
                    ca: {
                      type: 'string',
                      description: 'Text in Catalan.',
                    },
                    'zh-Hans': {
                      type: 'string',
                      description: 'Text in Chinese (Simplified).',
                    },
                    'zh-Hant': {
                      type: 'string',
                      description: 'Text in Chinese (Traditional).',
                    },
                    zh: {
                      type: 'string',
                      description: 'Alias for zh-Hans.',
                    },
                    hr: {
                      type: 'string',
                      description: 'Text in Croatian.',
                    },
                    cs: {
                      type: 'string',
                      description: 'Text in Czech.',
                    },
                    da: {
                      type: 'string',
                      description: 'Text in Danish.',
                    },
                    nl: {
                      type: 'string',
                      description: 'Text in Dutch.',
                    },
                    et: {
                      type: 'string',
                      description: 'Text in Estonian.',
                    },
                    fi: {
                      type: 'string',
                      description: 'Text in Finnish.',
                    },
                    fr: {
                      type: 'string',
                      description: 'Text in French.',
                    },
                    ka: {
                      type: 'string',
                      description: 'Text in Georgian.',
                    },
                    de: {
                      type: 'string',
                      description: 'Text in German.',
                    },
                    el: {
                      type: 'string',
                      description: 'Text in Greek.',
                    },
                    hi: {
                      type: 'string',
                      description: 'Text in Hindi.',
                    },
                    he: {
                      type: 'string',
                      description: 'Text in Hebrew.',
                    },
                    hu: {
                      type: 'string',
                      description: 'Text in Hungarian.',
                    },
                    id: {
                      type: 'string',
                      description: 'Text in Indonesian.',
                    },
                    it: {
                      type: 'string',
                      description: 'Text in Italian.',
                    },
                    ja: {
                      type: 'string',
                      description: 'Text in Japanese.',
                    },
                    ko: {
                      type: 'string',
                      description: 'Text in Korean.',
                    },
                    lv: {
                      type: 'string',
                      description: 'Text in Latvian.',
                    },
                    lt: {
                      type: 'string',
                      description: 'Text in Lithuanian.',
                    },
                    ms: {
                      type: 'string',
                      description: 'Text in Malay.',
                    },
                    nb: {
                      type: 'string',
                      description: 'Text in Norwegian.',
                    },
                    pl: {
                      type: 'string',
                      description: 'Text in Polish.',
                    },
                    fa: {
                      type: 'string',
                      description: 'Text in Persian.',
                    },
                    pt: {
                      type: 'string',
                      description: 'Text in Portuguese.',
                    },
                    pa: {
                      type: 'string',
                      description: 'Text in Punjabi.',
                    },
                    ro: {
                      type: 'string',
                      description: 'Text in Romanian.',
                    },
                    ru: {
                      type: 'string',
                      description: 'Text in Russian.',
                    },
                    sr: {
                      type: 'string',
                      description: 'Text in Serbian.',
                    },
                    sk: {
                      type: 'string',
                      description: 'Text in Slovak.',
                    },
                    es: {
                      type: 'string',
                      description: 'Text in Spanish.',
                    },
                    sv: {
                      type: 'string',
                      description: 'Text in Swedish.',
                    },
                    th: {
                      type: 'string',
                      description: 'Text in Thai.',
                    },
                    tr: {
                      type: 'string',
                      description: 'Text in Turkish.',
                    },
                    uk: {
                      type: 'string',
                      description: 'Text in Ukrainian.',
                    },
                    vi: {
                      type: 'string',
                      description: 'Text in Vietnamese.',
                    },
                  },
                },
                {
                  description:
                    'The message\'s subtitle, a map of language codes to text for each language. Each hash must have a language code string for a key, mapped to the localized text you would like users to receive for that language.\nThis field supports inline substitutions.\nExample: {"en": "English Subtitle", "es": "Spanish Subtitle"}\n',
                  writeOnly: true,
                },
              ],
            },
            data: {
              type: 'object',
              description:
                'Channel: Push Notifications\nPlatform: Huawei\nA custom map of data that is passed back to your app. Same as using Additional Data within the dashboard. Can use up to 2048 bytes of data.\nExample: {"abc": 123, "foo": "bar", "event_performed": true, "amount": 12.1}\n',
              writeOnly: true,
              nullable: true,
            },
            huaweiMsgType: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: Huawei\nUse "data" or "message" depending on the type of notification you are sending. More details in Data & Background Notifications.\n',
              writeOnly: true,
              nullable: true,
            },
            url: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: All\nThe URL to open in the browser when a user clicks on the notification.\nNote: iOS needs https or updated NSAppTransportSecurity in plist\nThis field supports inline substitutions.\nOmit if including webUrl or appUrl\nExample: https://onesignal.com\n',
              writeOnly: true,
              nullable: true,
            },
            webUrl: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: All Browsers\nSame as url but only sent to web push platforms.\nIncluding Chrome, Firefox, Safari, Opera, etc.\nExample: https://onesignal.com\n',
              writeOnly: true,
              nullable: true,
            },
            appUrl: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: All Browsers\nSame as url but only sent to web push platforms.\nIncluding iOS, Android, macOS, Windows, ChromeApps, etc.\nExample: https://onesignal.com\n',
              writeOnly: true,
              nullable: true,
            },
            iosAttachments: {
              type: 'object',
              description:
                'Channel: Push Notifications\nPlatform: iOS 10+\nAdds media attachments to notifications. Set as JSON object, key as a media id of your choice and the value as a valid local filename or URL. User must press and hold on the notification to view.\nDo not set mutableContent to download attachments. The OneSignal SDK does this automatically\nExample: {"id1": "https://domain.com/image.jpg"}\n',
              writeOnly: true,
              nullable: true,
            },
            templateId: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: All\nUse a template you setup on our dashboard. The templateId is the UUID found in the URL when viewing a template on our dashboard.\nExample: be4a8044-bbd6-11e4-a581-000c2940e62c\n',
              writeOnly: true,
              nullable: true,
            },
            contentAvailable: {
              type: 'boolean',
              description:
                'Channel: Push Notifications\nPlatform: iOS\nSending true wakes your app from background to run custom native code (Apple interprets this as content-available=1). Note: Not applicable if the app is in the "force-quit" state (i.e app was swiped away). Omit the contents field to prevent displaying a visible notification.\n',
              writeOnly: true,
              nullable: true,
            },
            mutableContent: {
              type: 'boolean',
              description:
                'Channel: Push Notifications\nPlatform: iOS 10+\nAlways defaults to true and cannot be turned off. Allows tracking of notification receives and changing of the notification content in your app before it is displayed. Triggers didReceive(_:withContentHandler:) on your UNNotificationServiceExtension.\n',
              writeOnly: true,
            },
            targetContentIdentifier: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: iOS 13+\nUse to target a specific experience in your App Clip, or to target your notification to a specific window in a multi-scene App.\n',
              writeOnly: true,
              nullable: true,
            },
            bigPicture: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: Android\nPicture to display in the expanded view. Can be a drawable resource name or a URL.\n',
              writeOnly: true,
              nullable: true,
            },
            huaweiBigPicture: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: Huawei\nPicture to display in the expanded view. Can be a drawable resource name or a URL.\n',
              writeOnly: true,
              nullable: true,
            },
            admBigPicture: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: Amazon\nPicture to display in the expanded view. Can be a drawable resource name or a URL.\n',
              writeOnly: true,
              nullable: true,
            },
            chromeBigPicture: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: ChromeApp\nLarge picture to display below the notification text. Must be a local URL.\n',
              writeOnly: true,
              nullable: true,
            },
            chromeWebImage: {
              type: 'string',
              description:
                "Channel: Push Notifications\nPlatform: Chrome 56+\nSets the web push notification's large image to be shown below the notification's title and text. Please see Web Push Notification Icons.\n",
              writeOnly: true,
              nullable: true,
            },
            buttons: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  id: {
                    type: 'string',
                  },
                  text: {
                    type: 'string',
                  },
                  icon: {
                    type: 'string',
                  },
                },
                required: ['id'],
              },
              description:
                'Channel: Push Notifications\nPlatform: iOS 8.0+, Android 4.1+, and derivatives like Amazon Buttons to add to the notification. Icon only works for Android.\nButtons show in reverse order of array position i.e. Last item in array shows as first button on device.\nExample: [{"id": "id2", "text": "second button", "icon": "ic_menu_share"}, {"id": "id1", "text": "first button", "icon": "ic_menu_send"}]\n',
              writeOnly: true,
              nullable: true,
            },
            webButtons: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  id: {
                    type: 'string',
                  },
                  text: {
                    type: 'string',
                  },
                  icon: {
                    type: 'string',
                  },
                },
                required: ['id'],
              },
              description:
                'Channel: Push Notifications\nPlatform: Chrome 48+\nAdd action buttons to the notification. The id field is required.\nExample: [{"id": "like-button", "text": "Like", "icon": "http://i.imgur.com/N8SN8ZS.png", "url": "https://yoursite.com"}, {"id": "read-more-button", "text": "Read more", "icon": "http://i.imgur.com/MIxJp1L.png", "url": "https://yoursite.com"}]\n',
              writeOnly: true,
              nullable: true,
            },
            iosCategory: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: iOS\nCategory APS payload, use with registerUserNotificationSettings:categories in your Objective-C / Swift code.\nExample: calendar category which contains actions like accept and decline\niOS 10+ This will trigger your UNNotificationContentExtension whose ID matches this category.\n',
              writeOnly: true,
              nullable: true,
            },
            androidChannelId: {
              type: 'string',
              description:
                "Channel: Push Notifications\nPlatform: Android\nThe Android Oreo Notification Category to send the notification under. See the Category documentation on creating one and getting it's id.\n",
              writeOnly: true,
            },
            huaweiChannelId: {
              type: 'string',
              description:
                "Channel: Push Notifications\nPlatform: Huawei\nThe Android Oreo Notification Category to send the notification under. See the Category documentation on creating one and getting it's id.\n",
              writeOnly: true,
              nullable: true,
            },
            existingAndroidChannelId: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: Android\nUse this if you have client side Android Oreo Channels you have already defined in your app with code.\n',
              writeOnly: true,
            },
            huaweiExistingChannelId: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: Huawei\nUse this if you have client side Android Oreo Channels you have already defined in your app with code.\n',
              writeOnly: true,
              nullable: true,
            },
            androidBackgroundLayout: {
              type: 'object',
              description:
                'Channel: Push Notifications\nPlatform: Android\nAllowing setting a background image for the notification. This is a JSON object containing the following keys. See our Background Image documentation for image sizes.\n',
              properties: {
                image: {
                  type: 'string',
                  description: 'Asset file, android resource name, or URL to remote image.',
                },
                headingsColor: {
                  type: 'string',
                  description: 'Title text color ARGB Hex format. Example(Blue) "FF0000FF".',
                },
                contentsColor: {
                  type: 'string',
                  description: 'Body text color ARGB Hex format. Example(Red) "FFFF0000".',
                },
              },
              writeOnly: true,
            },
            smallIcon: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: Android\nIcon shown in the status bar and on the top left of the notification.\nIf not set a bell icon will be used or ic_stat_onesignal_default if you have set this resource name.\nSee: How to create small icons\n',
              writeOnly: true,
              nullable: true,
            },
            huaweiSmallIcon: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: Huawei\nIcon shown in the status bar and on the top left of the notification.\nUse an Android resource path (E.g. /drawable/smallIcon).\nDefaults to your app icon if not set.\n',
              writeOnly: true,
              nullable: true,
            },
            largeIcon: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: Android\nCan be a drawable resource name or a URL.\nSee: How to create large icons\n',
              writeOnly: true,
              nullable: true,
            },
            huaweiLargeIcon: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: Huawei\nCan be a drawable resource name or a URL.\nSee: How to create large icons\n',
              writeOnly: true,
              nullable: true,
            },
            admSmallIcon: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: Amazon\nIf not set a bell icon will be used or ic_stat_onesignal_default if you have set this resource name.\nSee: How to create small icons\n',
              writeOnly: true,
              nullable: true,
            },
            admLargeIcon: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: Amazon\nIf blank the smallIcon is used. Can be a drawable resource name or a URL.\nSee: How to create large icons\n',
              writeOnly: true,
              nullable: true,
            },
            chromeWebIcon: {
              type: 'string',
              description:
                "Channel: Push Notifications\nPlatform: Chrome\nSets the web push notification's icon. An image URL linking to a valid image. Common image types are supported; GIF will not animate. We recommend 256x256 (at least 80x80) to display well on high DPI devices. Firefox will also use this icon, unless you specify firefoxIcon.\n",
              nullable: true,
            },
            chromeWebBadge: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: Chrome\nSets the web push notification icon for Android devices in the notification shade. Please see Web Push Notification Badge.\n',
              writeOnly: true,
              nullable: true,
            },
            firefoxIcon: {
              type: 'string',
              description:
                "Channel: Push Notifications\nPlatform: Firefox\nNot recommended Few people need to set Firefox-specific icons. We recommend setting chromeWebIcon instead, which Firefox will also use.\nSets the web push notification's icon for Firefox. An image URL linking to a valid image. Common image types are supported; GIF will not animate. We recommend 256x256 (at least 80x80) to display well on high DPI devices.\n",
              writeOnly: true,
              nullable: true,
            },
            chromeIcon: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: ChromeApp\nThis flag is not used for web push For web push, please see chromeWebIcon instead.\nThe local URL to an icon to use. If blank, the app icon will be used.\n',
              writeOnly: true,
              nullable: true,
            },
            iosSound: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: iOS\nSound file that is included in your app to play instead of the default device notification sound. Pass nil to disable vibration and sound for the notification.\nExample: "notification.wav"\n',
              writeOnly: true,
              nullable: true,
            },
            androidSound: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: Android\n&#9888;&#65039;Deprecated, this field doesn\'t work on Android 8 (Oreo) and newer devices!\nPlease use Notification Categories / Channels noted above instead to support ALL versions of Android.\nSound file that is included in your app to play instead of the default device notification sound. Pass nil to disable sound for the notification.\nNOTE: Leave off file extension for Android.\nExample: "notification"\n',
              writeOnly: true,
              nullable: true,
            },
            huaweiSound: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: Huawei\n&#9888;&#65039;Deprecated, this field ONLY works on EMUI 5 (Android 7 based) and older devices.\nPlease also set Notification Categories / Channels noted above to support EMUI 8 (Android 8 based) devices.\nSound file that is included in your app to play instead of the default device notification sound. NOTE: Leave off file extension for and include the full path.\n\nExample: "/res/raw/notification"\n',
              writeOnly: true,
              nullable: true,
            },
            admSound: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: Amazon\n&#9888;&#65039;Deprecated, this field doesn\'t work on Android 8 (Oreo) and newer devices!\nPlease use Notification Categories / Channels noted above instead to support ALL versions of Android.\nSound file that is included in your app to play instead of the default device notification sound. Pass nil to disable sound for the notification.\nNOTE: Leave off file extension for Android.\nExample: "notification"\n',
              writeOnly: true,
              nullable: true,
            },
            wpWnsSound: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: Windows\nSound file that is included in your app to play instead of the default device notification sound.\nExample: "notification.wav"\n',
              writeOnly: true,
              nullable: true,
            },
            androidLedColor: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: Android\n&#9888;&#65039;Deprecated, this field doesn\'t work on Android 8 (Oreo) and newer devices!\nPlease use Notification Categories / Channels noted above instead to support ALL versions of Android.\nSets the devices LED notification light if the device has one. ARGB Hex format.\nExample(Blue): "FF0000FF"\n',
              writeOnly: true,
              nullable: true,
            },
            huaweiLedColor: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: Huawei\n&#9888;&#65039;Deprecated, this field ONLY works on EMUI 5 (Android 7 based) and older devices.\nPlease also set Notification Categories / Channels noted above to support EMUI 8 (Android 8 based) devices.\nSets the devices LED notification light if the device has one. RGB Hex format.\nExample(Blue): "0000FF"\n',
              writeOnly: true,
              nullable: true,
            },
            androidAccentColor: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: Android\nSets the background color of the notification circle to the left of the notification text. Only applies to apps targeting Android API level 21+ on Android 5.0+ devices.\nExample(Red): "FFFF0000"\n',
              writeOnly: true,
              nullable: true,
            },
            huaweiAccentColor: {
              type: 'string',
              description:
                "Channel: Push Notifications\nPlatform: Huawei\nAccent Color used on Action Buttons and Group overflow count.\nUses RGB Hex value (E.g. #9900FF).\nDefaults to device's theme color if not set.\n",
              writeOnly: true,
              nullable: true,
            },
            androidVisibility: {
              type: 'integer',
              description:
                'Channel: Push Notifications\nPlatform: Android 5.0_\n&#9888;&#65039;Deprecated, this field doesn\'t work on Android 8 (Oreo) and newer devices!\nPlease use Notification Categories / Channels noted above instead to support ALL versions of Android.\n1 = Public (default) (Shows the full message on the lock screen unless the user has disabled all notifications from showing on the lock screen. Please consider the user and mark private if the contents are.)\n0 = Private (Hides message contents on lock screen if the user set "Hide sensitive notification content" in the system settings)\n-1 = Secret (Notification does not show on the lock screen at all)\n',
              writeOnly: true,
              nullable: true,
            },
            huaweiVisibility: {
              type: 'integer',
              nullable: true,
              description:
                'Channel: Push Notifications\nPlatform: Huawei\n&#9888;&#65039;Deprecated, this field ONLY works on EMUI 5 (Android 7 based) and older devices.\nPlease also set Notification Categories / Channels noted above to support EMUI 8 (Android 8 based) devices.\n1 = Public (default) (Shows the full message on the lock screen unless the user has disabled all notifications from showing on the lock screen. Please consider the user and mark private if the contents are.)\n0 = Private (Hides message contents on lock screen if the user set "Hide sensitive notification content" in the system settings)\n-1 = Secret (Notification does not show on the lock screen at all)\n',
              writeOnly: true,
            },
            iosBadgeType: {
              type: 'string',
              description:
                "Channel: Push Notifications\nPlatform: iOS\nDescribes whether to set or increase/decrease your app's iOS badge count by the iosBadgeCount specified count. Can specify None, SetTo, or Increase.\n`None` leaves the count unaffected.\n`SetTo` directly sets the badge count to the number specified in iosBadgeCount.\n`Increase` adds the number specified in iosBadgeCount to the total. Use a negative number to decrease the badge count.\n",
              writeOnly: true,
              nullable: true,
            },
            iosBadgeCount: {
              type: 'integer',
              nullable: true,
              description:
                "Channel: Push Notifications\nPlatform: iOS\nUsed with iosBadgeType, describes the value to set or amount to increase/decrease your app's iOS badge count by.\nYou can use a negative number to decrease the badge count when used with an iosBadgeType of Increase.\n",
              writeOnly: true,
            },
            collapseId: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: iOS 10+, Android\nOnly one notification with the same id will be shown on the device. Use the same id to update an existing notification instead of showing a new one. Limit of 64 characters.\n',
              writeOnly: true,
            },
            webPushTopic: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: All Browsers\nDisplay multiple notifications at once with different topics.\n',
              nullable: true,
            },
            apnsAlert: {
              type: 'object',
              description:
                "Channel: Push Notifications\nPlatform: iOS 10+\niOS can localize push notification messages on the client using special parameters such as loc-key. When using the Create Notification endpoint, you must include these parameters inside of a field called apnsAlert. Please see Apple's guide on localizing push notifications to learn more.\n",
              writeOnly: true,
              nullable: true,
            },
            delayedOption: {
              type: 'string',
              description:
                'Channel: All\nPossible values are:\ntimezone (Deliver at a specific time-of-day in each users own timezone)\nlast-active Same as Intelligent Delivery . (Deliver at the same time of day as each user last used your app).\nIf sendAfter is used, this takes effect after the sendAfter time has elapsed.\n',
              writeOnly: true,
              nullable: true,
            },
            deliveryTimeOfDay: {
              type: 'string',
              description: 'Channel: All\nUse with delayedOption=timezone.\nExamples: "9:00AM"\n"21:45"\n"9:45:30"\n',
              writeOnly: true,
              nullable: true,
            },
            ttl: {
              type: 'integer',
              nullable: true,
              description:
                'Channel: Push Notifications\nPlatform: iOS, Android, Chrome, Firefox, Safari, ChromeWeb\nTime To Live - In seconds. The notification will be expired if the device does not come back online within this time. The default is 259,200 seconds (3 days).\nMax value to set is 2419200 seconds (28 days).\n',
              writeOnly: true,
            },
            priority: {
              type: 'integer',
              nullable: true,
              description:
                'Channel: Push Notifications\nPlatform: Android, Chrome, ChromeWeb\nDelivery priority through the push server (example GCM/FCM). Pass 10 for high priority or any other integer for normal priority. Defaults to normal priority for Android and high for iOS. For Android 6.0+ devices setting priority to high will wake the device out of doze mode.\n',
              writeOnly: true,
            },
            apnsPushTypeOverride: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: iOS\nvalid values: voip\nSet the value to voip for sending VoIP Notifications\nThis field maps to the APNS header apns-push-type.\nNote: alert and background are automatically set by OneSignal\n',
              writeOnly: true,
            },
            throttleRatePerMinute: {
              type: 'string',
              description:
                'Channel: All\nApps with throttling enabled:\n  - the parameter value will be used to override the default application throttling value set from the dashboard settings.\n  - parameter value 0 indicates not to apply throttling to the notification.\n  - if the parameter is not passed then the default app throttling value will be applied to the notification.\nApps with throttling disabled:\n  - this parameter can be used to throttle delivery for the notification even though throttling is not enabled at the application level.\nRefer to throttling for more details.\n',
              writeOnly: true,
              nullable: true,
            },
            androidGroup: {
              type: 'string',
              description:
                "Channel: Push Notifications\nPlatform: Android\nNotifications with the same group will be stacked together using Android's Notification Grouping feature.\n",
              writeOnly: true,
              nullable: true,
            },
            androidGroupMessage: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: Android\nNote: This only works for Android 6 and older. Android 7+ allows full expansion of all message.\nSummary message to display when 2+ notifications are stacked together. Default is "# new messages". Include $[notif_count] in your message and it will be replaced with the current number.\nLanguages - The value of each key is the message that will be sent to users for that language. "en" (English) is required. The key of each hash is either a a 2 character language code or one of zh-Hans/zh-Hant for Simplified or Traditional Chinese. Read more: supported languages.\nExample: {"en": "You have $[notif_count] new messages"}\n',
              writeOnly: true,
              nullable: true,
            },
            admGroup: {
              type: 'string',
              description:
                "Channel: Push Notifications\nPlatform: Amazon\nNotifications with the same group will be stacked together using Android's Notification Grouping feature.\n",
              writeOnly: true,
              nullable: true,
            },
            admGroupMessage: {
              type: 'object',
              description:
                'Channel: Push Notifications\nPlatform: Amazon\nSummary message to display when 2+ notifications are stacked together. Default is "# new messages". Include $[notif_count] in your message and it will be replaced with the current number. "en" (English) is required. The key of each hash is either a a 2 character language code or one of zh-Hans/zh-Hant for Simplified or Traditional Chinese. The value of each key is the message that will be sent to users for that language.\nExample: {"en": "You have $[notif_count] new messages"}\n',
              writeOnly: true,
              nullable: true,
            },
            threadId: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: iOS 12+\nThis parameter is supported in iOS 12 and above. It allows you to group related notifications together.\nIf two notifications have the same thread-id, they will both be added to the same group.\n',
              writeOnly: true,
              nullable: true,
            },
            summaryArg: {
              type: 'string',
              description:
                'Channel: Push Notifications\nPlatform: iOS 12+\nWhen using threadId to create grouped notifications in iOS 12+, you can also control the summary. For example, a grouped notification can say "12 more notifications from John Doe".\nThe summaryArg lets you set the name of the person/thing the notifications are coming from, and will show up as "X more notifications from summaryArg"\n',
              writeOnly: true,
            },
            summaryArgCount: {
              type: 'integer',
              description:
                'Channel: Push Notifications\nPlatform: iOS 12+\nWhen using threadId, you can also control the count of the number of notifications in the group. For example, if the group already has 12 notifications, and you send a new notification with summaryArgCount = 2, the new total will be 14 and the summary will be "14 more notifications from summaryArg"\n',
              writeOnly: true,
            },
            emailSubject: {
              type: 'string',
              description: 'Channel: Email\nRequired.  The subject of the email.\n',
              writeOnly: true,
              nullable: true,
            },
            emailBody: {
              type: 'string',
              description:
                'Channel: Email\nRequired unless templateId is set.\nHTML suported\nThe body of the email you wish to send. Typically, customers include their own HTML templates here. Must include [unsubscribe_url] in an <a> tag somewhere in the email.\nNote: any malformed HTML content will be sent to users. Please double-check your HTML is valid.\n',
              writeOnly: true,
            },
            emailFromName: {
              type: 'string',
              description:
                'Channel: Email\nThe name the email is from. If not specified, will default to "from name" set in the OneSignal Dashboard Email Settings.\n',
              writeOnly: true,
              nullable: true,
            },
            emailFromAddress: {
              type: 'string',
              description:
                'Channel: Email\nThe email address the email is from. If not specified, will default to "from email" set in the OneSignal Dashboard Email Settings.\n',
              writeOnly: true,
              nullable: true,
            },
            emailPreheader: {
              type: 'string',
              description:
                'Channel: Email\nThe preheader text of the email.\nPreheader is the preview text displayed immediately after an email subject that provides additional context about the email content.\nIf not specified, will default to null.\n',
              writeOnly: true,
              nullable: true,
            },
            includeUnsubscribed: {
              type: 'boolean',
              description:
                "Channel: Email\nDefault is `false`. This field is used to send transactional notifications. If set to `true`, this notification will also be sent to unsubscribed emails. If a `templateId` is provided, the `includeUnsubscribed` value from the template will be inherited. If you are using a third-party ESP, this field requires the ESP's list of unsubscribed emails to be cleared.",
              writeOnly: true,
            },
            smsFrom: {
              type: 'string',
              description:
                'Channel: SMS\nPhone Number used to send SMS. Should be a registered Twilio phone number in E.164 format.\n',
              writeOnly: true,
              nullable: true,
            },
            smsMediaUrls: {
              type: 'array',
              items: {
                type: 'string',
              },
              description:
                'Channel: SMS\nURLs for the media files to be attached to the SMS content.\nLimit: 10 media urls with a total max. size of 5MBs.\n',
              writeOnly: true,
              nullable: true,
            },
            filters: {
              type: 'array',
              nullable: true,
              items: {
                type: 'object',
                properties: {
                  field: {
                    type: 'string',
                    description: 'Name of the field to use as the first operand in the filter expression.',
                  },
                  key: {
                    type: 'string',
                    description: 'If `field` is `tag`, this field is *required* to specify `key` inside the tags.',
                  },
                  value: {
                    type: 'string',
                    description:
                      'Constant value to use as the second operand in the filter expression. This value is *required* when the relation operator is a binary operator.',
                  },
                  relation: {
                    type: 'string',
                    description: 'Operator of a filter expression.',
                    enum: ['>', '<', '=', '!=', 'exists', 'not_exists', 'time_elapsed_gt', 'time_elapsed_lt'],
                  },
                },
                required: ['field', 'relation'],
              },
            },
            customData: {
              type: 'object',
              description:
                'Channel: All\nJSON object that can be used as a source of message personalization data for fields that support tag variable substitution.\nPush, SMS: Can accept up to 2048 bytes of valid JSON. Email: Can accept up to 10000 bytes of valid JSON.\nExample: {"order_id": 123, "currency": "USD", "amount": 25}\n',
              writeOnly: true,
              nullable: true,
            },
          },
        },
        {
          required: ['appId'],
        },
      ],
    },
    {
      type: 'object',
      properties: {
        sendAfter: {
          type: 'string',
          format: 'date-time',
          description:
            'Channel: All\nSchedule notification for future delivery. API defaults to UTC -1100\nExamples: All examples are the exact same date & time.\n"Thu Sep 24 2015 14:00:00 GMT-0700 (PDT)"\n"September 24th 2015, 2:00:00 pm UTC-07:00"\n"2015-09-24 14:00:00 GMT-0700"\n"Sept 24 2015 14:00:00 GMT-0700"\n"Thu Sep 24 2015 14:00:00 GMT-0700 (Pacific Daylight Time)"\nNote: SMS currently only supports sendAfter parameter.\n',
          writeOnly: true,
          nullable: true,
        },
      },
    },
  ],
  required: [],
  additionalProperties: true,
} as const satisfies JsonSchema;

export const oneSignalProviderSchema = {
  output: oneSignalOutputSchema,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  analytics
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/providers/sms/index.ts
Tamaño: 1744 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SmsProviderIdEnum } from '../../../shared';
import type { JsonSchema } from '../../../types/schema.types';
import { genericProviderSchemas } from '../generic.schema';
import { novuSmsProviderSchemas } from './novu-sms.schema';
import { twilioProviderSchemas } from './twilio.schema';

export const smsProviderSchemas = {
  'africas-talking': genericProviderSchemas,
  'azure-sms': genericProviderSchemas,
  bandwidth: genericProviderSchemas,
  'brevo-sms': genericProviderSchemas,
  'bulk-sms': genericProviderSchemas,
  'burst-sms': genericProviderSchemas,
  clickatell: genericProviderSchemas,
  clicksend: genericProviderSchemas,
  'eazy-sms': genericProviderSchemas,
  firetext: genericProviderSchemas,
  'forty-six-elks': genericProviderSchemas,
  'generic-sms': genericProviderSchemas,
  gupshup: genericProviderSchemas,
  'infobip-sms': genericProviderSchemas,
  'isend-sms': genericProviderSchemas,
  kannel: genericProviderSchemas,
  maqsam: genericProviderSchemas,
  messagebird: genericProviderSchemas,
  mobishastra: genericProviderSchemas,
  nexmo: genericProviderSchemas,
  'novu-sms': novuSmsProviderSchemas,
  plivo: genericProviderSchemas,
  'ring-central': genericProviderSchemas,
  sendchamp: genericProviderSchemas,
  simpletexting: genericProviderSchemas,
  sms77: genericProviderSchemas,
  'sms-central': genericProviderSchemas,
  smsmode: genericProviderSchemas,
  sns: genericProviderSchemas,
  telnyx: genericProviderSchemas,
  termii: genericProviderSchemas,
  twilio: twilioProviderSchemas,
  'afro-message': genericProviderSchemas,
  unifonic: genericProviderSchemas,
  imedia: genericProviderSchemas,
  sinch: genericProviderSchemas,
} as const satisfies Record<SmsProviderIdEnum, { output: JsonSchema }>;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/providers/sms/novu-sms.schema.ts
Tamaño: 312 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { JsonSchema } from '../../../types/schema.types';

/**
 * Novu sms schema
 */
const novuSmsOutputSchema = {
  type: 'object',
  properties: {},
  required: [],
  additionalProperties: false,
} as const satisfies JsonSchema;

export const novuSmsProviderSchemas = {
  output: novuSmsOutputSchema,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/providers/sms/twilio.schema.ts
Tamaño: 9523 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { JsonSchema } from '../../../types/schema.types';

/**
 * Twilio `POST /2010-04-01/Accounts/{AccountSid}/Messages.json` schema
 *
 * @see https://www.twilio.com/docs/sms/api/message-resource
 */
const twilioOutputSchema = {
  type: 'object',
  properties: {
    to: {
      type: 'string',
      pattern: '^\\+[1-9]\\d{1,14}$',
      description:
        "The recipient's phone number in [E.164](https://www.twilio.com/docs/glossary/what-e164) format (for SMS/MMS) or [channel address](https://www.twilio.com/docs/messaging/channels), e.g. `whatsapp:+15552229999`.",
    },
    statusCallback: {
      type: 'string',
      format: 'uri',
      description:
        'The URL of the endpoint to which Twilio sends [Message status callback requests](https://www.twilio.com/docs/sms/api/message-resource#twilios-request-to-the-statuscallback-url). URL must contain a valid hostname and underscores are not allowed. If you include this parameter with the `messagingServiceSid`, Twilio uses this URL instead of the Status Callback URL of the [Messaging Service](https://www.twilio.com/docs/messaging/api/service-resource). ',
    },
    applicationSid: {
      type: 'string',
      minLength: 34,
      maxLength: 34,
      pattern: '^AP[0-9a-fA-F]{32}$',
      description:
        "The SID of the associated [TwiML Application](https://www.twilio.com/docs/usage/api/applications). [Message status callback requests](https://www.twilio.com/docs/sms/api/message-resource#twilios-request-to-the-statuscallback-url) are sent to the TwiML App's `statusCallback` URL. Note that the `statusCallback` parameter of a request takes priority over the `applicationSid` parameter; if both are included `applicationSid` is ignored.",
    },
    maxPrice: {
      type: 'number',
      description: '[OBSOLETE] This parameter will no longer have any effect as of 2024-06-03.',
    },
    provideFeedback: {
      type: 'boolean',
      description:
        'Boolean indicating whether or not you intend to provide delivery confirmation feedback to Twilio (used in conjunction with the [Message Feedback subresource](https://www.twilio.com/docs/sms/api/message-feedback-resource)). Default value is `false`.',
    },
    attempt: {
      type: 'integer',
      description:
        'Total number of attempts made (including this request) to send the message regardless of the provider used',
    },
    validityPeriod: {
      type: 'integer',
      description:
        "The maximum length in seconds that the Message can remain in Twilio's outgoing message queue. If a queued Message exceeds the `validityPeriod`, the Message is not sent. Accepted values are integers from `1` to `36000`. Default value is `36000`. A `validityPeriod` greater than `5` is recommended. [Learn more about the validity period](https://www.twilio.com/blog/take-more-control-of-outbound-messages-using-validity-period-html)",
    },
    forceDelivery: {
      type: 'boolean',
      description: 'Reserved',
    },
    contentRetention: {
      type: 'string',
      enum: ['retain', 'discard'],
      description: 'Determines if the message content can be stored or redacted based on privacy settings',
    },
    addressRetention: {
      type: 'string',
      enum: ['retain', 'obfuscate'],
      description: 'Determines if the address can be stored or obfuscated based on privacy settings',
    },
    smartEncoded: {
      type: 'boolean',
      description:
        'Whether to detect Unicode characters that have a similar GSM-7 character and replace them. Can be: `true` or `false`.',
    },
    persistentAction: {
      type: 'array',
      items: {
        type: 'string',
      },
      description:
        'Rich actions for non-SMS/MMS channels. Used for [sending location in WhatsApp messages](https://www.twilio.com/docs/whatsapp/message-features#location-messages-with-whatsapp).',
    },
    shortenUrls: {
      type: 'boolean',
      description:
        'For Messaging Services with [Link Shortening configured](https://www.twilio.com/docs/messaging/features/link-shortening) only: A Boolean indicating whether or not Twilio should shorten links in the `body` of the Message. Default value is `false`. If `true`, the `messagingServiceSid` parameter must also be provided.',
    },
    scheduleType: {
      type: 'string',
      enum: ['fixed'],
      description:
        'For Messaging Services only: Include this parameter with a value of `fixed` in conjunction with the `sendAt` parameter in order to [schedule a Message](https://www.twilio.com/docs/messaging/features/message-scheduling).',
    },
    sendAt: {
      type: 'string',
      format: 'date-time',
      description: 'The time that Twilio will send the message. Must be in ISO 8601 format.',
    },
    sendAsMms: {
      type: 'boolean',
      description:
        'If set to `true`, Twilio delivers the message as a single MMS message, regardless of the presence of media.',
    },
    contentVariables: {
      type: 'string',
      description:
        "For [Content Editor/API](https://www.twilio.com/docs/content) only: Key-value pairs of [Template variables](https://www.twilio.com/docs/content/using-variables-with-content-api) and their substitution values. `contentSid` parameter must also be provided. If values are not defined in the `contentVariables` parameter, the [Template's default placeholder values](https://www.twilio.com/docs/content/content-api-resources#create-templates) are used.",
    },
    riskCheck: {
      type: 'string',
      enum: ['enable', 'disable'],
      description:
        'Include this parameter with a value of `disable` to skip any kind of risk check on the respective message request.',
    },
    from: {
      type: 'string',
      pattern: '^\\+[1-9]\\d{1,14}$',
      description:
        "The sender's Twilio phone number (in [E.164](https://en.wikipedia.org/wiki/E.164) format), [alphanumeric sender ID](https://www.twilio.com/docs/sms/quickstart), [Wireless SIM](https://www.twilio.com/docs/iot/wireless/programmable-wireless-send-machine-machine-sms-commands), [short code](https://www.twilio.com/en-us/messaging/channels/sms/short-codes), or [channel address](https://www.twilio.com/docs/messaging/channels) (e.g., `whatsapp:+15554449999`). The value of the `from` parameter must be a sender that is hosted within Twilio and belongs to the Account creating the Message. If you are using `messagingServiceSid`, this parameter can be empty (Twilio assigns a `from` value from the Messaging Service's Sender Pool) or you can provide a specific sender from your Sender Pool.",
    },
    messagingServiceSid: {
      type: 'string',
      minLength: 34,
      maxLength: 34,
      pattern: '^MG[0-9a-fA-F]{32}$',
      description:
        "The SID of the [Messaging Service](https://www.twilio.com/docs/messaging/services) you want to associate with the Message. When this parameter is provided and the `from` parameter is omitted, Twilio selects the optimal sender from the Messaging Service's Sender Pool. You may also provide a `from` parameter if you want to use a specific Sender from the Sender Pool.",
    },
    body: {
      type: 'string',
      description:
        'The text content of the outgoing message. Can be up to 1,600 characters in length. SMS only: If the `body` contains more than 160 [GSM-7](https://www.twilio.com/docs/glossary/what-is-gsm-7-character-encoding) characters (or 70 [UCS-2](https://www.twilio.com/docs/glossary/what-is-ucs-2-character-encoding) characters), the message is segmented and charged accordingly. For long `body` text, consider using the [sendAsMms parameter](https://www.twilio.com/blog/mms-for-long-text-messages).',
    },
    mediaUrl: {
      type: 'array',
      items: {
        type: 'string',
        format: 'uri',
      },
      description:
        'The URL of media to include in the Message content. `jpeg`, `jpg`, `gif`, and `png` file types are fully supported by Twilio and content is formatted for delivery on destination devices. The media size limit is 5 MB for supported file types (`jpeg`, `jpg`, `png`, `gif`) and 500 KB for [other types](https://www.twilio.com/docs/messaging/guides/accepted-mime-types) of accepted media. To send more than one image in the message, provide multiple `mediaUrl` parameters in the POST request. You can include up to ten `mediaUrl` parameters per message. [International](https://support.twilio.com/hc/en-us/articles/223179808-Sending-and-receiving-MMS-messages) and [carrier](https://support.twilio.com/hc/en-us/articles/223133707-Is-MMS-supported-for-all-carriers-in-US-and-Canada-) limits apply.',
    },
    contentSid: {
      type: 'string',
      minLength: 34,
      maxLength: 34,
      pattern: '^HX[0-9a-fA-F]{32}$',
      description:
        "For [Content Editor/API](https://www.twilio.com/docs/content) only: The SID of the Content Template to be used with the Message, e.g., `HXXXXXXXXXXXXXXXXXXXXXXXXXXXXX`. If this parameter is not provided, a Content Template is not used. Find the SID in the Console on the Content Editor page. For Content API users, the SID is found in Twilio's response when [creating the Template](https://www.twilio.com/docs/content/content-api-resources#create-templates) or by [fetching your Templates](https://www.twilio.com/docs/content/content-api-resources#fetch-all-content-resources).",
    },
  },
  required: [],
  additionalProperties: true,
} as const satisfies JsonSchema;

export const twilioProviderSchemas = {
  output: twilioOutputSchema,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/steps/empty.schema.ts
Tamaño: 206 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { JsonSchema } from '../../types/schema.types';

export const emptySchema = {
  type: 'object',
  properties: {},
  required: [],
  additionalProperties: false,
} as const satisfies JsonSchema;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/steps/index.ts
Tamaño: 245 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './actions';
export * from './actions/delay.schema';
export * from './actions/digest.schema';
export * from './actions/throttle.schema';
export * from './channels';
export * from './empty.schema';
export * from './trigger.schema';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/steps/trigger.schema.ts
Tamaño: 305 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { JsonSchema } from '../../types/schema.types';

export const triggerSchema = {
  type: 'object',
  properties: {
    to: { type: 'string', pattern: '/[0-9a-f]+/' },
    body: { type: 'string' },
  },
  required: ['to', 'body'],
  additionalProperties: false,
} as const satisfies JsonSchema;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/steps/actions/delay.schema.ts
Tamaño: 1504 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { JsonSchema } from '../../../types/schema.types';

export const delayRegularOutputSchema = {
  type: 'object',
  properties: {
    type: {
      enum: ['regular'],
    },
    amount: { type: 'number' },
    unit: {
      type: 'string',
      enum: ['seconds', 'minutes', 'hours', 'days', 'weeks', 'months'],
    },
    extendToSchedule: { type: 'boolean' },
  },
  required: ['amount', 'unit'],
  additionalProperties: false,
} as const satisfies JsonSchema;

export const delayTimedOutputSchema = {
  type: 'object',
  properties: {
    type: {
      enum: ['timed'],
    },
    cron: { type: 'string' },
    extendToSchedule: { type: 'boolean' },
  },
  required: ['cron'],
  additionalProperties: false,
} as const satisfies JsonSchema;

export const delayDynamicOutputSchema = {
  type: 'object',
  properties: {
    type: {
      enum: ['dynamic'],
    },
    dynamicKey: { type: 'string' },
    extendToSchedule: { type: 'boolean' },
  },
  required: ['dynamicKey'],
  additionalProperties: false,
} as const satisfies JsonSchema;

export const delayOutputSchema = {
  oneOf: [delayRegularOutputSchema, delayTimedOutputSchema, delayDynamicOutputSchema],
} as const satisfies JsonSchema;

export const delayResultSchema = {
  type: 'object',
  properties: {
    duration: { type: 'number' },
  },
  required: ['duration'],
  additionalProperties: false,
} as const satisfies JsonSchema;

export const delayActionSchemas = {
  output: delayOutputSchema,
  result: delayResultSchema,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/steps/actions/digest.schema.test.ts
Tamaño: 996 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { describe, expect, it } from 'vitest';
import { validateData } from '../../../validators';
import { digestActionSchemas } from './digest.schema';

describe('digest schema', () => {
  describe('output schema', () => {
    it('should validate regular digest', async () => {
      const schema = digestActionSchemas.output;

      const data = {
        amount: 1,
        unit: 'seconds',
      };

      const result = await validateData(schema, data);

      expect(result.success).toBe(true);
      expect(result.success && result.data).toEqual({
        amount: 1,
        unit: 'seconds',
      });
    });

    it('should validate timed digest', async () => {
      const schema = digestActionSchemas.output;

      const data = {
        cron: '0 0-23/1 * * *',
      };

      const result = await validateData(schema, data);

      expect(result.success).toBe(true);
      expect(result.success && result.data).toEqual({
        cron: '0 0-23/1 * * *',
      });
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - result(await validateData(schema, data);

      expect(result.success).toBe(true);
      expect(result.succ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/steps/actions/digest.schema.ts
Tamaño: 1912 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { JsonSchema } from '../../../types/schema.types';

export const digestRegularOutputSchema = {
  type: 'object',
  properties: {
    type: {
      enum: ['regular'],
    },
    amount: { type: 'number' },
    unit: {
      type: 'string',
      enum: ['seconds', 'minutes', 'hours', 'days', 'weeks', 'months'],
    },
    digestKey: {
      type: 'string',
    },
    lookBackWindow: {
      type: 'object',
      properties: {
        amount: { type: 'number' },
        unit: {
          type: 'string',
          enum: ['seconds', 'minutes', 'hours', 'days', 'weeks', 'months'],
        },
      },
      required: ['amount', 'unit'],
      additionalProperties: false,
    },
    extendToSchedule: { type: 'boolean' },
  },
  required: ['amount', 'unit'],
  additionalProperties: false,
} as const satisfies JsonSchema;

export const digestTimedOutputSchema = {
  type: 'object',
  properties: {
    type: {
      enum: ['timed'],
    },
    cron: { type: 'string' },
    digestKey: {
      type: 'string',
    },
    extendToSchedule: { type: 'boolean' },
  },
  required: ['cron'],
  additionalProperties: false,
} as const satisfies JsonSchema;

export const digestOutputSchema = {
  oneOf: [digestRegularOutputSchema, digestTimedOutputSchema],
} as const satisfies JsonSchema;

export const digestResultSchema = {
  type: 'object',
  properties: {
    eventCount: { type: 'number' },
    events: {
      type: 'array',
      items: {
        type: 'object',
        properties: {
          id: { type: 'string' },
          time: { type: 'string' },
          payload: { type: 'object' },
        },
        required: ['id', 'time', 'payload'],
        additionalProperties: false,
      },
    },
  },
  required: ['events'],
  additionalProperties: false,
} as const satisfies JsonSchema;

export const digestActionSchemas = {
  output: digestOutputSchema,
  result: digestResultSchema,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  const
- export  const
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/steps/actions/index.ts
Tamaño: 583 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ActionStepEnum } from '../../../constants';
import type { JsonSchema } from '../../../types/schema.types';
import { delayActionSchemas } from './delay.schema';
import { digestActionSchemas } from './digest.schema';
import { throttleActionSchemas } from './throttle.schema';

type RegularActionStepSchema = Exclude<ActionStepEnum, ActionStepEnum.CUSTOM>;

export const actionStepSchemas = {
  delay: delayActionSchemas,
  digest: digestActionSchemas,
  throttle: throttleActionSchemas,
} satisfies Record<RegularActionStepSchema, { output: JsonSchema; result: JsonSchema }>;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/steps/actions/throttle.schema.ts
Tamaño: 1280 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { JsonSchema } from '../../../types/schema.types';

export const throttleActionSchemas = {
  output: {
    type: 'object',
    properties: {
      type: { type: 'string', enum: ['fixed', 'dynamic'] },
      // Fixed throttle fields
      amount: { type: 'number' },
      unit: { type: 'string', enum: ['minutes', 'hours', 'days'] },
      // Dynamic throttle fields
      dynamicKey: { type: 'string' },
      // Common fields
      threshold: { type: 'number' },
      throttleKey: { type: 'string' },
    },
    required: ['type'],
    additionalProperties: false,
  } as const satisfies JsonSchema,
  result: {
    type: 'object',
    properties: {
      throttled: {
        type: 'boolean',
        description: 'Whether the workflow execution was throttled',
      },
      executionCount: {
        type: 'number',
        description: 'Number of executions within the throttle window',
      },
      threshold: {
        type: 'number',
        description: 'The throttle threshold that was applied',
      },
      windowStart: {
        type: 'string',
        format: 'date-time',
        description: 'Start time of the throttle window',
      },
    },
    required: ['throttled'],
    additionalProperties: false,
  } as const satisfies JsonSchema,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/steps/channels/chat.schema.ts
Tamaño: 486 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { JsonSchema } from '../../../types/schema.types';

const chatOutputSchema = {
  type: 'object',
  properties: {
    body: { type: 'string' },
  },
  required: ['body'],
  additionalProperties: false,
} as const satisfies JsonSchema;

const chatResultSchema = {
  type: 'object',
  properties: {},
  required: [],
  additionalProperties: false,
} as const satisfies JsonSchema;

export const chatChannelSchemas = {
  output: chatOutputSchema,
  result: chatResultSchema,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/steps/channels/email.schema.ts
Tamaño: 549 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { JsonSchema } from '../../../types/schema.types';

const emailOutputSchema = {
  type: 'object',
  properties: {
    subject: { type: 'string', minLength: 1 },
    body: { type: 'string' },
  },
  required: ['subject', 'body'],
  additionalProperties: false,
} as const satisfies JsonSchema;

const emailResultSchema = {
  type: 'object',
  properties: {},
  required: [],
  additionalProperties: false,
} as const satisfies JsonSchema;

export const emailChannelSchemas = {
  output: emailOutputSchema,
  result: emailResultSchema,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/steps/channels/in-app.schema.test.ts
Tamaño: 2468 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { describe, expect, it } from 'vitest';
import { validateData } from '../../../validators';
import { inAppChannelSchemas } from './in-app.schema';

describe('in-app schema', () => {
  describe('output schema', () => {
    it('should set target to _self by default if url is relative', async () => {
      const schema = inAppChannelSchemas.output;

      const data = {
        body: 'Hello, world!',
        redirect: {
          url: '/foo',
        },
      };

      const result = await validateData(schema, data);

      expect(result.success).toBe(true);
      expect(result.success && result.data).toEqual({
        body: 'Hello, world!',
        redirect: { url: '/foo', target: '_self' },
      });
    });

    it('should set target to _blank by default if url is absolute', async () => {
      const schema = inAppChannelSchemas.output;

      const data = {
        body: 'Hello, world!',
        redirect: {
          url: 'https://example.com/foo',
        },
      };

      const result = await validateData(schema, data);

      expect(result.success).toBe(true);
      expect(result.success && result.data).toEqual({
        body: 'Hello, world!',
        redirect: { url: 'https://example.com/foo', target: '_blank' },
      });
    });

    it('should throw an error if the url is not a valid absolute or relative url', async () => {
      const schema = inAppChannelSchemas.output;

      const data = {
        body: 'Hello, world!',
        redirect: {
          url: 'foo',
        },
      };

      const result = await validateData(schema, data);

      expect(result.success).toBe(false);
      expect(result.success === false && result.errors).toEqual([
        {
          message: 'must match pattern "^(?!mailto:)(?:(https?):\\/\\/[^\\s/$.?#].[^\\s]*)|^(\\/[^\\s]*)$"',
          path: '/redirect/url',
        },
      ]);
    });

    it('should throw an error if the redirect target is not a valid value', async () => {
      const schema = inAppChannelSchemas.output;

      const data = {
        body: 'Hello, world!',
        redirect: {
          url: '/foo',
          target: 'foo',
        },
      };

      const result = await validateData(schema, data);

      expect(result.success).toBe(false);
      expect(result.success === false && result.errors).toEqual([
        {
          message: 'must be equal to one of the allowed values',
          path: '/redirect/target',
        },
      ]);
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - result(await validateData(schema, data);

      expect(result.success).toBe(true);
      expect(result.succ...)
 - result(await validateData(schema, data);

      expect(result.success).toBe(true);
      expect(result.succ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/steps/channels/in-app.schema.ts
Tamaño: 2127 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { JsonSchema } from '../../../types/schema.types';

const ABSOLUTE_AND_RELATIVE_URL_REGEX = '^(?!mailto:)(?:(https?):\\/\\/[^\\s/$.?#].[^\\s]*)|^(\\/[^\\s]*)$';

const redirectSchema = {
  type: 'object',
  properties: {
    url: {
      type: 'string',
      pattern: ABSOLUTE_AND_RELATIVE_URL_REGEX,
    },
    target: {
      type: 'string',
      enum: ['_self', '_blank', '_parent', '_top', '_unfencedTop'],
      default: '_blank',
    },
  },
  if: {
    properties: {
      url: {
        type: 'string',
        pattern: '^/', // Check if url starts with a slash (relative path)
      },
    },
  },
  then: {
    properties: {
      target: {
        default: '_self',
      },
    },
  },
  else: {
    properties: {
      target: {
        default: '_blank',
      },
    },
  },
  required: ['url'],
  additionalProperties: false,
} as const satisfies JsonSchema;

const actionSchema = {
  type: 'object',
  properties: {
    label: { type: 'string' },
    redirect: redirectSchema,
  },
  required: ['label'],
  additionalProperties: false,
} as const satisfies JsonSchema;

const inAppOutputSchema = {
  type: 'object',
  properties: {
    subject: {
      type: 'string',
      minLength: 1,
    },
    body: {
      type: 'string',
      minLength: 1,
    },
    avatar: { type: 'string', format: 'uri' },
    primaryAction: actionSchema,
    secondaryAction: actionSchema,
    data: { type: 'object', additionalProperties: true },
    redirect: redirectSchema,
  },
  anyOf: [{ required: ['subject'] }, { required: ['body'] }],
  additionalProperties: false,
} as const satisfies JsonSchema;

const inAppResultSchema = {
  type: 'object',
  properties: {
    seen: { type: 'boolean' },
    read: { type: 'boolean' },
    lastSeenDate: { type: 'string', format: 'date-time', nullable: true },
    lastReadDate: { type: 'string', format: 'date-time', nullable: true },
  },
  required: ['seen', 'read', 'lastSeenDate', 'lastReadDate'],
  additionalProperties: false,
} as const satisfies JsonSchema;

export const inAppChannelSchemas = {
  output: inAppOutputSchema,
  result: inAppResultSchema,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/steps/channels/index.ts
Tamaño: 650 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChannelStepEnum } from '../../../constants';
import type { JsonSchema } from '../../../types/schema.types';
import { chatChannelSchemas } from './chat.schema';
import { emailChannelSchemas } from './email.schema';
import { inAppChannelSchemas } from './in-app.schema';
import { pushChannelSchemas } from './push.schema';
import { smsChannelSchemas } from './sms.schema';

export const channelStepSchemas = {
  chat: chatChannelSchemas,
  sms: smsChannelSchemas,
  push: pushChannelSchemas,
  email: emailChannelSchemas,
  in_app: inAppChannelSchemas,
} as const satisfies Record<ChannelStepEnum, { output: JsonSchema; result: JsonSchema }>;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/steps/channels/push.schema.ts
Tamaño: 530 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { JsonSchema } from '../../../types/schema.types';

const pushOutputSchema = {
  type: 'object',
  properties: {
    subject: { type: 'string' },
    body: { type: 'string' },
  },
  required: ['subject', 'body'],
  additionalProperties: false,
} as const satisfies JsonSchema;

const pushResultSchema = {
  type: 'object',
  properties: {},
  required: [],
  additionalProperties: false,
} as const satisfies JsonSchema;

export const pushChannelSchemas = {
  output: pushOutputSchema,
  result: pushResultSchema,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/schemas/steps/channels/sms.schema.ts
Tamaño: 476 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { JsonSchema } from '../../../types/schema.types';

const smsOutputSchema = {
  type: 'object',
  properties: {
    body: { type: 'string' },
  },
  required: ['body'],
  additionalProperties: false,
} as const satisfies JsonSchema;

const smsResultSchema = {
  type: 'object',
  properties: {},
  required: [],
  additionalProperties: false,
} as const satisfies JsonSchema;

export const smsChannelSchemas = {
  output: smsOutputSchema,
  result: smsResultSchema,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/servers/express.ts
Tamaño: 2851 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { type VercelRequest, type VercelResponse } from '@vercel/node';
import { type Request, type Response } from 'express';

import { NovuRequestHandler, ServeHandlerOptions } from '../handler';
import { Either, type SupportedFrameworkName } from '../types';

/*
 * Re-export all top level exports from the main package.
 * This results in better DX reduces the chances of the dual package hazard for ESM + CJS packages.
 *
 * Example:
 *
 * import { serve, Client, type Workflow } from '@novu/framework/express';
 *
 * instead of
 *
 * import { serve } from '@novu/framework/express';
 * import { Client, type Workflow } from '@novu/framework';
 */
export * from '../index';
export const frameworkName: SupportedFrameworkName = 'express';

/**
 * Serve and register any declared workflows with Novu, making them available
 * to be triggered by events.
 *
 * The return type is currently `any` to ensure there's no required type matches
 * between the `express` and `vercel` packages. This may change in the future to
 * appropriately infer.
 *
 * @example
 * ```ts
 * import { serve } from "@novu/framework/express";
 * import { myWorkflow } from "./src/novu/workflows"; // Your workflows
 *
 * // Important:  ensure you add JSON middleware to process incoming JSON POST payloads.
 * app.use(express.json());
 * app.use(
 *   // Expose the middleware on our recommended path at `/api/novu`.
 *   "/api/novu",
 *   serve({ workflows: [myWorkflow] })
 * );
 * ```
 */
export const serve = (options: ServeHandlerOptions): any => {
  const novuHandler = new NovuRequestHandler({
    frameworkName,
    ...options,
    /*
     * TODO: Fix this
     */
    handler: (incomingRequest: Either<VercelRequest, Request>, response: Either<Response, VercelResponse>) => ({
      body: () => incomingRequest.body,
      headers: (key) => {
        const header = incomingRequest.headers[key];

        return Array.isArray(header) ? header[0] : header;
      },
      method: () => incomingRequest.method || 'GET',
      url: () => {
        // `req.hostname` can filter out port numbers; beware!
        const hostname = incomingRequest.headers.host || '';

        const protocol = hostname?.includes('://') ? '' : `${incomingRequest.protocol || 'https'}://`;

        const url = new URL(incomingRequest.originalUrl || incomingRequest.url || '', `${protocol}${hostname || ''}`);

        return url;
      },
      queryString: (key) => {
        const qs = incomingRequest.query[key];

        return Array.isArray(qs) ? qs[0] : qs;
      },
      transformResponse: ({ body, headers, status }) => {
        Object.entries(headers).forEach(([headerName, headerValue]) => {
          response.setHeader(headerName, headerValue);
        });

        return response.status(status).send(body);
      },
    }),
  });

  return novuHandler.createHandler();
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - serve(options: ServeHandlerOptions): any)
 - novuHandler(new NovuRequestHandler({
    frameworkName,
    ...options,
    /*
     * TODO: Fix this
     */
   ...)
 - header(incomingRequest.headers[key];

        return Array.isArray(header) ? header[0] : header;
      },
 ...)
 - url(new URL(incomingRequest.originalUrl || incomingRequest.url || '', `${protocol}${hostname || ''}`);

...)
 - qs(incomingRequest.query[key];

        return Array.isArray(qs) ? qs[0] : qs;
      },
      transform...)
Declaraciones 'export' encontradas:
- export  all
- export
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/servers/h3.ts
Tamaño: 2144 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { getHeader, getQuery, type H3Event, readBody, send, setHeaders } from 'h3';

import { NovuRequestHandler, type ServeHandlerOptions } from '../handler';
import { type SupportedFrameworkName } from '../types';

/*
 * Re-export all top level exports from the main package.
 * This results in better DX reduces the chances of the dual package hazard for ESM + CJS packages.
 *
 * Example:
 *
 * import { serve, Client, type Workflow } from '@novu/framework/h3';
 *
 * instead of
 *
 * import { serve } from '@novu/framework/h3';
 * import { Client, type Workflow } from '@novu/framework';
 */
export * from '../index';
export const frameworkName: SupportedFrameworkName = 'h3';

/**
 * In h3, serve and register any declared workflows with Novu, making
 * them available to be triggered by events.
 *
 * @example
 * ```ts
 * import { createApp, eventHandler, toNodeListener } from "h3";
 * import { serve } from "@novu/framework/h3";
 * import { createServer } from "node:http";
 * import { myWorkflow } from "./src/novu/workflows";
 *
 * const app = createApp();
 * app.use(
 *   "/api/novu",
 *   eventHandler(
 *     serve({
 *       workflows: [myWorkflow],
 *     })
 *   )
 * );
 *
 * createServer(toNodeListener(app)).listen(process.env.PORT || 4000);
 * ```
 *
 * @public
 */
export const serve = (options: ServeHandlerOptions) => {
  const handler = new NovuRequestHandler({
    frameworkName,
    ...options,
    handler: (event: H3Event) => {
      return {
        body: () => readBody(event),
        headers: (key) => getHeader(event, key),
        method: () => event.method,
        url: () =>
          new URL(
            String(event.path),
            `${process.env.NODE_ENV === 'development' ? 'http' : 'https'}://${String(getHeader(event, 'host'))}`
          ),
        queryString: (key) => String(getQuery(event)[key]),
        transformResponse: (actionRes) => {
          const { res } = event.node;
          res.statusCode = actionRes.status;
          setHeaders(event, actionRes.headers);

          return send(event, actionRes.body);
        },
      };
    },
  });

  return handler.createHandler();
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - serve(options: ServeHandlerOptions))
 - handler(new NovuRequestHandler({
    frameworkName,
    ...options,
    handler: (event: H3Event))
Declaraciones 'export' encontradas:
- export  all
- export
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/servers/lambda.ts
Tamaño: 2743 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { type APIGatewayEvent, type APIGatewayProxyEventV2, type APIGatewayProxyResult } from 'aws-lambda';
import { NovuRequestHandler, type ServeHandlerOptions } from '../handler';
import { type Either, type SupportedFrameworkName } from '../types';

/*
 * Re-export all top level exports from the main package.
 * This results in better DX reduces the chances of the dual package hazard for ESM + CJS packages.
 *
 * Example:
 *
 * import { serve, Client, type Workflow } from '@novu/framework/lambda';
 *
 * instead of
 *
 * import { serve } from '@novu/framework/lambda';
 * import { Client, type Workflow } from '@novu/framework';
 */
export * from '../index';
export const frameworkName: SupportedFrameworkName = 'lambda';

/**
 * With AWS Lambda, serve and register any declared workflows with Novu,
 * making them available to be triggered by events.
 *
 * @example
 *
 * ```ts
 * import { serve } from "@novu/framework/lambda";
 * import { myWorkflow } from "./src/novu/workflows";
 *
 * export const handler = serve({ workflows: [myWorkflow] });
 * ```
 */
export const serve = (options: ServeHandlerOptions) => {
  const handler = new NovuRequestHandler({
    frameworkName,
    ...options,
    handler: (event: Either<APIGatewayEvent, APIGatewayProxyEventV2>) => {
      const eventIsV2 = ((ev: APIGatewayEvent | APIGatewayProxyEventV2): ev is APIGatewayProxyEventV2 => {
        return (ev as APIGatewayProxyEventV2).version === '2.0';
      })(event);

      return {
        url: () => {
          const path = eventIsV2 ? event.requestContext.http.path : event.path;
          const proto = event.headers['x-forwarded-proto'] || 'https';

          const url = new URL(path, `${proto}://${event.headers.host || event.headers.Host || ''}`);

          for (const key in event.queryStringParameters) {
            if (key) {
              url.searchParams.set(key, event.queryStringParameters[key] as string);
            }
          }

          return url;
        },
        body: () => {
          let bodyContent = '{}';
          if (event.body) {
            bodyContent = event.isBase64Encoded ? Buffer.from(event.body, 'base64').toString() : event.body;
          }

          return JSON.parse(bodyContent);
        },
        headers: (key) => event.headers[key],
        queryString: (key) => {
          return event.queryStringParameters?.[key];
        },
        transformResponse: ({ body, status: statusCode, headers }): Promise<APIGatewayProxyResult> => {
          return Promise.resolve({ body, statusCode, headers });
        },
        method: () => {
          return eventIsV2 ? event.requestContext.http.method : event.httpMethod;
        },
      };
    },
  });

  return handler.createHandler();
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - serve(options: ServeHandlerOptions))
 - handler(new NovuRequestHandler({
    frameworkName,
    ...options,
    handler: (event: Either<APIGatewayEv...)
 - eventIsV2((ev: APIGatewayEvent | APIGatewayProxyEventV2): ev is APIGatewayProxyEventV2)
 - url(new URL(path, `${proto}://${event.headers.host || event.headers.Host || ''}`);

          for (const...)
 - bodyContent(event.isBase64Encoded ? Buffer.from(event.body, 'base64').toString() : event.body;
          }

    ...)
Declaraciones 'export' encontradas:
- export  all
- export
- export  const
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/servers/nest.ts
Tamaño: 694 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Re-export all top level exports from the main package.
 * This results in better DX reduces the chances of the dual package hazard for ESM + CJS packages.
 *
 * Example:
 *
 * import { NovuModule, Client, type Workflow } from '@novu/framework/nest';
 *
 * instead of
 *
 * import { NovuModule } from '@novu/framework/nest';
 * import { Client, type Workflow } from '@novu/framework';
 */
export * from '../index';
export * from './nest/nest.client';
export * from './nest/nest.constants';
export * from './nest/nest.controller';
export * from './nest/nest.handler';
export * from './nest/nest.interface';
export * from './nest/nest.module';
export * from './nest/nest.register-api-path';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  all
- export
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/servers/next.ts
Tamaño: 8383 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { type NextApiRequest, type NextApiResponse } from 'next';
import { type NextRequest } from 'next/server';

import { NovuRequestHandler, type ServeHandlerOptions } from '../handler';
import { type Either, type SupportedFrameworkName } from '../types';
import { getResponse } from '../utils';

/*
 * Re-export all top level exports from the main package.
 * This results in better DX reduces the chances of the dual package hazard for ESM + CJS packages.
 *
 * Example:
 *
 * import { serve, Client, type Workflow } from '@novu/framework/next';
 *
 * instead of
 *
 * import { serve } from '@novu/framework/next';
 * import { Client, type Workflow } from '@novu/framework';
 */
export * from '../index';
export const frameworkName: SupportedFrameworkName = 'next';

/**
 * Defines a request handler for Next.js 12+.
 *
 * The argument types are kept abstract due to varying type checks across
 * Next.js versions. Next.js 15 uses `RouteContext` for the second argument,
 * while versions 13 and 14 omit it, and version 12 uses `NextApiResponse`,
 * which varies by environment (edge vs serverless).
 */
export type RequestHandler = (expectedReq: NextRequest, res: unknown) => Promise<Response>;

// Helper function to check if the response is a Next.js 12 API response
const isNext12ApiResponse = (val: unknown): val is NextApiResponse => {
  return (
    typeof val === 'object' &&
    val !== null &&
    typeof (val as NextApiResponse).setHeader === 'function' &&
    typeof (val as NextApiResponse).status === 'function' &&
    typeof (val as NextApiResponse).send === 'function'
  );
};

/**
 * In Next.js, serve and register any declared workflows with Novu, making
 * them available to be triggered by events.
 *
 * Supports Next.js 12+, both serverless and edge.
 *
 * @example Next.js <=12 or the pages router can export the handler directly
 * ```ts
 * import { serve } from "@novu/framework/next";
 * import { myWorkflow } from "./src/novu/workflows"; // Your workflows
 *
 * export default serve({ workflows: [myWorkflow] });
 * ```
 *
 * @example Next.js >=13 with the `app` dir must export individual methods
 * ```ts
 * import { serve } from "@novu/framework/next";
 * import { myWorkflow } from "./src/novu/workflows";
 *
 * export const { GET, POST, OPTIONS } = serve({ workflows: [myWorkflow] });
 * ```
 */
export const serve = (
  options: ServeHandlerOptions
): RequestHandler & {
  GET: RequestHandler;
  POST: RequestHandler;
  OPTIONS: RequestHandler;
} => {
  const novuHandler = new NovuRequestHandler({
    frameworkName,
    ...options,
    handler: (
      requestMethod: 'GET' | 'POST' | 'OPTIONS' | undefined,
      incomingRequest: NextRequest,
      response: unknown
    ) => {
      const request = incomingRequest as Either<NextApiRequest, NextRequest>;

      const extractHeader = (key: string): string | null | undefined => {
        const header = typeof request.headers.get === 'function' ? request.headers.get(key) : request.headers[key];

        return Array.isArray(header) ? header[0] : header;
      };

      return {
        body: () => (typeof request.json === 'function' ? request.json() : request.body),
        headers: extractHeader,
        method: () => {
          /**
           * `req.method`, though types say otherwise, is not available in Next.js
           * 13 {@link https://nextjs.org/docs/app/building-your-application/routing/route-handlers Route Handlers}.
           *
           * Therefore, we must try to set the method ourselves where we know it.
           */
          const method = requestMethod || request.method || '';

          return method;
        },
        queryString: (key, url) => {
          const qs = request.query?.[key] || url.searchParams.get(key);

          return Array.isArray(qs) ? qs[0] : qs;
        },

        url: () => {
          let absoluteUrl: URL | undefined;
          try {
            absoluteUrl = new URL(request.url as string);
          } catch {
            // no-op
          }

          if (absoluteUrl) {
            /**
             * `req.url` here should may be the full URL, including query string.
             * There are some caveats, however, where Next.js will obfuscate
             * the host. For example, in the case of `host.docker.internal`,
             * Next.js will instead set the host here to `localhost`.
             *
             * To avoid this, we'll try to parse the URL from `req.url`, but
             * also use the `host` header if it's available.
             */
            const host = extractHeader('host');
            if (host) {
              const hostWithProtocol = new URL(host.includes('://') ? host : `${absoluteUrl.protocol}//${host}`);

              absoluteUrl.protocol = hostWithProtocol.protocol;
              absoluteUrl.host = hostWithProtocol.host;
              absoluteUrl.port = hostWithProtocol.port;
              absoluteUrl.username = hostWithProtocol.username;
              absoluteUrl.password = hostWithProtocol.password;
            }

            return absoluteUrl;
          }

          let protocol: 'http' | 'https' = 'https';
          const hostHeader = extractHeader('host') || '';

          try {
            // biome-ignore lint/suspicious/noExplicitAny: Needed for some edge cases
            if (process.env.NODE_ENV === 'development' || (process.env.NODE_ENV as any) === 'dev') {
              protocol = 'http';
            }
          } catch (error) {
            // no-op
          }

          const url = new URL(request.url as string, `${protocol}://${hostHeader}`);

          return url;
        },
        transformResponse: ({ body, headers, status }): Response => {
          /**
           * Carefully attempt to set headers and data on the response object
           * for Next.js 12 support.
           */
          if (isNext12ApiResponse(response)) {
            Object.entries(headers).forEach(([headerName, headerValue]) => {
              response.setHeader(headerName, headerValue);
            });

            response.status(status).send(body);

            /**
             * If we're here, we're in a serverless endpoint (not edge), so
             * we've correctly sent the response and can return `undefined`.
             *
             * Next.js 13 edge requires that the return value is typed as
             * `Response`, so we still enforce that as we cannot dynamically
             * adjust typing based on the environment.
             */
            return undefined as unknown as Response;
          }

          /**
           * If we're here, we're in an edge environment and need to return a
           * `Response` object.
           *
           * We also don't know if the current environment has a native
           * `Response` object, so we'll grab that first.
           */
          const Res = getResponse();

          return new Res(body, { status, headers });
        },
      };
    },
  });

  /**
   * Next.js 13 uses
   * {@link https://nextjs.org/docs/app/building-your-application/routing/route-handlers Route Handlers}
   * to declare API routes instead of a generic catch-all method that was
   * available using the `pages/api` directory.
   *
   * This means that users must now export a function for each method supported
   * by the endpoint. For us, this means requiring a user explicitly exports
   * `GET`, `POST`, and `OPTIONS` functions.
   *
   * Because of this, we'll add circular references to those property names of
   * the returned handler, meaning we can write some succinct code to export
   * cspell:disable-next-line
   * them. Thanks, @goodoldneon.
   *
   * @example
   * ```ts
   * export const { GET, POST, OPTIONS } = serve(...);
   * ```
   *
   * See {@link https://nextjs.org/docs/app/building-your-application/routing/route-handlers}
   */
  const baseHandler = novuHandler.createHandler();

  const defaultHandler = baseHandler.bind(null, undefined);
  type HandlerFunction = typeof defaultHandler;

  const handlerFunctions = Object.defineProperties(defaultHandler, {
    GET: { value: baseHandler.bind(null, 'GET') },
    POST: { value: baseHandler.bind(null, 'POST') },
    OPTIONS: { value: baseHandler.bind(null, 'OPTIONS') },
  }) as HandlerFunction & {
    GET: HandlerFunction;
    POST: HandlerFunction;
    OPTIONS: HandlerFunction;
  };

  return handlerFunctions;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - RequestHandler(expectedReq: NextRequest, res: unknown))
 - isNext12ApiResponse(val: unknown): val is NextApiResponse)
 - serve(options: ServeHandlerOptions
): RequestHandler & {
  GET: RequestHandler;
  POST: RequestHandler;
  ...)
 - novuHandler(new NovuRequestHandler({
    frameworkName,
    ...options,
    handler: (
      requestMethod: 'GET...)
 - extractHeader(key: string): string | null | undefined)
 - method(requestMethod || request.method || '';

          return method;
        },
        queryString: (ke...)
 - qs(request.query?.[key] || url.searchParams.get(key);

          return Array.isArray(qs) ? qs[0] : qs;...)
 - url(new URL(request.url as string, `${protocol}://${hostHeader}`);

          return url;
        },
   ...)
Declaraciones 'export' encontradas:
- export  all
- export
- export  const
- export  type
- export  the
- export default  serve
- export  individual
- export  const
- export  const
- export  a
- export
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/servers/nuxt.ts
Tamaño: 1526 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { getHeader, getQuery, H3Event, readBody, send, setHeaders } from 'h3';

import { NovuRequestHandler, type ServeHandlerOptions } from '../handler';
import { type SupportedFrameworkName } from '../types';

/*
 * Re-export all top level exports from the main package.
 * This results in better DX reduces the chances of the dual package hazard for ESM + CJS packages.
 *
 * Example:
 *
 * import { serve, Client, type Workflow } from '@novu/framework/nuxt';
 *
 * instead of
 *
 * import { serve } from '@novu/framework/nuxt';
 * import { Client, type Workflow } from '@novu/framework';
 */
export * from '../index';
export const frameworkName: SupportedFrameworkName = 'nuxt';

export const serve = (options: ServeHandlerOptions) => {
  const handler = new NovuRequestHandler({
    frameworkName,
    ...options,
    /*
     * TODO: Fix this
     */
    handler: (event: H3Event) => ({
      queryString: (key) => String(getQuery(event)[key]),
      body: () => readBody(event),
      headers: (key) => getHeader(event, key),
      url: () =>
        new URL(
          String(event.path),
          `${process.env.NODE_ENV === 'development' ? 'http' : 'https'}://${String(getHeader(event, 'host'))}`
        ),
      method: () => event.method,
      transformResponse: (actionRes) => {
        const { res } = event.node;

        res.statusCode = actionRes.status;
        setHeaders(event, actionRes.headers);

        return send(event, actionRes.body);
      },
    }),
  });

  return handler.createHandler();
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - serve(options: ServeHandlerOptions))
 - handler(new NovuRequestHandler({
    frameworkName,
    ...options,
    /*
     * TODO: Fix this
     */
   ...)
Declaraciones 'export' encontradas:
- export  all
- export
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/servers/remix.ts
Tamaño: 2107 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { NovuRequestHandler, type ServeHandlerOptions } from '../handler';
import { type SupportedFrameworkName } from '../types';
import { getResponse } from '../utils';

/*
 * Re-export all top level exports from the main package.
 * This results in better DX reduces the chances of the dual package hazard for ESM + CJS packages.
 *
 * Example:
 *
 * import { serve, Client, type Workflow } from '@novu/framework/remix';
 *
 * instead of
 *
 * import { serve } from '@novu/framework/remix';
 * import { Client, type Workflow } from '@novu/framework';
 */
export * from '../index';
export const frameworkName: SupportedFrameworkName = 'remix';

/**
 * In Remix, serve and register any declared workflows with Novu, making them
 * available to be triggered by events.
 *
 * Remix requires that you export both a "loader" for serving `GET` requests,
 * and an "action" for serving other requests, therefore exporting both is
 * required.
 *
 * See {@link https://remix.run/docs/en/v1/guides/resource-routes}
 *
 * @example
 * ```ts
 * import { serve } from "@novu/framework/remix";
 * import { myWorkflow } from "./src/novu/workflows";
 *
 * const handler = serve({ workflows: [myWorkflow] });
 *
 * export { handler as loader, handler as action };
 * ```
 */
// Has explicit return type to avoid JSR-defined "slow types"
export const serve = (
  options: ServeHandlerOptions
): ((ctx: { request: Request; context?: unknown }) => Promise<Response>) => {
  const handler = new NovuRequestHandler({
    frameworkName,
    ...options,
    handler: ({ request: req }: { request: Request }) => {
      return {
        body: () => req.json(),
        headers: (key) => req.headers.get(key),
        method: () => req.method,
        url: () => new URL(req.url, `https://${req.headers.get('host') || ''}`),
        transformResponse: ({ body, status, headers }): Response => {
          // Handle Response polyfills
          const Res = getResponse();

          return new Res(body, {
            status,
            headers,
          });
        },
      };
    },
  });

  return handler.createHandler();
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - serve(options: ServeHandlerOptions
): ((ctx: { request: Request; context?: unknown }))
 - handler(new NovuRequestHandler({
    frameworkName,
    ...options,
    handler: ({ request: req }: { reques...)
Declaraciones 'export' encontradas:
- export  all
- export
- export  const
- export  both
- export
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/servers/sveltekit.ts
Tamaño: 2662 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { RequestEvent } from '@sveltejs/kit';
import { NovuRequestHandler, type ServeHandlerOptions } from '../handler';
import { type SupportedFrameworkName } from '../types';
import { getResponse } from '../utils';

/*
 * Re-export all top level exports from the main package.
 * This results in better DX reduces the chances of the dual package hazard for ESM + CJS packages.
 *
 * Example:
 *
 * import { serve, Client, type Workflow } from '@novu/framework/sveltekit';
 *
 * instead of
 *
 * import { serve } from '@novu/framework/sveltekit';
 * import { Client, type Workflow } from '@novu/framework';
 */
export * from '../index';
export const frameworkName: SupportedFrameworkName = 'sveltekit';

/**
 * Using SvelteKit, serve and register any declared workflows with Novu,
 * making them available to be triggered by events.
 *
 * @example
 * ```ts
 * // app/routes/api/novu/+server.ts
 * import { serve } from "@novu/framework/sveltekit";
 * import { myWorkflow } from "./src/novu/workflows"; // Your workflows
 *
 * const handler = serve({ workflows: [myWorkflow] });
 *
 * export { handler as action, handler as loader };
 * ```
 */
export const serve = (
  options: ServeHandlerOptions
): ((event: RequestEvent) => Promise<Response>) & {
  GET: (event: RequestEvent) => Promise<Response>;
  POST: (event: RequestEvent) => Promise<Response>;
  OPTIONS: (event: RequestEvent) => Promise<Response>;
} => {
  const handler = new NovuRequestHandler({
    frameworkName,
    ...options,
    handler: (reqMethod: 'GET' | 'POST' | 'OPTIONS' | undefined, event: RequestEvent) => {
      return {
        method: () => reqMethod || event.request.method || '',
        body: () => event.request.json(),
        headers: (key) => event.request.headers.get(key),
        url: () => {
          const protocol =
            process.env.NODE_ENV === 'development' || (process.env.NODE_ENV as any) === 'dev' ? 'http' : 'https';

          return new URL(event.request.url, `${protocol}://${event.request.headers.get('host') || ''}`);
        },
        transformResponse: ({ body, headers, status }) => {
          // Handle Response polyfills
          const Res = getResponse();

          return new Res(body, { status, headers });
        },
      };
    },
  });

  const baseFn = handler.createHandler();

  const fn = baseFn.bind(null, undefined);
  type Fn = typeof fn;

  const handlerFn = Object.defineProperties(fn, {
    GET: { value: baseFn.bind(null, 'GET') },
    POST: { value: baseFn.bind(null, 'POST') },
    OPTIONS: { value: baseFn.bind(null, 'OPTIONS') },
  }) as Fn & {
    GET: Fn;
    POST: Fn;
    OPTIONS: Fn;
  };

  return handlerFn;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - serve(options: ServeHandlerOptions
): ((event: RequestEvent))
 - handler(new NovuRequestHandler({
    frameworkName,
    ...options,
    handler: (reqMethod: 'GET' | 'POST' ...)
Declaraciones 'export' encontradas:
- export  all
- export
- export  const
- export
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/servers/nest/nest.client.ts
Tamaño: 912 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Inject, Injectable } from '@nestjs/common';
import type { Request, Response } from 'express';

import { NovuRequestHandler, type ServeHandlerOptions } from '../../handler';
import type { SupportedFrameworkName } from '../../types';
import { NOVU_OPTIONS } from './nest.constants';
import { NovuHandler } from './nest.handler';

export const frameworkName: SupportedFrameworkName = 'nest';

@Injectable()
export class NovuClient {
  public novuRequestHandler: NovuRequestHandler;

  constructor(
    @Inject(NOVU_OPTIONS) private options: ServeHandlerOptions,
    @Inject(NovuHandler) private novuHandler: NovuHandler
  ) {
    this.novuRequestHandler = new NovuRequestHandler({
      frameworkName,
      ...this.options,
      handler: this.novuHandler.handler,
    });
  }

  public async handleRequest(req: Request, res: Response) {
    await this.novuRequestHandler.createHandler()(req, res);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export class NovuClient

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/servers/nest/nest.constants.ts
Tamaño: 111 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export const REGISTER_API_PATH = 'REGISTER_API_PATH';
export { NOVU_OPTIONS } from './nest.module-definition';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/servers/nest/nest.controller.ts
Tamaño: 691 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Controller, Get, Inject, Options, Post, Req, Res } from '@nestjs/common';
import type { Request, Response } from 'express';
import { NovuClient } from './nest.client';

@Controller()
export class NovuController {
  constructor(@Inject(NovuClient) private novuService: NovuClient) {}

  @Get()
  async handleGet(@Req() req: Request, @Res() res: Response) {
    await this.novuService.handleRequest(req, res);
  }

  @Post()
  async handlePost(@Req() req: Request, @Res() res: Response) {
    await this.novuService.handleRequest(req, res);
  }

  @Options()
  async handleOptions(@Req() req: Request, @Res() res: Response) {
    await this.novuService.handleRequest(req, res);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class NovuController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/servers/nest/nest.handler.ts
Tamaño: 1645 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { type VercelRequest, type VercelResponse } from '@vercel/node';
import type { Request, Response } from 'express';

import { type INovuRequestHandlerOptions } from '../../handler';
import type { Either } from '../../types';

@Injectable()
export class NovuHandler {
  public handler(
    incomingRequest: Either<VercelRequest, Request>,
    response: Either<Response, VercelResponse>
  ): ReturnType<INovuRequestHandlerOptions['handler']> {
    const extractHeader = (key: string): string | null | undefined => {
      const header = incomingRequest.headers[key.toLowerCase()];

      return Array.isArray(header) ? header[0] : header;
    };

    return {
      body: () => incomingRequest.body,
      headers: extractHeader,
      method: () => incomingRequest.method || 'GET',
      queryString: (key) => {
        const qs = incomingRequest.query[key];

        return Array.isArray(qs) ? qs[0] : qs;
      },
      url: () => {
        // `req.hostname` can filter out port numbers; beware!
        const hostname = incomingRequest.headers.host || '';

        const protocol = hostname?.includes('://') ? '' : `${incomingRequest.protocol || 'https'}://`;

        const url = new URL(incomingRequest.originalUrl || incomingRequest.url || '', `${protocol}${hostname || ''}`);

        return url;
      },
      transformResponse: ({ body, headers, status }) => {
        Object.entries(headers).forEach(([headerName, headerValue]) => {
          response.setHeader(headerName, headerValue as string);
        });

        return response.status(status).send(body);
      },
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - extractHeader(key: string): string | null | undefined)
 - header(incomingRequest.headers[key.toLowerCase()];

      return Array.isArray(header) ? header[0] : header...)
 - qs(incomingRequest.query[key];

        return Array.isArray(qs) ? qs[0] : qs;
      },
      url: ())
 - url(new URL(incomingRequest.originalUrl || incomingRequest.url || '', `${protocol}${hostname || ''}`);

...)
Declaraciones 'export' encontradas:
- export class NovuHandler

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/servers/nest/nest.interface.ts
Tamaño: 180 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { ServeHandlerOptions } from '../../handler';

export type NovuModuleOptions = ServeHandlerOptions & {
  apiPath: string;
  controllerDecorators?: ClassDecorator[];
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/servers/nest/nest.module-definition.ts
Tamaño: 588 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ConfigurableModuleBuilder } from '@nestjs/common';
import { NovuModuleOptions } from './nest.interface';

// use ConfigurableModuleBuilder, because building dynamic modules from scratch is painful
export const {
  ConfigurableModuleClass: NovuBaseModule,
  MODULE_OPTIONS_TOKEN: NOVU_OPTIONS,
  OPTIONS_TYPE,
  ASYNC_OPTIONS_TYPE,
} = new ConfigurableModuleBuilder<NovuModuleOptions>()
  .setClassMethodName('register')
  .setFactoryMethodName('createNovuModuleOptions')
  .setExtras((definition: NovuModuleOptions) => ({
    ...definition,
    isGlobal: true,
  }))
  .build();


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/servers/nest/nest.module.ts
Tamaño: 2491 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Module, Provider } from '@nestjs/common';
import { NovuClient } from './nest.client';
import { NovuController } from './nest.controller';
import { NovuHandler } from './nest.handler';
import { ASYNC_OPTIONS_TYPE, NovuBaseModule, OPTIONS_TYPE } from './nest.module-definition';
import { registerApiPath } from './nest.register-api-path';
import { applyDecorators } from './nest.utils';

/**
 * In NestJS, serve and register any declared workflows with Novu, making
 * them available to be triggered by events.
 *
 * @example
 * ```ts
 * import { NovuModule } from "@novu/framework/nest";
 * import { myWorkflow } from "./src/novu/workflows"; // Your workflows
 *
 * @Module({
 *   imports: [
 *     // Expose the middleware on our recommended path at `/api/novu`.
 *     NovuModule.register({
 *       apiPath: '/api/novu',
 *       workflows: [myWorkflow]
 *     })
 *   ]
 * })
 * export class AppModule {}
 *
 * const app = await NestFactory.create(AppModule);
 *
 * // Important:  ensure you add JSON middleware to process incoming JSON POST payloads.
 * app.use(express.json());
 * ```
 */
@Module({})
export class NovuModule extends NovuBaseModule {
  /**
   * Register the Novu module
   *
   * @param options - The options to register the Novu module
   * @param customProviders - Custom providers to register. These will be merged with the default providers.
   * @returns The Novu module
   */
  static register(options: typeof OPTIONS_TYPE, customProviders?: Provider[]) {
    const superModule = NovuBaseModule.register(options);

    superModule.controllers = [applyDecorators(NovuController, options.controllerDecorators || [])];
    superModule.providers?.push(registerApiPath, NovuClient, NovuHandler, ...(customProviders || []));
    superModule.exports = [NovuClient, NovuHandler];

    return superModule;
  }

  /**
   * Register the Novu module asynchronously
   *
   * @param options - The options to register the Novu module
   * @param customProviders - Custom providers to register. These will be merged with the default providers.
   * @returns The Novu module
   */
  static registerAsync(options: typeof ASYNC_OPTIONS_TYPE, customProviders?: Provider[]) {
    const superModule = NovuBaseModule.registerAsync(options);

    superModule.controllers = [NovuController];
    superModule.providers?.push(registerApiPath, NovuClient, NovuHandler, ...(customProviders || []));
    superModule.exports = [NovuClient, NovuHandler];

    return superModule;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class AppModule
- export class NovuModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/servers/nest/nest.register-api-path.ts
Tamaño: 1005 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { FactoryProvider } from '@nestjs/common';
import { PATH_METADATA } from '@nestjs/common/constants';
import { NOVU_OPTIONS, REGISTER_API_PATH } from './nest.constants';
import { NovuController } from './nest.controller';
import { OPTIONS_TYPE } from './nest.module-definition';

/**
 * Workaround to dynamically set the path for the controller.
 *
 * A custom provider is necessary to ensure that the controller path is set during
 * application initialization, because NestJS does not support declaration of
 * paths after the application has been initialized.
 *
 * @see https://github.com/nestjs/nest/issues/1438#issuecomment-863446608
 */
export const registerApiPath: FactoryProvider = {
  provide: REGISTER_API_PATH,
  useFactory: (options: typeof OPTIONS_TYPE) => {
    if (!options.apiPath) {
      throw new Error('`apiPath` must be provided to set the controller path');
    }

    Reflect.defineMetadata(PATH_METADATA, options.apiPath, NovuController);
  },
  inject: [NOVU_OPTIONS],
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - FactoryProvider({
  provide: REGISTER_API_PATH,
  useFactory: (options: typeof OPTIONS_TYPE))
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/servers/nest/nest.utils.ts
Tamaño: 302 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Type } from '@nestjs/common';

export function applyDecorators<T>(baseClass: Type<T>, decorators: Array<ClassDecorator> = []): Type<T> {
  return decorators.reduce((decoratedClass, decorator) => {
    const result = decorator(decoratedClass);

    return result as Type<T>;
  }, baseClass);
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export function applyDecorators

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/types/code.types.ts
Tamaño: 46 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export type CodeResult = {
  code: string;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/types/config.types.ts
Tamaño: 901 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export type ClientOptions = {
  /**
   * Use Novu Cloud US (https://api.novu.co) or EU deployment (https://eu.api.novu.co). Defaults to US.
   */
  apiUrl?: string;

  /**
   * Specify your Novu secret key, to secure the Bridge Endpoint, and Novu API communication.
   * Novu communicates securely with your endpoint using a signed HMAC header,
   * ensuring that only trusted requests from Novu are actioned by your Bridge API.
   * The secret key is used to sign the HMAC header.
   */
  secretKey?: string;

  /**
   * Explicitly use HMAC signature verification.
   * Setting this to `false` will enable Novu to communicate with your Bridge API
   * without requiring a valid HMAC signature.
   * This is useful for local development and testing.
   *
   * In production you must specify an `secretKey` and set this to `true`.
   *
   * Defaults to true.
   */
  strictAuthentication?: boolean;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/types/context.types.ts
Tamaño: 2710 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

type ContextType = string;
type ContextId = string;
type ContextData = Record<string, unknown>;

/**
 * Context value can be either a simple string identifier or a rich object with additional data
 *
 * @example
 * // Simple string value
 * "org-acme"
 *
 * @example
 * // Rich object with optional data
 * {
 *   id: "org-acme",
 *   data: { name: "Acme Corp", plan: "enterprise" }
 * }
 */
export type ContextValue =
  | string
  | {
      id: ContextId;
      data?: ContextData;
    };

/**
 * Context payload represents the raw context data provided by users when triggering workflows.
 * It's a flexible structure that maps context types to their values.
 *
 * This is the input format that gets processed and resolved into ContextResolved.
 *
 * @example
 * // Single context with string value
 * { tenant: "org-acme" }
 *
 * @example
 * // Multiple contexts with string values
 * { tenant: "org-acme", app: "jira", user: "john-doe" }
 *
 * @example
 * // Context with rich object containing additional data
 * {
 *   tenant: {
 *     id: "org-acme",
 *     data: { name: "Acme Corp", plan: "enterprise" }
 *   }
 * }
 *
 * @example
 * // Mixed context values (string and object)
 * {
 *   tenant: { id: "org-acme", data: { name: "Acme Corp" } },
 *   app: "jira",
 *   user: "john-doe"
 * }
 */
export type ContextPayload = Partial<Record<ContextType, ContextValue>>;

/**
 * Resolved contexts represent the normalized, fully-processed context data used internally
 * throughout the application and framework. This ensures consistent structure regardless
 * of the input format in ContextPayload.
 *
 * All contexts are normalized to have both an `id` and `data` field, even if the original
 * payload only provided a string value (in which case `data` will be an empty object).
 *
 * This type is used to:
 * - Pass context data between services without exposing full entity details
 * - Ensure consistent context structure in workflow execution
 * - Provide type safety for context access in templates and conditions
 *
 * @example
 * // Resolved from payload: { tenant: "org-acme", app: "jira" }
 * {
 *   tenant: {
 *     id: "org-acme",
 *     data: {} // Empty data since only ID was provided
 *   },
 *   app: {
 *     id: "jira",
 *     data: {} // Empty data since only ID was provided
 *   }
 * }
 *
 * @example
 * // Resolved from payload with rich data
 * {
 *   tenant: {
 *     id: "org-acme",
 *     data: { name: "Acme Corp", plan: "enterprise", region: "us-east" }
 *   },
 *   app: {
 *     id: "jira",
 *     data: { version: "8.0", environment: "production" }
 *   }
 * }
 */
export type ContextResolved = Record<
  ContextType,
  {
    id: ContextId;
    data: ContextData;
  }
>;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/types/discover.types.ts
Tamaño: 2795 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ActionStepEnum, ChannelStepEnum } from '../constants';
import type { WorkflowPreferencesPartial } from '../shared';
import type { EventTriggerParams, EventTriggerResult } from './event.types';
import type { WithPassthrough } from './provider.types';
import type { JsonSchema, Schema } from './schema.types';
import type { StepOptions } from './step.types';
import type { Awaitable, Prettify } from './util.types';
import type { Execute, SeverityLevelEnum } from './workflow.types';

export type StepType = `${ChannelStepEnum | ActionStepEnum}`;

export type DiscoverProviderOutput = {
  type: string;
  code: string;
  resolve: ({
    controls,
    outputs,
  }: {
    controls: Record<string, unknown>;
    outputs: Record<string, unknown>;
  }) => Awaitable<WithPassthrough<Record<string, unknown>>>;
  outputs: {
    schema: JsonSchema;
    unknownSchema: Schema;
  };
};

export type DiscoverStepOutput = {
  stepId: string;
  type: StepType;
  controls: {
    schema: JsonSchema;
    unknownSchema: Schema;
  };
  outputs: {
    schema: JsonSchema;
    unknownSchema: Schema;
  };
  results: {
    schema: JsonSchema;
    unknownSchema: Schema;
  };
  code: string;
  resolve: (controls: Record<string, unknown>) => Awaitable<Record<string, unknown>>;
  providers: Array<DiscoverProviderOutput>;
  options: StepOptions;
};

export type DiscoverWorkflowOutput = {
  workflowId: string;
  execute: Execute<Record<string, unknown>, Record<string, unknown>>;
  code: string;
  steps: Array<DiscoverStepOutput>;
  payload: {
    schema: JsonSchema;
    unknownSchema: Schema;
  };
  controls: {
    schema: JsonSchema;
    unknownSchema: Schema;
  };
  preferences: WorkflowPreferencesPartial;
  tags: string[];
  name?: string;
  description?: string;
  severity: SeverityLevelEnum;
};

/**
 * A workflow resource.
 *
 * @property `id` - The unique identifier for the workflow.
 * @property `trigger` - The function to trigger the workflow.
 * @property `discover` - The function to discover the workflow definition.
 */
export type Workflow<T_Payload = never> = {
  /**
   * The unique identifier for the workflow.
   */
  id: string;
  /**
   * Trigger an event for this workflow with a strongly typed and validated `payload`, derived from the `payloadSchema`.
   *
   * @param event - The event to trigger
   * @returns `EventTriggerResult` - The result of the event trigger
   */
  trigger: (
    event: Prettify<Omit<EventTriggerParams<T_Payload>, 'workflowId' | 'bridgeUrl' | 'controls'>>
  ) => Promise<EventTriggerResult>;
  /**
   * Discover the workflow definition.
   *
   * @returns `DiscoverWorkflowOutput` - The workflow definition
   */
  discover: () => Promise<DiscoverWorkflowOutput>;
};

export type DiscoverOutput = {
  workflows: Array<DiscoverWorkflowOutput>;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - DiscoverProviderOutput({
  type: string;
  code: string;
  resolve: ({
    controls,
    outputs,
  }: {
    controls: Reco...)
 - DiscoverStepOutput({
  stepId: string;
  type: StepType;
  controls: {
    schema: JsonSchema;
    unknownSchema: Schem...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/types/error.types.ts
Tamaño: 1743 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/**
 * The required format for an error code.
 */
export type IErrorCodeKey = `${Uppercase<string>}_ERROR`;
export type IErrorCodeVal = `${Capitalize<string>}Error`;

/**
 * Helper function to test that enum keys and values match correct format.
 *
 * It is not possible as of Typescript 5.2 to declare a type for an enum key or value in-line.
 * Therefore we must test the enum via a helper function that abstracts the enum to an object.
 *
 * If the test fails, you should review your `enum` to verify that
 * * keys match the format specified by the `IErrorCodeKey` template literal type.
 * * values match the format specified by the `IErrorCodeVal` template literal type.
 * * keys are CONSTANT_CASED versions of the PascalCased values.
 * ref: https://stackoverflow.com/a/58181315
 *
 * @param testEnum - the Enum to type check
 */
export function testErrorCodeEnumValidity<TEnum extends Record<IErrorCodeKey, IErrorCodeVal>>(
  testEnum: TEnum &
    Record<
      Exclude<keyof TEnum, keyof Record<ToConstantCaseForString<TEnum[keyof TEnum] & string>, TEnum[keyof TEnum]>>,
      ['Key must be CONSTANT_CASED version of the PascalCased value']
    >
): void {}

/**
 * Helper function to convert a PascalCase string to CONSTANT_CASE.
 */
type PascalToConstant<T extends string> = T extends `${infer First}${infer Rest}`
  ? `${First extends Capitalize<First> ? '_' : ''}${Uppercase<First>}${PascalToConstant<Rest>}`
  : '';

/**
 * Convert a PascalCase string to CONSTANT_CASE.
 *
 * @example
 * ```ts
 * type Test = PascalToConstant<"FirstName">; // "FIRST_NAME"
 * ```
 */
export type ToConstantCaseForString<T extends string> = PascalToConstant<T> extends `_${infer WithoutUnderscore}`
  ? WithoutUnderscore
  : PascalToConstant<T>;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export  type
- export function testErrorCodeEnumValidity
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/types/errors.types.test.ts
Tamaño: 1988 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { describe, expect, it } from 'vitest';
import { IErrorCodeKey, IErrorCodeVal, testErrorCodeEnumValidity } from './error.types';

describe('Error Codes', () => {
  /**
   * This describe block resolves the Jest error of a test suite not having any tests.
   * It has no other purpose.
   */
  it('tests the Typescript compiler errors below', () => {
    expect(true).toBe(true);
  });
});

/**
 * IErrorCodeKey tests
 */
// Valid
const validErrorCodeKey: IErrorCodeKey = 'SOMETHING_ERROR';

// @ts-expect-error - Not ending with `_ERROR`
const invalidErrorCodeKeySuffix: IErrorCodeKey = 'SOMETHING_WRONG';

// @ts-expect-error - Not uppercase
const invalidErrorCodeKeyCase: IErrorCodeKey = 'Something_ERROR';

/**
 * IErrorCodeVal tests
 */
// Valid
const validErrorCodeVal: IErrorCodeVal = 'SomethingError';

// @ts-expect-error - Not ending with `Error`
const invalidErrorCodeValSuffix: IErrorCodeVal = 'SomethingIssue';

// @ts-expect-error - Not PascalCase
const invalidErrorCodeValCase: IErrorCodeVal = 'somethingError';

/**
 * testErrorCodeEnumValidity Tests
 */
enum ValidErrorCodeEnum {
  SOMETHING_ERROR = 'SomethingError',
  ANOTHER_THING_ERROR = 'AnotherThingError',
}
testErrorCodeEnumValidity(ValidErrorCodeEnum);

enum InvalidKeyErrorCodeEnum {
  SOMETHING_ERROR = 'SomethingError',
  WRONG_FORMAT = 'WrongFormatError',
}
// @ts-expect-error - Invalid key - WRONG_FORMAT
testErrorCodeEnumValidity(InvalidKeyErrorCodeEnum);

enum InvalidValueErrorCodeEnum {
  SOMETHING_ERROR = 'SomethingError',
  ANOTHER_THING_ERROR = 'AnotherThingIssue',
}
// @ts-expect-error - Invalid value on ANOTHER_THING_ERROR: 'AnotherThingIssue'
testErrorCodeEnumValidity(InvalidValueErrorCodeEnum);

enum NonMatchingConstantCaseValueEnum {
  SOMETHING_ELSE_ERROR = 'SomethingError', // The CONSTANT_CASE key does not match the PascalCase value
}
// @ts-expect-error - Key must be CONSTANT_CASED version of the PascalCased value
testErrorCodeEnumValidity(NonMatchingConstantCaseValueEnum);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

No se detectaron funciones/exportaciones con heurística JS/TS.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/types/event.types.ts
Tamaño: 2287 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { ISubscriberPayload, ITriggerPayload, TriggerEventStatusEnum, TriggerRecipientsPayload } from '../shared';
import { ContextPayload } from './context.types';
import { ConditionalPartial, PickRequiredKeys } from './util.types';

type EventPayload = ITriggerPayload;

type Actor = string | ISubscriberPayload;

type Recipients = TriggerRecipientsPayload;

export type EventTriggerResult = {
  /**
   * Cancel the workflow execution
   */
  cancel: () => Promise<CancelEventTriggerResponse>;
  /**
   * Response data for the trigger
   */
  data: EventTriggerResponse;
};

export type EventTriggerParams<T_Payload = EventPayload> = {
  /**
   * Workflow id
   */
  workflowId: string;
  /**
   * Recipients to trigger the workflow to
   */
  to: Recipients;
  /**
   * Actor to trigger the workflow from
   */
  actor?: Actor;
  /**
   * Context to trigger the workflow with
   */
  context?: ContextPayload;
  /**
   * Bridge url to trigger the workflow to
   */
  bridgeUrl?: string;
  /**
   * Transaction id for trigger
   */
  transactionId?: string;
  /**
   * Overrides for trigger
   */
  overrides?: Record<string, unknown>;
  /**
   * Controls for the step execution
   */
  controls?: {
    steps: {
      [stepId: string]: Record<string, unknown>;
    };
  };
  /**
   * Use Novu Cloud US (https://api.novu.co) or EU deployment (https://eu.api.novu.co). Defaults to US.
   */
  apiUrl?: string;
  /**
   * Override secret key for the trigger
   */
  secretKey?: string;
} & ConditionalPartial<
  {
    /**
     * Payload to trigger the workflow with
     */
    payload: T_Payload;
  },
  PickRequiredKeys<T_Payload> extends never ? true : false
>;

export type EventTriggerResponse = {
  /**
   * If trigger was acknowledged or not
   */
  acknowledged: boolean;
  /**
   * Status for trigger
   */
  status: `${TriggerEventStatusEnum}`;
  /**
   * Any errors encountered during the trigger
   */
  error?: string[];
  /**
   * Unique transaction identifier for the event
   */
  transactionId?: string;
};

/**
 * Flag indicating if the event was cancelled or not.
 * `false` indicates the event was not cancelled because the execution was completed.
 * `true` indicates the in-flight execution was cancelled.
 */
export type CancelEventTriggerResponse = boolean;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - EventTriggerResult({
  /**
   * Cancel the workflow execution
   */
  cancel: ())
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/types/execution.types.ts
Tamaño: 1038 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { PostActionEnum } from '../constants';
import type { ContextResolved } from './context.types';
import { WithPassthrough } from './provider.types';
import type { Subscriber } from './subscriber.types';

export type Event = {
  payload: Record<string, unknown>;
  workflowId: string;
  stepId: string;
  controls: Record<string, unknown>;
  state: State[];
  action: Exclude<PostActionEnum, PostActionEnum.TRIGGER>;
  subscriber: Subscriber;
  context: ContextResolved;
};

export type State = {
  stepId: string;
  outputs: Record<string, unknown>;
  state: { status: string; error?: string };
};

export type ExecuteOutputMetadata = {
  status: string;
  error: boolean;
  /**
   * The duration of the step execution in milliseconds
   */
  duration: number;
};

export type ExecuteOutputOptions = {
  skip: boolean;
};

export type ExecuteOutput = {
  outputs: Record<string, unknown>;
  providers?: Record<string, WithPassthrough<Record<string, unknown>>>;
  options: ExecuteOutputOptions;
  metadata: ExecuteOutputMetadata;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/types/health-check.types.ts
Tamaño: 170 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export type HealthCheck = {
  status: 'ok' | 'error';
  sdkVersion: string;
  frameworkVersion: string;
  discovered: {
    workflows: number;
    steps: number;
  };
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/types/import.types.ts
Tamaño: 1241 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export type ImportRequirement = {
  /**
   * The name of the dependency.
   *
   * This is a necessary duplicate as ESM does not provide a consistent API for
   * reading the name of a dependency that can't be resolved.
   *
   * @example
   * ```typescript
   * 'module-name'
   * ```
   */
  name: string;
  /**
   * The import statement for the required dependency. An explicit `import('module-name')`
   * call with a static module string is necessary to ensure that the bundler will make
   * the dependency available for usage after tree-shaking. Without a static string,
   * tree-shaking may aggressively remove the import, making it unavailable.
   *
   * This syntax is required during synchronous declaration (e.g. on a class property),
   * but should only be awaited when you can handle a runtime import error.
   *
   * @example
   * ```typescript
   * import('module-name')
   * ```
   */
  import: Promise<{ default: unknown } & Record<string, unknown>>;
  /**
   * The required exports of the dependency. The availability of these exports are
   * checked by the import validator to verify the dependency is installed.
   *
   * @example
   * ```typescript
   * ['my-export']
   * ```
   */
  exports: readonly string[];
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/types/index.ts
Tamaño: 492 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './code.types';
export * from './config.types';
export * from './context.types';
export * from './discover.types';
export * from './event.types';
export * from './execution.types';
export * from './health-check.types';
export * from './schema.types';
export * from './server.types';
export * from './skip.types';
export * from './step.types';
export * from './subscriber.types';
export * from './util.types';
export * from './validator.types';
export * from './workflow.types';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/types/provider.types.ts
Tamaño: 978 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { providerSchemas } from '../schemas/providers';
import type { FromSchemaUnvalidated } from './schema.types';
import { Awaitable, Prettify } from './util.types';

export type Passthrough = {
  body?: Record<string, unknown>;
  headers?: Record<string, string>;
  query?: Record<string, string>;
};

export type WithPassthrough<T> = Prettify<T & { _passthrough?: Passthrough }>;

export type Providers<T_StepType extends keyof typeof providerSchemas, T_Controls, T_Output> = {
  [K in keyof (typeof providerSchemas)[T_StepType]]?: (step: {
    /**
     * The controls for the step.
     */
    controls: T_Controls;
    /**
     * The outputs of the step.
     */
    outputs: T_Output;
    // TODO: fix the typing for `type` to use the keyof providerSchema[channelType]
    // @ts-expect-error - Types of parameters 'options' and 'options' are incompatible.
  }) => Awaitable<WithPassthrough<FromSchemaUnvalidated<(typeof providerSchemas)[T_StepType][K]['output']>>>;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/types/server.types.ts
Tamaño: 117 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export type SupportedFrameworkName = 'next' | 'express' | 'nuxt' | 'h3' | 'sveltekit' | 'remix' | 'lambda' | 'nest';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/types/skip.types.ts
Tamaño: 107 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { Awaitable } from './util.types';

export type Skip<T> = (controls: T) => Awaitable<boolean>;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/types/step.types.ts
Tamaño: 9630 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChannelStepEnum } from '../constants';
import { actionStepSchemas } from '../schemas/steps/actions';
import {
  delayDynamicOutputSchema,
  delayRegularOutputSchema,
  delayTimedOutputSchema,
} from '../schemas/steps/actions/delay.schema';
import { digestRegularOutputSchema, digestTimedOutputSchema } from '../schemas/steps/actions/digest.schema';
import { channelStepSchemas } from '../schemas/steps/channels';
import type { Providers } from './provider.types';
import type { FromSchema, FromSchemaUnvalidated, Schema } from './schema.types';
import type { Skip } from './skip.types';
import type { Awaitable, Prettify } from './util.types';

export type StepOptions<
  T_ControlSchema extends Schema = Schema,
  T_Controls extends Record<string, unknown> = FromSchema<T_ControlSchema>,
> = {
  /**
   * Skip the step. If the skip function returns true, the step will be skipped.
   *
   * @param controls The controls for the step.
   */
  skip?: Skip<T_Controls>;
  /**
   * The schema for the controls of the step. Used to validate the user-provided controls from Novu Dashboard.
   */
  controlSchema?: T_ControlSchema;
};

export enum JobStatusEnum {
  PENDING = 'pending',
  QUEUED = 'queued',
  RUNNING = 'running',
  COMPLETED = 'completed',
  FAILED = 'failed',
  DELAYED = 'delayed',
  CANCELED = 'canceled',
  MERGED = 'merged',
  SKIPPED = 'skipped',
}

export type StepContext = {
  /** The context of the step. */
  _ctx: {
    /** The timestamp of the step. */
    timestamp: number;
    /** The state of the step. */
    state: {
      /** The status of the step. */
      status: `${JobStatusEnum}`;
      /** A boolean flag to indicate if the step has errored. */
      error: boolean;
    };
  };
};

export type StepOutput<T_Result> = Promise<T_Result & StepContext>;

export type ActionStep<
  T_Outputs extends Record<string, unknown> = Record<string, unknown>,
  T_Result extends Record<string, unknown> = Record<string, unknown>,
> = <
  /**
   * The schema for the controls of the step.
   */
  T_ControlSchema extends Schema,
  /**
   * The controls for the step.
   */
  T_Controls extends Record<string, unknown> = FromSchema<T_ControlSchema>,
>(
  /**
   * The name of the step. This is used to identify the step in the workflow.
   */
  name: string,
  /**
   * The function to resolve the step notification content for the step.
   *
   * @param controls The controls for the step.
   */
  resolve: (controls: T_Controls) => Awaitable<T_Outputs>,
  /**
   * The options for the step.
   */
  options?: StepOptions<T_ControlSchema, T_Controls>
) => StepOutput<T_Result>;

export type CustomStep = <
  /**
   * The schema for the controls of the step.
   */
  T_ControlSchema extends Schema = Schema,
  /**
   * The schema for the outputs of the step.
   */
  T_OutputsSchema extends Schema = Schema,
  /**
   * The controls for the step.
   */
  T_Controls extends Record<string, unknown> = FromSchema<T_ControlSchema>,
  /*
   * These intermediary types are needed to capture the types in a single type instance
   * to stop Typescript from erroring with:
   * `Type instantiation is excessively deep and possibly infinite.`
   */
  T_IntermediaryResult extends Record<string, unknown> = FromSchema<T_OutputsSchema>,
  T_IntermediaryOutput extends Record<string, unknown> = FromSchemaUnvalidated<T_OutputsSchema>,
  /**
   * The output for the step.
   */
  T_Outputs extends T_IntermediaryOutput = T_IntermediaryOutput,
  /**
   * The result for the step.
   */
  T_Result extends T_IntermediaryResult = T_IntermediaryResult,
>(
  /**
   * The name of the step. This is used to identify the step in the workflow.
   */
  name: string,
  /**
   * The function to resolve the custom data for the step.
   *
   * @param controls The controls for the step.
   */
  resolve: (controls: T_Controls) => Awaitable<T_Outputs>,
  /**
   * The options for the step.
   */
  options?: StepOptions<T_ControlSchema, T_Controls> & {
    /**
     * The schema for the outputs of the step. Used to validate the output of the `resolve` function.
     */
    outputSchema?: T_OutputsSchema;
  }
) => StepOutput<T_Result>;

export type ChannelStep<
  /**
   * The type of channel step.
   */
  T_StepType extends keyof typeof channelStepSchemas = keyof typeof channelStepSchemas,
  /**
   * The outputs for the step.
   */
  T_Outputs extends Record<string, unknown> = Record<string, unknown>,
  /**
   * The result for the step.
   */
  T_Result extends Record<string, unknown> = Record<string, unknown>,
> = <
  /**
   * The schema for the controls of the step.
   */
  T_ControlSchema extends Schema,
  /**
   * The controls for the step.
   */
  T_Controls extends Record<string, unknown> = FromSchema<T_ControlSchema>,
>(
  /**
   * The name of the step. This is used to identify the step in the workflow.
   */
  name: string,
  /**
   * The function to resolve the step notification content for the step.
   *
   * @param controls The controls for the step.
   */
  resolve: (controls: T_Controls) => Awaitable<T_Outputs>,
  /**
   * The options for the step.
   */
  options?: StepOptions<T_ControlSchema, T_Controls> & {
    /**
     * The providers for the step. Used to override the behaviour of the providers for the step.
     */
    providers?: Prettify<Providers<T_StepType, T_Controls, T_Outputs>>;
    /**
     * A flag to disable output sanitization for the step.
     *
     * @default false
     */
    disableOutputSanitization?: boolean;
  }
) => StepOutput<T_Result>;

export type EmailOutput = FromSchema<(typeof channelStepSchemas)['email']['output']>;
export type EmailOutputUnvalidated = FromSchemaUnvalidated<(typeof channelStepSchemas)['email']['output']>;
export type EmailResult = FromSchema<(typeof channelStepSchemas)['email']['result']>;

export type SmsOutput = FromSchema<(typeof channelStepSchemas)['sms']['output']>;
export type SmsOutputUnvalidated = FromSchemaUnvalidated<(typeof channelStepSchemas)['sms']['output']>;
export type SmsResult = FromSchema<(typeof channelStepSchemas)['sms']['result']>;

export type PushOutput = FromSchema<(typeof channelStepSchemas)['push']['output']>;
export type PushOutputUnvalidated = FromSchemaUnvalidated<(typeof channelStepSchemas)['push']['output']>;
export type PushResult = FromSchema<(typeof channelStepSchemas)['push']['result']>;

export type ChatOutput = FromSchema<(typeof channelStepSchemas)['chat']['output']>;
export type ChatOutputUnvalidated = FromSchemaUnvalidated<(typeof channelStepSchemas)['chat']['output']>;
export type ChatResult = FromSchema<(typeof channelStepSchemas)['chat']['result']>;

export type InAppOutput = FromSchema<(typeof channelStepSchemas)['in_app']['output']>;
export type InAppOutputUnvalidated = FromSchemaUnvalidated<(typeof channelStepSchemas)['in_app']['output']>;
export type InAppResult = FromSchema<(typeof channelStepSchemas)['in_app']['result']>;

export type DelayRegularOutput = FromSchema<typeof delayRegularOutputSchema>;
export type DelayRegularOutputUnvalidated = FromSchemaUnvalidated<typeof delayRegularOutputSchema>;
export type DelayTimedOutput = FromSchema<typeof delayTimedOutputSchema>;
export type DelayTimedOutputUnvalidated = FromSchemaUnvalidated<typeof delayTimedOutputSchema>;
export type DelayDynamicOutput = FromSchema<typeof delayDynamicOutputSchema>;
export type DelayDynamicOutputUnvalidated = FromSchemaUnvalidated<typeof delayDynamicOutputSchema>;

export type DelayOutput = FromSchema<(typeof actionStepSchemas)['delay']['output']>;
export type DelayOutputUnvalidated = FromSchemaUnvalidated<(typeof actionStepSchemas)['delay']['output']>;
export type DelayResult = FromSchema<(typeof actionStepSchemas)['delay']['result']>;

export type DigestRegularOutput = FromSchema<typeof digestRegularOutputSchema>;
export type DigestRegularOutputUnvalidated = FromSchemaUnvalidated<typeof digestRegularOutputSchema>;
export type DigestTimedOutput = FromSchema<typeof digestTimedOutputSchema>;
export type DigestTimedOutputUnvalidated = FromSchemaUnvalidated<typeof digestTimedOutputSchema>;

export type DigestOutput = FromSchema<(typeof actionStepSchemas)['digest']['output']>;
export type DigestOutputUnvalidated = FromSchemaUnvalidated<(typeof actionStepSchemas)['digest']['output']>;
export type DigestResult = FromSchema<(typeof actionStepSchemas)['digest']['result']>;

export type ThrottleOutput = FromSchema<(typeof actionStepSchemas)['throttle']['output']>;
export type ThrottleOutputUnvalidated = FromSchemaUnvalidated<(typeof actionStepSchemas)['throttle']['output']>;
export type ThrottleResult = FromSchema<(typeof actionStepSchemas)['throttle']['result']>;

/**
 * The step type.
 */
export type Step = {
  /** Send an email. */
  email: ChannelStep<ChannelStepEnum.EMAIL, EmailOutputUnvalidated, EmailResult>;
  /** Send an SMS. */
  sms: ChannelStep<ChannelStepEnum.SMS, SmsOutputUnvalidated, SmsResult>;
  /** Send a push notification. */
  push: ChannelStep<ChannelStepEnum.PUSH, PushOutputUnvalidated, PushResult>;
  /** Send a chat message. */
  chat: ChannelStep<ChannelStepEnum.CHAT, ChatOutputUnvalidated, ChatResult>;
  /** Send an in-app notification. */
  inApp: ChannelStep<ChannelStepEnum.IN_APP, InAppOutputUnvalidated, InAppResult>;
  /** Aggregate events for a period of time. */
  digest: ActionStep<DigestOutputUnvalidated, DigestResult>;
  /** Delay the workflow for a period of time. */
  delay: ActionStep<DelayOutputUnvalidated, DelayResult>;
  /** Throttle workflow executions within a time window. */
  throttle: ActionStep<ThrottleOutputUnvalidated, ThrottleResult>;
  /** Execute custom code */
  custom: CustomStep;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - T_IntermediaryResult(T_IntermediaryResult,
>(
  /**
   * The name of the step. This is used to identify the step in the w...)
Declaraciones 'export' encontradas:
- export  type
- export  enum
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/types/subscriber.types.ts
Tamaño: 214 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export type Subscriber = {
  subscriberId?: string;
  firstName?: string | null;
  lastName?: string | null;
  email?: string | null;
  phone?: string | null;
  avatar?: string | null;
  locale?: string | null;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/types/util.types.test-d.ts
Tamaño: 8948 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { describe, it } from 'vitest';
import {
  Awaitable,
  ConditionalPartial,
  DeepPartial,
  DeepRequired,
  Either,
  PickOptional,
  PickOptionalKeys,
  PickRequired,
  PickRequiredKeys,
  Prettify,
} from './util.types';

describe('Either', () => {
  it('should compile when the first type is the correct type', () => {
    type TestEither = Either<{ foo: string }, { bar: number }>;
    const testEitherValid: TestEither = { foo: 'bar' };
  });

  it('should compile when the second type is the correct type', () => {
    type TestEither = Either<{ foo: string }, { bar: number }>;
    const testEitherValid: TestEither = { bar: 123 };
  });

  it('should compile when a shared property is present', () => {
    type TestEither = Either<{ foo: string }, { foo: string; bar: number }>;
    const testEitherValid: TestEither = { foo: 'bar', bar: 123 };
  });

  it('should not compile when neither type is the correct type', () => {
    type TestEither = Either<{ foo: string }, { bar: number }>;
    // @ts-expect-error - foo should be a string
    const testEitherInvalid: TestEither = { foo: 123 };
  });
});

describe('Awaitable', () => {
  it('should compile when the type is an awaitable', () => {
    type TestAwaitable = Awaitable<Promise<string>>;
    const testAwaitableValid: TestAwaitable = Promise.resolve('bar');
  });

  it('should compile when the type is not an awaitable', () => {
    type TestAwaitable = Awaitable<string>;
    const testAwaitableValid: TestAwaitable = 'bar';
  });

  it('should not compile when a non-awaitable type has incorrect properties', () => {
    type TestAwaitable = Awaitable<{ foo: string }>;
    // @ts-expect-error - foo should be a string
    const testAwaitableInvalid: TestAwaitable = { foo: 123 };
  });

  it('should not compile when an awaitable type has incorrect properties', () => {
    type TestAwaitable = Awaitable<{ foo: string }>;
    // @ts-expect-error - foo should be a string
    const testAwaitableInvalid: TestAwaitable = Promise.resolve({ foo: 123 });
  });
});

describe('ConditionalPartial', () => {
  it('should compile an empty object when the condition is true', () => {
    type TestConditionalPartialTrue = ConditionalPartial<{ foo: string }, true>;
    const testConditionalPartialTrueValid: TestConditionalPartialTrue = {};
  });

  it('should compile an object with the correct type of properties when the condition is true', () => {
    type TestConditionalPartialTrue = ConditionalPartial<{ foo: string }, true>;
    const testConditionalPartialTrueValid: TestConditionalPartialTrue = { foo: 'bar' };
  });

  it('should not compile an object with the wrong type of properties when the condition is true', () => {
    type TestConditionalPartialTrue = ConditionalPartial<{ foo: string }, true>;
    // @ts-expect-error - foo should be a string
    const testConditionalPartialTrueInvalid: TestConditionalPartialTrue = { foo: 123 };
  });

  it('should compile an object with the required properties when the condition is false', () => {
    type TestConditionalPartialFalse = ConditionalPartial<{ foo: string }, false>;
    const testConditionalPartialFalseValid: TestConditionalPartialFalse = { foo: 'bar' };
  });

  it('should not compile an empty object when the condition is false', () => {
    type TestConditionalPartialFalse = ConditionalPartial<{ foo: string }, false>;
    // @ts-expect-error: 'foo' is required but missing
    const testConditionalPartialFalseInvalid: TestConditionalPartialFalse = {};
  });

  it('should not compile when the first argument is not an indexable type', () => {
    // @ts-expect-error - string is not an object
    type TestConditionalPartialFalse = ConditionalPartial<string, false>;
  });
});

describe('PickOptional', () => {
  it('should compile when the optional property is present', () => {
    type TestPickOptional = PickOptional<{ foo?: string }>;
    const testPickOptionalValid: TestPickOptional = { foo: 'bar' };
  });

  it('should not compile when the optional property is the wrong type', () => {
    type TestPickOptional = PickOptional<{ foo?: string }>;
    // @ts-expect-error - foo should be a string
    const testPickOptionalInvalid: TestPickOptional = { foo: 123 };
  });

  it('should compile when the optional property is not present', () => {
    type TestPickOptional = PickOptional<{ foo?: string }>;
    const testPickOptionalValid: TestPickOptional = {};
  });

  it('should not compile when specifying a required property', () => {
    type TestPickOptional = PickOptional<{ foo?: string; bar: string }>;
    // @ts-expect-error - bar should not be present
    const testPickOptionalInvalid: TestPickOptional = { bar: 'bar' };
  });
});

describe('PickOptionalKeys', () => {
  it('should compile when the optional property is present', () => {
    type TestPickOptionalKeys = PickOptionalKeys<{ foo?: string }>;
    const testPickOptionalKeysValid: TestPickOptionalKeys = 'foo';
  });

  it('should not compile when the object has no optional properties', () => {
    type TestPickOptionalKeys = PickOptionalKeys<{ foo: string }>;
    // @ts-expect-error - no optional property is present
    const testPickOptionalKeysInvalid: TestPickOptionalKeys = 'invalid';
  });
});

describe('PickRequired', () => {
  it('should compile when the required property is present', () => {
    type TestPickRequired = PickRequired<{ foo: string }>;
    const testPickRequiredValid: TestPickRequired = { foo: 'bar' };
  });

  it('should not compile when the required property is the wrong type', () => {
    type TestPickRequired = PickRequired<{ foo: string }>;
    // @ts-expect-error - foo should be a string
    const testPickRequiredInvalid: TestPickRequired = { foo: 123 };
  });

  it('should not compile when the required property is not present', () => {
    type TestPickRequired = PickRequired<{ foo: string }>;
    // @ts-expect-error - foo should be present
    const testPickRequiredInvalid: TestPickRequired = {};
  });

  it('should not compile when specifying an optional property', () => {
    type TestPickRequired = PickRequired<{ foo?: string; bar: string }>;
    // @ts-expect-error - foo should not be present
    const testPickRequiredInvalid: TestPickRequired = { foo: 'bar', bar: 'bar' };
  });
});

describe('PickRequiredKeys', () => {
  it('should compile when the object is empty', () => {
    type TestPickRequiredKeys = PickRequiredKeys<{ foo: string }>;
    const testPickRequiredKeysValid: TestPickRequiredKeys = 'foo';
  });

  it('should not compile when the object has no required properties', () => {
    type TestPickRequiredKeys = PickRequiredKeys<{ foo?: string }>;
    // @ts-expect-error - no required property is present
    const testPickRequiredKeysInvalid: TestPickRequiredKeys = 'invalid';
  });
});

describe('Prettify', () => {
  it('should compile the prettified type to the identity type', () => {
    type TestPrettify = Prettify<{ foo: string }>;
    const testPrettifyValid: TestPrettify = { foo: 'bar' };
  });

  it('should not compile when the object has incorrect properties', () => {
    type TestPrettify = Prettify<{ foo: string }>;
    // @ts-expect-error - foo should be a string
    const testPrettifyInvalid: TestPrettify = { foo: 123 };
  });
});

describe('DeepPartial', () => {
  it('should make a top-level property optional', () => {
    type TestDeepPartial = DeepPartial<{ foo: string }>;
    const testDeepPartialValid: TestDeepPartial = { foo: undefined };
  });

  it('should make a nested property optional', () => {
    type TestDeepPartial = DeepPartial<{ foo: { bar: string } }>;
    const testDeepPartialValid: TestDeepPartial = { foo: { bar: undefined } };
  });
});

describe('DeepRequired', () => {
  it('should make a top-level property required', () => {
    type TestDeepRequired = DeepRequired<{ foo?: string }>;
    const testDeepRequiredValid: TestDeepRequired = { foo: 'bar' };
  });

  it('should make a nested object property required', () => {
    type TestDeepRequired = DeepRequired<{ foo: { bar?: string } }>;
    const testDeepRequiredValid: TestDeepRequired = { foo: { bar: 'bar' } };
  });

  it('should make a nested array property required', () => {
    type TestDeepRequired = DeepRequired<{ foo: { bar: (string | undefined)[] } }>;
    const testDeepRequiredValid: TestDeepRequired = { foo: { bar: ['bar'] } };
  });

  it('should not compile when the array has incorrect properties', () => {
    type TestDeepRequired = DeepRequired<{ foo: { bar: (string | undefined)[] } }>;
    // @ts-expect-error - bar should be an array of strings
    const testDeepRequiredInvalid: TestDeepRequired = { foo: { bar: [undefined] } };
  });

  it('should not compile when the object has incorrect properties', () => {
    type TestDeepRequired = DeepRequired<{ foo: string }>;
    // @ts-expect-error - foo should be a string
    const testDeepRequiredInvalid: TestDeepRequired = { foo: 123 };
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - TestEither({ foo: 'bar' };
  });

  it('should compile when the second type is the correct type', ())
 - TestEither({ bar: 123 };
  });

  it('should compile when a shared property is present', ())
 - TestEither({ foo: 'bar', bar: 123 };
  });

  it('should not compile when neither type is the correct type', ())
 - TestEither({ foo: 123 };
  });
});

describe('Awaitable', ())
 - TestAwaitable(Promise.resolve('bar');
  });

  it('should compile when the type is not an awaitable', ())
 - TestAwaitable('bar';
  });

  it('should not compile when a non-awaitable type has incorrect properties', ())
 - TestAwaitable({ foo: 123 };
  });

  it('should not compile when an awaitable type has incorrect properties', ())
 - TestAwaitable(Promise.resolve({ foo: 123 });
  });
});

describe('ConditionalPartial', ())
 - TestConditionalPartialTrue({};
  });

  it('should compile an object with the correct type of properties when the condition is ...)
 - TestConditionalPartialTrue({ foo: 'bar' };
  });

  it('should not compile an object with the wrong type of properties when the...)
 - TestConditionalPartialTrue({ foo: 123 };
  });

  it('should compile an object with the required properties when the condition ...)
 - TestConditionalPartialFalse({ foo: 'bar' };
  });

  it('should not compile an empty object when the condition is false', ())
 - TestConditionalPartialFalse({};
  });

  it('should not compile when the first argument is not an indexable type', ())
 - TestConditionalPartialFalse(ConditionalPartial<string, false>;
  });
});

describe('PickOptional', ())
 - TestPickOptional({ foo: 'bar' };
  });

  it('should not compile when the optional property is the wrong type', ())
 - TestPickOptional({ foo: 123 };
  });

  it('should compile when the optional property is not present', ())
 - TestPickOptional({};
  });

  it('should not compile when specifying a required property', ())
 - TestPickOptional({ bar: 'bar' };
  });
});

describe('PickOptionalKeys', ())
 - TestPickOptionalKeys('foo';
  });

  it('should not compile when the object has no optional properties', ())
 - TestPickOptionalKeys('invalid';
  });
});

describe('PickRequired', ())
 - TestPickRequired({ foo: 'bar' };
  });

  it('should not compile when the required property is the wrong type', ())
 - TestPickRequired({ foo: 123 };
  });

  it('should not compile when the required property is not present', ())
 - TestPickRequired({};
  });

  it('should not compile when specifying an optional property', ())
 - TestPickRequired({ foo: 'bar', bar: 'bar' };
  });
});

describe('PickRequiredKeys', ())
 - TestPickRequiredKeys('foo';
  });

  it('should not compile when the object has no required properties', ())
 - TestPickRequiredKeys('invalid';
  });
});

describe('Prettify', ())
 - TestPrettify({ foo: 'bar' };
  });

  it('should not compile when the object has incorrect properties', ())
 - TestPrettify({ foo: 123 };
  });
});

describe('DeepPartial', ())
 - TestDeepPartial({ foo: undefined };
  });

  it('should make a nested property optional', ())
 - TestDeepPartial({ foo: { bar: undefined } };
  });
});

describe('DeepRequired', ())
 - TestDeepRequired({ foo: 'bar' };
  });

  it('should make a nested object property required', ())
 - TestDeepRequired({ foo: { bar: 'bar' } };
  });

  it('should make a nested array property required', ())
 - TestDeepRequired({ foo: { bar: ['bar'] } };
  });

  it('should not compile when the array has incorrect properties',...)
 - TestDeepRequired({ foo: { bar: [undefined] } };
  });

  it('should not compile when the object has incorrect propert...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/types/util.types.ts
Tamaño: 3565 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * THIS FILE SHOULD NOT DEPEND ON ANY OTHER FILES.
 * IT SHOULD ONLY CONTAIN UTILITY TYPES.
 */

/**
 * A type that represents either `A` or `B`. Shared properties retain their
 * types and unique properties are marked as optional.
 */
export type Either<A, B> = Partial<A> & Partial<B> & (A | B);

/**
 * A type that represents a value that may be a promise or a regular value.
 */
export type Awaitable<T> = T | Promise<T>;

/**
 * A type that represents a type that is a prettified version of the original type.
 * The prettified type has all generics removed from intellisense and displays a flat object.
 */

export type Prettify<T> = { [K in keyof T]: T[K] } & {};

/**
 * Mark properties of T as optional if Condition is true
 */
export type ConditionalPartial<T extends Obj, Condition extends boolean> = Condition extends true ? Partial<T> : T;

/**
 * Same as Nullable except without `null`.
 */
type Optional<T> = T | undefined;

/**
 * Types that can be used to index native JavaScript types, (Object, Array, etc.).
 */
type IndexSignature = string | number | symbol;

/**
 * An object of any index-able type to avoid conflicts between `{}`, `Record`, `object`, etc.
 */
type Obj<O extends Record<IndexSignature, unknown> | object = Record<IndexSignature, unknown> | object> = {
  [K in keyof O as K extends never ? never : K]: K extends never ? never : O[K] extends never ? never : O[K];
} & Omit<O, never>;

/**
 * Any type that is indexable using `string`, `number`, or `symbol`.
 */
export type Indexable<ValueTypes = unknown> =
  | {
      [K: IndexSignature]: ValueTypes;
    }
  | Obj;

/**
 * Picks only the optional properties from a type, removing the required ones.
 * Optionally, recurses through nested objects if `DEEP` is true.
 */
export type PickOptional<T, DEEP extends boolean = true> = {
  /*
   * `DEEP` must be false b/c `never` interferes with root level objects with both optional/required properties
   * If `undefined` extends the type of the value, it's optional (e.g. `undefined extends string | undefined`)
   */
  [K in keyof T as undefined extends T[K] ? K : never]: DEEP extends false
    ? T[K]
    : T[K] extends Optional<Indexable> // Like above, we must include `undefined` so we can recurse through both nested keys in `{ myKey?: { optionalKey?: object, requiredKey: object }}`
      ? PickOptional<T[K], DEEP>
      : T[K];
};

/**
 * Picks only the required fields out of a type, removing the optional ones.
 * Optionally, recurses through nested objects if `DEEP` is true.
 */
export type PickRequired<T, DEEP extends boolean = true> = {
  [K in keyof T as K extends keyof PickOptional<T, DEEP> ? never : K]: T[K] extends Indexable
    ? PickRequired<T[K], DEEP>
    : T[K];
};

/**
 * Picks only the required keys out of a type, removing the optional ones.
 * Optionally, recurses through nested objects if `DEEP` is true.
 */
export type PickRequiredKeys<T, DEEP extends boolean = true> = keyof PickRequired<T, DEEP>;

/**
 * Picks only the optional keys out of a type, removing the required ones.
 * Optionally, recurses through nested objects if `DEEP` is true.
 */
export type PickOptionalKeys<T, DEEP extends boolean = true> = keyof PickOptional<T, DEEP>;

/**
 * Recursively make all properties of type `T` optional.
 */
export type DeepPartial<T> = T extends object
  ? {
      [P in keyof T]?: DeepPartial<T[P]>;
    }
  : T;

/**
 * Recursively make all properties of type `T` required.
 */
export type DeepRequired<T> = T extends object
  ? {
      [P in keyof T]-?: DeepRequired<T[P]>;
    }
  : T;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/types/validator.types.ts
Tamaño: 1142 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { ValidateFunction as AjvValidateFunction } from 'ajv';
import type { ParseReturnType } from 'zod';
import type { ImportRequirement } from './import.types';
import type { FromSchema, FromSchemaUnvalidated, Schema } from './schema.types';
import type { JsonSchema } from './schema.types/json.schema.types';

export type ValidateFunction<T = unknown> = AjvValidateFunction<T> | ((data: T) => ParseReturnType<T>);

export type ValidationError = {
  path: string;
  message: string;
};

export type ValidateResult<T> =
  | {
      success: false;
      errors: ValidationError[];
    }
  | {
      success: true;
      data: T;
    };

export type Validator<T_Schema extends Schema = Schema> = {
  validate: <
    T_Unvalidated extends Record<string, unknown> = FromSchemaUnvalidated<T_Schema>,
    T_Validated extends Record<string, unknown> = FromSchema<T_Schema>,
  >(
    data: T_Unvalidated,
    schema: T_Schema
  ) => Promise<ValidateResult<T_Validated>>;
  canHandle: (schema: Schema) => Promise<boolean>;
  transformToJsonSchema: (schema: T_Schema) => Promise<JsonSchema>;
  requiredImports: readonly ImportRequirement[];
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/types/workflow.types.ts
Tamaño: 5135 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { WorkflowChannelEnum } from '../constants';
import { ContextResolved } from './context.types';
import type { Schema } from './schema.types';
import type { Step } from './step.types';
import type { Subscriber } from './subscriber.types';
import type { DeepPartial, Prettify } from './util.types';

/**
 * The severity level of a workflow.
 */
export enum SeverityLevelEnum {
  NONE = 'none',
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
}

/**
 * The parameters for the workflow function.
 */
export type ExecuteInput<T_Payload extends Record<string, unknown>, T_Controls extends Record<string, unknown>> = {
  /** Define a step in your workflow. */
  step: Step;
  /** The payload for the event, provided during trigger. */
  payload: T_Payload;
  /** The subscriber for the event, provided during trigger. */
  subscriber: Prettify<Subscriber>;
  /** The environment the workflow is running in. */
  environment: Record<string, unknown>;
  /** The controls for the event. Provided via the Dashboard. */
  controls: T_Controls;
  /** The resolved context for the event. */
  context: ContextResolved;
};

/**
 * The function to execute the workflow.
 */
export type Execute<T_Payload extends Record<string, unknown>, T_Controls extends Record<string, unknown>> = (
  event: ExecuteInput<T_Payload, T_Controls>
) => Promise<void>;

/**
 * A preference for a notification delivery workflow.
 *
 * This provides a shortcut to setting all channels to the same preference.
 */
export type WorkflowPreference = {
  /**
   * A flag specifying if notification delivery is enabled for the workflow.
   *
   * If `true`, notification delivery is enabled by default for all channels.
   *
   * This setting can be overridden by the channel preferences.
   *
   * @default true
   */
  enabled: boolean;
  /**
   * A flag specifying if the preference is read-only.
   *
   * If `true`, the preference cannot be changed by the Subscriber.
   *
   * @default false
   */
  readOnly: boolean;
};

/** A preference for a notification delivery channel. */
export type ChannelPreference = {
  /**
   * A flag specifying if notification delivery is enabled for the channel.
   *
   * If `true`, notification delivery is enabled.
   *
   * @default true
   */
  enabled: boolean;
};

/**
 * A partial set of workflow preferences.
 */
export type WorkflowPreferences = DeepPartial<{
  /**
   * A default preference for the channels.
   *
   * The values specified here will be used if no preference is specified for a channel.
   */
  all: WorkflowPreference;
  /**
   * A preference for each notification delivery channel.
   *
   * If no preference is specified for a channel, the `all` preference will be used.
   */
  channels: Record<WorkflowChannelEnum, ChannelPreference>;
}>;

/**
 * The options for the workflow.
 */
export type WorkflowOptions<T_PayloadSchema extends Schema, T_ControlSchema extends Schema> = {
  /** The schema for the payload. */
  payloadSchema?: T_PayloadSchema;
  /** The schema for the controls. */
  controlSchema?: T_ControlSchema;
  /**
   * The preferences for the notification workflow.
   *
   * If no preference is specified for a channel, the `all` preference will be used.
   *
   * @example
   * ```ts
   * // Enable notification delivery for only the in-app channel by default.
   * {
   *   all: { enabled: false },
   *   channels: {
   *     inApp: { enabled: true },
   *   },
   * }
   * ```
   *
   * @example
   * ```ts
   * // Enable notification delivery for all channels by default.
   * {
   *   all: { enabled: true }
   * }
   * ```
   *
   * @example
   * ```ts
   * // Enable notification delivery for all channels by default,
   * // disallowing the Subscriber to change the preference.
   * {
   *   all: { enabled: true, readOnly: true },
   * }
   * ```
   *
   * @example
   * ```ts
   * // Disable notification delivery for all channels by default,
   * // allowing the Subscriber to change the preference.
   * {
   *   all: { enabled: false, readOnly: false },
   * }
   * ```
   *
   * @example
   * ```ts
   * // Disable notification delivery for only the in-app channel by default,
   * // allowing the Subscriber to change the preference.
   * {
   *   all: { readOnly: false },
   *   channels: {
   *     inApp: { enabled: false },
   *   },
   * }
   * ```
   */
  preferences?: WorkflowPreferences;
  /** The tags for the workflow. */
  tags?: string[];
  /**
   * The name of the workflow.
   *
   * This is used to display a human-friendly name for the workflow in the Dashboard and `<Inbox />` component.
   *
   * If no value is specified, the `workflowId` will be used as the name.
   *
   * @example `Weekly Comment Digest`
   */
  name?: string;
  /**
   * The description of the workflow.
   *
   * This is used to provide a brief overview of the workflow in the Dashboard.
   *
   * @example `This workflow sends a weekly digest of comments to users.`
   */
  description?: string;
  /**
   * The severity of the workflow.
   *
   * This is used to determine the severity of the workflow.
   *
   * @example `high`
   */
  severity?: SeverityLevelEnum;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  enum
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/types/schema.types/base.schema.types.test-d.ts
Tamaño: 2584 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { describe, expectTypeOf, it } from 'vitest';
import { z } from 'zod';
import { FromSchema, FromSchemaUnvalidated, Schema } from './base.schema.types';

describe('FromSchema', () => {
  it('should infer an unknown record type when a generic schema is provided', () => {
    expectTypeOf<FromSchema<Schema>>().toEqualTypeOf<Record<string, unknown>>();
  });

  it('should not compile when the schema is primitive', () => {
    const primitiveSchema = { type: 'string' } as const;

    // @ts-expect-error - Type '{ type: string; }' is not assignable to type '{ type: "object"; }'.
    type Test = FromSchema<typeof primitiveSchema>;

    expectTypeOf<Test>().toEqualTypeOf<never>();
  });

  it('should infer a Json Schema type', () => {
    const testJsonSchema = {
      type: 'object',
      properties: {
        foo: { type: 'string', default: 'bar' },
        bar: { type: 'string' },
      },
      additionalProperties: false,
    } as const;

    expectTypeOf<FromSchema<typeof testJsonSchema>>().toEqualTypeOf<{ foo: string; bar?: string }>();
  });

  it('should infer a Zod Schema type', () => {
    const testZodSchema = z.object({
      foo: z.string().default('bar'),
      bar: z.string().optional(),
    });

    expectTypeOf<FromSchema<typeof testZodSchema>>().toEqualTypeOf<{ foo: string; bar?: string }>();
  });
});

describe('FromSchemaUnvalidated', () => {
  it('should infer an unknown record type when a generic schema is provided', () => {
    expectTypeOf<FromSchemaUnvalidated<Schema>>().toEqualTypeOf<Record<string, unknown>>();
  });

  it('should not compile when the schema is primitive', () => {
    const primitiveSchema = { type: 'string' } as const;

    // @ts-expect-error - Type '{ type: string; }' is not assignable to type '{ type: "object"; }'.
    type Test = FromSchemaUnvalidated<typeof primitiveSchema>;

    expectTypeOf<Test>().toEqualTypeOf<never>();
  });

  it('should infer a Json Schema type', () => {
    const testJsonSchema = {
      type: 'object',
      properties: {
        foo: { type: 'string', default: 'bar' },
        bar: { type: 'string' },
      },
      additionalProperties: false,
    } as const;

    expectTypeOf<FromSchemaUnvalidated<typeof testJsonSchema>>().toEqualTypeOf<{ foo?: string; bar?: string }>();
  });

  it('should infer a Zod Schema type', () => {
    const testZodSchema = z.object({
      foo: z.string().default('bar'),
      bar: z.string().optional(),
    });

    expectTypeOf<FromSchemaUnvalidated<typeof testZodSchema>>().toEqualTypeOf<{ foo?: string; bar?: string }>();
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - Test(FromSchema<typeof primitiveSchema>;

    expectTypeOf<Test>().toEqualTypeOf<never>();
  });

  it('s...)
 - testJsonSchema({
      type: 'object',
      properties: {
        foo: { type: 'string', default: 'bar' },
       ...)
 - testZodSchema(z.object({
      foo: z.string().default('bar'),
      bar: z.string().optional(),
    });

    expe...)
 - Test(FromSchemaUnvalidated<typeof primitiveSchema>;

    expectTypeOf<Test>().toEqualTypeOf<never>();
  }...)
 - testJsonSchema({
      type: 'object',
      properties: {
        foo: { type: 'string', default: 'bar' },
       ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/types/schema.types/base.schema.types.ts
Tamaño: 1564 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { InferJsonSchema, JsonSchemaMinimal } from './json.schema.types';
import type { InferZodSchema, ZodSchemaMinimal } from './zod.schema.types';

/**
 * A schema used to validate a JSON object.
 */
export type Schema = JsonSchemaMinimal | ZodSchemaMinimal;

/**
 * Main utility type for schema inference
 *
 * @param T - The Schema to infer the type of.
 * @param Options - Configuration options for the type inference. The `validated` flag determines whether the schema has been validated. If `validated` is true, all properties are required unless specified otherwise. If false, properties with default values are optional.
 */
type InferSchema<T extends Schema, Options extends { validated: boolean }> =
  | InferJsonSchema<T, Options>
  | InferZodSchema<T, Options>;

/**
 * Infer the type of a Schema for unvalidated data.
 *
 * The resulting type has default properties set to optional,
 * reflecting the fact that the data is unvalidated and has
 * not had default properties set.
 *
 * @example
 * ```ts
 * type MySchema = FromSchemaUnvalidated<typeof mySchema>;
 * ```
 */
export type FromSchemaUnvalidated<T extends Schema> = InferSchema<T, { validated: false }>;

/**
 * Infer the type of a Schema for validated data.
 *
 * The resulting type has default properties set to required,
 * reflecting the fact that the data has been validated and
 * default properties have been set.
 *
 * @example
 * ```ts
 * type MySchema = FromSchema<typeof mySchema>;
 * ```
 */
export type FromSchema<T extends Schema> = InferSchema<T, { validated: true }>;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/types/schema.types/index.ts
Tamaño: 212 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export type { FromSchema, FromSchemaUnvalidated, Schema } from './base.schema.types';
export type { JsonSchema } from './json.schema.types';
export type { ZodSchema, ZodSchemaMinimal } from './zod.schema.types';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/types/schema.types/json.schema.types.test-d.ts
Tamaño: 1817 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { describe, expectTypeOf, it } from 'vitest';
import { InferJsonSchema, JsonSchema } from './json.schema.types';

describe('JsonSchema types', () => {
  const testSchema = {
    type: 'object',
    properties: {
      foo: { type: 'string', default: 'bar' },
      bar: { type: 'string' },
    },
    additionalProperties: false,
  } as const satisfies JsonSchema;

  describe('validated data', () => {
    it('should compile when the expected properties are provided', () => {
      expectTypeOf<InferJsonSchema<typeof testSchema, { validated: true }>>().toEqualTypeOf<{
        foo: string;
        bar?: string;
      }>();
    });

    it('should not compile when the schema is not a JsonSchema', () => {
      expectTypeOf<InferJsonSchema<string, { validated: true }>>().toEqualTypeOf<never>();
    });

    it('should not compile when the schema is generic', () => {
      expectTypeOf<InferJsonSchema<{}, { validated: true }>>().toEqualTypeOf<never>();
    });

    it('should not compile when the schema is a primitive JsonSchema', () => {
      const testPrimitiveSchema = { type: 'string' } as const;

      expectTypeOf<InferJsonSchema<typeof testPrimitiveSchema, { validated: true }>>().toEqualTypeOf<never>();
    });

    it('should not compile when a property does not match the expected type', () => {
      // @ts-expect-error - Type 'number' is not assignable to type 'string'.
      expectTypeOf<InferJsonSchema<typeof testSchema, { validated: true }>>().toEqualTypeOf<{
        foo: number;
      }>();
    });
  });

  describe('unvalidated data', () => {
    it('should keep the defaulted properties optional', () => {
      expectTypeOf<InferJsonSchema<typeof testSchema, { validated: false }>>().toEqualTypeOf<{
        foo?: string;
        bar?: string;
      }>();
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - testSchema({
    type: 'object',
    properties: {
      foo: { type: 'string', default: 'bar' },
      bar: { ...)
 - testPrimitiveSchema({ type: 'string' } as const;

      expectTypeOf<InferJsonSchema<typeof testPrimitiveSchema, { valid...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/types/schema.types/json.schema.types.ts
Tamaño: 1759 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { JSONSchema, FromSchema as JsonSchemaInfer } from 'json-schema-to-ts';

/**
 * A minimal JSON schema type.
 *
 * This type is used to narrow the type of a JSON schema to a minimal type
 * that is compatible with the `json-schema-to-ts` library.
 */
export type JsonSchemaMinimal = { type: 'object' } | { anyOf: unknown[] } | { allOf: unknown[] } | { oneOf: unknown[] };

/**
 * A JSON schema
 */
export type JsonSchema = Exclude<JSONSchema, boolean> & JsonSchemaMinimal;

/**
 * Infer the data type of a JsonSchema.
 *
 * @param T - The `JsonSchema` to infer the data type of.
 * @param Options - Configuration options for the type inference. The `validated` flag determines whether the schema has been validated. If `validated` is true, all properties are required unless specified otherwise. If false, properties with default values are optional.
 *
 * @returns The inferred type.
 *
 * @example
 * ```ts
 * const mySchema = {
 *   type: 'object',
 *   properties: {
 *     name: { type: 'string' },
 *     email: { type: 'string' },
 *   },
 *   required: ['name'],
 *   additionalProperties: false,
 * } as const satisfies JsonSchema;
 *
 * // has type { name: string, email?: string }
 * type MySchema = InferJsonSchema<typeof mySchema, { validated: true }>;
 * ```
 */
export type InferJsonSchema<T, Options extends { validated: boolean }> = T extends JsonSchemaMinimal // Firstly, narrow to the minimal schema type without using the `json-schema-to-ts` import
  ? // Secondly, narrow to the JSON schema type to provide type-safety to `json-schema-to-ts`
    T extends JSONSchema
    ? Options['validated'] extends true
      ? JsonSchemaInfer<T>
      : JsonSchemaInfer<T, { keepDefaultedPropertiesOptional: true }>
    : never
  : never;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/types/schema.types/zod.schema.types.test-d.ts
Tamaño: 1720 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { describe, expectTypeOf, it } from 'vitest';
import { z } from 'zod';
import { InferZodSchema, ZodSchemaMinimal } from './zod.schema.types';

describe('ZodSchema', () => {
  const testSchema = z.object({
    foo: z.string().default('bar'),
    bar: z.string().optional(),
  });

  describe('validated data', () => {
    it('should compile when the expected properties are provided', () => {
      expectTypeOf<InferZodSchema<typeof testSchema, { validated: true }>>().toEqualTypeOf<{
        foo: string;
        bar?: string;
      }>();
    });

    it('should not compile when the schema is not a ZodSchema', () => {
      expectTypeOf<InferZodSchema<string, { validated: true }>>().toEqualTypeOf<never>();
    });

    it('should not compile when the schema is generic', () => {
      expectTypeOf<InferZodSchema<ZodSchemaMinimal, { validated: true }>>().toEqualTypeOf<never>();
    });

    it('should not compile when the schema is a primitive ZodSchema', () => {
      const testPrimitiveSchema = z.string();

      expectTypeOf<InferZodSchema<typeof testPrimitiveSchema, { validated: true }>>().toEqualTypeOf<never>();
    });

    it('should not compile when a property does not match the expected type', () => {
      // @ts-expect-error - Type 'number' is not assignable to type 'string'.
      expectTypeOf<InferZodSchema<typeof testSchema, { validated: true }>>().toEqualTypeOf<{
        foo: number;
      }>();
    });
  });

  describe('unvalidated data', () => {
    it('should keep the defaulted properties optional', () => {
      expectTypeOf<InferZodSchema<typeof testSchema, { validated: false }>>().toEqualTypeOf<{
        foo?: string;
        bar?: string;
      }>();
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - testSchema(z.object({
    foo: z.string().default('bar'),
    bar: z.string().optional(),
  });

  describe('va...)
 - testPrimitiveSchema(z.string();

      expectTypeOf<InferZodSchema<typeof testPrimitiveSchema, { validated: true }>>().t...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/types/schema.types/zod.schema.types.ts
Tamaño: 1513 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type zod from 'zod';

/**
 * A ZodSchema used to validate a JSON object.
 */
export type ZodSchema = zod.ZodType<Record<string, unknown>, zod.ZodTypeDef, Record<string, unknown>>;

/**
 * A minimal ZodSchema type.
 *
 * It is necessary to define a minimal ZodSchema type to enable correct inference
 * when Zod is not available, as Typescript doesn't support detection of module
 * availability via `typeof import('zod')`.
 */
export type ZodSchemaMinimal = {
  readonly safeParseAsync: unknown;
};

/**
 * Infer the data type of a ZodSchema.
 *
 * @param T - The ZodSchema to infer the data type of.
 * @param Options - Configuration options for the type inference. The `validated` flag determines whether the schema has been validated. If `validated` is true, all properties are required unless specified otherwise. If false, properties with default values are optional.
 *
 * @example
 * ```ts
 * const mySchema = z.object({
 *   name: z.string(),
 *   email: z.string().optional(),
 * });
 *
 * // has type { name: string, email?: string }
 * type MySchema = InferZodSchema<typeof mySchema>;
 * ```
 */
export type InferZodSchema<T, Options extends { validated: boolean }> = T extends ZodSchemaMinimal // Firstly, narrow to the minimal schema type without using the `zod` import
  ? // Secondly, narrow to the Zod type to provide type-safety to `zod.infer` and `zod.input`
    T extends ZodSchema
    ? Options['validated'] extends true
      ? zod.infer<T>
      : zod.input<T>
    : never
  : never;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/utils/clone.utils.test.ts
Tamaño: 1189 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { describe, expect, it } from 'vitest';
import { cloneData } from './clone.utils';

describe('cloneData', () => {
  type TestCase = {
    name: string;
    data: unknown;
  };

  const testCases: TestCase[] = [
    {
      name: 'object',
      data: { a: 1, b: 2 },
    },
    {
      name: 'array',
      data: [1, 2, 3],
    },
    {
      name: 'string',
      data: 'hello',
    },
    {
      name: 'number',
      data: 1,
    },
    {
      name: 'boolean',
      data: true,
    },
    {
      name: 'null',
      data: null,
    },
    {
      name: 'undefined',
      data: undefined,
    },
    {
      name: 'nested-object',
      data: { a: { b: { c: 1 } } },
    },
    {
      name: 'nested-array',
      data: [1, [2, [3, [4, [5]]]]],
    },
  ];

  testCases.forEach(({ name, data }) => {
    it(`should deep clone a ${name}`, () => {
      const cloned = cloneData(data);
      expect(cloned).toEqual(data);
    });
  });

  it('should clone such that the mutating the orginal data does not affect the cloned data', () => {
    const data = { a: 1, b: 2 };
    const cloned = cloneData(data);
    data.a = 2;
    expect(cloned).toEqual({ a: 1, b: 2 });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - cloned(cloneData(data);
      expect(cloned).toEqual(data);
    });
  });

  it('should clone such that the...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/utils/clone.utils.ts
Tamaño: 382 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/**
 * Deep clone data.
 * Uses builtin structuredClone if available, otherwise fallback to JSON.parse(JSON.stringify(obj))
 *
 * @param obj - The data to clone.
 * @returns The cloned data.
 */
export const cloneData = <T>(obj: T): T => {
  if (typeof structuredClone === 'function') {
    return structuredClone(obj);
  } else {
    return JSON.parse(JSON.stringify(obj));
  }
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - cloneData(<T>(obj: T): T)
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/utils/crypto.utils.test.ts
Tamaño: 638 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { createHmac } from 'node:crypto';
import { describe, expect, it } from 'vitest';
import { createHmacSubtle } from './crypto.utils';

describe('crypto utils', () => {
  describe('createHmacSubtle', () => {
    const createHmacNode = (secretKey: string, data: string): string => {
      return createHmac('sha256', secretKey).update(data).digest('hex');
    };

    it('should create an HMAC equivalent to node crypto createHmac', async () => {
      const hmacSubtle = await createHmacSubtle('secret', 'data');
      const hmacNode = createHmacNode('secret', 'data');

      expect(hmacSubtle).toEqual(hmacNode);
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - createHmacNode(secretKey: string, data: string): string)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/utils/crypto.utils.ts
Tamaño: 868 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/**
 * Create HMAC using subtle crypto.
 *
 * `crypto.subtle` is a Web Crypto API this is available in browsers,
 * Node.js, and most edge runtimes, such as Cloudflare Workers.
 *
 * @param secretKey - The secret key.
 * @param data - The data to hash.
 * @returns The HMAC.
 */
export const createHmacSubtle = async (secretKey: string, data: string): Promise<string> => {
  const encoder = new TextEncoder();
  const keyData = encoder.encode(secretKey);
  const dataBuffer = encoder.encode(data);

  const cryptoKey = await crypto.subtle.importKey(
    'raw',
    keyData,
    {
      name: 'HMAC',
      hash: { name: 'SHA-256' },
    },
    false,
    ['sign']
  );

  const signature = await crypto.subtle.sign('HMAC', cryptoKey, dataBuffer);

  return Array.from(new Uint8Array(signature))
    .map((byte) => byte.toString(16).padStart(2, '0'))
    .join('');
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - createHmacSubtle(async (secretKey: string, data: string): Promise<string>)
 - signature(await crypto.subtle.sign('HMAC', cryptoKey, dataBuffer);

  return Array.from(new Uint8Array(signatu...)
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/utils/deepmerge.utils.test.ts
Tamaño: 1573 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { describe, expect, it } from 'vitest';
import { deepMerge } from './object.utils';

describe('deepMerge function', () => {
  it('should merge objects and replace arrays correctly', () => {
    const source1 = {
      name: 'John',
      age: 30,
      hobbies: ['reading', 'gaming'],
      address: {
        city: 'New York',
        zip: '10001',
      },
    };

    const source2 = {
      age: 25,
      hobbies: ['cooking', 'traveling'],
      address: {
        zip: '10002',
        country: 'USA',
      },
    };

    const expectedOutput = {
      name: 'John',
      age: 25,
      hobbies: ['cooking', 'traveling'],
      address: {
        city: 'New York',
        zip: '10002',
        country: 'USA',
      },
    };

    expect(deepMerge(source1, source2)).toEqual(expectedOutput);
  });

  it('should merge nested objects and replace arrays correctly', () => {
    const source1 = {
      user: {
        id: 1,
        name: 'Alice',
        preferences: {
          theme: 'dark',
          notifications: true,
          tags: ['work', 'personal'],
        },
      },
    };

    const source2 = {
      user: {
        id: 2,
        preferences: {
          theme: 'light',
          tags: ['travel', 'hobby'],
        },
      },
    };

    const expectedOutput = {
      user: {
        id: 2,
        name: 'Alice',
        preferences: {
          theme: 'light',
          notifications: true,
          tags: ['travel', 'hobby'],
        },
      },
    };

    expect(deepMerge(source1, source2)).toEqual(expectedOutput);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - expectedOutput({
      name: 'John',
      age: 25,
      hobbies: ['cooking', 'traveling'],
      address: {
     ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/utils/env.utils.test.ts
Tamaño: 2266 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { beforeEach, describe, expect, it, vi } from 'vitest';
import { getBridgeUrl, getResponse } from './env.utils';

describe('env.utils', () => {
  describe('getResponse', () => {
    it('should return global Response if defined', () => {
      // @ts-expect-error - incorrect Response types
      global.Response = class {};
      const response = getResponse();
      expect(response).toBe(global.Response);
    });

    it('should return cross-fetch Response if global Response is undefined', () => {
      // @ts-expect-error - incorrect Response types
      global.Response = undefined;
      const response = getResponse();
      expect(response).toBe(require('cross-fetch').Response);
    });
  });

  describe('getBridgeUrl', () => {
    beforeEach(() => {
      delete process.env.NOVU_BRIDGE_ORIGIN;
      delete process.env.NEXT_PUBLIC_VERCEL_URL;
      delete process.env.NEXT_PUBLIC_VERCEL_ENV;
      // @ts-expect-error - overriding read-only property
      process.env.NODE_ENV = 'development';
    });

    it('should return NOVU_BRIDGE_ORIGIN if defined', async () => {
      process.env.NOVU_BRIDGE_ORIGIN = 'http://example.com';
      const url = await getBridgeUrl();
      expect(url).toBe('http://example.com/api/novu');
    });

    it('should return NEXT_PUBLIC_VERCEL_URL if NEXT_PUBLIC_VERCEL_ENV is preview', async () => {
      process.env.NEXT_PUBLIC_VERCEL_URL = 'vercel.example.com';
      process.env.NEXT_PUBLIC_VERCEL_ENV = 'preview';

      const url = await getBridgeUrl();
      expect(url).toBe('https://vercel.example.com/api/novu');
    });

    it('should return local bridge URL in development environment', async () => {
      const mockFetch = vi.fn().mockResolvedValue({
        json: vi.fn().mockResolvedValue({
          tunnelOrigin: 'http://localhost:2022',
          route: '/api/novu',
        }),
      });
      global.fetch = mockFetch;
      const url = await getBridgeUrl();
      expect(url).toBe('http://localhost:2022/api/novu');
    });

    it('should return empty string if no conditions are met', async () => {
      // @ts-expect-error - overriding read-only property
      process.env.NODE_ENV = 'production';
      const url = await getBridgeUrl();
      expect(url).toBe('');
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - response(getResponse();
      expect(response).toBe(global.Response);
    });

    it('should return cross-fe...)
 - response(getResponse();
      expect(response).toBe(require('cross-fetch').Response);
    });
  });

  descri...)
 - NODE_ENV('development';
    });

    it('should return NOVU_BRIDGE_ORIGIN if defined', async ())
 - url(await getBridgeUrl();
      expect(url).toBe('http://example.com/api/novu');
    });

    it('should...)
 - url(await getBridgeUrl();
      expect(url).toBe('https://vercel.example.com/api/novu');
    });

    it...)
 - url(await getBridgeUrl();
      expect(url).toBe('http://localhost:2022/api/novu');
    });

    it('sho...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/utils/env.utils.ts
Tamaño: 1161 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Response as CrossFetchResponse } from 'cross-fetch';

export const getResponse = (): typeof Response => {
  if (typeof Response !== 'undefined') {
    return Response;
  }

  return CrossFetchResponse;
};

export const getBridgeUrl = async (): Promise<string> => {
  /*
   * Production, staging, or local environments with bring your own local tunnel
   * An escape hatch for unknown use-cases.
   */
  if (process.env.NOVU_BRIDGE_ORIGIN) {
    return `${process.env.NOVU_BRIDGE_ORIGIN}/api/novu`;
  }

  // Vercel preview deployments
  if (process.env.NEXT_PUBLIC_VERCEL_ENV === 'preview' && process.env.NEXT_PUBLIC_VERCEL_URL) {
    return `https://${process.env.NEXT_PUBLIC_VERCEL_URL}/api/novu`;
  }

  // Local environments
  try {
    // biome-ignore lint/suspicious/noExplicitAny: Needed for some edge cases
    if (process.env.NODE_ENV === 'development' || (process.env.NODE_ENV as any) === 'dev') {
      const response = await fetch('http://localhost:2022/.well-known/novu');
      const data = await response.json();

      return `${data.tunnelOrigin}${data.route}`;
    }
  } catch (error) {
    console.error(error);
  }

  return '';
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - getResponse(): typeof Response)
 - getBridgeUrl(async (): Promise<string>)
Declaraciones 'export' encontradas:
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/utils/http.utils.ts
Tamaño: 1261 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BridgeError, MissingSecretKeyError, PlatformError } from '../errors';
import { checkIsResponseError } from '../shared';

export const initApiClient = (secretKey: string, apiUrl: string) => {
  if (!secretKey) {
    throw new MissingSecretKeyError();
  }

  return {
    post: async <T = unknown>(route: string, data: Record<string, unknown>): Promise<T> => {
      const response = await fetch(`${apiUrl}/v1${route}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `ApiKey ${secretKey}`,
        },
        body: JSON.stringify(data),
      });

      const resJson = await response.json();

      if (response.ok) {
        return resJson as T;
      } else if (checkIsResponseError(resJson)) {
        throw new PlatformError(resJson.statusCode, resJson.error, resJson.message);
      } else {
        throw new BridgeError(resJson);
      }
    },
    delete: async <T = unknown>(route: string): Promise<T> => {
      return (
        await fetch(`${apiUrl}/v1${route}`, {
          method: 'DELETE',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `ApiKey ${secretKey}`,
          },
        })
      ).json() as T;
    },
  };
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - initApiClient(secretKey: string, apiUrl: string))
 - T(unknown>(route: string, data: Record<string, unknown>): Promise<T>)
 - T(unknown>(route: string): Promise<T>)
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/utils/import.utils.test.ts
Tamaño: 2963 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { describe, expect, it } from 'vitest';
import { checkDependencies } from './import.utils';

describe('import utils', () => {
  describe('checkDependencies', () => {
    it('should not throw an error if all dependencies are installed', async () => {
      await expect(
        checkDependencies(
          [{ name: 'typescript', import: import('typescript'), exports: ['tokenToString'] }],
          'test schema'
        )
      ).resolves.not.toThrow();
    });

    it('should throw an error if a single dependency is not installed', async () => {
      await expect(
        checkDependencies(
          // @ts-expect-error - Cannot find module 'missing-random-dependency' or its corresponding type declarations.
          [{ name: 'missing-random-dependency', import: import('missing-random-dependency'), exports: [] }],
          'test schema'
        )
      ).rejects.toThrow(
        'Tried to use a test schema in @novu/framework without missing-random-dependency installed. Please install it by running `npm install missing-random-dependency`.'
      );
    });

    it('should throw an error if multiple dependencies are not installed', async () => {
      await expect(
        checkDependencies(
          [
            // @ts-expect-error - Cannot find module 'missing-random-dependency-1' or its corresponding type declarations.
            { name: 'missing-random-dependency-1', import: import('missing-random-dependency-1'), exports: [] },
            // @ts-expect-error - Cannot find module 'missing-random-dependency-2' or its corresponding type declarations.
            { name: 'missing-random-dependency-2', import: import('missing-random-dependency-2'), exports: [] },
          ],
          'test schema'
        )
      ).rejects.toThrow(
        'Tried to use a test schema in @novu/framework without missing-random-dependency-1, missing-random-dependency-2 installed. Please install them by running `npm install missing-random-dependency-1 missing-random-dependency-2`.'
      );
    });

    it('should throw an error listing a single dependency that is not installed when using a root and non-root import', async () => {
      await expect(
        checkDependencies(
          [
            // @ts-expect-error - Cannot find module 'missing-random-dependency' or its corresponding type declarations.
            { name: 'missing-random-dependency', import: import('missing-random-dependency'), exports: [] },
            // @ts-expect-error - Cannot find module 'missing-random-dependency/nested' or its corresponding type declarations.
            { name: 'missing-random-dependency', import: import('missing-random-dependency/nested'), exports: [] },
          ],
          'test schema'
        )
      ).rejects.toThrow(
        'Tried to use a test schema in @novu/framework without missing-random-dependency installed. Please install it by running `npm install missing-random-dependency`.'
      );
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

No se detectaron funciones/exportaciones con heurística JS/TS.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/utils/import.utils.ts
Tamaño: 1324 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { MissingDependencyError } from '../errors/import.errors';
import type { ImportRequirement } from '../types/import.types';

/**
 * Check if the required dependencies are installed and throw an error if not.
 *
 * @param dependencies - The list of dependencies to check
 * @param usageReason - The usage of the dependencies
 */
export const checkDependencies = async (
  dependencies: readonly ImportRequirement[],
  usageReason: string
): Promise<void> => {
  const missingDependencies = new Set<string>();
  const results = await Promise.allSettled(dependencies.map((dep) => dep.import));

  results.forEach((result, index) => {
    const dep = dependencies[index];
    if (result.status === 'fulfilled') {
      const hasAllExports = dep.exports.every((exportName) => result.value[exportName] !== undefined);

      /*
       * First way that a dependency isn't available is if the import succeeds
       * but the necessary exports are not available.
       */
      if (!hasAllExports) {
        missingDependencies.add(dep.name);
      }
    } else {
      // Second way that a dependency isn't available is if the import fails.
      missingDependencies.add(dep.name);
    }
  });

  if (missingDependencies.size > 0) {
    throw new MissingDependencyError(usageReason, Array.from(missingDependencies));
  }
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - checkDependencies(async (
  dependencies: readonly ImportRequirement[],
  usageReason: string
): Promise<void>)
 - results(await Promise.allSettled(dependencies.map((dep))
 - hasAllExports(dep.exports.every((exportName))
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/utils/index.ts
Tamaño: 251 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './crypto.utils';
export * from './env.utils';
export * from './http.utils';
export * from './liquid.utils';
export * from './log.utils';
export * from './options.utils';
export * from './sanitize.utils';
export * from './string.utils';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/utils/liquid.utils.test.ts
Tamaño: 13464 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Liquid } from 'liquidjs';
import { describe, expect, it } from 'vitest';
import { createLiquidEngine, defaultOutputEscape, stringifyDataStructureWithSingleQuotes } from './liquid.utils';

describe('createLiquidEngine', () => {
  it('should create a Liquid instance with default configuration', () => {
    const engine = createLiquidEngine();
    expect(engine).toBeInstanceOf(Liquid);
  });

  it('should register the default json filter', async () => {
    const engine = createLiquidEngine();
    const template = '{{ data | json }}';
    const data = { data: { a: 1, b: 'test' } };
    const result = await engine.parseAndRender(template, data);
    expect(result).toBe("{'a':1,'b':'test'}");
  });

  it('should register the default digest filter', async () => {
    const engine = createLiquidEngine();
    const template = '{{ names | digest }}';
    const data = { names: ['John', 'Jane', 'Bob', 'Alice'] };
    const result = await engine.parseAndRender(template, data);
    expect(result).toBe('John, Jane and 2 others');
  });

  it('should register the toSentence filter', async () => {
    const engine = createLiquidEngine();
    const template = `{{ names | toSentence: '', 2, 'other' }}`;
    const data = { names: ['John', 'Jane', 'Bob', 'Alice'] };
    const result = await engine.parseAndRender(template, data);
    expect(result).toBe('John, Jane, and 2 others');
  });

  it('should register the pluralize filter', async () => {
    const engine = createLiquidEngine();
    const template = `{{ count | pluralize: 'other' }}`;
    const data = { count: 1 };
    const result = await engine.parseAndRender(template, data);
    expect(result).toBe('1 other');
  });

  it('should register the pluralize filter with showCount parameter', async () => {
    const engine = createLiquidEngine();
    const template = `{{ count | pluralize: 'activity', 'activities', false }}`;
    const data = { count: 2 };
    const result = await engine.parseAndRender(template, data);
    expect(result).toBe('activities');
  });

  it('should correctly handle complex templates with multiple filters', async () => {
    const engine = createLiquidEngine();

    let data = {
      users: [
        { name: 'John', age: 30 },
        { name: 'Jane', age: 25 },
        { name: 'Bob', age: 40 },
      ],
    };
    const template = 'Users: {{ users | json }}\nFirst two users: {{ users | digest: 2, "name" }}';

    let result = await engine.parseAndRender(template, data);

    expect(result).toContain("Users: [{'name':'John','age':30},{'name':'Jane','age':25},{'name':'Bob','age':40}]");
    expect(result).toContain('First two users: John, Jane and 1 other');

    data = {
      users: [
        { name: 'John', age: 30 },
        { name: 'Jane', age: 25 },
        { name: 'Bob', age: 40 },
        { name: 'Alice', age: 35 },
      ],
    };
    result = await engine.parseAndRender(template, data);

    expect(result).toContain(
      "Users: [{'name':'John','age':30},{'name':'Jane','age':25},{'name':'Bob','age':40},{'name':'Alice','age':35}]"
    );
    expect(result).toContain('First two users: John, Jane and 2 others');
  });

  it('should handle the compileControls pattern used in the framework', async () => {
    const engine = createLiquidEngine();

    // This test simulates how the template engine is used in Client.compileControls
    const templateControls = {
      subject: 'Hello, {{ subscriber.firstName }}',
      content: 'Your order #{{ payload.orderId }} has been {{ payload.status }}',
      buttonText: 'View details',
      amount: '{{ payload.amount }}',
      items: '{{ payload.items | json }}',
    };

    const event = {
      payload: {
        orderId: 'ORD-123',
        status: 'confirmed',
        amount: 99.99,
        items: [
          { name: 'Product A', quantity: 2 },
          { name: 'Product B', quantity: 1 },
        ],
      },
      subscriber: {
        firstName: 'Alice',
        lastName: 'Smith',
        email: 'alice@example.com',
      },
      state: [
        {
          stepId: 'previous-step',
          outputs: {
            result: 'success',
            metadata: { processed: true },
          },
        },
      ],
    };

    // Simulate the same approach as in the Client class
    const templateString = engine.parse(JSON.stringify(templateControls));

    const compiledString = await engine.render(templateString, {
      payload: event.payload,
      subscriber: event.subscriber,
      steps: event.state.reduce(
        (acc, state) => {
          acc[state.stepId] = state.outputs;

          return acc;
        },
        {} as Record<string, Record<string, unknown>>
      ),
    });

    const result = JSON.parse(compiledString);

    expect(result.subject).toBe('Hello, Alice');
    expect(result.content).toBe('Your order #ORD-123 has been confirmed');
    expect(result.amount).toBe('99.99');
    expect(result.items).toMatch(/^\[.*\]$/); // Just check if it's an array format
  });

  it('should properly parse and render complex control objects with nested properties', async () => {
    const engine = createLiquidEngine();

    const controls = {
      email: {
        subject: 'Welcome {{ subscriber.firstName }}',
        header: '{{ payload.companyName }} Newsletter',
        body: {
          greeting: 'Hi {{ subscriber.firstName }} {{ subscriber.lastName }}',
          content: 'Thanks for signing up for our {{ payload.subscriptionType }} plan',
          footer: 'Contact us at {{ payload.contact.email }}',
        },
        attachments: '{{ payload.files | json }}',
      },
      timing: {
        sendAt: '{{ payload.scheduledTime }}',
        expireAt: '{{ payload.expiryTime }}',
      },
    };

    const data = {
      payload: {
        companyName: 'Acme Inc',
        subscriptionType: 'premium',
        scheduledTime: '2023-05-10T15:00:00Z',
        expiryTime: '2023-06-10T15:00:00Z',
        contact: {
          email: 'support@acme.com',
          phone: '+1234567890',
        },
        files: [
          { name: 'welcome.pdf', url: 'https://example.com/welcome.pdf' },
          { name: 'terms.pdf', url: 'https://example.com/terms.pdf' },
        ],
      },
      subscriber: {
        firstName: 'John',
        lastName: 'Doe',
        email: 'john@example.com',
      },
    };

    const templateString = engine.parse(JSON.stringify(controls));
    const rendered = await engine.render(templateString, data);
    const result = JSON.parse(rendered);

    expect(result.email.subject).toBe('Welcome John');
    expect(result.email.header).toBe('Acme Inc Newsletter');
    expect(result.email.body.greeting).toBe('Hi John Doe');
    expect(result.email.body.content).toBe('Thanks for signing up for our premium plan');
    expect(result.email.body.footer).toBe('Contact us at support@acme.com');
    expect(result.email.attachments).toMatch(/^\[.*\]$/); // Just check if it's an array format
    expect(result.timing.sendAt).toBe('2023-05-10T15:00:00Z');
    expect(result.timing.expireAt).toBe('2023-06-10T15:00:00Z');
  });

  it('should handle step outputs reference in templates', async () => {
    const engine = createLiquidEngine();

    const template =
      'Previous step result: {{ steps.step1.status }}\nDigest result: {{ steps.digest.users | digest }}\nFrom email step: {{ steps.email.recipient }}';

    const data = {
      steps: {
        step1: {
          status: 'success',
          timestamp: '2023-01-01T12:00:00Z',
        },
        digest: {
          users: ['Alice', 'Bob', 'Charlie', 'David'],
        },
        email: {
          recipient: 'user@example.com',
          subject: 'Important notification',
        },
      },
    };

    const result = await engine.parseAndRender(template, data);

    expect(result).toContain('Previous step result: success');
    expect(result).toContain('Digest result: Alice, Bob and 2 others');
    expect(result).toContain('From email step: user@example.com');
  });

  it('should handle displaying array items directly', async () => {
    const engine = createLiquidEngine();

    // Using a simplified template without loops
    const template = 'Items: {{ payload.items | json }}\nTotal: ${{ payload.total }}';

    const data = {
      payload: {
        items: [
          { name: 'Item 1', price: 10 },
          { name: 'Item 2', price: 20 },
          { name: 'Item 3', price: 30 },
        ],
        total: 60,
      },
    };

    const result = await engine.parseAndRender(template, data);
    expect(result).toContain('Items:');
    expect(result).toContain('Total: $60');
  });

  it('should preserve newlines in data payload when rendering templates', async () => {
    const engine = createLiquidEngine();

    // Template with multiline content
    const template = `
      Message:\n{{ payload.message }}
      
      Formatted description:
      {{ payload.formattedDescription }}
    `;

    const data = {
      payload: {
        message: 'Line 1\nLine 2\nLine 3',
        formattedDescription: 'Header\n\n- Point 1\n- Point 2\n\nFooter',
      },
    };

    const result = await engine.parseAndRender(template, data);

    // Verify newlines are escaped in the output as expected by the engine's behavior
    expect(result).toContain('Message:\nLine 1\\nLine 2\\nLine 3');
    expect(result).toContain('Formatted description:\n      Header\\n\\n- Point 1\\n- Point 2\\n\\nFooter');

    // Also test with json filter to ensure object serialization preserves newlines
    const jsonTemplate = '{{ payload.message | json }}';
    const jsonResult = await engine.parseAndRender(jsonTemplate, data);
    expect(jsonResult).toBe('Line 1\\nLine 2\\nLine 3');
  });
});