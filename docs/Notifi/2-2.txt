) => {
    const { classes, theme } = useSelectStyles();
    const searchableSelectProps = searchable
      ? {
          searchable,
          nothingFound: 'Nothing Found',
          clearable: true,
        }
      : {};
    const defaultDesign = {
      radius: 'md',
      size: 'md',
      rightSection: <ArrowDown />,
      rightSectionWidth: 50,
      styles: inputStyles,
      classNames: classes,
      ...inputProps,
    } as InputBaseProps;
    const multiselect = type === 'multiselect';

    let filterResults: ((value: string, item: SelectItem) => boolean) | undefined = filter;

    if (creatable && !filter) {
      filterResults = (currentValue, _) => {
        const isEmptyValue = !currentValue;
        const includedInExistingGroups = !!data.find((group) => {
          return (group as SelectItem)?.label?.toLowerCase().includes(currentValue.toLowerCase());
        });
        const showAllOptionsInSelect = isEmptyValue || includedInExistingGroups;

        return showAllOptionsInSelect;
      };
    }

    const loadingProps = useMemo(() => {
      const loadingStyle = { ...inputStyles(theme), ...{ rightSection: { width: '100%' } } };

      return loading
        ? {
            rightSection: <Loader color={colors.B70} size={32} />,
            styles: loadingStyle,
            value: undefined,
            placeholder: '',
            disabled: true,
          }
        : {};
    }, [loading, theme]);

    return (
      <Wrapper style={{ position: 'relative' }} className={className}>
        {multiselect ? (
          <MantineMultiSelect
            ref={ref}
            onChange={onChange}
            autoComplete="nope"
            value={value as string[] | undefined}
            {...defaultDesign}
            {...searchableSelectProps}
            creatable={creatable}
            data={data}
            disabled={disabled}
            required={required}
            valueComponent={Value}
            data-test-id={dataTestId}
            {...props}
            {...loadingProps}
          />
        ) : (
          <MantineSelect
            ref={ref}
            value={value as string | undefined}
            autoComplete="nope"
            {...defaultDesign}
            {...searchableSelectProps}
            creatable={creatable}
            disabled={disabled}
            filter={filterResults}
            onChange={onChange}
            data={data}
            required={required}
            data-test-id={dataTestId}
            withinPortal={withinPortal}
            {...props}
            {...loadingProps}
          />
        )}
      </Wrapper>
    );
  }
);

function Value({ label, onRemove, disabled }: MultiSelectValueProps) {
  const theme = useMantineTheme();
  const dark = theme.colorScheme === 'dark';
  const enabledBackgroundColor = dark ? theme.colors.dark[4] : theme.colors.gray[0];
  const disabledBackgroundColor = dark ? theme.colors.dark[5] : theme.colors.gray[3];
  const backgroundColor = disabled ? disabledBackgroundColor : enabledBackgroundColor;
  const color = dark ? theme.colors.dark[3] : theme.colors.gray[5];

  return (
    <Box
      sx={{
        alignItems: 'center',
        display: 'flex',
        borderRadius: '5px',
        backgroundColor,
        margin: '5px',
      }}
    >
      <div
        style={{
          margin: `6.5px ${disabled ? '10px' : '0px'} 6.5px 10px`,
          lineHeight: '20px',
          maxWidth: '80px',
          fontSize: 14,
          fontWeight: 400,
        }}
      >
        <Text rows={1}>{label}</Text>
      </div>
      {!disabled && (
        <CloseButton style={{ color }} onMouseDown={onRemove} variant="transparent" size={30} iconSize={15} />
      )}
    </Box>
  );
}

const Wrapper = styled.div`
  .mantine-MultiSelect-values {
    min-height: 48px;
    padding: 0;
  }

  .mantine-MultiSelect-input {
    min-height: 50px;

    input {
      height: 100%;
    }
  }
`;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import React, { useMemo } from 'react';
import {
Box,
Select as MantineSelect,
MultiSelect as MantineMultiSelect,
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/design-system/src/select/Select.types.ts
Tamaño: 1281 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import React, { FC } from 'react';
import { SelectProps, InputBaseProps, SelectItem } from '@mantine/core';

import { SpacingProps } from '../shared/spacing.props';

export interface ISelectProps extends SpacingProps {
  data: (string | { value: string; label?: string } | SelectItem)[];
  value?: string[] | string | null;
  onChange?: (value: string[] | string | null) => void;
  label?: React.ReactNode;
  error?: React.ReactNode;
  itemComponent?: FC<any>;
  valueComponent?: FC<any>;
  placeholder?: string;
  description?: React.ReactNode;
  getCreateLabel?: (query: string) => React.ReactNode;
  onDropdownOpen?: () => void;
  onDropdownClose?: () => void;
  onSearchChange?: (query: string) => void;
  onCreate?: SelectProps['onCreate'];
  searchable?: boolean;
  creatable?: boolean;
  disabled?: boolean;
  required?: boolean;
  loading?: boolean;
  type?: 'multiselect' | 'select';
  filter?: (value: string, item: SelectItem) => boolean;
  allowDeselect?: boolean;
  dataTestId?: string;
  rightSectionWidth?: React.CSSProperties['width'];
  inputProps?: InputBaseProps;
  withinPortal?: boolean;
  limit?: SelectProps['limit'];
  dropdownPosition?: SelectProps['dropdownPosition'];
  icon?: React.ReactNode;
  variant?: SelectProps['variant'];
  className?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  interface

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/design-system/src/shared/spacing.props.ts
Tamaño: 138 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export interface SpacingProps {
  m?: number;
  my?: number;
  mx?: number;
  mt?: number;
  mb?: number;
  ml?: number;
  mr?: number;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  interface

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/design-system/src/sidebar/Close.tsx
Tamaño: 491 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

export const Close = (props: React.ComponentPropsWithoutRef<'svg'>) => {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 12 12" fill="none" {...props}>
      <path
        d="M1.3339 11.9928L0.0078125 10.6667L4.67448 6.00001L0.0078125 1.33335L1.3339 0.00726318L6.00056 4.67393L10.6672 0.00726318L11.9933 1.33335L7.32665 6.00001L11.9933 10.6667L10.6672 11.9928L6.00056 7.3261L1.3339 11.9928Z"
        fill="currentColor"
      />
    </svg>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

export const Close = (props: React.ComponentPropsWithoutRef<'svg'>) => {
return (
<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 12 12" fill="none" {...props}>
<path
d="M1.3339 11.9928L0.0078125 10.6667L4.67448 6.00001L0.0078125 1.33335L1.3339 0.00726318L6.00056 4.67393L10.6672 0.00726318L11.9933 1.33335L7.32665 6.00001L11.9933 10.6667L10.6672 11.9928L6.00056 7.3261L1.3339 11.9928Z"
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/design-system/src/sidebar/Sidebar.const.ts
Tamaño: 203 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export const COLLAPSED_WIDTH = 600;
export const NAVIGATION_WIDTH = 272;
/**
 * @deprecated
 * TODO:Remove this once Information Architecture is 100% live
 */
export const LEGACY_NAVIGATION_WIDTH = 300;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/design-system/src/sidebar/Sidebar.styles.ts
Tamaño: 2266 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { css } from '@emotion/css';
import styled from '@emotion/styled';
import { createStyles, MantineTheme } from '@mantine/core';
import { FeatureFlagsKeysEnum } from '@novu/shared';
import { colors, shadows } from '../config';
import { NAVIGATION_WIDTH, LEGACY_NAVIGATION_WIDTH, COLLAPSED_WIDTH } from './Sidebar.const';
import { ISidebarBaseProps } from './Sidebar.types';

export const HeaderHolder = styled.div`
  display: flex;
  flex-wrap: nowrap;
  gap: 12px;
  margin: 24px;
  margin-bottom: 0;
`;

const scrollable = `
  overflow-x: hidden;
  overflow-y: auto;
`;

export const scrollableClass = css(scrollable);

export const Form = styled.form<{ isParentScrollable: boolean }>`
  height: 100%;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  gap: 24px;
  ${(props) => props.isParentScrollable && scrollable};
`;

export const BodyHolder = styled.div<{ isParentScrollable: boolean }>`
  display: flex;
  flex-direction: column;
  ${(props) => !props.isParentScrollable && scrollable};
  margin: 0 24px;
  gap: 24px;
  padding-right: 5px;
  margin-right: 19px;
  height: 100%;
`;

export const FooterHolder = styled.div`
  display: flex;
  flex-wrap: nowrap;
  gap: 6px;
  margin: 24px;
  margin-top: 0;
  margin-top: auto;
`;

export const useDrawerStyles = createStyles(
  (
    theme: MantineTheme,
    { isExpanded, navigationWidth = NAVIGATION_WIDTH }: Pick<ISidebarBaseProps, 'isExpanded' | 'navigationWidth'>
  ) => {
    return {
      root: {
        position: 'absolute',
      },
      drawer: {
        position: 'fixed',
        top: 40,
        right: 0,
        bottom: 0,
        backgroundColor: theme.colorScheme === 'dark' ? colors.B17 : colors.white,
        borderTopLeftRadius: 7,
        borderBottomLeftRadius: 7,
        boxShadow: shadows.dark,
        width: isExpanded ? `calc(100% - ${navigationWidth}px)` : COLLAPSED_WIDTH,
        transition: 'all 300ms ease !important',
        '@media screen and (max-width: 768px)': {
          width: isExpanded ? `100%` : COLLAPSED_WIDTH,
        },
      },
      body: {
        height: '100%',
      },
    };
  }
);

export const sidebarDrawerContentClassName = css`
  height: 100%;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  gap: 24px;
`;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - Form(styled.form<{ isParentScrollable: boolean }>`
  height: 100%;
  overflow: hidden;
  display: flex;
 ...)
 - BodyHolder(styled.div<{ isParentScrollable: boolean }>`
  display: flex;
  flex-direction: column;
  ${(props))
 - navigationWidth(NAVIGATION_WIDTH }: Pick<ISidebarBaseProps, 'isExpanded' | 'navigationWidth'>
  ))
Declaraciones 'export' encontradas:
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/design-system/src/sidebar/Sidebar.tsx
Tamaño: 2944 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Drawer, Loader, Stack } from '@mantine/core';
import { useKeyDown } from '../hooks/useKeyDown';

import { ActionButton } from '../button/ActionButton';
import { colors } from '../config';
import { ArrowLeft } from '../icons';
import { When } from '../when';
import { Close } from './Close';
import { BodyHolder, FooterHolder, HeaderHolder, Form, useDrawerStyles } from './Sidebar.styles';
import { ISidebarBaseProps } from './Sidebar.types';

export interface ISidebarProps extends ISidebarBaseProps {
  onSubmit?: React.FormEventHandler<HTMLFormElement>;
}

export const Sidebar = ({
  customFooter,
  customHeader,
  children,
  isOpened,
  isExpanded = false,
  isLoading = false,
  isParentScrollable = false,
  styles,
  navigationWidth,
  'data-test-id': dataTestId,
  onClose,
  onBack,
  onSubmit,
}: ISidebarProps) => {
  const { classes: drawerClasses } = useDrawerStyles({ isExpanded, navigationWidth });
  const onCloseCallback = () => {
    onClose();
  };

  useKeyDown('Escape', onCloseCallback);

  return (
    <Drawer
      opened={isOpened}
      position="right"
      styles={styles}
      classNames={drawerClasses}
      onClose={onCloseCallback}
      withOverlay={false}
      withCloseButton={false}
      closeOnEscape={false}
      withinPortal={true}
      trapFocus={false}
      data-expanded={isExpanded}
    >
      <Form
        name="form-name"
        noValidate
        onSubmit={onSubmit}
        data-test-id={dataTestId}
        isParentScrollable={isParentScrollable}
        onClick={(e) => {
          e.stopPropagation();
        }}
      >
        <HeaderHolder className="sidebar-header-holder">
          {isExpanded && onBack && (
            <ActionButton
              onClick={onBack}
              Icon={ArrowLeft}
              data-test-id="sidebar-back"
              sx={{
                '> svg': {
                  width: 16,
                  height: 16,
                },
              }}
            />
          )}
          {customHeader}
          <ActionButton
            onClick={onCloseCallback}
            Icon={Close}
            sx={{
              marginLeft: 'auto',
              '> svg': {
                width: 14,
                height: 14,
              },
            }}
            data-test-id="sidebar-close"
          />
        </HeaderHolder>
        <BodyHolder isParentScrollable={isParentScrollable} className="sidebar-body-holder">
          <When truthy={isLoading}>
            <Stack
              align="center"
              justify="center"
              sx={{
                height: '100%',
              }}
            >
              <Loader color={colors.error} size={32} />
            </Stack>
          </When>
          <When truthy={!isLoading}>{children}</When>
        </BodyHolder>
        {customFooter && <FooterHolder className="sidebar-footer-holder">{customFooter}</FooterHolder>}
      </Form>
    </Drawer>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Drawer, Loader, Stack } from '@mantine/core';
import { useKeyDown } from '../hooks/useKeyDown';
import { ActionButton } from '../button/ActionButton';
import { colors } from '../config';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/design-system/src/sidebar/Sidebar.types.ts
Tamaño: 527 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Styles, DrawerStylesNames } from '@mantine/core';
import { ReactNode } from 'react';

export interface ISidebarBaseProps {
  navigationWidth?: number;
  customHeader?: ReactNode;
  customFooter?: ReactNode;
  children: ReactNode;
  isOpened: boolean;
  isExpanded?: boolean;
  isLoading?: boolean;
  isParentScrollable?: boolean;
  styles?: Styles<DrawerStylesNames, Record<string, any>>;
  onClose: () => void;
  onBack?: () => void;
  onSubmit?: React.FormEventHandler<HTMLFormElement>;
  'data-test-id'?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  interface

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/design-system/src/sidebar/SidebarFormless.tsx
Tamaño: 3251 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { cx } from '@emotion/css';
import { Drawer, Loader, Stack } from '@mantine/core';
import { useKeyDown } from '../hooks/useKeyDown';
import { ActionButton } from '../button/ActionButton';
import { colors } from '../config';
import { ArrowLeft } from '../icons';
import { When } from '../when';
import { Close } from './Close';
import {
  BodyHolder,
  FooterHolder,
  HeaderHolder,
  scrollableClass,
  sidebarDrawerContentClassName,
  useDrawerStyles,
} from './Sidebar.styles';
import { ISidebarBaseProps } from './Sidebar.types';

/**
 * A Sidebar component without the form element that wraps content.
 *
 * This is a temporary solution to a overloaded pattern. The Sidebar component should
 * not have an embedded form as it removes the caller from properly controlling their own form.
 * We will refactor the Sidebar later on as part of the design system work.
 *
 * https://linear.app/novu/issue/NV-3632/de-couple-the-sidebar-from-its-internal-form
 */

export const SidebarFormless = ({
  customFooter,
  customHeader,
  children,
  isOpened,
  isExpanded = false,
  isLoading = false,
  isParentScrollable = false,
  styles,
  'data-test-id': dataTestId,
  onClose,
  onBack,
  navigationWidth,
}: ISidebarBaseProps) => {
  const { classes: drawerClasses } = useDrawerStyles({ isExpanded, navigationWidth });
  const onCloseCallback = () => {
    onClose();
  };

  useKeyDown('Escape', onCloseCallback);

  return (
    <Drawer
      opened={isOpened}
      position="right"
      styles={styles}
      classNames={drawerClasses}
      onClose={onCloseCallback}
      withOverlay={false}
      withCloseButton={false}
      closeOnEscape={false}
      withinPortal={true}
      trapFocus={false}
      data-expanded={isExpanded}
    >
      <div
        data-test-id={dataTestId}
        className={cx(sidebarDrawerContentClassName, { [scrollableClass]: isParentScrollable })}
      >
        <HeaderHolder className="sidebar-header-holder">
          {isExpanded && onBack && (
            <ActionButton
              onClick={onBack}
              Icon={ArrowLeft}
              data-test-id="sidebar-back"
              sx={{
                '> svg': {
                  width: 16,
                  height: 16,
                },
              }}
            />
          )}
          {customHeader}
          <ActionButton
            onClick={onCloseCallback}
            Icon={Close}
            sx={{
              marginLeft: 'auto',
              '> svg': {
                width: 14,
                height: 14,
              },
            }}
            data-test-id="sidebar-close"
          />
        </HeaderHolder>
        <BodyHolder isParentScrollable={isParentScrollable} className="sidebar-body-holder">
          <When truthy={isLoading}>
            <Stack
              align="center"
              justify="center"
              sx={{
                height: '100%',
              }}
            >
              <Loader color={colors.error} size={32} />
            </Stack>
          </When>
          <When truthy={!isLoading}>{children}</When>
        </BodyHolder>
        {customFooter && <FooterHolder className="sidebar-footer-holder">{customFooter}</FooterHolder>}
      </div>
    </Drawer>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { cx } from '@emotion/css';
import { Drawer, Loader, Stack } from '@mantine/core';
import { useKeyDown } from '../hooks/useKeyDown';
import { ActionButton } from '../button/ActionButton';
import { colors } from '../config';
/**
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/design-system/src/sidebar/index.ts
Tamaño: 95 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './Sidebar';
export * from './SidebarFormless';
export * from './Sidebar.const';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/design-system/src/switch/Switch.stories.tsx
Tamaño: 558 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import React from 'react';
import { StoryFn, Meta } from '@storybook/react';
import { Switch } from './Switch';

export default {
  title: 'Components/Switch',
  component: Switch,
  argTypes: {
    label: {
      control: false,
    },
    onChange: {
      table: {
        disable: true,
      },
    },
  },
} as Meta<typeof Switch>;

const Template: StoryFn<typeof Switch> = ({ ...args }) => <Switch {...args} />;

export const Default = Template.bind({});
Default.args = {};

export const Label = Template.bind({});
Label.args = {
  label: 'Label',
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import React from 'react';
import { StoryFn, Meta } from '@storybook/react';
import { Switch } from './Switch';
export default {
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/design-system/src/switch/Switch.styles.ts
Tamaño: 1359 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { createStyles, MantineTheme } from '@mantine/core';

import { colors } from '../config';

export default createStyles((theme: MantineTheme, _params, getRef) => {
  const dark = theme.colorScheme === 'dark';
  const label = getRef('label');

  return {
    root: {
      display: 'flex',
      alignItems: 'center',
    },
    input: {
      backgroundColor: dark ? theme.colors.dark[5] : theme.colors.gray[5],
      width: '1px',
      height: '1px',
      border: 'transparent',
      cursor: 'pointer',
      '&::before': {
        border: 'transparent',
        width: '20px',
        height: '20px',
      },
      '&:not(checked) ~ label': {
        backgroundColor: dark ? 'rgb(61, 61, 77)' : theme.colors.gray[5],
      },
      '&:checked ~ label': {
        backgroundImage: colors.horizontal,
      },
      [`&:checked ~ div > .${label}`]: {
        backgroundImage: colors.horizontal,
        backgroundClip: 'text',
        color: 'transparent',
      },
      '&:disabled': {
        opacity: 0.75,
      },
    },
    label: {
      ref: label,
      paddingLeft: '10px',
      backgroundImage: 'none',
      color: dark ? theme.colors.dark[6] : theme.colors.gray[6],
      cursor: 'pointer',
    },
    track: {
      width: '46px',
      height: '24px',
      border: 'none',
    },
    thumb: {
      border: 'none',
    },
  };
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export default  createStyles

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/design-system/src/switch/Switch.tsx
Tamaño: 753 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import React, { ChangeEvent } from 'react';
import { Switch as MantineSwitch } from '@mantine/core';
import useStyles from './Switch.styles';

interface ISwitchProps {
  label?: React.ReactNode;
  checked?: boolean;
  onChange?: (event: ChangeEvent<HTMLInputElement>) => void;
  loading?: boolean;
  disabled?: boolean;
}

/**
 * Switch component
 *
 */
export const Switch = React.forwardRef<HTMLInputElement, ISwitchProps>(
  ({ onChange, loading = false, disabled = false, ...props }, ref) => {
    const { classes } = useStyles();

    return (
      <MantineSwitch
        ref={ref}
        disabled={disabled}
        onChange={onChange}
        radius="xl"
        size="md"
        classNames={classes}
        {...props}
      />
    );
  }
);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import React, { ChangeEvent } from 'react';
import { Switch as MantineSwitch } from '@mantine/core';
import useStyles from './Switch.styles';
interface ISwitchProps {
/**
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/design-system/src/table/DefaultCell.tsx
Tamaño: 263 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import type { IExtendedCellProps } from './Table';
import { withCellLoading } from './withCellLoading';

const DefaultCellComponent = ({ value }: IExtendedCellProps) => {
  return value ?? '';
};

export const DefaultCell = withCellLoading(DefaultCellComponent);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import type { IExtendedCellProps } from './Table';
import { withCellLoading } from './withCellLoading';
const DefaultCellComponent = ({ value }: IExtendedCellProps) => {
return value ?? '';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/design-system/src/table/Table.stories.tsx
Tamaño: 2040 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { useState } from 'react';
import { StoryFn, Meta } from '@storybook/react';
import { Badge } from '@mantine/core';

import { Switch } from '../switch/Switch';
import { IExtendedColumn, Table } from './Table';

export default {
  title: 'Components/Table',
  component: Table,
  argTypes: {
    data: {
      control: false,
    },
    columns: {
      control: false,
    },
  },
} as Meta<typeof Table>;

const SwitchCell = (props) => {
  const [status, setStatus] = useState(props.status);
  const switchHandler = () => {
    setStatus((prev) => (prev === 'Enabled' ? 'Disabled' : 'Enabled'));
  };

  return <Switch label={status} onChange={switchHandler} checked={status === 'Enabled'} />;
};

const BadgeCell = (props) => {
  return (
    <Badge
      sx={(theme) => ({
        color: theme.colorScheme === 'dark' ? theme.white : theme.colors.gray[8],
        borderColor: theme.colorScheme === 'dark' ? theme.colors.dark[5] : theme.colors.gray[5],
        borderRadius: '5px',
        backgroundColor: 'transparent',
        height: '30px',
        padding: '10px',
        fontSize: '14px',
        fontWeight: 400,
      })}
      variant="outline"
      size="md"
      radius="xs"
    >
      {props.category}
    </Badge>
  );
};

interface IExampleData {
  name: string;
  category: string;
  creationDate: string;
  status: string;
}

const columns: IExtendedColumn<IExampleData>[] = [
  { accessor: 'name', Header: 'Name' },
  { accessor: 'category', Header: 'Category', Cell: BadgeCell },
  { accessor: 'creationDate', Header: 'Date Created' },
  { accessor: 'status', Header: 'Status', Cell: SwitchCell },
];

const data: IExampleData[] = [
  { name: 'Great', category: 'Fun', status: 'Disabled', creationDate: '01/01/2021 16:36' },
  { name: 'Whats up?', category: 'Done', status: 'Enabled', creationDate: '01/01/2021 16:36' },
];

const Template: StoryFn<typeof Table> = ({ ...args }) => <Table columns={columns as any} data={data} {...args} />;

export const PrimaryUse = Template.bind({});
PrimaryUse.args = {};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { useState } from 'react';
import { StoryFn, Meta } from '@storybook/react';
import { Badge } from '@mantine/core';
import { Switch } from '../switch/Switch';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/design-system/src/table/Table.styles.ts
Tamaño: 1941 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { createStyles, MantineTheme } from '@mantine/core';
import { colors } from '../config';

export default createStyles((theme: MantineTheme, { withSelection }: { withSelection: boolean }, getRef) => {
  const dark = theme.colorScheme === 'dark';
  const hover = { ref: getRef('hover') };

  return {
    hover,
    tableRow: {
      td: {
        textOverflow: 'ellipsis',
      },
    },
    root: {
      borderCollapse: 'collapse',
      borderSpacing: '0px 20px',
      'tr td:first-of-type': {
        paddingLeft: withSelection ? 10 : 30,
        paddingRight: withSelection ? 10 : 30,
      },
      'tr th:first-of-type': {
        paddingLeft: withSelection ? 10 : 30,
        paddingRight: withSelection ? 10 : 30,
      },
      'tr td:last-child': {
        paddingRight: 30,
      },
      'tr th:last-child': {
        paddingRight: 30,
      },
      '& thead tr': {
        borderBottom: `1px solid ${dark ? colors.B30 : colors.B98}`,
      },
      '& thead tr th': {
        fontWeight: 400,
        height: '17px',
        color: dark ? colors.B40 : colors.B70,
        borderBottom: 'none',
        borderSpacing: '0px',
        paddingBottom: '15px',
      },
      '& tbody tr td': {
        maxWidth: '100px',
        color: dark ? colors.white : colors.B40,
        borderBottomColor: dark ? colors.BGDark : colors.BGLight,
        height: '80px',
      },
      '& tbody tr[data-disabled="true"]:hover': {
        cursor: 'default',
      },
      '& tbody tr[data-disabled="false"]:hover': {
        cursor: 'pointer',
      },
      '& tbody tr:last-of-type td': {
        borderBottom: `1px solid ${dark ? colors.B20 : colors.B98}`,
      },
      '&[data-hover]': {
        '& tbody tr:hover': {
          backgroundColor: dark ? colors.B20 : colors.B98,
        },
        [`&.${hover.ref} tbody tr:hover`]: {
          backgroundColor: dark ? colors.B20 : colors.B98,
        },
      },
    },
  };
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export default  createStyles

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/design-system/src/table/Table.tsx
Tamaño: 8578 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import React, { useEffect, useMemo } from 'react';
import { Skeleton, TableProps, Table as MantineTable, Pagination, Button } from '@mantine/core';
import styled from '@emotion/styled';
import {
  useTable,
  Column,
  usePagination,
  TableInstance,
  UsePaginationInstanceProps,
  UsePaginationState,
  Row,
  CellProps,
  IdType,
  useRowSelect,
  UseRowSelectInstanceProps,
  UseRowSelectState,
} from 'react-table';
import { useDataRef } from '../hooks/useDataRef';

import useStyles from './Table.styles';
import { colors } from '../config';
import { DefaultCell } from './DefaultCell';
import { ChevronLeft, ChevronRight } from '../icons';
import { Radio } from '../radio/Radio';

const NoDataPlaceholder = styled.div`
  padding: 0 30px;
  flex: 1;
`;

const RadioSkeleton = styled(Skeleton)`
  width: 20px;
  min-width: 20px;
  height: 20px;
  border-radius: 100%;
`;

export type IExtendedCellProps<T extends object = {}> = CellProps<T> & { isLoading: boolean };

export type IExtendedColumn<T extends object = {}> = Column<T> & {
  Cell?: (props: IExtendedCellProps<T>) => React.ReactNode;
};

export type IRow<T extends object = {}> = Row<T>;

const defaultColumn: Partial<IExtendedColumn> = {
  Cell: DefaultCell,
};

export interface ITableProps<T extends object> {
  columns?: IExtendedColumn<T>[];
  data?: T[];
  loading?: boolean;
  pagination?: any;
  noDataPlaceholder?: React.ReactNode;
  loadingItems?: number;
  hasMore?: boolean;
  minimalPagination?: boolean;
  withSelection?: boolean;
  withRowClickSelection?: boolean;
  initialSelectedRows?: Record<IdType<T>, boolean>;
  onRowClick?: (row: Row<T>) => void;
  onRowSelect?: (row: Row<T>) => void;
}

type UseTableProps<T extends object> = UsePaginationInstanceProps<T> &
  UseRowSelectInstanceProps<T> &
  TableInstance<T> & {
    state: UsePaginationState<T> & UseRowSelectState<T>;
  };

/**
 * Table component
 *
 */
export function Table<T extends object>({
  columns: userColumns,
  data: userData,
  pagination = false,
  loading = false,
  noDataPlaceholder,
  loadingItems = 10,
  withSelection = false,
  initialSelectedRows,
  onRowClick,
  onRowSelect,
  ...props
}: ITableProps<T>) {
  const { pageSize, total, onPageChange, current } = pagination;
  const columns = useMemo(() => userColumns?.map((col) => ({ ...col })), [userColumns]);
  const data = useMemo(() => (userData || [])?.map((row) => ({ ...row })), [userData]);
  const fakeData = useMemo(() => Array.from({ length: loadingItems }).map((_, index) => ({ index })), [loadingItems]);
  const onPageChangeRef = useDataRef(onPageChange);

  const {
    getTableProps,
    getTableBodyProps,
    headerGroups,
    rows: allRows,
    prepareRow,
    page,
    gotoPage,
    toggleAllRowsSelected,
    state: { pageIndex },
  } = useTable(
    {
      columns,
      defaultColumn,
      data: loading ? fakeData : data,
      ...(pagination && !pagination?.minimalPagination
        ? {
            initialState: { pageIndex: current, pageSize },
            manualPagination: true,
            pageCount: Math.ceil(total / pageSize),
          }
        : {}),
      ...(withSelection && {
        autoResetSelectedRows: false,
        initialState: { selectedRowIds: initialSelectedRows ?? {} },
      }),
    } as any,
    usePagination,
    useRowSelect,
    (hooks) => {
      if (!withSelection) {
        return;
      }

      const selectionRow = {
        id: 'selection',
        Header: () => null,
        Cell: ({ row, isLoading }) => {
          if (isLoading) {
            return <RadioSkeleton />;
          }

          const { checked } = row.getToggleRowSelectedProps();

          return (
            <Radio
              checked={checked}
              onChange={(e) => {
                e.stopPropagation();

                toggleAllRowsSelected(false);
                row.toggleRowSelected(true);
                onRowSelect?.(row);
              }}
              size="sm"
              styles={{ radio: { margin: '0 !important', cursor: 'pointer' } }}
            />
          );
        },
        width: 30,
        maxWidth: 30,
      };
      hooks.visibleColumns.push((visibleColumns) => [selectionRow, ...visibleColumns]);
    }
  ) as unknown as UseTableProps<T>;

  useEffect(() => {
    onPageChangeRef.current?.(pageIndex);
  }, [onPageChangeRef, pageIndex]);

  const handlePageChange = (pageNumber) => {
    if (pagination?.minimalPagination) {
      onPageChange(pageNumber);
    } else {
      gotoPage(pageNumber - 1);
    }
  };
  const getPageCount = () => {
    return Math.ceil(total / pageSize);
  };

  const { classes } = useStyles({ withSelection });
  const defaultDesign = { verticalSpacing: 'sm', horizontalSpacing: 'sm', highlightOnHover: true } as TableProps;
  const rows = pagination ? page : allRows;
  const noData = rows.length === 0;

  return (
    <div style={{ position: 'relative', minHeight: 500, display: 'flex', flexDirection: 'column' }} data-table-holder>
      <MantineTable className={classes.root} {...defaultDesign} {...getTableProps()} {...props}>
        <thead>
          {headerGroups.map((headerGroup, i) => {
            const { key: trKey, ...trRest } = headerGroup.getHeaderGroupProps();

            return (
              <tr key={trKey} {...trRest}>
                {headerGroup.headers.map((column) => {
                  const { key: thKey, ...thRest } = column.getHeaderProps();

                  return (
                    <th key={thKey} {...thRest}>
                      {column.render('Header')}
                    </th>
                  );
                })}
              </tr>
            );
          })}
        </thead>
        <tbody {...getTableBodyProps()}>
          {rows.map((row) => {
            prepareRow(row);

            const { key: trKey, ...trRest } = row.getRowProps();

            return (
              <tr
                key={trKey}
                onClick={(e) => {
                  e.stopPropagation();
                  if (!loading && onRowClick) {
                    onRowClick(row);
                  }
                }}
                {...trRest}
                className={classes.tableRow}
                data-disabled={loading || !onRowClick}
              >
                {row.cells.map((cell, i) => {
                  const { key: tdKey, ...tdRest } = cell.getCellProps({
                    style: {
                      maxWidth: cell.column.maxWidth,
                      width: cell.column.width,
                    },
                  });

                  return (
                    <td key={tdKey} {...tdRest}>
                      {cell.render('Cell', { isLoading: loading })}
                    </td>
                  );
                })}
              </tr>
            );
          })}
        </tbody>
      </MantineTable>
      {!loading && noData && noDataPlaceholder && <NoDataPlaceholder>{noDataPlaceholder}</NoDataPlaceholder>}
      {!loading && pagination && total > 0 && pageSize > 1 && getPageCount() > 1 && !pagination?.minimalPagination && (
        <div style={{ marginTop: 'auto' }}>
          <Pagination
            styles={{
              item: {
                marginTop: '15px',
                marginBottom: '15px',
                backgroundColor: 'transparent',
                '&[data-active]': {
                  backgroundImage: colors.horizontal,
                  border: 'none',
                },
              },
            }}
            total={getPageCount()}
            page={pageIndex + 1}
            onChange={handlePageChange}
            position="center"
          />
        </div>
      )}

      {!loading && pagination && pageSize > 1 && pagination?.minimalPagination && (
        <div
          style={{
            display: 'flex',
            width: '100%',
            justifyContent: 'center',
            alignItems: 'center',
            padding: '15px',
          }}
        >
          <Button.Group>
            <Button
              variant="outline"
              disabled={pagination?.current === 0 || loading}
              onClick={() => handlePageChange(pagination?.current - 1)}
            >
              <ChevronLeft />
            </Button>
            <Button
              loading={loading}
              variant="outline"
              disabled={!pagination?.hasMore || loading}
              onClick={() => handlePageChange(pagination?.current + 1)}
            >
              <ChevronRight />
            </Button>
          </Button.Group>
        </div>
      )}
    </div>
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import React, { useEffect, useMemo } from 'react';
import { Skeleton, TableProps, Table as MantineTable, Pagination, Button } from '@mantine/core';
import styled from '@emotion/styled';
import {
useTable,
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/design-system/src/table/index.ts
Tamaño: 173 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export { Table } from './Table';
export type { IExtendedColumn, IExtendedCellProps, IRow, ITableProps } from './Table';
export { withCellLoading } from './withCellLoading';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export  type
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/design-system/src/table/withCellLoading.tsx
Tamaño: 1012 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import styled from '@emotion/styled';
import { Skeleton } from '@mantine/core';

import { Renderer } from 'react-table';
import { IExtendedCellProps } from './Table';

const SkeletonStyled = styled(Skeleton)`
  width: 100%;
`;

export const withCellLoading = <T extends object = {}>(
  Component: Renderer<IExtendedCellProps<T>>,
  { width = 100, height = 20, loadingTestId }: { width?: number; height?: number; loadingTestId?: string } = {}
) => {
  const displayName =
    typeof Component === 'function' ? (Component as React.ComponentType).displayName || Component.name : 'Component';

  const CellLoading = ({ isLoading, ...rest }: IExtendedCellProps<T>) => {
    if (isLoading) {
      return <SkeletonStyled width={width} height={height} data-test-id={loadingTestId} />;
    }

    if (typeof Component === 'function') {
      return <Component isLoading={isLoading} {...rest} />;
    }

    return Component;
  };

  CellLoading.displayName = `withCellLoading(${displayName})`;

  return CellLoading;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import styled from '@emotion/styled';
import { Skeleton } from '@mantine/core';
import { Renderer } from 'react-table';
import { IExtendedCellProps } from './Table';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/design-system/src/tabs/Tabs.stories.tsx
Tamaño: 1561 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { StoryFn, Meta } from '@storybook/react';

import { Tabs } from './Tabs';

export default {
  title: 'Menus/TabsMenu',

  component: Tabs,

  argTypes: {},
} as Meta<typeof Tabs>;

const Template: StoryFn<typeof Tabs> = ({ ...args }) => <Tabs {...args} />;

export const Default = Template.bind({});
Default.args = {
  menuTabs: [
    {
      value: 'Branding',
      content: 'Branding',
    },

    {
      value: 'In App Center',
      content: 'In App Center',
    },

    {
      value: 'Email Settings',
      content: 'Email Settings',
    },

    {
      value: 'SMS',
      content: 'SMS',
    },

    {
      value: 'Api Keys',
      content: 'Api Keys',
    },
  ],
};

export const VerticalTabMenu = Template.bind({});
VerticalTabMenu.args = {
  ...Default.args,

  orientation: 'vertical',
};

export const HorizontalTabMenuWithIcon = Template.bind({});
HorizontalTabMenuWithIcon.args = {
  menuTabs: [
    {
      value: 'Branding',
      content: 'Branding',
      icon: '46',
    },

    {
      value: 'In App Center',
      content: 'In App Center',
      icon: '45',
    },

    {
      value: 'Email Settings',
      content: 'Email Settings',
      icon: '44',
    },

    {
      value: 'SMS',
      content: 'SMS',
      icon: '43',
    },

    {
      value: 'Api Keys',
      content: 'Api Keys',
      icon: '42',
    },
  ],

  withIcon: true,
};

export const VerticalTabMenuWithIcon = Template.bind({});
VerticalTabMenuWithIcon.args = {
  ...HorizontalTabMenuWithIcon.args,

  withIcon: true,

  orientation: 'vertical',
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { StoryFn, Meta } from '@storybook/react';
import { Tabs } from './Tabs';
export default {
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/design-system/src/tabs/Tabs.styles.ts
Tamaño: 1811 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { createStyles, MantineTheme } from '@mantine/core';

import { colors } from '../config';

export const useTabsStyles = createStyles((theme: MantineTheme, withIcon: boolean, getRef) => {
  const dark = theme.colorScheme === 'dark';

  const tabLabel = getRef('tabLabel');
  const tabIcon = getRef('tabIcon');

  return {
    tabsList: {
      gap: '30px',
      borderBottom: 'none',
    },

    panel: {
      paddingTop: '15px',
    },

    tab: {
      display: 'block',
      cursor: 'pointer',
      marginBottom: withIcon ? '30px' : '0',
      padding: '0px',
      height: '30px',
      borderBottom: 'none',

      '&:hover': {
        background: 'none',

        [`& .${tabIcon}`]: {
          color: dark ? colors.white : colors.B40,
        },

        [`& .${tabLabel}`]: {
          color: dark ? colors.white : colors.B40,
        },
      },
      '&[data-active]': {
        width: 'auto',

        [`& .${tabLabel}`]: {
          color: dark ? colors.white : colors.B40,

          '&::after': {
            content: '""',
            display: 'block',

            height: '2px',
            marginTop: '10px',
            background: colors.horizontal,
            borderRadius: '10px',
          },
        },

        [`& .${tabIcon}`]: {
          color: 'red',
          background: colors.horizontal,
          WebkitBackgroundClip: 'text',
          WebkitTextFillColor: 'transparent',
        },
      },
    },

    tabLabel: {
      ref: tabLabel,
      height: '100%',
      fontSize: '14px',
      fontWeight: 700,
      color: colors.B60,
      textAlign: 'left',
    },

    tabIcon: {
      ref: tabIcon,

      display: 'block',
      fontSize: '26px',
      fontWeight: 700,
      marginBottom: '5px',
      color: colors.B60,
      textAlign: 'left',
    },
  };
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - useTabsStyles(createStyles((theme: MantineTheme, withIcon: boolean, getRef))
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/design-system/src/tabs/Tabs.tsx
Tamaño: 2363 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { LoadingOverlay, Tabs as MantineTabs, TabsValue, Group } from '@mantine/core';
import React, { ReactNode } from 'react';
import { useTabsStyles } from './Tabs.styles';
import { colors } from '../config';
import { SpacingProps } from '../shared/spacing.props';

interface IMenuButtonProp {
  value: string;
  content?: ReactNode | string;
  icon?: ReactNode | string;
}

interface ITabsProp extends SpacingProps {
  menuTabs: IMenuButtonProp[];
  orientation?: 'horizontal' | 'vertical';
  value?: string | null;
  defaultValue?: string | null;
  onTabChange?: (value: TabsValue) => void;
  withIcon?: boolean;
  loading?: boolean;
  keepMounted?: boolean;
}

export const Tabs = React.forwardRef<HTMLDivElement, ITabsProp>(
  (
    {
      menuTabs,
      value,
      defaultValue,
      onTabChange,
      orientation = 'horizontal',
      withIcon = false,
      loading = false,
      keepMounted = true,
    }: ITabsProp,
    ref
  ) => {
    const { classes, theme } = useTabsStyles(withIcon);

    return (
      <div style={{ position: 'relative', minHeight: 'inherit' }}>
        <LoadingOverlay
          visible={loading}
          overlayColor={theme.colorScheme === 'dark' ? colors.B30 : colors.B98}
          loaderProps={{
            color: colors.error,
          }}
        />
        <MantineTabs
          orientation={orientation}
          ref={ref}
          value={value}
          defaultValue={defaultValue}
          onTabChange={onTabChange}
          variant="default"
          classNames={classes}
          keepMounted={keepMounted}
        >
          <MantineTabs.List>
            {menuTabs.map((menuTab, i) =>
              withIcon ? (
                <MantineTabs.Tab mb={0} value={menuTab.value} key={i}>
                  <Group spacing={8}>
                    {menuTab.icon} <span>{menuTab.value}</span>
                  </Group>
                </MantineTabs.Tab>
              ) : (
                <MantineTabs.Tab value={menuTab.value} key={i}>
                  {menuTab.value}
                </MantineTabs.Tab>
              )
            )}
          </MantineTabs.List>
          {menuTabs.map((menuTab, i) => (
            <MantineTabs.Panel value={menuTab.value} key={i}>
              {menuTab.content}
            </MantineTabs.Panel>
          ))}
        </MantineTabs>
      </div>
    );
  }
);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { LoadingOverlay, Tabs as MantineTabs, TabsValue, Group } from '@mantine/core';
import React, { ReactNode } from 'react';
import { useTabsStyles } from './Tabs.styles';
import { colors } from '../config';
import { SpacingProps } from '../shared/spacing.props';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/design-system/src/tag/Tag.tsx
Tamaño: 830 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Badge } from '@mantine/core';
import { PropsWithChildren } from 'react';
import { colors } from '../config';

interface ITagProps extends PropsWithChildren<{}> {
  color?: string;
  border?: string;
  ml?: number;
  mr?: number;
}

/**
 * Tag Component
 *
 */
export function Tag({ children, color, border, ...props }: ITagProps) {
  return (
    <Badge
      sx={(theme) => ({
        color: theme.colorScheme === 'dark' ? theme.white : colors.B40,
        border: `1px solid ${colors.B30}`,
        borderRadius: '5px',
        textTransform: 'none',
        backgroundColor: 'transparent',
        height: '30px',
        padding: '10px',
        fontSize: '14px',
        fontWeight: 400,
      })}
      variant="outline"
      size="md"
      radius="xs"
      {...props}
    >
      {children}
    </Badge>
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Badge } from '@mantine/core';
import { PropsWithChildren } from 'react';
import { colors } from '../config';
interface ITagProps extends PropsWithChildren<{}> {
/**
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/design-system/src/template-button/DragButton.tsx
Tamaño: 1982 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import styled from '@emotion/styled';
import { UnstyledButton } from '@mantine/core';
import React, { useState } from 'react';
import { When } from '../when';
import { colors } from '../config';
import { Drag } from '../icons/general/Drag';
import { useTemplateButtonStyles } from './TemplateButton.styles';

interface IDragButtonProps {
  Icon: React.FC<any>;
  description: string;
}

export function DragButton({ description, Icon }: IDragButtonProps) {
  const { classes, theme } = useTemplateButtonStyles();
  const [hover, setHover] = useState(false);

  return (
    <>
      <Button
        type={'button'}
        sx={{
          background: theme.colorScheme === 'dark' ? colors.B17 : colors.white,
          border: `1px dashed ${theme.colorScheme === 'dark' ? colors.B30 : colors.B80}`,
          height: description.length > 0 ? '75px' : '50px',
          position: 'relative',
          '&:hover': {
            cursor: 'grab',
          },
        }}
        onMouseEnter={() => {
          setHover(true);
        }}
        onMouseLeave={() => {
          setHover(false);
        }}
      >
        <When truthy={hover}>
          <Drag
            style={{
              position: 'absolute',
              left: -17,
              top: 15,
            }}
            color={colors.B80}
          />
        </When>
        <ButtonWrapper>
          <IconWrapper className={classes.linkIcon}>
            <Icon />
          </IconWrapper>
        </ButtonWrapper>
      </Button>
    </>
  );
}

const IconWrapper = styled.div`
  @media screen and (max-width: 1400px) {
    svg {
      width: 24px;
      height: 24px;
    }
  }
  margin-left: 0px;
`;

const ButtonWrapper = styled.div`
  display: flex;
  justify-content: center;
`;

const Button: any = styled(UnstyledButton)`
  position: relative;
  margin-bottom: 0;
  width: 64px;
  @media screen and (max-width: 1400px) {
    padding: 5px;
  }
  text-align: center;
  border-radius: 7px;
  cursor: grab;
`;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import styled from '@emotion/styled';
import { UnstyledButton } from '@mantine/core';
import React, { useState } from 'react';
import { When } from '../when';
import { colors } from '../config';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/design-system/src/template-button/IconWrapper.tsx
Tamaño: 231 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import styled from '@emotion/styled';

export const IconWrapper = styled.div`
  padding-right: 15px;

  @media screen and (max-width: 1400px) {
    padding-right: 5px;

    svg {
      width: 20px;
      height: 20px;
    }
  }
`;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import styled from '@emotion/styled';
export const IconWrapper = styled.div`
padding-right: 15px;
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/design-system/src/template-button/TemplateButton.styles.ts
Tamaño: 1139 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { createStyles } from '@mantine/core';
import { colors, shadows } from '../config';
import { getGradient } from '../config/helper';

export const useTemplateButtonStyles = createStyles((theme) => {
  const dark = theme.colorScheme === 'dark';

  return {
    active: {
      background: `${dark ? getGradient(colors.B20) : getGradient(colors.white)} padding-box, ${
        colors.horizontal
      } border-box`,
      boxShadow: dark ? shadows.dark : shadows.light,
    },
    variant: {
      height: '120px',
    },
    variantRoot: {
      border: `1px dashed ${dark ? colors.B40 : colors.B60}`,
    },
    button: {
      height: '80px',
      width: '100%',
      margin: '0px',
      backgroundColor: dark ? colors.B17 : colors.B98,
      borderRadius: '7px',
      fontWeight: 700,
      border: '1px solid transparent',
      boxShadow: dark ? shadows.dark : shadows.light,

      '&:hover': {
        backgroundColor: dark ? colors.B20 : colors.BGLight,
      },
    },
    linkIcon: {
      marginLeft: '5px',
      color: dark ? colors.B40 : colors.B70,
      '& *': {
        display: 'block',
      },
    },
  };
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - useTemplateButtonStyles(createStyles((theme))
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/design-system/src/template-button/TemplateButton.tsx
Tamaño: 4469 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import React, { useState } from 'react';
import { Popover, createStyles, UnstyledButton, UnstyledButtonProps, createPolymorphicComponent } from '@mantine/core';
import styled from '@emotion/styled';
import { useFormContext } from 'react-hook-form';

import { Text } from '../typography/text/Text';
import { Switch } from '../switch/Switch';
import { useTemplateButtonStyles } from './TemplateButton.styles';
import { colors } from '../config';
import { IconWrapper } from './IconWrapper';

const Button = createPolymorphicComponent<'button', UnstyledButtonProps>(
  React.forwardRef<HTMLButtonElement, UnstyledButtonProps>((props, ref) => {
    return <WrapperButton ref={ref} {...props} />;
  })
);

const WrapperButton: any = styled(UnstyledButton)`
  position: relative;

  @media screen and (max-width: 1400px) {
    padding: 0 5px;
  }
`;

const usePopoverStyles = createStyles(() => ({
  dropdown: {
    position: 'absolute',
    padding: '12px 15px 14px',
    backgroundColor: colors.error,
    color: colors.white,
    border: 'none',
    marginTop: '1px',
    maxWidth: 300,
  },
  arrow: {
    backgroundColor: colors.error,
    height: '7px',
    border: 'none',
    margin: '0px',
  },
}));

interface ITemplateButtonProps {
  Icon: React.FC<any>;
  description: string;
  label: string;
  active?: boolean;
  action?: boolean;
  tabKey: string;
  testId?: string;
  checked?: boolean;
  readonly?: boolean;
  switchButton?: (boolean) => void;
  changeTab: (string) => void;
  errors?: boolean | string;
}

export function TemplateButton({
  description,
  active,
  changeTab,
  tabKey,
  action = false,
  switchButton,
  checked = false,
  readonly = false,
  label,
  Icon,
  testId,
  errors = false,
}: ITemplateButtonProps) {
  const { cx, classes, theme } = useTemplateButtonStyles();
  const disabled = action && !checked;
  const disabledColor = disabled ? { color: theme.colorScheme === 'dark' ? colors.B40 : colors.B70 } : {};
  const disabledProp = disabled ? { disabled } : {};
  const [popoverOpened, setPopoverOpened] = useState(false);
  const { trigger } = useFormContext();
  const { classes: popoverClasses } = usePopoverStyles();

  return (
    <Button
      onMouseEnter={() => setPopoverOpened(true)}
      onMouseLeave={() => setPopoverOpened(false)}
      onClick={async () => {
        if (active) {
          return;
        }

        changeTab(tabKey);
      }}
      data-test-id={testId}
      className={cx(classes.button, { [classes.active]: active })}
    >
      <ButtonWrapper>
        <LeftContainerWrapper>
          <IconWrapper className={classes.linkIcon}>
            <Icon {...disabledProp} />
          </IconWrapper>
          <StyledContentWrapper>
            <Text {...disabledColor} weight="bold">
              {label}
            </Text>
            <Text mt={3} color={colors.B60} {...disabledColor}>
              {description}
            </Text>
          </StyledContentWrapper>
        </LeftContainerWrapper>

        <ActionWrapper>
          {action && !readonly && (
            <Switch checked={checked} onChange={(e) => switchButton && switchButton(e.target.checked)} />
          )}
        </ActionWrapper>
      </ButtonWrapper>

      {errors && (
        <Popover
          classNames={popoverClasses}
          withArrow
          opened={popoverOpened}
          transition="rotate-left"
          transitionDuration={250}
          offset={theme.spacing.xs}
          position="right"
        >
          <Popover.Target>
            <ErrorCircle data-test-id="error-circle" dark={theme.colorScheme === 'dark'} />
          </Popover.Target>
          <Popover.Dropdown>
            <Text color={colors.white} rows={1}>
              {errors || 'Something is missing here'}
            </Text>
          </Popover.Dropdown>
        </Popover>
      )}
    </Button>
  );
}
const ErrorCircle = styled.div<{ dark: boolean }>`
  width: 11px;
  height: 11px;
  display: inline-block;
  position: absolute;
  right: -6px;
  top: calc(50% - 4px);
  background: ${colors.error};
  border-radius: 50%;
  border: 3px solid ${({ dark }) => (dark ? colors.B15 : 'white')};
`;

const ActionWrapper = styled.div`
  display: flex;
  align-items: center;
`;

const LeftContainerWrapper = styled.div`
  display: flex;
  align-items: center;
`;

const ButtonWrapper = styled.div`
  display: flex;
  justify-content: space-between;
`;

const StyledContentWrapper = styled.div`
  padding-right: 10px;
`;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import React, { useState } from 'react';
import { Popover, createStyles, UnstyledButton, UnstyledButtonProps, createPolymorphicComponent } from '@mantine/core';
import styled from '@emotion/styled';
import { useFormContext } from 'react-hook-form';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/design-system/src/testing/index.tsx
Tamaño: 548 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import styled from '@emotion/styled';
import { MemoryRouter } from 'react-router-dom';
import { ThemeProvider } from '../ThemeProvider';

export function TestWrapper({ children }) {
  return (
    <MemoryRouter>
      <Wrapper>
        <Frame>
          <ThemeProvider>{children}</ThemeProvider>
        </Frame>
      </Wrapper>
    </MemoryRouter>
  );
}

const Frame = styled.div`
  min-width: 500px;
  display: inline-block;
`;

const Wrapper = styled.div`
  height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
`;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import styled from '@emotion/styled';
import { MemoryRouter } from 'react-router-dom';
import { ThemeProvider } from '../ThemeProvider';
export function TestWrapper({ children }) {
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/design-system/src/textarea/Textarea.tsx
Tamaño: 956 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import React, { ChangeEvent } from 'react';
import { Textarea as MantineTextarea } from '@mantine/core';
import { SpacingProps } from '../shared/spacing.props';
import { textareaStyles } from './textarea.styles';

interface ITextareaProps extends SpacingProps {
  label?: React.ReactNode;
  error?: React.ReactNode;
  placeholder?: string;
  required?: boolean;
  disabled?: boolean;
  value?: string;
  description?: string;
  onChange?: (event: ChangeEvent<HTMLTextAreaElement>) => void;
  minRows?: number;
  maxRows?: number;
}

/**
 * Textarea component
 *
 */
export const Textarea = React.forwardRef<HTMLTextAreaElement, ITextareaProps>(
  ({ value, onChange, disabled = false, ...props }: ITextareaProps, ref) => {
    return (
      <MantineTextarea
        ref={ref}
        styles={textareaStyles}
        onChange={onChange}
        autoComplete="off"
        disabled={disabled}
        value={value}
        {...props}
      />
    );
  }
);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import React, { ChangeEvent } from 'react';
import { Textarea as MantineTextarea } from '@mantine/core';
import { SpacingProps } from '../shared/spacing.props';
import { textareaStyles } from './textarea.styles';
/**
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/design-system/src/textarea/textarea.styles.ts
Tamaño: 1599 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { MantineTheme } from '@mantine/core';
import { colors } from '../config';

export const textareaStyles = (theme: MantineTheme) => {
  const dark = theme.colorScheme === 'dark';

  const primaryColor = dark ? theme.white : theme.colors.gray[8];
  const invalidColor = colors.error;
  const secondaryColor = dark ? theme.colors.dark[3] : theme.colors.gray[6];

  return {
    input: {
      borderColor: dark ? theme.colors.dark[5] : theme.colors.gray[5],
      backgroundColor: 'transparent',
      color: primaryColor,
      margin: '5px 0px',
      '&:focus, &:focus-within': {
        borderColor: theme.colors.gray[7],
      },
      '&::placeholder': {
        color: secondaryColor,
      },
    },
    label: {
      color: primaryColor,
      fontWeight: 700,
      fontSize: '14px',
      lineHeight: '17px',
      margin: '5px 0px',
    },
    invalid: {
      borderColor: invalidColor,
      color: primaryColor,
      '&::placeholder': {
        color: secondaryColor,
      },
    },
    error: {
      color: `${invalidColor} !important`,
      fontSize: '12px',
    },
    description: {
      color: `${secondaryColor} !important`,
      fontSize: `14px !important`,
      fontWeight: 400,
      marginTop: '0px',
      marginBottom: '10px',
      lineHeight: '17px',
    },
    disabled: {
      backgroundColor: `${dark ? colors.B20 : colors.B98} !important`,
      borderColor: `${dark ? colors.B30 : colors.BGLight} !important`,
      color: `${secondaryColor} !important`,
      '&::placeholder': {
        color: `${secondaryColor} !important`,
      },
    },
  };
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - textareaStyles(theme: MantineTheme))
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/design-system/src/tooltip/Tooltip.stories.tsx
Tamaño: 419 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import React from 'react';
import { StoryFn, Meta } from '@storybook/react';
import { Tooltip } from './Tooltip';

export default {
  title: 'Components/Tooltip',
  component: Tooltip,
  argTypes: {},
} as Meta<typeof Tooltip>;

const Template: StoryFn<typeof Tooltip> = ({ ...args }) => <Tooltip {...args}>Hover Here</Tooltip>;

export const Label = Template.bind({});
Label.args = {
  label: 'This is a tooltip!',
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import React from 'react';
import { StoryFn, Meta } from '@storybook/react';
import { Tooltip } from './Tooltip';
export default {
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/design-system/src/tooltip/Tooltip.styles.ts
Tamaño: 913 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { createStyles, MantineTheme } from '@mantine/core';
import { colors, shadows } from '../config';
import { getGradient } from '../config/helper';

export default createStyles((theme: MantineTheme, { error }: { error: boolean }) => {
  const dark = theme.colorScheme === 'dark';
  const opacityErrorColor = theme.fn.rgba(colors.error, 0.2);
  const errorGradient = getGradient(opacityErrorColor);
  const backgroundErrorColor = dark ? colors.B17 : colors.white;
  const backgroundColor = dark ? colors.B20 : colors.white;
  const background = error ? `${errorGradient}, ${backgroundErrorColor}` : backgroundColor;
  const color = error ? colors.error : colors.B60;

  return {
    tooltip: {
      background,
      color,
      boxShadow: dark ? shadows.dark : shadows.medium,
      padding: '12px 15px',
      fontSize: '14px',
      fontWeight: 400,
    },
    arrow: {
      background,
    },
  };
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export default  createStyles

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/design-system/src/tooltip/Tooltip.tsx
Tamaño: 1121 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { cx } from '@emotion/css';
import { Tooltip as MantineTooltip, TooltipProps } from '@mantine/core';

import useStyles from './Tooltip.styles';

export interface ITooltipProps
  extends Pick<
    TooltipProps,
    | 'arrowSize'
    | 'multiline'
    | 'width'
    | 'label'
    | 'opened'
    | 'position'
    | 'disabled'
    | 'children'
    | 'sx'
    | 'withinPortal'
    | 'offset'
    | 'classNames'
  > {
  error?: boolean;
}
/**
 * Tooltip component
 *
 */
export function Tooltip({
  children,
  label,
  opened = undefined,
  error = false,
  arrowSize = 3.5,
  classNames,
  ...props
}: ITooltipProps) {
  const { classes } = useStyles({ error });

  return (
    <MantineTooltip
      transition="fade"
      transitionDuration={300}
      opened={opened}
      // merge base classes with caller-supplied ones
      classNames={{
        tooltip: cx(classes.tooltip, classNames?.tooltip),
        arrow: cx(classes.arrow, classNames?.arrow),
      }}
      withArrow
      arrowSize={arrowSize}
      radius="md"
      label={label}
      {...props}
    >
      {children}
    </MantineTooltip>
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { cx } from '@emotion/css';
import { Tooltip as MantineTooltip, TooltipProps } from '@mantine/core';
import useStyles from './Tooltip.styles';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/design-system/src/typography/label/index.ts
Tamaño: 660 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import styled from '@emotion/styled';

export const Label = styled.div<{ gradientColor?: 'red' | 'blue' | 'none' }>`
  height: 20px;
  font-family: 'Lato', serif;
  font-style: normal;
  font-weight: 700;
  font-size: 16px;
  line-height: 20px;

  display: flex;
  align-items: center;

  ${({ gradientColor }) => {
    return (
      gradientColor !== 'none' &&
      `
    background: ${
      gradientColor === 'red'
        ? 'linear-gradient(90deg, #DD2476 0%, #FF512F 100%)'
        : 'linear-gradient(0deg, #14deeb 0%, #446edc 100%)'
    };
        
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;  
      `
    );
  }};
`;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - Label(styled.div<{ gradientColor?: 'red' | 'blue' | 'none' }>`
  height: 20px;
  font-family: 'Lato', seri...)
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/design-system/src/typography/text/Text.stories.tsx
Tamaño: 871 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import React from 'react';
import { StoryFn, Meta } from '@storybook/react';
import { Text } from './Text';

export default {
  title: 'Components/Typography/Text',
  component: Text,
  argTypes: {},
} as Meta<typeof Text>;

const Template: StoryFn<typeof Text> = ({ ...args }) => <Text {...args}>Example Text</Text>;

export const all = () => (
  <div>
    <Text>Default Body</Text>
    <Text size="lg">Body Large</Text>
    <Text weight="bold">Body Bold</Text>
    <Text size="md" weight="bold">
      Body Large Bold
    </Text>
  </div>
);

export const Body = Template.bind({});
Body.args = {};

export const BodyLarge = Template.bind({});
BodyLarge.args = {
  size: 'lg',
};

export const BodyBold = Template.bind({});
BodyBold.args = {
  weight: 'bold',
};

export const BodyLargeBold = Template.bind({});
BodyLargeBold.args = {
  size: 'lg',
  weight: 'bold',
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import React from 'react';
import { StoryFn, Meta } from '@storybook/react';
import { Text } from './Text';
export default {
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/design-system/src/typography/text/Text.tsx
Tamaño: 1291 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import React, { PropsWithChildren } from 'react';
import { Text as MantineText, MantineColor, useMantineTheme, TextProps } from '@mantine/core';

import { colors } from '../../config';
import { SpacingProps } from '../../shared/spacing.props';

interface ITextProps extends PropsWithChildren<{}>, SpacingProps {
  size?: TextProps['size'];
  style?: TextProps['style'];
  styles?: TextProps['styles'];
  align?: 'left' | 'center' | 'right' | 'justify';
  weight?: 'bold' | 'normal';
  color?: MantineColor;
  rows?: number;
  gradient?: boolean;
  transform?: TextProps['transform'];
}

/**
 * Text component
 *
 */
export const Text = React.forwardRef<HTMLDivElement, ITextProps>(({ children, gradient = false, ...props }, ref) => {
  const { colorScheme } = useMantineTheme();
  const gradientStyles = gradient
    ? { backgroundImage: colors.horizontal, WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent' }
    : {};

  let textColor = props.color;
  if (!textColor) {
    textColor = colorScheme === 'dark' ? colors.white : colors.B40;
  }

  return (
    <MantineText
      lineClamp={props.rows}
      size="md"
      weight="normal"
      style={gradientStyles}
      ref={ref}
      {...props}
      color={textColor}
    >
      {children}
    </MantineText>
  );
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import React, { PropsWithChildren } from 'react';
import { Text as MantineText, MantineColor, useMantineTheme, TextProps } from '@mantine/core';
import { colors } from '../../config';
import { SpacingProps } from '../../shared/spacing.props';
/**
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/design-system/src/typography/title/Title.stories.tsx
Tamaño: 587 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import React from 'react';
import { StoryFn, Meta } from '@storybook/react';
import { Title } from './Title';

export default {
  title: 'Components/Typography/Title',
  component: Title,
  argTypes: {},
} as Meta<typeof Title>;

const Template: StoryFn<typeof Title> = ({ ...args }) => <Title {...args}>Example Text</Title>;

export const all = () => (
  <div>
    <Title>Header 1</Title>
    <Title size={2}>Header 2</Title>
  </div>
);

export const Header1 = Template.bind({});
Header1.args = {
  size: 1,
};

export const Header2 = Template.bind({});
Header2.args = {
  size: 2,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import React from 'react';
import { StoryFn, Meta } from '@storybook/react';
import { Title } from './Title';
export default {
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/design-system/src/typography/title/Title.tsx
Tamaño: 826 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { MantineColor, Title as MantineTitle, useMantineTheme } from '@mantine/core';
import { PropsWithChildren } from 'react';
import { colors } from '../../config';
import { SpacingProps } from '../../shared/spacing.props';

interface ITitleProps extends PropsWithChildren<{}>, SpacingProps {
  size?: 1 | 2;
  color?: MantineColor;
}
/**
 * Use Title to create headers.
 *
 */
export function Title({ size = 1, children, ...props }: ITitleProps) {
  const { colorScheme } = useMantineTheme();

  let textColor = props.color;
  if (!textColor) {
    textColor = colorScheme === 'dark' ? colors.white : colors.B40;
  }

  return (
    <MantineTitle
      sx={{
        fontWeight: size === 1 ? 800 : 700,
      }}
      order={size}
      color={textColor}
      {...props}
    >
      {children}
    </MantineTitle>
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { MantineColor, Title as MantineTitle, useMantineTheme } from '@mantine/core';
import { PropsWithChildren } from 'react';
import { colors } from '../../config';
import { SpacingProps } from '../../shared/spacing.props';
/**
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/design-system/src/utils/clamp.spec.ts
Tamaño: 1545 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, describe, it } from 'vitest';
import { clamp } from './clamp';

describe('clamp', () => {
  it('should return the value itself if it is within the inclusive bounds', () => {
    const result = clamp(5, 0, 10);
    expect(result).to.equal(5);
  });

  it('should clamp the value to the minimum bound if it is less than the minimum bound', () => {
    const result = clamp(-5, 0, 10);
    expect(result).to.equal(0);
  });

  it('should clamp the value to the maximum bound if it is greater than the maximum bound', () => {
    const result = clamp(15, 0, 10);
    expect(result).to.equal(10);
  });

  it('should work correctly with negative values', () => {
    const result = clamp(-7, -10, 5);
    expect(result).to.equal(-7);
  });

  it('should work correctly with decimal values', () => {
    const result = clamp(3.5, 1, 5);
    expect(result).to.equal(3.5);
  });

  it('should handle min and max being the same value', () => {
    const result = clamp(5, 5, 5);
    expect(result).to.equal(5);
  });

  it('should handle min being greater than max by swapping them', () => {
    const result = clamp(8, 10, 5);
    expect(result).to.equal(8);
  });

  it('should handle NaN values by returning NaN', () => {
    const result = clamp(NaN, 0, 10);
    expect(result).to.be.NaN;
  });

  it('should handle Infinity and -Infinity values correctly', () => {
    const result1 = clamp(Infinity, 0, 10);
    expect(result1).to.equal(10);

    const result2 = clamp(-Infinity, 0, 10);
    expect(result2).to.equal(0);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - result(clamp(5, 0, 10);
    expect(result).to.equal(5);
  });

  it('should clamp the value to the minimum ...)
 - result(clamp(-5, 0, 10);
    expect(result).to.equal(0);
  });

  it('should clamp the value to the maximum...)
 - result(clamp(15, 0, 10);
    expect(result).to.equal(10);
  });

  it('should work correctly with negative ...)
 - result(clamp(-7, -10, 5);
    expect(result).to.equal(-7);
  });

  it('should work correctly with decimal ...)
 - result(clamp(3.5, 1, 5);
    expect(result).to.equal(3.5);
  });

  it('should handle min and max being the...)
 - result(clamp(5, 5, 5);
    expect(result).to.equal(5);
  });

  it('should handle min being greater than ma...)
 - result(clamp(8, 10, 5);
    expect(result).to.equal(8);
  });

  it('should handle NaN values by returning ...)
 - result(clamp(NaN, 0, 10);
    expect(result).to.be.NaN;
  });

  it('should handle Infinity and -Infinity v...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/design-system/src/utils/clamp.ts
Tamaño: 285 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/** Return value within inclusive bounds of min and max */
export const clamp = (value: number, min: number, max: number): number => {
  const verifiedMin = Math.min(min, max);
  const verifiedMax = Math.max(min, max);

  return Math.max(Math.min(value, verifiedMax), verifiedMin);
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - clamp(value: number, min: number, max: number): number)
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/design-system/src/utils/index.ts
Tamaño: 58 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './clamp';
export * from './notifications';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/design-system/src/utils/notifications.tsx
Tamaño: 931 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { showNotification } from '@mantine/notifications';
import { colors } from '../config';
import { Check, ErrorIcon } from '../icons';

export function successMessage(message: string, id?: string) {
  showNotification({
    id,
    message,
    icon: <Check />,
    styles: (theme) => ({
      icon: {
        width: '22px',
        height: '22px',
        marginRight: '10px',
        color: theme.colorScheme === 'dark' ? `${colors.B15} !important` : `${colors.white} !important`,
        backgroundColor: colors.success,
      },
    }),
  });
}

export function errorMessage(message: string) {
  showNotification({
    message,
    icon: <ErrorIcon />,
    styles: (theme) => ({
      icon: {
        width: '22px',
        height: '22px',
        marginRight: '10px',
        color: `${colors.error} !important`,
        backgroundColor: theme.colorScheme === 'dark' ? colors.B15 : colors.white,
      },
    }),
  });
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { showNotification } from '@mantine/notifications';
import { colors } from '../config';
import { Check, ErrorIcon } from '../icons';
export function successMessage(message: string, id?: string) {
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/design-system/src/when/index.tsx
Tamaño: 91 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

export const When = ({ truthy, children, fallback = null }) => (truthy ? children : null);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

export const When = ({ truthy, children, fallback = null }) => (truthy ? children : null);
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/internal-sdk/.gitattributes
Tamaño: 82 bytes
Lenguaje detectado: GITATTRIBUTES

### CONTENIDO ORIGINAL ###

# This allows generated code to be indexed correctly
*.ts linguist-generated=false

### ANALISIS AUTOMATICO (ESPAÑOL) ###

# This allows generated code to be indexed correctly
*.ts linguist-generated=false
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/internal-sdk/.gitignore
Tamaño: 415 bytes
Lenguaje detectado: GITIGNORE

### CONTENIDO ORIGINAL ###

/.eslintcache
/examples/node_modules
.env
.env.local
.env.*.local
**/.speakeasy/temp/
**/.speakeasy/logs/
.speakeasy/temp/
.DS_Store
/mcp-server
/bin
/models
/models/errors
/types
/node_modules
/lib
/sdk
/funcs
/react-query
/hooks
/docs
/sources/json-development.json
/.speakeasy/gen.lock
/.speakeasy/workflow.lock
/*.md
/index.*
/core.*
/cjs
/esm
/dist
/.tsbuildinfo
/.tshy
/.tshy-*
/__tests__
/.speakeasy/reports


### ANALISIS AUTOMATICO (ESPAÑOL) ###

/.eslintcache
/examples/node_modules
.env
.env.local
.env.*.local
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/internal-sdk/.npmignore
Tamaño: 157 bytes
Lenguaje detectado: NPMIGNORE

### CONTENIDO ORIGINAL ###

**/*
!/FUNCTIONS.md
!/RUNTIMES.md
!/REACT_QUERY.md
!/**/*.ts
!/**/*.js
!/**/*.mjs
!/**/*.json
!/**/*.map

/eslint.config.mjs
/cjs
/.tshy
/.tshy-*
/__tests__


### ANALISIS AUTOMATICO (ESPAÑOL) ###

**/*
!/FUNCTIONS.md
!/RUNTIMES.md
!/REACT_QUERY.md
!/**/*.ts
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/internal-sdk/CONTRIBUTING.md
Tamaño: 1333 bytes
Lenguaje detectado: Markdown

### CONTENIDO ORIGINAL ###

# Contributing to This Repository

Thank you for your interest in contributing to this repository. Please note that this repository contains generated code. As such, we do not accept direct changes or pull requests. Instead, we encourage you to follow the guidelines below to report issues and suggest improvements.

## How to Report Issues

If you encounter any bugs or have suggestions for improvements, please open an issue on GitHub. When reporting an issue, please provide as much detail as possible to help us reproduce the problem. This includes:

- A clear and descriptive title
- Steps to reproduce the issue
- Expected and actual behavior
- Any relevant logs, screenshots, or error messages
- Information about your environment (e.g., operating system, software versions)
    - For example can be collected using the `npx envinfo` command from your terminal if you have Node.js installed

## Issue Triage and Upstream Fixes

We will review and triage issues as quickly as possible. Our goal is to address bugs and incorporate improvements in the upstream source code. Fixes will be included in the next generation of the generated code.

## Contact

If you have any questions or need further assistance, please feel free to reach out by opening an issue.

Thank you for your understanding and cooperation!

The Maintainers


### ANALISIS AUTOMATICO (ESPAÑOL) ###

# Contributing to This Repository
Thank you for your interest in contributing to this repository. Please note that this repository contains generated code. As such, we do not accept direct changes or pull requests. Instead, we encourage you to follow the guidelines below to report issues and suggest improvements.
## How to Report Issues
## Issue Triage and Upstream Fixes
## Contact
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/internal-sdk/RUNTIMES.md
Tamaño: 2045 bytes
Lenguaje detectado: Markdown

### CONTENIDO ORIGINAL ###

# Supported JavaScript runtimes

This SDK is intended to be used in JavaScript runtimes that support ECMAScript 2020 or newer. The SDK uses the following features:

- [Web Fetch API][web-fetch]
- [Web Streams API][web-streams] and in particular `ReadableStream`
- [Async iterables][async-iter] using `Symbol.asyncIterator`

[web-fetch]: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
[web-streams]: https://developer.mozilla.org/en-US/docs/Web/API/Streams_API
[async-iter]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_async_iterator_and_async_iterable_protocols

Runtime environments that are explicitly supported are:

- Evergreen browsers which include: Chrome, Safari, Edge, Firefox
- Node.js active and maintenance LTS releases
  - Currently, this is v18 and v20
- Bun v1 and above
- Deno v1.39
  - Note that Deno does not currently have native support for streaming file uploads backed by the filesystem ([issue link][deno-file-streaming])

[deno-file-streaming]: https://github.com/denoland/deno/issues/11018

## Recommended TypeScript compiler options

The following `tsconfig.json` options are recommended for projects using this
SDK in order to get static type support for features like async iterables,
streams and `fetch`-related APIs ([`for await...of`][for-await-of],
[`AbortSignal`][abort-signal], [`Request`][request], [`Response`][response] and
so on):

[for-await-of]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of
[abort-signal]: https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal
[request]: https://developer.mozilla.org/en-US/docs/Web/API/Request
[response]: https://developer.mozilla.org/en-US/docs/Web/API/Response

```jsonc
{
  "compilerOptions": {
    "target": "es2020", // or higher
    "lib": ["es2020", "dom", "dom.iterable"]
  }
}
```

While `target` can be set to older ECMAScript versions, it may result in extra,
unnecessary compatibility code being generated if you are not targeting old
runtimes.


### ANALISIS AUTOMATICO (ESPAÑOL) ###

# Supported JavaScript runtimes
This SDK is intended to be used in JavaScript runtimes that support ECMAScript 2020 or newer. The SDK uses the following features:
- [Web Fetch API][web-fetch]
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/internal-sdk/core.js.map
Tamaño: 181 bytes
Lenguaje detectado: MAP

### CONTENIDO ORIGINAL ###

{"version":3,"file":"core.js","sourceRoot":"","sources":["src/core.ts"],"names":[],"mappings":";AAAA;;GAEG;;;AAEH,2CAA0C;AAE1C;;;;;GAKG;AACH,MAAa,QAAS,SAAQ,mBAAS;CAAG;AAA1C,4BAA0C"}

### ANALISIS AUTOMATICO (ESPAÑOL) ###

{"version":3,"file":"core.js","sourceRoot":"","sources":["src/core.ts"],"names":[],"mappings":";AAAA;;GAEG;;;AAEH,2CAA0C;AAE1C;;;;;GAKG;AACH,MAAa,QAAS,SAAQ,mBAAS;CAAG;AAA1C,4BAA0C"}
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/internal-sdk/eslint.config.mjs
Tamaño: 682 bytes
Lenguaje detectado: MJS

### CONTENIDO ORIGINAL ###

import globals from "globals";
import pluginJs from "@eslint/js";
import tseslint from "typescript-eslint";

/** @type {import('eslint').Linter.Config[]} */
export default [
  { files: ["**/*.{js,mjs,cjs,ts}"] },
  { languageOptions: { globals: globals.browser } },
  pluginJs.configs.recommended,
  ...tseslint.configs.recommended,
  {
    rules: {
      "no-constant-condition": "off",
      "no-useless-escape": "off",
      // Handled by typescript compiler
      "@typescript-eslint/no-unused-vars": "off",
      "@typescript-eslint/no-explicit-any": "off",
      "@typescript-eslint/no-empty-object-type": "off",
      "@typescript-eslint/no-namespace": "off",
    },
  },
];


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import globals from "globals";
import pluginJs from "@eslint/js";
import tseslint from "typescript-eslint";
/** @type {import('eslint').Linter.Config[]} */
// Handled by typescript compiler
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/internal-sdk/index.js.map
Tamaño: 221 bytes
Lenguaje detectado: MAP

### CONTENIDO ORIGINAL ###

{"version":3,"file":"index.js","sourceRoot":"","sources":["src/index.ts"],"names":[],"mappings":";AAAA;;GAEG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEH,kDAAgC;AAChC,wDAAwC;AACxC,yCAA2C;AAAlC,qGAAA,UAAU,OAAA;AAEnB,+CAA6B"}

### ANALISIS AUTOMATICO (ESPAÑOL) ###

{"version":3,"file":"index.js","sourceRoot":"","sources":["src/index.ts"],"names":[],"mappings":";AAAA;;GAEG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEH,kDAAgC;AAChC,wDAAwC;AACxC,yCAA2C;AAAlC,qGAAA,UAAU,OAAA;AAEnB,+CAA6B"}
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/internal-sdk/jsr.json
Tamaño: 651 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###



{
  "name": "@novu/api",
  "version": "0.1.21",
  "exports": {
    ".": "./src/index.ts",    
    "./models/errors": "./src/models/errors/index.ts",    
    "./models/components": "./src/models/components/index.ts",    
    "./models/operations": "./src/models/operations/index.ts",
    "./lib/config": "./src/lib/config.ts",
    "./lib/http": "./src/lib/http.ts",
    "./lib/retries": "./src/lib/retries.ts",
    "./lib/sdks": "./src/lib/sdks.ts",
    "./types": "./src/types/index.ts"
  },
  "publish": {
    "include": [
      "LICENSE",
      "README.md",
      "RUNTIMES.md",
      "USAGE.md",
      "jsr.json",
      "src/**/*.ts"
    ]
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"name": "@novu/api",
"version": "0.1.21",
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/internal-sdk/package.json
Tamaño: 854 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "name": "@novu/api",
  "version": "0.1.21",
  "author": "Novu",
  "main": "./index.js",
  "sideEffects": false,
  "scripts": {
    "lint": "eslint --cache --max-warnings=0 src",
    "build": "tsc",
    "prepublishOnly": "npm run build"
  },
  "peerDependencies": {
    "@tanstack/react-query": "^5",
    "react": "^18 || ^19",
    "react-dom": "^18 || ^19"
  },
  "peerDependenciesMeta": {
    "@tanstack/react-query": {
      "optional": true
    },
    "react": {
      "optional": true
    },
    "react-dom": {
      "optional": true
    }
  },
  "devDependencies": {
    "@eslint/js": "^9.19.0",
    "@tanstack/react-query": "^5.61.4",
    "@types/react": "^18.3.12",
    "eslint": "^9.19.0",
    "globals": "^15.14.0",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.26.0"
  },
  "dependencies": {
    "zod": "^3.25.0 || ^4.0.0"
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"name": "@novu/api",
"version": "0.1.21",
"author": "Novu",
"main": "./index.js",
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/internal-sdk/project.json
Tamaño: 1059 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "name": "@novu/api",
  "sourceRoot": "libs/internal-sdk/src",
  "projectType": "library",
  "targets": {
    "build": {
      "cache": true,
      "inputs": [
        "default",
        "{projectRoot}/src/**/*",
        "{projectRoot}/tsconfig.json",
        "{projectRoot}/package.json",
        "!{projectRoot}/**/?(*.)+(spec|test).[jt]s?(x)?(.snap)"
      ],
      "outputs": [
        "{projectRoot}/funcs",
        "{projectRoot}/hooks",
        "{projectRoot}/lib",
        "{projectRoot}/models",
        "{projectRoot}/react-query",
        "{projectRoot}/sdk",
        "{projectRoot}/types",
        "{projectRoot}/utils",
        "{projectRoot}/docs",
        "{projectRoot}/speakeasyusagegen",
        "{projectRoot}/index.js",
        "{projectRoot}/index.js.map",
        "{projectRoot}/index.d.ts",
        "{projectRoot}/index.d.ts.map",
        "{projectRoot}/core.js",
        "{projectRoot}/core.js.map",
        "{projectRoot}/core.d.ts",
        "{projectRoot}/core.d.ts.map",
        "{projectRoot}/.tsbuildinfo"
      ]
    }
  }
} 


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"name": "@novu/api",
"sourceRoot": "libs/internal-sdk/src",
"projectType": "library",
"targets": {
Menciona package.json.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/internal-sdk/tsconfig.json
Tamaño: 1099 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": ".tsbuildinfo",
    "target": "ES2020",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "jsx": "react-jsx",

    "module": "Node16",
    "moduleResolution": "Node16",

    "allowJs": true,

    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": ".",
    

    // https://github.com/tsconfig/bases/blob/a1bf7c0fa2e094b068ca3e1448ca2ece4157977e/bases/strictest.json
    "strict": true,
    "allowUnusedLabels": false,
    "allowUnreachableCode": false,
    "exactOptionalPropertyTypes": true,
    "useUnknownInCatchVariables": true,
    "noFallthroughCasesInSwitch": true,
    "noImplicitOverride": true,
    "noImplicitReturns": true,
    "noPropertyAccessFromIndexSignature": true,
    "noUncheckedIndexedAccess": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "isolatedModules": true,
    "checkJs": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src"],
  "exclude": ["node_modules"]
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"compilerOptions": {
"incremental": true,
"tsBuildInfoFile": ".tsbuildinfo",
"target": "ES2020",
// https://github.com/tsconfig/bases/blob/a1bf7c0fa2e094b068ca3e1448ca2ece4157977e/bases/strictest.json
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/internal-sdk/.speakeasy/gen.yaml
Tamaño: 1806 bytes
Lenguaje detectado: YAML

### CONTENIDO ORIGINAL ###

configVersion: 2.0.0
generation:
  sdkClassName: Novu
  maintainOpenAPIOrder: true
  usageSnippets:
    optionalPropertyRendering: withExample
    sdkInitStyle: constructor
  useClassNamesForArrayFields: true
  fixes:
    nameResolutionDec2023: true
    nameResolutionFeb2025: false
    parameterOrderingFeb2024: true
    requestResponseComponentNamesFeb2024: true
    securityFeb2025: false
    sharedErrorComponentsApr2025: false
  auth:
    oAuth2ClientCredentialsEnabled: false
    oAuth2PasswordEnabled: false
    hoistGlobalSecurity: true
  inferSSEOverload: true
  sdkHooksConfigAccess: true
  schemas:
    allOfMergeStrategy: shallowMerge
  tests:
    generateTests: true
    generateNewTests: false
    skipResponseBodyAssertions: false
typescript:
  version: 0.1.21
  acceptHeaderEnum: true
  additionalDependencies:
    dependencies: {}
    devDependencies: {}
    peerDependencies: {}
  additionalPackageJSON: {}
  author: Novu
  baseErrorName: NovuError
  clientServerStatusCodesAsErrors: true
  constFieldsAlwaysOptional: true
  defaultErrorName: SDKError
  enableCustomCodeRegions: false
  enableMCPServer: false
  enableReactQuery: true
  enumFormat: union
  flattenGlobalSecurity: true
  flatteningOrder: body-first
  generateExamples: true
  imports:
    option: openapi
    paths:
      callbacks: models/callbacks
      errors: models/errors
      operations: models/operations
      shared: models/components
      webhooks: models/webhooks
  inputModelSuffix: input
  jsonpath: rfc9535
  maxMethodParams: 3
  methodArguments: require-security-and-request
  modelPropertyCasing: camel
  moduleFormat: commonjs
  outputModelSuffix: output
  packageName: '@novu/api'
  responseFormat: flat
  sseFlatResponse: false
  templateVersion: v2
  usageSDKInitImports: []
  useIndexModules: true


### ANALISIS AUTOMATICO (ESPAÑOL) ###

configVersion: 2.0.0
generation:
sdkClassName: Novu
maintainOpenAPIOrder: true
usageSnippets:
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/internal-sdk/.speakeasy/speakeasy-modifications-overlay.yaml
Tamaño: 15793 bytes
Lenguaje detectado: YAML

### CONTENIDO ORIGINAL ###

overlay: 1.0.0
info:
  title: Speakeasy Modifications
  version: 0.0.6
  x-speakeasy-metadata:
    after: ""
    before: ""
    type: speakeasy-modifications
actions:
  - target: $["paths"]["/v1/subscribers/{subscriberId}/preferences"]["patch"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Subscribers.Preferences.updateGlobal()
      after: sdk.subscribersPreferences.updateGlobal()
      reviewed_at: 1732386050400
      created_at: 1732385969424
      disabled: true
  - target: $["paths"]["/v1/notification-groups/{id}"]["delete"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Workflow groups.NotificationGroupsController_deleteNotificationGroup()
      after: sdk.workflowGroups.delete()
      reviewed_at: 1732386050400
      created_at: 1732385969424
      disabled: true
  - target: $["paths"]["/v1/events/trigger/{transactionId}"]["delete"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Events.cancel()
      after: sdk.events.cancelByTransactionId()
      reviewed_at: 1732563929240
      created_at: 1732563888541
      disabled: true
  - target: $["paths"]["/v1/integrations/webhook/provider/{providerOrIntegrationId}/status"]["get"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Integrations.Webhooks.IntegrationsController_getWebhookSupportStatus()
      after: sdk.integrationsWebhooks.getStatus()
      reviewed_at: 1732386050400
      created_at: 1732385969424
      disabled: true
  - target: $["paths"]["/v1/subscribers/{subscriberId}/credentials/{providerId}/oauth"]["get"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Subscribers.Authentication.chatAccessOauth()
      after: sdk.subscribers.authentication.handleOauth()
      reviewed_at: 1732386050400
      created_at: 1732385969423
      disabled: true
  - target: $["paths"]["/v1/topics/{topicKey}/subscribers/{externalSubscriberId}"]["get"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Topics.Subscribers.TopicsController_getTopicSubscriber()
      after: sdk.topics.subscribers.check()
      reviewed_at: 1732386050400
      created_at: 1732385969424
      disabled: true
  - target: $["paths"]["/v1/topics/{topicKey}"]["delete"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Topics.TopicsController_deleteTopic()
      after: sdk.topics.delete()
      reviewed_at: 1732386050400
      created_at: 1732385969423
      disabled: true
  - target: $["paths"]["/v1/notifications/stats"]["get"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Notifications.Stats.NotificationsController_getActivityStats()
      after: sdk.notifications.stats.get()
      reviewed_at: 1732386050400
      created_at: 1732385969423
      disabled: true
  - target: $["paths"]["/v1/messages"]["get"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Messages.MessagesController_getMessages()
      after: sdk.messages.get()
      reviewed_at: 1732386050400
      created_at: 1732385969423
      disabled: true
  - target: $["paths"]["/v1/integrations"]["get"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Integrations.IntegrationsController_listIntegrations()
      after: sdk.integrations.list()
      reviewed_at: 1732386050400
      created_at: 1732385969423
      disabled: true
  - target: $["paths"]["/v1/subscribers/{subscriberId}/preferences/{parameter}"]["get"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Subscribers.Preferences.retrieveByLevel()
      after: sdk.subscribers.preferences.getByLevel()
      reviewed_at: 1732386050400
      created_at: 1732385969424
      disabled: true
  - target: $["paths"]["/v1/environments/me"]["get"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Environments.EnvironmentsControllerV1_getCurrentEnvironment()
      after: sdk.environments.getCurrent()
      reviewed_at: 1732386050400
      created_at: 1732385969424
      disabled: true
  - target: $["paths"]["/v1/subscribers/{subscriberId}/notifications/feed"]["get"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Subscribers.Notifications.SubscribersController_getNotificationsFeed()
      after: sdk.subscribers.notifications.getFeed()
      reviewed_at: 1732386050400
      created_at: 1732385969424
      disabled: true
  - target: $["paths"]["/v1/subscribers/{subscriberId}/preferences/{parameter}"]["patch"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Subscribers.Preferences.SubscribersController_updateSubscriberPreference()
      after: sdk.subscribers.preferences.update()
      reviewed_at: 1732386050400
      created_at: 1732385969423
      disabled: true
  - target: $["paths"]["/v1/notification-groups/{id}"]["get"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Workflow groups.NotificationGroupsController_getNotificationGroup()
      after: sdk.workflowGroups.get()
      reviewed_at: 1732386050400
      created_at: 1732385969424
      disabled: true
  - target: $["paths"]["/v1/subscribers/{subscriberId}/credentials"]["patch"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Subscribers.Credentials.append()
      after: sdk.subscribers.credentials.append()
      reviewed_at: 1732386050400
      created_at: 1732385969423
      disabled: true
  - target: $["paths"]["/v1/subscribers/{subscriberId}/preferences"]["get"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Subscribers.Preferences.SubscribersController_listSubscriberPreferences()
      after: sdk.subscribers.preferences.get()
      reviewed_at: 1732386050400
      created_at: 1732385969424
      disabled: true
  - target: $["paths"]["/v1/integrations/{integrationId}"]["put"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Integrations.IntegrationsController_updateIntegrationById()
      after: sdk.integrations.update()
      reviewed_at: 1732386050400
      created_at: 1732385969423
      disabled: true
  - target: $["paths"]["/v1/notification-groups/{id}"]["patch"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Workflow groups.NotificationGroupsController_updateNotificationGroup()
      after: sdk.workflowGroups.update()
      reviewed_at: 1732386050400
      created_at: 1732385969423
      disabled: true
  - target: $["paths"]["/v1/environments"]["get"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Environments.EnvironmentsControllerV1_listMyEnvironments()
      after: sdk.environments.getAll()
      reviewed_at: 1732386050400
      created_at: 1732385969423
      disabled: true
  - target: $["paths"]["/v1/notification-groups"]["post"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Workflow groups.NotificationGroupsController_createNotificationGroup()
      after: sdk.workflowGroups.create()
      reviewed_at: 1732386050400
      created_at: 1732385969423
      disabled: true
  - target: $["paths"]["/v1/subscribers/{subscriberId}/notifications/unseen"]["get"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Subscribers.Notifications.unseenCount()
      after: sdk.subscribersNotifications.getUnseenCount()
      reviewed_at: 1732386050400
      created_at: 1732385969423
      disabled: true
  - target: $["paths"]["/v1/subscribers/{subscriberId}/credentials"]["put"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Subscribers.Credentials.SubscribersController_updateSubscriberChannel()
      after: sdk.subscribers.credentials.update()
      reviewed_at: 1732386050400
      created_at: 1732385969424
      disabled: true
  - target: $["paths"]["/v1/subscribers/{subscriberId}/messages/mark-as"]["post"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Subscribers.Messages.markAllAs()
      after: sdk.subscribers.messages.mark()
      reviewed_at: 1732386050400
      created_at: 1732385969424
      disabled: true
  - target: $["paths"]["/v1/integrations/{integrationId}/set-primary"]["post"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Integrations.setAsPrimary()
      after: sdk.integrations.setPrimary()
      reviewed_at: 1732386050400
      created_at: 1732385969423
      disabled: true
  - target: $["paths"]["/v1/notifications"]["get"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Notifications.NotificationsController_listNotifications()
      after: sdk.notifications.list()
      reviewed_at: 1732386050400
      created_at: 1732385969423
      disabled: true
  - target: $["paths"]["/v1/notifications/graph/stats"]["get"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Notifications.Stats.graph()
      after: sdk.notificationsStats.get()
      reviewed_at: 1732386050400
      created_at: 1732385969423
      disabled: true
  - target: $["paths"]["/v1/notifications/{notificationId}"]["get"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Notifications.NotificationsController_getNotification()
      after: sdk.notifications.get()
      reviewed_at: 1732386050400
      created_at: 1732385969423
      disabled: true
  - target: $["paths"]["/v1/topics/{topicKey}/subscribers/removal"]["post"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Topics.Subscribers.TopicsController_removeSubscribers()
      after: sdk.topics.subscribers.remove()
      reviewed_at: 1732386050400
      created_at: 1732385969424
      disabled: true
  - target: $["paths"]["/v1/subscribers/{subscriberId}"]["get"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Subscribers.SubscribersController_getSubscriber()
      after: sdk.subscribers.get()
      reviewed_at: 1732386050400
      created_at: 1732385969423
      disabled: true
  - target: $["paths"]["/v1/topics/{topicKey}"]["get"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Topics.TopicsController_getTopic()
      after: sdk.topics.get()
      reviewed_at: 1732386050400
      created_at: 1732385969423
      disabled: true
  - target: $["paths"]["/v1/subscribers/{subscriberId}/credentials/{providerId}"]["delete"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Subscribers.Credentials.SubscribersController_deleteSubscriberCredentials()
      after: sdk.subscribers.credentials.delete()
      reviewed_at: 1732386050400
      created_at: 1732385969423
      disabled: true
  - target: $["paths"]["/v1/subscribers/{subscriberId}/credentials/{providerId}/oauth/callback"]["get"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Subscribers.Authentication.chatAccessOauthCallBack()
      after: sdk.subscribers.authentication.handleOauthCallback()
      reviewed_at: 1732386050400
      created_at: 1732385969423
      disabled: true
  - target: $["paths"]["/v1/subscribers"]["get"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Subscribers.SubscribersController_listSubscribers()
      after: sdk.subscribers.getAll()
      reviewed_at: 1732386050400
      created_at: 1732385969424
      disabled: true
  - target: $["paths"]["/v1/topics"]["get"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Topics.TopicsController_listTopics()
      after: sdk.topics.getAll()
      reviewed_at: 1732386050400
      created_at: 1732385969424
      disabled: true
  - target: $["paths"]["/v1/subscribers/{subscriberId}"]["put"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Subscribers.SubscribersController_updateSubscriber()
      after: sdk.subscribers.update()
      reviewed_at: 1732386050400
      created_at: 1732385969423
      disabled: true
  - target: $["paths"]["/v1/environments/api-keys"]["get"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Environments.ApiKeys.EnvironmentsControllerV1_listOrganizationApiKeys()
      after: sdk.environments.apiKeys.list()
      reviewed_at: 1732386050400
      created_at: 1732385969424
      disabled: true
  - target: $["paths"]["/v1/notification-groups"]["get"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Workflow groups.NotificationGroupsController_listNotificationGroups()
      after: sdk.workflowGroups.list()
      reviewed_at: 1732386050400
      created_at: 1732385969424
      disabled: true
  - target: $["paths"]["/v1/topics/{topicKey}/subscribers"]["post"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Topics.Subscribers.assign()
      after: sdk.topics.subscribers.add()
      reviewed_at: 1732386050400
      created_at: 1732385969423
      disabled: true
  - target: $["paths"]["/v1/messages/{messageId}"]["delete"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Messages.MessagesController_deleteMessage()
      after: sdk.messages.delete()
      reviewed_at: 1732386050400
      created_at: 1732385969423
      disabled: true
  - target: $["paths"]["/v1/subscribers/{subscriberId}/messages/mark-all"]["post"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Subscribers.Messages.markAll()
      after: sdk.subscribersMessages.markAll()
      reviewed_at: 1732386050400
      created_at: 1732385969424
      disabled: true
  - target: $["paths"]["/v1/topics"]["post"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Topics.TopicsController_createTopic()
      after: sdk.topics.create()
      reviewed_at: 1732386050400
      created_at: 1732385969423
      disabled: true
  - target: $["paths"]["/v1/execution-details"]["get"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Execution Details.ExecutionDetailsController_getExecutionDetailsForNotification()
      after: sdk.executionDetails.get()
      reviewed_at: 1732386050400
      created_at: 1732385969424
      disabled: true
  - target: $["paths"]["/v1/subscribers/{subscriberId}/online-status"]["patch"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Subscribers.properties.updateOnlineFlag()
      after: sdk.subscribers.properties.updateOnlineStatus()
      reviewed_at: 1732386050400
      created_at: 1732385969424
      disabled: true
  - target: $["paths"]["/v1/subscribers/{subscriberId}"]["delete"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Subscribers.SubscribersController_removeSubscriber()
      after: sdk.subscribers.delete()
      reviewed_at: 1732386050400
      created_at: 1732385969424
      disabled: true
  - target: $["paths"]["/v1/integrations"]["post"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Integrations.IntegrationsController_createIntegration()
      after: sdk.integrations.create()
      reviewed_at: 1732386050400
      created_at: 1732385969424
      disabled: true
  - target: $["paths"]["/v1/subscribers/{subscriberId}/messages/{messageId}/actions/{type}"]["post"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Subscribers.Messages.updateAsSeen()
      after: sdk.subscribersMessages.updateAsSeen()
      reviewed_at: 1732386050400
      created_at: 1732385969424
      disabled: true
  - target: $["paths"]["/v1/integrations/{integrationId}"]["delete"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Integrations.IntegrationsController_removeIntegration()
      after: sdk.integrations.delete()
      reviewed_at: 1732386050400
      created_at: 1732385969423
      disabled: true
  - target: $["paths"]["/v1/subscribers"]["post"]
    x-speakeasy-metadata:
      type: method-name
      before: sdk.Subscribers.SubscribersController_createSubscriber()
      after: sdk.subscribers.create()
      reviewed_at: 1732386050400
      created_at: 1732385969423
      disabled: true


### ANALISIS AUTOMATICO (ESPAÑOL) ###

overlay: 1.0.0
info:
title: Speakeasy Modifications
version: 0.0.6
x-speakeasy-metadata:
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/internal-sdk/.speakeasy/workflow.yaml
Tamaño: 665 bytes
Lenguaje detectado: YAML

### CONTENIDO ORIGINAL ###

workflowVersion: 1.0.0
speakeasyVersion: latest
sources:
    internal-sdk-OAS:
        inputs:
            - location: ../../apps/api/dist/swagger-spec.json
        overlays:
            - location: .speakeasy/speakeasy-modifications-overlay.yaml
        output: sources/json-development.json
        registry:
            location: registry.speakeasyapi.dev/novu/novu/json-development-internal
targets:
    internal-sdk:
        target: typescript
        source: internal-sdk-OAS
        codeSamples:
            registry:
                location: registry.speakeasyapi.dev/novu/novu/json-development-internal-typescript-code-samples
            blocking: false


### ANALISIS AUTOMATICO (ESPAÑOL) ###

workflowVersion: 1.0.0
speakeasyVersion: latest
sources:
internal-sdk-OAS:
inputs:
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/internal-sdk/examples/.env.template
Tamaño: 143 bytes
Lenguaje detectado: TEMPLATE

### CONTENIDO ORIGINAL ###

# @novu/api SDK Environment Variables
# Copy this file to .env and fill in your actual values
# DO NOT commit the .env file to version control


### ANALISIS AUTOMATICO (ESPAÑOL) ###

# @novu/api SDK Environment Variables
# Copy this file to .env and fill in your actual values
# DO NOT commit the .env file to version control
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/internal-sdk/examples/README.md
Tamaño: 539 bytes
Lenguaje detectado: Markdown

### CONTENIDO ORIGINAL ###

# @novu/api Examples

This directory contains example scripts demonstrating how to use the @novu/api SDK.

## Prerequisites

- Node.js (v18 or higher)
- npm

## Setup

1. Copy `.env.template` to `.env`:
   ```bash
   cp .env.template .env
   ```

2. Edit `.env` and add your actual credentials

## Running the Examples

To run an example file from the examples directory:

```bash
npm run build && npx tsx example.ts
```

## Creating new examples

Duplicate an existing example file, they won't be overwritten by the generation process.




### ANALISIS AUTOMATICO (ESPAÑOL) ###

# @novu/api Examples
This directory contains example scripts demonstrating how to use the @novu/api SDK.
## Prerequisites
## Setup
## Running the Examples
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/internal-sdk/examples/package.json
Tamaño: 407 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "name": "@novu/api-examples",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "build:parent": "cd .. && npm i && npm run build && cd -",
    "build:examples": "npm i",
    "build": "npm run build:parent && npm run build:examples"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "dotenv": "^16.4.5",
    "tsx": "^4.19.2"
  },
  "dependencies": {
    "@novu/api": "file:.."
  }
}

### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"name": "@novu/api-examples",
"version": "1.0.0",
"private": true,
"scripts": {
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/internal-sdk/examples/trigger.example.ts
Tamaño: 751 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import dotenv from "dotenv";
dotenv.config();
/**
 * Example usage of the @novu/api SDK
 *
 * To run this example from the examples directory:
 * npm run build && npx tsx trigger.example.ts
 */

import { Novu } from "@novu/api";

const novu = new Novu({
  security: {
    secretKey: "YOUR_SECRET_KEY_HERE",
  },
});

async function main() {
  const result = await novu.trigger({
    workflowId: "workflow_identifier",
    payload: {
      "comment_id": "string",
      "post": {
        "text": "string",
      },
    },
    overrides: {},
    to: "SUBSCRIBER_ID",
    context: {
      "key": "org-acme",
    },
  });

  console.log(result);
}

main().catch(console.error);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - main()

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/sources/temp.json
Tamaño: 0 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###



### ANALISIS AUTOMATICO (ESPAÑOL) ###

Sin cabecera detectada en las primeras líneas.
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/libs/internal-sdk/src/core.ts
Tamaño: 461 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { ClientSDK } from "./lib/sdks.js";

/**
 * A minimal client to use when calling standalone SDK functions. Typically, an
 * instance of this class would be instantiated once at the start of an
 * application and passed around through some dependency injection mechanism  to
 * parts of an application that need to make SDK calls.
 */
export class NovuCore extends ClientSDK {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class NovuCore

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/index.ts
Tamaño: 290 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

export * from "./lib/config.js";
export * as files from "./lib/files.js";
export { HTTPClient } from "./lib/http.js";
export type { Fetcher, HTTPClientOptions } from "./lib/http.js";
export * from "./sdk/sdk.js";


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export  type
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/activityChartsRetrieve.ts
Tamaño: 5257 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeFormQuery, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Retrieve activity charts
 *
 * @remarks
 * Retrieve chart data for activity analytics and metrics visualization.
 */
export function activityChartsRetrieve(
  client: NovuCore,
  request: operations.ActivityControllerGetChartsRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    components.GetChartsResponseDto,
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: NovuCore,
  request: operations.ActivityControllerGetChartsRequest,
  options?: RequestOptions,
): Promise<
  [
    Result<
      components.GetChartsResponseDto,
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) =>
      operations.ActivityControllerGetChartsRequest$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const path = pathToFunc("/v1/activity/charts")();

  const query = encodeFormQuery({
    "channels": payload.channels,
    "createdAtGte": payload.createdAtGte,
    "createdAtLte": payload.createdAtLte,
    "reportType": payload.reportType,
    "statuses": payload.statuses,
    "subscriberIds": payload.subscriberIds,
    "topicKey": payload.topicKey,
    "transactionIds": payload.transactionIds,
    "workflowIds": payload.workflowIds,
  });

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "ActivityController_getCharts",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    query: query,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const [result] = await M.match<
    components.GetChartsResponseDto,
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, components.GetChartsResponseDto$inboundSchema),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - activityChartsRetrieve(client: NovuCore,
  request: operations.ActivityControllerGetChartsRequest,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  request: operations.ActivityControllerGetChartsRequest,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    request,
    (value))
Declaraciones 'export' encontradas:
- export function activityChartsRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/activityRequestsList.ts
Tamaño: 5122 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeFormQuery, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * List activity requests
 *
 * @remarks
 * Retrieve a list of activity requests with optional filtering and pagination.
 */
export function activityRequestsList(
  client: NovuCore,
  request: operations.ActivityControllerGetLogsRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    components.GetRequestsResponseDto,
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: NovuCore,
  request: operations.ActivityControllerGetLogsRequest,
  options?: RequestOptions,
): Promise<
  [
    Result<
      components.GetRequestsResponseDto,
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) =>
      operations.ActivityControllerGetLogsRequest$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const path = pathToFunc("/v1/activity/requests")();

  const query = encodeFormQuery({
    "createdGte": payload.createdGte,
    "limit": payload.limit,
    "page": payload.page,
    "statusCodes": payload.statusCodes,
    "transactionId": payload.transactionId,
    "urlPattern": payload.urlPattern,
  });

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "ActivityController_getLogs",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    query: query,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const [result] = await M.match<
    components.GetRequestsResponseDto,
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, components.GetRequestsResponseDto$inboundSchema),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - activityRequestsList(client: NovuCore,
  request: operations.ActivityControllerGetLogsRequest,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  request: operations.ActivityControllerGetLogsRequest,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    request,
    (value))
Declaraciones 'export' encontradas:
- export function activityRequestsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/activityRequestsRetrieve.ts
Tamaño: 5215 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Retrieve activity request
 *
 * @remarks
 * Retrieve detailed traces and information for a specific activity request by ID.
 */
export function activityRequestsRetrieve(
  client: NovuCore,
  requestId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    components.GetRequestResponseDto,
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    requestId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  requestId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      components.GetRequestResponseDto,
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.ActivityControllerGetRequestTracesRequest = {
    requestId: requestId,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.ActivityControllerGetRequestTracesRequest$outboundSchema.parse(
        value,
      ),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    requestId: encodeSimple("requestId", payload.requestId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v1/activity/requests/{requestId}")(pathParams);

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "ActivityController_getRequestTraces",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const [result] = await M.match<
    components.GetRequestResponseDto,
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, components.GetRequestResponseDto$inboundSchema),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - activityRequestsRetrieve(client: NovuCore,
  requestId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  requestId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function activityRequestsRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/activityTrack.ts
Tamaño: 5394 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { NovuCore } from '../core.js';
import { encodeJSON, encodeSimple } from '../lib/encodings.js';
import * as M from '../lib/matchers.js';
import { compactMap } from '../lib/primitives.js';
import { safeParse } from '../lib/schemas.js';
import { RequestOptions } from '../lib/sdks.js';
import { extractSecurity, resolveGlobalSecurity } from '../lib/security.js';
import { pathToFunc } from '../lib/url.js';
import * as components from '../models/components/index.js';
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from '../models/errors/httpclienterrors.js';
import { NovuError } from '../models/errors/novuerror.js';
import { ResponseValidationError } from '../models/errors/responsevalidationerror.js';
import { SDKValidationError } from '../models/errors/sdkvalidationerror.js';
import * as operations from '../models/operations/index.js';
import { APICall, APIPromise } from '../types/async.js';
import { Result } from '../types/fp.js';

/**
 * Track activity and engagement events
 *
 * @remarks
 * Track activity and engagement events for a specific delivery provider
 */
export function activityTrack(
  client: NovuCore,
  request: operations.InboundWebhooksControllerHandleWebhookRequest,
  options?: RequestOptions
): APIPromise<
  Result<
    Array<components.WebhookResultDto>,
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(client, request, options));
}

async function $do(
  client: NovuCore,
  request: operations.InboundWebhooksControllerHandleWebhookRequest,
  options?: RequestOptions
): Promise<
  [
    Result<
      Array<components.WebhookResultDto>,
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) => operations.InboundWebhooksControllerHandleWebhookRequest$outboundSchema.parse(value),
    'Input validation failed'
  );
  if (!parsed.ok) {
    return [parsed, { status: 'invalid' }];
  }
  const payload = parsed.value;
  const body = encodeJSON('body', payload.RequestBody, { explode: true });

  const pathParams = {
    environmentId: encodeSimple('environmentId', payload.environmentId, {
      explode: false,
      charEncoding: 'percent',
    }),
    integrationId: encodeSimple('integrationId', payload.integrationId, {
      explode: false,
      charEncoding: 'percent',
    }),
  };

  const path = pathToFunc('/v2/inbound-webhooks/delivery-providers/{environmentId}/{integrationId}')(pathParams);

  const headers = new Headers(
    compactMap({
      'Content-Type': 'application/json',
      Accept: 'application/json',
      'idempotency-key': encodeSimple('idempotency-key', payload['idempotency-key'], {
        explode: false,
        charEncoding: 'none',
      }),
    })
  );

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? '',
    operationID: 'InboundWebhooksController_handleWebhook',
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries ||
      client._options.retryConfig || {
        strategy: 'backoff',
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      } || { strategy: 'none' },
    retryCodes: options?.retryCodes || ['408', '409', '429', '5XX'],
  };

  const requestRes = client._createRequest(
    context,
    {
      security: requestSecurity,
      method: 'POST',
      baseURL: options?.serverURL,
      path: path,
      headers: headers,
      body: body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
    },
    options
  );
  if (!requestRes.ok) {
    return [requestRes, { status: 'invalid' }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: ['4XX', '5XX'],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: 'request-error', request: req }];
  }
  const response = doResult.value;

  const [result] = await M.match<
    Array<components.WebhookResultDto>,
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, z.array(components.WebhookResultDto$inboundSchema)),
    M.fail('4XX'),
    M.fail('5XX')
  )(response, req);
  if (!result.ok) {
    return [result, { status: 'complete', request: req, response }];
  }

  return [result, { status: 'complete', request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - activityTrack(client: NovuCore,
  request: operations.InboundWebhooksControllerHandleWebhookRequest,
  options?: RequestOptions)
 - $do(client: NovuCore,
  request: operations.InboundWebhooksControllerHandleWebhookRequest,
  options?: RequestOptions)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    request,
    (value))
Declaraciones 'export' encontradas:
- export function activityTrack

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/activityWorkflowRunsList.ts
Tamaño: 5414 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeFormQuery, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * List workflow runs
 *
 * @remarks
 * Retrieve a list of workflow runs with optional filtering and pagination.
 */
export function activityWorkflowRunsList(
  client: NovuCore,
  request: operations.ActivityControllerGetWorkflowRunsRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    components.GetWorkflowRunsResponseDto,
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: NovuCore,
  request: operations.ActivityControllerGetWorkflowRunsRequest,
  options?: RequestOptions,
): Promise<
  [
    Result<
      components.GetWorkflowRunsResponseDto,
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) =>
      operations.ActivityControllerGetWorkflowRunsRequest$outboundSchema.parse(
        value,
      ),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const path = pathToFunc("/v1/activity/workflow-runs")();

  const query = encodeFormQuery({
    "channels": payload.channels,
    "contextKeys": payload.contextKeys,
    "createdGte": payload.createdGte,
    "createdLte": payload.createdLte,
    "cursor": payload.cursor,
    "limit": payload.limit,
    "severity": payload.severity,
    "statuses": payload.statuses,
    "subscriberIds": payload.subscriberIds,
    "topicKey": payload.topicKey,
    "transactionIds": payload.transactionIds,
    "workflowIds": payload.workflowIds,
  });

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "ActivityController_getWorkflowRuns",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    query: query,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const [result] = await M.match<
    components.GetWorkflowRunsResponseDto,
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, components.GetWorkflowRunsResponseDto$inboundSchema),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - activityWorkflowRunsList(client: NovuCore,
  request: operations.ActivityControllerGetWorkflowRunsRequest,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  request: operations.ActivityControllerGetWorkflowRunsRequest,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    request,
    (value))
Declaraciones 'export' encontradas:
- export function activityWorkflowRunsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/activityWorkflowRunsRetrieve.ts
Tamaño: 5260 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Retrieve workflow run
 *
 * @remarks
 * Retrieve detailed information for a specific workflow run by ID.
 */
export function activityWorkflowRunsRetrieve(
  client: NovuCore,
  workflowRunId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    components.GetWorkflowRunResponseDto,
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    workflowRunId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  workflowRunId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      components.GetWorkflowRunResponseDto,
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.ActivityControllerGetWorkflowRunRequest = {
    workflowRunId: workflowRunId,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.ActivityControllerGetWorkflowRunRequest$outboundSchema.parse(
        value,
      ),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    workflowRunId: encodeSimple("workflowRunId", payload.workflowRunId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v1/activity/workflow-runs/{workflowRunId}")(
    pathParams,
  );

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "ActivityController_getWorkflowRun",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const [result] = await M.match<
    components.GetWorkflowRunResponseDto,
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, components.GetWorkflowRunResponseDto$inboundSchema),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - activityWorkflowRunsRetrieve(client: NovuCore,
  workflowRunId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  workflowRunId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function activityWorkflowRunsRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/cancel.ts
Tamaño: 6187 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Cancel triggered event
 *
 * @remarks
 *
 *     Using a previously generated transactionId during the event trigger,
 *      will cancel any active or pending workflows. This is useful to cancel active digests, delays etc...
 */
export function cancel(
  client: NovuCore,
  transactionId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.EventsControllerCancelResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    transactionId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  transactionId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.EventsControllerCancelResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.EventsControllerCancelRequest = {
    transactionId: transactionId,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.EventsControllerCancelRequest$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    transactionId: encodeSimple("transactionId", payload.transactionId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v1/events/trigger/{transactionId}")(pathParams);

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "EventsController_cancel",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.EventsControllerCancelResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, operations.EventsControllerCancelResponse$inboundSchema, {
      hdrs: true,
      key: "Result",
    }),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - cancel(client: NovuCore,
  transactionId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  transactionId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function cancel

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/contextsCreate.ts
Tamaño: 6284 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Create context
 *
 * @remarks
 * Create a new context with the specified type, id, and data. Returns 409 if context already exists.
 */
export function contextsCreate(
  client: NovuCore,
  createContextRequestDto: components.CreateContextRequestDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.ContextsControllerCreateContextResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    createContextRequestDto,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  createContextRequestDto: components.CreateContextRequestDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.ContextsControllerCreateContextResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.ContextsControllerCreateContextRequest = {
    createContextRequestDto: createContextRequestDto,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.ContextsControllerCreateContextRequest$outboundSchema.parse(
        value,
      ),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.CreateContextRequestDto, {
    explode: true,
  });

  const path = pathToFunc("/v2/contexts")();

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "ContextsController_createContext",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.ContextsControllerCreateContextResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      201,
      operations.ContextsControllerCreateContextResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - contextsCreate(client: NovuCore,
  createContextRequestDto: components.CreateContextRequestDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  createContextRequestDto: components.CreateContextRequestDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function contextsCreate

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/contextsDelete.ts
Tamaño: 6213 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Delete context
 *
 * @remarks
 * Delete a context by its type and id
 */
export function contextsDelete(
  client: NovuCore,
  type: string,
  id: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.ContextsControllerDeleteContextResponse | undefined,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    type,
    id,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  type: string,
  id: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.ContextsControllerDeleteContextResponse | undefined,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.ContextsControllerDeleteContextRequest = {
    type: type,
    id: id,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.ContextsControllerDeleteContextRequest$outboundSchema.parse(
        value,
      ),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent",
    }),
    type: encodeSimple("type", payload.type, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v2/contexts/{type}/{id}")(pathParams);

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "ContextsController_deleteContext",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.ContextsControllerDeleteContextResponse | undefined,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.nil(
      204,
      operations.ContextsControllerDeleteContextResponse$inboundSchema
        .optional(),
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - contextsDelete(client: NovuCore,
  type: string,
  id: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  type: string,
  id: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function contextsDelete

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/contextsList.ts
Tamaño: 6153 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeFormQuery, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * List contexts
 *
 * @remarks
 * Retrieve a paginated list of contexts, optionally filtered by type and key pattern
 */
export function contextsList(
  client: NovuCore,
  request: operations.ContextsControllerListContextsRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.ContextsControllerListContextsResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: NovuCore,
  request: operations.ContextsControllerListContextsRequest,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.ContextsControllerListContextsResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) =>
      operations.ContextsControllerListContextsRequest$outboundSchema.parse(
        value,
      ),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const path = pathToFunc("/v2/contexts")();

  const query = encodeFormQuery({
    "after": payload.after,
    "before": payload.before,
    "id": payload.id,
    "includeCursor": payload.includeCursor,
    "limit": payload.limit,
    "orderBy": payload.orderBy,
    "orderDirection": payload.orderDirection,
    "search": payload.search,
    "type": payload.type,
  });

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "ContextsController_listContexts",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    query: query,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.ContextsControllerListContextsResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations.ContextsControllerListContextsResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - contextsList(client: NovuCore,
  request: operations.ContextsControllerListContextsRequest,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  request: operations.ContextsControllerListContextsRequest,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    request,
    (value))
Declaraciones 'export' encontradas:
- export function contextsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/contextsRetrieve.ts
Tamaño: 6179 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Get context by id
 *
 * @remarks
 * Retrieve a specific context by its type and id
 */
export function contextsRetrieve(
  client: NovuCore,
  type: string,
  id: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.ContextsControllerGetContextResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    type,
    id,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  type: string,
  id: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.ContextsControllerGetContextResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.ContextsControllerGetContextRequest = {
    type: type,
    id: id,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.ContextsControllerGetContextRequest$outboundSchema.parse(
        value,
      ),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent",
    }),
    type: encodeSimple("type", payload.type, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v2/contexts/{type}/{id}")(pathParams);

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "ContextsController_getContext",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.ContextsControllerGetContextResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, operations.ContextsControllerGetContextResponse$inboundSchema, {
      hdrs: true,
      key: "Result",
    }),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - contextsRetrieve(client: NovuCore,
  type: string,
  id: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  type: string,
  id: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function contextsRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/contextsUpdate.ts
Tamaño: 6191 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Update context data
 *
 * @remarks
 * Update the data of an existing context. Returns 404 if context does not exist.
 */
export function contextsUpdate(
  client: NovuCore,
  request: operations.ContextsControllerUpdateContextRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.ContextsControllerUpdateContextResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: NovuCore,
  request: operations.ContextsControllerUpdateContextRequest,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.ContextsControllerUpdateContextResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) =>
      operations.ContextsControllerUpdateContextRequest$outboundSchema.parse(
        value,
      ),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.UpdateContextRequestDto, {
    explode: true,
  });

  const pathParams = {
    id: encodeSimple("id", payload.id, {
      explode: false,
      charEncoding: "percent",
    }),
    type: encodeSimple("type", payload.type, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v2/contexts/{type}/{id}")(pathParams);

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "ContextsController_updateContext",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.ContextsControllerUpdateContextResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations.ContextsControllerUpdateContextResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - contextsUpdate(client: NovuCore,
  request: operations.ContextsControllerUpdateContextRequest,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  request: operations.ContextsControllerUpdateContextRequest,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    request,
    (value))
Declaraciones 'export' encontradas:
- export function contextsUpdate

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/environmentsCreate.ts
Tamaño: 6554 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Create an environment
 *
 * @remarks
 * Creates a new environment within the current organization.
 *     Environments allow you to manage different stages of your application development lifecycle.
 *     Each environment has its own set of API keys and configurations.
 */
export function environmentsCreate(
  client: NovuCore,
  createEnvironmentRequestDto: components.CreateEnvironmentRequestDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.EnvironmentsControllerV1CreateEnvironmentResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    createEnvironmentRequestDto,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  createEnvironmentRequestDto: components.CreateEnvironmentRequestDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.EnvironmentsControllerV1CreateEnvironmentResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.EnvironmentsControllerV1CreateEnvironmentRequest = {
    createEnvironmentRequestDto: createEnvironmentRequestDto,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.EnvironmentsControllerV1CreateEnvironmentRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.CreateEnvironmentRequestDto, {
    explode: true,
  });

  const path = pathToFunc("/v1/environments")();

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "EnvironmentsControllerV1_createEnvironment",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "402",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.EnvironmentsControllerV1CreateEnvironmentResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      201,
      operations
        .EnvironmentsControllerV1CreateEnvironmentResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr([402, 414], errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - environmentsCreate(client: NovuCore,
  createEnvironmentRequestDto: components.CreateEnvironmentRequestDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  createEnvironmentRequestDto: components.CreateEnvironmentRequestDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function environmentsCreate

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/environmentsDelete.ts
Tamaño: 6342 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Delete an environment
 *
 * @remarks
 * Delete an environment by its unique identifier **environmentId**.
 *     This action is irreversible and will remove the environment and all its associated data.
 */
export function environmentsDelete(
  client: NovuCore,
  environmentId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.EnvironmentsControllerV1DeleteEnvironmentResponse | undefined,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    environmentId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  environmentId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.EnvironmentsControllerV1DeleteEnvironmentResponse | undefined,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.EnvironmentsControllerV1DeleteEnvironmentRequest = {
    environmentId: environmentId,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.EnvironmentsControllerV1DeleteEnvironmentRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    environmentId: encodeSimple("environmentId", payload.environmentId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v1/environments/{environmentId}")(pathParams);

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "EnvironmentsControllerV1_deleteEnvironment",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.EnvironmentsControllerV1DeleteEnvironmentResponse | undefined,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.nil(
      200,
      operations.EnvironmentsControllerV1DeleteEnvironmentResponse$inboundSchema
        .optional(),
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - environmentsDelete(client: NovuCore,
  environmentId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  environmentId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function environmentsDelete

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/environmentsGetTags.ts
Tamaño: 6282 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Get environment tags
 *
 * @remarks
 * Retrieve all unique tags used in workflows within the specified environment. These tags can be used for filtering workflows.
 */
export function environmentsGetTags(
  client: NovuCore,
  environmentId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.EnvironmentsControllerGetEnvironmentTagsResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    environmentId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  environmentId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.EnvironmentsControllerGetEnvironmentTagsResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.EnvironmentsControllerGetEnvironmentTagsRequest = {
    environmentId: environmentId,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.EnvironmentsControllerGetEnvironmentTagsRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    environmentId: encodeSimple("environmentId", payload.environmentId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v2/environments/{environmentId}/tags")(pathParams);

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "EnvironmentsController_getEnvironmentTags",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.EnvironmentsControllerGetEnvironmentTagsResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations.EnvironmentsControllerGetEnvironmentTagsResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - environmentsGetTags(client: NovuCore,
  environmentId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  environmentId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function environmentsGetTags

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/environmentsList.ts
Tamaño: 6068 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * List all environments
 *
 * @remarks
 * This API returns a list of environments for the current organization.
 *     Each environment contains its configuration, API keys (if user has access), and metadata.
 */
export function environmentsList(
  client: NovuCore,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.EnvironmentsControllerV1ListMyEnvironmentsResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.EnvironmentsControllerV1ListMyEnvironmentsResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.EnvironmentsControllerV1ListMyEnvironmentsRequest = {
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations
        .EnvironmentsControllerV1ListMyEnvironmentsRequest$outboundSchema.parse(
          value,
        ),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const path = pathToFunc("/v1/environments")();

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "EnvironmentsControllerV1_listMyEnvironments",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.EnvironmentsControllerV1ListMyEnvironmentsResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations
        .EnvironmentsControllerV1ListMyEnvironmentsResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - environmentsList(client: NovuCore,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function environmentsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/environmentsUpdate.ts
Tamaño: 6781 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Update an environment
 *
 * @remarks
 * Update an environment by its unique identifier **environmentId**.
 *     You can modify the environment name, identifier, color, and other configuration settings.
 */
export function environmentsUpdate(
  client: NovuCore,
  updateEnvironmentRequestDto: components.UpdateEnvironmentRequestDto,
  environmentId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.EnvironmentsControllerV1UpdateMyEnvironmentResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    updateEnvironmentRequestDto,
    environmentId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  updateEnvironmentRequestDto: components.UpdateEnvironmentRequestDto,
  environmentId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.EnvironmentsControllerV1UpdateMyEnvironmentResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.EnvironmentsControllerV1UpdateMyEnvironmentRequest = {
    updateEnvironmentRequestDto: updateEnvironmentRequestDto,
    environmentId: environmentId,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations
        .EnvironmentsControllerV1UpdateMyEnvironmentRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.UpdateEnvironmentRequestDto, {
    explode: true,
  });

  const pathParams = {
    environmentId: encodeSimple("environmentId", payload.environmentId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v1/environments/{environmentId}")(pathParams);

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "EnvironmentsControllerV1_updateMyEnvironment",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PUT",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.EnvironmentsControllerV1UpdateMyEnvironmentResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations
        .EnvironmentsControllerV1UpdateMyEnvironmentResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - environmentsUpdate(client: NovuCore,
  updateEnvironmentRequestDto: components.UpdateEnvironmentRequestDto,
  environmentId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  updateEnvironmentRequestDto: components.UpdateEnvironmentRequestDto,
  environmentId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function environmentsUpdate

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/integrationsCreate.ts
Tamaño: 6477 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Create an integration
 *
 * @remarks
 * Create an integration for the current environment the user is based on the API key provided.
 *     Each provider supports different credentials, check the provider documentation for more details.
 */
export function integrationsCreate(
  client: NovuCore,
  createIntegrationRequestDto: components.CreateIntegrationRequestDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.IntegrationsControllerCreateIntegrationResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    createIntegrationRequestDto,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  createIntegrationRequestDto: components.CreateIntegrationRequestDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.IntegrationsControllerCreateIntegrationResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.IntegrationsControllerCreateIntegrationRequest = {
    createIntegrationRequestDto: createIntegrationRequestDto,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.IntegrationsControllerCreateIntegrationRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.CreateIntegrationRequestDto, {
    explode: true,
  });

  const path = pathToFunc("/v1/integrations")();

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "IntegrationsController_createIntegration",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.IntegrationsControllerCreateIntegrationResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      201,
      operations.IntegrationsControllerCreateIntegrationResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - integrationsCreate(client: NovuCore,
  createIntegrationRequestDto: components.CreateIntegrationRequestDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  createIntegrationRequestDto: components.CreateIntegrationRequestDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function integrationsCreate

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/integrationsDelete.ts
Tamaño: 6254 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Delete an integration
 *
 * @remarks
 * Delete an integration by its unique key identifier **integrationId**.
 *     This action is irreversible.
 */
export function integrationsDelete(
  client: NovuCore,
  integrationId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.IntegrationsControllerRemoveIntegrationResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    integrationId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  integrationId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.IntegrationsControllerRemoveIntegrationResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.IntegrationsControllerRemoveIntegrationRequest = {
    integrationId: integrationId,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.IntegrationsControllerRemoveIntegrationRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    integrationId: encodeSimple("integrationId", payload.integrationId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v1/integrations/{integrationId}")(pathParams);

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "IntegrationsController_removeIntegration",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.IntegrationsControllerRemoveIntegrationResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations.IntegrationsControllerRemoveIntegrationResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - integrationsDelete(client: NovuCore,
  integrationId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  integrationId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function integrationsDelete

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/integrationsIntegrationsControllerAutoConfigureIntegration.ts
Tamaño: 6527 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Auto-configure an integration for inbound webhooks
 *
 * @remarks
 * Auto-configure an integration by its unique key identifier **integrationId** for inbound webhook support.
 *     This will automatically generate required webhook signing keys and configure webhook endpoints.
 */
export function integrationsIntegrationsControllerAutoConfigureIntegration(
  client: NovuCore,
  integrationId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.IntegrationsControllerAutoConfigureIntegrationResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    integrationId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  integrationId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.IntegrationsControllerAutoConfigureIntegrationResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input:
    operations.IntegrationsControllerAutoConfigureIntegrationRequest = {
      integrationId: integrationId,
      idempotencyKey: idempotencyKey,
    };

  const parsed = safeParse(
    input,
    (value) =>
      operations
        .IntegrationsControllerAutoConfigureIntegrationRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    integrationId: encodeSimple("integrationId", payload.integrationId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v1/integrations/{integrationId}/auto-configure")(
    pathParams,
  );

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "IntegrationsController_autoConfigureIntegration",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.IntegrationsControllerAutoConfigureIntegrationResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations
        .IntegrationsControllerAutoConfigureIntegrationResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail([404, 429]),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - integrationsIntegrationsControllerAutoConfigureIntegration(client: NovuCore,
  integrationId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  integrationId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function integrationsIntegrationsControllerAutoConfigureIntegration

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/integrationsList.ts
Tamaño: 5906 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * List all integrations
 *
 * @remarks
 * List all the channels integrations created in the organization
 */
export function integrationsList(
  client: NovuCore,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.IntegrationsControllerListIntegrationsResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.IntegrationsControllerListIntegrationsResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.IntegrationsControllerListIntegrationsRequest = {
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.IntegrationsControllerListIntegrationsRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const path = pathToFunc("/v1/integrations")();

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "IntegrationsController_listIntegrations",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.IntegrationsControllerListIntegrationsResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations.IntegrationsControllerListIntegrationsResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - integrationsList(client: NovuCore,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function integrationsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/integrationsListActive.ts
Tamaño: 5973 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * List active integrations
 *
 * @remarks
 * List all the active integrations created in the organization
 */
export function integrationsListActive(
  client: NovuCore,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.IntegrationsControllerGetActiveIntegrationsResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.IntegrationsControllerGetActiveIntegrationsResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.IntegrationsControllerGetActiveIntegrationsRequest = {
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations
        .IntegrationsControllerGetActiveIntegrationsRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const path = pathToFunc("/v1/integrations/active")();

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "IntegrationsController_getActiveIntegrations",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.IntegrationsControllerGetActiveIntegrationsResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations
        .IntegrationsControllerGetActiveIntegrationsResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - integrationsListActive(client: NovuCore,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function integrationsListActive

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/integrationsSetAsPrimary.ts
Tamaño: 6538 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Update integration as primary
 *
 * @remarks
 * Update an integration as **primary** by its unique key identifier **integrationId**.
 *     This API will set the integration as primary for that channel in the current environment.
 *     Primary integration is used to deliver notification for sms and email channels in the workflow.
 */
export function integrationsSetAsPrimary(
  client: NovuCore,
  integrationId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.IntegrationsControllerSetIntegrationAsPrimaryResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    integrationId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  integrationId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.IntegrationsControllerSetIntegrationAsPrimaryResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.IntegrationsControllerSetIntegrationAsPrimaryRequest =
    {
      integrationId: integrationId,
      idempotencyKey: idempotencyKey,
    };

  const parsed = safeParse(
    input,
    (value) =>
      operations
        .IntegrationsControllerSetIntegrationAsPrimaryRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    integrationId: encodeSimple("integrationId", payload.integrationId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v1/integrations/{integrationId}/set-primary")(
    pathParams,
  );

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "IntegrationsController_setIntegrationAsPrimary",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.IntegrationsControllerSetIntegrationAsPrimaryResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations
        .IntegrationsControllerSetIntegrationAsPrimaryResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail([404, 429]),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - integrationsSetAsPrimary(client: NovuCore,
  integrationId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  integrationId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function integrationsSetAsPrimary

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/integrationsUpdate.ts
Tamaño: 6794 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Update an integration
 *
 * @remarks
 * Update an integration by its unique key identifier **integrationId**.
 *     Each provider supports different credentials, check the provider documentation for more details.
 */
export function integrationsUpdate(
  client: NovuCore,
  updateIntegrationRequestDto: components.UpdateIntegrationRequestDto,
  integrationId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.IntegrationsControllerUpdateIntegrationByIdResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    updateIntegrationRequestDto,
    integrationId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  updateIntegrationRequestDto: components.UpdateIntegrationRequestDto,
  integrationId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.IntegrationsControllerUpdateIntegrationByIdResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.IntegrationsControllerUpdateIntegrationByIdRequest = {
    updateIntegrationRequestDto: updateIntegrationRequestDto,
    integrationId: integrationId,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations
        .IntegrationsControllerUpdateIntegrationByIdRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.UpdateIntegrationRequestDto, {
    explode: true,
  });

  const pathParams = {
    integrationId: encodeSimple("integrationId", payload.integrationId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v1/integrations/{integrationId}")(pathParams);

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "IntegrationsController_updateIntegrationById",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PUT",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.IntegrationsControllerUpdateIntegrationByIdResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations
        .IntegrationsControllerUpdateIntegrationByIdResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail([404, 429]),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - integrationsUpdate(client: NovuCore,
  updateIntegrationRequestDto: components.UpdateIntegrationRequestDto,
  integrationId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  updateIntegrationRequestDto: components.UpdateIntegrationRequestDto,
  integrationId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function integrationsUpdate

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/layoutsCreate.ts
Tamaño: 6083 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Create a layout
 *
 * @remarks
 * Creates a new layout in the Novu Cloud environment
 */
export function layoutsCreate(
  client: NovuCore,
  createLayoutDto: components.CreateLayoutDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.LayoutsControllerCreateResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    createLayoutDto,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  createLayoutDto: components.CreateLayoutDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.LayoutsControllerCreateResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.LayoutsControllerCreateRequest = {
    createLayoutDto: createLayoutDto,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.LayoutsControllerCreateRequest$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.CreateLayoutDto, { explode: true });

  const path = pathToFunc("/v2/layouts")();

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "LayoutsController_create",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.LayoutsControllerCreateResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(201, operations.LayoutsControllerCreateResponse$inboundSchema, {
      hdrs: true,
      key: "Result",
    }),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - layoutsCreate(client: NovuCore,
  createLayoutDto: components.CreateLayoutDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  createLayoutDto: components.CreateLayoutDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function layoutsCreate

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/layoutsDelete.ts
Tamaño: 6039 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Delete a layout
 *
 * @remarks
 * Removes a specific layout by its unique identifier **layoutId**
 */
export function layoutsDelete(
  client: NovuCore,
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.LayoutsControllerDeleteResponse | undefined,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    layoutId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.LayoutsControllerDeleteResponse | undefined,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.LayoutsControllerDeleteRequest = {
    layoutId: layoutId,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.LayoutsControllerDeleteRequest$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    layoutId: encodeSimple("layoutId", payload.layoutId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v2/layouts/{layoutId}")(pathParams);

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "LayoutsController_delete",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.LayoutsControllerDeleteResponse | undefined,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.nil(
      204,
      operations.LayoutsControllerDeleteResponse$inboundSchema.optional(),
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - layoutsDelete(client: NovuCore,
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function layoutsDelete

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/layoutsDuplicate.ts
Tamaño: 6478 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Duplicate a layout
 *
 * @remarks
 * Duplicates a layout by its unique identifier **layoutId**. This will create a new layout with the content of the original layout.
 */
export function layoutsDuplicate(
  client: NovuCore,
  duplicateLayoutDto: components.DuplicateLayoutDto,
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.LayoutsControllerDuplicateResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    duplicateLayoutDto,
    layoutId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  duplicateLayoutDto: components.DuplicateLayoutDto,
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.LayoutsControllerDuplicateResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.LayoutsControllerDuplicateRequest = {
    duplicateLayoutDto: duplicateLayoutDto,
    layoutId: layoutId,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.LayoutsControllerDuplicateRequest$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.DuplicateLayoutDto, {
    explode: true,
  });

  const pathParams = {
    layoutId: encodeSimple("layoutId", payload.layoutId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v2/layouts/{layoutId}/duplicate")(pathParams);

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "LayoutsController_duplicate",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.LayoutsControllerDuplicateResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(201, operations.LayoutsControllerDuplicateResponse$inboundSchema, {
      hdrs: true,
      key: "Result",
    }),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - layoutsDuplicate(client: NovuCore,
  duplicateLayoutDto: components.DuplicateLayoutDto,
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  duplicateLayoutDto: components.DuplicateLayoutDto,
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function layoutsDuplicate

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/layoutsGeneratePreview.ts
Tamaño: 6535 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Generate layout preview
 *
 * @remarks
 * Generates a preview for a layout by its unique identifier **layoutId**
 */
export function layoutsGeneratePreview(
  client: NovuCore,
  layoutPreviewRequestDto: components.LayoutPreviewRequestDto,
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.LayoutsControllerGeneratePreviewResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    layoutPreviewRequestDto,
    layoutId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  layoutPreviewRequestDto: components.LayoutPreviewRequestDto,
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.LayoutsControllerGeneratePreviewResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.LayoutsControllerGeneratePreviewRequest = {
    layoutPreviewRequestDto: layoutPreviewRequestDto,
    layoutId: layoutId,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.LayoutsControllerGeneratePreviewRequest$outboundSchema.parse(
        value,
      ),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.LayoutPreviewRequestDto, {
    explode: true,
  });

  const pathParams = {
    layoutId: encodeSimple("layoutId", payload.layoutId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v2/layouts/{layoutId}/preview")(pathParams);

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "LayoutsController_generatePreview",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.LayoutsControllerGeneratePreviewResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      201,
      operations.LayoutsControllerGeneratePreviewResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - layoutsGeneratePreview(client: NovuCore,
  layoutPreviewRequestDto: components.LayoutPreviewRequestDto,
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  layoutPreviewRequestDto: components.LayoutPreviewRequestDto,
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function layoutsGeneratePreview

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/layoutsList.ts
Tamaño: 5919 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeFormQuery, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * List all layouts
 *
 * @remarks
 * Retrieves a list of layouts with optional filtering and pagination
 */
export function layoutsList(
  client: NovuCore,
  request: operations.LayoutsControllerListRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.LayoutsControllerListResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: NovuCore,
  request: operations.LayoutsControllerListRequest,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.LayoutsControllerListResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) =>
      operations.LayoutsControllerListRequest$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const path = pathToFunc("/v2/layouts")();

  const query = encodeFormQuery({
    "limit": payload.limit,
    "offset": payload.offset,
    "orderBy": payload.orderBy,
    "orderDirection": payload.orderDirection,
    "query": payload.query,
  });

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "LayoutsController_list",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    query: query,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.LayoutsControllerListResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, operations.LayoutsControllerListResponse$inboundSchema, {
      hdrs: true,
      key: "Result",
    }),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - layoutsList(client: NovuCore,
  request: operations.LayoutsControllerListRequest,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  request: operations.LayoutsControllerListRequest,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    request,
    (value))
Declaraciones 'export' encontradas:
- export function layoutsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/layoutsRetrieve.ts
Tamaño: 6013 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Retrieve a layout
 *
 * @remarks
 * Fetches details of a specific layout by its unique identifier **layoutId**
 */
export function layoutsRetrieve(
  client: NovuCore,
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.LayoutsControllerGetResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    layoutId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.LayoutsControllerGetResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.LayoutsControllerGetRequest = {
    layoutId: layoutId,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.LayoutsControllerGetRequest$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    layoutId: encodeSimple("layoutId", payload.layoutId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v2/layouts/{layoutId}")(pathParams);

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "LayoutsController_get",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.LayoutsControllerGetResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, operations.LayoutsControllerGetResponse$inboundSchema, {
      hdrs: true,
      key: "Result",
    }),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - layoutsRetrieve(client: NovuCore,
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function layoutsRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/layoutsUpdate.ts
Tamaño: 6372 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Update a layout
 *
 * @remarks
 * Updates the details of an existing layout, here **layoutId** is the identifier of the layout
 */
export function layoutsUpdate(
  client: NovuCore,
  updateLayoutDto: components.UpdateLayoutDto,
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.LayoutsControllerUpdateResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    updateLayoutDto,
    layoutId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  updateLayoutDto: components.UpdateLayoutDto,
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.LayoutsControllerUpdateResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.LayoutsControllerUpdateRequest = {
    updateLayoutDto: updateLayoutDto,
    layoutId: layoutId,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.LayoutsControllerUpdateRequest$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.UpdateLayoutDto, { explode: true });

  const pathParams = {
    layoutId: encodeSimple("layoutId", payload.layoutId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v2/layouts/{layoutId}")(pathParams);

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "LayoutsController_update",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PUT",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.LayoutsControllerUpdateResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, operations.LayoutsControllerUpdateResponse$inboundSchema, {
      hdrs: true,
      key: "Result",
    }),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - layoutsUpdate(client: NovuCore,
  updateLayoutDto: components.UpdateLayoutDto,
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  updateLayoutDto: components.UpdateLayoutDto,
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function layoutsUpdate

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/layoutsUsage.ts
Tamaño: 6081 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Get layout usage
 *
 * @remarks
 * Retrieves information about workflows that use the specified layout by its unique identifier **layoutId**
 */
export function layoutsUsage(
  client: NovuCore,
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.LayoutsControllerGetUsageResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    layoutId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.LayoutsControllerGetUsageResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.LayoutsControllerGetUsageRequest = {
    layoutId: layoutId,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.LayoutsControllerGetUsageRequest$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    layoutId: encodeSimple("layoutId", payload.layoutId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v2/layouts/{layoutId}/usage")(pathParams);

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "LayoutsController_getUsage",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.LayoutsControllerGetUsageResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, operations.LayoutsControllerGetUsageResponse$inboundSchema, {
      hdrs: true,
      key: "Result",
    }),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - layoutsUsage(client: NovuCore,
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  layoutId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function layoutsUsage

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/messagesDelete.ts
Tamaño: 6201 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Delete a message
 *
 * @remarks
 * Delete a message entity from the Novu platform by **messageId**.
 *     This action is irreversible. **messageId** is required and of mongodbId type.
 */
export function messagesDelete(
  client: NovuCore,
  messageId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.MessagesControllerDeleteMessageResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    messageId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  messageId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.MessagesControllerDeleteMessageResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.MessagesControllerDeleteMessageRequest = {
    messageId: messageId,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.MessagesControllerDeleteMessageRequest$outboundSchema.parse(
        value,
      ),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    messageId: encodeSimple("messageId", payload.messageId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v1/messages/{messageId}")(pathParams);

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "MessagesController_deleteMessage",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.MessagesControllerDeleteMessageResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations.MessagesControllerDeleteMessageResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messagesDelete(client: NovuCore,
  messageId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  messageId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function messagesDelete

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/messagesDeleteByTransactionId.ts
Tamaño: 6769 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeFormQuery, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Delete messages by transactionId
 *
 * @remarks
 * Delete multiple messages from the Novu platform using **transactionId** of triggered event.
 *     This API supports filtering by **channel** and delete all messages associated with the **transactionId**.
 */
export function messagesDeleteByTransactionId(
  client: NovuCore,
  transactionId: string,
  channel?: operations.Channel | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    | operations.MessagesControllerDeleteMessagesByTransactionIdResponse
    | undefined,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    transactionId,
    channel,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  transactionId: string,
  channel?: operations.Channel | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      | operations.MessagesControllerDeleteMessagesByTransactionIdResponse
      | undefined,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input:
    operations.MessagesControllerDeleteMessagesByTransactionIdRequest = {
      transactionId: transactionId,
      channel: channel,
      idempotencyKey: idempotencyKey,
    };

  const parsed = safeParse(
    input,
    (value) =>
      operations
        .MessagesControllerDeleteMessagesByTransactionIdRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    transactionId: encodeSimple("transactionId", payload.transactionId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v1/messages/transaction/{transactionId}")(
    pathParams,
  );

  const query = encodeFormQuery({
    "channel": payload.channel,
  });

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "MessagesController_deleteMessagesByTransactionId",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    query: query,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    | operations.MessagesControllerDeleteMessagesByTransactionIdResponse
    | undefined,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.nil(
      204,
      operations
        .MessagesControllerDeleteMessagesByTransactionIdResponse$inboundSchema
        .optional(),
      { hdrs: true },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messagesDeleteByTransactionId(client: NovuCore,
  transactionId: string,
  channel?: operations.Channel | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  transactionId: string,
  channel?: operations.Channel | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function messagesDeleteByTransactionId

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/messagesRetrieve.ts
Tamaño: 6189 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeFormQuery, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * List all messages
 *
 * @remarks
 * List all messages for the current environment.
 *     This API supports filtering by **channel**, **subscriberId**, and **transactionId**.
 *     This API returns a paginated list of messages.
 */
export function messagesRetrieve(
  client: NovuCore,
  request: operations.MessagesControllerGetMessagesRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.MessagesControllerGetMessagesResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: NovuCore,
  request: operations.MessagesControllerGetMessagesRequest,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.MessagesControllerGetMessagesResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) =>
      operations.MessagesControllerGetMessagesRequest$outboundSchema.parse(
        value,
      ),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const path = pathToFunc("/v1/messages")();

  const query = encodeFormQuery({
    "channel": payload.channel,
    "contextKeys": payload.contextKeys,
    "limit": payload.limit,
    "page": payload.page,
    "subscriberId": payload.subscriberId,
    "transactionId": payload.transactionId,
  });

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "MessagesController_getMessages",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    query: query,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.MessagesControllerGetMessagesResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations.MessagesControllerGetMessagesResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - messagesRetrieve(client: NovuCore,
  request: operations.MessagesControllerGetMessagesRequest,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  request: operations.MessagesControllerGetMessagesRequest,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    request,
    (value))
Declaraciones 'export' encontradas:
- export function messagesRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/notificationsList.ts
Tamaño: 6671 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeFormQuery, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * List all events
 *
 * @remarks
 * List all notification events (triggered events) for the current environment.
 *     This API supports filtering by **channels**, **templates**, **emails**, **subscriberIds**, **transactionId**, **topicKey**.
 *     Checkout all available filters in the query section.
 *     This API returns event triggers, to list each channel notifications, check messages APIs.
 */
export function notificationsList(
  client: NovuCore,
  request: operations.NotificationsControllerListNotificationsRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.NotificationsControllerListNotificationsResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: NovuCore,
  request: operations.NotificationsControllerListNotificationsRequest,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.NotificationsControllerListNotificationsResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) =>
      operations.NotificationsControllerListNotificationsRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const path = pathToFunc("/v1/notifications")();

  const query = encodeFormQuery({
    "after": payload.after,
    "before": payload.before,
    "channels": payload.channels,
    "contextKeys": payload.contextKeys,
    "emails": payload.emails,
    "limit": payload.limit,
    "page": payload.page,
    "search": payload.search,
    "severity": payload.severity,
    "subscriberIds": payload.subscriberIds,
    "templates": payload.templates,
    "topicKey": payload.topicKey,
    "transactionId": payload.transactionId,
  });

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "NotificationsController_listNotifications",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    query: query,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.NotificationsControllerListNotificationsResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations.NotificationsControllerListNotificationsResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - notificationsList(client: NovuCore,
  request: operations.NotificationsControllerListNotificationsRequest,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  request: operations.NotificationsControllerListNotificationsRequest,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    request,
    (value))
Declaraciones 'export' encontradas:
- export function notificationsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/notificationsRetrieve.ts
Tamaño: 6398 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Retrieve an event
 *
 * @remarks
 * Retrieve an event by its unique key identifier **notificationId**.
 *     Here **notificationId** is of mongodbId type.
 *     This API returns the event details - execution logs, status, actual notification (message) generated by each workflow step.
 */
export function notificationsRetrieve(
  client: NovuCore,
  notificationId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.NotificationsControllerGetNotificationResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    notificationId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  notificationId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.NotificationsControllerGetNotificationResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.NotificationsControllerGetNotificationRequest = {
    notificationId: notificationId,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.NotificationsControllerGetNotificationRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    notificationId: encodeSimple("notificationId", payload.notificationId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v1/notifications/{notificationId}")(pathParams);

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "NotificationsController_getNotification",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.NotificationsControllerGetNotificationResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations.NotificationsControllerGetNotificationResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - notificationsRetrieve(client: NovuCore,
  notificationId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  notificationId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function notificationsRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/subscribersCreate.ts
Tamaño: 6864 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeFormQuery, encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Create a subscriber
 *
 * @remarks
 * Create a subscriber with the subscriber attributes.
 *       **subscriberId** is a required field, rest other fields are optional, if the subscriber already exists, it will be updated
 */
export function subscribersCreate(
  client: NovuCore,
  createSubscriberRequestDto: components.CreateSubscriberRequestDto,
  failIfExists?: boolean | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.SubscribersControllerCreateSubscriberResponse,
    | errors.SubscriberResponseDto
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    createSubscriberRequestDto,
    failIfExists,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  createSubscriberRequestDto: components.CreateSubscriberRequestDto,
  failIfExists?: boolean | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.SubscribersControllerCreateSubscriberResponse,
      | errors.SubscriberResponseDto
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.SubscribersControllerCreateSubscriberRequest = {
    createSubscriberRequestDto: createSubscriberRequestDto,
    failIfExists: failIfExists,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.SubscribersControllerCreateSubscriberRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.CreateSubscriberRequestDto, {
    explode: true,
  });

  const path = pathToFunc("/v2/subscribers")();

  const query = encodeFormQuery({
    "failIfExists": payload.failIfExists,
  });

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "SubscribersController_createSubscriber",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    query: query,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.SubscribersControllerCreateSubscriberResponse,
    | errors.SubscriberResponseDto
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      201,
      operations.SubscribersControllerCreateSubscriberResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(409, errors.SubscriberResponseDto$inboundSchema, { hdrs: true }),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersCreate(client: NovuCore,
  createSubscriberRequestDto: components.CreateSubscriberRequestDto,
  failIfExists?: boolean | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  createSubscriberRequestDto: components.CreateSubscriberRequestDto,
  failIfExists?: boolean | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function subscribersCreate

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/subscribersCreateBulk.ts
Tamaño: 6450 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Bulk create subscribers
 *
 * @remarks
 *
 *       Using this endpoint multiple subscribers can be created at once. The bulk API is limited to 500 subscribers per request.
 */
export function subscribersCreateBulk(
  client: NovuCore,
  bulkSubscriberCreateDto: components.BulkSubscriberCreateDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.SubscribersV1ControllerBulkCreateSubscribersResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    bulkSubscriberCreateDto,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  bulkSubscriberCreateDto: components.BulkSubscriberCreateDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.SubscribersV1ControllerBulkCreateSubscribersResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.SubscribersV1ControllerBulkCreateSubscribersRequest =
    {
      bulkSubscriberCreateDto: bulkSubscriberCreateDto,
      idempotencyKey: idempotencyKey,
    };

  const parsed = safeParse(
    input,
    (value) =>
      operations
        .SubscribersV1ControllerBulkCreateSubscribersRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.BulkSubscriberCreateDto, {
    explode: true,
  });

  const path = pathToFunc("/v1/subscribers/bulk")();

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "SubscribersV1Controller_bulkCreateSubscribers",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.SubscribersV1ControllerBulkCreateSubscribersResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      201,
      operations
        .SubscribersV1ControllerBulkCreateSubscribersResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersCreateBulk(client: NovuCore,
  bulkSubscriberCreateDto: components.BulkSubscriberCreateDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  bulkSubscriberCreateDto: components.BulkSubscriberCreateDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function subscribersCreateBulk

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/subscribersCredentialsAppend.ts
Tamaño: 6913 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Update provider credentials
 *
 * @remarks
 * Update credentials for a provider such as **slack** and **FCM**.
 *       **providerId** is required field. This API creates the **deviceTokens** or replaces the existing ones.
 */
export function subscribersCredentialsAppend(
  client: NovuCore,
  updateSubscriberChannelRequestDto:
    components.UpdateSubscriberChannelRequestDto,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.SubscribersV1ControllerModifySubscriberChannelResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    updateSubscriberChannelRequestDto,
    subscriberId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  updateSubscriberChannelRequestDto:
    components.UpdateSubscriberChannelRequestDto,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.SubscribersV1ControllerModifySubscriberChannelResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input:
    operations.SubscribersV1ControllerModifySubscriberChannelRequest = {
      updateSubscriberChannelRequestDto: updateSubscriberChannelRequestDto,
      subscriberId: subscriberId,
      idempotencyKey: idempotencyKey,
    };

  const parsed = safeParse(
    input,
    (value) =>
      operations
        .SubscribersV1ControllerModifySubscriberChannelRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.UpdateSubscriberChannelRequestDto, {
    explode: true,
  });

  const pathParams = {
    subscriberId: encodeSimple("subscriberId", payload.subscriberId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v1/subscribers/{subscriberId}/credentials")(
    pathParams,
  );

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "SubscribersV1Controller_modifySubscriberChannel",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.SubscribersV1ControllerModifySubscriberChannelResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations
        .SubscribersV1ControllerModifySubscriberChannelResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersCredentialsAppend(client: NovuCore,
  updateSubscriberChannelRequestDto:
    components.UpdateSubscriberChannelRequestDto,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  updateSubscriberChannelRequestDto:
    components.UpdateSubscriberChannelRequestDto,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function subscribersCredentialsAppend

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/subscribersCredentialsDelete.ts
Tamaño: 6780 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Delete provider credentials
 *
 * @remarks
 * Delete subscriber credentials for a provider such as **slack** and **FCM** by **providerId**.
 *     This action is irreversible and will remove the credentials for the provider for particular **subscriberId**.
 */
export function subscribersCredentialsDelete(
  client: NovuCore,
  subscriberId: string,
  providerId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    | operations.SubscribersV1ControllerDeleteSubscriberCredentialsResponse
    | undefined,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    subscriberId,
    providerId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  subscriberId: string,
  providerId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      | operations.SubscribersV1ControllerDeleteSubscriberCredentialsResponse
      | undefined,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input:
    operations.SubscribersV1ControllerDeleteSubscriberCredentialsRequest = {
      subscriberId: subscriberId,
      providerId: providerId,
      idempotencyKey: idempotencyKey,
    };

  const parsed = safeParse(
    input,
    (value) =>
      operations
        .SubscribersV1ControllerDeleteSubscriberCredentialsRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    providerId: encodeSimple("providerId", payload.providerId, {
      explode: false,
      charEncoding: "percent",
    }),
    subscriberId: encodeSimple("subscriberId", payload.subscriberId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc(
    "/v1/subscribers/{subscriberId}/credentials/{providerId}",
  )(pathParams);

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "SubscribersV1Controller_deleteSubscriberCredentials",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    | operations.SubscribersV1ControllerDeleteSubscriberCredentialsResponse
    | undefined,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.nil(
      204,
      operations
        .SubscribersV1ControllerDeleteSubscriberCredentialsResponse$inboundSchema
        .optional(),
      { hdrs: true },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersCredentialsDelete(client: NovuCore,
  subscriberId: string,
  providerId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  subscriberId: string,
  providerId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function subscribersCredentialsDelete

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/subscribersCredentialsUpdate.ts
Tamaño: 6909 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Upsert provider credentials
 *
 * @remarks
 * Upsert credentials for a provider such as slack and push tokens.
 *       **providerId** is required field. This API creates **deviceTokens** or appends to the existing ones.
 */
export function subscribersCredentialsUpdate(
  client: NovuCore,
  updateSubscriberChannelRequestDto:
    components.UpdateSubscriberChannelRequestDto,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.SubscribersV1ControllerUpdateSubscriberChannelResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    updateSubscriberChannelRequestDto,
    subscriberId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  updateSubscriberChannelRequestDto:
    components.UpdateSubscriberChannelRequestDto,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.SubscribersV1ControllerUpdateSubscriberChannelResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input:
    operations.SubscribersV1ControllerUpdateSubscriberChannelRequest = {
      updateSubscriberChannelRequestDto: updateSubscriberChannelRequestDto,
      subscriberId: subscriberId,
      idempotencyKey: idempotencyKey,
    };

  const parsed = safeParse(
    input,
    (value) =>
      operations
        .SubscribersV1ControllerUpdateSubscriberChannelRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.UpdateSubscriberChannelRequestDto, {
    explode: true,
  });

  const pathParams = {
    subscriberId: encodeSimple("subscriberId", payload.subscriberId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v1/subscribers/{subscriberId}/credentials")(
    pathParams,
  );

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "SubscribersV1Controller_updateSubscriberChannel",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PUT",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.SubscribersV1ControllerUpdateSubscriberChannelResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations
        .SubscribersV1ControllerUpdateSubscriberChannelResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersCredentialsUpdate(client: NovuCore,
  updateSubscriberChannelRequestDto:
    components.UpdateSubscriberChannelRequestDto,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  updateSubscriberChannelRequestDto:
    components.UpdateSubscriberChannelRequestDto,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function subscribersCredentialsUpdate

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/subscribersDelete.ts
Tamaño: 6289 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Delete a subscriber
 *
 * @remarks
 * Deletes a subscriber entity from the Novu platform along with associated messages, preferences, and topic subscriptions.
 *       **subscriberId** is a required field.
 */
export function subscribersDelete(
  client: NovuCore,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.SubscribersControllerRemoveSubscriberResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    subscriberId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.SubscribersControllerRemoveSubscriberResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.SubscribersControllerRemoveSubscriberRequest = {
    subscriberId: subscriberId,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.SubscribersControllerRemoveSubscriberRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    subscriberId: encodeSimple("subscriberId", payload.subscriberId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v2/subscribers/{subscriberId}")(pathParams);

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "SubscribersController_removeSubscriber",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.SubscribersControllerRemoveSubscriberResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations.SubscribersControllerRemoveSubscriberResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersDelete(client: NovuCore,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function subscribersDelete

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/subscribersMessagesMarkAll.ts
Tamaño: 6765 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Update all notifications state
 *
 * @remarks
 * Update all subscriber in-app (inbox) notifications state such as read, unread, seen or unseen by **subscriberId**.
 */
export function subscribersMessagesMarkAll(
  client: NovuCore,
  markAllMessageAsRequestDto: components.MarkAllMessageAsRequestDto,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.SubscribersV1ControllerMarkAllUnreadAsReadResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    markAllMessageAsRequestDto,
    subscriberId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  markAllMessageAsRequestDto: components.MarkAllMessageAsRequestDto,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.SubscribersV1ControllerMarkAllUnreadAsReadResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.SubscribersV1ControllerMarkAllUnreadAsReadRequest = {
    markAllMessageAsRequestDto: markAllMessageAsRequestDto,
    subscriberId: subscriberId,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations
        .SubscribersV1ControllerMarkAllUnreadAsReadRequest$outboundSchema.parse(
          value,
        ),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.MarkAllMessageAsRequestDto, {
    explode: true,
  });

  const pathParams = {
    subscriberId: encodeSimple("subscriberId", payload.subscriberId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v1/subscribers/{subscriberId}/messages/mark-all")(
    pathParams,
  );

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "SubscribersV1Controller_markAllUnreadAsRead",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.SubscribersV1ControllerMarkAllUnreadAsReadResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      201,
      operations
        .SubscribersV1ControllerMarkAllUnreadAsReadResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersMessagesMarkAll(client: NovuCore,
  markAllMessageAsRequestDto: components.MarkAllMessageAsRequestDto,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  markAllMessageAsRequestDto: components.MarkAllMessageAsRequestDto,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function subscribersMessagesMarkAll

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/subscribersMessagesMarkAllAs.ts
Tamaño: 6741 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Update notifications state
 *
 * @remarks
 * Update subscriber's multiple in-app (inbox) notifications state such as seen, read, unseen or unread by **subscriberId**.
 *       **messageId** is of type mongodbId of notifications
 */
export function subscribersMessagesMarkAllAs(
  client: NovuCore,
  messageMarkAsRequestDto: components.MessageMarkAsRequestDto,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.SubscribersV1ControllerMarkMessagesAsResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    messageMarkAsRequestDto,
    subscriberId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  messageMarkAsRequestDto: components.MessageMarkAsRequestDto,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.SubscribersV1ControllerMarkMessagesAsResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.SubscribersV1ControllerMarkMessagesAsRequest = {
    messageMarkAsRequestDto: messageMarkAsRequestDto,
    subscriberId: subscriberId,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.SubscribersV1ControllerMarkMessagesAsRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.MessageMarkAsRequestDto, {
    explode: true,
  });

  const pathParams = {
    subscriberId: encodeSimple("subscriberId", payload.subscriberId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v1/subscribers/{subscriberId}/messages/mark-as")(
    pathParams,
  );

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "SubscribersV1Controller_markMessagesAs",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.SubscribersV1ControllerMarkMessagesAsResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      201,
      operations.SubscribersV1ControllerMarkMessagesAsResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersMessagesMarkAllAs(client: NovuCore,
  messageMarkAsRequestDto: components.MessageMarkAsRequestDto,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  messageMarkAsRequestDto: components.MessageMarkAsRequestDto,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function subscribersMessagesMarkAllAs

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/subscribersMessagesUpdateAsSeen.ts
Tamaño: 6584 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Update notification action status
 *
 * @remarks
 * Update in-app (inbox) notification's action status by its unique key identifier **messageId** and type field **type**.
 *       **type** field can be **primary** or **secondary**
 */
export function subscribersMessagesUpdateAsSeen(
  client: NovuCore,
  request: operations.SubscribersV1ControllerMarkActionAsSeenRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.SubscribersV1ControllerMarkActionAsSeenResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: NovuCore,
  request: operations.SubscribersV1ControllerMarkActionAsSeenRequest,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.SubscribersV1ControllerMarkActionAsSeenResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) =>
      operations.SubscribersV1ControllerMarkActionAsSeenRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.MarkMessageActionAsSeenDto, {
    explode: true,
  });

  const pathParams = {
    messageId: encodeSimple("messageId", payload.messageId, {
      explode: false,
      charEncoding: "percent",
    }),
    subscriberId: encodeSimple("subscriberId", payload.subscriberId, {
      explode: false,
      charEncoding: "percent",
    }),
    type: encodeSimple("type", payload.type, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc(
    "/v1/subscribers/{subscriberId}/messages/{messageId}/actions/{type}",
  )(pathParams);

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "SubscribersV1Controller_markActionAsSeen",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.SubscribersV1ControllerMarkActionAsSeenResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      201,
      operations.SubscribersV1ControllerMarkActionAsSeenResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersMessagesUpdateAsSeen(client: NovuCore,
  request: operations.SubscribersV1ControllerMarkActionAsSeenRequest,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  request: operations.SubscribersV1ControllerMarkActionAsSeenRequest,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    request,
    (value))
Declaraciones 'export' encontradas:
- export function subscribersMessagesUpdateAsSeen

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/subscribersNotificationsFeed.ts
Tamaño: 6385 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeFormQuery, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Retrieve subscriber notifications
 *
 * @remarks
 * Retrieve subscriber in-app (inbox) notifications by its unique key identifier **subscriberId**.
 */
export function subscribersNotificationsFeed(
  client: NovuCore,
  request: operations.SubscribersV1ControllerGetNotificationsFeedRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.SubscribersV1ControllerGetNotificationsFeedResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: NovuCore,
  request: operations.SubscribersV1ControllerGetNotificationsFeedRequest,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.SubscribersV1ControllerGetNotificationsFeedResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) =>
      operations
        .SubscribersV1ControllerGetNotificationsFeedRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    subscriberId: encodeSimple("subscriberId", payload.subscriberId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v1/subscribers/{subscriberId}/notifications/feed")(
    pathParams,
  );

  const query = encodeFormQuery({
    "limit": payload.limit,
    "page": payload.page,
    "payload": payload.payload,
    "read": payload.read,
    "seen": payload.seen,
  });

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "SubscribersV1Controller_getNotificationsFeed",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    query: query,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.SubscribersV1ControllerGetNotificationsFeedResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations
        .SubscribersV1ControllerGetNotificationsFeedResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersNotificationsFeed(client: NovuCore,
  request: operations.SubscribersV1ControllerGetNotificationsFeedRequest,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  request: operations.SubscribersV1ControllerGetNotificationsFeedRequest,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    request,
    (value))
Declaraciones 'export' encontradas:
- export function subscribersNotificationsFeed

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/subscribersNotificationsUnseenCount.ts
Tamaño: 6265 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeFormQuery, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Retrieve unseen notifications count
 *
 * @remarks
 * Retrieve unseen in-app (inbox) notifications count for a subscriber by its unique key identifier **subscriberId**.
 */
export function subscribersNotificationsUnseenCount(
  client: NovuCore,
  request: operations.SubscribersV1ControllerGetUnseenCountRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.SubscribersV1ControllerGetUnseenCountResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: NovuCore,
  request: operations.SubscribersV1ControllerGetUnseenCountRequest,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.SubscribersV1ControllerGetUnseenCountResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) =>
      operations.SubscribersV1ControllerGetUnseenCountRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    subscriberId: encodeSimple("subscriberId", payload.subscriberId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc(
    "/v1/subscribers/{subscriberId}/notifications/unseen",
  )(pathParams);

  const query = encodeFormQuery({
    "limit": payload.limit,
    "seen": payload.seen,
  });

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "SubscribersV1Controller_getUnseenCount",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    query: query,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.SubscribersV1ControllerGetUnseenCountResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations.SubscribersV1ControllerGetUnseenCountResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersNotificationsUnseenCount(client: NovuCore,
  request: operations.SubscribersV1ControllerGetUnseenCountRequest,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  request: operations.SubscribersV1ControllerGetUnseenCountRequest,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    request,
    (value))
Declaraciones 'export' encontradas:
- export function subscribersNotificationsUnseenCount

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/subscribersPatch.ts
Tamaño: 6666 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Update a subscriber
 *
 * @remarks
 * Update a subscriber by its unique key identifier **subscriberId**.
 *     **subscriberId** is a required field, rest other fields are optional
 */
export function subscribersPatch(
  client: NovuCore,
  patchSubscriberRequestDto: components.PatchSubscriberRequestDto,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.SubscribersControllerPatchSubscriberResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    patchSubscriberRequestDto,
    subscriberId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  patchSubscriberRequestDto: components.PatchSubscriberRequestDto,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.SubscribersControllerPatchSubscriberResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.SubscribersControllerPatchSubscriberRequest = {
    patchSubscriberRequestDto: patchSubscriberRequestDto,
    subscriberId: subscriberId,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.SubscribersControllerPatchSubscriberRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.PatchSubscriberRequestDto, {
    explode: true,
  });

  const pathParams = {
    subscriberId: encodeSimple("subscriberId", payload.subscriberId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v2/subscribers/{subscriberId}")(pathParams);

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "SubscribersController_patchSubscriber",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.SubscribersControllerPatchSubscriberResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations.SubscribersControllerPatchSubscriberResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersPatch(client: NovuCore,
  patchSubscriberRequestDto: components.PatchSubscriberRequestDto,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  patchSubscriberRequestDto: components.PatchSubscriberRequestDto,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function subscribersPatch

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/subscribersPreferencesBulkUpdate.ts
Tamaño: 6967 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Bulk update subscriber preferences
 *
 * @remarks
 * Bulk update subscriber preferences by its unique key identifier **subscriberId**.
 *     This API allows updating multiple workflow preferences in a single request.
 */
export function subscribersPreferencesBulkUpdate(
  client: NovuCore,
  bulkUpdateSubscriberPreferencesDto:
    components.BulkUpdateSubscriberPreferencesDto,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.SubscribersControllerBulkUpdateSubscriberPreferencesResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    bulkUpdateSubscriberPreferencesDto,
    subscriberId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  bulkUpdateSubscriberPreferencesDto:
    components.BulkUpdateSubscriberPreferencesDto,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.SubscribersControllerBulkUpdateSubscriberPreferencesResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input:
    operations.SubscribersControllerBulkUpdateSubscriberPreferencesRequest = {
      bulkUpdateSubscriberPreferencesDto: bulkUpdateSubscriberPreferencesDto,
      subscriberId: subscriberId,
      idempotencyKey: idempotencyKey,
    };

  const parsed = safeParse(
    input,
    (value) =>
      operations
        .SubscribersControllerBulkUpdateSubscriberPreferencesRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.BulkUpdateSubscriberPreferencesDto, {
    explode: true,
  });

  const pathParams = {
    subscriberId: encodeSimple("subscriberId", payload.subscriberId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v2/subscribers/{subscriberId}/preferences/bulk")(
    pathParams,
  );

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "SubscribersController_bulkUpdateSubscriberPreferences",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.SubscribersControllerBulkUpdateSubscriberPreferencesResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations
        .SubscribersControllerBulkUpdateSubscriberPreferencesResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersPreferencesBulkUpdate(client: NovuCore,
  bulkUpdateSubscriberPreferencesDto:
    components.BulkUpdateSubscriberPreferencesDto,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  bulkUpdateSubscriberPreferencesDto:
    components.BulkUpdateSubscriberPreferencesDto,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function subscribersPreferencesBulkUpdate

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/subscribersPreferencesList.ts
Tamaño: 6696 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeFormQuery, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Retrieve subscriber preferences
 *
 * @remarks
 * Retrieve subscriber channel preferences by its unique key identifier **subscriberId**.
 *     This API returns all five channels preferences for all workflows and global preferences.
 */
export function subscribersPreferencesList(
  client: NovuCore,
  subscriberId: string,
  criticality?: operations.Criticality | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.SubscribersControllerGetSubscriberPreferencesResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    subscriberId,
    criticality,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  subscriberId: string,
  criticality?: operations.Criticality | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.SubscribersControllerGetSubscriberPreferencesResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.SubscribersControllerGetSubscriberPreferencesRequest =
    {
      subscriberId: subscriberId,
      criticality: criticality,
      idempotencyKey: idempotencyKey,
    };

  const parsed = safeParse(
    input,
    (value) =>
      operations
        .SubscribersControllerGetSubscriberPreferencesRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    subscriberId: encodeSimple("subscriberId", payload.subscriberId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v2/subscribers/{subscriberId}/preferences")(
    pathParams,
  );

  const query = encodeFormQuery({
    "criticality": payload.criticality,
  });

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "SubscribersController_getSubscriberPreferences",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    query: query,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.SubscribersControllerGetSubscriberPreferencesResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations
        .SubscribersControllerGetSubscriberPreferencesResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersPreferencesList(client: NovuCore,
  subscriberId: string,
  criticality?: operations.Criticality | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  subscriberId: string,
  criticality?: operations.Criticality | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function subscribersPreferencesList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/subscribersPreferencesUpdate.ts
Tamaño: 6941 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Update subscriber preferences
 *
 * @remarks
 * Update subscriber preferences by its unique key identifier **subscriberId**.
 *     **workflowId** is optional field, if provided, this API will update that workflow preference,
 *     otherwise it will update global preferences
 */
export function subscribersPreferencesUpdate(
  client: NovuCore,
  patchSubscriberPreferencesDto: components.PatchSubscriberPreferencesDto,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.SubscribersControllerUpdateSubscriberPreferencesResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    patchSubscriberPreferencesDto,
    subscriberId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  patchSubscriberPreferencesDto: components.PatchSubscriberPreferencesDto,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.SubscribersControllerUpdateSubscriberPreferencesResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input:
    operations.SubscribersControllerUpdateSubscriberPreferencesRequest = {
      patchSubscriberPreferencesDto: patchSubscriberPreferencesDto,
      subscriberId: subscriberId,
      idempotencyKey: idempotencyKey,
    };

  const parsed = safeParse(
    input,
    (value) =>
      operations
        .SubscribersControllerUpdateSubscriberPreferencesRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.PatchSubscriberPreferencesDto, {
    explode: true,
  });

  const pathParams = {
    subscriberId: encodeSimple("subscriberId", payload.subscriberId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v2/subscribers/{subscriberId}/preferences")(
    pathParams,
  );

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "SubscribersController_updateSubscriberPreferences",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.SubscribersControllerUpdateSubscriberPreferencesResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations
        .SubscribersControllerUpdateSubscriberPreferencesResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersPreferencesUpdate(client: NovuCore,
  patchSubscriberPreferencesDto: components.PatchSubscriberPreferencesDto,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  patchSubscriberPreferencesDto: components.PatchSubscriberPreferencesDto,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function subscribersPreferencesUpdate

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/subscribersPropertiesUpdateOnlineFlag.ts
Tamaño: 6896 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Update subscriber online status
 *
 * @remarks
 * Update the subscriber online status by its unique key identifier **subscriberId**
 */
export function subscribersPropertiesUpdateOnlineFlag(
  client: NovuCore,
  updateSubscriberOnlineFlagRequestDto:
    components.UpdateSubscriberOnlineFlagRequestDto,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    updateSubscriberOnlineFlagRequestDto,
    subscriberId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  updateSubscriberOnlineFlagRequestDto:
    components.UpdateSubscriberOnlineFlagRequestDto,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input:
    operations.SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest = {
      updateSubscriberOnlineFlagRequestDto:
        updateSubscriberOnlineFlagRequestDto,
      subscriberId: subscriberId,
      idempotencyKey: idempotencyKey,
    };

  const parsed = safeParse(
    input,
    (value) =>
      operations
        .SubscribersV1ControllerUpdateSubscriberOnlineFlagRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON(
    "body",
    payload.UpdateSubscriberOnlineFlagRequestDto,
    { explode: true },
  );

  const pathParams = {
    subscriberId: encodeSimple("subscriberId", payload.subscriberId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v1/subscribers/{subscriberId}/online-status")(
    pathParams,
  );

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "SubscribersV1Controller_updateSubscriberOnlineFlag",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations
        .SubscribersV1ControllerUpdateSubscriberOnlineFlagResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersPropertiesUpdateOnlineFlag(client: NovuCore,
  updateSubscriberOnlineFlagRequestDto:
    components.UpdateSubscriberOnlineFlagRequestDto,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  updateSubscriberOnlineFlagRequestDto:
    components.UpdateSubscriberOnlineFlagRequestDto,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function subscribersPropertiesUpdateOnlineFlag

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/subscribersRetrieve.ts
Tamaño: 6221 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Retrieve a subscriber
 *
 * @remarks
 * Retrieve a subscriber by its unique key identifier **subscriberId**.
 *     **subscriberId** field is required.
 */
export function subscribersRetrieve(
  client: NovuCore,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.SubscribersControllerGetSubscriberResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    subscriberId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.SubscribersControllerGetSubscriberResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.SubscribersControllerGetSubscriberRequest = {
    subscriberId: subscriberId,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.SubscribersControllerGetSubscriberRequest$outboundSchema.parse(
        value,
      ),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    subscriberId: encodeSimple("subscriberId", payload.subscriberId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v2/subscribers/{subscriberId}")(pathParams);

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "SubscribersController_getSubscriber",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.SubscribersControllerGetSubscriberResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations.SubscribersControllerGetSubscriberResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersRetrieve(client: NovuCore,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  subscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function subscribersRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/subscribersSearch.ts
Tamaño: 6379 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeFormQuery, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Search subscribers
 *
 * @remarks
 * Search subscribers by their **email**, **phone**, **subscriberId** and **name**.
 *     The search is case sensitive and supports pagination.Checkout all available filters in the query section.
 */
export function subscribersSearch(
  client: NovuCore,
  request: operations.SubscribersControllerSearchSubscribersRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.SubscribersControllerSearchSubscribersResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: NovuCore,
  request: operations.SubscribersControllerSearchSubscribersRequest,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.SubscribersControllerSearchSubscribersResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) =>
      operations.SubscribersControllerSearchSubscribersRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const path = pathToFunc("/v2/subscribers")();

  const query = encodeFormQuery({
    "after": payload.after,
    "before": payload.before,
    "email": payload.email,
    "includeCursor": payload.includeCursor,
    "limit": payload.limit,
    "name": payload.name,
    "orderBy": payload.orderBy,
    "orderDirection": payload.orderDirection,
    "phone": payload.phone,
    "subscriberId": payload.subscriberId,
  });

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "SubscribersController_searchSubscribers",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    query: query,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.SubscribersControllerSearchSubscribersResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations.SubscribersControllerSearchSubscribersResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersSearch(client: NovuCore,
  request: operations.SubscribersControllerSearchSubscribersRequest,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  request: operations.SubscribersControllerSearchSubscribersRequest,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    request,
    (value))
Declaraciones 'export' encontradas:
- export function subscribersSearch

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/subscribersTopicsList.ts
Tamaño: 6495 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeFormQuery, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Retrieve subscriber subscriptions
 *
 * @remarks
 * Retrieve subscriber's topic subscriptions by its unique key identifier **subscriberId**.
 *     Checkout all available filters in the query section.
 */
export function subscribersTopicsList(
  client: NovuCore,
  request: operations.SubscribersControllerListSubscriberTopicsRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.SubscribersControllerListSubscriberTopicsResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: NovuCore,
  request: operations.SubscribersControllerListSubscriberTopicsRequest,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.SubscribersControllerListSubscriberTopicsResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) =>
      operations.SubscribersControllerListSubscriberTopicsRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    subscriberId: encodeSimple("subscriberId", payload.subscriberId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v2/subscribers/{subscriberId}/subscriptions")(
    pathParams,
  );

  const query = encodeFormQuery({
    "after": payload.after,
    "before": payload.before,
    "includeCursor": payload.includeCursor,
    "key": payload.key,
    "limit": payload.limit,
    "orderBy": payload.orderBy,
    "orderDirection": payload.orderDirection,
  });

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "SubscribersController_listSubscriberTopics",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    query: query,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.SubscribersControllerListSubscriberTopicsResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations
        .SubscribersControllerListSubscriberTopicsResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - subscribersTopicsList(client: NovuCore,
  request: operations.SubscribersControllerListSubscriberTopicsRequest,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  request: operations.SubscribersControllerListSubscriberTopicsRequest,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    request,
    (value))
Declaraciones 'export' encontradas:
- export function subscribersTopicsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/topicsCreate.ts
Tamaño: 6717 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeFormQuery, encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Create a topic
 *
 * @remarks
 * Creates a new topic if it does not exist, or updates an existing topic if it already exists. Use ?failIfExists=true to prevent updates.
 */
export function topicsCreate(
  client: NovuCore,
  createUpdateTopicRequestDto: components.CreateUpdateTopicRequestDto,
  failIfExists?: boolean | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.TopicsControllerUpsertTopicResponse,
    | errors.TopicResponseDto
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    createUpdateTopicRequestDto,
    failIfExists,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  createUpdateTopicRequestDto: components.CreateUpdateTopicRequestDto,
  failIfExists?: boolean | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.TopicsControllerUpsertTopicResponse,
      | errors.TopicResponseDto
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.TopicsControllerUpsertTopicRequest = {
    createUpdateTopicRequestDto: createUpdateTopicRequestDto,
    failIfExists: failIfExists,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.TopicsControllerUpsertTopicRequest$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.CreateUpdateTopicRequestDto, {
    explode: true,
  });

  const path = pathToFunc("/v2/topics")();

  const query = encodeFormQuery({
    "failIfExists": payload.failIfExists,
  });

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "TopicsController_upsertTopic",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    query: query,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.TopicsControllerUpsertTopicResponse,
    | errors.TopicResponseDto
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      [200, 201],
      operations.TopicsControllerUpsertTopicResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(409, errors.TopicResponseDto$inboundSchema, { hdrs: true }),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicsCreate(client: NovuCore,
  createUpdateTopicRequestDto: components.CreateUpdateTopicRequestDto,
  failIfExists?: boolean | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  createUpdateTopicRequestDto: components.CreateUpdateTopicRequestDto,
  failIfExists?: boolean | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function topicsCreate

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/topicsDelete.ts
Tamaño: 6124 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Delete a topic
 *
 * @remarks
 * Delete a topic by its unique key identifier **topicKey**.
 *     This action is irreversible and will remove all subscriptions to the topic.
 */
export function topicsDelete(
  client: NovuCore,
  topicKey: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.TopicsControllerDeleteTopicResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    topicKey,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  topicKey: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.TopicsControllerDeleteTopicResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.TopicsControllerDeleteTopicRequest = {
    topicKey: topicKey,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.TopicsControllerDeleteTopicRequest$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    topicKey: encodeSimple("topicKey", payload.topicKey, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v2/topics/{topicKey}")(pathParams);

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "TopicsController_deleteTopic",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.TopicsControllerDeleteTopicResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, operations.TopicsControllerDeleteTopicResponse$inboundSchema, {
      hdrs: true,
      key: "Result",
    }),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicsDelete(client: NovuCore,
  topicKey: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  topicKey: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function topicsDelete

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/topicsGet.ts
Tamaño: 6017 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Retrieve a topic
 *
 * @remarks
 * Retrieve a topic by its unique key identifier **topicKey**
 */
export function topicsGet(
  client: NovuCore,
  topicKey: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.TopicsControllerGetTopicResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    topicKey,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  topicKey: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.TopicsControllerGetTopicResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.TopicsControllerGetTopicRequest = {
    topicKey: topicKey,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.TopicsControllerGetTopicRequest$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    topicKey: encodeSimple("topicKey", payload.topicKey, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v2/topics/{topicKey}")(pathParams);

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "TopicsController_getTopic",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.TopicsControllerGetTopicResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, operations.TopicsControllerGetTopicResponse$inboundSchema, {
      hdrs: true,
      key: "Result",
    }),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicsGet(client: NovuCore,
  topicKey: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  topicKey: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function topicsGet

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/topicsList.ts
Tamaño: 6191 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeFormQuery, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * List all topics
 *
 * @remarks
 * This api returns a paginated list of topics.
 *     Topics can be filtered by **key**, **name**, or **includeCursor** to paginate through the list.
 *     Checkout all available filters in the query section.
 */
export function topicsList(
  client: NovuCore,
  request: operations.TopicsControllerListTopicsRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.TopicsControllerListTopicsResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: NovuCore,
  request: operations.TopicsControllerListTopicsRequest,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.TopicsControllerListTopicsResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) =>
      operations.TopicsControllerListTopicsRequest$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const path = pathToFunc("/v2/topics")();

  const query = encodeFormQuery({
    "after": payload.after,
    "before": payload.before,
    "includeCursor": payload.includeCursor,
    "key": payload.key,
    "limit": payload.limit,
    "name": payload.name,
    "orderBy": payload.orderBy,
    "orderDirection": payload.orderDirection,
  });

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "TopicsController_listTopics",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    query: query,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.TopicsControllerListTopicsResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, operations.TopicsControllerListTopicsResponse$inboundSchema, {
      hdrs: true,
      key: "Result",
    }),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicsList(client: NovuCore,
  request: operations.TopicsControllerListTopicsRequest,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  request: operations.TopicsControllerListTopicsRequest,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    request,
    (value))
Declaraciones 'export' encontradas:
- export function topicsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/topicsSubscribersRetrieve.ts
Tamaño: 6476 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Check topic subscriber
 *
 * @remarks
 * Check if a subscriber belongs to a certain topic
 */
export function topicsSubscribersRetrieve(
  client: NovuCore,
  topicKey: string,
  externalSubscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.TopicsV1ControllerGetTopicSubscriberResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    topicKey,
    externalSubscriberId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  topicKey: string,
  externalSubscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.TopicsV1ControllerGetTopicSubscriberResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.TopicsV1ControllerGetTopicSubscriberRequest = {
    topicKey: topicKey,
    externalSubscriberId: externalSubscriberId,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.TopicsV1ControllerGetTopicSubscriberRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    externalSubscriberId: encodeSimple(
      "externalSubscriberId",
      payload.externalSubscriberId,
      { explode: false, charEncoding: "percent" },
    ),
    topicKey: encodeSimple("topicKey", payload.topicKey, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc(
    "/v1/topics/{topicKey}/subscribers/{externalSubscriberId}",
  )(pathParams);

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "TopicsV1Controller_getTopicSubscriber",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.TopicsV1ControllerGetTopicSubscriberResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations.TopicsV1ControllerGetTopicSubscriberResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicsSubscribersRetrieve(client: NovuCore,
  topicKey: string,
  externalSubscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  topicKey: string,
  externalSubscriberId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function topicsSubscribersRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/topicsSubscriptionsCreate.ts
Tamaño: 6787 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Create topic subscriptions
 *
 * @remarks
 * This api will create subscription for subscriberIds for a topic.
 *       Its like subscribing to a common interest group. if topic does not exist, it will be created.
 */
export function topicsSubscriptionsCreate(
  client: NovuCore,
  createTopicSubscriptionsRequestDto:
    components.CreateTopicSubscriptionsRequestDto,
  topicKey: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.TopicsControllerCreateTopicSubscriptionsResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    createTopicSubscriptionsRequestDto,
    topicKey,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  createTopicSubscriptionsRequestDto:
    components.CreateTopicSubscriptionsRequestDto,
  topicKey: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.TopicsControllerCreateTopicSubscriptionsResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.TopicsControllerCreateTopicSubscriptionsRequest = {
    createTopicSubscriptionsRequestDto: createTopicSubscriptionsRequestDto,
    topicKey: topicKey,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.TopicsControllerCreateTopicSubscriptionsRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.CreateTopicSubscriptionsRequestDto, {
    explode: true,
  });

  const pathParams = {
    topicKey: encodeSimple("topicKey", payload.topicKey, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v2/topics/{topicKey}/subscriptions")(pathParams);

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "TopicsController_createTopicSubscriptions",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.TopicsControllerCreateTopicSubscriptionsResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      201,
      operations.TopicsControllerCreateTopicSubscriptionsResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicsSubscriptionsCreate(client: NovuCore,
  createTopicSubscriptionsRequestDto:
    components.CreateTopicSubscriptionsRequestDto,
  topicKey: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  createTopicSubscriptionsRequestDto:
    components.CreateTopicSubscriptionsRequestDto,
  topicKey: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function topicsSubscriptionsCreate

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/topicsSubscriptionsDelete.ts
Tamaño: 6673 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Delete topic subscriptions
 *
 * @remarks
 * Delete subscriptions for subscriberIds for a topic.
 */
export function topicsSubscriptionsDelete(
  client: NovuCore,
  deleteTopicSubscriptionsRequestDto:
    components.DeleteTopicSubscriptionsRequestDto,
  topicKey: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.TopicsControllerDeleteTopicSubscriptionsResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    deleteTopicSubscriptionsRequestDto,
    topicKey,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  deleteTopicSubscriptionsRequestDto:
    components.DeleteTopicSubscriptionsRequestDto,
  topicKey: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.TopicsControllerDeleteTopicSubscriptionsResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.TopicsControllerDeleteTopicSubscriptionsRequest = {
    deleteTopicSubscriptionsRequestDto: deleteTopicSubscriptionsRequestDto,
    topicKey: topicKey,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.TopicsControllerDeleteTopicSubscriptionsRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.DeleteTopicSubscriptionsRequestDto, {
    explode: true,
  });

  const pathParams = {
    topicKey: encodeSimple("topicKey", payload.topicKey, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v2/topics/{topicKey}/subscriptions")(pathParams);

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "TopicsController_deleteTopicSubscriptions",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.TopicsControllerDeleteTopicSubscriptionsResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations.TopicsControllerDeleteTopicSubscriptionsResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicsSubscriptionsDelete(client: NovuCore,
  deleteTopicSubscriptionsRequestDto:
    components.DeleteTopicSubscriptionsRequestDto,
  topicKey: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  deleteTopicSubscriptionsRequestDto:
    components.DeleteTopicSubscriptionsRequestDto,
  topicKey: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function topicsSubscriptionsDelete

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/topicsSubscriptionsList.ts
Tamaño: 6405 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeFormQuery, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * List topic subscriptions
 *
 * @remarks
 * List all subscriptions of subscribers for a topic.
 *     Checkout all available filters in the query section.
 */
export function topicsSubscriptionsList(
  client: NovuCore,
  request: operations.TopicsControllerListTopicSubscriptionsRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.TopicsControllerListTopicSubscriptionsResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: NovuCore,
  request: operations.TopicsControllerListTopicSubscriptionsRequest,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.TopicsControllerListTopicSubscriptionsResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) =>
      operations.TopicsControllerListTopicSubscriptionsRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    topicKey: encodeSimple("topicKey", payload.topicKey, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v2/topics/{topicKey}/subscriptions")(pathParams);

  const query = encodeFormQuery({
    "after": payload.after,
    "before": payload.before,
    "includeCursor": payload.includeCursor,
    "limit": payload.limit,
    "orderBy": payload.orderBy,
    "orderDirection": payload.orderDirection,
    "subscriberId": payload.subscriberId,
  });

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "TopicsController_listTopicSubscriptions",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    query: query,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.TopicsControllerListTopicSubscriptionsResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations.TopicsControllerListTopicSubscriptionsResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicsSubscriptionsList(client: NovuCore,
  request: operations.TopicsControllerListTopicSubscriptionsRequest,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  request: operations.TopicsControllerListTopicSubscriptionsRequest,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    request,
    (value))
Declaraciones 'export' encontradas:
- export function topicsSubscriptionsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/topicsUpdate.ts
Tamaño: 6423 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Update a topic
 *
 * @remarks
 * Update a topic name by its unique key identifier **topicKey**
 */
export function topicsUpdate(
  client: NovuCore,
  updateTopicRequestDto: components.UpdateTopicRequestDto,
  topicKey: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.TopicsControllerUpdateTopicResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    updateTopicRequestDto,
    topicKey,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  updateTopicRequestDto: components.UpdateTopicRequestDto,
  topicKey: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.TopicsControllerUpdateTopicResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.TopicsControllerUpdateTopicRequest = {
    updateTopicRequestDto: updateTopicRequestDto,
    topicKey: topicKey,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.TopicsControllerUpdateTopicRequest$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.UpdateTopicRequestDto, {
    explode: true,
  });

  const pathParams = {
    topicKey: encodeSimple("topicKey", payload.topicKey, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v2/topics/{topicKey}")(pathParams);

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "TopicsController_updateTopic",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.TopicsControllerUpdateTopicResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, operations.TopicsControllerUpdateTopicResponse$inboundSchema, {
      hdrs: true,
      key: "Result",
    }),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - topicsUpdate(client: NovuCore,
  updateTopicRequestDto: components.UpdateTopicRequestDto,
  topicKey: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  updateTopicRequestDto: components.UpdateTopicRequestDto,
  topicKey: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function topicsUpdate

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/translationsCreate.ts
Tamaño: 5391 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Create a translation
 *
 * @remarks
 * Create a translation for a specific workflow and locale, if the translation already exists, it will be updated
 */
export function translationsCreate(
  client: NovuCore,
  createTranslationRequestDto: components.CreateTranslationRequestDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    components.TranslationResponseDto,
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    createTranslationRequestDto,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  createTranslationRequestDto: components.CreateTranslationRequestDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      components.TranslationResponseDto,
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input:
    operations.TranslationControllerCreateTranslationEndpointRequest = {
      createTranslationRequestDto: createTranslationRequestDto,
      idempotencyKey: idempotencyKey,
    };

  const parsed = safeParse(
    input,
    (value) =>
      operations
        .TranslationControllerCreateTranslationEndpointRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.CreateTranslationRequestDto, {
    explode: true,
  });

  const path = pathToFunc("/v2/translations")();

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "TranslationController_createTranslationEndpoint",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const [result] = await M.match<
    components.TranslationResponseDto,
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, components.TranslationResponseDto$inboundSchema),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - translationsCreate(client: NovuCore,
  createTranslationRequestDto: components.CreateTranslationRequestDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  createTranslationRequestDto: components.CreateTranslationRequestDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function translationsCreate

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/translationsDelete.ts
Tamaño: 5201 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { NovuCore } from '../core.js';
import { encodeSimple } from '../lib/encodings.js';
import * as M from '../lib/matchers.js';
import { compactMap } from '../lib/primitives.js';
import { safeParse } from '../lib/schemas.js';
import { RequestOptions } from '../lib/sdks.js';
import { extractSecurity, resolveGlobalSecurity } from '../lib/security.js';
import { pathToFunc } from '../lib/url.js';
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from '../models/errors/httpclienterrors.js';
import { NovuError } from '../models/errors/novuerror.js';
import { ResponseValidationError } from '../models/errors/responsevalidationerror.js';
import { SDKValidationError } from '../models/errors/sdkvalidationerror.js';
import * as operations from '../models/operations/index.js';
import { APICall, APIPromise } from '../types/async.js';
import { Result } from '../types/fp.js';

/**
 * Delete a translation
 *
 * @remarks
 * Delete a specific translation by resource type, resource ID and locale
 */
export function translationsDelete(
  client: NovuCore,
  request: operations.TranslationControllerDeleteTranslationEndpointRequest,
  options?: RequestOptions
): APIPromise<
  Result<
    void,
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(client, request, options));
}

async function $do(
  client: NovuCore,
  request: operations.TranslationControllerDeleteTranslationEndpointRequest,
  options?: RequestOptions
): Promise<
  [
    Result<
      void,
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) => operations.TranslationControllerDeleteTranslationEndpointRequest$outboundSchema.parse(value),
    'Input validation failed'
  );
  if (!parsed.ok) {
    return [parsed, { status: 'invalid' }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    locale: encodeSimple('locale', payload.locale, {
      explode: false,
      charEncoding: 'percent',
    }),
    resourceId: encodeSimple('resourceId', payload.resourceId, {
      explode: false,
      charEncoding: 'percent',
    }),
    resourceType: encodeSimple('resourceType', payload.resourceType, {
      explode: false,
      charEncoding: 'percent',
    }),
  };

  const path = pathToFunc('/v2/translations/{resourceType}/{resourceId}/{locale}')(pathParams);

  const headers = new Headers(
    compactMap({
      Accept: '*/*',
      'idempotency-key': encodeSimple('idempotency-key', payload['idempotency-key'], {
        explode: false,
        charEncoding: 'none',
      }),
    })
  );

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? '',
    operationID: 'TranslationController_deleteTranslationEndpoint',
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries ||
      client._options.retryConfig || {
        strategy: 'backoff',
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      } || { strategy: 'none' },
    retryCodes: options?.retryCodes || ['408', '409', '429', '5XX'],
  };

  const requestRes = client._createRequest(
    context,
    {
      security: requestSecurity,
      method: 'DELETE',
      baseURL: options?.serverURL,
      path: path,
      headers: headers,
      body: body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
    },
    options
  );
  if (!requestRes.ok) {
    return [requestRes, { status: 'invalid' }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: ['404', '4XX', '5XX'],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: 'request-error', request: req }];
  }
  const response = doResult.value;

  const [result] = await M.match<
    void,
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.nil(204, z.void()),
    M.fail([404, '4XX']),
    M.fail('5XX')
  )(response, req);
  if (!result.ok) {
    return [result, { status: 'complete', request: req, response }];
  }

  return [result, { status: 'complete', request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - translationsDelete(client: NovuCore,
  request: operations.TranslationControllerDeleteTranslationEndpointRequest,
  options?: RequestOptions)
 - $do(client: NovuCore,
  request: operations.TranslationControllerDeleteTranslationEndpointRequest,
  options?: RequestOptions)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    request,
    (value))
Declaraciones 'export' encontradas:
- export function translationsDelete

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/translationsGroupsDelete.ts
Tamaño: 5361 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { NovuCore } from '../core.js';
import { encodeSimple } from '../lib/encodings.js';
import * as M from '../lib/matchers.js';
import { compactMap } from '../lib/primitives.js';
import { safeParse } from '../lib/schemas.js';
import { RequestOptions } from '../lib/sdks.js';
import { extractSecurity, resolveGlobalSecurity } from '../lib/security.js';
import { pathToFunc } from '../lib/url.js';
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from '../models/errors/httpclienterrors.js';
import { NovuError } from '../models/errors/novuerror.js';
import { ResponseValidationError } from '../models/errors/responsevalidationerror.js';
import { SDKValidationError } from '../models/errors/sdkvalidationerror.js';
import * as operations from '../models/operations/index.js';
import { APICall, APIPromise } from '../types/async.js';
import { Result } from '../types/fp.js';

/**
 * Delete a translation group
 *
 * @remarks
 * Delete an entire translation group and all its translations
 */
export function translationsGroupsDelete(
  client: NovuCore,
  resourceType: operations.ResourceType,
  resourceId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions
): APIPromise<
  Result<
    void,
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(client, resourceType, resourceId, idempotencyKey, options));
}

async function $do(
  client: NovuCore,
  resourceType: operations.ResourceType,
  resourceId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions
): Promise<
  [
    Result<
      void,
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.TranslationControllerDeleteTranslationGroupEndpointRequest = {
    resourceType: resourceType,
    resourceId: resourceId,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) => operations.TranslationControllerDeleteTranslationGroupEndpointRequest$outboundSchema.parse(value),
    'Input validation failed'
  );
  if (!parsed.ok) {
    return [parsed, { status: 'invalid' }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    resourceId: encodeSimple('resourceId', payload.resourceId, {
      explode: false,
      charEncoding: 'percent',
    }),
    resourceType: encodeSimple('resourceType', payload.resourceType, {
      explode: false,
      charEncoding: 'percent',
    }),
  };

  const path = pathToFunc('/v2/translations/{resourceType}/{resourceId}')(pathParams);

  const headers = new Headers(
    compactMap({
      Accept: '*/*',
      'idempotency-key': encodeSimple('idempotency-key', payload['idempotency-key'], {
        explode: false,
        charEncoding: 'none',
      }),
    })
  );

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? '',
    operationID: 'TranslationController_deleteTranslationGroupEndpoint',
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries ||
      client._options.retryConfig || {
        strategy: 'backoff',
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      } || { strategy: 'none' },
    retryCodes: options?.retryCodes || ['408', '409', '429', '5XX'],
  };

  const requestRes = client._createRequest(
    context,
    {
      security: requestSecurity,
      method: 'DELETE',
      baseURL: options?.serverURL,
      path: path,
      headers: headers,
      body: body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
    },
    options
  );
  if (!requestRes.ok) {
    return [requestRes, { status: 'invalid' }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: ['404', '4XX', '5XX'],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: 'request-error', request: req }];
  }
  const response = doResult.value;

  const [result] = await M.match<
    void,
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.nil(204, z.void()),
    M.fail([404, '4XX']),
    M.fail('5XX')
  )(response, req);
  if (!result.ok) {
    return [result, { status: 'complete', request: req, response }];
  }

  return [result, { status: 'complete', request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - translationsGroupsDelete(client: NovuCore,
  resourceType: operations.ResourceType,
  resourceId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions)
 - $do(client: NovuCore,
  resourceType: operations.ResourceType,
  resourceId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function translationsGroupsDelete

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/translationsGroupsRetrieve.ts
Tamaño: 5733 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Retrieve a translation group
 *
 * @remarks
 * Retrieves a single translation group by resource type (workflow, layout) and resource ID (workflowId, layoutId)
 */
export function translationsGroupsRetrieve(
  client: NovuCore,
  resourceType:
    operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
  resourceId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    components.TranslationGroupDto,
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    resourceType,
    resourceId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  resourceType:
    operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
  resourceId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      components.TranslationGroupDto,
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input:
    operations.TranslationControllerGetTranslationGroupEndpointRequest = {
      resourceType: resourceType,
      resourceId: resourceId,
      idempotencyKey: idempotencyKey,
    };

  const parsed = safeParse(
    input,
    (value) =>
      operations
        .TranslationControllerGetTranslationGroupEndpointRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    resourceId: encodeSimple("resourceId", payload.resourceId, {
      explode: false,
      charEncoding: "percent",
    }),
    resourceType: encodeSimple("resourceType", payload.resourceType, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v2/translations/group/{resourceType}/{resourceId}")(
    pathParams,
  );

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "TranslationController_getTranslationGroupEndpoint",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const [result] = await M.match<
    components.TranslationGroupDto,
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, components.TranslationGroupDto$inboundSchema),
    M.fail([404, "4XX"]),
    M.fail("5XX"),
  )(response, req);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - translationsGroupsRetrieve(client: NovuCore,
  resourceType:
    operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
  resourceId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  resourceType:
    operations.TranslationControllerGetTranslationGroupEndpointPathParamResourceType,
  resourceId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function translationsGroupsRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/translationsMasterImport.ts
Tamaño: 5407 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Import master translations JSON
 *
 * @remarks
 * Import translations for multiple workflows from master JSON format for a specific locale
 */
export function translationsMasterImport(
  client: NovuCore,
  importMasterJsonRequestDto: components.ImportMasterJsonRequestDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    components.ImportMasterJsonResponseDto,
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    importMasterJsonRequestDto,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  importMasterJsonRequestDto: components.ImportMasterJsonRequestDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      components.ImportMasterJsonResponseDto,
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.TranslationControllerImportMasterJsonEndpointRequest =
    {
      importMasterJsonRequestDto: importMasterJsonRequestDto,
      idempotencyKey: idempotencyKey,
    };

  const parsed = safeParse(
    input,
    (value) =>
      operations
        .TranslationControllerImportMasterJsonEndpointRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.ImportMasterJsonRequestDto, {
    explode: true,
  });

  const path = pathToFunc("/v2/translations/master-json")();

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "TranslationController_importMasterJsonEndpoint",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const [result] = await M.match<
    components.ImportMasterJsonResponseDto,
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, components.ImportMasterJsonResponseDto$inboundSchema),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - translationsMasterImport(client: NovuCore,
  importMasterJsonRequestDto: components.ImportMasterJsonRequestDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  importMasterJsonRequestDto: components.ImportMasterJsonRequestDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function translationsMasterImport

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/translationsMasterRetrieve.ts
Tamaño: 5242 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeFormQuery, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Retrieve master translations JSON
 *
 * @remarks
 * Retrieve all translations for a locale in master JSON format organized by resourceId (workflowId)
 */
export function translationsMasterRetrieve(
  client: NovuCore,
  locale?: string | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    components.GetMasterJsonResponseDto,
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    locale,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  locale?: string | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      components.GetMasterJsonResponseDto,
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.TranslationControllerGetMasterJsonEndpointRequest = {
    locale: locale,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations
        .TranslationControllerGetMasterJsonEndpointRequest$outboundSchema.parse(
          value,
        ),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const path = pathToFunc("/v2/translations/master-json")();

  const query = encodeFormQuery({
    "locale": payload.locale,
  });

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "TranslationController_getMasterJsonEndpoint",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    query: query,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const [result] = await M.match<
    components.GetMasterJsonResponseDto,
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, components.GetMasterJsonResponseDto$inboundSchema),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - translationsMasterRetrieve(client: NovuCore,
  locale?: string | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  locale?: string | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function translationsMasterRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/translationsMasterUpload.ts
Tamaño: 5110 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Upload master translations JSON file
 *
 * @remarks
 * Upload a master JSON file containing translations for multiple workflows. Locale is automatically detected from filename (e.g., en_US.json)
 */
export function translationsMasterUpload(
  client: NovuCore,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    components.ImportMasterJsonResponseDto,
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      components.ImportMasterJsonResponseDto,
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.TranslationControllerUploadMasterJsonEndpointRequest =
    {
      idempotencyKey: idempotencyKey,
    };

  const parsed = safeParse(
    input,
    (value) =>
      operations
        .TranslationControllerUploadMasterJsonEndpointRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const path = pathToFunc("/v2/translations/master-json/upload")();

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "TranslationController_uploadMasterJsonEndpoint",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const [result] = await M.match<
    components.ImportMasterJsonResponseDto,
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, components.ImportMasterJsonResponseDto$inboundSchema),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - translationsMasterUpload(client: NovuCore,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function translationsMasterUpload

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/translationsRetrieve.ts
Tamaño: 5367 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Retrieve a translation
 *
 * @remarks
 * Retrieve a specific translation by resource type, resource ID and locale
 */
export function translationsRetrieve(
  client: NovuCore,
  request: operations.TranslationControllerGetSingleTranslationRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    components.TranslationResponseDto,
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: NovuCore,
  request: operations.TranslationControllerGetSingleTranslationRequest,
  options?: RequestOptions,
): Promise<
  [
    Result<
      components.TranslationResponseDto,
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) =>
      operations.TranslationControllerGetSingleTranslationRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    locale: encodeSimple("locale", payload.locale, {
      explode: false,
      charEncoding: "percent",
    }),
    resourceId: encodeSimple("resourceId", payload.resourceId, {
      explode: false,
      charEncoding: "percent",
    }),
    resourceType: encodeSimple("resourceType", payload.resourceType, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc(
    "/v2/translations/{resourceType}/{resourceId}/{locale}",
  )(pathParams);

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "TranslationController_getSingleTranslation",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: ["404", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const [result] = await M.match<
    components.TranslationResponseDto,
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, components.TranslationResponseDto$inboundSchema),
    M.fail([404, "4XX"]),
    M.fail("5XX"),
  )(response, req);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - translationsRetrieve(client: NovuCore,
  request: operations.TranslationControllerGetSingleTranslationRequest,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  request: operations.TranslationControllerGetSingleTranslationRequest,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    request,
    (value))
Declaraciones 'export' encontradas:
- export function translationsRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/translationsUpload.ts
Tamaño: 5522 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { appendForm, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Upload translation files
 *
 * @remarks
 * Upload one or more JSON translation files for a specific workflow. Files name must match the locale, e.g. en_US.json
 */
export function translationsUpload(
  client: NovuCore,
  uploadTranslationsRequestDto: components.UploadTranslationsRequestDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    components.UploadTranslationsResponseDto,
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    uploadTranslationsRequestDto,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  uploadTranslationsRequestDto: components.UploadTranslationsRequestDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      components.UploadTranslationsResponseDto,
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.TranslationControllerUploadTranslationFilesRequest = {
    uploadTranslationsRequestDto: uploadTranslationsRequestDto,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations
        .TranslationControllerUploadTranslationFilesRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = new FormData();

  appendForm(
    body,
    "resourceId",
    payload.UploadTranslationsRequestDto.resourceId,
  );
  appendForm(
    body,
    "resourceType",
    payload.UploadTranslationsRequestDto.resourceType,
  );

  const path = pathToFunc("/v2/translations/upload")();

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "TranslationController_uploadTranslationFiles",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const [result] = await M.match<
    components.UploadTranslationsResponseDto,
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, components.UploadTranslationsResponseDto$inboundSchema),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - translationsUpload(client: NovuCore,
  uploadTranslationsRequestDto: components.UploadTranslationsRequestDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  uploadTranslationsRequestDto: components.UploadTranslationsRequestDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function translationsUpload

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/trigger.ts
Tamaño: 6790 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Trigger event
 *
 * @remarks
 *
 *     Trigger event is the main (and only) way to send notifications to subscribers. The trigger identifier is used to match the particular workflow associated with it. Additional information can be passed according the body interface below.
 *     To prevent duplicate triggers, you can optionally pass a **transactionId** in the request body. If the same **transactionId** is used again, the trigger will be ignored. The retention period depends on your billing tier.
 */
export function trigger(
  client: NovuCore,
  triggerEventRequestDto: components.TriggerEventRequestDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.EventsControllerTriggerResponse,
    | errors.PayloadValidationExceptionDto
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    triggerEventRequestDto,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  triggerEventRequestDto: components.TriggerEventRequestDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.EventsControllerTriggerResponse,
      | errors.PayloadValidationExceptionDto
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.EventsControllerTriggerRequest = {
    triggerEventRequestDto: triggerEventRequestDto,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.EventsControllerTriggerRequest$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.TriggerEventRequestDto, {
    explode: true,
  });

  const path = pathToFunc("/v1/events/trigger")();

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "EventsController_trigger",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.EventsControllerTriggerResponse,
    | errors.PayloadValidationExceptionDto
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(201, operations.EventsControllerTriggerResponse$inboundSchema, {
      hdrs: true,
      key: "Result",
    }),
    M.jsonErr(400, errors.PayloadValidationExceptionDto$inboundSchema, {
      hdrs: true,
    }),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - trigger(client: NovuCore,
  triggerEventRequestDto: components.TriggerEventRequestDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  triggerEventRequestDto: components.TriggerEventRequestDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function trigger

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/triggerBroadcast.ts
Tamaño: 6700 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Broadcast event to all
 *
 * @remarks
 * Trigger a broadcast event to all existing subscribers, could be used to send announcements, etc.
 *       In the future could be used to trigger events to a subset of subscribers based on defined filters.
 */
export function triggerBroadcast(
  client: NovuCore,
  triggerEventToAllRequestDto: components.TriggerEventToAllRequestDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.EventsControllerBroadcastEventToAllResponse,
    | errors.PayloadValidationExceptionDto
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    triggerEventToAllRequestDto,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  triggerEventToAllRequestDto: components.TriggerEventToAllRequestDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.EventsControllerBroadcastEventToAllResponse,
      | errors.PayloadValidationExceptionDto
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.EventsControllerBroadcastEventToAllRequest = {
    triggerEventToAllRequestDto: triggerEventToAllRequestDto,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.EventsControllerBroadcastEventToAllRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.TriggerEventToAllRequestDto, {
    explode: true,
  });

  const path = pathToFunc("/v1/events/trigger/broadcast")();

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "EventsController_broadcastEventToAll",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.EventsControllerBroadcastEventToAllResponse,
    | errors.PayloadValidationExceptionDto
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      [200, 201],
      operations.EventsControllerBroadcastEventToAllResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(400, errors.PayloadValidationExceptionDto$inboundSchema, {
      hdrs: true,
    }),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - triggerBroadcast(client: NovuCore,
  triggerEventToAllRequestDto: components.TriggerEventToAllRequestDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  triggerEventToAllRequestDto: components.TriggerEventToAllRequestDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function triggerBroadcast

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/triggerBulk.ts
Tamaño: 6503 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Bulk trigger event
 *
 * @remarks
 *
 *       Using this endpoint you can trigger multiple events at once, to avoid multiple calls to the API.
 *       The bulk API is limited to 100 events per request.
 */
export function triggerBulk(
  client: NovuCore,
  bulkTriggerEventDto: components.BulkTriggerEventDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.EventsControllerTriggerBulkResponse,
    | errors.PayloadValidationExceptionDto
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    bulkTriggerEventDto,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  bulkTriggerEventDto: components.BulkTriggerEventDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.EventsControllerTriggerBulkResponse,
      | errors.PayloadValidationExceptionDto
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.EventsControllerTriggerBulkRequest = {
    bulkTriggerEventDto: bulkTriggerEventDto,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.EventsControllerTriggerBulkRequest$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.BulkTriggerEventDto, {
    explode: true,
  });

  const path = pathToFunc("/v1/events/trigger/bulk")();

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "EventsController_triggerBulk",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.EventsControllerTriggerBulkResponse,
    | errors.PayloadValidationExceptionDto
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(201, operations.EventsControllerTriggerBulkResponse$inboundSchema, {
      hdrs: true,
      key: "Result",
    }),
    M.jsonErr(400, errors.PayloadValidationExceptionDto$inboundSchema, {
      hdrs: true,
    }),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - triggerBulk(client: NovuCore,
  bulkTriggerEventDto: components.BulkTriggerEventDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  bulkTriggerEventDto: components.BulkTriggerEventDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function triggerBulk

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/workflowsCreate.ts
Tamaño: 6114 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Create a workflow
 *
 * @remarks
 * Creates a new workflow in the Novu Cloud environment
 */
export function workflowsCreate(
  client: NovuCore,
  createWorkflowDto: components.CreateWorkflowDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.WorkflowControllerCreateResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    createWorkflowDto,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  createWorkflowDto: components.CreateWorkflowDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.WorkflowControllerCreateResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.WorkflowControllerCreateRequest = {
    createWorkflowDto: createWorkflowDto,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.WorkflowControllerCreateRequest$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.CreateWorkflowDto, { explode: true });

  const path = pathToFunc("/v2/workflows")();

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "WorkflowController_create",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.WorkflowControllerCreateResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(201, operations.WorkflowControllerCreateResponse$inboundSchema, {
      hdrs: true,
      key: "Result",
    }),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowsCreate(client: NovuCore,
  createWorkflowDto: components.CreateWorkflowDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  createWorkflowDto: components.CreateWorkflowDto,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function workflowsCreate

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/workflowsDelete.ts
Tamaño: 6156 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Delete a workflow
 *
 * @remarks
 * Removes a specific workflow by its unique identifier **workflowId**
 */
export function workflowsDelete(
  client: NovuCore,
  workflowId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.WorkflowControllerRemoveWorkflowResponse | undefined,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    workflowId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  workflowId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.WorkflowControllerRemoveWorkflowResponse | undefined,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.WorkflowControllerRemoveWorkflowRequest = {
    workflowId: workflowId,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.WorkflowControllerRemoveWorkflowRequest$outboundSchema.parse(
        value,
      ),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    workflowId: encodeSimple("workflowId", payload.workflowId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v2/workflows/{workflowId}")(pathParams);

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "WorkflowController_removeWorkflow",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "DELETE",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.WorkflowControllerRemoveWorkflowResponse | undefined,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.nil(
      204,
      operations.WorkflowControllerRemoveWorkflowResponse$inboundSchema
        .optional(),
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowsDelete(client: NovuCore,
  workflowId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  workflowId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function workflowsDelete

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/workflowsDuplicate.ts
Tamaño: 6597 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Duplicate a workflow
 *
 * @remarks
 * Duplicates a workflow by its unique identifier **workflowId**. This will create a new workflow with the same steps and settings.
 */
export function workflowsDuplicate(
  client: NovuCore,
  duplicateWorkflowDto: components.DuplicateWorkflowDto,
  workflowId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.WorkflowControllerDuplicateWorkflowResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    duplicateWorkflowDto,
    workflowId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  duplicateWorkflowDto: components.DuplicateWorkflowDto,
  workflowId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.WorkflowControllerDuplicateWorkflowResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.WorkflowControllerDuplicateWorkflowRequest = {
    duplicateWorkflowDto: duplicateWorkflowDto,
    workflowId: workflowId,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.WorkflowControllerDuplicateWorkflowRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.DuplicateWorkflowDto, {
    explode: true,
  });

  const pathParams = {
    workflowId: encodeSimple("workflowId", payload.workflowId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v2/workflows/{workflowId}/duplicate")(pathParams);

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "WorkflowController_duplicateWorkflow",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.WorkflowControllerDuplicateWorkflowResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      201,
      operations.WorkflowControllerDuplicateWorkflowResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowsDuplicate(client: NovuCore,
  duplicateWorkflowDto: components.DuplicateWorkflowDto,
  workflowId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  duplicateWorkflowDto: components.DuplicateWorkflowDto,
  workflowId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function workflowsDuplicate

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/workflowsGet.ts
Tamaño: 6373 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeFormQuery, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Retrieve a workflow
 *
 * @remarks
 * Fetches details of a specific workflow by its unique identifier **workflowId**
 */
export function workflowsGet(
  client: NovuCore,
  workflowId: string,
  environmentId?: string | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.WorkflowControllerGetWorkflowResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    workflowId,
    environmentId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  workflowId: string,
  environmentId?: string | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.WorkflowControllerGetWorkflowResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.WorkflowControllerGetWorkflowRequest = {
    workflowId: workflowId,
    environmentId: environmentId,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.WorkflowControllerGetWorkflowRequest$outboundSchema.parse(
        value,
      ),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    workflowId: encodeSimple("workflowId", payload.workflowId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v2/workflows/{workflowId}")(pathParams);

  const query = encodeFormQuery({
    "environmentId": payload.environmentId,
  });

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "WorkflowController_getWorkflow",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    query: query,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.WorkflowControllerGetWorkflowResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations.WorkflowControllerGetWorkflowResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowsGet(client: NovuCore,
  workflowId: string,
  environmentId?: string | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  workflowId: string,
  environmentId?: string | undefined,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function workflowsGet

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/workflowsList.ts
Tamaño: 6104 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeFormQuery, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * List all workflows
 *
 * @remarks
 * Retrieves a list of workflows with optional filtering and pagination
 */
export function workflowsList(
  client: NovuCore,
  request: operations.WorkflowControllerSearchWorkflowsRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.WorkflowControllerSearchWorkflowsResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: NovuCore,
  request: operations.WorkflowControllerSearchWorkflowsRequest,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.WorkflowControllerSearchWorkflowsResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) =>
      operations.WorkflowControllerSearchWorkflowsRequest$outboundSchema.parse(
        value,
      ),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const path = pathToFunc("/v2/workflows")();

  const query = encodeFormQuery({
    "limit": payload.limit,
    "offset": payload.offset,
    "orderBy": payload.orderBy,
    "orderDirection": payload.orderDirection,
    "query": payload.query,
    "status": payload.status,
    "tags": payload.tags,
  });

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "WorkflowController_searchWorkflows",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    query: query,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.WorkflowControllerSearchWorkflowsResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations.WorkflowControllerSearchWorkflowsResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowsList(client: NovuCore,
  request: operations.WorkflowControllerSearchWorkflowsRequest,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  request: operations.WorkflowControllerSearchWorkflowsRequest,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    request,
    (value))
Declaraciones 'export' encontradas:
- export function workflowsList

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/workflowsPatch.ts
Tamaño: 6462 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Update a workflow
 *
 * @remarks
 * Partially updates a workflow by its unique identifier **workflowId**
 */
export function workflowsPatch(
  client: NovuCore,
  patchWorkflowDto: components.PatchWorkflowDto,
  workflowId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.WorkflowControllerPatchWorkflowResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    patchWorkflowDto,
    workflowId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  patchWorkflowDto: components.PatchWorkflowDto,
  workflowId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.WorkflowControllerPatchWorkflowResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.WorkflowControllerPatchWorkflowRequest = {
    patchWorkflowDto: patchWorkflowDto,
    workflowId: workflowId,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.WorkflowControllerPatchWorkflowRequest$outboundSchema.parse(
        value,
      ),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.PatchWorkflowDto, { explode: true });

  const pathParams = {
    workflowId: encodeSimple("workflowId", payload.workflowId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v2/workflows/{workflowId}")(pathParams);

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "WorkflowController_patchWorkflow",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.WorkflowControllerPatchWorkflowResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations.WorkflowControllerPatchWorkflowResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowsPatch(client: NovuCore,
  patchWorkflowDto: components.PatchWorkflowDto,
  workflowId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  patchWorkflowDto: components.PatchWorkflowDto,
  workflowId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function workflowsPatch

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/workflowsStepsGeneratePreview.ts
Tamaño: 6294 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Generate step preview
 *
 * @remarks
 * Generates a preview for a specific workflow step by its unique identifier **stepId**
 */
export function workflowsStepsGeneratePreview(
  client: NovuCore,
  request: operations.WorkflowControllerGeneratePreviewRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.WorkflowControllerGeneratePreviewResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: NovuCore,
  request: operations.WorkflowControllerGeneratePreviewRequest,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.WorkflowControllerGeneratePreviewResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) =>
      operations.WorkflowControllerGeneratePreviewRequest$outboundSchema.parse(
        value,
      ),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.GeneratePreviewRequestDto, {
    explode: true,
  });

  const pathParams = {
    stepId: encodeSimple("stepId", payload.stepId, {
      explode: false,
      charEncoding: "percent",
    }),
    workflowId: encodeSimple("workflowId", payload.workflowId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v2/workflows/{workflowId}/step/{stepId}/preview")(
    pathParams,
  );

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "WorkflowController_generatePreview",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.WorkflowControllerGeneratePreviewResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      201,
      operations.WorkflowControllerGeneratePreviewResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowsStepsGeneratePreview(client: NovuCore,
  request: operations.WorkflowControllerGeneratePreviewRequest,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  request: operations.WorkflowControllerGeneratePreviewRequest,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    request,
    (value))
Declaraciones 'export' encontradas:
- export function workflowsStepsGeneratePreview

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/workflowsStepsRetrieve.ts
Tamaño: 6361 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Retrieve workflow step
 *
 * @remarks
 * Retrieves data for a specific step in a workflow
 */
export function workflowsStepsRetrieve(
  client: NovuCore,
  workflowId: string,
  stepId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.WorkflowControllerGetWorkflowStepDataResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    workflowId,
    stepId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  workflowId: string,
  stepId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.WorkflowControllerGetWorkflowStepDataResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.WorkflowControllerGetWorkflowStepDataRequest = {
    workflowId: workflowId,
    stepId: stepId,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.WorkflowControllerGetWorkflowStepDataRequest$outboundSchema
        .parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    stepId: encodeSimple("stepId", payload.stepId, {
      explode: false,
      charEncoding: "percent",
    }),
    workflowId: encodeSimple("workflowId", payload.workflowId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v2/workflows/{workflowId}/steps/{stepId}")(
    pathParams,
  );

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "WorkflowController_getWorkflowStepData",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.WorkflowControllerGetWorkflowStepDataResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations.WorkflowControllerGetWorkflowStepDataResponse$inboundSchema,
      { hdrs: true, key: "Result" },
    ),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowsStepsRetrieve(client: NovuCore,
  workflowId: string,
  stepId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  workflowId: string,
  stepId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function workflowsStepsRetrieve

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/workflowsSync.ts
Tamaño: 6347 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Sync a workflow
 *
 * @remarks
 * Synchronizes a workflow to the target environment
 */
export function workflowsSync(
  client: NovuCore,
  syncWorkflowDto: components.SyncWorkflowDto,
  workflowId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.WorkflowControllerSyncResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    syncWorkflowDto,
    workflowId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  syncWorkflowDto: components.SyncWorkflowDto,
  workflowId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.WorkflowControllerSyncResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.WorkflowControllerSyncRequest = {
    syncWorkflowDto: syncWorkflowDto,
    workflowId: workflowId,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.WorkflowControllerSyncRequest$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.SyncWorkflowDto, { explode: true });

  const pathParams = {
    workflowId: encodeSimple("workflowId", payload.workflowId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v2/workflows/{workflowId}/sync")(pathParams);

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "WorkflowController_sync",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PUT",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.WorkflowControllerSyncResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, operations.WorkflowControllerSyncResponse$inboundSchema, {
      hdrs: true,
      key: "Result",
    }),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowsSync(client: NovuCore,
  syncWorkflowDto: components.SyncWorkflowDto,
  workflowId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  syncWorkflowDto: components.SyncWorkflowDto,
  workflowId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function workflowsSync

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/funcs/workflowsUpdate.ts
Tamaño: 6425 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { NovuCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { NovuError } from "../models/errors/novuerror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Update a workflow
 *
 * @remarks
 * Updates the details of an existing workflow, here **workflowId** is the identifier of the workflow
 */
export function workflowsUpdate(
  client: NovuCore,
  updateWorkflowDto: components.UpdateWorkflowDto,
  workflowId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.WorkflowControllerUpdateResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    updateWorkflowDto,
    workflowId,
    idempotencyKey,
    options,
  ));
}

async function $do(
  client: NovuCore,
  updateWorkflowDto: components.UpdateWorkflowDto,
  workflowId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.WorkflowControllerUpdateResponse,
      | errors.ErrorDto
      | errors.ValidationErrorDto
      | NovuError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const input: operations.WorkflowControllerUpdateRequest = {
    updateWorkflowDto: updateWorkflowDto,
    workflowId: workflowId,
    idempotencyKey: idempotencyKey,
  };

  const parsed = safeParse(
    input,
    (value) =>
      operations.WorkflowControllerUpdateRequest$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.UpdateWorkflowDto, { explode: true });

  const pathParams = {
    workflowId: encodeSimple("workflowId", payload.workflowId, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/v2/workflows/{workflowId}")(pathParams);

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
    "idempotency-key": encodeSimple(
      "idempotency-key",
      payload["idempotency-key"],
      { explode: false, charEncoding: "none" },
    ),
  }));

  const securityInput = await extractSecurity(client._options.security);
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "WorkflowController_update",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 1000,
          maxInterval: 30000,
          exponent: 1.5,
          maxElapsedTime: 3600000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["408", "409", "429", "5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PUT",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "405",
      "409",
      "413",
      "414",
      "415",
      "422",
      "429",
      "4XX",
      "500",
      "503",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.WorkflowControllerUpdateResponse,
    | errors.ErrorDto
    | errors.ValidationErrorDto
    | NovuError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, operations.WorkflowControllerUpdateResponse$inboundSchema, {
      hdrs: true,
      key: "Result",
    }),
    M.jsonErr(414, errors.ErrorDto$inboundSchema),
    M.jsonErr(
      [400, 401, 403, 404, 405, 409, 413, 415],
      errors.ErrorDto$inboundSchema,
      { hdrs: true },
    ),
    M.jsonErr(422, errors.ValidationErrorDto$inboundSchema, { hdrs: true }),
    M.fail(429),
    M.jsonErr(500, errors.ErrorDto$inboundSchema, { hdrs: true }),
    M.fail(503),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - workflowsUpdate(client: NovuCore,
  updateWorkflowDto: components.UpdateWorkflowDto,
  workflowId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
 - $do(client: NovuCore,
  updateWorkflowDto: components.UpdateWorkflowDto,
  workflowId: string,
  idempotencyKey?: string | undefined,
  options?: RequestOptions,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - parsed(safeParse(
    input,
    (value))
Declaraciones 'export' encontradas:
- export function workflowsUpdate

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/hooks/hooks.ts
Tamaño: 3145 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { SDKOptions } from "../lib/config.js";
import { RequestInput } from "../lib/http.js";
import {
  AfterErrorContext,
  AfterErrorHook,
  AfterSuccessContext,
  AfterSuccessHook,
  BeforeCreateRequestContext,
  BeforeCreateRequestHook,
  BeforeRequestContext,
  BeforeRequestHook,
  Hook,
  Hooks,
  SDKInitHook,
} from "./types.js";

import { initHooks } from "./registration.js";

export class SDKHooks implements Hooks {
  sdkInitHooks: SDKInitHook[] = [];
  beforeCreateRequestHooks: BeforeCreateRequestHook[] = [];
  beforeRequestHooks: BeforeRequestHook[] = [];
  afterSuccessHooks: AfterSuccessHook[] = [];
  afterErrorHooks: AfterErrorHook[] = [];

  constructor() {
    const presetHooks: Array<Hook> = [];

    for (const hook of presetHooks) {
      if ("sdkInit" in hook) {
        this.registerSDKInitHook(hook);
      }
      if ("beforeCreateRequest" in hook) {
        this.registerBeforeCreateRequestHook(hook);
      }
      if ("beforeRequest" in hook) {
        this.registerBeforeRequestHook(hook);
      }
      if ("afterSuccess" in hook) {
        this.registerAfterSuccessHook(hook);
      }
      if ("afterError" in hook) {
        this.registerAfterErrorHook(hook);
      }
    }
    initHooks(this);
  }

  registerSDKInitHook(hook: SDKInitHook) {
    this.sdkInitHooks.push(hook);
  }

  registerBeforeCreateRequestHook(hook: BeforeCreateRequestHook) {
    this.beforeCreateRequestHooks.push(hook);
  }

  registerBeforeRequestHook(hook: BeforeRequestHook) {
    this.beforeRequestHooks.push(hook);
  }

  registerAfterSuccessHook(hook: AfterSuccessHook) {
    this.afterSuccessHooks.push(hook);
  }

  registerAfterErrorHook(hook: AfterErrorHook) {
    this.afterErrorHooks.push(hook);
  }

  sdkInit(opts: SDKOptions): SDKOptions {
    return this.sdkInitHooks.reduce((opts, hook) => hook.sdkInit(opts), opts);
  }

  beforeCreateRequest(
    hookCtx: BeforeCreateRequestContext,
    input: RequestInput,
  ): RequestInput {
    let inp = input;

    for (const hook of this.beforeCreateRequestHooks) {
      inp = hook.beforeCreateRequest(hookCtx, inp);
    }

    return inp;
  }

  async beforeRequest(
    hookCtx: BeforeRequestContext,
    request: Request,
  ): Promise<Request> {
    let req = request;

    for (const hook of this.beforeRequestHooks) {
      req = await hook.beforeRequest(hookCtx, req);
    }

    return req;
  }

  async afterSuccess(
    hookCtx: AfterSuccessContext,
    response: Response,
  ): Promise<Response> {
    let res = response;

    for (const hook of this.afterSuccessHooks) {
      res = await hook.afterSuccess(hookCtx, res);
    }

    return res;
  }

  async afterError(
    hookCtx: AfterErrorContext,
    response: Response | null,
    error: unknown,
  ): Promise<{ response: Response | null; error: unknown }> {
    let res = response;
    let err = error;

    for (const hook of this.afterErrorHooks) {
      const result = await hook.afterError(hookCtx, res, err);
      res = result.response;
      err = result.error;
    }

    return { response: res, error: err };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SDKHooks

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/hooks/index.ts
Tamaño: 133 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

export * from "./hooks.js";
export * from "./types.js";


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/hooks/novu-custom-hook.ts
Tamaño: 3129 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { RequestInput } from "../lib/http.js";
import {
  AfterSuccessContext,
  AfterSuccessHook,
  BeforeCreateRequestHook,
  BeforeRequestContext,
  BeforeRequestHook,
  HookContext
} from "./types.js";

export class NovuCustomHook
    implements BeforeRequestHook, AfterSuccessHook, BeforeCreateRequestHook {
    beforeCreateRequest(_hookCtx: HookContext, input: RequestInput): RequestInput {
        const idempotencyKey = 'idempotency-key';
        const headers = input.options?.headers
        if (!headers) {
            return input
        }
        const updatedHeaders = this.updateHeaderValue(headers, idempotencyKey, this.generateIdempotencyKey)

        return {...input, options: {...input.options, headers: updatedHeaders}}
    }

    beforeRequest(_hookCtx: BeforeRequestContext, request: Request): Request {
        const authKey = 'authorization';
        const hasAuthorization = request.headers.has(authKey);
        const apiKeyPrefix = 'ApiKey';
        const bearer = 'Bearer';
        if (hasAuthorization) {
            const key = request.headers.get(authKey);

            if (key && !key.includes(apiKeyPrefix) && !key.includes(bearer)  ) {
                request.headers.set(authKey, `${apiKeyPrefix} ${key}`)
            }
        }

        return request;
    }

    private generateIdempotencyKey(): string {
        const timestamp = Date.now();
        const randomString = Math.random().toString(36).substr(2, 9); // Generates a random alphanumeric string
        return `${timestamp}${randomString}`.trim(); // Trim any potential whitespace
    }

    async afterSuccess(_hookCtx: AfterSuccessContext, response: Response): Promise<Response> {
        const responseAsText = await response.clone().text();
        const contentType = response.headers.get('content-type') || '';
        if (!responseAsText || responseAsText == '' || contentType.includes('text/html')) {
            return response;
        }
        const jsonResponse = await response.clone().json();

        if (jsonResponse && Object.keys(jsonResponse).length === 1 && 'data' in jsonResponse) {
            return new Response(JSON.stringify(jsonResponse.data), {
                status: response.status,
                statusText: response.statusText,
                headers: response.headers,
            }); // Return the new Response object
        }

        return response;
    }

    private updateHeaderValue(
        headers: HeadersInit,
        key: string,
        defaultValueFunction: () => string
    ): Record<string, string> {
        const headersRecord = this.convertToRecord(headers);

        if (!(key in headersRecord) || headersRecord[key] == '') {
            headersRecord[key] = defaultValueFunction();
        }

        return headersRecord;
    }

    private convertToRecord(headers: HeadersInit): Record<string, string> {
        if (Array.isArray(headers)) {
            return Object.fromEntries(headers);
        } else if (headers instanceof Headers) {
            return Object.fromEntries(headers.entries());
        } else {
            return {...headers};
        }
    }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class NovuCustomHook

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/hooks/registration.ts
Tamaño: 580 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Hooks } from "./types.js";
import {NovuCustomHook} from "./novu-custom-hook.js";

/*
 * This file is only ever generated once on the first generation and then is free to be modified.
 * Any hooks you wish to add should be registered in the initHooks function. Feel free to define them
 * in this file or in separate files in the hooks folder.
 */

export function initHooks(hooks: Hooks) {
    hooks.registerAfterSuccessHook(new NovuCustomHook())
    hooks.registerBeforeRequestHook(new NovuCustomHook())
    hooks.registerBeforeCreateRequestHook(new NovuCustomHook())
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - initHooks(hooks: Hooks)
Declaraciones 'export' encontradas:
- export function initHooks

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/hooks/types.ts
Tamaño: 3512 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { SDKOptions } from "../lib/config.js";
import { RequestInput } from "../lib/http.js";
import { RetryConfig } from "../lib/retries.js";
import { SecurityState } from "../lib/security.js";

export type HookContext = {
  baseURL: string | URL;
  operationID: string;
  oAuth2Scopes: string[] | null;
  securitySource?: any | (() => Promise<any>);
  retryConfig: RetryConfig;
  resolvedSecurity: SecurityState | null;
  options: SDKOptions;
};

export type Awaitable<T> = T | Promise<T>;

export type BeforeCreateRequestContext = HookContext & {};
export type BeforeRequestContext = HookContext & {};
export type AfterSuccessContext = HookContext & {};
export type AfterErrorContext = HookContext & {};

/**
 * SDKInitHook is called when the SDK is initializing. The
 * hook can return a new baseURL and HTTP client to be used by the SDK.
 */
export interface SDKInitHook {
  sdkInit: (opts: SDKOptions) => SDKOptions;
}

export interface BeforeCreateRequestHook {
  /**
   * A hook that is called before the SDK creates a `Request` object. The hook
   * can modify how a request is constructed since certain modifications, like
   * changing the request URL, cannot be done on a request object directly.
   */
  beforeCreateRequest: (
    hookCtx: BeforeCreateRequestContext,
    input: RequestInput,
  ) => RequestInput;
}

export interface BeforeRequestHook {
  /**
   * A hook that is called before the SDK sends a request. The hook can
   * introduce instrumentation code such as logging, tracing and metrics or
   * replace the request before it is sent or throw an error to stop the
   * request from being sent.
   */
  beforeRequest: (
    hookCtx: BeforeRequestContext,
    request: Request,
  ) => Awaitable<Request>;
}

export interface AfterSuccessHook {
  /**
   * A hook that is called after the SDK receives a response. The hook can
   * introduce instrumentation code such as logging, tracing and metrics or
   * modify the response before it is handled or throw an error to stop the
   * response from being handled.
   */
  afterSuccess: (
    hookCtx: AfterSuccessContext,
    response: Response,
  ) => Awaitable<Response>;
}

export interface AfterErrorHook {
  /**
   * A hook that is called after the SDK encounters an error, or a
   * non-successful response. The hook can introduce instrumentation code such
   * as logging, tracing and metrics or modify the response or error values.
   */
  afterError: (
    hookCtx: AfterErrorContext,
    response: Response | null,
    error: unknown,
  ) => Awaitable<{
    response: Response | null;
    error: unknown;
  }>;
}

export interface Hooks {
  /** Registers a hook to be used by the SDK for initialization event. */
  registerSDKInitHook(hook: SDKInitHook): void;
  /** Registers a hook to be used by the SDK for to modify `Request` construction. */
  registerBeforeCreateRequestHook(hook: BeforeCreateRequestHook): void;
  /** Registers a hook to be used by the SDK for the before request event. */
  registerBeforeRequestHook(hook: BeforeRequestHook): void;
  /** Registers a hook to be used by the SDK for the after success event. */
  registerAfterSuccessHook(hook: AfterSuccessHook): void;
  /** Registers a hook to be used by the SDK for the after error event. */
  registerAfterErrorHook(hook: AfterErrorHook): void;
}

export type Hook =
  | SDKInitHook
  | BeforeCreateRequestHook
  | BeforeRequestHook
  | AfterSuccessHook
  | AfterErrorHook;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - HookContext({
  baseURL: string | URL;
  operationID: string;
  oAuth2Scopes: string[] | null;
  securitySource?...)
 - AfterErrorContext(HookContext & {};

/**
 * SDKInitHook is called when the SDK is initializing. The
 * hook can return...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  interface
- export  interface
- export  interface
- export  interface
- export  interface
- export  interface
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/lib/base64.ts
Tamaño: 955 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';

export function bytesToBase64(u8arr: Uint8Array): string {
  return btoa(String.fromCodePoint(...u8arr));
}

export function bytesFromBase64(encoded: string): Uint8Array {
  return Uint8Array.from(atob(encoded), (c) => c.charCodeAt(0));
}

export function stringToBytes(str: string): Uint8Array {
  return new TextEncoder().encode(str);
}

export function stringFromBytes(u8arr: Uint8Array): string {
  return new TextDecoder().decode(u8arr);
}

export function stringToBase64(str: string): string {
  return bytesToBase64(stringToBytes(str));
}

export function stringFromBase64(b64str: string): string {
  return stringFromBytes(bytesFromBase64(b64str));
}

export const zodOutbound = z.instanceof(Uint8Array).or(z.string().transform(stringToBytes));

export const zodInbound = z.instanceof(Uint8Array).or(z.string().transform(bytesFromBase64));


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - bytesToBase64(u8arr: Uint8Array)
 - bytesFromBase64(encoded: string)
 - stringToBytes(str: string)
 - stringFromBytes(u8arr: Uint8Array)
 - stringToBase64(str: string)
 - stringFromBase64(b64str: string)
Declaraciones 'export' encontradas:
- export function bytesToBase64
- export function bytesFromBase64
- export function stringToBytes
- export function stringFromBytes
- export function stringToBase64
- export function stringFromBase64
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/lib/config.ts
Tamaño: 1809 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as components from '../models/components/index.js';
import { HTTPClient } from './http.js';
import { Logger } from './logger.js';
import { RetryConfig } from './retries.js';
import { Params, pathToFunc } from './url.js';

/**
 * Contains the list of servers available to the SDK
 */
export const ServerList = ['https://api.novu.co', 'https://eu.api.novu.co'] as const;

export type SDKOptions = {
  /**
   * The security details required to authenticate the SDK
   */
  security?: components.Security | (() => Promise<components.Security>) | undefined;

  httpClient?: HTTPClient;
  /**
   * Allows overriding the default server used by the SDK
   */
  serverIdx?: number | undefined;
  /**
   * Allows overriding the default server URL used by the SDK
   */
  serverURL?: string | undefined;
  /**
   * Allows overriding the default user agent used by the SDK
   */
  userAgent?: string | undefined;
  /**
   * Allows overriding the default retry config used by the SDK
   */
  retryConfig?: RetryConfig;
  timeoutMs?: number;
  debugLogger?: Logger;
};

export function serverURLFromOptions(options: SDKOptions): URL | null {
  let serverURL = options.serverURL;

  const params: Params = {};

  if (!serverURL) {
    const serverIdx = options.serverIdx ?? 0;
    if (serverIdx < 0 || serverIdx >= ServerList.length) {
      throw new Error(`Invalid server index ${serverIdx}`);
    }
    serverURL = ServerList[serverIdx] || '';
  }

  const u = pathToFunc(serverURL)(params);
  return new URL(u);
}

export const SDK_METADATA = {
  language: 'typescript',
  openapiDocVersion: '3.9.0',
  sdkVersion: '0.1.21',
  genVersion: '2.729.2',
  userAgent: 'speakeasy-sdk/typescript 0.1.21 2.729.2 3.9.0 @novu/api',
} as const;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - serverURLFromOptions(options: SDKOptions)
Asignaciones con arrow functions encontradas (posibles funciones):
 - SDKOptions({
  /**
   * The security details required to authenticate the SDK
   */
  security?: components.Sec...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export function serverURLFromOptions
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/lib/dlv.ts
Tamaño: 1838 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

/*
MIT License

Copyright (c) 2024 Jason Miller <jason@developit.ca> (http://jasonformat.com)

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

/**
 * @param obj The object to walk
 * @param key The key path to walk the object with
 * @param def A default value to return if the result is undefined
 *
 * @example
 * dlv(obj, "a.b.c.d")
 * @example
 * dlv(object, ["a", "b", "c", "d"])
 * @example
 * dlv(object, "foo.bar.baz", "Hello, default value!")
 */
export function dlv<T = any>(
  obj: any,
  key: string | string[],
  def?: T,
  p?: number,
  undef?: never,
): T | undefined {
  key = Array.isArray(key) ? key : key.split(".");
  for (p = 0; p < key.length; p++) {
    const k = key[p];
    obj = k != null && obj ? obj[k] : undef;
  }
  return obj === undef ? def : obj;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export function dlv

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/lib/encodings.ts
Tamaño: 11863 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { bytesToBase64 } from "./base64.js";
import { isPlainObject } from "./is-plain-object.js";

export class EncodingError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "EncodingError";
  }
}

export function encodeMatrix(
  key: string,
  value: unknown,
  options?: { explode?: boolean; charEncoding?: "percent" | "none" },
): string | undefined {
  let out = "";
  const pairs: [string, unknown][] = options?.explode
    ? explode(key, value)
    : [[key, value]];

  if (pairs.every(([_, v]) => v == null)) {
    return;
  }

  const encodeString = (v: string) => {
    return options?.charEncoding === "percent" ? encodeURIComponent(v) : v;
  };
  const encodeValue = (v: unknown) => encodeString(serializeValue(v));

  pairs.forEach(([pk, pv]) => {
    let tmp = "";
    let encValue: string | null | undefined = null;

    if (pv == null) {
      return;
    } else if (Array.isArray(pv)) {
      encValue = mapDefined(pv, (v) => `${encodeValue(v)}`)?.join(",");
    } else if (isPlainObject(pv)) {
      const mapped = mapDefinedEntries(Object.entries(pv), ([k, v]) => {
        return `,${encodeString(k)},${encodeValue(v)}`;
      });
      encValue = mapped?.join("").slice(1);
    } else {
      encValue = `${encodeValue(pv)}`;
    }

    if (encValue == null) {
      return;
    }

    const keyPrefix = encodeString(pk);
    tmp = `${keyPrefix}=${encValue}`;
    // trim trailing '=' if value was empty
    if (tmp === `${keyPrefix}=`) {
      tmp = tmp.slice(0, -1);
    }

    // If we end up with the nothing then skip forward
    if (!tmp) {
      return;
    }

    out += `;${tmp}`;
  });

  return out;
}

export function encodeLabel(
  key: string,
  value: unknown,
  options?: { explode?: boolean; charEncoding?: "percent" | "none" },
): string | undefined {
  let out = "";
  const pairs: [string, unknown][] = options?.explode
    ? explode(key, value)
    : [[key, value]];

  if (pairs.every(([_, v]) => v == null)) {
    return;
  }

  const encodeString = (v: string) => {
    return options?.charEncoding === "percent" ? encodeURIComponent(v) : v;
  };
  const encodeValue = (v: unknown) => encodeString(serializeValue(v));

  pairs.forEach(([pk, pv]) => {
    let encValue: string | null | undefined = "";

    if (pv == null) {
      return;
    } else if (Array.isArray(pv)) {
      encValue = mapDefined(pv, (v) => `${encodeValue(v)}`)?.join(".");
    } else if (isPlainObject(pv)) {
      const mapped = mapDefinedEntries(Object.entries(pv), ([k, v]) => {
        return `.${encodeString(k)}.${encodeValue(v)}`;
      });
      encValue = mapped?.join("").slice(1);
    } else {
      const k =
        options?.explode && isPlainObject(value) ? `${encodeString(pk)}=` : "";
      encValue = `${k}${encodeValue(pv)}`;
    }

    out += encValue == null ? "" : `.${encValue}`;
  });

  return out;
}

type FormEncoder = (
  key: string,
  value: unknown,
  options?: { explode?: boolean; charEncoding?: "percent" | "none" },
) => string | undefined;

function formEncoder(sep: string): FormEncoder {
  return (
    key: string,
    value: unknown,
    options?: { explode?: boolean; charEncoding?: "percent" | "none" },
  ) => {
    let out = "";
    const pairs: [string, unknown][] = options?.explode
      ? explode(key, value)
      : [[key, value]];

    if (pairs.every(([_, v]) => v == null)) {
      return;
    }

    const encodeString = (v: string) => {
      return options?.charEncoding === "percent" ? encodeURIComponent(v) : v;
    };

    const encodeValue = (v: unknown) => encodeString(serializeValue(v));

    const encodedSep = encodeString(sep);

    pairs.forEach(([pk, pv]) => {
      let tmp = "";
      let encValue: string | null | undefined = null;

      if (pv == null) {
        return;
      } else if (Array.isArray(pv)) {
        encValue = mapDefined(pv, (v) => `${encodeValue(v)}`)?.join(encodedSep);
      } else if (isPlainObject(pv)) {
        encValue = mapDefinedEntries(Object.entries(pv), ([k, v]) => {
          return `${encodeString(k)}${encodedSep}${encodeValue(v)}`;
        })?.join(encodedSep);
      } else {
        encValue = `${encodeValue(pv)}`;
      }

      if (encValue == null) {
        return;
      }

      tmp = `${encodeString(pk)}=${encValue}`;

      // If we end up with the nothing then skip forward
      if (!tmp || tmp === "=") {
        return;
      }

      out += `&${tmp}`;
    });

    return out.slice(1);
  };
}

export const encodeForm = formEncoder(",");
export const encodeSpaceDelimited = formEncoder(" ");
export const encodePipeDelimited = formEncoder("|");

export function encodeBodyForm(
  key: string,
  value: unknown,
  options?: { explode?: boolean; charEncoding?: "percent" | "none" },
): string {
  let out = "";
  const pairs: [string, unknown][] = options?.explode
    ? explode(key, value)
    : [[key, value]];

  const encodeString = (v: string) => {
    return options?.charEncoding === "percent" ? encodeURIComponent(v) : v;
  };

  const encodeValue = (v: unknown) => encodeString(serializeValue(v));

  pairs.forEach(([pk, pv]) => {
    let tmp = "";
    let encValue = "";

    if (pv == null) {
      return;
    } else if (Array.isArray(pv)) {
      encValue = JSON.stringify(pv, jsonReplacer);
    } else if (isPlainObject(pv)) {
      encValue = JSON.stringify(pv, jsonReplacer);
    } else {
      encValue = `${encodeValue(pv)}`;
    }

    tmp = `${encodeString(pk)}=${encValue}`;

    // If we end up with the nothing then skip forward
    if (!tmp || tmp === "=") {
      return;
    }

    out += `&${tmp}`;
  });

  return out.slice(1);
}

export function encodeDeepObject(
  key: string,
  value: unknown,
  options?: { charEncoding?: "percent" | "none" },
): string | undefined {
  if (value == null) {
    return;
  }

  if (!isPlainObject(value)) {
    throw new EncodingError(
      `Value of parameter '${key}' which uses deepObject encoding must be an object or null`,
    );
  }

  return encodeDeepObjectObject(key, value, options);
}

export function encodeDeepObjectObject(
  key: string,
  value: unknown,
  options?: { charEncoding?: "percent" | "none" },
): string | undefined {
  if (value == null) {
    return;
  }

  let out = "";

  const encodeString = (v: string) => {
    return options?.charEncoding === "percent" ? encodeURIComponent(v) : v;
  };

  if (!isPlainObject(value)) {
    throw new EncodingError(`Expected parameter '${key}' to be an object.`);
  }

  Object.entries(value).forEach(([ck, cv]) => {
    if (cv == null) {
      return;
    }

    const pk = `${key}[${ck}]`;

    if (isPlainObject(cv)) {
      const objOut = encodeDeepObjectObject(pk, cv, options);

      out += objOut == null ? "" : `&${objOut}`;

      return;
    }

    const pairs: unknown[] = Array.isArray(cv) ? cv : [cv];
    const encoded = mapDefined(pairs, (v) => {
      return `${encodeString(pk)}=${encodeString(serializeValue(v))}`;
    })?.join("&");

    out += encoded == null ? "" : `&${encoded}`;
  });

  return out.slice(1);
}

export function encodeJSON(
  key: string,
  value: unknown,
  options?: { explode?: boolean; charEncoding?: "percent" | "none" },
): string | undefined {
  if (typeof value === "undefined") {
    return;
  }

  const encodeString = (v: string) => {
    return options?.charEncoding === "percent" ? encodeURIComponent(v) : v;
  };

  const encVal = encodeString(JSON.stringify(value, jsonReplacer));

  return options?.explode ? encVal : `${encodeString(key)}=${encVal}`;
}

export const encodeSimple = (
  key: string,
  value: unknown,
  options?: { explode?: boolean; charEncoding?: "percent" | "none" },
): string | undefined => {
  let out = "";
  const pairs: [string, unknown][] = options?.explode
    ? explode(key, value)
    : [[key, value]];

  if (pairs.every(([_, v]) => v == null)) {
    return;
  }

  const encodeString = (v: string) => {
    return options?.charEncoding === "percent" ? encodeURIComponent(v) : v;
  };
  const encodeValue = (v: unknown) => encodeString(serializeValue(v));

  pairs.forEach(([pk, pv]) => {
    let tmp: string | null | undefined = "";

    if (pv == null) {
      return;
    } else if (Array.isArray(pv)) {
      tmp = mapDefined(pv, (v) => `${encodeValue(v)}`)?.join(",");
    } else if (isPlainObject(pv)) {
      const mapped = mapDefinedEntries(Object.entries(pv), ([k, v]) => {
        return `,${encodeString(k)},${encodeValue(v)}`;
      });
      tmp = mapped?.join("").slice(1);
    } else {
      const k = options?.explode && isPlainObject(value) ? `${pk}=` : "";
      tmp = `${k}${encodeValue(pv)}`;
    }

    out += tmp ? `,${tmp}` : "";
  });

  return out.slice(1);
};

function explode(key: string, value: unknown): [string, unknown][] {
  if (Array.isArray(value)) {
    return value.map((v) => [key, v]);
  } else if (isPlainObject(value)) {
    const o = value ?? {};
    return Object.entries(o).map(([k, v]) => [k, v]);
  } else {
    return [[key, value]];
  }
}

function serializeValue(value: unknown): string {
  if (value == null) {
    return "";
  } else if (value instanceof Date) {
    return value.toISOString();
  } else if (value instanceof Uint8Array) {
    return bytesToBase64(value);
  } else if (typeof value === "object") {
    return JSON.stringify(value, jsonReplacer);
  }

  return `${value}`;
}

function jsonReplacer(_: string, value: unknown): unknown {
  if (value instanceof Uint8Array) {
    return bytesToBase64(value);
  } else {
    return value;
  }
}

function mapDefined<T, R>(inp: T[], mapper: (v: T) => R): R[] | null {
  const res = inp.reduce<R[]>((acc, v) => {
    if (v == null) {
      return acc;
    }

    const m = mapper(v);
    if (m == null) {
      return acc;
    }

    acc.push(m);

    return acc;
  }, []);

  return res.length ? res : null;
}

function mapDefinedEntries<K, V, R>(
  inp: Iterable<[K, V]>,
  mapper: (v: [K, V]) => R,
): R[] | null {
  const acc: R[] = [];
  for (const [k, v] of inp) {
    if (v == null) {
      continue;
    }

    const m = mapper([k, v]);
    if (m == null) {
      continue;
    }

    acc.push(m);
  }

  return acc.length ? acc : null;
}

export function queryJoin(...args: (string | undefined)[]): string {
  return args.filter(Boolean).join("&");
}

type QueryEncoderOptions = {
  explode?: boolean;
  charEncoding?: "percent" | "none";
};

type QueryEncoder = (
  key: string,
  value: unknown,
  options?: QueryEncoderOptions,
) => string | undefined;

type BulkQueryEncoder = (
  values: Record<string, unknown>,
  options?: QueryEncoderOptions,
) => string;

export function queryEncoder(f: QueryEncoder): BulkQueryEncoder {
  const bulkEncode = function (
    values: Record<string, unknown>,
    options?: QueryEncoderOptions,
  ): string {
    const opts: QueryEncoderOptions = {
      ...options,
      explode: options?.explode ?? true,
      charEncoding: options?.charEncoding ?? "percent",
    };

    const encoded = Object.entries(values).map(([key, value]) => {
      return f(key, value, opts);
    });
    return queryJoin(...encoded);
  };

  return bulkEncode;
}

export const encodeJSONQuery = queryEncoder(encodeJSON);
export const encodeFormQuery = queryEncoder(encodeForm);
export const encodeSpaceDelimitedQuery = queryEncoder(encodeSpaceDelimited);
export const encodePipeDelimitedQuery = queryEncoder(encodePipeDelimited);
export const encodeDeepObjectQuery = queryEncoder(encodeDeepObject);

export function appendForm(
  fd: FormData,
  key: string,
  value: unknown,
  fileName?: string,
): void {
  if (value == null) {
    return;
  } else if (value instanceof Blob && fileName) {
    fd.append(key, value, fileName);
  } else if (value instanceof Blob) {
    fd.append(key, value);
  } else {
    fd.append(key, String(value));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - encodeMatrix(key: string,
  value: unknown,
  options?: { explode?: boolean; charEncoding?: "percent" | "none" },)
 - encodeLabel(key: string,
  value: unknown,
  options?: { explode?: boolean; charEncoding?: "percent" | "none" },)
 - formEncoder(sep: string)
 - encodeBodyForm(key: string,
  value: unknown,
  options?: { explode?: boolean; charEncoding?: "percent" | "none" },)
 - encodeDeepObject(key: string,
  value: unknown,
  options?: { charEncoding?: "percent" | "none" },)
 - encodeDeepObjectObject(key: string,
  value: unknown,
  options?: { charEncoding?: "percent" | "none" },)
 - encodeJSON(key: string,
  value: unknown,
  options?: { explode?: boolean; charEncoding?: "percent" | "none" },)
 - explode(key: string, value: unknown)
 - serializeValue(value: unknown)
 - jsonReplacer(_: string, value: unknown)
 - queryJoin(...args: (string | undefined)
 - queryEncoder(f: QueryEncoder)
 - appendForm(fd: FormData,
  key: string,
  value: unknown,
  fileName?: string,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - encodeString(v: string))
 - encodeValue(v: unknown))
 - encValue(mapDefined(pv, (v))
 - mapped(mapDefinedEntries(Object.entries(pv), ([k, v]))
 - encodeString(v: string))
 - encodeValue(v: unknown))
 - encValue(mapDefined(pv, (v))
 - mapped(mapDefinedEntries(Object.entries(pv), ([k, v]))
 - FormEncoder(key: string,
  value: unknown,
  options?: { explode?: boolean; charEncoding?: "percent" | "none" },...)
 - encodeString(v: string))
 - encodeValue(v: unknown))
 - encodedSep(encodeString(sep);

    pairs.forEach(([pk, pv]))
 - encValue(mapDefined(pv, (v))
 - encValue(mapDefinedEntries(Object.entries(pv), ([k, v]))
 - encodeString(v: string))
 - encodeValue(v: unknown))
 - encodeString(v: string))
 - encoded(mapDefined(pairs, (v))
 - encodeString(v: string))
 - encodeSimple(key: string,
  value: unknown,
  options?: { explode?: boolean; charEncoding?: "percent" | "none" },...)
 - encodeString(v: string))
 - encodeValue(v: unknown))
 - tmp(mapDefined(pv, (v))
 - mapped(mapDefinedEntries(Object.entries(pv), ([k, v]))
 - o(value ?? {};
    return Object.entries(o).map(([k, v]))
 - res(inp.reduce<R[]>((acc, v))
 - QueryEncoder(key: string,
  value: unknown,
  options?: QueryEncoderOptions,
))
 - BulkQueryEncoder(values: Record<string, unknown>,
  options?: QueryEncoderOptions,
))
 - encoded(Object.entries(values).map(([key, value]))
Declaraciones 'export' encontradas:
- export class EncodingError
- export function encodeMatrix
- export function encodeLabel
- export  const
- export  const
- export  const
- export function encodeBodyForm
- export function encodeDeepObject
- export function encodeDeepObjectObject
- export function encodeJSON
- export  const
- export function queryJoin
- export function queryEncoder
- export  const
- export  const
- export  const
- export  const
- export  const
- export function appendForm

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/lib/files.ts
Tamaño: 2059 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

/**
 * Consumes a stream and returns a concatenated array buffer. Useful in
 * situations where we need to read the whole file because it forms part of a
 * larger payload containing other fields, and we can't modify the underlying
 * request structure.
 */
export async function readableStreamToArrayBuffer(
  readable: ReadableStream<Uint8Array>,
): Promise<ArrayBuffer> {
  const reader = readable.getReader();
  const chunks: Uint8Array[] = [];

  let totalLength = 0;
  let done = false;

  while (!done) {
    const { value, done: doneReading } = await reader.read();

    if (doneReading) {
      done = true;
    } else {
      chunks.push(value);
      totalLength += value.length;
    }
  }

  const concatenatedChunks = new Uint8Array(totalLength);
  let offset = 0;

  for (const chunk of chunks) {
    concatenatedChunks.set(chunk, offset);
    offset += chunk.length;
  }

  return concatenatedChunks.buffer as ArrayBuffer;
}

/**
 * Determines the MIME content type based on a file's extension.
 * Returns null if the extension is not recognized.
 */
export function getContentTypeFromFileName(fileName: string): string | null {
  if (!fileName) return null;

  const ext = fileName.toLowerCase().split(".").pop();
  if (!ext) return null;

  const mimeTypes: Record<string, string> = {
    json: "application/json",
    xml: "application/xml",
    html: "text/html",
    htm: "text/html",
    txt: "text/plain",
    csv: "text/csv",
    pdf: "application/pdf",
    png: "image/png",
    jpg: "image/jpeg",
    jpeg: "image/jpeg",
    gif: "image/gif",
    svg: "image/svg+xml",
    js: "application/javascript",
    css: "text/css",
    zip: "application/zip",
    tar: "application/x-tar",
    gz: "application/gzip",
    mp4: "video/mp4",
    mp3: "audio/mpeg",
    wav: "audio/wav",
    webp: "image/webp",
    ico: "image/x-icon",
    woff: "font/woff",
    woff2: "font/woff2",
    ttf: "font/ttf",
    otf: "font/otf",
  };

  return mimeTypes[ext] || null;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - readableStreamToArrayBuffer(readable: ReadableStream<Uint8Array>,)
 - getContentTypeFromFileName(fileName: string)
Declaraciones 'export' encontradas:
- export  async
- export function getContentTypeFromFileName

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/lib/http.ts
Tamaño: 8875 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

export type Fetcher = (
  input: RequestInfo | URL,
  init?: RequestInit,
) => Promise<Response>;

export type Awaitable<T> = T | Promise<T>;

const DEFAULT_FETCHER: Fetcher = (input, init) => {
  // If input is a Request and init is undefined, Bun will discard the method,
  // headers, body and other options that were set on the request object.
  // Node.js and browers would ignore an undefined init value. This check is
  // therefore needed for interop with Bun.
  if (init == null) {
    return fetch(input);
  } else {
    return fetch(input, init);
  }
};

export type RequestInput = {
  /**
   * The URL the request will use.
   */
  url: URL;
  /**
   * Options used to create a [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request/Request).
   */
  options?: RequestInit | undefined;
};

export interface HTTPClientOptions {
  fetcher?: Fetcher;
}

export type BeforeRequestHook = (req: Request) => Awaitable<Request | void>;
export type RequestErrorHook = (err: unknown, req: Request) => Awaitable<void>;
export type ResponseHook = (res: Response, req: Request) => Awaitable<void>;

export class HTTPClient {
  private fetcher: Fetcher;
  private requestHooks: BeforeRequestHook[] = [];
  private requestErrorHooks: RequestErrorHook[] = [];
  private responseHooks: ResponseHook[] = [];

  constructor(private options: HTTPClientOptions = {}) {
    this.fetcher = options.fetcher || DEFAULT_FETCHER;
  }

  async request(request: Request): Promise<Response> {
    let req = request;
    for (const hook of this.requestHooks) {
      const nextRequest = await hook(req);
      if (nextRequest) {
        req = nextRequest;
      }
    }

    try {
      const res = await this.fetcher(req);

      for (const hook of this.responseHooks) {
        await hook(res, req);
      }

      return res;
    } catch (err) {
      for (const hook of this.requestErrorHooks) {
        await hook(err, req);
      }

      throw err;
    }
  }

  /**
   * Registers a hook that is called before a request is made. The hook function
   * can mutate the request or return a new request. This may be useful to add
   * additional information to request such as request IDs and tracing headers.
   */
  addHook(hook: "beforeRequest", fn: BeforeRequestHook): this;
  /**
   * Registers a hook that is called when a request cannot be made due to a
   * network error.
   */
  addHook(hook: "requestError", fn: RequestErrorHook): this;
  /**
   * Registers a hook that is called when a response has been received from the
   * server.
   */
  addHook(hook: "response", fn: ResponseHook): this;
  addHook(
    ...args:
      | [hook: "beforeRequest", fn: BeforeRequestHook]
      | [hook: "requestError", fn: RequestErrorHook]
      | [hook: "response", fn: ResponseHook]
  ) {
    if (args[0] === "beforeRequest") {
      this.requestHooks.push(args[1]);
    } else if (args[0] === "requestError") {
      this.requestErrorHooks.push(args[1]);
    } else if (args[0] === "response") {
      this.responseHooks.push(args[1]);
    } else {
      throw new Error(`Invalid hook type: ${args[0]}`);
    }
    return this;
  }

  /** Removes a hook that was previously registered with `addHook`. */
  removeHook(hook: "beforeRequest", fn: BeforeRequestHook): this;
  /** Removes a hook that was previously registered with `addHook`. */
  removeHook(hook: "requestError", fn: RequestErrorHook): this;
  /** Removes a hook that was previously registered with `addHook`. */
  removeHook(hook: "response", fn: ResponseHook): this;
  removeHook(
    ...args:
      | [hook: "beforeRequest", fn: BeforeRequestHook]
      | [hook: "requestError", fn: RequestErrorHook]
      | [hook: "response", fn: ResponseHook]
  ): this {
    let target: unknown[];
    if (args[0] === "beforeRequest") {
      target = this.requestHooks;
    } else if (args[0] === "requestError") {
      target = this.requestErrorHooks;
    } else if (args[0] === "response") {
      target = this.responseHooks;
    } else {
      throw new Error(`Invalid hook type: ${args[0]}`);
    }

    const index = target.findIndex((v) => v === args[1]);
    if (index >= 0) {
      target.splice(index, 1);
    }

    return this;
  }

  clone(): HTTPClient {
    const child = new HTTPClient(this.options);
    child.requestHooks = this.requestHooks.slice();
    child.requestErrorHooks = this.requestErrorHooks.slice();
    child.responseHooks = this.responseHooks.slice();

    return child;
  }
}

export type StatusCodePredicate = number | string | (number | string)[];

// A semicolon surrounded by optional whitespace characters is used to separate
// segments in a media type string.
const mediaParamSeparator = /\s*;\s*/g;

export function matchContentType(response: Response, pattern: string): boolean {
  // `*` is a special case which means anything is acceptable.
  if (pattern === "*") {
    return true;
  }

  let contentType =
    response.headers.get("content-type")?.trim() || "application/octet-stream";
  contentType = contentType.toLowerCase();

  const wantParts = pattern.toLowerCase().trim().split(mediaParamSeparator);
  const [wantType = "", ...wantParams] = wantParts;

  if (wantType.split("/").length !== 2) {
    return false;
  }

  const gotParts = contentType.split(mediaParamSeparator);
  const [gotType = "", ...gotParams] = gotParts;

  const [type = "", subtype = ""] = gotType.split("/");
  if (!type || !subtype) {
    return false;
  }

  if (
    wantType !== "*/*" &&
    gotType !== wantType &&
    `${type}/*` !== wantType &&
    `*/${subtype}` !== wantType
  ) {
    return false;
  }

  if (gotParams.length < wantParams.length) {
    return false;
  }

  const params = new Set(gotParams);
  for (const wantParam of wantParams) {
    if (!params.has(wantParam)) {
      return false;
    }
  }

  return true;
}

const codeRangeRE = new RegExp("^[0-9]xx$", "i");

export function matchStatusCode(
  response: Response,
  codes: StatusCodePredicate,
): boolean {
  const actual = `${response.status}`;
  const expectedCodes = Array.isArray(codes) ? codes : [codes];
  if (!expectedCodes.length) {
    return false;
  }

  return expectedCodes.some((ec) => {
    const code = `${ec}`;

    if (code === "default") {
      return true;
    }

    if (!codeRangeRE.test(`${code}`)) {
      return code === actual;
    }

    const expectFamily = code.charAt(0);
    if (!expectFamily) {
      throw new Error("Invalid status code range");
    }

    const actualFamily = actual.charAt(0);
    if (!actualFamily) {
      throw new Error(`Invalid response status code: ${actual}`);
    }

    return actualFamily === expectFamily;
  });
}

export function matchResponse(
  response: Response,
  code: StatusCodePredicate,
  contentTypePattern: string,
): boolean {
  return (
    matchStatusCode(response, code) &&
    matchContentType(response, contentTypePattern)
  );
}

/**
 * Uses various heurisitics to determine if an error is a connection error.
 */
export function isConnectionError(err: unknown): boolean {
  if (typeof err !== "object" || err == null) {
    return false;
  }

  // Covers fetch in Deno as well
  const isBrowserErr =
    err instanceof TypeError &&
    err.message.toLowerCase().startsWith("failed to fetch");

  const isNodeErr =
    err instanceof TypeError &&
    err.message.toLowerCase().startsWith("fetch failed");

  const isBunErr = "name" in err && err.name === "ConnectionError";

  const isGenericErr =
    "code" in err &&
    typeof err.code === "string" &&
    err.code.toLowerCase() === "econnreset";

  return isBrowserErr || isNodeErr || isGenericErr || isBunErr;
}

/**
 * Uses various heurisitics to determine if an error is a timeout error.
 */
export function isTimeoutError(err: unknown): boolean {
  if (typeof err !== "object" || err == null) {
    return false;
  }

  // Fetch in browser, Node.js, Bun, Deno
  const isNative = "name" in err && err.name === "TimeoutError";
  const isLegacyNative = "code" in err && err.code === 23;

  // Node.js HTTP client and Axios
  const isGenericErr =
    "code" in err &&
    typeof err.code === "string" &&
    err.code.toLowerCase() === "econnaborted";

  return isNative || isLegacyNative || isGenericErr;
}

/**
 * Uses various heurisitics to determine if an error is a abort error.
 */
export function isAbortError(err: unknown): boolean {
  if (typeof err !== "object" || err == null) {
    return false;
  }

  // Fetch in browser, Node.js, Bun, Deno
  const isNative = "name" in err && err.name === "AbortError";
  const isLegacyNative = "code" in err && err.code === 20;

  // Node.js HTTP client and Axios
  const isGenericErr =
    "code" in err &&
    typeof err.code === "string" &&
    err.code.toLowerCase() === "econnaborted";

  return isNative || isLegacyNative || isGenericErr;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - matchContentType(response: Response, pattern: string)
 - matchStatusCode(response: Response,
  codes: StatusCodePredicate,)
 - matchResponse(response: Response,
  code: StatusCodePredicate,
  contentTypePattern: string,)
 - isConnectionError(err: unknown)
 - isTimeoutError(err: unknown)
 - isAbortError(err: unknown)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Fetcher(input: RequestInfo | URL,
  init?: RequestInit,
))
 - Fetcher(input, init))
 - BeforeRequestHook(req: Request))
 - RequestErrorHook(err: unknown, req: Request))
 - ResponseHook(res: Response, req: Request))
 - index(target.findIndex((v))
 - expectedCodes(Array.isArray(codes) ? codes : [codes];
  if (!expectedCodes.length) {
    return false;
  }

  retu...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  interface
- export  type
- export  type
- export  type
- export class HTTPClient
- export  type
- export function matchContentType
- export function matchStatusCode
- export function matchResponse
- export function isConnectionError
- export function isTimeoutError
- export function isAbortError

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/lib/is-plain-object.ts
Tamaño: 1714 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

/*
MIT License

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

// Taken from https://github.com/sindresorhus/is-plain-obj/blob/97f38e8836f86a642cce98fc6ab3058bc36df181/index.js

export function isPlainObject(value: unknown): value is object {
  if (typeof value !== "object" || value === null) {
    return false;
  }

  const prototype = Object.getPrototypeOf(value);
  return (
    (prototype === null ||
      prototype === Object.prototype ||
      Object.getPrototypeOf(prototype) === null) &&
    !(Symbol.toStringTag in value) &&
    !(Symbol.iterator in value)
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - isPlainObject(value: unknown)
Declaraciones 'export' encontradas:
- export function isPlainObject

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/lib/logger.ts
Tamaño: 199 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

export interface Logger {
  group(label?: string): void;
  groupEnd(): void;
  log(message: any, ...args: any[]): void;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  interface

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/lib/matchers.ts
Tamaño: 8804 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKError } from "../models/errors/sdkerror.js";
import { ERR, OK, Result } from "../types/fp.js";
import { matchResponse, matchStatusCode, StatusCodePredicate } from "./http.js";
import { isPlainObject } from "./is-plain-object.js";

export type Encoding =
  | "jsonl"
  | "json"
  | "text"
  | "bytes"
  | "stream"
  | "sse"
  | "nil"
  | "fail";

const DEFAULT_CONTENT_TYPES: Record<Encoding, string> = {
  jsonl: "application/jsonl",
  json: "application/json",
  text: "text/plain",
  bytes: "application/octet-stream",
  stream: "application/octet-stream",
  sse: "text/event-stream",
  nil: "*",
  fail: "*",
};

type Schema<T> = { parse(raw: unknown): T };

type MatchOptions = {
  ctype?: string;
  hdrs?: boolean;
  key?: string;
  sseSentinel?: string;
};

export type ValueMatcher<V> = MatchOptions & {
  enc: Encoding;
  codes: StatusCodePredicate;
  schema: Schema<V>;
};

export type ErrorMatcher<E> = MatchOptions & {
  enc: Encoding;
  codes: StatusCodePredicate;
  schema: Schema<E>;
  err: true;
};

export type FailMatcher = {
  enc: "fail";
  codes: StatusCodePredicate;
};

export type Matcher<T, E> = ValueMatcher<T> | ErrorMatcher<E> | FailMatcher;

export function jsonErr<E>(
  codes: StatusCodePredicate,
  schema: Schema<E>,
  options?: MatchOptions,
): ErrorMatcher<E> {
  return { ...options, err: true, enc: "json", codes, schema };
}
export function json<T>(
  codes: StatusCodePredicate,
  schema: Schema<T>,
  options?: MatchOptions,
): ValueMatcher<T> {
  return { ...options, enc: "json", codes, schema };
}

export function jsonl<T>(
  codes: StatusCodePredicate,
  schema: Schema<T>,
  options?: MatchOptions,
): ValueMatcher<T> {
  return { ...options, enc: "jsonl", codes, schema };
}

export function jsonlErr<E>(
  codes: StatusCodePredicate,
  schema: Schema<E>,
  options?: MatchOptions,
): ErrorMatcher<E> {
  return { ...options, err: true, enc: "jsonl", codes, schema };
}
export function textErr<E>(
  codes: StatusCodePredicate,
  schema: Schema<E>,
  options?: MatchOptions,
): ErrorMatcher<E> {
  return { ...options, err: true, enc: "text", codes, schema };
}
export function text<T>(
  codes: StatusCodePredicate,
  schema: Schema<T>,
  options?: MatchOptions,
): ValueMatcher<T> {
  return { ...options, enc: "text", codes, schema };
}

export function bytesErr<E>(
  codes: StatusCodePredicate,
  schema: Schema<E>,
  options?: MatchOptions,
): ErrorMatcher<E> {
  return { ...options, err: true, enc: "bytes", codes, schema };
}
export function bytes<T>(
  codes: StatusCodePredicate,
  schema: Schema<T>,
  options?: MatchOptions,
): ValueMatcher<T> {
  return { ...options, enc: "bytes", codes, schema };
}

export function streamErr<E>(
  codes: StatusCodePredicate,
  schema: Schema<E>,
  options?: MatchOptions,
): ErrorMatcher<E> {
  return { ...options, err: true, enc: "stream", codes, schema };
}
export function stream<T>(
  codes: StatusCodePredicate,
  schema: Schema<T>,
  options?: MatchOptions,
): ValueMatcher<T> {
  return { ...options, enc: "stream", codes, schema };
}

export function sseErr<E>(
  codes: StatusCodePredicate,
  schema: Schema<E>,
  options?: MatchOptions,
): ErrorMatcher<E> {
  return { ...options, err: true, enc: "sse", codes, schema };
}
export function sse<T>(
  codes: StatusCodePredicate,
  schema: Schema<T>,
  options?: MatchOptions,
): ValueMatcher<T> {
  return { ...options, enc: "sse", codes, schema };
}

export function nilErr<E>(
  codes: StatusCodePredicate,
  schema: Schema<E>,
  options?: MatchOptions,
): ErrorMatcher<E> {
  return { ...options, err: true, enc: "nil", codes, schema };
}
export function nil<T>(
  codes: StatusCodePredicate,
  schema: Schema<T>,
  options?: MatchOptions,
): ValueMatcher<T> {
  return { ...options, enc: "nil", codes, schema };
}

export function fail(codes: StatusCodePredicate): FailMatcher {
  return { enc: "fail", codes };
}

export type MatchedValue<Matchers> = Matchers extends Matcher<infer T, any>[]
  ? T
  : never;
export type MatchedError<Matchers> = Matchers extends Matcher<any, infer E>[]
  ? E
  : never;
export type MatchFunc<T, E> = (
  response: Response,
  request: Request,
  options?: { resultKey?: string; extraFields?: Record<string, unknown> },
) => Promise<[result: Result<T, E>, raw: unknown]>;

export function match<T, E>(
  ...matchers: Array<Matcher<T, E>>
): MatchFunc<T, E | SDKError | ResponseValidationError> {
  return async function matchFunc(
    response: Response,
    request: Request,
    options?: { resultKey?: string; extraFields?: Record<string, unknown> },
  ): Promise<
    [result: Result<T, E | SDKError | ResponseValidationError>, raw: unknown]
  > {
    let raw: unknown;
    let matcher: Matcher<T, E> | undefined;
    for (const match of matchers) {
      const { codes } = match;
      const ctpattern = "ctype" in match
        ? match.ctype
        : DEFAULT_CONTENT_TYPES[match.enc];
      if (ctpattern && matchResponse(response, codes, ctpattern)) {
        matcher = match;
        break;
      } else if (!ctpattern && matchStatusCode(response, codes)) {
        matcher = match;
        break;
      }
    }

    if (!matcher) {
      return [{
        ok: false,
        error: new SDKError("Unexpected Status or Content-Type", {
          response,
          request,
          body: await response.text().catch(() => ""),
        }),
      }, raw];
    }

    const encoding = matcher.enc;
    let body = "";
    switch (encoding) {
      case "json":
        body = await response.text();
        raw = JSON.parse(body);
        break;
      case "jsonl":
        raw = response.body;
        break;
      case "bytes":
        raw = new Uint8Array(await response.arrayBuffer());
        break;
      case "stream":
        raw = response.body;
        break;
      case "text":
        body = await response.text();
        raw = body;
        break;
      case "sse":
        raw = response.body;
        break;
      case "nil":
        body = await response.text();
        raw = undefined;
        break;
      case "fail":
        body = await response.text();
        raw = body;
        break;
      default:
        encoding satisfies never;
        throw new Error(`Unsupported response type: ${encoding}`);
    }

    if (matcher.enc === "fail") {
      return [{
        ok: false,
        error: new SDKError("API error occurred", { request, response, body }),
      }, raw];
    }

    const resultKey = matcher.key || options?.resultKey;
    let data: unknown;

    if ("err" in matcher) {
      data = {
        ...options?.extraFields,
        ...(matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null),
        ...(isPlainObject(raw) ? raw : null),
        request$: request,
        response$: response,
        body$: body,
      };
    } else if (resultKey) {
      data = {
        ...options?.extraFields,
        ...(matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null),
        [resultKey]: raw,
      };
    } else if (matcher.hdrs) {
      data = {
        ...options?.extraFields,
        ...(matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null),
        ...(isPlainObject(raw) ? raw : null),
      };
    } else {
      data = raw;
    }

    if ("err" in matcher) {
      const result = safeParseResponse(
        data,
        (v: unknown) => matcher.schema.parse(v),
        "Response validation failed",
        { request, response, body },
      );
      return [result.ok ? { ok: false, error: result.value } : result, raw];
    } else {
      return [
        safeParseResponse(
          data,
          (v: unknown) => matcher.schema.parse(v),
          "Response validation failed",
          { request, response, body },
        ),
        raw,
      ];
    }
  };
}

const headerValRE = /, */;
/**
 * Iterates over a Headers object and returns an object with all the header
 * entries. Values are represented as an array to account for repeated headers.
 */
export function unpackHeaders(headers: Headers): Record<string, string[]> {
  const out: Record<string, string[]> = {};

  for (const [k, v] of headers.entries()) {
    out[k] = v.split(headerValRE);
  }

  return out;
}

function safeParseResponse<Inp, Out>(
  rawValue: Inp,
  fn: (value: Inp) => Out,
  errorMessage: string,
  httpMeta: { response: Response; request: Request; body: string },
): Result<Out, ResponseValidationError> {
  try {
    return OK(fn(rawValue));
  } catch (err) {
    return ERR(
      new ResponseValidationError(errorMessage, {
        cause: err,
        rawValue,
        rawMessage: errorMessage,
        ...httpMeta,
      }),
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - fail(codes: StatusCodePredicate)
 - matchFunc(response: Response,
    request: Request,
    options?: { resultKey?: string; extraFields?: Record<string, unknown> },)
 - unpackHeaders(headers: Headers)
Asignaciones con arrow functions encontradas (posibles funciones):
 - matcher(match;
        break;
      }
    }

    if (!matcher) {
      return [{
        ok: false,
        ...)
 - result(safeParseResponse(
        data,
        (v: unknown))
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  type
- export function jsonErr
- export function json
- export function jsonl
- export function jsonlErr
- export function textErr
- export function text
- export function bytesErr
- export function bytes
- export function streamErr
- export function stream
- export function sseErr
- export function sse
- export function nilErr
- export function nil
- export function fail
- export  type
- export  type
- export  type
- export function match
- export function unpackHeaders

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/lib/primitives.ts
Tamaño: 3533 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

class InvariantError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "InvariantError";
  }
}

export function invariant(
  condition: unknown,
  message: string,
): asserts condition {
  if (!condition) {
    throw new InvariantError(message);
  }
}

export type ExactPartial<T> = {
  [P in keyof T]?: T[P] | undefined;
};

export type Remap<Inp, Mapping extends { [k in keyof Inp]?: string | null }> = {
  [k in keyof Inp as Mapping[k] extends string /* if we have a string mapping for this key then use it */
    ? Mapping[k]
    : Mapping[k] extends null /* if the mapping is to `null` then drop the key */
    ? never
    : k /* otherwise keep the key as-is */]: Inp[k];
};

/**
 * Converts or omits an object's keys according to a mapping.
 *
 * @param inp An object whose keys will be remapped
 * @param mappings A mapping of original keys to new keys. If a key is not present in the mapping, it will be left as is. If a key is mapped to `null`, it will be removed in the resulting object.
 * @returns A new object with keys remapped or omitted according to the mappings
 */
export function remap<
  Inp extends Record<string, unknown>,
  const Mapping extends { [k in keyof Inp]?: string | null },
>(inp: Inp, mappings: Mapping): Remap<Inp, Mapping> {
  let out: any = {};

  if (!Object.keys(mappings).length) {
    out = inp;
    return out;
  }

  for (const [k, v] of Object.entries(inp)) {
    const j = mappings[k];
    if (j === null) {
      continue;
    }
    out[j ?? k] = v;
  }

  return out;
}

export function combineSignals(
  ...signals: Array<AbortSignal | null | undefined>
): AbortSignal | null {
  const filtered: AbortSignal[] = [];
  for (const signal of signals) {
    if (signal) {
      filtered.push(signal);
    }
  }

  switch (filtered.length) {
    case 0:
    case 1:
      return filtered[0] || null;
    default:
      if ("any" in AbortSignal && typeof AbortSignal.any === "function") {
        return AbortSignal.any(filtered);
      }
      return abortSignalAny(filtered);
  }
}

export function abortSignalAny(signals: AbortSignal[]): AbortSignal {
  const controller = new AbortController();
  const result = controller.signal;
  if (!signals.length) {
    return controller.signal;
  }

  if (signals.length === 1) {
    return signals[0] || controller.signal;
  }

  for (const signal of signals) {
    if (signal.aborted) {
      return signal;
    }
  }

  function abort(this: AbortSignal) {
    controller.abort(this.reason);
    clean();
  }

  const signalRefs: WeakRef<AbortSignal>[] = [];
  function clean() {
    for (const signalRef of signalRefs) {
      const signal = signalRef.deref();
      if (signal) {
        signal.removeEventListener("abort", abort);
      }
    }
  }

  for (const signal of signals) {
    signalRefs.push(new WeakRef(signal));
    signal.addEventListener("abort", abort);
  }

  return result;
}

export function compactMap<T>(
  values: Record<string, T | undefined>,
): Record<string, T> {
  const out: Record<string, T> = {};

  for (const [k, v] of Object.entries(values)) {
    if (typeof v !== "undefined") {
      out[k] = v;
    }
  }

  return out;
}

export function allRequired<V extends Record<string, unknown>>(
  v: V,
):
  | {
      [K in keyof V]: NonNullable<V[K]>;
    }
  | undefined {
  if (Object.values(v).every((x) => x == null)) {
    return void 0;
  }

  return v as ReturnType<typeof allRequired<V>>;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - invariant(condition: unknown,
  message: string,)
 - combineSignals(...signals: Array<AbortSignal | null | undefined>)
 - abortSignalAny(signals: AbortSignal[])
 - abort(this: AbortSignal)
 - clean()
Declaraciones 'export' encontradas:
- export function invariant
- export  type
- export  type
- export function remap
- export function combineSignals
- export function abortSignalAny
- export function compactMap
- export function allRequired

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/lib/retries.ts
Tamaño: 5228 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { isConnectionError, isTimeoutError } from "./http.js";

export type BackoffStrategy = {
  initialInterval: number;
  maxInterval: number;
  exponent: number;
  maxElapsedTime: number;
};

const defaultBackoff: BackoffStrategy = {
  initialInterval: 500,
  maxInterval: 60000,
  exponent: 1.5,
  maxElapsedTime: 3600000,
};

export type RetryConfig =
  | { strategy: "none" }
  | {
      strategy: "backoff";
      backoff?: BackoffStrategy;
      retryConnectionErrors?: boolean;
    };

/**
 * PermanentError is an error that is not recoverable. Throwing this error will
 * cause a retry loop to terminate.
 */
export class PermanentError extends Error {
  /** The underlying cause of the error. */
  override readonly cause: unknown;

  constructor(message: string, options?: { cause?: unknown }) {
    let msg = message;
    if (options?.cause) {
      msg += `: ${options.cause}`;
    }

    super(msg, options);
    this.name = "PermanentError";
    // In older runtimes, the cause field would not have been assigned through
    // the super() call.
    if (typeof this.cause === "undefined") {
      this.cause = options?.cause;
    }

    Object.setPrototypeOf(this, PermanentError.prototype);
  }
}

/**
 * TemporaryError is an error is used to signal that an HTTP request can be
 * retried as part of a retry loop. If retry attempts are exhausted and this
 * error is thrown, the response will be returned to the caller.
 */
export class TemporaryError extends Error {
  response: Response;

  constructor(message: string, response: Response) {
    super(message);
    this.response = response;
    this.name = "TemporaryError";

    Object.setPrototypeOf(this, TemporaryError.prototype);
  }
}

export async function retry(
  fetchFn: () => Promise<Response>,
  options: {
    config: RetryConfig;
    statusCodes: string[];
  },
): Promise<Response> {
  switch (options.config.strategy) {
    case "backoff":
      return retryBackoff(
        wrapFetcher(fetchFn, {
          statusCodes: options.statusCodes,
          retryConnectionErrors: !!options.config.retryConnectionErrors,
        }),
        options.config.backoff ?? defaultBackoff,
      );
    default:
      return await fetchFn();
  }
}

function wrapFetcher(
  fn: () => Promise<Response>,
  options: {
    statusCodes: string[];
    retryConnectionErrors: boolean;
  },
): () => Promise<Response> {
  return async () => {
    try {
      const res = await fn();
      if (isRetryableResponse(res, options.statusCodes)) {
        throw new TemporaryError(
          "Response failed with retryable status code",
          res,
        );
      }

      return res;
    } catch (err: unknown) {
      if (err instanceof TemporaryError) {
        throw err;
      }

      if (
        options.retryConnectionErrors &&
        (isTimeoutError(err) || isConnectionError(err))
      ) {
        throw err;
      }

      throw new PermanentError("Permanent error", { cause: err });
    }
  };
}

const codeRangeRE = new RegExp("^[0-9]xx$", "i");

function isRetryableResponse(res: Response, statusCodes: string[]): boolean {
  const actual = `${res.status}`;

  return statusCodes.some((code) => {
    if (!codeRangeRE.test(code)) {
      return code === actual;
    }

    const expectFamily = code.charAt(0);
    if (!expectFamily) {
      throw new Error("Invalid status code range");
    }

    const actualFamily = actual.charAt(0);
    if (!actualFamily) {
      throw new Error(`Invalid response status code: ${actual}`);
    }

    return actualFamily === expectFamily;
  });
}

async function retryBackoff(
  fn: () => Promise<Response>,
  strategy: BackoffStrategy,
): Promise<Response> {
  const { maxElapsedTime, initialInterval, exponent, maxInterval } = strategy;

  const start = Date.now();
  let x = 0;

  while (true) {
    try {
      const res = await fn();
      return res;
    } catch (err: unknown) {
      if (err instanceof PermanentError) {
        throw err.cause;
      }
      const elapsed = Date.now() - start;
      if (elapsed > maxElapsedTime) {
        if (err instanceof TemporaryError) {
          return err.response;
        }

        throw err;
      }

      let retryInterval = 0;
      if (err instanceof TemporaryError) {
        retryInterval = retryIntervalFromResponse(err.response);
      }

      if (retryInterval <= 0) {
        retryInterval =
          initialInterval * Math.pow(x, exponent) + Math.random() * 1000;
      }

      const d = Math.min(retryInterval, maxInterval);

      await delay(d);
      x++;
    }
  }
}

function retryIntervalFromResponse(res: Response): number {
  const retryVal = res.headers.get("retry-after") || "";
  if (!retryVal) {
    return 0;
  }

  const parsedNumber = Number(retryVal);
  if (Number.isInteger(parsedNumber)) {
    return parsedNumber * 1000;
  }

  const parsedDate = Date.parse(retryVal);
  if (Number.isInteger(parsedDate)) {
    const deltaMS = parsedDate - Date.now();
    return deltaMS > 0 ? Math.ceil(deltaMS) : 0;
  }

  return 0;
}

async function delay(delay: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, delay));
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - retry(fetchFn: ()
 - wrapFetcher(fn: ()
 - isRetryableResponse(res: Response, statusCodes: string[])
 - retryBackoff(fn: ()
 - retryIntervalFromResponse(res: Response)
 - delay(delay: number)
Asignaciones con arrow functions encontradas (posibles funciones):
 - name("TemporaryError";

    Object.setPrototypeOf(this, TemporaryError.prototype);
  }
}

export async fu...)
 - actual(`${res.status}`;

  return statusCodes.some((code))
 - deltaMS(parsedDate - Date.now();
    return deltaMS > 0 ? Math.ceil(deltaMS) : 0;
  }

  return 0;
}

async ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export class PermanentError
- export class TemporaryError
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/lib/schemas.ts
Tamaño: 2083 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { output, ZodEffects, ZodError, ZodObject, ZodRawShape, ZodTypeAny } from 'zod/v3';
import { SDKValidationError } from '../models/errors/sdkvalidationerror.js';
import { ERR, OK, Result } from '../types/fp.js';

/**
 * Utility function that executes some code which may throw a ZodError. It
 * intercepts this error and converts it to an SDKValidationError so as to not
 * leak Zod implementation details to user code.
 */
export function parse<Inp, Out>(rawValue: Inp, fn: (value: Inp) => Out, errorMessage: string): Out {
  try {
    return fn(rawValue);
  } catch (err) {
    if (err instanceof ZodError) {
      throw new SDKValidationError(errorMessage, err, rawValue);
    }
    throw err;
  }
}

/**
 * Utility function that executes some code which may result in a ZodError. It
 * intercepts this error and converts it to an SDKValidationError so as to not
 * leak Zod implementation details to user code.
 */
export function safeParse<Inp, Out>(
  rawValue: Inp,
  fn: (value: Inp) => Out,
  errorMessage: string
): Result<Out, SDKValidationError> {
  try {
    return OK(fn(rawValue));
  } catch (err) {
    return ERR(new SDKValidationError(errorMessage, err, rawValue));
  }
}

export function collectExtraKeys<Shape extends ZodRawShape, Catchall extends ZodTypeAny, K extends string>(
  obj: ZodObject<Shape, 'strip', Catchall>,
  extrasKey: K,
  optional: boolean
): ZodEffects<
  typeof obj,
  output<ZodObject<Shape, 'strict'>> & {
    [k in K]: Record<string, output<Catchall>>;
  }
> {
  return obj.transform((val) => {
    const extras: Record<string, output<Catchall>> = {};
    const { shape } = obj;
    for (const [key] of Object.entries(val)) {
      if (key in shape) {
        continue;
      }

      const v = val[key];
      if (typeof v === 'undefined') {
        continue;
      }

      extras[key] = v;
      delete val[key];
    }

    if (optional && Object.keys(extras).length === 0) {
      return val;
    }

    return { ...val, [extrasKey]: extras };
  });
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export function parse
- export function safeParse
- export function collectExtraKeys

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/lib/sdks.ts
Tamaño: 11501 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { SDKHooks } from "../hooks/hooks.js";
import { HookContext } from "../hooks/types.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import { ERR, OK, Result } from "../types/fp.js";
import { stringToBase64 } from "./base64.js";
import { SDK_METADATA, SDKOptions, serverURLFromOptions } from "./config.js";
import { encodeForm } from "./encodings.js";
import {
  HTTPClient,
  isAbortError,
  isConnectionError,
  isTimeoutError,
  matchContentType,
  matchStatusCode,
} from "./http.js";
import { Logger } from "./logger.js";
import { retry, RetryConfig } from "./retries.js";
import { SecurityState } from "./security.js";

export type RequestOptions = {
  /**
   * Sets a timeout, in milliseconds, on HTTP requests made by an SDK method. If
   * `fetchOptions.signal` is set then it will take precedence over this option.
   */
  timeoutMs?: number;
  /**
   * Set or override a retry policy on HTTP calls.
   */
  retries?: RetryConfig;
  /**
   * Specifies the status codes which should be retried using the given retry policy.
   */
  retryCodes?: string[];
  /**
   * Overrides the base server URL that will be used by an operation.
   */
  serverURL?: string | URL;
  /**
   * @deprecated `fetchOptions` has been flattened into `RequestOptions`.
   *
   * Sets various request options on the `fetch` call made by an SDK method.
   *
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#options|Request}
   */
  fetchOptions?: Omit<RequestInit, "method" | "body">;
} & Omit<RequestInit, "method" | "body">;

type RequestConfig = {
  method: string;
  path: string;
  baseURL?: string | URL | undefined;
  query?: string;
  body?: RequestInit["body"];
  headers?: HeadersInit;
  security?: SecurityState | null;
  uaHeader?: string;
  userAgent?: string | undefined;
  timeoutMs?: number;
};

const gt: unknown = typeof globalThis === "undefined" ? null : globalThis;
const webWorkerLike = typeof gt === "object"
  && gt != null
  && "importScripts" in gt
  && typeof gt["importScripts"] === "function";
const isBrowserLike = webWorkerLike
  || (typeof navigator !== "undefined" && "serviceWorker" in navigator)
  || (typeof window === "object" && typeof window.document !== "undefined");

export class ClientSDK {
  readonly #httpClient: HTTPClient;
  readonly #hooks: SDKHooks;
  readonly #logger?: Logger | undefined;
  public readonly _baseURL: URL | null;
  public readonly _options: SDKOptions & { hooks?: SDKHooks };

  constructor(options: SDKOptions = {}) {
    const opt = options as unknown;
    if (
      typeof opt === "object"
      && opt != null
      && "hooks" in opt
      && opt.hooks instanceof SDKHooks
    ) {
      this.#hooks = opt.hooks;
    } else {
      this.#hooks = new SDKHooks();
    }
    const defaultHttpClient = new HTTPClient();
    options.httpClient = options.httpClient || defaultHttpClient;
    options = this.#hooks.sdkInit(options);

    const url = serverURLFromOptions(options);
    if (url) {
      url.pathname = url.pathname.replace(/\/+$/, "") + "/";
    }
    this._baseURL = url;
    this.#httpClient = options.httpClient || defaultHttpClient;

    this._options = { ...options, hooks: this.#hooks };

    this.#logger = this._options.debugLogger;
  }

  public _createRequest(
    context: HookContext,
    conf: RequestConfig,
    options?: RequestOptions,
  ): Result<Request, InvalidRequestError | UnexpectedClientError> {
    const { method, path, query, headers: opHeaders, security } = conf;

    const base = conf.baseURL ?? this._baseURL;
    if (!base) {
      return ERR(new InvalidRequestError("No base URL provided for operation"));
    }
    const reqURL = new URL(base);
    const inputURL = new URL(path, reqURL);

    if (path) {
      reqURL.pathname += reqURL.pathname.endsWith("/") ? "" : "/";
      reqURL.pathname += inputURL.pathname.replace(/^\/+/, "");
    }

    let finalQuery = query || "";

    const secQuery: string[] = [];
    for (const [k, v] of Object.entries(security?.queryParams || {})) {
      const q = encodeForm(k, v, { charEncoding: "percent" });
      if (typeof q !== "undefined") {
        secQuery.push(q);
      }
    }
    if (secQuery.length) {
      finalQuery += `&${secQuery.join("&")}`;
    }

    if (finalQuery) {
      const q = finalQuery.startsWith("&") ? finalQuery.slice(1) : finalQuery;
      reqURL.search = `?${q}`;
    }

    const headers = new Headers(opHeaders);

    const username = security?.basic.username;
    const password = security?.basic.password;
    if (username != null || password != null) {
      const encoded = stringToBase64(
        [username || "", password || ""].join(":"),
      );
      headers.set("Authorization", `Basic ${encoded}`);
    }

    const securityHeaders = new Headers(security?.headers || {});
    for (const [k, v] of securityHeaders) {
      headers.set(k, v);
    }

    let cookie = headers.get("cookie") || "";
    for (const [k, v] of Object.entries(security?.cookies || {})) {
      cookie += `; ${k}=${v}`;
    }
    cookie = cookie.startsWith("; ") ? cookie.slice(2) : cookie;
    headers.set("cookie", cookie);

    const userHeaders = new Headers(
      options?.headers ?? options?.fetchOptions?.headers,
    );
    for (const [k, v] of userHeaders) {
      headers.set(k, v);
    }

    // Only set user agent header in non-browser-like environments since CORS
    // policy disallows setting it in browsers e.g. Chrome throws an error.
    if (!isBrowserLike) {
      headers.set(
        conf.uaHeader ?? "user-agent",
        conf.userAgent ?? SDK_METADATA.userAgent,
      );
    }

    const fetchOptions: Omit<RequestInit, "method" | "body"> = {
      ...options?.fetchOptions,
      ...options,
    };
    if (!fetchOptions?.signal && conf.timeoutMs && conf.timeoutMs > 0) {
      const timeoutSignal = AbortSignal.timeout(conf.timeoutMs);
      fetchOptions.signal = timeoutSignal;
    }

    if (conf.body instanceof ReadableStream) {
      Object.assign(fetchOptions, { duplex: "half" });
    }

    let input;
    try {
      input = this.#hooks.beforeCreateRequest(context, {
        url: reqURL,
        options: {
          ...fetchOptions,
          body: conf.body ?? null,
          headers,
          method,
        },
      });
    } catch (err: unknown) {
      return ERR(
        new UnexpectedClientError("Create request hook failed to execute", {
          cause: err,
        }),
      );
    }

    return OK(new Request(input.url, input.options));
  }

  public async _do(
    request: Request,
    options: {
      context: HookContext;
      errorCodes: number | string | (number | string)[];
      retryConfig: RetryConfig;
      retryCodes: string[];
    },
  ): Promise<
    Result<
      Response,
      | RequestAbortedError
      | RequestTimeoutError
      | ConnectionError
      | UnexpectedClientError
    >
  > {
    const { context, errorCodes } = options;

    return retry(
      async () => {
        const req = await this.#hooks.beforeRequest(context, request.clone());
        await logRequest(this.#logger, req).catch((e) =>
          this.#logger?.log("Failed to log request:", e)
        );

        let response = await this.#httpClient.request(req);

        try {
          if (matchStatusCode(response, errorCodes)) {
            const result = await this.#hooks.afterError(
              context,
              response,
              null,
            );
            if (result.error) {
              throw result.error;
            }
            response = result.response || response;
          } else {
            response = await this.#hooks.afterSuccess(context, response);
          }
        } finally {
          await logResponse(this.#logger, response, req)
            .catch(e => this.#logger?.log("Failed to log response:", e));
        }

        return response;
      },
      { config: options.retryConfig, statusCodes: options.retryCodes },
    ).then(
      (r) => OK(r),
      (err) => {
        switch (true) {
          case isAbortError(err):
            return ERR(
              new RequestAbortedError("Request aborted by client", {
                cause: err,
              }),
            );
          case isTimeoutError(err):
            return ERR(
              new RequestTimeoutError("Request timed out", { cause: err }),
            );
          case isConnectionError(err):
            return ERR(
              new ConnectionError("Unable to make request", { cause: err }),
            );
          default:
            return ERR(
              new UnexpectedClientError("Unexpected HTTP client error", {
                cause: err,
              }),
            );
        }
      },
    );
  }
}

const jsonLikeContentTypeRE = /(application|text)\/.*?\+*json.*/;
const jsonlLikeContentTypeRE =
  /(application|text)\/(.*?\+*\bjsonl\b.*|.*?\+*\bx-ndjson\b.*)/;
async function logRequest(logger: Logger | undefined, req: Request) {
  if (!logger) {
    return;
  }

  const contentType = req.headers.get("content-type");
  const ct = contentType?.split(";")[0] || "";

  logger.group(`> Request: ${req.method} ${req.url}`);

  logger.group("Headers:");
  for (const [k, v] of req.headers.entries()) {
    logger.log(`${k}: ${v}`);
  }
  logger.groupEnd();

  logger.group("Body:");
  switch (true) {
    case jsonLikeContentTypeRE.test(ct):
      logger.log(await req.clone().json());
      break;
    case ct.startsWith("text/"):
      logger.log(await req.clone().text());
      break;
    case ct === "multipart/form-data": {
      const body = await req.clone().formData();
      for (const [k, v] of body) {
        const vlabel = v instanceof Blob ? "<Blob>" : v;
        logger.log(`${k}: ${vlabel}`);
      }
      break;
    }
    default:
      logger.log(`<${contentType}>`);
      break;
  }
  logger.groupEnd();

  logger.groupEnd();
}

async function logResponse(
  logger: Logger | undefined,
  res: Response,
  req: Request,
) {
  if (!logger) {
    return;
  }

  const contentType = res.headers.get("content-type");
  const ct = contentType?.split(";")[0] || "";

  logger.group(`< Response: ${req.method} ${req.url}`);
  logger.log("Status Code:", res.status, res.statusText);

  logger.group("Headers:");
  for (const [k, v] of res.headers.entries()) {
    logger.log(`${k}: ${v}`);
  }
  logger.groupEnd();

  logger.group("Body:");
  switch (true) {
    case matchContentType(res, "application/json")
      || jsonLikeContentTypeRE.test(ct) && !jsonlLikeContentTypeRE.test(ct):
      logger.log(await res.clone().json());
      break;
    case matchContentType(res, "application/jsonl")
      || jsonlLikeContentTypeRE.test(ct):
      logger.log(await res.clone().text());
      break;
    case matchContentType(res, "text/event-stream"):
      logger.log(`<${contentType}>`);
      break;
    case matchContentType(res, "text/*"):
      logger.log(await res.clone().text());
      break;
    case matchContentType(res, "multipart/form-data"): {
      const body = await res.clone().formData();
      for (const [k, v] of body) {
        const vlabel = v instanceof Blob ? "<Blob>" : v;
        logger.log(`${k}: ${vlabel}`);
      }
      break;
    }
    default:
      logger.log(`<${contentType}>`);
      break;
  }
  logger.groupEnd();

  logger.groupEnd();
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - logRequest(logger: Logger | undefined, req: Request)
 - logResponse(logger: Logger | undefined,
  res: Response,
  req: Request,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - req(await this.#hooks.beforeRequest(context, request.clone());
        await logRequest(this.#logger, re...)
 - response(await this.#hooks.afterSuccess(context, response);
          }
        } finally {
          await l...)
Declaraciones 'export' encontradas:
- export  type
- export class ClientSDK

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/lib/security.ts
Tamaño: 6150 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as components from "../models/components/index.js";

type OAuth2PasswordFlow = {
  username: string;
  password: string;
  clientID?: string | undefined;
  clientSecret?: string | undefined;
  tokenURL: string;
};

export enum SecurityErrorCode {
  Incomplete = "incomplete",
  UnrecognisedSecurityType = "unrecognized_security_type",
}

export class SecurityError extends Error {
  constructor(
    public code: SecurityErrorCode,
    message: string,
  ) {
    super(message);
    this.name = "SecurityError";
  }

  static incomplete(): SecurityError {
    return new SecurityError(
      SecurityErrorCode.Incomplete,
      "Security requirements not met in order to perform the operation",
    );
  }
  static unrecognizedType(type: string): SecurityError {
    return new SecurityError(
      SecurityErrorCode.UnrecognisedSecurityType,
      `Unrecognised security type: ${type}`,
    );
  }
}

export type SecurityState = {
  basic: { username?: string | undefined; password?: string | undefined };
  headers: Record<string, string>;
  queryParams: Record<string, string>;
  cookies: Record<string, string>;
  oauth2: ({ type: "password" } & OAuth2PasswordFlow) | { type: "none" };
};

type SecurityInputBasic = {
  type: "http:basic";
  value:
    | { username?: string | undefined; password?: string | undefined }
    | null
    | undefined;
};

type SecurityInputBearer = {
  type: "http:bearer";
  value: string | null | undefined;
  fieldName: string;
};

type SecurityInputAPIKey = {
  type: "apiKey:header" | "apiKey:query" | "apiKey:cookie";
  value: string | null | undefined;
  fieldName: string;
};

type SecurityInputOIDC = {
  type: "openIdConnect";
  value: string | null | undefined;
  fieldName: string;
};

type SecurityInputOAuth2 = {
  type: "oauth2";
  value: string | null | undefined;
  fieldName: string;
};

type SecurityInputOAuth2ClientCredentials = {
  type: "oauth2:client_credentials";
  value:
    | {
      clientID?: string | undefined;
      clientSecret?: string | undefined;
    }
    | null
    | string
    | undefined;
  fieldName?: string;
};

type SecurityInputOAuth2PasswordCredentials = {
  type: "oauth2:password";
  value:
    | string
    | null
    | undefined;
  fieldName?: string;
};

type SecurityInputCustom = {
  type: "http:custom";
  value: any | null | undefined;
  fieldName?: string;
};

export type SecurityInput =
  | SecurityInputBasic
  | SecurityInputBearer
  | SecurityInputAPIKey
  | SecurityInputOAuth2
  | SecurityInputOAuth2ClientCredentials
  | SecurityInputOAuth2PasswordCredentials
  | SecurityInputOIDC
  | SecurityInputCustom;

export function resolveSecurity(
  ...options: SecurityInput[][]
): SecurityState | null {
  const state: SecurityState = {
    basic: {},
    headers: {},
    queryParams: {},
    cookies: {},
    oauth2: { type: "none" },
  };

  const option = options.find((opts) => {
    return opts.every((o) => {
      if (o.value == null) {
        return false;
      } else if (o.type === "http:basic") {
        return o.value.username != null || o.value.password != null;
      } else if (o.type === "http:custom") {
        return null;
      } else if (o.type === "oauth2:password") {
        return (
          typeof o.value === "string" && !!o.value
        );
      } else if (o.type === "oauth2:client_credentials") {
        if (typeof o.value == "string") {
          return !!o.value;
        }
        return o.value.clientID != null || o.value.clientSecret != null;
      } else if (typeof o.value === "string") {
        return !!o.value;
      } else {
        throw new Error(
          `Unrecognized security type: ${o.type} (value type: ${typeof o
            .value})`,
        );
      }
    });
  });
  if (option == null) {
    return null;
  }

  option.forEach((spec) => {
    if (spec.value == null) {
      return;
    }

    const { type } = spec;

    switch (type) {
      case "apiKey:header":
        state.headers[spec.fieldName] = spec.value;
        break;
      case "apiKey:query":
        state.queryParams[spec.fieldName] = spec.value;
        break;
      case "apiKey:cookie":
        state.cookies[spec.fieldName] = spec.value;
        break;
      case "http:basic":
        applyBasic(state, spec);
        break;
      case "http:custom":
        break;
      case "http:bearer":
        applyBearer(state, spec);
        break;
      case "oauth2":
        applyBearer(state, spec);
        break;
      case "oauth2:password":
        applyBearer(state, spec);
        break;
      case "oauth2:client_credentials":
        break;
      case "openIdConnect":
        applyBearer(state, spec);
        break;
      default:
        spec satisfies never;
        throw SecurityError.unrecognizedType(type);
    }
  });

  return state;
}

function applyBasic(
  state: SecurityState,
  spec: SecurityInputBasic,
) {
  if (spec.value == null) {
    return;
  }

  state.basic = spec.value;
}

function applyBearer(
  state: SecurityState,
  spec:
    | SecurityInputBearer
    | SecurityInputOAuth2
    | SecurityInputOIDC
    | SecurityInputOAuth2PasswordCredentials,
) {
  if (typeof spec.value !== "string" || !spec.value) {
    return;
  }

  let value = spec.value;
  if (value.slice(0, 7).toLowerCase() !== "bearer ") {
    value = `Bearer ${value}`;
  }

  if (spec.fieldName !== undefined) {
    state.headers[spec.fieldName] = value;
  }
}

export function resolveGlobalSecurity(
  security: Partial<components.Security> | null | undefined,
): SecurityState | null {
  return resolveSecurity(
    [
      {
        fieldName: "Authorization",
        type: "apiKey:header",
        value: security?.secretKey,
      },
    ],
    [
      {
        fieldName: "Authorization",
        type: "http:bearer",
        value: security?.bearerAuth,
      },
    ],
  );
}

export async function extractSecurity<
  T extends string | Record<string, unknown>,
>(sec: T | (() => Promise<T>) | undefined): Promise<T | undefined> {
  if (sec == null) {
    return;
  }

  return typeof sec === "function" ? sec() : sec;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - resolveSecurity(...options: SecurityInput[][])
 - applyBasic(state: SecurityState,
  spec: SecurityInputBasic,)
 - applyBearer(state: SecurityState,
  spec:
    | SecurityInputBearer
    | SecurityInputOAuth2
    | SecurityInputOIDC
    | SecurityInputOAuth2PasswordCredentials,)
 - resolveGlobalSecurity(security: Partial<components.Security> | null | undefined,)
Asignaciones con arrow functions encontradas (posibles funciones):
 - option(options.find((opts))
Declaraciones 'export' encontradas:
- export  enum
- export class SecurityError
- export  type
- export  type
- export function resolveSecurity
- export function resolveGlobalSecurity
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/lib/url.ts
Tamaño: 1000 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

const hasOwn = Object.prototype.hasOwnProperty;

export type Params = Partial<Record<string, string | number>>;

export function pathToFunc(
  pathPattern: string,
  options?: { charEncoding?: "percent" | "none" },
): (params?: Params) => string {
  const paramRE = /\{([a-zA-Z0-9_][a-zA-Z0-9_-]*?)\}/g;

  return function buildURLPath(params: Record<string, unknown> = {}): string {
    return pathPattern.replace(paramRE, function (_, placeholder) {
      if (!hasOwn.call(params, placeholder)) {
        throw new Error(`Parameter '${placeholder}' is required`);
      }

      const value = params[placeholder];
      if (typeof value !== "string" && typeof value !== "number") {
        throw new Error(
          `Parameter '${placeholder}' must be a string or number`,
        );
      }

      return options?.charEncoding === "percent"
        ? encodeURIComponent(`${value}`)
        : `${value}`;
    });
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - pathToFunc(pathPattern: string,
  options?: { charEncoding?: "percent" | "none" },)
 - buildURLPath(params: Record<string, unknown> = {})
Asignaciones con arrow functions encontradas (posibles funciones):
 - Params(Partial<Record<string, string | number>>;

export function pathToFunc(
  pathPattern: string,
  opti...)
Declaraciones 'export' encontradas:
- export  type
- export function pathToFunc

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/actiondto.ts
Tamaño: 2073 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  RedirectDto,
  RedirectDto$inboundSchema,
  RedirectDto$Outbound,
  RedirectDto$outboundSchema,
} from './redirectdto.js';

export type ActionDto = {
  /**
   * Label for the action button.
   */
  label?: string | undefined;
  /**
   * Redirect configuration for the action.
   */
  redirect?: RedirectDto | undefined;
};

/** @internal */
export const ActionDto$inboundSchema: z.ZodType<ActionDto, z.ZodTypeDef, unknown> = z.object({
  label: z.string().optional(),
  redirect: RedirectDto$inboundSchema.optional(),
});

/** @internal */
export type ActionDto$Outbound = {
  label?: string | undefined;
  redirect?: RedirectDto$Outbound | undefined;
};

/** @internal */
export const ActionDto$outboundSchema: z.ZodType<ActionDto$Outbound, z.ZodTypeDef, ActionDto> = z.object({
  label: z.string().optional(),
  redirect: RedirectDto$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ActionDto$ {
  /** @deprecated use `ActionDto$inboundSchema` instead. */
  export const inboundSchema = ActionDto$inboundSchema;
  /** @deprecated use `ActionDto$outboundSchema` instead. */
  export const outboundSchema = ActionDto$outboundSchema;
  /** @deprecated use `ActionDto$Outbound` instead. */
  export type Outbound = ActionDto$Outbound;
}

export function actionDtoToJSON(actionDto: ActionDto): string {
  return JSON.stringify(ActionDto$outboundSchema.parse(actionDto));
}

export function actionDtoFromJSON(jsonString: string): SafeParseResult<ActionDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ActionDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ActionDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - actionDtoToJSON(actionDto: ActionDto)
 - actionDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ActionDto$Outbound;
}

export function actionDtoToJSON(actionDto: ActionDto): string {
  return JSON...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function actionDtoToJSON
- export function actionDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/activitiesresponsedto.ts
Tamaño: 2747 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ActivityNotificationResponseDto,
  ActivityNotificationResponseDto$inboundSchema,
  ActivityNotificationResponseDto$Outbound,
  ActivityNotificationResponseDto$outboundSchema,
} from './activitynotificationresponsedto.js';

export type ActivitiesResponseDto = {
  /**
   * Indicates if there are more activities in the result set
   */
  hasMore: boolean;
  /**
   * Array of activity notifications
   */
  data: Array<ActivityNotificationResponseDto>;
  /**
   * Page size of the activities
   */
  pageSize: number;
  /**
   * Current page of the activities
   */
  page: number;
};

/** @internal */
export const ActivitiesResponseDto$inboundSchema: z.ZodType<ActivitiesResponseDto, z.ZodTypeDef, unknown> = z.object({
  hasMore: z.boolean(),
  data: z.array(ActivityNotificationResponseDto$inboundSchema),
  pageSize: z.number(),
  page: z.number(),
});

/** @internal */
export type ActivitiesResponseDto$Outbound = {
  hasMore: boolean;
  data: Array<ActivityNotificationResponseDto$Outbound>;
  pageSize: number;
  page: number;
};

/** @internal */
export const ActivitiesResponseDto$outboundSchema: z.ZodType<
  ActivitiesResponseDto$Outbound,
  z.ZodTypeDef,
  ActivitiesResponseDto
> = z.object({
  hasMore: z.boolean(),
  data: z.array(ActivityNotificationResponseDto$outboundSchema),
  pageSize: z.number(),
  page: z.number(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ActivitiesResponseDto$ {
  /** @deprecated use `ActivitiesResponseDto$inboundSchema` instead. */
  export const inboundSchema = ActivitiesResponseDto$inboundSchema;
  /** @deprecated use `ActivitiesResponseDto$outboundSchema` instead. */
  export const outboundSchema = ActivitiesResponseDto$outboundSchema;
  /** @deprecated use `ActivitiesResponseDto$Outbound` instead. */
  export type Outbound = ActivitiesResponseDto$Outbound;
}

export function activitiesResponseDtoToJSON(activitiesResponseDto: ActivitiesResponseDto): string {
  return JSON.stringify(ActivitiesResponseDto$outboundSchema.parse(activitiesResponseDto));
}

export function activitiesResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<ActivitiesResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ActivitiesResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ActivitiesResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - activitiesResponseDtoToJSON(activitiesResponseDto: ActivitiesResponseDto)
 - activitiesResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ActivitiesResponseDto$Outbound;
}

export function activitiesResponseDtoToJSON(activitiesResponseDto...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function activitiesResponseDtoToJSON
- export function activitiesResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/activitynotificationexecutiondetailresponsedto.ts
Tamaño: 4714 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ExecutionDetailsSourceEnum,
  ExecutionDetailsSourceEnum$inboundSchema,
  ExecutionDetailsSourceEnum$outboundSchema,
} from './executiondetailssourceenum.js';
import {
  ExecutionDetailsStatusEnum,
  ExecutionDetailsStatusEnum$inboundSchema,
  ExecutionDetailsStatusEnum$outboundSchema,
} from './executiondetailsstatusenum.js';
import { ProvidersIdEnum, ProvidersIdEnum$inboundSchema, ProvidersIdEnum$outboundSchema } from './providersidenum.js';

export type ActivityNotificationExecutionDetailResponseDto = {
  /**
   * Unique identifier of the execution detail
   */
  id: string;
  /**
   * Creation time of the execution detail
   */
  createdAt?: string | undefined;
  /**
   * Status of the execution detail
   */
  status: ExecutionDetailsStatusEnum;
  /**
   * Detailed information about the execution
   */
  detail: string;
  /**
   * Whether the execution is a retry or not
   */
  isRetry: boolean;
  /**
   * Whether the execution is a test or not
   */
  isTest: boolean;
  /**
   * Provider ID of the job
   */
  providerId?: ProvidersIdEnum | undefined;
  /**
   * Raw data of the execution
   */
  raw?: string | null | undefined;
  /**
   * Source of the execution detail
   */
  source: ExecutionDetailsSourceEnum;
};

/** @internal */
export const ActivityNotificationExecutionDetailResponseDto$inboundSchema: z.ZodType<
  ActivityNotificationExecutionDetailResponseDto,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    _id: z.string(),
    createdAt: z.string().optional(),
    status: ExecutionDetailsStatusEnum$inboundSchema,
    detail: z.string(),
    isRetry: z.boolean(),
    isTest: z.boolean(),
    providerId: ProvidersIdEnum$inboundSchema.optional(),
    raw: z.nullable(z.string()).optional(),
    source: ExecutionDetailsSourceEnum$inboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type ActivityNotificationExecutionDetailResponseDto$Outbound = {
  _id: string;
  createdAt?: string | undefined;
  status: string;
  detail: string;
  isRetry: boolean;
  isTest: boolean;
  providerId?: string | undefined;
  raw?: string | null | undefined;
  source: string;
};

/** @internal */
export const ActivityNotificationExecutionDetailResponseDto$outboundSchema: z.ZodType<
  ActivityNotificationExecutionDetailResponseDto$Outbound,
  z.ZodTypeDef,
  ActivityNotificationExecutionDetailResponseDto
> = z
  .object({
    id: z.string(),
    createdAt: z.string().optional(),
    status: ExecutionDetailsStatusEnum$outboundSchema,
    detail: z.string(),
    isRetry: z.boolean(),
    isTest: z.boolean(),
    providerId: ProvidersIdEnum$outboundSchema.optional(),
    raw: z.nullable(z.string()).optional(),
    source: ExecutionDetailsSourceEnum$outboundSchema,
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ActivityNotificationExecutionDetailResponseDto$ {
  /** @deprecated use `ActivityNotificationExecutionDetailResponseDto$inboundSchema` instead. */
  export const inboundSchema = ActivityNotificationExecutionDetailResponseDto$inboundSchema;
  /** @deprecated use `ActivityNotificationExecutionDetailResponseDto$outboundSchema` instead. */
  export const outboundSchema = ActivityNotificationExecutionDetailResponseDto$outboundSchema;
  /** @deprecated use `ActivityNotificationExecutionDetailResponseDto$Outbound` instead. */
  export type Outbound = ActivityNotificationExecutionDetailResponseDto$Outbound;
}

export function activityNotificationExecutionDetailResponseDtoToJSON(
  activityNotificationExecutionDetailResponseDto: ActivityNotificationExecutionDetailResponseDto
): string {
  return JSON.stringify(
    ActivityNotificationExecutionDetailResponseDto$outboundSchema.parse(activityNotificationExecutionDetailResponseDto)
  );
}

export function activityNotificationExecutionDetailResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<ActivityNotificationExecutionDetailResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ActivityNotificationExecutionDetailResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ActivityNotificationExecutionDetailResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - activityNotificationExecutionDetailResponseDtoToJSON(activityNotificationExecutionDetailResponseDto: ActivityNotificationExecutionDetailResponseDto)
 - activityNotificationExecutionDetailResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ActivityNotificationExecutionDetailResponseDto$Outbound;
}

export function activityNotificationExec...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function activityNotificationExecutionDetailResponseDtoToJSON
- export function activityNotificationExecutionDetailResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/activitynotificationjobresponsedto.ts
Tamaño: 9422 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ActivityNotificationExecutionDetailResponseDto,
  ActivityNotificationExecutionDetailResponseDto$inboundSchema,
  ActivityNotificationExecutionDetailResponseDto$Outbound,
  ActivityNotificationExecutionDetailResponseDto$outboundSchema,
} from './activitynotificationexecutiondetailresponsedto.js';
import {
  ActivityNotificationStepResponseDto,
  ActivityNotificationStepResponseDto$inboundSchema,
  ActivityNotificationStepResponseDto$Outbound,
  ActivityNotificationStepResponseDto$outboundSchema,
} from './activitynotificationstepresponsedto.js';
import {
  DigestMetadataDto,
  DigestMetadataDto$inboundSchema,
  DigestMetadataDto$Outbound,
  DigestMetadataDto$outboundSchema,
} from './digestmetadatadto.js';
import { ProvidersIdEnum, ProvidersIdEnum$inboundSchema, ProvidersIdEnum$outboundSchema } from './providersidenum.js';

/**
 * Type of the job
 */
export const ActivityNotificationJobResponseDtoType = {
  InApp: 'in_app',
  Email: 'email',
  Sms: 'sms',
  Chat: 'chat',
  Push: 'push',
  Digest: 'digest',
  Trigger: 'trigger',
  Delay: 'delay',
  Throttle: 'throttle',
  Custom: 'custom',
} as const;
/**
 * Type of the job
 */
export type ActivityNotificationJobResponseDtoType = ClosedEnum<typeof ActivityNotificationJobResponseDtoType>;

/**
 * Optional payload for the job
 */
export type ActivityNotificationJobResponseDtoPayload = {};

export type ActivityNotificationJobResponseDto = {
  /**
   * Unique identifier of the job
   */
  id: string;
  /**
   * Type of the job
   */
  type: ActivityNotificationJobResponseDtoType;
  /**
   * Optional digest for the job, including metadata and events
   */
  digest?: DigestMetadataDto | undefined;
  /**
   * Execution details of the job
   */
  executionDetails: Array<ActivityNotificationExecutionDetailResponseDto>;
  /**
   * Step details of the job
   */
  step: ActivityNotificationStepResponseDto;
  /**
   * Optional context object for additional error details.
   */
  overrides?: { [k: string]: any } | undefined;
  /**
   * Optional payload for the job
   */
  payload?: ActivityNotificationJobResponseDtoPayload | undefined;
  /**
   * Provider ID of the job
   */
  providerId: ProvidersIdEnum;
  /**
   * Status of the job
   */
  status: string;
  /**
   * Updated time of the notification
   */
  updatedAt?: string | undefined;
  /**
   * The number of times the digest/delay job has been extended to align with the subscribers schedule
   */
  scheduleExtensionsCount?: number | undefined;
};

/** @internal */
export const ActivityNotificationJobResponseDtoType$inboundSchema: z.ZodNativeEnum<
  typeof ActivityNotificationJobResponseDtoType
> = z.nativeEnum(ActivityNotificationJobResponseDtoType);

/** @internal */
export const ActivityNotificationJobResponseDtoType$outboundSchema: z.ZodNativeEnum<
  typeof ActivityNotificationJobResponseDtoType
> = ActivityNotificationJobResponseDtoType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ActivityNotificationJobResponseDtoType$ {
  /** @deprecated use `ActivityNotificationJobResponseDtoType$inboundSchema` instead. */
  export const inboundSchema = ActivityNotificationJobResponseDtoType$inboundSchema;
  /** @deprecated use `ActivityNotificationJobResponseDtoType$outboundSchema` instead. */
  export const outboundSchema = ActivityNotificationJobResponseDtoType$outboundSchema;
}

/** @internal */
export const ActivityNotificationJobResponseDtoPayload$inboundSchema: z.ZodType<
  ActivityNotificationJobResponseDtoPayload,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type ActivityNotificationJobResponseDtoPayload$Outbound = {};

/** @internal */
export const ActivityNotificationJobResponseDtoPayload$outboundSchema: z.ZodType<
  ActivityNotificationJobResponseDtoPayload$Outbound,
  z.ZodTypeDef,
  ActivityNotificationJobResponseDtoPayload
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ActivityNotificationJobResponseDtoPayload$ {
  /** @deprecated use `ActivityNotificationJobResponseDtoPayload$inboundSchema` instead. */
  export const inboundSchema = ActivityNotificationJobResponseDtoPayload$inboundSchema;
  /** @deprecated use `ActivityNotificationJobResponseDtoPayload$outboundSchema` instead. */
  export const outboundSchema = ActivityNotificationJobResponseDtoPayload$outboundSchema;
  /** @deprecated use `ActivityNotificationJobResponseDtoPayload$Outbound` instead. */
  export type Outbound = ActivityNotificationJobResponseDtoPayload$Outbound;
}

export function activityNotificationJobResponseDtoPayloadToJSON(
  activityNotificationJobResponseDtoPayload: ActivityNotificationJobResponseDtoPayload
): string {
  return JSON.stringify(
    ActivityNotificationJobResponseDtoPayload$outboundSchema.parse(activityNotificationJobResponseDtoPayload)
  );
}

export function activityNotificationJobResponseDtoPayloadFromJSON(
  jsonString: string
): SafeParseResult<ActivityNotificationJobResponseDtoPayload, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ActivityNotificationJobResponseDtoPayload$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ActivityNotificationJobResponseDtoPayload' from JSON`
  );
}

/** @internal */
export const ActivityNotificationJobResponseDto$inboundSchema: z.ZodType<
  ActivityNotificationJobResponseDto,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    _id: z.string(),
    type: ActivityNotificationJobResponseDtoType$inboundSchema,
    digest: DigestMetadataDto$inboundSchema.optional(),
    executionDetails: z.array(ActivityNotificationExecutionDetailResponseDto$inboundSchema),
    step: ActivityNotificationStepResponseDto$inboundSchema,
    overrides: z.record(z.any()).optional(),
    payload: z.lazy(() => ActivityNotificationJobResponseDtoPayload$inboundSchema).optional(),
    providerId: ProvidersIdEnum$inboundSchema,
    status: z.string(),
    updatedAt: z.string().optional(),
    scheduleExtensionsCount: z.number().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type ActivityNotificationJobResponseDto$Outbound = {
  _id: string;
  type: string;
  digest?: DigestMetadataDto$Outbound | undefined;
  executionDetails: Array<ActivityNotificationExecutionDetailResponseDto$Outbound>;
  step: ActivityNotificationStepResponseDto$Outbound;
  overrides?: { [k: string]: any } | undefined;
  payload?: ActivityNotificationJobResponseDtoPayload$Outbound | undefined;
  providerId: string;
  status: string;
  updatedAt?: string | undefined;
  scheduleExtensionsCount?: number | undefined;
};

/** @internal */
export const ActivityNotificationJobResponseDto$outboundSchema: z.ZodType<
  ActivityNotificationJobResponseDto$Outbound,
  z.ZodTypeDef,
  ActivityNotificationJobResponseDto
> = z
  .object({
    id: z.string(),
    type: ActivityNotificationJobResponseDtoType$outboundSchema,
    digest: DigestMetadataDto$outboundSchema.optional(),
    executionDetails: z.array(ActivityNotificationExecutionDetailResponseDto$outboundSchema),
    step: ActivityNotificationStepResponseDto$outboundSchema,
    overrides: z.record(z.any()).optional(),
    payload: z.lazy(() => ActivityNotificationJobResponseDtoPayload$outboundSchema).optional(),
    providerId: ProvidersIdEnum$outboundSchema,
    status: z.string(),
    updatedAt: z.string().optional(),
    scheduleExtensionsCount: z.number().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ActivityNotificationJobResponseDto$ {
  /** @deprecated use `ActivityNotificationJobResponseDto$inboundSchema` instead. */
  export const inboundSchema = ActivityNotificationJobResponseDto$inboundSchema;
  /** @deprecated use `ActivityNotificationJobResponseDto$outboundSchema` instead. */
  export const outboundSchema = ActivityNotificationJobResponseDto$outboundSchema;
  /** @deprecated use `ActivityNotificationJobResponseDto$Outbound` instead. */
  export type Outbound = ActivityNotificationJobResponseDto$Outbound;
}

export function activityNotificationJobResponseDtoToJSON(
  activityNotificationJobResponseDto: ActivityNotificationJobResponseDto
): string {
  return JSON.stringify(ActivityNotificationJobResponseDto$outboundSchema.parse(activityNotificationJobResponseDto));
}

export function activityNotificationJobResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<ActivityNotificationJobResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ActivityNotificationJobResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ActivityNotificationJobResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - activityNotificationJobResponseDtoPayloadToJSON(activityNotificationJobResponseDtoPayload: ActivityNotificationJobResponseDtoPayload)
 - activityNotificationJobResponseDtoPayloadFromJSON(jsonString: string)
 - activityNotificationJobResponseDtoToJSON(activityNotificationJobResponseDto: ActivityNotificationJobResponseDto)
 - activityNotificationJobResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ActivityNotificationJobResponseDtoPayload$Outbound;
}

export function activityNotificationJobRespon...)
 - Outbound(ActivityNotificationJobResponseDto$Outbound;
}

export function activityNotificationJobResponseDtoTo...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function activityNotificationJobResponseDtoPayloadToJSON
- export function activityNotificationJobResponseDtoPayloadFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function activityNotificationJobResponseDtoToJSON
- export function activityNotificationJobResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/activitynotificationresponsedto.ts
Tamaño: 8674 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ActivityNotificationJobResponseDto,
  ActivityNotificationJobResponseDto$inboundSchema,
  ActivityNotificationJobResponseDto$Outbound,
  ActivityNotificationJobResponseDto$outboundSchema,
} from './activitynotificationjobresponsedto.js';
import {
  ActivityNotificationSubscriberResponseDto,
  ActivityNotificationSubscriberResponseDto$inboundSchema,
  ActivityNotificationSubscriberResponseDto$Outbound,
  ActivityNotificationSubscriberResponseDto$outboundSchema,
} from './activitynotificationsubscriberresponsedto.js';
import {
  ActivityNotificationTemplateResponseDto,
  ActivityNotificationTemplateResponseDto$inboundSchema,
  ActivityNotificationTemplateResponseDto$Outbound,
  ActivityNotificationTemplateResponseDto$outboundSchema,
} from './activitynotificationtemplateresponsedto.js';
import {
  ActivityTopicDto,
  ActivityTopicDto$inboundSchema,
  ActivityTopicDto$Outbound,
  ActivityTopicDto$outboundSchema,
} from './activitytopicdto.js';
import {
  SeverityLevelEnum,
  SeverityLevelEnum$inboundSchema,
  SeverityLevelEnum$outboundSchema,
} from './severitylevelenum.js';
import { StepTypeEnum, StepTypeEnum$inboundSchema, StepTypeEnum$outboundSchema } from './steptypeenum.js';

export type ActivityNotificationResponseDto = {
  /**
   * Unique identifier of the notification
   */
  id?: string | undefined;
  /**
   * Environment ID of the notification
   */
  environmentId: string;
  /**
   * Organization ID of the notification
   */
  organizationId: string;
  /**
   * Subscriber ID of the notification
   */
  subscriberId: string;
  /**
   * Transaction ID of the notification
   */
  transactionId: string;
  /**
   * Template ID of the notification
   */
  templateId?: string | undefined;
  /**
   * Digested Notification ID
   */
  digestedNotificationId?: string | undefined;
  /**
   * Creation time of the notification
   */
  createdAt?: string | undefined;
  /**
   * Last updated time of the notification
   */
  updatedAt?: string | undefined;
  channels?: Array<StepTypeEnum> | undefined;
  /**
   * Subscriber of the notification
   */
  subscriber?: ActivityNotificationSubscriberResponseDto | undefined;
  /**
   * Template of the notification
   */
  template?: ActivityNotificationTemplateResponseDto | undefined;
  /**
   * Jobs of the notification
   */
  jobs?: Array<ActivityNotificationJobResponseDto> | undefined;
  /**
   * Payload of the notification
   */
  payload?: { [k: string]: any } | undefined;
  /**
   * Tags associated with the notification
   */
  tags?: Array<string> | undefined;
  /**
   * Controls associated with the notification
   */
  controls?: { [k: string]: any } | undefined;
  /**
   * To field for subscriber definition
   */
  to?: { [k: string]: any } | undefined;
  /**
   * Topics of the notification
   */
  topics?: Array<ActivityTopicDto> | undefined;
  /**
   * Severity of the workflow
   */
  severity?: SeverityLevelEnum | undefined;
  /**
   * Criticality of the notification
   */
  critical?: boolean | undefined;
  /**
   * Contexts (keys) in which the notification was sent
   */
  contextKeys?: Array<string> | undefined;
};

/** @internal */
export const ActivityNotificationResponseDto$inboundSchema: z.ZodType<
  ActivityNotificationResponseDto,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    _id: z.string().optional(),
    _environmentId: z.string(),
    _organizationId: z.string(),
    _subscriberId: z.string(),
    transactionId: z.string(),
    _templateId: z.string().optional(),
    _digestedNotificationId: z.string().optional(),
    createdAt: z.string().optional(),
    updatedAt: z.string().optional(),
    channels: z.array(StepTypeEnum$inboundSchema).optional(),
    subscriber: ActivityNotificationSubscriberResponseDto$inboundSchema.optional(),
    template: ActivityNotificationTemplateResponseDto$inboundSchema.optional(),
    jobs: z.array(ActivityNotificationJobResponseDto$inboundSchema).optional(),
    payload: z.record(z.any()).optional(),
    tags: z.array(z.string()).optional(),
    controls: z.record(z.any()).optional(),
    to: z.record(z.any()).optional(),
    topics: z.array(ActivityTopicDto$inboundSchema).optional(),
    severity: SeverityLevelEnum$inboundSchema.optional(),
    critical: z.boolean().optional(),
    contextKeys: z.array(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
      _environmentId: 'environmentId',
      _organizationId: 'organizationId',
      _subscriberId: 'subscriberId',
      _templateId: 'templateId',
      _digestedNotificationId: 'digestedNotificationId',
    });
  });

/** @internal */
export type ActivityNotificationResponseDto$Outbound = {
  _id?: string | undefined;
  _environmentId: string;
  _organizationId: string;
  _subscriberId: string;
  transactionId: string;
  _templateId?: string | undefined;
  _digestedNotificationId?: string | undefined;
  createdAt?: string | undefined;
  updatedAt?: string | undefined;
  channels?: Array<string> | undefined;
  subscriber?: ActivityNotificationSubscriberResponseDto$Outbound | undefined;
  template?: ActivityNotificationTemplateResponseDto$Outbound | undefined;
  jobs?: Array<ActivityNotificationJobResponseDto$Outbound> | undefined;
  payload?: { [k: string]: any } | undefined;
  tags?: Array<string> | undefined;
  controls?: { [k: string]: any } | undefined;
  to?: { [k: string]: any } | undefined;
  topics?: Array<ActivityTopicDto$Outbound> | undefined;
  severity?: string | undefined;
  critical?: boolean | undefined;
  contextKeys?: Array<string> | undefined;
};

/** @internal */
export const ActivityNotificationResponseDto$outboundSchema: z.ZodType<
  ActivityNotificationResponseDto$Outbound,
  z.ZodTypeDef,
  ActivityNotificationResponseDto
> = z
  .object({
    id: z.string().optional(),
    environmentId: z.string(),
    organizationId: z.string(),
    subscriberId: z.string(),
    transactionId: z.string(),
    templateId: z.string().optional(),
    digestedNotificationId: z.string().optional(),
    createdAt: z.string().optional(),
    updatedAt: z.string().optional(),
    channels: z.array(StepTypeEnum$outboundSchema).optional(),
    subscriber: ActivityNotificationSubscriberResponseDto$outboundSchema.optional(),
    template: ActivityNotificationTemplateResponseDto$outboundSchema.optional(),
    jobs: z.array(ActivityNotificationJobResponseDto$outboundSchema).optional(),
    payload: z.record(z.any()).optional(),
    tags: z.array(z.string()).optional(),
    controls: z.record(z.any()).optional(),
    to: z.record(z.any()).optional(),
    topics: z.array(ActivityTopicDto$outboundSchema).optional(),
    severity: SeverityLevelEnum$outboundSchema.optional(),
    critical: z.boolean().optional(),
    contextKeys: z.array(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
      environmentId: '_environmentId',
      organizationId: '_organizationId',
      subscriberId: '_subscriberId',
      templateId: '_templateId',
      digestedNotificationId: '_digestedNotificationId',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ActivityNotificationResponseDto$ {
  /** @deprecated use `ActivityNotificationResponseDto$inboundSchema` instead. */
  export const inboundSchema = ActivityNotificationResponseDto$inboundSchema;
  /** @deprecated use `ActivityNotificationResponseDto$outboundSchema` instead. */
  export const outboundSchema = ActivityNotificationResponseDto$outboundSchema;
  /** @deprecated use `ActivityNotificationResponseDto$Outbound` instead. */
  export type Outbound = ActivityNotificationResponseDto$Outbound;
}

export function activityNotificationResponseDtoToJSON(
  activityNotificationResponseDto: ActivityNotificationResponseDto
): string {
  return JSON.stringify(ActivityNotificationResponseDto$outboundSchema.parse(activityNotificationResponseDto));
}

export function activityNotificationResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<ActivityNotificationResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ActivityNotificationResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ActivityNotificationResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - activityNotificationResponseDtoToJSON(activityNotificationResponseDto: ActivityNotificationResponseDto)
 - activityNotificationResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ActivityNotificationResponseDto$Outbound;
}

export function activityNotificationResponseDtoToJSON(
...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function activityNotificationResponseDtoToJSON
- export function activityNotificationResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/activitynotificationstepresponsedto.ts
Tamaño: 12756 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  MessageTemplateDto,
  MessageTemplateDto$inboundSchema,
  MessageTemplateDto$Outbound,
  MessageTemplateDto$outboundSchema,
} from './messagetemplatedto.js';
import {
  StepFilterDto,
  StepFilterDto$inboundSchema,
  StepFilterDto$Outbound,
  StepFilterDto$outboundSchema,
} from './stepfilterdto.js';

/**
 * Reply callback settings
 */
export type ActivityNotificationStepResponseDtoReplyCallback = {};

/**
 * Control variables
 */
export type ControlVariables = {};

/**
 * Metadata for the workflow step
 */
export type ActivityNotificationStepResponseDtoMetadata = {};

/**
 * Step issues
 */
export type Issues = {};

export type ActivityNotificationStepResponseDto = {
  /**
   * Unique identifier of the step
   */
  id: string;
  /**
   * Whether the step is active or not
   */
  active: boolean;
  /**
   * Reply callback settings
   */
  replyCallback?: ActivityNotificationStepResponseDtoReplyCallback | undefined;
  /**
   * Control variables
   */
  controlVariables?: ControlVariables | undefined;
  /**
   * Metadata for the workflow step
   */
  metadata?: ActivityNotificationStepResponseDtoMetadata | undefined;
  /**
   * Step issues
   */
  issues?: Issues | undefined;
  /**
   * Filter criteria for the step
   */
  filters: Array<StepFilterDto>;
  /**
   * Optional template for the step
   */
  template?: MessageTemplateDto | undefined;
  /**
   * Variants of the step
   */
  variants?: Array<ActivityNotificationStepResponseDto> | undefined;
  /**
   * The identifier for the template associated with this step
   */
  templateId: string;
  /**
   * The name of the step
   */
  name?: string | undefined;
  /**
   * The unique identifier for the parent step
   */
  parentId?: string | null | undefined;
};

/** @internal */
export const ActivityNotificationStepResponseDtoReplyCallback$inboundSchema: z.ZodType<
  ActivityNotificationStepResponseDtoReplyCallback,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type ActivityNotificationStepResponseDtoReplyCallback$Outbound = {};

/** @internal */
export const ActivityNotificationStepResponseDtoReplyCallback$outboundSchema: z.ZodType<
  ActivityNotificationStepResponseDtoReplyCallback$Outbound,
  z.ZodTypeDef,
  ActivityNotificationStepResponseDtoReplyCallback
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ActivityNotificationStepResponseDtoReplyCallback$ {
  /** @deprecated use `ActivityNotificationStepResponseDtoReplyCallback$inboundSchema` instead. */
  export const inboundSchema = ActivityNotificationStepResponseDtoReplyCallback$inboundSchema;
  /** @deprecated use `ActivityNotificationStepResponseDtoReplyCallback$outboundSchema` instead. */
  export const outboundSchema = ActivityNotificationStepResponseDtoReplyCallback$outboundSchema;
  /** @deprecated use `ActivityNotificationStepResponseDtoReplyCallback$Outbound` instead. */
  export type Outbound = ActivityNotificationStepResponseDtoReplyCallback$Outbound;
}

export function activityNotificationStepResponseDtoReplyCallbackToJSON(
  activityNotificationStepResponseDtoReplyCallback: ActivityNotificationStepResponseDtoReplyCallback
): string {
  return JSON.stringify(
    ActivityNotificationStepResponseDtoReplyCallback$outboundSchema.parse(
      activityNotificationStepResponseDtoReplyCallback
    )
  );
}

export function activityNotificationStepResponseDtoReplyCallbackFromJSON(
  jsonString: string
): SafeParseResult<ActivityNotificationStepResponseDtoReplyCallback, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ActivityNotificationStepResponseDtoReplyCallback$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ActivityNotificationStepResponseDtoReplyCallback' from JSON`
  );
}

/** @internal */
export const ControlVariables$inboundSchema: z.ZodType<ControlVariables, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type ControlVariables$Outbound = {};

/** @internal */
export const ControlVariables$outboundSchema: z.ZodType<ControlVariables$Outbound, z.ZodTypeDef, ControlVariables> =
  z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ControlVariables$ {
  /** @deprecated use `ControlVariables$inboundSchema` instead. */
  export const inboundSchema = ControlVariables$inboundSchema;
  /** @deprecated use `ControlVariables$outboundSchema` instead. */
  export const outboundSchema = ControlVariables$outboundSchema;
  /** @deprecated use `ControlVariables$Outbound` instead. */
  export type Outbound = ControlVariables$Outbound;
}

export function controlVariablesToJSON(controlVariables: ControlVariables): string {
  return JSON.stringify(ControlVariables$outboundSchema.parse(controlVariables));
}

export function controlVariablesFromJSON(jsonString: string): SafeParseResult<ControlVariables, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ControlVariables$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ControlVariables' from JSON`
  );
}

/** @internal */
export const ActivityNotificationStepResponseDtoMetadata$inboundSchema: z.ZodType<
  ActivityNotificationStepResponseDtoMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type ActivityNotificationStepResponseDtoMetadata$Outbound = {};

/** @internal */
export const ActivityNotificationStepResponseDtoMetadata$outboundSchema: z.ZodType<
  ActivityNotificationStepResponseDtoMetadata$Outbound,
  z.ZodTypeDef,
  ActivityNotificationStepResponseDtoMetadata
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ActivityNotificationStepResponseDtoMetadata$ {
  /** @deprecated use `ActivityNotificationStepResponseDtoMetadata$inboundSchema` instead. */
  export const inboundSchema = ActivityNotificationStepResponseDtoMetadata$inboundSchema;
  /** @deprecated use `ActivityNotificationStepResponseDtoMetadata$outboundSchema` instead. */
  export const outboundSchema = ActivityNotificationStepResponseDtoMetadata$outboundSchema;
  /** @deprecated use `ActivityNotificationStepResponseDtoMetadata$Outbound` instead. */
  export type Outbound = ActivityNotificationStepResponseDtoMetadata$Outbound;
}

export function activityNotificationStepResponseDtoMetadataToJSON(
  activityNotificationStepResponseDtoMetadata: ActivityNotificationStepResponseDtoMetadata
): string {
  return JSON.stringify(
    ActivityNotificationStepResponseDtoMetadata$outboundSchema.parse(activityNotificationStepResponseDtoMetadata)
  );
}

export function activityNotificationStepResponseDtoMetadataFromJSON(
  jsonString: string
): SafeParseResult<ActivityNotificationStepResponseDtoMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ActivityNotificationStepResponseDtoMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ActivityNotificationStepResponseDtoMetadata' from JSON`
  );
}

/** @internal */
export const Issues$inboundSchema: z.ZodType<Issues, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type Issues$Outbound = {};

/** @internal */
export const Issues$outboundSchema: z.ZodType<Issues$Outbound, z.ZodTypeDef, Issues> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Issues$ {
  /** @deprecated use `Issues$inboundSchema` instead. */
  export const inboundSchema = Issues$inboundSchema;
  /** @deprecated use `Issues$outboundSchema` instead. */
  export const outboundSchema = Issues$outboundSchema;
  /** @deprecated use `Issues$Outbound` instead. */
  export type Outbound = Issues$Outbound;
}

export function issuesToJSON(issues: Issues): string {
  return JSON.stringify(Issues$outboundSchema.parse(issues));
}

export function issuesFromJSON(jsonString: string): SafeParseResult<Issues, SDKValidationError> {
  return safeParse(jsonString, (x) => Issues$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Issues' from JSON`);
}

/** @internal */
export const ActivityNotificationStepResponseDto$inboundSchema: z.ZodType<
  ActivityNotificationStepResponseDto,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    _id: z.string(),
    active: z.boolean(),
    replyCallback: z.lazy(() => ActivityNotificationStepResponseDtoReplyCallback$inboundSchema).optional(),
    controlVariables: z.lazy(() => ControlVariables$inboundSchema).optional(),
    metadata: z.lazy(() => ActivityNotificationStepResponseDtoMetadata$inboundSchema).optional(),
    issues: z.lazy(() => Issues$inboundSchema).optional(),
    filters: z.array(StepFilterDto$inboundSchema),
    template: MessageTemplateDto$inboundSchema.optional(),
    variants: z.array(z.lazy(() => ActivityNotificationStepResponseDto$inboundSchema)).optional(),
    _templateId: z.string(),
    name: z.string().optional(),
    _parentId: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
      _templateId: 'templateId',
      _parentId: 'parentId',
    });
  });

/** @internal */
export type ActivityNotificationStepResponseDto$Outbound = {
  _id: string;
  active: boolean;
  replyCallback?: ActivityNotificationStepResponseDtoReplyCallback$Outbound | undefined;
  controlVariables?: ControlVariables$Outbound | undefined;
  metadata?: ActivityNotificationStepResponseDtoMetadata$Outbound | undefined;
  issues?: Issues$Outbound | undefined;
  filters: Array<StepFilterDto$Outbound>;
  template?: MessageTemplateDto$Outbound | undefined;
  variants?: Array<ActivityNotificationStepResponseDto$Outbound> | undefined;
  _templateId: string;
  name?: string | undefined;
  _parentId?: string | null | undefined;
};

/** @internal */
export const ActivityNotificationStepResponseDto$outboundSchema: z.ZodType<
  ActivityNotificationStepResponseDto$Outbound,
  z.ZodTypeDef,
  ActivityNotificationStepResponseDto
> = z
  .object({
    id: z.string(),
    active: z.boolean(),
    replyCallback: z.lazy(() => ActivityNotificationStepResponseDtoReplyCallback$outboundSchema).optional(),
    controlVariables: z.lazy(() => ControlVariables$outboundSchema).optional(),
    metadata: z.lazy(() => ActivityNotificationStepResponseDtoMetadata$outboundSchema).optional(),
    issues: z.lazy(() => Issues$outboundSchema).optional(),
    filters: z.array(StepFilterDto$outboundSchema),
    template: MessageTemplateDto$outboundSchema.optional(),
    variants: z.array(z.lazy(() => ActivityNotificationStepResponseDto$outboundSchema)).optional(),
    templateId: z.string(),
    name: z.string().optional(),
    parentId: z.nullable(z.string()).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
      templateId: '_templateId',
      parentId: '_parentId',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ActivityNotificationStepResponseDto$ {
  /** @deprecated use `ActivityNotificationStepResponseDto$inboundSchema` instead. */
  export const inboundSchema = ActivityNotificationStepResponseDto$inboundSchema;
  /** @deprecated use `ActivityNotificationStepResponseDto$outboundSchema` instead. */
  export const outboundSchema = ActivityNotificationStepResponseDto$outboundSchema;
  /** @deprecated use `ActivityNotificationStepResponseDto$Outbound` instead. */
  export type Outbound = ActivityNotificationStepResponseDto$Outbound;
}

export function activityNotificationStepResponseDtoToJSON(
  activityNotificationStepResponseDto: ActivityNotificationStepResponseDto
): string {
  return JSON.stringify(ActivityNotificationStepResponseDto$outboundSchema.parse(activityNotificationStepResponseDto));
}

export function activityNotificationStepResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<ActivityNotificationStepResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ActivityNotificationStepResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ActivityNotificationStepResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - activityNotificationStepResponseDtoReplyCallbackToJSON(activityNotificationStepResponseDtoReplyCallback: ActivityNotificationStepResponseDtoReplyCallback)
 - activityNotificationStepResponseDtoReplyCallbackFromJSON(jsonString: string)
 - controlVariablesToJSON(controlVariables: ControlVariables)
 - controlVariablesFromJSON(jsonString: string)
 - activityNotificationStepResponseDtoMetadataToJSON(activityNotificationStepResponseDtoMetadata: ActivityNotificationStepResponseDtoMetadata)
 - activityNotificationStepResponseDtoMetadataFromJSON(jsonString: string)
 - issuesToJSON(issues: Issues)
 - issuesFromJSON(jsonString: string)
 - activityNotificationStepResponseDtoToJSON(activityNotificationStepResponseDto: ActivityNotificationStepResponseDto)
 - activityNotificationStepResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ActivityNotificationStepResponseDtoReplyCallback$Outbound;
}

export function activityNotificationSt...)
 - Outbound(ControlVariables$Outbound;
}

export function controlVariablesToJSON(controlVariables: ControlVariab...)
 - Outbound(ActivityNotificationStepResponseDtoMetadata$Outbound;
}

export function activityNotificationStepRes...)
 - Outbound(Issues$Outbound;
}

export function issuesToJSON(issues: Issues): string {
  return JSON.stringify(I...)
 - Outbound(ActivityNotificationStepResponseDto$Outbound;
}

export function activityNotificationStepResponseDto...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function activityNotificationStepResponseDtoReplyCallbackToJSON
- export function activityNotificationStepResponseDtoReplyCallbackFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function controlVariablesToJSON
- export function controlVariablesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function activityNotificationStepResponseDtoMetadataToJSON
- export function activityNotificationStepResponseDtoMetadataFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function issuesToJSON
- export function issuesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function activityNotificationStepResponseDtoToJSON
- export function activityNotificationStepResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/activitynotificationsubscriberresponsedto.ts
Tamaño: 3552 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type ActivityNotificationSubscriberResponseDto = {
  /**
   * First name of the subscriber
   */
  firstName?: string | undefined;
  /**
   * External unique identifier of the subscriber
   */
  subscriberId: string;
  /**
   * Internal to Novu unique identifier of the subscriber
   */
  id: string;
  /**
   * Last name of the subscriber
   */
  lastName?: string | undefined;
  /**
   * Email address of the subscriber
   */
  email?: string | undefined;
  /**
   * Phone number of the subscriber
   */
  phone?: string | undefined;
};

/** @internal */
export const ActivityNotificationSubscriberResponseDto$inboundSchema: z.ZodType<
  ActivityNotificationSubscriberResponseDto,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    firstName: z.string().optional(),
    subscriberId: z.string(),
    _id: z.string(),
    lastName: z.string().optional(),
    email: z.string().optional(),
    phone: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type ActivityNotificationSubscriberResponseDto$Outbound = {
  firstName?: string | undefined;
  subscriberId: string;
  _id: string;
  lastName?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
};

/** @internal */
export const ActivityNotificationSubscriberResponseDto$outboundSchema: z.ZodType<
  ActivityNotificationSubscriberResponseDto$Outbound,
  z.ZodTypeDef,
  ActivityNotificationSubscriberResponseDto
> = z
  .object({
    firstName: z.string().optional(),
    subscriberId: z.string(),
    id: z.string(),
    lastName: z.string().optional(),
    email: z.string().optional(),
    phone: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ActivityNotificationSubscriberResponseDto$ {
  /** @deprecated use `ActivityNotificationSubscriberResponseDto$inboundSchema` instead. */
  export const inboundSchema = ActivityNotificationSubscriberResponseDto$inboundSchema;
  /** @deprecated use `ActivityNotificationSubscriberResponseDto$outboundSchema` instead. */
  export const outboundSchema = ActivityNotificationSubscriberResponseDto$outboundSchema;
  /** @deprecated use `ActivityNotificationSubscriberResponseDto$Outbound` instead. */
  export type Outbound = ActivityNotificationSubscriberResponseDto$Outbound;
}

export function activityNotificationSubscriberResponseDtoToJSON(
  activityNotificationSubscriberResponseDto: ActivityNotificationSubscriberResponseDto
): string {
  return JSON.stringify(
    ActivityNotificationSubscriberResponseDto$outboundSchema.parse(activityNotificationSubscriberResponseDto)
  );
}

export function activityNotificationSubscriberResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<ActivityNotificationSubscriberResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ActivityNotificationSubscriberResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ActivityNotificationSubscriberResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - activityNotificationSubscriberResponseDtoToJSON(activityNotificationSubscriberResponseDto: ActivityNotificationSubscriberResponseDto)
 - activityNotificationSubscriberResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ActivityNotificationSubscriberResponseDto$Outbound;
}

export function activityNotificationSubscribe...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function activityNotificationSubscriberResponseDtoToJSON
- export function activityNotificationSubscriberResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/activitynotificationtemplateresponsedto.ts
Tamaño: 3565 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  NotificationTriggerDto,
  NotificationTriggerDto$inboundSchema,
  NotificationTriggerDto$Outbound,
  NotificationTriggerDto$outboundSchema,
} from './notificationtriggerdto.js';
import {
  ResourceOriginEnum,
  ResourceOriginEnum$inboundSchema,
  ResourceOriginEnum$outboundSchema,
} from './resourceoriginenum.js';

export type ActivityNotificationTemplateResponseDto = {
  /**
   * Unique identifier of the template
   */
  id?: string | undefined;
  /**
   * Name of the template
   */
  name: string;
  /**
   * Origin of the layout
   */
  origin?: ResourceOriginEnum | undefined;
  /**
   * Triggers of the template
   */
  triggers: Array<NotificationTriggerDto>;
};

/** @internal */
export const ActivityNotificationTemplateResponseDto$inboundSchema: z.ZodType<
  ActivityNotificationTemplateResponseDto,
  z.ZodTypeDef,
  unknown
> = z
  .object({
    _id: z.string().optional(),
    name: z.string(),
    origin: ResourceOriginEnum$inboundSchema.optional(),
    triggers: z.array(NotificationTriggerDto$inboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type ActivityNotificationTemplateResponseDto$Outbound = {
  _id?: string | undefined;
  name: string;
  origin?: string | undefined;
  triggers: Array<NotificationTriggerDto$Outbound>;
};

/** @internal */
export const ActivityNotificationTemplateResponseDto$outboundSchema: z.ZodType<
  ActivityNotificationTemplateResponseDto$Outbound,
  z.ZodTypeDef,
  ActivityNotificationTemplateResponseDto
> = z
  .object({
    id: z.string().optional(),
    name: z.string(),
    origin: ResourceOriginEnum$outboundSchema.optional(),
    triggers: z.array(NotificationTriggerDto$outboundSchema),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ActivityNotificationTemplateResponseDto$ {
  /** @deprecated use `ActivityNotificationTemplateResponseDto$inboundSchema` instead. */
  export const inboundSchema = ActivityNotificationTemplateResponseDto$inboundSchema;
  /** @deprecated use `ActivityNotificationTemplateResponseDto$outboundSchema` instead. */
  export const outboundSchema = ActivityNotificationTemplateResponseDto$outboundSchema;
  /** @deprecated use `ActivityNotificationTemplateResponseDto$Outbound` instead. */
  export type Outbound = ActivityNotificationTemplateResponseDto$Outbound;
}

export function activityNotificationTemplateResponseDtoToJSON(
  activityNotificationTemplateResponseDto: ActivityNotificationTemplateResponseDto
): string {
  return JSON.stringify(
    ActivityNotificationTemplateResponseDto$outboundSchema.parse(activityNotificationTemplateResponseDto)
  );
}

export function activityNotificationTemplateResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<ActivityNotificationTemplateResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ActivityNotificationTemplateResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ActivityNotificationTemplateResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - activityNotificationTemplateResponseDtoToJSON(activityNotificationTemplateResponseDto: ActivityNotificationTemplateResponseDto)
 - activityNotificationTemplateResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ActivityNotificationTemplateResponseDto$Outbound;
}

export function activityNotificationTemplateRes...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function activityNotificationTemplateResponseDtoToJSON
- export function activityNotificationTemplateResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/activitytopicdto.ts
Tamaño: 2211 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type ActivityTopicDto = {
  /**
   * Internal Topic ID of the notification
   */
  topicId: string;
  /**
   * Topic Key of the notification
   */
  topicKey: string;
};

/** @internal */
export const ActivityTopicDto$inboundSchema: z.ZodType<ActivityTopicDto, z.ZodTypeDef, unknown> = z
  .object({
    _topicId: z.string(),
    topicKey: z.string(),
  })
  .transform((v) => {
    return remap$(v, {
      _topicId: 'topicId',
    });
  });

/** @internal */
export type ActivityTopicDto$Outbound = {
  _topicId: string;
  topicKey: string;
};

/** @internal */
export const ActivityTopicDto$outboundSchema: z.ZodType<ActivityTopicDto$Outbound, z.ZodTypeDef, ActivityTopicDto> = z
  .object({
    topicId: z.string(),
    topicKey: z.string(),
  })
  .transform((v) => {
    return remap$(v, {
      topicId: '_topicId',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ActivityTopicDto$ {
  /** @deprecated use `ActivityTopicDto$inboundSchema` instead. */
  export const inboundSchema = ActivityTopicDto$inboundSchema;
  /** @deprecated use `ActivityTopicDto$outboundSchema` instead. */
  export const outboundSchema = ActivityTopicDto$outboundSchema;
  /** @deprecated use `ActivityTopicDto$Outbound` instead. */
  export type Outbound = ActivityTopicDto$Outbound;
}

export function activityTopicDtoToJSON(activityTopicDto: ActivityTopicDto): string {
  return JSON.stringify(ActivityTopicDto$outboundSchema.parse(activityTopicDto));
}

export function activityTopicDtoFromJSON(jsonString: string): SafeParseResult<ActivityTopicDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ActivityTopicDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ActivityTopicDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - activityTopicDtoToJSON(activityTopicDto: ActivityTopicDto)
 - activityTopicDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ActivityTopicDto$Outbound;
}

export function activityTopicDtoToJSON(activityTopicDto: ActivityTopic...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function activityTopicDtoToJSON
- export function activityTopicDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/actorfeeditemdto.ts
Tamaño: 2204 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import { ActorTypeEnum, ActorTypeEnum$inboundSchema, ActorTypeEnum$outboundSchema } from './actortypeenum.js';

export type ActorFeedItemDto = {
  /**
   * The data associated with the actor, can be null if not applicable.
   */
  data: string | null;
  /**
   * The type of the actor, indicating the role in the notification process.
   */
  type: ActorTypeEnum;
};

/** @internal */
export const ActorFeedItemDto$inboundSchema: z.ZodType<ActorFeedItemDto, z.ZodTypeDef, unknown> = z.object({
  data: z.nullable(z.string()),
  type: ActorTypeEnum$inboundSchema,
});

/** @internal */
export type ActorFeedItemDto$Outbound = {
  data: string | null;
  type: string;
};

/** @internal */
export const ActorFeedItemDto$outboundSchema: z.ZodType<ActorFeedItemDto$Outbound, z.ZodTypeDef, ActorFeedItemDto> =
  z.object({
    data: z.nullable(z.string()),
    type: ActorTypeEnum$outboundSchema,
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ActorFeedItemDto$ {
  /** @deprecated use `ActorFeedItemDto$inboundSchema` instead. */
  export const inboundSchema = ActorFeedItemDto$inboundSchema;
  /** @deprecated use `ActorFeedItemDto$outboundSchema` instead. */
  export const outboundSchema = ActorFeedItemDto$outboundSchema;
  /** @deprecated use `ActorFeedItemDto$Outbound` instead. */
  export type Outbound = ActorFeedItemDto$Outbound;
}

export function actorFeedItemDtoToJSON(actorFeedItemDto: ActorFeedItemDto): string {
  return JSON.stringify(ActorFeedItemDto$outboundSchema.parse(actorFeedItemDto));
}

export function actorFeedItemDtoFromJSON(jsonString: string): SafeParseResult<ActorFeedItemDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ActorFeedItemDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ActorFeedItemDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - actorFeedItemDtoToJSON(actorFeedItemDto: ActorFeedItemDto)
 - actorFeedItemDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ActorFeedItemDto$Outbound;
}

export function actorFeedItemDtoToJSON(actorFeedItemDto: ActorFeedItem...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function actorFeedItemDtoToJSON
- export function actorFeedItemDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/actortypeenum.ts
Tamaño: 1224 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * The type of the actor, indicating the role in the notification process.
 */
export const ActorTypeEnum = {
  None: 'none',
  User: 'user',
  SystemIcon: 'system_icon',
  SystemCustom: 'system_custom',
} as const;
/**
 * The type of the actor, indicating the role in the notification process.
 */
export type ActorTypeEnum = ClosedEnum<typeof ActorTypeEnum>;

/** @internal */
export const ActorTypeEnum$inboundSchema: z.ZodNativeEnum<typeof ActorTypeEnum> = z.nativeEnum(ActorTypeEnum);

/** @internal */
export const ActorTypeEnum$outboundSchema: z.ZodNativeEnum<typeof ActorTypeEnum> = ActorTypeEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ActorTypeEnum$ {
  /** @deprecated use `ActorTypeEnum$inboundSchema` instead. */
  export const inboundSchema = ActorTypeEnum$inboundSchema;
  /** @deprecated use `ActorTypeEnum$outboundSchema` instead. */
  export const outboundSchema = ActorTypeEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/apikeydto.ts
Tamaño: 2176 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type ApiKeyDto = {
  /**
   * API key
   */
  key: string;
  /**
   * User ID associated with the API key
   */
  userId: string;
  /**
   * Hashed representation of the API key
   */
  hash?: string | undefined;
};

/** @internal */
export const ApiKeyDto$inboundSchema: z.ZodType<ApiKeyDto, z.ZodTypeDef, unknown> = z
  .object({
    key: z.string(),
    _userId: z.string(),
    hash: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _userId: 'userId',
    });
  });

/** @internal */
export type ApiKeyDto$Outbound = {
  key: string;
  _userId: string;
  hash?: string | undefined;
};

/** @internal */
export const ApiKeyDto$outboundSchema: z.ZodType<ApiKeyDto$Outbound, z.ZodTypeDef, ApiKeyDto> = z
  .object({
    key: z.string(),
    userId: z.string(),
    hash: z.string().optional(),
  })
  .transform((v) => {
    return remap$(v, {
      userId: '_userId',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ApiKeyDto$ {
  /** @deprecated use `ApiKeyDto$inboundSchema` instead. */
  export const inboundSchema = ApiKeyDto$inboundSchema;
  /** @deprecated use `ApiKeyDto$outboundSchema` instead. */
  export const outboundSchema = ApiKeyDto$outboundSchema;
  /** @deprecated use `ApiKeyDto$Outbound` instead. */
  export type Outbound = ApiKeyDto$Outbound;
}

export function apiKeyDtoToJSON(apiKeyDto: ApiKeyDto): string {
  return JSON.stringify(ApiKeyDto$outboundSchema.parse(apiKeyDto));
}

export function apiKeyDtoFromJSON(jsonString: string): SafeParseResult<ApiKeyDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ApiKeyDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ApiKeyDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - apiKeyDtoToJSON(apiKeyDto: ApiKeyDto)
 - apiKeyDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ApiKeyDto$Outbound;
}

export function apiKeyDtoToJSON(apiKeyDto: ApiKeyDto): string {
  return JSON...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function apiKeyDtoToJSON
- export function apiKeyDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/autoconfigureintegrationresponsedto.ts
Tamaño: 4164 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * The updated configurations after auto-configuration
 */
export type Integration = {};

export type AutoConfigureIntegrationResponseDto = {
  /**
   * Indicates whether the auto-configuration was successful
   */
  success: boolean;
  /**
   * Optional message describing the result or any errors that occurred
   */
  message?: string | undefined;
  /**
   * The updated configurations after auto-configuration
   */
  integration?: Integration | undefined;
};

/** @internal */
export const Integration$inboundSchema: z.ZodType<Integration, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type Integration$Outbound = {};

/** @internal */
export const Integration$outboundSchema: z.ZodType<Integration$Outbound, z.ZodTypeDef, Integration> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Integration$ {
  /** @deprecated use `Integration$inboundSchema` instead. */
  export const inboundSchema = Integration$inboundSchema;
  /** @deprecated use `Integration$outboundSchema` instead. */
  export const outboundSchema = Integration$outboundSchema;
  /** @deprecated use `Integration$Outbound` instead. */
  export type Outbound = Integration$Outbound;
}

export function integrationToJSON(integration: Integration): string {
  return JSON.stringify(Integration$outboundSchema.parse(integration));
}

export function integrationFromJSON(jsonString: string): SafeParseResult<Integration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Integration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Integration' from JSON`
  );
}

/** @internal */
export const AutoConfigureIntegrationResponseDto$inboundSchema: z.ZodType<
  AutoConfigureIntegrationResponseDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  success: z.boolean(),
  message: z.string().optional(),
  integration: z.lazy(() => Integration$inboundSchema).optional(),
});

/** @internal */
export type AutoConfigureIntegrationResponseDto$Outbound = {
  success: boolean;
  message?: string | undefined;
  integration?: Integration$Outbound | undefined;
};

/** @internal */
export const AutoConfigureIntegrationResponseDto$outboundSchema: z.ZodType<
  AutoConfigureIntegrationResponseDto$Outbound,
  z.ZodTypeDef,
  AutoConfigureIntegrationResponseDto
> = z.object({
  success: z.boolean(),
  message: z.string().optional(),
  integration: z.lazy(() => Integration$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AutoConfigureIntegrationResponseDto$ {
  /** @deprecated use `AutoConfigureIntegrationResponseDto$inboundSchema` instead. */
  export const inboundSchema = AutoConfigureIntegrationResponseDto$inboundSchema;
  /** @deprecated use `AutoConfigureIntegrationResponseDto$outboundSchema` instead. */
  export const outboundSchema = AutoConfigureIntegrationResponseDto$outboundSchema;
  /** @deprecated use `AutoConfigureIntegrationResponseDto$Outbound` instead. */
  export type Outbound = AutoConfigureIntegrationResponseDto$Outbound;
}

export function autoConfigureIntegrationResponseDtoToJSON(
  autoConfigureIntegrationResponseDto: AutoConfigureIntegrationResponseDto
): string {
  return JSON.stringify(AutoConfigureIntegrationResponseDto$outboundSchema.parse(autoConfigureIntegrationResponseDto));
}

export function autoConfigureIntegrationResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<AutoConfigureIntegrationResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AutoConfigureIntegrationResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AutoConfigureIntegrationResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - integrationToJSON(integration: Integration)
 - integrationFromJSON(jsonString: string)
 - autoConfigureIntegrationResponseDtoToJSON(autoConfigureIntegrationResponseDto: AutoConfigureIntegrationResponseDto)
 - autoConfigureIntegrationResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Integration$Outbound;
}

export function integrationToJSON(integration: Integration): string {
  ret...)
 - Outbound(AutoConfigureIntegrationResponseDto$Outbound;
}

export function autoConfigureIntegrationResponseDto...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function integrationToJSON
- export function integrationFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function autoConfigureIntegrationResponseDtoToJSON
- export function autoConfigureIntegrationResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/bridgeconfigurationdto.ts
Tamaño: 1954 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type BridgeConfigurationDto = {
  url?: string | undefined;
};

/** @internal */
export const BridgeConfigurationDto$inboundSchema: z.ZodType<BridgeConfigurationDto, z.ZodTypeDef, unknown> = z.object({
  url: z.string().optional(),
});

/** @internal */
export type BridgeConfigurationDto$Outbound = {
  url?: string | undefined;
};

/** @internal */
export const BridgeConfigurationDto$outboundSchema: z.ZodType<
  BridgeConfigurationDto$Outbound,
  z.ZodTypeDef,
  BridgeConfigurationDto
> = z.object({
  url: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BridgeConfigurationDto$ {
  /** @deprecated use `BridgeConfigurationDto$inboundSchema` instead. */
  export const inboundSchema = BridgeConfigurationDto$inboundSchema;
  /** @deprecated use `BridgeConfigurationDto$outboundSchema` instead. */
  export const outboundSchema = BridgeConfigurationDto$outboundSchema;
  /** @deprecated use `BridgeConfigurationDto$Outbound` instead. */
  export type Outbound = BridgeConfigurationDto$Outbound;
}

export function bridgeConfigurationDtoToJSON(bridgeConfigurationDto: BridgeConfigurationDto): string {
  return JSON.stringify(BridgeConfigurationDto$outboundSchema.parse(bridgeConfigurationDto));
}

export function bridgeConfigurationDtoFromJSON(
  jsonString: string
): SafeParseResult<BridgeConfigurationDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BridgeConfigurationDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BridgeConfigurationDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - bridgeConfigurationDtoToJSON(bridgeConfigurationDto: BridgeConfigurationDto)
 - bridgeConfigurationDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(BridgeConfigurationDto$Outbound;
}

export function bridgeConfigurationDtoToJSON(bridgeConfiguration...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function bridgeConfigurationDtoToJSON
- export function bridgeConfigurationDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/builderfieldtypeenum.ts
Tamaño: 1227 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

export const BuilderFieldTypeEnum = {
  Boolean: 'BOOLEAN',
  Text: 'TEXT',
  Date: 'DATE',
  Number: 'NUMBER',
  Statement: 'STATEMENT',
  List: 'LIST',
  MultiList: 'MULTI_LIST',
  Group: 'GROUP',
} as const;
export type BuilderFieldTypeEnum = ClosedEnum<typeof BuilderFieldTypeEnum>;

/** @internal */
export const BuilderFieldTypeEnum$inboundSchema: z.ZodNativeEnum<typeof BuilderFieldTypeEnum> =
  z.nativeEnum(BuilderFieldTypeEnum);

/** @internal */
export const BuilderFieldTypeEnum$outboundSchema: z.ZodNativeEnum<typeof BuilderFieldTypeEnum> =
  BuilderFieldTypeEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BuilderFieldTypeEnum$ {
  /** @deprecated use `BuilderFieldTypeEnum$inboundSchema` instead. */
  export const inboundSchema = BuilderFieldTypeEnum$inboundSchema;
  /** @deprecated use `BuilderFieldTypeEnum$outboundSchema` instead. */
  export const outboundSchema = BuilderFieldTypeEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/bulkcreatesubscriberresponsedto.ts
Tamaño: 3420 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  CreatedSubscriberDto,
  CreatedSubscriberDto$inboundSchema,
  CreatedSubscriberDto$Outbound,
  CreatedSubscriberDto$outboundSchema,
} from './createdsubscriberdto.js';
import {
  FailedOperationDto,
  FailedOperationDto$inboundSchema,
  FailedOperationDto$Outbound,
  FailedOperationDto$outboundSchema,
} from './failedoperationdto.js';
import {
  UpdatedSubscriberDto,
  UpdatedSubscriberDto$inboundSchema,
  UpdatedSubscriberDto$Outbound,
  UpdatedSubscriberDto$outboundSchema,
} from './updatedsubscriberdto.js';

export type BulkCreateSubscriberResponseDto = {
  /**
   * An array of subscribers that were successfully updated.
   */
  updated: Array<UpdatedSubscriberDto>;
  /**
   * An array of subscribers that were successfully created.
   */
  created: Array<CreatedSubscriberDto>;
  /**
   * An array of failed operations with error messages and optional subscriber IDs.
   */
  failed: Array<FailedOperationDto>;
};

/** @internal */
export const BulkCreateSubscriberResponseDto$inboundSchema: z.ZodType<
  BulkCreateSubscriberResponseDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  updated: z.array(UpdatedSubscriberDto$inboundSchema),
  created: z.array(CreatedSubscriberDto$inboundSchema),
  failed: z.array(FailedOperationDto$inboundSchema),
});

/** @internal */
export type BulkCreateSubscriberResponseDto$Outbound = {
  updated: Array<UpdatedSubscriberDto$Outbound>;
  created: Array<CreatedSubscriberDto$Outbound>;
  failed: Array<FailedOperationDto$Outbound>;
};

/** @internal */
export const BulkCreateSubscriberResponseDto$outboundSchema: z.ZodType<
  BulkCreateSubscriberResponseDto$Outbound,
  z.ZodTypeDef,
  BulkCreateSubscriberResponseDto
> = z.object({
  updated: z.array(UpdatedSubscriberDto$outboundSchema),
  created: z.array(CreatedSubscriberDto$outboundSchema),
  failed: z.array(FailedOperationDto$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BulkCreateSubscriberResponseDto$ {
  /** @deprecated use `BulkCreateSubscriberResponseDto$inboundSchema` instead. */
  export const inboundSchema = BulkCreateSubscriberResponseDto$inboundSchema;
  /** @deprecated use `BulkCreateSubscriberResponseDto$outboundSchema` instead. */
  export const outboundSchema = BulkCreateSubscriberResponseDto$outboundSchema;
  /** @deprecated use `BulkCreateSubscriberResponseDto$Outbound` instead. */
  export type Outbound = BulkCreateSubscriberResponseDto$Outbound;
}

export function bulkCreateSubscriberResponseDtoToJSON(
  bulkCreateSubscriberResponseDto: BulkCreateSubscriberResponseDto
): string {
  return JSON.stringify(BulkCreateSubscriberResponseDto$outboundSchema.parse(bulkCreateSubscriberResponseDto));
}

export function bulkCreateSubscriberResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<BulkCreateSubscriberResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BulkCreateSubscriberResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BulkCreateSubscriberResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - bulkCreateSubscriberResponseDtoToJSON(bulkCreateSubscriberResponseDto: BulkCreateSubscriberResponseDto)
 - bulkCreateSubscriberResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(BulkCreateSubscriberResponseDto$Outbound;
}

export function bulkCreateSubscriberResponseDtoToJSON(
...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function bulkCreateSubscriberResponseDtoToJSON
- export function bulkCreateSubscriberResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/bulksubscribercreatedto.ts
Tamaño: 2382 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  CreateSubscriberRequestDto,
  CreateSubscriberRequestDto$inboundSchema,
  CreateSubscriberRequestDto$Outbound,
  CreateSubscriberRequestDto$outboundSchema,
} from './createsubscriberrequestdto.js';

export type BulkSubscriberCreateDto = {
  /**
   * An array of subscribers to be created in bulk.
   */
  subscribers: Array<CreateSubscriberRequestDto>;
};

/** @internal */
export const BulkSubscriberCreateDto$inboundSchema: z.ZodType<BulkSubscriberCreateDto, z.ZodTypeDef, unknown> =
  z.object({
    subscribers: z.array(CreateSubscriberRequestDto$inboundSchema),
  });

/** @internal */
export type BulkSubscriberCreateDto$Outbound = {
  subscribers: Array<CreateSubscriberRequestDto$Outbound>;
};

/** @internal */
export const BulkSubscriberCreateDto$outboundSchema: z.ZodType<
  BulkSubscriberCreateDto$Outbound,
  z.ZodTypeDef,
  BulkSubscriberCreateDto
> = z.object({
  subscribers: z.array(CreateSubscriberRequestDto$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BulkSubscriberCreateDto$ {
  /** @deprecated use `BulkSubscriberCreateDto$inboundSchema` instead. */
  export const inboundSchema = BulkSubscriberCreateDto$inboundSchema;
  /** @deprecated use `BulkSubscriberCreateDto$outboundSchema` instead. */
  export const outboundSchema = BulkSubscriberCreateDto$outboundSchema;
  /** @deprecated use `BulkSubscriberCreateDto$Outbound` instead. */
  export type Outbound = BulkSubscriberCreateDto$Outbound;
}

export function bulkSubscriberCreateDtoToJSON(bulkSubscriberCreateDto: BulkSubscriberCreateDto): string {
  return JSON.stringify(BulkSubscriberCreateDto$outboundSchema.parse(bulkSubscriberCreateDto));
}

export function bulkSubscriberCreateDtoFromJSON(
  jsonString: string
): SafeParseResult<BulkSubscriberCreateDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BulkSubscriberCreateDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BulkSubscriberCreateDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - bulkSubscriberCreateDtoToJSON(bulkSubscriberCreateDto: BulkSubscriberCreateDto)
 - bulkSubscriberCreateDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(BulkSubscriberCreateDto$Outbound;
}

export function bulkSubscriberCreateDtoToJSON(bulkSubscriberCre...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function bulkSubscriberCreateDtoToJSON
- export function bulkSubscriberCreateDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/bulktriggereventdto.ts
Tamaño: 2164 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  TriggerEventRequestDto,
  TriggerEventRequestDto$inboundSchema,
  TriggerEventRequestDto$Outbound,
  TriggerEventRequestDto$outboundSchema,
} from './triggereventrequestdto.js';

export type BulkTriggerEventDto = {
  events: Array<TriggerEventRequestDto>;
};

/** @internal */
export const BulkTriggerEventDto$inboundSchema: z.ZodType<BulkTriggerEventDto, z.ZodTypeDef, unknown> = z.object({
  events: z.array(TriggerEventRequestDto$inboundSchema),
});

/** @internal */
export type BulkTriggerEventDto$Outbound = {
  events: Array<TriggerEventRequestDto$Outbound>;
};

/** @internal */
export const BulkTriggerEventDto$outboundSchema: z.ZodType<
  BulkTriggerEventDto$Outbound,
  z.ZodTypeDef,
  BulkTriggerEventDto
> = z.object({
  events: z.array(TriggerEventRequestDto$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BulkTriggerEventDto$ {
  /** @deprecated use `BulkTriggerEventDto$inboundSchema` instead. */
  export const inboundSchema = BulkTriggerEventDto$inboundSchema;
  /** @deprecated use `BulkTriggerEventDto$outboundSchema` instead. */
  export const outboundSchema = BulkTriggerEventDto$outboundSchema;
  /** @deprecated use `BulkTriggerEventDto$Outbound` instead. */
  export type Outbound = BulkTriggerEventDto$Outbound;
}

export function bulkTriggerEventDtoToJSON(bulkTriggerEventDto: BulkTriggerEventDto): string {
  return JSON.stringify(BulkTriggerEventDto$outboundSchema.parse(bulkTriggerEventDto));
}

export function bulkTriggerEventDtoFromJSON(
  jsonString: string
): SafeParseResult<BulkTriggerEventDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BulkTriggerEventDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BulkTriggerEventDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - bulkTriggerEventDtoToJSON(bulkTriggerEventDto: BulkTriggerEventDto)
 - bulkTriggerEventDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(BulkTriggerEventDto$Outbound;
}

export function bulkTriggerEventDtoToJSON(bulkTriggerEventDto: Bulk...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function bulkTriggerEventDtoToJSON
- export function bulkTriggerEventDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/bulkupdatesubscriberpreferenceitemdto.ts
Tamaño: 2819 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  PatchPreferenceChannelsDto,
  PatchPreferenceChannelsDto$inboundSchema,
  PatchPreferenceChannelsDto$Outbound,
  PatchPreferenceChannelsDto$outboundSchema,
} from './patchpreferencechannelsdto.js';

export type BulkUpdateSubscriberPreferenceItemDto = {
  /**
   * Channel-specific preference settings
   */
  channels: PatchPreferenceChannelsDto;
  /**
   * Workflow internal _id, identifier or slug
   */
  workflowId: string;
};

/** @internal */
export const BulkUpdateSubscriberPreferenceItemDto$inboundSchema: z.ZodType<
  BulkUpdateSubscriberPreferenceItemDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  channels: PatchPreferenceChannelsDto$inboundSchema,
  workflowId: z.string(),
});

/** @internal */
export type BulkUpdateSubscriberPreferenceItemDto$Outbound = {
  channels: PatchPreferenceChannelsDto$Outbound;
  workflowId: string;
};

/** @internal */
export const BulkUpdateSubscriberPreferenceItemDto$outboundSchema: z.ZodType<
  BulkUpdateSubscriberPreferenceItemDto$Outbound,
  z.ZodTypeDef,
  BulkUpdateSubscriberPreferenceItemDto
> = z.object({
  channels: PatchPreferenceChannelsDto$outboundSchema,
  workflowId: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BulkUpdateSubscriberPreferenceItemDto$ {
  /** @deprecated use `BulkUpdateSubscriberPreferenceItemDto$inboundSchema` instead. */
  export const inboundSchema = BulkUpdateSubscriberPreferenceItemDto$inboundSchema;
  /** @deprecated use `BulkUpdateSubscriberPreferenceItemDto$outboundSchema` instead. */
  export const outboundSchema = BulkUpdateSubscriberPreferenceItemDto$outboundSchema;
  /** @deprecated use `BulkUpdateSubscriberPreferenceItemDto$Outbound` instead. */
  export type Outbound = BulkUpdateSubscriberPreferenceItemDto$Outbound;
}

export function bulkUpdateSubscriberPreferenceItemDtoToJSON(
  bulkUpdateSubscriberPreferenceItemDto: BulkUpdateSubscriberPreferenceItemDto
): string {
  return JSON.stringify(
    BulkUpdateSubscriberPreferenceItemDto$outboundSchema.parse(bulkUpdateSubscriberPreferenceItemDto)
  );
}

export function bulkUpdateSubscriberPreferenceItemDtoFromJSON(
  jsonString: string
): SafeParseResult<BulkUpdateSubscriberPreferenceItemDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BulkUpdateSubscriberPreferenceItemDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BulkUpdateSubscriberPreferenceItemDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - bulkUpdateSubscriberPreferenceItemDtoToJSON(bulkUpdateSubscriberPreferenceItemDto: BulkUpdateSubscriberPreferenceItemDto)
 - bulkUpdateSubscriberPreferenceItemDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(BulkUpdateSubscriberPreferenceItemDto$Outbound;
}

export function bulkUpdateSubscriberPreferenceIte...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function bulkUpdateSubscriberPreferenceItemDtoToJSON
- export function bulkUpdateSubscriberPreferenceItemDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/bulkupdatesubscriberpreferencesdto.ts
Tamaño: 2753 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  BulkUpdateSubscriberPreferenceItemDto,
  BulkUpdateSubscriberPreferenceItemDto$inboundSchema,
  BulkUpdateSubscriberPreferenceItemDto$Outbound,
  BulkUpdateSubscriberPreferenceItemDto$outboundSchema,
} from './bulkupdatesubscriberpreferenceitemdto.js';

export type BulkUpdateSubscriberPreferencesDto = {
  /**
   * Array of workflow preferences to update (maximum 100 items)
   */
  preferences: Array<BulkUpdateSubscriberPreferenceItemDto>;
};

/** @internal */
export const BulkUpdateSubscriberPreferencesDto$inboundSchema: z.ZodType<
  BulkUpdateSubscriberPreferencesDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  preferences: z.array(BulkUpdateSubscriberPreferenceItemDto$inboundSchema),
});

/** @internal */
export type BulkUpdateSubscriberPreferencesDto$Outbound = {
  preferences: Array<BulkUpdateSubscriberPreferenceItemDto$Outbound>;
};

/** @internal */
export const BulkUpdateSubscriberPreferencesDto$outboundSchema: z.ZodType<
  BulkUpdateSubscriberPreferencesDto$Outbound,
  z.ZodTypeDef,
  BulkUpdateSubscriberPreferencesDto
> = z.object({
  preferences: z.array(BulkUpdateSubscriberPreferenceItemDto$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BulkUpdateSubscriberPreferencesDto$ {
  /** @deprecated use `BulkUpdateSubscriberPreferencesDto$inboundSchema` instead. */
  export const inboundSchema = BulkUpdateSubscriberPreferencesDto$inboundSchema;
  /** @deprecated use `BulkUpdateSubscriberPreferencesDto$outboundSchema` instead. */
  export const outboundSchema = BulkUpdateSubscriberPreferencesDto$outboundSchema;
  /** @deprecated use `BulkUpdateSubscriberPreferencesDto$Outbound` instead. */
  export type Outbound = BulkUpdateSubscriberPreferencesDto$Outbound;
}

export function bulkUpdateSubscriberPreferencesDtoToJSON(
  bulkUpdateSubscriberPreferencesDto: BulkUpdateSubscriberPreferencesDto
): string {
  return JSON.stringify(BulkUpdateSubscriberPreferencesDto$outboundSchema.parse(bulkUpdateSubscriberPreferencesDto));
}

export function bulkUpdateSubscriberPreferencesDtoFromJSON(
  jsonString: string
): SafeParseResult<BulkUpdateSubscriberPreferencesDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BulkUpdateSubscriberPreferencesDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BulkUpdateSubscriberPreferencesDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - bulkUpdateSubscriberPreferencesDtoToJSON(bulkUpdateSubscriberPreferencesDto: BulkUpdateSubscriberPreferencesDto)
 - bulkUpdateSubscriberPreferencesDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(BulkUpdateSubscriberPreferencesDto$Outbound;
}

export function bulkUpdateSubscriberPreferencesDtoTo...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function bulkUpdateSubscriberPreferencesDtoToJSON
- export function bulkUpdateSubscriberPreferencesDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/buttontypeenum.ts
Tamaño: 1122 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Type of button for the action result
 */
export const ButtonTypeEnum = {
  Primary: 'primary',
  Secondary: 'secondary',
} as const;
/**
 * Type of button for the action result
 */
export type ButtonTypeEnum = ClosedEnum<typeof ButtonTypeEnum>;

/** @internal */
export const ButtonTypeEnum$inboundSchema: z.ZodNativeEnum<typeof ButtonTypeEnum> = z.nativeEnum(ButtonTypeEnum);

/** @internal */
export const ButtonTypeEnum$outboundSchema: z.ZodNativeEnum<typeof ButtonTypeEnum> = ButtonTypeEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ButtonTypeEnum$ {
  /** @deprecated use `ButtonTypeEnum$inboundSchema` instead. */
  export const inboundSchema = ButtonTypeEnum$inboundSchema;
  /** @deprecated use `ButtonTypeEnum$outboundSchema` instead. */
  export const outboundSchema = ButtonTypeEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/channelcredentials.ts
Tamaño: 3517 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type ChannelCredentials = {
  /**
   * Webhook URL used by chat app integrations. The webhook should be obtained from the chat app provider.
   */
  webhookUrl?: string | undefined;
  /**
   * Channel specification for Mattermost chat notifications.
   */
  channel?: string | undefined;
  /**
   * Contains an array of the subscriber device tokens for a given provider. Used on Push integrations.
   */
  deviceTokens?: Array<string> | undefined;
  /**
   * Alert UID for Grafana on-call webhook payload.
   */
  alertUid?: string | undefined;
  /**
   * Title to be used with Grafana on-call webhook.
   */
  title?: string | undefined;
  /**
   * Image URL property for Grafana on-call webhook.
   */
  imageUrl?: string | undefined;
  /**
   * State property for Grafana on-call webhook.
   */
  state?: string | undefined;
  /**
   * Link to upstream details property for Grafana on-call webhook.
   */
  externalUrl?: string | undefined;
};

/** @internal */
export const ChannelCredentials$inboundSchema: z.ZodType<ChannelCredentials, z.ZodTypeDef, unknown> = z.object({
  webhookUrl: z.string().optional(),
  channel: z.string().optional(),
  deviceTokens: z.array(z.string()).optional(),
  alertUid: z.string().optional(),
  title: z.string().optional(),
  imageUrl: z.string().optional(),
  state: z.string().optional(),
  externalUrl: z.string().optional(),
});

/** @internal */
export type ChannelCredentials$Outbound = {
  webhookUrl?: string | undefined;
  channel?: string | undefined;
  deviceTokens?: Array<string> | undefined;
  alertUid?: string | undefined;
  title?: string | undefined;
  imageUrl?: string | undefined;
  state?: string | undefined;
  externalUrl?: string | undefined;
};

/** @internal */
export const ChannelCredentials$outboundSchema: z.ZodType<
  ChannelCredentials$Outbound,
  z.ZodTypeDef,
  ChannelCredentials
> = z.object({
  webhookUrl: z.string().optional(),
  channel: z.string().optional(),
  deviceTokens: z.array(z.string()).optional(),
  alertUid: z.string().optional(),
  title: z.string().optional(),
  imageUrl: z.string().optional(),
  state: z.string().optional(),
  externalUrl: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChannelCredentials$ {
  /** @deprecated use `ChannelCredentials$inboundSchema` instead. */
  export const inboundSchema = ChannelCredentials$inboundSchema;
  /** @deprecated use `ChannelCredentials$outboundSchema` instead. */
  export const outboundSchema = ChannelCredentials$outboundSchema;
  /** @deprecated use `ChannelCredentials$Outbound` instead. */
  export type Outbound = ChannelCredentials$Outbound;
}

export function channelCredentialsToJSON(channelCredentials: ChannelCredentials): string {
  return JSON.stringify(ChannelCredentials$outboundSchema.parse(channelCredentials));
}

export function channelCredentialsFromJSON(
  jsonString: string
): SafeParseResult<ChannelCredentials, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ChannelCredentials$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChannelCredentials' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - channelCredentialsToJSON(channelCredentials: ChannelCredentials)
 - channelCredentialsFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ChannelCredentials$Outbound;
}

export function channelCredentialsToJSON(channelCredentials: Channel...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function channelCredentialsToJSON
- export function channelCredentialsFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/channelcredentialsdto.ts
Tamaño: 2280 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type ChannelCredentialsDto = {
  /**
   * The URL for the webhook associated with the channel.
   */
  webhookUrl?: string | undefined;
  /**
   * An array of device tokens for push notifications.
   */
  deviceTokens?: Array<string> | undefined;
};

/** @internal */
export const ChannelCredentialsDto$inboundSchema: z.ZodType<ChannelCredentialsDto, z.ZodTypeDef, unknown> = z.object({
  webhookUrl: z.string().optional(),
  deviceTokens: z.array(z.string()).optional(),
});

/** @internal */
export type ChannelCredentialsDto$Outbound = {
  webhookUrl?: string | undefined;
  deviceTokens?: Array<string> | undefined;
};

/** @internal */
export const ChannelCredentialsDto$outboundSchema: z.ZodType<
  ChannelCredentialsDto$Outbound,
  z.ZodTypeDef,
  ChannelCredentialsDto
> = z.object({
  webhookUrl: z.string().optional(),
  deviceTokens: z.array(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChannelCredentialsDto$ {
  /** @deprecated use `ChannelCredentialsDto$inboundSchema` instead. */
  export const inboundSchema = ChannelCredentialsDto$inboundSchema;
  /** @deprecated use `ChannelCredentialsDto$outboundSchema` instead. */
  export const outboundSchema = ChannelCredentialsDto$outboundSchema;
  /** @deprecated use `ChannelCredentialsDto$Outbound` instead. */
  export type Outbound = ChannelCredentialsDto$Outbound;
}

export function channelCredentialsDtoToJSON(channelCredentialsDto: ChannelCredentialsDto): string {
  return JSON.stringify(ChannelCredentialsDto$outboundSchema.parse(channelCredentialsDto));
}

export function channelCredentialsDtoFromJSON(
  jsonString: string
): SafeParseResult<ChannelCredentialsDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ChannelCredentialsDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChannelCredentialsDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - channelCredentialsDtoToJSON(channelCredentialsDto: ChannelCredentialsDto)
 - channelCredentialsDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ChannelCredentialsDto$Outbound;
}

export function channelCredentialsDtoToJSON(channelCredentialsDto...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function channelCredentialsDtoToJSON
- export function channelCredentialsDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/channelctatypeenum.ts
Tamaño: 1130 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Type of call to action
 */
export const ChannelCTATypeEnum = {
  Redirect: 'redirect',
} as const;
/**
 * Type of call to action
 */
export type ChannelCTATypeEnum = ClosedEnum<typeof ChannelCTATypeEnum>;

/** @internal */
export const ChannelCTATypeEnum$inboundSchema: z.ZodNativeEnum<typeof ChannelCTATypeEnum> =
  z.nativeEnum(ChannelCTATypeEnum);

/** @internal */
export const ChannelCTATypeEnum$outboundSchema: z.ZodNativeEnum<typeof ChannelCTATypeEnum> =
  ChannelCTATypeEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChannelCTATypeEnum$ {
  /** @deprecated use `ChannelCTATypeEnum$inboundSchema` instead. */
  export const inboundSchema = ChannelCTATypeEnum$inboundSchema;
  /** @deprecated use `ChannelCTATypeEnum$outboundSchema` instead. */
  export const outboundSchema = ChannelCTATypeEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/channelpreferencedto.ts
Tamaño: 2052 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type ChannelPreferenceDto = {
  /**
   * A flag specifying if notification delivery is enabled for the channel. If true, notification delivery is enabled.
   */
  enabled?: boolean | undefined;
};

/** @internal */
export const ChannelPreferenceDto$inboundSchema: z.ZodType<ChannelPreferenceDto, z.ZodTypeDef, unknown> = z.object({
  enabled: z.boolean().default(true),
});

/** @internal */
export type ChannelPreferenceDto$Outbound = {
  enabled: boolean;
};

/** @internal */
export const ChannelPreferenceDto$outboundSchema: z.ZodType<
  ChannelPreferenceDto$Outbound,
  z.ZodTypeDef,
  ChannelPreferenceDto
> = z.object({
  enabled: z.boolean().default(true),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChannelPreferenceDto$ {
  /** @deprecated use `ChannelPreferenceDto$inboundSchema` instead. */
  export const inboundSchema = ChannelPreferenceDto$inboundSchema;
  /** @deprecated use `ChannelPreferenceDto$outboundSchema` instead. */
  export const outboundSchema = ChannelPreferenceDto$outboundSchema;
  /** @deprecated use `ChannelPreferenceDto$Outbound` instead. */
  export type Outbound = ChannelPreferenceDto$Outbound;
}

export function channelPreferenceDtoToJSON(channelPreferenceDto: ChannelPreferenceDto): string {
  return JSON.stringify(ChannelPreferenceDto$outboundSchema.parse(channelPreferenceDto));
}

export function channelPreferenceDtoFromJSON(
  jsonString: string
): SafeParseResult<ChannelPreferenceDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ChannelPreferenceDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChannelPreferenceDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - channelPreferenceDtoToJSON(channelPreferenceDto: ChannelPreferenceDto)
 - channelPreferenceDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ChannelPreferenceDto$Outbound;
}

export function channelPreferenceDtoToJSON(channelPreferenceDto: C...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function channelPreferenceDtoToJSON
- export function channelPreferenceDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/channelsettingsdto.ts
Tamaño: 3246 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ChannelCredentials,
  ChannelCredentials$inboundSchema,
  ChannelCredentials$Outbound,
  ChannelCredentials$outboundSchema,
} from './channelcredentials.js';
import {
  ChatOrPushProviderEnum,
  ChatOrPushProviderEnum$inboundSchema,
  ChatOrPushProviderEnum$outboundSchema,
} from './chatorpushproviderenum.js';

export type ChannelSettingsDto = {
  /**
   * The provider identifier for the credentials
   */
  providerId: ChatOrPushProviderEnum;
  /**
   * The integration identifier
   */
  integrationIdentifier?: string | undefined;
  /**
   * Credentials payload for the specified provider
   */
  credentials: ChannelCredentials;
  /**
   * The unique identifier of the integration associated with this channel.
   */
  integrationId: string;
};

/** @internal */
export const ChannelSettingsDto$inboundSchema: z.ZodType<ChannelSettingsDto, z.ZodTypeDef, unknown> = z
  .object({
    providerId: ChatOrPushProviderEnum$inboundSchema,
    integrationIdentifier: z.string().optional(),
    credentials: ChannelCredentials$inboundSchema,
    _integrationId: z.string(),
  })
  .transform((v) => {
    return remap$(v, {
      _integrationId: 'integrationId',
    });
  });

/** @internal */
export type ChannelSettingsDto$Outbound = {
  providerId: string;
  integrationIdentifier?: string | undefined;
  credentials: ChannelCredentials$Outbound;
  _integrationId: string;
};

/** @internal */
export const ChannelSettingsDto$outboundSchema: z.ZodType<
  ChannelSettingsDto$Outbound,
  z.ZodTypeDef,
  ChannelSettingsDto
> = z
  .object({
    providerId: ChatOrPushProviderEnum$outboundSchema,
    integrationIdentifier: z.string().optional(),
    credentials: ChannelCredentials$outboundSchema,
    integrationId: z.string(),
  })
  .transform((v) => {
    return remap$(v, {
      integrationId: '_integrationId',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChannelSettingsDto$ {
  /** @deprecated use `ChannelSettingsDto$inboundSchema` instead. */
  export const inboundSchema = ChannelSettingsDto$inboundSchema;
  /** @deprecated use `ChannelSettingsDto$outboundSchema` instead. */
  export const outboundSchema = ChannelSettingsDto$outboundSchema;
  /** @deprecated use `ChannelSettingsDto$Outbound` instead. */
  export type Outbound = ChannelSettingsDto$Outbound;
}

export function channelSettingsDtoToJSON(channelSettingsDto: ChannelSettingsDto): string {
  return JSON.stringify(ChannelSettingsDto$outboundSchema.parse(channelSettingsDto));
}

export function channelSettingsDtoFromJSON(
  jsonString: string
): SafeParseResult<ChannelSettingsDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ChannelSettingsDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChannelSettingsDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - channelSettingsDtoToJSON(channelSettingsDto: ChannelSettingsDto)
 - channelSettingsDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ChannelSettingsDto$Outbound;
}

export function channelSettingsDtoToJSON(channelSettingsDto: Channel...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function channelSettingsDtoToJSON
- export function channelSettingsDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/channeltypeenum.ts
Tamaño: 1191 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Channel type through which the message is sent
 */
export const ChannelTypeEnum = {
  InApp: 'in_app',
  Email: 'email',
  Sms: 'sms',
  Chat: 'chat',
  Push: 'push',
} as const;
/**
 * Channel type through which the message is sent
 */
export type ChannelTypeEnum = ClosedEnum<typeof ChannelTypeEnum>;

/** @internal */
export const ChannelTypeEnum$inboundSchema: z.ZodNativeEnum<typeof ChannelTypeEnum> = z.nativeEnum(ChannelTypeEnum);

/** @internal */
export const ChannelTypeEnum$outboundSchema: z.ZodNativeEnum<typeof ChannelTypeEnum> = ChannelTypeEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChannelTypeEnum$ {
  /** @deprecated use `ChannelTypeEnum$inboundSchema` instead. */
  export const inboundSchema = ChannelTypeEnum$inboundSchema;
  /** @deprecated use `ChannelTypeEnum$outboundSchema` instead. */
  export const outboundSchema = ChannelTypeEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/chatcontroldto.ts
Tamaño: 2202 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type ChatControlDto = {
  /**
   * JSONLogic filter conditions for conditionally skipping the step execution. Supports complex logical operations with AND, OR, and comparison operators. See https://jsonlogic.com/ for full typing reference.
   */
  skip?: { [k: string]: any } | undefined;
  /**
   * Content of the chat message.
   */
  body?: string | undefined;
};

/** @internal */
export const ChatControlDto$inboundSchema: z.ZodType<ChatControlDto, z.ZodTypeDef, unknown> = z.object({
  skip: z.record(z.any()).optional(),
  body: z.string().optional(),
});

/** @internal */
export type ChatControlDto$Outbound = {
  skip?: { [k: string]: any } | undefined;
  body?: string | undefined;
};

/** @internal */
export const ChatControlDto$outboundSchema: z.ZodType<ChatControlDto$Outbound, z.ZodTypeDef, ChatControlDto> = z.object(
  {
    skip: z.record(z.any()).optional(),
    body: z.string().optional(),
  }
);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChatControlDto$ {
  /** @deprecated use `ChatControlDto$inboundSchema` instead. */
  export const inboundSchema = ChatControlDto$inboundSchema;
  /** @deprecated use `ChatControlDto$outboundSchema` instead. */
  export const outboundSchema = ChatControlDto$outboundSchema;
  /** @deprecated use `ChatControlDto$Outbound` instead. */
  export type Outbound = ChatControlDto$Outbound;
}

export function chatControlDtoToJSON(chatControlDto: ChatControlDto): string {
  return JSON.stringify(ChatControlDto$outboundSchema.parse(chatControlDto));
}

export function chatControlDtoFromJSON(jsonString: string): SafeParseResult<ChatControlDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ChatControlDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChatControlDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - chatControlDtoToJSON(chatControlDto: ChatControlDto)
 - chatControlDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ChatControlDto$Outbound;
}

export function chatControlDtoToJSON(chatControlDto: ChatControlDto): st...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function chatControlDtoToJSON
- export function chatControlDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/chatcontrolsmetadataresponsedto.ts
Tamaño: 2946 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ChatControlDto,
  ChatControlDto$inboundSchema,
  ChatControlDto$Outbound,
  ChatControlDto$outboundSchema,
} from './chatcontroldto.js';
import { UiSchema, UiSchema$inboundSchema, UiSchema$Outbound, UiSchema$outboundSchema } from './uischema.js';

export type ChatControlsMetadataResponseDto = {
  /**
   * JSON Schema for data
   */
  dataSchema?: { [k: string]: any } | undefined;
  /**
   * UI Schema for rendering
   */
  uiSchema?: UiSchema | undefined;
  /**
   * Control values specific to Chat
   */
  values: ChatControlDto;
};

/** @internal */
export const ChatControlsMetadataResponseDto$inboundSchema: z.ZodType<
  ChatControlsMetadataResponseDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  dataSchema: z.record(z.any()).optional(),
  uiSchema: UiSchema$inboundSchema.optional(),
  values: ChatControlDto$inboundSchema,
});

/** @internal */
export type ChatControlsMetadataResponseDto$Outbound = {
  dataSchema?: { [k: string]: any } | undefined;
  uiSchema?: UiSchema$Outbound | undefined;
  values: ChatControlDto$Outbound;
};

/** @internal */
export const ChatControlsMetadataResponseDto$outboundSchema: z.ZodType<
  ChatControlsMetadataResponseDto$Outbound,
  z.ZodTypeDef,
  ChatControlsMetadataResponseDto
> = z.object({
  dataSchema: z.record(z.any()).optional(),
  uiSchema: UiSchema$outboundSchema.optional(),
  values: ChatControlDto$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChatControlsMetadataResponseDto$ {
  /** @deprecated use `ChatControlsMetadataResponseDto$inboundSchema` instead. */
  export const inboundSchema = ChatControlsMetadataResponseDto$inboundSchema;
  /** @deprecated use `ChatControlsMetadataResponseDto$outboundSchema` instead. */
  export const outboundSchema = ChatControlsMetadataResponseDto$outboundSchema;
  /** @deprecated use `ChatControlsMetadataResponseDto$Outbound` instead. */
  export type Outbound = ChatControlsMetadataResponseDto$Outbound;
}

export function chatControlsMetadataResponseDtoToJSON(
  chatControlsMetadataResponseDto: ChatControlsMetadataResponseDto
): string {
  return JSON.stringify(ChatControlsMetadataResponseDto$outboundSchema.parse(chatControlsMetadataResponseDto));
}

export function chatControlsMetadataResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<ChatControlsMetadataResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ChatControlsMetadataResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChatControlsMetadataResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - chatControlsMetadataResponseDtoToJSON(chatControlsMetadataResponseDto: ChatControlsMetadataResponseDto)
 - chatControlsMetadataResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ChatControlsMetadataResponseDto$Outbound;
}

export function chatControlsMetadataResponseDtoToJSON(
...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function chatControlsMetadataResponseDtoToJSON
- export function chatControlsMetadataResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/chatorpushproviderenum.ts
Tamaño: 1677 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * The provider identifier for the credentials
 */
export const ChatOrPushProviderEnum = {
  Slack: 'slack',
  Discord: 'discord',
  Msteams: 'msteams',
  Mattermost: 'mattermost',
  Ryver: 'ryver',
  Zulip: 'zulip',
  GrafanaOnCall: 'grafana-on-call',
  Getstream: 'getstream',
  RocketChat: 'rocket-chat',
  WhatsappBusiness: 'whatsapp-business',
  ChatWebhook: 'chat-webhook',
  NovuSlack: 'novu-slack',
  Fcm: 'fcm',
  Apns: 'apns',
  Expo: 'expo',
  OneSignal: 'one-signal',
  Pushpad: 'pushpad',
  PushWebhook: 'push-webhook',
  PusherBeams: 'pusher-beams',
} as const;
/**
 * The provider identifier for the credentials
 */
export type ChatOrPushProviderEnum = ClosedEnum<typeof ChatOrPushProviderEnum>;

/** @internal */
export const ChatOrPushProviderEnum$inboundSchema: z.ZodNativeEnum<typeof ChatOrPushProviderEnum> =
  z.nativeEnum(ChatOrPushProviderEnum);

/** @internal */
export const ChatOrPushProviderEnum$outboundSchema: z.ZodNativeEnum<typeof ChatOrPushProviderEnum> =
  ChatOrPushProviderEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChatOrPushProviderEnum$ {
  /** @deprecated use `ChatOrPushProviderEnum$inboundSchema` instead. */
  export const inboundSchema = ChatOrPushProviderEnum$inboundSchema;
  /** @deprecated use `ChatOrPushProviderEnum$outboundSchema` instead. */
  export const outboundSchema = ChatOrPushProviderEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/chatrenderoutput.ts
Tamaño: 1808 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type ChatRenderOutput = {
  /**
   * Body of the chat message
   */
  body: string;
};

/** @internal */
export const ChatRenderOutput$inboundSchema: z.ZodType<ChatRenderOutput, z.ZodTypeDef, unknown> = z.object({
  body: z.string(),
});

/** @internal */
export type ChatRenderOutput$Outbound = {
  body: string;
};

/** @internal */
export const ChatRenderOutput$outboundSchema: z.ZodType<ChatRenderOutput$Outbound, z.ZodTypeDef, ChatRenderOutput> =
  z.object({
    body: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChatRenderOutput$ {
  /** @deprecated use `ChatRenderOutput$inboundSchema` instead. */
  export const inboundSchema = ChatRenderOutput$inboundSchema;
  /** @deprecated use `ChatRenderOutput$outboundSchema` instead. */
  export const outboundSchema = ChatRenderOutput$outboundSchema;
  /** @deprecated use `ChatRenderOutput$Outbound` instead. */
  export type Outbound = ChatRenderOutput$Outbound;
}

export function chatRenderOutputToJSON(chatRenderOutput: ChatRenderOutput): string {
  return JSON.stringify(ChatRenderOutput$outboundSchema.parse(chatRenderOutput));
}

export function chatRenderOutputFromJSON(jsonString: string): SafeParseResult<ChatRenderOutput, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ChatRenderOutput$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChatRenderOutput' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - chatRenderOutputToJSON(chatRenderOutput: ChatRenderOutput)
 - chatRenderOutputFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ChatRenderOutput$Outbound;
}

export function chatRenderOutputToJSON(chatRenderOutput: ChatRenderOut...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function chatRenderOutputToJSON
- export function chatRenderOutputFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/chatstepresponsedto.ts
Tamaño: 7660 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { collectExtraKeys as collectExtraKeys$, safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ChatControlsMetadataResponseDto,
  ChatControlsMetadataResponseDto$inboundSchema,
  ChatControlsMetadataResponseDto$Outbound,
  ChatControlsMetadataResponseDto$outboundSchema,
} from './chatcontrolsmetadataresponsedto.js';
import {
  ResourceOriginEnum,
  ResourceOriginEnum$inboundSchema,
  ResourceOriginEnum$outboundSchema,
} from './resourceoriginenum.js';
import {
  StepIssuesDto,
  StepIssuesDto$inboundSchema,
  StepIssuesDto$Outbound,
  StepIssuesDto$outboundSchema,
} from './stepissuesdto.js';
import { StepTypeEnum, StepTypeEnum$inboundSchema, StepTypeEnum$outboundSchema } from './steptypeenum.js';

/**
 * Control values for the chat step
 */
export type ChatStepResponseDtoControlValues = {
  /**
   * JSONLogic filter conditions for conditionally skipping the step execution. Supports complex logical operations with AND, OR, and comparison operators. See https://jsonlogic.com/ for full typing reference.
   */
  skip?: { [k: string]: any } | undefined;
  /**
   * Content of the chat message.
   */
  body?: string | undefined;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type ChatStepResponseDto = {
  /**
   * Controls metadata for the chat step
   */
  controls: ChatControlsMetadataResponseDto;
  /**
   * Control values for the chat step
   */
  controlValues?: ChatStepResponseDtoControlValues | undefined;
  /**
   * JSON Schema for variables, follows the JSON Schema standard
   */
  variables: { [k: string]: any };
  /**
   * Unique identifier of the step
   */
  stepId: string;
  /**
   * Database identifier of the step
   */
  id: string;
  /**
   * Name of the step
   */
  name: string;
  /**
   * Slug of the step
   */
  slug: string;
  /**
   * Type of the step
   */
  type: StepTypeEnum;
  /**
   * Origin of the layout
   */
  origin: ResourceOriginEnum;
  /**
   * Workflow identifier
   */
  workflowId: string;
  /**
   * Workflow database identifier
   */
  workflowDatabaseId: string;
  /**
   * Issues associated with the step
   */
  issues?: StepIssuesDto | undefined;
};

/** @internal */
export const ChatStepResponseDtoControlValues$inboundSchema: z.ZodType<
  ChatStepResponseDtoControlValues,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z
    .object({
      skip: z.record(z.any()).optional(),
      body: z.string().optional(),
    })
    .catchall(z.any()),
  'additionalProperties',
  true
);

/** @internal */
export type ChatStepResponseDtoControlValues$Outbound = {
  skip?: { [k: string]: any } | undefined;
  body?: string | undefined;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const ChatStepResponseDtoControlValues$outboundSchema: z.ZodType<
  ChatStepResponseDtoControlValues$Outbound,
  z.ZodTypeDef,
  ChatStepResponseDtoControlValues
> = z
  .object({
    skip: z.record(z.any()).optional(),
    body: z.string().optional(),
    additionalProperties: z.record(z.any()).optional(),
  })
  .transform((v) => {
    return {
      ...v.additionalProperties,
      ...remap$(v, {
        additionalProperties: null,
      }),
    };
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChatStepResponseDtoControlValues$ {
  /** @deprecated use `ChatStepResponseDtoControlValues$inboundSchema` instead. */
  export const inboundSchema = ChatStepResponseDtoControlValues$inboundSchema;
  /** @deprecated use `ChatStepResponseDtoControlValues$outboundSchema` instead. */
  export const outboundSchema = ChatStepResponseDtoControlValues$outboundSchema;
  /** @deprecated use `ChatStepResponseDtoControlValues$Outbound` instead. */
  export type Outbound = ChatStepResponseDtoControlValues$Outbound;
}

export function chatStepResponseDtoControlValuesToJSON(
  chatStepResponseDtoControlValues: ChatStepResponseDtoControlValues
): string {
  return JSON.stringify(ChatStepResponseDtoControlValues$outboundSchema.parse(chatStepResponseDtoControlValues));
}

export function chatStepResponseDtoControlValuesFromJSON(
  jsonString: string
): SafeParseResult<ChatStepResponseDtoControlValues, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ChatStepResponseDtoControlValues$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChatStepResponseDtoControlValues' from JSON`
  );
}

/** @internal */
export const ChatStepResponseDto$inboundSchema: z.ZodType<ChatStepResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    controls: ChatControlsMetadataResponseDto$inboundSchema,
    controlValues: z.lazy(() => ChatStepResponseDtoControlValues$inboundSchema).optional(),
    variables: z.record(z.any()),
    stepId: z.string(),
    _id: z.string(),
    name: z.string(),
    slug: z.string(),
    type: StepTypeEnum$inboundSchema,
    origin: ResourceOriginEnum$inboundSchema,
    workflowId: z.string(),
    workflowDatabaseId: z.string(),
    issues: StepIssuesDto$inboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type ChatStepResponseDto$Outbound = {
  controls: ChatControlsMetadataResponseDto$Outbound;
  controlValues?: ChatStepResponseDtoControlValues$Outbound | undefined;
  variables: { [k: string]: any };
  stepId: string;
  _id: string;
  name: string;
  slug: string;
  type: string;
  origin: string;
  workflowId: string;
  workflowDatabaseId: string;
  issues?: StepIssuesDto$Outbound | undefined;
};

/** @internal */
export const ChatStepResponseDto$outboundSchema: z.ZodType<
  ChatStepResponseDto$Outbound,
  z.ZodTypeDef,
  ChatStepResponseDto
> = z
  .object({
    controls: ChatControlsMetadataResponseDto$outboundSchema,
    controlValues: z.lazy(() => ChatStepResponseDtoControlValues$outboundSchema).optional(),
    variables: z.record(z.any()),
    stepId: z.string(),
    id: z.string(),
    name: z.string(),
    slug: z.string(),
    type: StepTypeEnum$outboundSchema,
    origin: ResourceOriginEnum$outboundSchema,
    workflowId: z.string(),
    workflowDatabaseId: z.string(),
    issues: StepIssuesDto$outboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChatStepResponseDto$ {
  /** @deprecated use `ChatStepResponseDto$inboundSchema` instead. */
  export const inboundSchema = ChatStepResponseDto$inboundSchema;
  /** @deprecated use `ChatStepResponseDto$outboundSchema` instead. */
  export const outboundSchema = ChatStepResponseDto$outboundSchema;
  /** @deprecated use `ChatStepResponseDto$Outbound` instead. */
  export type Outbound = ChatStepResponseDto$Outbound;
}

export function chatStepResponseDtoToJSON(chatStepResponseDto: ChatStepResponseDto): string {
  return JSON.stringify(ChatStepResponseDto$outboundSchema.parse(chatStepResponseDto));
}

export function chatStepResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<ChatStepResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ChatStepResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChatStepResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - chatStepResponseDtoControlValuesToJSON(chatStepResponseDtoControlValues: ChatStepResponseDtoControlValues)
 - chatStepResponseDtoControlValuesFromJSON(jsonString: string)
 - chatStepResponseDtoToJSON(chatStepResponseDto: ChatStepResponseDto)
 - chatStepResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ChatStepResponseDtoControlValues$Outbound;
}

export function chatStepResponseDtoControlValuesToJSON...)
 - Outbound(ChatStepResponseDto$Outbound;
}

export function chatStepResponseDtoToJSON(chatStepResponseDto: Chat...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function chatStepResponseDtoControlValuesToJSON
- export function chatStepResponseDtoControlValuesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function chatStepResponseDtoToJSON
- export function chatStepResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/chatstepupsertdto.ts
Tamaño: 5201 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ChatControlDto,
  ChatControlDto$inboundSchema,
  ChatControlDto$Outbound,
  ChatControlDto$outboundSchema,
} from './chatcontroldto.js';
import { StepTypeEnum, StepTypeEnum$inboundSchema, StepTypeEnum$outboundSchema } from './steptypeenum.js';

/**
 * Control values for the Chat step.
 */
export type ChatStepUpsertDtoControlValues =
  | ChatControlDto
  | {
      [k: string]: any;
    };

export type ChatStepUpsertDto = {
  /**
   * Database identifier of the step. Used for updating the step.
   */
  id?: string | undefined;
  /**
   * Unique identifier for the step
   */
  stepId?: string | undefined;
  /**
   * Name of the step
   */
  name: string;
  /**
   * Type of the step
   */
  type: StepTypeEnum;
  /**
   * Control values for the Chat step.
   */
  controlValues?: ChatControlDto | { [k: string]: any } | undefined;
};

/** @internal */
export const ChatStepUpsertDtoControlValues$inboundSchema: z.ZodType<
  ChatStepUpsertDtoControlValues,
  z.ZodTypeDef,
  unknown
> = z.union([ChatControlDto$inboundSchema, z.record(z.any())]);

/** @internal */
export type ChatStepUpsertDtoControlValues$Outbound = ChatControlDto$Outbound | { [k: string]: any };

/** @internal */
export const ChatStepUpsertDtoControlValues$outboundSchema: z.ZodType<
  ChatStepUpsertDtoControlValues$Outbound,
  z.ZodTypeDef,
  ChatStepUpsertDtoControlValues
> = z.union([ChatControlDto$outboundSchema, z.record(z.any())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChatStepUpsertDtoControlValues$ {
  /** @deprecated use `ChatStepUpsertDtoControlValues$inboundSchema` instead. */
  export const inboundSchema = ChatStepUpsertDtoControlValues$inboundSchema;
  /** @deprecated use `ChatStepUpsertDtoControlValues$outboundSchema` instead. */
  export const outboundSchema = ChatStepUpsertDtoControlValues$outboundSchema;
  /** @deprecated use `ChatStepUpsertDtoControlValues$Outbound` instead. */
  export type Outbound = ChatStepUpsertDtoControlValues$Outbound;
}

export function chatStepUpsertDtoControlValuesToJSON(
  chatStepUpsertDtoControlValues: ChatStepUpsertDtoControlValues
): string {
  return JSON.stringify(ChatStepUpsertDtoControlValues$outboundSchema.parse(chatStepUpsertDtoControlValues));
}

export function chatStepUpsertDtoControlValuesFromJSON(
  jsonString: string
): SafeParseResult<ChatStepUpsertDtoControlValues, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ChatStepUpsertDtoControlValues$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChatStepUpsertDtoControlValues' from JSON`
  );
}

/** @internal */
export const ChatStepUpsertDto$inboundSchema: z.ZodType<ChatStepUpsertDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().optional(),
    stepId: z.string().optional(),
    name: z.string(),
    type: StepTypeEnum$inboundSchema,
    controlValues: z.union([ChatControlDto$inboundSchema, z.record(z.any())]).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type ChatStepUpsertDto$Outbound = {
  _id?: string | undefined;
  stepId?: string | undefined;
  name: string;
  type: string;
  controlValues?: ChatControlDto$Outbound | { [k: string]: any } | undefined;
};

/** @internal */
export const ChatStepUpsertDto$outboundSchema: z.ZodType<ChatStepUpsertDto$Outbound, z.ZodTypeDef, ChatStepUpsertDto> =
  z
    .object({
      id: z.string().optional(),
      stepId: z.string().optional(),
      name: z.string(),
      type: StepTypeEnum$outboundSchema,
      controlValues: z.union([ChatControlDto$outboundSchema, z.record(z.any())]).optional(),
    })
    .transform((v) => {
      return remap$(v, {
        id: '_id',
      });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChatStepUpsertDto$ {
  /** @deprecated use `ChatStepUpsertDto$inboundSchema` instead. */
  export const inboundSchema = ChatStepUpsertDto$inboundSchema;
  /** @deprecated use `ChatStepUpsertDto$outboundSchema` instead. */
  export const outboundSchema = ChatStepUpsertDto$outboundSchema;
  /** @deprecated use `ChatStepUpsertDto$Outbound` instead. */
  export type Outbound = ChatStepUpsertDto$Outbound;
}

export function chatStepUpsertDtoToJSON(chatStepUpsertDto: ChatStepUpsertDto): string {
  return JSON.stringify(ChatStepUpsertDto$outboundSchema.parse(chatStepUpsertDto));
}

export function chatStepUpsertDtoFromJSON(jsonString: string): SafeParseResult<ChatStepUpsertDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ChatStepUpsertDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChatStepUpsertDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - chatStepUpsertDtoControlValuesToJSON(chatStepUpsertDtoControlValues: ChatStepUpsertDtoControlValues)
 - chatStepUpsertDtoControlValuesFromJSON(jsonString: string)
 - chatStepUpsertDtoToJSON(chatStepUpsertDto: ChatStepUpsertDto)
 - chatStepUpsertDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ChatStepUpsertDtoControlValues$Outbound;
}

export function chatStepUpsertDtoControlValuesToJSON(
  ...)
 - Outbound(ChatStepUpsertDto$Outbound;
}

export function chatStepUpsertDtoToJSON(chatStepUpsertDto: ChatStepUp...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function chatStepUpsertDtoControlValuesToJSON
- export function chatStepUpsertDtoControlValuesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function chatStepUpsertDtoToJSON
- export function chatStepUpsertDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/configurationsdto.ts
Tamaño: 2111 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type ConfigurationsDto = {
  inboundWebhookEnabled?: boolean | undefined;
  inboundWebhookSigningKey?: string | undefined;
};

/** @internal */
export const ConfigurationsDto$inboundSchema: z.ZodType<ConfigurationsDto, z.ZodTypeDef, unknown> = z.object({
  inboundWebhookEnabled: z.boolean().optional(),
  inboundWebhookSigningKey: z.string().optional(),
});

/** @internal */
export type ConfigurationsDto$Outbound = {
  inboundWebhookEnabled?: boolean | undefined;
  inboundWebhookSigningKey?: string | undefined;
};

/** @internal */
export const ConfigurationsDto$outboundSchema: z.ZodType<ConfigurationsDto$Outbound, z.ZodTypeDef, ConfigurationsDto> =
  z.object({
    inboundWebhookEnabled: z.boolean().optional(),
    inboundWebhookSigningKey: z.string().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConfigurationsDto$ {
  /** @deprecated use `ConfigurationsDto$inboundSchema` instead. */
  export const inboundSchema = ConfigurationsDto$inboundSchema;
  /** @deprecated use `ConfigurationsDto$outboundSchema` instead. */
  export const outboundSchema = ConfigurationsDto$outboundSchema;
  /** @deprecated use `ConfigurationsDto$Outbound` instead. */
  export type Outbound = ConfigurationsDto$Outbound;
}

export function configurationsDtoToJSON(configurationsDto: ConfigurationsDto): string {
  return JSON.stringify(ConfigurationsDto$outboundSchema.parse(configurationsDto));
}

export function configurationsDtoFromJSON(jsonString: string): SafeParseResult<ConfigurationsDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConfigurationsDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConfigurationsDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - configurationsDtoToJSON(configurationsDto: ConfigurationsDto)
 - configurationsDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ConfigurationsDto$Outbound;
}

export function configurationsDtoToJSON(configurationsDto: Configurat...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function configurationsDtoToJSON
- export function configurationsDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/constraintvalidation.ts
Tamaño: 7023 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type Five = string | number | boolean | { [k: string]: any };

export type Four = {};

/**
 * Value that failed validation
 */
export type Value = string | number | boolean | Four | Array<string | number | boolean | { [k: string]: any } | null>;

export type ConstraintValidation = {
  /**
   * List of validation error messages
   */
  messages: Array<string>;
  /**
   * Value that failed validation
   */
  value?:
    | string
    | number
    | boolean
    | Four
    | Array<string | number | boolean | { [k: string]: any } | null>
    | null
    | undefined;
};

/** @internal */
export const Five$inboundSchema: z.ZodType<Five, z.ZodTypeDef, unknown> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.record(z.any()),
]);

/** @internal */
export type Five$Outbound = string | number | boolean | { [k: string]: any };

/** @internal */
export const Five$outboundSchema: z.ZodType<Five$Outbound, z.ZodTypeDef, Five> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.record(z.any()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Five$ {
  /** @deprecated use `Five$inboundSchema` instead. */
  export const inboundSchema = Five$inboundSchema;
  /** @deprecated use `Five$outboundSchema` instead. */
  export const outboundSchema = Five$outboundSchema;
  /** @deprecated use `Five$Outbound` instead. */
  export type Outbound = Five$Outbound;
}

export function fiveToJSON(five: Five): string {
  return JSON.stringify(Five$outboundSchema.parse(five));
}

export function fiveFromJSON(jsonString: string): SafeParseResult<Five, SDKValidationError> {
  return safeParse(jsonString, (x) => Five$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Five' from JSON`);
}

/** @internal */
export const Four$inboundSchema: z.ZodType<Four, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type Four$Outbound = {};

/** @internal */
export const Four$outboundSchema: z.ZodType<Four$Outbound, z.ZodTypeDef, Four> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Four$ {
  /** @deprecated use `Four$inboundSchema` instead. */
  export const inboundSchema = Four$inboundSchema;
  /** @deprecated use `Four$outboundSchema` instead. */
  export const outboundSchema = Four$outboundSchema;
  /** @deprecated use `Four$Outbound` instead. */
  export type Outbound = Four$Outbound;
}

export function fourToJSON(four: Four): string {
  return JSON.stringify(Four$outboundSchema.parse(four));
}

export function fourFromJSON(jsonString: string): SafeParseResult<Four, SDKValidationError> {
  return safeParse(jsonString, (x) => Four$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Four' from JSON`);
}

/** @internal */
export const Value$inboundSchema: z.ZodType<Value, z.ZodTypeDef, unknown> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.lazy(() => Four$inboundSchema),
  z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
]);

/** @internal */
export type Value$Outbound =
  | string
  | number
  | boolean
  | Four$Outbound
  | Array<string | number | boolean | { [k: string]: any } | null>;

/** @internal */
export const Value$outboundSchema: z.ZodType<Value$Outbound, z.ZodTypeDef, Value> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.lazy(() => Four$outboundSchema),
  z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Value$ {
  /** @deprecated use `Value$inboundSchema` instead. */
  export const inboundSchema = Value$inboundSchema;
  /** @deprecated use `Value$outboundSchema` instead. */
  export const outboundSchema = Value$outboundSchema;
  /** @deprecated use `Value$Outbound` instead. */
  export type Outbound = Value$Outbound;
}

export function valueToJSON(value: Value): string {
  return JSON.stringify(Value$outboundSchema.parse(value));
}

export function valueFromJSON(jsonString: string): SafeParseResult<Value, SDKValidationError> {
  return safeParse(jsonString, (x) => Value$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Value' from JSON`);
}

/** @internal */
export const ConstraintValidation$inboundSchema: z.ZodType<ConstraintValidation, z.ZodTypeDef, unknown> = z.object({
  messages: z.array(z.string()),
  value: z
    .nullable(
      z.union([
        z.string(),
        z.number(),
        z.boolean(),
        z.lazy(() => Four$inboundSchema),
        z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
      ])
    )
    .optional(),
});

/** @internal */
export type ConstraintValidation$Outbound = {
  messages: Array<string>;
  value?:
    | string
    | number
    | boolean
    | Four$Outbound
    | Array<string | number | boolean | { [k: string]: any } | null>
    | null
    | undefined;
};

/** @internal */
export const ConstraintValidation$outboundSchema: z.ZodType<
  ConstraintValidation$Outbound,
  z.ZodTypeDef,
  ConstraintValidation
> = z.object({
  messages: z.array(z.string()),
  value: z
    .nullable(
      z.union([
        z.string(),
        z.number(),
        z.boolean(),
        z.lazy(() => Four$outboundSchema),
        z.array(z.nullable(z.union([z.string(), z.number(), z.boolean(), z.record(z.any())]))),
      ])
    )
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConstraintValidation$ {
  /** @deprecated use `ConstraintValidation$inboundSchema` instead. */
  export const inboundSchema = ConstraintValidation$inboundSchema;
  /** @deprecated use `ConstraintValidation$outboundSchema` instead. */
  export const outboundSchema = ConstraintValidation$outboundSchema;
  /** @deprecated use `ConstraintValidation$Outbound` instead. */
  export type Outbound = ConstraintValidation$Outbound;
}

export function constraintValidationToJSON(constraintValidation: ConstraintValidation): string {
  return JSON.stringify(ConstraintValidation$outboundSchema.parse(constraintValidation));
}

export function constraintValidationFromJSON(
  jsonString: string
): SafeParseResult<ConstraintValidation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConstraintValidation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConstraintValidation' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - fiveToJSON(five: Five)
 - fiveFromJSON(jsonString: string)
 - fourToJSON(four: Four)
 - fourFromJSON(jsonString: string)
 - valueToJSON(value: Value)
 - valueFromJSON(jsonString: string)
 - constraintValidationToJSON(constraintValidation: ConstraintValidation)
 - constraintValidationFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Five$Outbound;
}

export function fiveToJSON(five: Five): string {
  return JSON.stringify(Five$outb...)
 - Outbound(Four$Outbound;
}

export function fourToJSON(four: Four): string {
  return JSON.stringify(Four$outb...)
 - Outbound(Value$Outbound;
}

export function valueToJSON(value: Value): string {
  return JSON.stringify(Value...)
 - Outbound(ConstraintValidation$Outbound;
}

export function constraintValidationToJSON(constraintValidation: C...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function fiveToJSON
- export function fiveFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function fourToJSON
- export function fourFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function valueToJSON
- export function valueFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function constraintValidationToJSON
- export function constraintValidationFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/contentissueenum.ts
Tamaño: 1293 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { ClosedEnum } from '../../types/enums.js';

/**
 * Type of step content issue
 */
export const ContentIssueEnum = {
  IllegalVariableInControlValue: 'ILLEGAL_VARIABLE_IN_CONTROL_VALUE',
  InvalidFilterArgInVariable: 'INVALID_FILTER_ARG_IN_VARIABLE',
  MissingValue: 'MISSING_VALUE',
  TierLimitExceeded: 'TIER_LIMIT_EXCEEDED',
} as const;
/**
 * Type of step content issue
 */
export type ContentIssueEnum = ClosedEnum<typeof ContentIssueEnum>;

/** @internal */
export const ContentIssueEnum$inboundSchema: z.ZodNativeEnum<typeof ContentIssueEnum> = z.nativeEnum(ContentIssueEnum);

/** @internal */
export const ContentIssueEnum$outboundSchema: z.ZodNativeEnum<typeof ContentIssueEnum> = ContentIssueEnum$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContentIssueEnum$ {
  /** @deprecated use `ContentIssueEnum$inboundSchema` instead. */
  export const inboundSchema = ContentIssueEnum$inboundSchema;
  /** @deprecated use `ContentIssueEnum$outboundSchema` instead. */
  export const outboundSchema = ContentIssueEnum$outboundSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/controlsmetadatadto.ts
Tamaño: 2318 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import { UiSchema, UiSchema$inboundSchema, UiSchema$Outbound, UiSchema$outboundSchema } from './uischema.js';

export type ControlsMetadataDto = {
  /**
   * JSON Schema for data
   */
  dataSchema?: { [k: string]: any } | undefined;
  /**
   * UI Schema for rendering
   */
  uiSchema?: UiSchema | undefined;
};

/** @internal */
export const ControlsMetadataDto$inboundSchema: z.ZodType<ControlsMetadataDto, z.ZodTypeDef, unknown> = z.object({
  dataSchema: z.record(z.any()).optional(),
  uiSchema: UiSchema$inboundSchema.optional(),
});

/** @internal */
export type ControlsMetadataDto$Outbound = {
  dataSchema?: { [k: string]: any } | undefined;
  uiSchema?: UiSchema$Outbound | undefined;
};

/** @internal */
export const ControlsMetadataDto$outboundSchema: z.ZodType<
  ControlsMetadataDto$Outbound,
  z.ZodTypeDef,
  ControlsMetadataDto
> = z.object({
  dataSchema: z.record(z.any()).optional(),
  uiSchema: UiSchema$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ControlsMetadataDto$ {
  /** @deprecated use `ControlsMetadataDto$inboundSchema` instead. */
  export const inboundSchema = ControlsMetadataDto$inboundSchema;
  /** @deprecated use `ControlsMetadataDto$outboundSchema` instead. */
  export const outboundSchema = ControlsMetadataDto$outboundSchema;
  /** @deprecated use `ControlsMetadataDto$Outbound` instead. */
  export type Outbound = ControlsMetadataDto$Outbound;
}

export function controlsMetadataDtoToJSON(controlsMetadataDto: ControlsMetadataDto): string {
  return JSON.stringify(ControlsMetadataDto$outboundSchema.parse(controlsMetadataDto));
}

export function controlsMetadataDtoFromJSON(
  jsonString: string
): SafeParseResult<ControlsMetadataDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ControlsMetadataDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ControlsMetadataDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - controlsMetadataDtoToJSON(controlsMetadataDto: ControlsMetadataDto)
 - controlsMetadataDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(ControlsMetadataDto$Outbound;
}

export function controlsMetadataDtoToJSON(controlsMetadataDto: Cont...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function controlsMetadataDtoToJSON
- export function controlsMetadataDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/createcontextrequestdto.ts
Tamaño: 3643 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Optional custom data to associate with this context.
 */
export type Data = {};

export type CreateContextRequestDto = {
  /**
   * Context type (e.g., tenant, app, workspace). Must be lowercase alphanumeric with optional separators.
   */
  type: string;
  /**
   * Unique identifier for this context. Must be lowercase alphanumeric with optional separators.
   */
  id: string;
  /**
   * Optional custom data to associate with this context.
   */
  data?: Data | undefined;
};

/** @internal */
export const Data$inboundSchema: z.ZodType<Data, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type Data$Outbound = {};

/** @internal */
export const Data$outboundSchema: z.ZodType<Data$Outbound, z.ZodTypeDef, Data> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Data$ {
  /** @deprecated use `Data$inboundSchema` instead. */
  export const inboundSchema = Data$inboundSchema;
  /** @deprecated use `Data$outboundSchema` instead. */
  export const outboundSchema = Data$outboundSchema;
  /** @deprecated use `Data$Outbound` instead. */
  export type Outbound = Data$Outbound;
}

export function dataToJSON(data: Data): string {
  return JSON.stringify(Data$outboundSchema.parse(data));
}

export function dataFromJSON(jsonString: string): SafeParseResult<Data, SDKValidationError> {
  return safeParse(jsonString, (x) => Data$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Data' from JSON`);
}

/** @internal */
export const CreateContextRequestDto$inboundSchema: z.ZodType<CreateContextRequestDto, z.ZodTypeDef, unknown> =
  z.object({
    type: z.string(),
    id: z.string(),
    data: z.lazy(() => Data$inboundSchema).optional(),
  });

/** @internal */
export type CreateContextRequestDto$Outbound = {
  type: string;
  id: string;
  data?: Data$Outbound | undefined;
};

/** @internal */
export const CreateContextRequestDto$outboundSchema: z.ZodType<
  CreateContextRequestDto$Outbound,
  z.ZodTypeDef,
  CreateContextRequestDto
> = z.object({
  type: z.string(),
  id: z.string(),
  data: z.lazy(() => Data$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateContextRequestDto$ {
  /** @deprecated use `CreateContextRequestDto$inboundSchema` instead. */
  export const inboundSchema = CreateContextRequestDto$inboundSchema;
  /** @deprecated use `CreateContextRequestDto$outboundSchema` instead. */
  export const outboundSchema = CreateContextRequestDto$outboundSchema;
  /** @deprecated use `CreateContextRequestDto$Outbound` instead. */
  export type Outbound = CreateContextRequestDto$Outbound;
}

export function createContextRequestDtoToJSON(createContextRequestDto: CreateContextRequestDto): string {
  return JSON.stringify(CreateContextRequestDto$outboundSchema.parse(createContextRequestDto));
}

export function createContextRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<CreateContextRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateContextRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateContextRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - dataToJSON(data: Data)
 - dataFromJSON(jsonString: string)
 - createContextRequestDtoToJSON(createContextRequestDto: CreateContextRequestDto)
 - createContextRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Data$Outbound;
}

export function dataToJSON(data: Data): string {
  return JSON.stringify(Data$outb...)
 - Outbound(CreateContextRequestDto$Outbound;
}

export function createContextRequestDtoToJSON(createContextRequ...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function dataToJSON
- export function dataFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function createContextRequestDtoToJSON
- export function createContextRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/createdsubscriberdto.ts
Tamaño: 1956 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type CreatedSubscriberDto = {
  /**
   * The ID of the subscriber that was created.
   */
  subscriberId: string;
};

/** @internal */
export const CreatedSubscriberDto$inboundSchema: z.ZodType<CreatedSubscriberDto, z.ZodTypeDef, unknown> = z.object({
  subscriberId: z.string(),
});

/** @internal */
export type CreatedSubscriberDto$Outbound = {
  subscriberId: string;
};

/** @internal */
export const CreatedSubscriberDto$outboundSchema: z.ZodType<
  CreatedSubscriberDto$Outbound,
  z.ZodTypeDef,
  CreatedSubscriberDto
> = z.object({
  subscriberId: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatedSubscriberDto$ {
  /** @deprecated use `CreatedSubscriberDto$inboundSchema` instead. */
  export const inboundSchema = CreatedSubscriberDto$inboundSchema;
  /** @deprecated use `CreatedSubscriberDto$outboundSchema` instead. */
  export const outboundSchema = CreatedSubscriberDto$outboundSchema;
  /** @deprecated use `CreatedSubscriberDto$Outbound` instead. */
  export type Outbound = CreatedSubscriberDto$Outbound;
}

export function createdSubscriberDtoToJSON(createdSubscriberDto: CreatedSubscriberDto): string {
  return JSON.stringify(CreatedSubscriberDto$outboundSchema.parse(createdSubscriberDto));
}

export function createdSubscriberDtoFromJSON(
  jsonString: string
): SafeParseResult<CreatedSubscriberDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatedSubscriberDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatedSubscriberDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - createdSubscriberDtoToJSON(createdSubscriberDto: CreatedSubscriberDto)
 - createdSubscriberDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(CreatedSubscriberDto$Outbound;
}

export function createdSubscriberDtoToJSON(createdSubscriberDto: C...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function createdSubscriberDtoToJSON
- export function createdSubscriberDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/createenvironmentrequestdto.ts
Tamaño: 2425 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type CreateEnvironmentRequestDto = {
  /**
   * Name of the environment to be created
   */
  name: string;
  /**
   * MongoDB ObjectId of the parent environment (optional)
   */
  parentId?: string | undefined;
  /**
   * Hex color code for the environment
   */
  color: string;
};

/** @internal */
export const CreateEnvironmentRequestDto$inboundSchema: z.ZodType<CreateEnvironmentRequestDto, z.ZodTypeDef, unknown> =
  z.object({
    name: z.string(),
    parentId: z.string().optional(),
    color: z.string(),
  });

/** @internal */
export type CreateEnvironmentRequestDto$Outbound = {
  name: string;
  parentId?: string | undefined;
  color: string;
};

/** @internal */
export const CreateEnvironmentRequestDto$outboundSchema: z.ZodType<
  CreateEnvironmentRequestDto$Outbound,
  z.ZodTypeDef,
  CreateEnvironmentRequestDto
> = z.object({
  name: z.string(),
  parentId: z.string().optional(),
  color: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateEnvironmentRequestDto$ {
  /** @deprecated use `CreateEnvironmentRequestDto$inboundSchema` instead. */
  export const inboundSchema = CreateEnvironmentRequestDto$inboundSchema;
  /** @deprecated use `CreateEnvironmentRequestDto$outboundSchema` instead. */
  export const outboundSchema = CreateEnvironmentRequestDto$outboundSchema;
  /** @deprecated use `CreateEnvironmentRequestDto$Outbound` instead. */
  export type Outbound = CreateEnvironmentRequestDto$Outbound;
}

export function createEnvironmentRequestDtoToJSON(createEnvironmentRequestDto: CreateEnvironmentRequestDto): string {
  return JSON.stringify(CreateEnvironmentRequestDto$outboundSchema.parse(createEnvironmentRequestDto));
}

export function createEnvironmentRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<CreateEnvironmentRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateEnvironmentRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateEnvironmentRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - createEnvironmentRequestDtoToJSON(createEnvironmentRequestDto: CreateEnvironmentRequestDto)
 - createEnvironmentRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(CreateEnvironmentRequestDto$Outbound;
}

export function createEnvironmentRequestDtoToJSON(createEnv...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function createEnvironmentRequestDtoToJSON
- export function createEnvironmentRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/createintegrationrequestdto.ts
Tamaño: 7552 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  CredentialsDto,
  CredentialsDto$inboundSchema,
  CredentialsDto$Outbound,
  CredentialsDto$outboundSchema,
} from './credentialsdto.js';
import {
  StepFilterDto,
  StepFilterDto$inboundSchema,
  StepFilterDto$Outbound,
  StepFilterDto$outboundSchema,
} from './stepfilterdto.js';

/**
 * The channel type for the integration
 */
export const CreateIntegrationRequestDtoChannel = {
  InApp: 'in_app',
  Email: 'email',
  Sms: 'sms',
  Chat: 'chat',
  Push: 'push',
} as const;
/**
 * The channel type for the integration
 */
export type CreateIntegrationRequestDtoChannel = ClosedEnum<typeof CreateIntegrationRequestDtoChannel>;

/**
 * Configurations for the integration
 */
export type Configurations = {};

export type CreateIntegrationRequestDto = {
  /**
   * The name of the integration
   */
  name?: string | undefined;
  /**
   * The unique identifier for the integration
   */
  identifier?: string | undefined;
  /**
   * The ID of the associated environment
   */
  environmentId?: string | undefined;
  /**
   * The provider ID for the integration
   */
  providerId: string;
  /**
   * The channel type for the integration
   */
  channel: CreateIntegrationRequestDtoChannel;
  /**
   * The credentials for the integration
   */
  credentials?: CredentialsDto | undefined;
  /**
   * If the integration is active, the validation on the credentials field will run
   */
  active?: boolean | undefined;
  /**
   * Flag to check the integration status
   */
  check?: boolean | undefined;
  /**
   * Conditions for the integration
   */
  conditions?: Array<StepFilterDto> | undefined;
  /**
   * Configurations for the integration
   */
  configurations?: Configurations | undefined;
};

/** @internal */
export const CreateIntegrationRequestDtoChannel$inboundSchema: z.ZodNativeEnum<
  typeof CreateIntegrationRequestDtoChannel
> = z.nativeEnum(CreateIntegrationRequestDtoChannel);

/** @internal */
export const CreateIntegrationRequestDtoChannel$outboundSchema: z.ZodNativeEnum<
  typeof CreateIntegrationRequestDtoChannel
> = CreateIntegrationRequestDtoChannel$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateIntegrationRequestDtoChannel$ {
  /** @deprecated use `CreateIntegrationRequestDtoChannel$inboundSchema` instead. */
  export const inboundSchema = CreateIntegrationRequestDtoChannel$inboundSchema;
  /** @deprecated use `CreateIntegrationRequestDtoChannel$outboundSchema` instead. */
  export const outboundSchema = CreateIntegrationRequestDtoChannel$outboundSchema;
}

/** @internal */
export const Configurations$inboundSchema: z.ZodType<Configurations, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type Configurations$Outbound = {};

/** @internal */
export const Configurations$outboundSchema: z.ZodType<Configurations$Outbound, z.ZodTypeDef, Configurations> = z.object(
  {}
);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Configurations$ {
  /** @deprecated use `Configurations$inboundSchema` instead. */
  export const inboundSchema = Configurations$inboundSchema;
  /** @deprecated use `Configurations$outboundSchema` instead. */
  export const outboundSchema = Configurations$outboundSchema;
  /** @deprecated use `Configurations$Outbound` instead. */
  export type Outbound = Configurations$Outbound;
}

export function configurationsToJSON(configurations: Configurations): string {
  return JSON.stringify(Configurations$outboundSchema.parse(configurations));
}

export function configurationsFromJSON(jsonString: string): SafeParseResult<Configurations, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Configurations$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Configurations' from JSON`
  );
}

/** @internal */
export const CreateIntegrationRequestDto$inboundSchema: z.ZodType<CreateIntegrationRequestDto, z.ZodTypeDef, unknown> =
  z
    .object({
      name: z.string().optional(),
      identifier: z.string().optional(),
      _environmentId: z.string().optional(),
      providerId: z.string(),
      channel: CreateIntegrationRequestDtoChannel$inboundSchema,
      credentials: CredentialsDto$inboundSchema.optional(),
      active: z.boolean().optional(),
      check: z.boolean().optional(),
      conditions: z.array(StepFilterDto$inboundSchema).optional(),
      configurations: z.lazy(() => Configurations$inboundSchema).optional(),
    })
    .transform((v) => {
      return remap$(v, {
        _environmentId: 'environmentId',
      });
    });

/** @internal */
export type CreateIntegrationRequestDto$Outbound = {
  name?: string | undefined;
  identifier?: string | undefined;
  _environmentId?: string | undefined;
  providerId: string;
  channel: string;
  credentials?: CredentialsDto$Outbound | undefined;
  active?: boolean | undefined;
  check?: boolean | undefined;
  conditions?: Array<StepFilterDto$Outbound> | undefined;
  configurations?: Configurations$Outbound | undefined;
};

/** @internal */
export const CreateIntegrationRequestDto$outboundSchema: z.ZodType<
  CreateIntegrationRequestDto$Outbound,
  z.ZodTypeDef,
  CreateIntegrationRequestDto
> = z
  .object({
    name: z.string().optional(),
    identifier: z.string().optional(),
    environmentId: z.string().optional(),
    providerId: z.string(),
    channel: CreateIntegrationRequestDtoChannel$outboundSchema,
    credentials: CredentialsDto$outboundSchema.optional(),
    active: z.boolean().optional(),
    check: z.boolean().optional(),
    conditions: z.array(StepFilterDto$outboundSchema).optional(),
    configurations: z.lazy(() => Configurations$outboundSchema).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      environmentId: '_environmentId',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateIntegrationRequestDto$ {
  /** @deprecated use `CreateIntegrationRequestDto$inboundSchema` instead. */
  export const inboundSchema = CreateIntegrationRequestDto$inboundSchema;
  /** @deprecated use `CreateIntegrationRequestDto$outboundSchema` instead. */
  export const outboundSchema = CreateIntegrationRequestDto$outboundSchema;
  /** @deprecated use `CreateIntegrationRequestDto$Outbound` instead. */
  export type Outbound = CreateIntegrationRequestDto$Outbound;
}

export function createIntegrationRequestDtoToJSON(createIntegrationRequestDto: CreateIntegrationRequestDto): string {
  return JSON.stringify(CreateIntegrationRequestDto$outboundSchema.parse(createIntegrationRequestDto));
}

export function createIntegrationRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<CreateIntegrationRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateIntegrationRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateIntegrationRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - configurationsToJSON(configurations: Configurations)
 - configurationsFromJSON(jsonString: string)
 - createIntegrationRequestDtoToJSON(createIntegrationRequestDto: CreateIntegrationRequestDto)
 - createIntegrationRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Configurations$Outbound;
}

export function configurationsToJSON(configurations: Configurations): st...)
 - Outbound(CreateIntegrationRequestDto$Outbound;
}

export function createIntegrationRequestDtoToJSON(createInt...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function configurationsToJSON
- export function configurationsFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function createIntegrationRequestDtoToJSON
- export function createIntegrationRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/createlayoutdto.ts
Tamaño: 2830 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  LayoutCreationSourceEnum,
  LayoutCreationSourceEnum$inboundSchema,
  LayoutCreationSourceEnum$outboundSchema,
} from './layoutcreationsourceenum.js';

export type CreateLayoutDto = {
  /**
   * Unique identifier for the layout
   */
  layoutId: string;
  /**
   * Name of the layout
   */
  name: string;
  /**
   * Enable or disable translations for this layout
   */
  isTranslationEnabled?: boolean | undefined;
  /**
   * Source of layout creation
   */
  source?: LayoutCreationSourceEnum | undefined;
};

/** @internal */
export const CreateLayoutDto$inboundSchema: z.ZodType<CreateLayoutDto, z.ZodTypeDef, unknown> = z
  .object({
    layoutId: z.string(),
    name: z.string(),
    isTranslationEnabled: z.boolean().default(false),
    __source: LayoutCreationSourceEnum$inboundSchema.default('dashboard'),
  })
  .transform((v) => {
    return remap$(v, {
      __source: 'source',
    });
  });

/** @internal */
export type CreateLayoutDto$Outbound = {
  layoutId: string;
  name: string;
  isTranslationEnabled: boolean;
  __source: string;
};

/** @internal */
export const CreateLayoutDto$outboundSchema: z.ZodType<CreateLayoutDto$Outbound, z.ZodTypeDef, CreateLayoutDto> = z
  .object({
    layoutId: z.string(),
    name: z.string(),
    isTranslationEnabled: z.boolean().default(false),
    source: LayoutCreationSourceEnum$outboundSchema.default('dashboard'),
  })
  .transform((v) => {
    return remap$(v, {
      source: '__source',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateLayoutDto$ {
  /** @deprecated use `CreateLayoutDto$inboundSchema` instead. */
  export const inboundSchema = CreateLayoutDto$inboundSchema;
  /** @deprecated use `CreateLayoutDto$outboundSchema` instead. */
  export const outboundSchema = CreateLayoutDto$outboundSchema;
  /** @deprecated use `CreateLayoutDto$Outbound` instead. */
  export type Outbound = CreateLayoutDto$Outbound;
}

export function createLayoutDtoToJSON(createLayoutDto: CreateLayoutDto): string {
  return JSON.stringify(CreateLayoutDto$outboundSchema.parse(createLayoutDto));
}

export function createLayoutDtoFromJSON(jsonString: string): SafeParseResult<CreateLayoutDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateLayoutDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateLayoutDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - createLayoutDtoToJSON(createLayoutDto: CreateLayoutDto)
 - createLayoutDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(CreateLayoutDto$Outbound;
}

export function createLayoutDtoToJSON(createLayoutDto: CreateLayoutDto)...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function createLayoutDtoToJSON
- export function createLayoutDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/createsubscriberrequestdto.ts
Tamaño: 3866 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type CreateSubscriberRequestDto = {
  /**
   * Unique identifier of the subscriber
   */
  subscriberId: string;
  /**
   * First name of the subscriber
   */
  firstName?: string | null | undefined;
  /**
   * Last name of the subscriber
   */
  lastName?: string | null | undefined;
  /**
   * Email address of the subscriber
   */
  email?: string | null | undefined;
  /**
   * Phone number of the subscriber
   */
  phone?: string | null | undefined;
  /**
   * Avatar URL or identifier
   */
  avatar?: string | null | undefined;
  /**
   * Timezone of the subscriber
   */
  timezone?: string | null | undefined;
  /**
   * Locale of the subscriber
   */
  locale?: string | null | undefined;
  /**
   * Additional custom data for the subscriber
   */
  data?: { [k: string]: any } | null | undefined;
};

/** @internal */
export const CreateSubscriberRequestDto$inboundSchema: z.ZodType<CreateSubscriberRequestDto, z.ZodTypeDef, unknown> =
  z.object({
    subscriberId: z.string(),
    firstName: z.nullable(z.string()).optional(),
    lastName: z.nullable(z.string()).optional(),
    email: z.nullable(z.string()).optional(),
    phone: z.nullable(z.string()).optional(),
    avatar: z.nullable(z.string()).optional(),
    timezone: z.nullable(z.string()).optional(),
    locale: z.nullable(z.string()).optional(),
    data: z.nullable(z.record(z.any())).optional(),
  });

/** @internal */
export type CreateSubscriberRequestDto$Outbound = {
  subscriberId: string;
  firstName?: string | null | undefined;
  lastName?: string | null | undefined;
  email?: string | null | undefined;
  phone?: string | null | undefined;
  avatar?: string | null | undefined;
  timezone?: string | null | undefined;
  locale?: string | null | undefined;
  data?: { [k: string]: any } | null | undefined;
};

/** @internal */
export const CreateSubscriberRequestDto$outboundSchema: z.ZodType<
  CreateSubscriberRequestDto$Outbound,
  z.ZodTypeDef,
  CreateSubscriberRequestDto
> = z.object({
  subscriberId: z.string(),
  firstName: z.nullable(z.string()).optional(),
  lastName: z.nullable(z.string()).optional(),
  email: z.nullable(z.string()).optional(),
  phone: z.nullable(z.string()).optional(),
  avatar: z.nullable(z.string()).optional(),
  timezone: z.nullable(z.string()).optional(),
  locale: z.nullable(z.string()).optional(),
  data: z.nullable(z.record(z.any())).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateSubscriberRequestDto$ {
  /** @deprecated use `CreateSubscriberRequestDto$inboundSchema` instead. */
  export const inboundSchema = CreateSubscriberRequestDto$inboundSchema;
  /** @deprecated use `CreateSubscriberRequestDto$outboundSchema` instead. */
  export const outboundSchema = CreateSubscriberRequestDto$outboundSchema;
  /** @deprecated use `CreateSubscriberRequestDto$Outbound` instead. */
  export type Outbound = CreateSubscriberRequestDto$Outbound;
}

export function createSubscriberRequestDtoToJSON(createSubscriberRequestDto: CreateSubscriberRequestDto): string {
  return JSON.stringify(CreateSubscriberRequestDto$outboundSchema.parse(createSubscriberRequestDto));
}

export function createSubscriberRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<CreateSubscriberRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateSubscriberRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateSubscriberRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - createSubscriberRequestDtoToJSON(createSubscriberRequestDto: CreateSubscriberRequestDto)
 - createSubscriberRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(CreateSubscriberRequestDto$Outbound;
}

export function createSubscriberRequestDtoToJSON(createSubsc...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function createSubscriberRequestDtoToJSON
- export function createSubscriberRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/createtopicsubscriptionsrequestdto.ts
Tamaño: 2351 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type CreateTopicSubscriptionsRequestDto = {
  /**
   * List of subscriber identifiers to subscribe to the topic (max: 100)
   */
  subscriberIds: Array<string>;
};

/** @internal */
export const CreateTopicSubscriptionsRequestDto$inboundSchema: z.ZodType<
  CreateTopicSubscriptionsRequestDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  subscriberIds: z.array(z.string()),
});

/** @internal */
export type CreateTopicSubscriptionsRequestDto$Outbound = {
  subscriberIds: Array<string>;
};

/** @internal */
export const CreateTopicSubscriptionsRequestDto$outboundSchema: z.ZodType<
  CreateTopicSubscriptionsRequestDto$Outbound,
  z.ZodTypeDef,
  CreateTopicSubscriptionsRequestDto
> = z.object({
  subscriberIds: z.array(z.string()),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateTopicSubscriptionsRequestDto$ {
  /** @deprecated use `CreateTopicSubscriptionsRequestDto$inboundSchema` instead. */
  export const inboundSchema = CreateTopicSubscriptionsRequestDto$inboundSchema;
  /** @deprecated use `CreateTopicSubscriptionsRequestDto$outboundSchema` instead. */
  export const outboundSchema = CreateTopicSubscriptionsRequestDto$outboundSchema;
  /** @deprecated use `CreateTopicSubscriptionsRequestDto$Outbound` instead. */
  export type Outbound = CreateTopicSubscriptionsRequestDto$Outbound;
}

export function createTopicSubscriptionsRequestDtoToJSON(
  createTopicSubscriptionsRequestDto: CreateTopicSubscriptionsRequestDto
): string {
  return JSON.stringify(CreateTopicSubscriptionsRequestDto$outboundSchema.parse(createTopicSubscriptionsRequestDto));
}

export function createTopicSubscriptionsRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<CreateTopicSubscriptionsRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateTopicSubscriptionsRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateTopicSubscriptionsRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - createTopicSubscriptionsRequestDtoToJSON(createTopicSubscriptionsRequestDto: CreateTopicSubscriptionsRequestDto)
 - createTopicSubscriptionsRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(CreateTopicSubscriptionsRequestDto$Outbound;
}

export function createTopicSubscriptionsRequestDtoTo...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function createTopicSubscriptionsRequestDtoToJSON
- export function createTopicSubscriptionsRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/createtopicsubscriptionsresponsedto.ts
Tamaño: 3288 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import { MetaDto, MetaDto$inboundSchema, MetaDto$Outbound, MetaDto$outboundSchema } from './metadto.js';
import {
  SubscriptionDto,
  SubscriptionDto$inboundSchema,
  SubscriptionDto$Outbound,
  SubscriptionDto$outboundSchema,
} from './subscriptiondto.js';
import {
  SubscriptionErrorDto,
  SubscriptionErrorDto$inboundSchema,
  SubscriptionErrorDto$Outbound,
  SubscriptionErrorDto$outboundSchema,
} from './subscriptionerrordto.js';

export type CreateTopicSubscriptionsResponseDto = {
  /**
   * The list of successfully created subscriptions
   */
  data: Array<SubscriptionDto>;
  /**
   * Metadata about the operation
   */
  meta: MetaDto;
  /**
   * The list of errors for failed subscription attempts
   */
  errors?: Array<SubscriptionErrorDto> | undefined;
};

/** @internal */
export const CreateTopicSubscriptionsResponseDto$inboundSchema: z.ZodType<
  CreateTopicSubscriptionsResponseDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  data: z.array(SubscriptionDto$inboundSchema),
  meta: MetaDto$inboundSchema,
  errors: z.array(SubscriptionErrorDto$inboundSchema).optional(),
});

/** @internal */
export type CreateTopicSubscriptionsResponseDto$Outbound = {
  data: Array<SubscriptionDto$Outbound>;
  meta: MetaDto$Outbound;
  errors?: Array<SubscriptionErrorDto$Outbound> | undefined;
};

/** @internal */
export const CreateTopicSubscriptionsResponseDto$outboundSchema: z.ZodType<
  CreateTopicSubscriptionsResponseDto$Outbound,
  z.ZodTypeDef,
  CreateTopicSubscriptionsResponseDto
> = z.object({
  data: z.array(SubscriptionDto$outboundSchema),
  meta: MetaDto$outboundSchema,
  errors: z.array(SubscriptionErrorDto$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateTopicSubscriptionsResponseDto$ {
  /** @deprecated use `CreateTopicSubscriptionsResponseDto$inboundSchema` instead. */
  export const inboundSchema = CreateTopicSubscriptionsResponseDto$inboundSchema;
  /** @deprecated use `CreateTopicSubscriptionsResponseDto$outboundSchema` instead. */
  export const outboundSchema = CreateTopicSubscriptionsResponseDto$outboundSchema;
  /** @deprecated use `CreateTopicSubscriptionsResponseDto$Outbound` instead. */
  export type Outbound = CreateTopicSubscriptionsResponseDto$Outbound;
}

export function createTopicSubscriptionsResponseDtoToJSON(
  createTopicSubscriptionsResponseDto: CreateTopicSubscriptionsResponseDto
): string {
  return JSON.stringify(CreateTopicSubscriptionsResponseDto$outboundSchema.parse(createTopicSubscriptionsResponseDto));
}

export function createTopicSubscriptionsResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<CreateTopicSubscriptionsResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateTopicSubscriptionsResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateTopicSubscriptionsResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - createTopicSubscriptionsResponseDtoToJSON(createTopicSubscriptionsResponseDto: CreateTopicSubscriptionsResponseDto)
 - createTopicSubscriptionsResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(CreateTopicSubscriptionsResponseDto$Outbound;
}

export function createTopicSubscriptionsResponseDto...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function createTopicSubscriptionsResponseDtoToJSON
- export function createTopicSubscriptionsResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/createtranslationrequestdto.ts
Tamaño: 4935 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * The resource type to associate translation with
 */
export const ResourceType = {
  Workflow: 'workflow',
  Layout: 'layout',
} as const;
/**
 * The resource type to associate translation with
 */
export type ResourceType = ClosedEnum<typeof ResourceType>;

/**
 * Translation content as JSON object
 */
export type Content = {};

export type CreateTranslationRequestDto = {
  /**
   * The resource ID to associate translation with. Accepts identifier or slug format
   */
  resourceId: string;
  /**
   * The resource type to associate translation with
   */
  resourceType: ResourceType;
  /**
   * Locale code (e.g., en_US, es_ES)
   */
  locale: string;
  /**
   * Translation content as JSON object
   */
  content: Content;
};

/** @internal */
export const ResourceType$inboundSchema: z.ZodNativeEnum<typeof ResourceType> = z.nativeEnum(ResourceType);

/** @internal */
export const ResourceType$outboundSchema: z.ZodNativeEnum<typeof ResourceType> = ResourceType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResourceType$ {
  /** @deprecated use `ResourceType$inboundSchema` instead. */
  export const inboundSchema = ResourceType$inboundSchema;
  /** @deprecated use `ResourceType$outboundSchema` instead. */
  export const outboundSchema = ResourceType$outboundSchema;
}

/** @internal */
export const Content$inboundSchema: z.ZodType<Content, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type Content$Outbound = {};

/** @internal */
export const Content$outboundSchema: z.ZodType<Content$Outbound, z.ZodTypeDef, Content> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Content$ {
  /** @deprecated use `Content$inboundSchema` instead. */
  export const inboundSchema = Content$inboundSchema;
  /** @deprecated use `Content$outboundSchema` instead. */
  export const outboundSchema = Content$outboundSchema;
  /** @deprecated use `Content$Outbound` instead. */
  export type Outbound = Content$Outbound;
}

export function contentToJSON(content: Content): string {
  return JSON.stringify(Content$outboundSchema.parse(content));
}

export function contentFromJSON(jsonString: string): SafeParseResult<Content, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Content$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Content' from JSON`
  );
}

/** @internal */
export const CreateTranslationRequestDto$inboundSchema: z.ZodType<CreateTranslationRequestDto, z.ZodTypeDef, unknown> =
  z.object({
    resourceId: z.string(),
    resourceType: ResourceType$inboundSchema,
    locale: z.string(),
    content: z.lazy(() => Content$inboundSchema),
  });

/** @internal */
export type CreateTranslationRequestDto$Outbound = {
  resourceId: string;
  resourceType: string;
  locale: string;
  content: Content$Outbound;
};

/** @internal */
export const CreateTranslationRequestDto$outboundSchema: z.ZodType<
  CreateTranslationRequestDto$Outbound,
  z.ZodTypeDef,
  CreateTranslationRequestDto
> = z.object({
  resourceId: z.string(),
  resourceType: ResourceType$outboundSchema,
  locale: z.string(),
  content: z.lazy(() => Content$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateTranslationRequestDto$ {
  /** @deprecated use `CreateTranslationRequestDto$inboundSchema` instead. */
  export const inboundSchema = CreateTranslationRequestDto$inboundSchema;
  /** @deprecated use `CreateTranslationRequestDto$outboundSchema` instead. */
  export const outboundSchema = CreateTranslationRequestDto$outboundSchema;
  /** @deprecated use `CreateTranslationRequestDto$Outbound` instead. */
  export type Outbound = CreateTranslationRequestDto$Outbound;
}

export function createTranslationRequestDtoToJSON(createTranslationRequestDto: CreateTranslationRequestDto): string {
  return JSON.stringify(CreateTranslationRequestDto$outboundSchema.parse(createTranslationRequestDto));
}

export function createTranslationRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<CreateTranslationRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateTranslationRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateTranslationRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - contentToJSON(content: Content)
 - contentFromJSON(jsonString: string)
 - createTranslationRequestDtoToJSON(createTranslationRequestDto: CreateTranslationRequestDto)
 - createTranslationRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Content$Outbound;
}

export function contentToJSON(content: Content): string {
  return JSON.stringi...)
 - Outbound(CreateTranslationRequestDto$Outbound;
}

export function createTranslationRequestDtoToJSON(createTra...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function contentToJSON
- export function contentFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function createTranslationRequestDtoToJSON
- export function createTranslationRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/createupdatetopicrequestdto.ts
Tamaño: 2393 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type CreateUpdateTopicRequestDto = {
  /**
   * The unique key identifier for the topic. The key must contain only alphanumeric characters (a-z, A-Z, 0-9), hyphens (-), underscores (_), colons (:), or be a valid email address.
   */
  key: string;
  /**
   * The display name for the topic
   */
  name?: string | undefined;
};

/** @internal */
export const CreateUpdateTopicRequestDto$inboundSchema: z.ZodType<CreateUpdateTopicRequestDto, z.ZodTypeDef, unknown> =
  z.object({
    key: z.string(),
    name: z.string().optional(),
  });

/** @internal */
export type CreateUpdateTopicRequestDto$Outbound = {
  key: string;
  name?: string | undefined;
};

/** @internal */
export const CreateUpdateTopicRequestDto$outboundSchema: z.ZodType<
  CreateUpdateTopicRequestDto$Outbound,
  z.ZodTypeDef,
  CreateUpdateTopicRequestDto
> = z.object({
  key: z.string(),
  name: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateUpdateTopicRequestDto$ {
  /** @deprecated use `CreateUpdateTopicRequestDto$inboundSchema` instead. */
  export const inboundSchema = CreateUpdateTopicRequestDto$inboundSchema;
  /** @deprecated use `CreateUpdateTopicRequestDto$outboundSchema` instead. */
  export const outboundSchema = CreateUpdateTopicRequestDto$outboundSchema;
  /** @deprecated use `CreateUpdateTopicRequestDto$Outbound` instead. */
  export type Outbound = CreateUpdateTopicRequestDto$Outbound;
}

export function createUpdateTopicRequestDtoToJSON(createUpdateTopicRequestDto: CreateUpdateTopicRequestDto): string {
  return JSON.stringify(CreateUpdateTopicRequestDto$outboundSchema.parse(createUpdateTopicRequestDto));
}

export function createUpdateTopicRequestDtoFromJSON(
  jsonString: string
): SafeParseResult<CreateUpdateTopicRequestDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateUpdateTopicRequestDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateUpdateTopicRequestDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - createUpdateTopicRequestDtoToJSON(createUpdateTopicRequestDto: CreateUpdateTopicRequestDto)
 - createUpdateTopicRequestDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(CreateUpdateTopicRequestDto$Outbound;
}

export function createUpdateTopicRequestDtoToJSON(createUpd...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function createUpdateTopicRequestDtoToJSON
- export function createUpdateTopicRequestDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/createworkflowdto.ts
Tamaño: 14997 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  ChatStepUpsertDto,
  ChatStepUpsertDto$inboundSchema,
  ChatStepUpsertDto$Outbound,
  ChatStepUpsertDto$outboundSchema,
} from './chatstepupsertdto.js';
import {
  CustomStepUpsertDto,
  CustomStepUpsertDto$inboundSchema,
  CustomStepUpsertDto$Outbound,
  CustomStepUpsertDto$outboundSchema,
} from './customstepupsertdto.js';
import {
  DelayStepUpsertDto,
  DelayStepUpsertDto$inboundSchema,
  DelayStepUpsertDto$Outbound,
  DelayStepUpsertDto$outboundSchema,
} from './delaystepupsertdto.js';
import {
  DigestStepUpsertDto,
  DigestStepUpsertDto$inboundSchema,
  DigestStepUpsertDto$Outbound,
  DigestStepUpsertDto$outboundSchema,
} from './digeststepupsertdto.js';
import {
  EmailStepUpsertDto,
  EmailStepUpsertDto$inboundSchema,
  EmailStepUpsertDto$Outbound,
  EmailStepUpsertDto$outboundSchema,
} from './emailstepupsertdto.js';
import {
  InAppStepUpsertDto,
  InAppStepUpsertDto$inboundSchema,
  InAppStepUpsertDto$Outbound,
  InAppStepUpsertDto$outboundSchema,
} from './inappstepupsertdto.js';
import {
  PreferencesRequestDto,
  PreferencesRequestDto$inboundSchema,
  PreferencesRequestDto$Outbound,
  PreferencesRequestDto$outboundSchema,
} from './preferencesrequestdto.js';
import {
  PushStepUpsertDto,
  PushStepUpsertDto$inboundSchema,
  PushStepUpsertDto$Outbound,
  PushStepUpsertDto$outboundSchema,
} from './pushstepupsertdto.js';
import {
  SeverityLevelEnum,
  SeverityLevelEnum$inboundSchema,
  SeverityLevelEnum$outboundSchema,
} from './severitylevelenum.js';
import {
  SmsStepUpsertDto,
  SmsStepUpsertDto$inboundSchema,
  SmsStepUpsertDto$Outbound,
  SmsStepUpsertDto$outboundSchema,
} from './smsstepupsertdto.js';
import {
  ThrottleStepUpsertDto,
  ThrottleStepUpsertDto$inboundSchema,
  ThrottleStepUpsertDto$Outbound,
  ThrottleStepUpsertDto$outboundSchema,
} from './throttlestepupsertdto.js';
import {
  WorkflowCreationSourceEnum,
  WorkflowCreationSourceEnum$inboundSchema,
  WorkflowCreationSourceEnum$outboundSchema,
} from './workflowcreationsourceenum.js';

export type Steps =
  | (InAppStepUpsertDto & { type: 'in_app' })
  | (EmailStepUpsertDto & { type: 'email' })
  | (SmsStepUpsertDto & { type: 'sms' })
  | (PushStepUpsertDto & { type: 'push' })
  | (ChatStepUpsertDto & { type: 'chat' })
  | (DelayStepUpsertDto & { type: 'delay' })
  | (DigestStepUpsertDto & { type: 'digest' })
  | (ThrottleStepUpsertDto & { type: 'throttle' })
  | (CustomStepUpsertDto & { type: 'custom' });

export type CreateWorkflowDto = {
  /**
   * Name of the workflow
   */
  name: string;
  /**
   * Description of the workflow
   */
  description?: string | undefined;
  /**
   * Tags associated with the workflow
   */
  tags?: Array<string> | undefined;
  /**
   * Whether the workflow is active
   */
  active?: boolean | undefined;
  /**
   * Enable or disable payload schema validation
   */
  validatePayload?: boolean | undefined;
  /**
   * The payload JSON Schema for the workflow
   */
  payloadSchema?: { [k: string]: any } | null | undefined;
  /**
   * Enable or disable translations for this workflow
   */
  isTranslationEnabled?: boolean | undefined;
  /**
   * Unique identifier for the workflow
   */
  workflowId: string;
  /**
   * Steps of the workflow
   */
  steps: Array<
    | (InAppStepUpsertDto & { type: 'in_app' })
    | (EmailStepUpsertDto & { type: 'email' })
    | (SmsStepUpsertDto & { type: 'sms' })
    | (PushStepUpsertDto & { type: 'push' })
    | (ChatStepUpsertDto & { type: 'chat' })
    | (DelayStepUpsertDto & { type: 'delay' })
    | (DigestStepUpsertDto & { type: 'digest' })
    | (ThrottleStepUpsertDto & { type: 'throttle' })
    | (CustomStepUpsertDto & { type: 'custom' })
  >;
  /**
   * Source of workflow creation
   */
  source?: WorkflowCreationSourceEnum | undefined;
  /**
   * Workflow preferences
   */
  preferences?: PreferencesRequestDto | undefined;
  /**
   * Severity of the workflow
   */
  severity?: SeverityLevelEnum | undefined;
};

/** @internal */
export const Steps$inboundSchema: z.ZodType<Steps, z.ZodTypeDef, unknown> = z.union([
  InAppStepUpsertDto$inboundSchema.and(
    z.object({ type: z.literal('in_app') }).transform((v) => ({
      type: v.type,
    }))
  ),
  EmailStepUpsertDto$inboundSchema.and(
    z.object({ type: z.literal('email') }).transform((v) => ({
      type: v.type,
    }))
  ),
  SmsStepUpsertDto$inboundSchema.and(z.object({ type: z.literal('sms') }).transform((v) => ({ type: v.type }))),
  PushStepUpsertDto$inboundSchema.and(
    z.object({ type: z.literal('push') }).transform((v) => ({
      type: v.type,
    }))
  ),
  ChatStepUpsertDto$inboundSchema.and(
    z.object({ type: z.literal('chat') }).transform((v) => ({
      type: v.type,
    }))
  ),
  DelayStepUpsertDto$inboundSchema.and(
    z.object({ type: z.literal('delay') }).transform((v) => ({
      type: v.type,
    }))
  ),
  DigestStepUpsertDto$inboundSchema.and(
    z.object({ type: z.literal('digest') }).transform((v) => ({
      type: v.type,
    }))
  ),
  ThrottleStepUpsertDto$inboundSchema.and(
    z.object({ type: z.literal('throttle') }).transform((v) => ({
      type: v.type,
    }))
  ),
  CustomStepUpsertDto$inboundSchema.and(
    z.object({ type: z.literal('custom') }).transform((v) => ({
      type: v.type,
    }))
  ),
]);

/** @internal */
export type Steps$Outbound =
  | (InAppStepUpsertDto$Outbound & { type: 'in_app' })
  | (EmailStepUpsertDto$Outbound & { type: 'email' })
  | (SmsStepUpsertDto$Outbound & { type: 'sms' })
  | (PushStepUpsertDto$Outbound & { type: 'push' })
  | (ChatStepUpsertDto$Outbound & { type: 'chat' })
  | (DelayStepUpsertDto$Outbound & { type: 'delay' })
  | (DigestStepUpsertDto$Outbound & { type: 'digest' })
  | (ThrottleStepUpsertDto$Outbound & { type: 'throttle' })
  | (CustomStepUpsertDto$Outbound & { type: 'custom' });

/** @internal */
export const Steps$outboundSchema: z.ZodType<Steps$Outbound, z.ZodTypeDef, Steps> = z.union([
  InAppStepUpsertDto$outboundSchema.and(
    z.object({ type: z.literal('in_app') }).transform((v) => ({
      type: v.type,
    }))
  ),
  EmailStepUpsertDto$outboundSchema.and(z.object({ type: z.literal('email') }).transform((v) => ({ type: v.type }))),
  SmsStepUpsertDto$outboundSchema.and(z.object({ type: z.literal('sms') }).transform((v) => ({ type: v.type }))),
  PushStepUpsertDto$outboundSchema.and(z.object({ type: z.literal('push') }).transform((v) => ({ type: v.type }))),
  ChatStepUpsertDto$outboundSchema.and(z.object({ type: z.literal('chat') }).transform((v) => ({ type: v.type }))),
  DelayStepUpsertDto$outboundSchema.and(z.object({ type: z.literal('delay') }).transform((v) => ({ type: v.type }))),
  DigestStepUpsertDto$outboundSchema.and(
    z.object({ type: z.literal('digest') }).transform((v) => ({
      type: v.type,
    }))
  ),
  ThrottleStepUpsertDto$outboundSchema.and(
    z.object({ type: z.literal('throttle') }).transform((v) => ({
      type: v.type,
    }))
  ),
  CustomStepUpsertDto$outboundSchema.and(
    z.object({ type: z.literal('custom') }).transform((v) => ({
      type: v.type,
    }))
  ),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Steps$ {
  /** @deprecated use `Steps$inboundSchema` instead. */
  export const inboundSchema = Steps$inboundSchema;
  /** @deprecated use `Steps$outboundSchema` instead. */
  export const outboundSchema = Steps$outboundSchema;
  /** @deprecated use `Steps$Outbound` instead. */
  export type Outbound = Steps$Outbound;
}

export function stepsToJSON(steps: Steps): string {
  return JSON.stringify(Steps$outboundSchema.parse(steps));
}

export function stepsFromJSON(jsonString: string): SafeParseResult<Steps, SDKValidationError> {
  return safeParse(jsonString, (x) => Steps$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'Steps' from JSON`);
}

/** @internal */
export const CreateWorkflowDto$inboundSchema: z.ZodType<CreateWorkflowDto, z.ZodTypeDef, unknown> = z
  .object({
    name: z.string(),
    description: z.string().optional(),
    tags: z.array(z.string()).optional(),
    active: z.boolean().default(false),
    validatePayload: z.boolean().optional(),
    payloadSchema: z.nullable(z.record(z.any())).optional(),
    isTranslationEnabled: z.boolean().default(false),
    workflowId: z.string(),
    steps: z.array(
      z.union([
        InAppStepUpsertDto$inboundSchema.and(
          z.object({ type: z.literal('in_app') }).transform((v) => ({
            type: v.type,
          }))
        ),
        EmailStepUpsertDto$inboundSchema.and(
          z.object({ type: z.literal('email') }).transform((v) => ({
            type: v.type,
          }))
        ),
        SmsStepUpsertDto$inboundSchema.and(
          z.object({ type: z.literal('sms') }).transform((v) => ({
            type: v.type,
          }))
        ),
        PushStepUpsertDto$inboundSchema.and(
          z.object({ type: z.literal('push') }).transform((v) => ({
            type: v.type,
          }))
        ),
        ChatStepUpsertDto$inboundSchema.and(
          z.object({ type: z.literal('chat') }).transform((v) => ({
            type: v.type,
          }))
        ),
        DelayStepUpsertDto$inboundSchema.and(
          z.object({ type: z.literal('delay') }).transform((v) => ({
            type: v.type,
          }))
        ),
        DigestStepUpsertDto$inboundSchema.and(
          z.object({ type: z.literal('digest') }).transform((v) => ({
            type: v.type,
          }))
        ),
        ThrottleStepUpsertDto$inboundSchema.and(
          z.object({ type: z.literal('throttle') }).transform((v) => ({
            type: v.type,
          }))
        ),
        CustomStepUpsertDto$inboundSchema.and(
          z.object({ type: z.literal('custom') }).transform((v) => ({
            type: v.type,
          }))
        ),
      ])
    ),
    __source: WorkflowCreationSourceEnum$inboundSchema.default('editor'),
    preferences: PreferencesRequestDto$inboundSchema.optional(),
    severity: SeverityLevelEnum$inboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      __source: 'source',
    });
  });

/** @internal */
export type CreateWorkflowDto$Outbound = {
  name: string;
  description?: string | undefined;
  tags?: Array<string> | undefined;
  active: boolean;
  validatePayload?: boolean | undefined;
  payloadSchema?: { [k: string]: any } | null | undefined;
  isTranslationEnabled: boolean;
  workflowId: string;
  steps: Array<
    | (InAppStepUpsertDto$Outbound & { type: 'in_app' })
    | (EmailStepUpsertDto$Outbound & { type: 'email' })
    | (SmsStepUpsertDto$Outbound & { type: 'sms' })
    | (PushStepUpsertDto$Outbound & { type: 'push' })
    | (ChatStepUpsertDto$Outbound & { type: 'chat' })
    | (DelayStepUpsertDto$Outbound & { type: 'delay' })
    | (DigestStepUpsertDto$Outbound & { type: 'digest' })
    | (ThrottleStepUpsertDto$Outbound & { type: 'throttle' })
    | (CustomStepUpsertDto$Outbound & { type: 'custom' })
  >;
  __source: string;
  preferences?: PreferencesRequestDto$Outbound | undefined;
  severity?: string | undefined;
};

/** @internal */
export const CreateWorkflowDto$outboundSchema: z.ZodType<CreateWorkflowDto$Outbound, z.ZodTypeDef, CreateWorkflowDto> =
  z
    .object({
      name: z.string(),
      description: z.string().optional(),
      tags: z.array(z.string()).optional(),
      active: z.boolean().default(false),
      validatePayload: z.boolean().optional(),
      payloadSchema: z.nullable(z.record(z.any())).optional(),
      isTranslationEnabled: z.boolean().default(false),
      workflowId: z.string(),
      steps: z.array(
        z.union([
          InAppStepUpsertDto$outboundSchema.and(
            z.object({ type: z.literal('in_app') }).transform((v) => ({
              type: v.type,
            }))
          ),
          EmailStepUpsertDto$outboundSchema.and(
            z.object({ type: z.literal('email') }).transform((v) => ({
              type: v.type,
            }))
          ),
          SmsStepUpsertDto$outboundSchema.and(
            z.object({ type: z.literal('sms') }).transform((v) => ({
              type: v.type,
            }))
          ),
          PushStepUpsertDto$outboundSchema.and(
            z.object({ type: z.literal('push') }).transform((v) => ({
              type: v.type,
            }))
          ),
          ChatStepUpsertDto$outboundSchema.and(
            z.object({ type: z.literal('chat') }).transform((v) => ({
              type: v.type,
            }))
          ),
          DelayStepUpsertDto$outboundSchema.and(
            z.object({ type: z.literal('delay') }).transform((v) => ({
              type: v.type,
            }))
          ),
          DigestStepUpsertDto$outboundSchema.and(
            z.object({ type: z.literal('digest') }).transform((v) => ({
              type: v.type,
            }))
          ),
          ThrottleStepUpsertDto$outboundSchema.and(
            z.object({ type: z.literal('throttle') }).transform((v) => ({
              type: v.type,
            }))
          ),
          CustomStepUpsertDto$outboundSchema.and(
            z.object({ type: z.literal('custom') }).transform((v) => ({
              type: v.type,
            }))
          ),
        ])
      ),
      source: WorkflowCreationSourceEnum$outboundSchema.default('editor'),
      preferences: PreferencesRequestDto$outboundSchema.optional(),
      severity: SeverityLevelEnum$outboundSchema.optional(),
    })
    .transform((v) => {
      return remap$(v, {
        source: '__source',
      });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateWorkflowDto$ {
  /** @deprecated use `CreateWorkflowDto$inboundSchema` instead. */
  export const inboundSchema = CreateWorkflowDto$inboundSchema;
  /** @deprecated use `CreateWorkflowDto$outboundSchema` instead. */
  export const outboundSchema = CreateWorkflowDto$outboundSchema;
  /** @deprecated use `CreateWorkflowDto$Outbound` instead. */
  export type Outbound = CreateWorkflowDto$Outbound;
}

export function createWorkflowDtoToJSON(createWorkflowDto: CreateWorkflowDto): string {
  return JSON.stringify(CreateWorkflowDto$outboundSchema.parse(createWorkflowDto));
}

export function createWorkflowDtoFromJSON(jsonString: string): SafeParseResult<CreateWorkflowDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateWorkflowDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateWorkflowDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - stepsToJSON(steps: Steps)
 - stepsFromJSON(jsonString: string)
 - createWorkflowDtoToJSON(createWorkflowDto: CreateWorkflowDto)
 - createWorkflowDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(Steps$Outbound;
}

export function stepsToJSON(steps: Steps): string {
  return JSON.stringify(Steps...)
 - Outbound(CreateWorkflowDto$Outbound;
}

export function createWorkflowDtoToJSON(createWorkflowDto: CreateWork...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function stepsToJSON
- export function stepsFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function createWorkflowDtoToJSON
- export function createWorkflowDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/credentialsdto.ts
Tamaño: 9359 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type TlsOptions = {};

export type CredentialsDto = {
  apiKey?: string | undefined;
  user?: string | undefined;
  secretKey?: string | undefined;
  domain?: string | undefined;
  password?: string | undefined;
  host?: string | undefined;
  port?: string | undefined;
  secure?: boolean | undefined;
  region?: string | undefined;
  accountSid?: string | undefined;
  messageProfileId?: string | undefined;
  token?: string | undefined;
  from?: string | undefined;
  senderName?: string | undefined;
  projectName?: string | undefined;
  applicationId?: string | undefined;
  clientId?: string | undefined;
  requireTls?: boolean | undefined;
  ignoreTls?: boolean | undefined;
  tlsOptions?: TlsOptions | undefined;
  baseUrl?: string | undefined;
  webhookUrl?: string | undefined;
  redirectUrl?: string | undefined;
  hmac?: boolean | undefined;
  serviceAccount?: string | undefined;
  ipPoolName?: string | undefined;
  apiKeyRequestHeader?: string | undefined;
  secretKeyRequestHeader?: string | undefined;
  idPath?: string | undefined;
  datePath?: string | undefined;
  apiToken?: string | undefined;
  authenticateByToken?: boolean | undefined;
  authenticationTokenKey?: string | undefined;
  instanceId?: string | undefined;
  alertUid?: string | undefined;
  title?: string | undefined;
  imageUrl?: string | undefined;
  state?: string | undefined;
  externalLink?: string | undefined;
  channelId?: string | undefined;
  phoneNumberIdentification?: string | undefined;
  accessKey?: string | undefined;
  appSid?: string | undefined;
  senderId?: string | undefined;
};

/** @internal */
export const TlsOptions$inboundSchema: z.ZodType<TlsOptions, z.ZodTypeDef, unknown> = z.object({});

/** @internal */
export type TlsOptions$Outbound = {};

/** @internal */
export const TlsOptions$outboundSchema: z.ZodType<TlsOptions$Outbound, z.ZodTypeDef, TlsOptions> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TlsOptions$ {
  /** @deprecated use `TlsOptions$inboundSchema` instead. */
  export const inboundSchema = TlsOptions$inboundSchema;
  /** @deprecated use `TlsOptions$outboundSchema` instead. */
  export const outboundSchema = TlsOptions$outboundSchema;
  /** @deprecated use `TlsOptions$Outbound` instead. */
  export type Outbound = TlsOptions$Outbound;
}

export function tlsOptionsToJSON(tlsOptions: TlsOptions): string {
  return JSON.stringify(TlsOptions$outboundSchema.parse(tlsOptions));
}

export function tlsOptionsFromJSON(jsonString: string): SafeParseResult<TlsOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TlsOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TlsOptions' from JSON`
  );
}

/** @internal */
export const CredentialsDto$inboundSchema: z.ZodType<CredentialsDto, z.ZodTypeDef, unknown> = z.object({
  apiKey: z.string().optional(),
  user: z.string().optional(),
  secretKey: z.string().optional(),
  domain: z.string().optional(),
  password: z.string().optional(),
  host: z.string().optional(),
  port: z.string().optional(),
  secure: z.boolean().optional(),
  region: z.string().optional(),
  accountSid: z.string().optional(),
  messageProfileId: z.string().optional(),
  token: z.string().optional(),
  from: z.string().optional(),
  senderName: z.string().optional(),
  projectName: z.string().optional(),
  applicationId: z.string().optional(),
  clientId: z.string().optional(),
  requireTls: z.boolean().optional(),
  ignoreTls: z.boolean().optional(),
  tlsOptions: z.lazy(() => TlsOptions$inboundSchema).optional(),
  baseUrl: z.string().optional(),
  webhookUrl: z.string().optional(),
  redirectUrl: z.string().optional(),
  hmac: z.boolean().optional(),
  serviceAccount: z.string().optional(),
  ipPoolName: z.string().optional(),
  apiKeyRequestHeader: z.string().optional(),
  secretKeyRequestHeader: z.string().optional(),
  idPath: z.string().optional(),
  datePath: z.string().optional(),
  apiToken: z.string().optional(),
  authenticateByToken: z.boolean().optional(),
  authenticationTokenKey: z.string().optional(),
  instanceId: z.string().optional(),
  alertUid: z.string().optional(),
  title: z.string().optional(),
  imageUrl: z.string().optional(),
  state: z.string().optional(),
  externalLink: z.string().optional(),
  channelId: z.string().optional(),
  phoneNumberIdentification: z.string().optional(),
  accessKey: z.string().optional(),
  appSid: z.string().optional(),
  senderId: z.string().optional(),
});

/** @internal */
export type CredentialsDto$Outbound = {
  apiKey?: string | undefined;
  user?: string | undefined;
  secretKey?: string | undefined;
  domain?: string | undefined;
  password?: string | undefined;
  host?: string | undefined;
  port?: string | undefined;
  secure?: boolean | undefined;
  region?: string | undefined;
  accountSid?: string | undefined;
  messageProfileId?: string | undefined;
  token?: string | undefined;
  from?: string | undefined;
  senderName?: string | undefined;
  projectName?: string | undefined;
  applicationId?: string | undefined;
  clientId?: string | undefined;
  requireTls?: boolean | undefined;
  ignoreTls?: boolean | undefined;
  tlsOptions?: TlsOptions$Outbound | undefined;
  baseUrl?: string | undefined;
  webhookUrl?: string | undefined;
  redirectUrl?: string | undefined;
  hmac?: boolean | undefined;
  serviceAccount?: string | undefined;
  ipPoolName?: string | undefined;
  apiKeyRequestHeader?: string | undefined;
  secretKeyRequestHeader?: string | undefined;
  idPath?: string | undefined;
  datePath?: string | undefined;
  apiToken?: string | undefined;
  authenticateByToken?: boolean | undefined;
  authenticationTokenKey?: string | undefined;
  instanceId?: string | undefined;
  alertUid?: string | undefined;
  title?: string | undefined;
  imageUrl?: string | undefined;
  state?: string | undefined;
  externalLink?: string | undefined;
  channelId?: string | undefined;
  phoneNumberIdentification?: string | undefined;
  accessKey?: string | undefined;
  appSid?: string | undefined;
  senderId?: string | undefined;
};

/** @internal */
export const CredentialsDto$outboundSchema: z.ZodType<CredentialsDto$Outbound, z.ZodTypeDef, CredentialsDto> = z.object(
  {
    apiKey: z.string().optional(),
    user: z.string().optional(),
    secretKey: z.string().optional(),
    domain: z.string().optional(),
    password: z.string().optional(),
    host: z.string().optional(),
    port: z.string().optional(),
    secure: z.boolean().optional(),
    region: z.string().optional(),
    accountSid: z.string().optional(),
    messageProfileId: z.string().optional(),
    token: z.string().optional(),
    from: z.string().optional(),
    senderName: z.string().optional(),
    projectName: z.string().optional(),
    applicationId: z.string().optional(),
    clientId: z.string().optional(),
    requireTls: z.boolean().optional(),
    ignoreTls: z.boolean().optional(),
    tlsOptions: z.lazy(() => TlsOptions$outboundSchema).optional(),
    baseUrl: z.string().optional(),
    webhookUrl: z.string().optional(),
    redirectUrl: z.string().optional(),
    hmac: z.boolean().optional(),
    serviceAccount: z.string().optional(),
    ipPoolName: z.string().optional(),
    apiKeyRequestHeader: z.string().optional(),
    secretKeyRequestHeader: z.string().optional(),
    idPath: z.string().optional(),
    datePath: z.string().optional(),
    apiToken: z.string().optional(),
    authenticateByToken: z.boolean().optional(),
    authenticationTokenKey: z.string().optional(),
    instanceId: z.string().optional(),
    alertUid: z.string().optional(),
    title: z.string().optional(),
    imageUrl: z.string().optional(),
    state: z.string().optional(),
    externalLink: z.string().optional(),
    channelId: z.string().optional(),
    phoneNumberIdentification: z.string().optional(),
    accessKey: z.string().optional(),
    appSid: z.string().optional(),
    senderId: z.string().optional(),
  }
);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CredentialsDto$ {
  /** @deprecated use `CredentialsDto$inboundSchema` instead. */
  export const inboundSchema = CredentialsDto$inboundSchema;
  /** @deprecated use `CredentialsDto$outboundSchema` instead. */
  export const outboundSchema = CredentialsDto$outboundSchema;
  /** @deprecated use `CredentialsDto$Outbound` instead. */
  export type Outbound = CredentialsDto$Outbound;
}

export function credentialsDtoToJSON(credentialsDto: CredentialsDto): string {
  return JSON.stringify(CredentialsDto$outboundSchema.parse(credentialsDto));
}

export function credentialsDtoFromJSON(jsonString: string): SafeParseResult<CredentialsDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CredentialsDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CredentialsDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - tlsOptionsToJSON(tlsOptions: TlsOptions)
 - tlsOptionsFromJSON(jsonString: string)
 - credentialsDtoToJSON(credentialsDto: CredentialsDto)
 - credentialsDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(TlsOptions$Outbound;
}

export function tlsOptionsToJSON(tlsOptions: TlsOptions): string {
  return ...)
 - Outbound(CredentialsDto$Outbound;
}

export function credentialsDtoToJSON(credentialsDto: CredentialsDto): st...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function tlsOptionsToJSON
- export function tlsOptionsFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function credentialsDtoToJSON
- export function credentialsDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/customcontroldto.ts
Tamaño: 1917 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export type CustomControlDto = {
  /**
   * Custom control values for the step.
   */
  custom?: { [k: string]: any } | undefined;
};

/** @internal */
export const CustomControlDto$inboundSchema: z.ZodType<CustomControlDto, z.ZodTypeDef, unknown> = z.object({
  custom: z.record(z.any()).optional(),
});

/** @internal */
export type CustomControlDto$Outbound = {
  custom?: { [k: string]: any } | undefined;
};

/** @internal */
export const CustomControlDto$outboundSchema: z.ZodType<CustomControlDto$Outbound, z.ZodTypeDef, CustomControlDto> =
  z.object({
    custom: z.record(z.any()).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CustomControlDto$ {
  /** @deprecated use `CustomControlDto$inboundSchema` instead. */
  export const inboundSchema = CustomControlDto$inboundSchema;
  /** @deprecated use `CustomControlDto$outboundSchema` instead. */
  export const outboundSchema = CustomControlDto$outboundSchema;
  /** @deprecated use `CustomControlDto$Outbound` instead. */
  export type Outbound = CustomControlDto$Outbound;
}

export function customControlDtoToJSON(customControlDto: CustomControlDto): string {
  return JSON.stringify(CustomControlDto$outboundSchema.parse(customControlDto));
}

export function customControlDtoFromJSON(jsonString: string): SafeParseResult<CustomControlDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CustomControlDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CustomControlDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - customControlDtoToJSON(customControlDto: CustomControlDto)
 - customControlDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(CustomControlDto$Outbound;
}

export function customControlDtoToJSON(customControlDto: CustomControl...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function customControlDtoToJSON
- export function customControlDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/customcontrolsmetadataresponsedto.ts
Tamaño: 3017 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  CustomControlDto,
  CustomControlDto$inboundSchema,
  CustomControlDto$Outbound,
  CustomControlDto$outboundSchema,
} from './customcontroldto.js';
import { UiSchema, UiSchema$inboundSchema, UiSchema$Outbound, UiSchema$outboundSchema } from './uischema.js';

export type CustomControlsMetadataResponseDto = {
  /**
   * JSON Schema for data
   */
  dataSchema?: { [k: string]: any } | undefined;
  /**
   * UI Schema for rendering
   */
  uiSchema?: UiSchema | undefined;
  /**
   * Control values specific to Custom step
   */
  values: CustomControlDto;
};

/** @internal */
export const CustomControlsMetadataResponseDto$inboundSchema: z.ZodType<
  CustomControlsMetadataResponseDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  dataSchema: z.record(z.any()).optional(),
  uiSchema: UiSchema$inboundSchema.optional(),
  values: CustomControlDto$inboundSchema,
});

/** @internal */
export type CustomControlsMetadataResponseDto$Outbound = {
  dataSchema?: { [k: string]: any } | undefined;
  uiSchema?: UiSchema$Outbound | undefined;
  values: CustomControlDto$Outbound;
};

/** @internal */
export const CustomControlsMetadataResponseDto$outboundSchema: z.ZodType<
  CustomControlsMetadataResponseDto$Outbound,
  z.ZodTypeDef,
  CustomControlsMetadataResponseDto
> = z.object({
  dataSchema: z.record(z.any()).optional(),
  uiSchema: UiSchema$outboundSchema.optional(),
  values: CustomControlDto$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CustomControlsMetadataResponseDto$ {
  /** @deprecated use `CustomControlsMetadataResponseDto$inboundSchema` instead. */
  export const inboundSchema = CustomControlsMetadataResponseDto$inboundSchema;
  /** @deprecated use `CustomControlsMetadataResponseDto$outboundSchema` instead. */
  export const outboundSchema = CustomControlsMetadataResponseDto$outboundSchema;
  /** @deprecated use `CustomControlsMetadataResponseDto$Outbound` instead. */
  export type Outbound = CustomControlsMetadataResponseDto$Outbound;
}

export function customControlsMetadataResponseDtoToJSON(
  customControlsMetadataResponseDto: CustomControlsMetadataResponseDto
): string {
  return JSON.stringify(CustomControlsMetadataResponseDto$outboundSchema.parse(customControlsMetadataResponseDto));
}

export function customControlsMetadataResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<CustomControlsMetadataResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CustomControlsMetadataResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CustomControlsMetadataResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - customControlsMetadataResponseDtoToJSON(customControlsMetadataResponseDto: CustomControlsMetadataResponseDto)
 - customControlsMetadataResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(CustomControlsMetadataResponseDto$Outbound;
}

export function customControlsMetadataResponseDtoToJS...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function customControlsMetadataResponseDtoToJSON
- export function customControlsMetadataResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/customstepresponsedto.ts
Tamaño: 7451 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { collectExtraKeys as collectExtraKeys$, safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  CustomControlsMetadataResponseDto,
  CustomControlsMetadataResponseDto$inboundSchema,
  CustomControlsMetadataResponseDto$Outbound,
  CustomControlsMetadataResponseDto$outboundSchema,
} from './customcontrolsmetadataresponsedto.js';
import {
  ResourceOriginEnum,
  ResourceOriginEnum$inboundSchema,
  ResourceOriginEnum$outboundSchema,
} from './resourceoriginenum.js';
import {
  StepIssuesDto,
  StepIssuesDto$inboundSchema,
  StepIssuesDto$Outbound,
  StepIssuesDto$outboundSchema,
} from './stepissuesdto.js';
import { StepTypeEnum, StepTypeEnum$inboundSchema, StepTypeEnum$outboundSchema } from './steptypeenum.js';

/**
 * Control values for the custom step
 */
export type CustomStepResponseDtoControlValues = {
  /**
   * Custom control values for the step.
   */
  custom?: { [k: string]: any } | undefined;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type CustomStepResponseDto = {
  /**
   * Controls metadata for the custom step
   */
  controls: CustomControlsMetadataResponseDto;
  /**
   * Control values for the custom step
   */
  controlValues?: CustomStepResponseDtoControlValues | undefined;
  /**
   * JSON Schema for variables, follows the JSON Schema standard
   */
  variables: { [k: string]: any };
  /**
   * Unique identifier of the step
   */
  stepId: string;
  /**
   * Database identifier of the step
   */
  id: string;
  /**
   * Name of the step
   */
  name: string;
  /**
   * Slug of the step
   */
  slug: string;
  /**
   * Type of the step
   */
  type: StepTypeEnum;
  /**
   * Origin of the layout
   */
  origin: ResourceOriginEnum;
  /**
   * Workflow identifier
   */
  workflowId: string;
  /**
   * Workflow database identifier
   */
  workflowDatabaseId: string;
  /**
   * Issues associated with the step
   */
  issues?: StepIssuesDto | undefined;
};

/** @internal */
export const CustomStepResponseDtoControlValues$inboundSchema: z.ZodType<
  CustomStepResponseDtoControlValues,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z
    .object({
      custom: z.record(z.any()).optional(),
    })
    .catchall(z.any()),
  'additionalProperties',
  true
);

/** @internal */
export type CustomStepResponseDtoControlValues$Outbound = {
  custom?: { [k: string]: any } | undefined;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const CustomStepResponseDtoControlValues$outboundSchema: z.ZodType<
  CustomStepResponseDtoControlValues$Outbound,
  z.ZodTypeDef,
  CustomStepResponseDtoControlValues
> = z
  .object({
    custom: z.record(z.any()).optional(),
    additionalProperties: z.record(z.any()).optional(),
  })
  .transform((v) => {
    return {
      ...v.additionalProperties,
      ...remap$(v, {
        additionalProperties: null,
      }),
    };
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CustomStepResponseDtoControlValues$ {
  /** @deprecated use `CustomStepResponseDtoControlValues$inboundSchema` instead. */
  export const inboundSchema = CustomStepResponseDtoControlValues$inboundSchema;
  /** @deprecated use `CustomStepResponseDtoControlValues$outboundSchema` instead. */
  export const outboundSchema = CustomStepResponseDtoControlValues$outboundSchema;
  /** @deprecated use `CustomStepResponseDtoControlValues$Outbound` instead. */
  export type Outbound = CustomStepResponseDtoControlValues$Outbound;
}

export function customStepResponseDtoControlValuesToJSON(
  customStepResponseDtoControlValues: CustomStepResponseDtoControlValues
): string {
  return JSON.stringify(CustomStepResponseDtoControlValues$outboundSchema.parse(customStepResponseDtoControlValues));
}

export function customStepResponseDtoControlValuesFromJSON(
  jsonString: string
): SafeParseResult<CustomStepResponseDtoControlValues, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CustomStepResponseDtoControlValues$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CustomStepResponseDtoControlValues' from JSON`
  );
}

/** @internal */
export const CustomStepResponseDto$inboundSchema: z.ZodType<CustomStepResponseDto, z.ZodTypeDef, unknown> = z
  .object({
    controls: CustomControlsMetadataResponseDto$inboundSchema,
    controlValues: z.lazy(() => CustomStepResponseDtoControlValues$inboundSchema).optional(),
    variables: z.record(z.any()),
    stepId: z.string(),
    _id: z.string(),
    name: z.string(),
    slug: z.string(),
    type: StepTypeEnum$inboundSchema,
    origin: ResourceOriginEnum$inboundSchema,
    workflowId: z.string(),
    workflowDatabaseId: z.string(),
    issues: StepIssuesDto$inboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type CustomStepResponseDto$Outbound = {
  controls: CustomControlsMetadataResponseDto$Outbound;
  controlValues?: CustomStepResponseDtoControlValues$Outbound | undefined;
  variables: { [k: string]: any };
  stepId: string;
  _id: string;
  name: string;
  slug: string;
  type: string;
  origin: string;
  workflowId: string;
  workflowDatabaseId: string;
  issues?: StepIssuesDto$Outbound | undefined;
};

/** @internal */
export const CustomStepResponseDto$outboundSchema: z.ZodType<
  CustomStepResponseDto$Outbound,
  z.ZodTypeDef,
  CustomStepResponseDto
> = z
  .object({
    controls: CustomControlsMetadataResponseDto$outboundSchema,
    controlValues: z.lazy(() => CustomStepResponseDtoControlValues$outboundSchema).optional(),
    variables: z.record(z.any()),
    stepId: z.string(),
    id: z.string(),
    name: z.string(),
    slug: z.string(),
    type: StepTypeEnum$outboundSchema,
    origin: ResourceOriginEnum$outboundSchema,
    workflowId: z.string(),
    workflowDatabaseId: z.string(),
    issues: StepIssuesDto$outboundSchema.optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CustomStepResponseDto$ {
  /** @deprecated use `CustomStepResponseDto$inboundSchema` instead. */
  export const inboundSchema = CustomStepResponseDto$inboundSchema;
  /** @deprecated use `CustomStepResponseDto$outboundSchema` instead. */
  export const outboundSchema = CustomStepResponseDto$outboundSchema;
  /** @deprecated use `CustomStepResponseDto$Outbound` instead. */
  export type Outbound = CustomStepResponseDto$Outbound;
}

export function customStepResponseDtoToJSON(customStepResponseDto: CustomStepResponseDto): string {
  return JSON.stringify(CustomStepResponseDto$outboundSchema.parse(customStepResponseDto));
}

export function customStepResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<CustomStepResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CustomStepResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CustomStepResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - customStepResponseDtoControlValuesToJSON(customStepResponseDtoControlValues: CustomStepResponseDtoControlValues)
 - customStepResponseDtoControlValuesFromJSON(jsonString: string)
 - customStepResponseDtoToJSON(customStepResponseDto: CustomStepResponseDto)
 - customStepResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(CustomStepResponseDtoControlValues$Outbound;
}

export function customStepResponseDtoControlValuesTo...)
 - Outbound(CustomStepResponseDto$Outbound;
}

export function customStepResponseDtoToJSON(customStepResponseDto...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function customStepResponseDtoControlValuesToJSON
- export function customStepResponseDtoControlValuesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function customStepResponseDtoToJSON
- export function customStepResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/customstepupsertdto.ts
Tamaño: 5309 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { remap as remap$ } from '../../lib/primitives.js';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  CustomControlDto,
  CustomControlDto$inboundSchema,
  CustomControlDto$Outbound,
  CustomControlDto$outboundSchema,
} from './customcontroldto.js';
import { StepTypeEnum, StepTypeEnum$inboundSchema, StepTypeEnum$outboundSchema } from './steptypeenum.js';

/**
 * Control values for the Custom step.
 */
export type CustomStepUpsertDtoControlValues =
  | CustomControlDto
  | {
      [k: string]: any;
    };

export type CustomStepUpsertDto = {
  /**
   * Database identifier of the step. Used for updating the step.
   */
  id?: string | undefined;
  /**
   * Unique identifier for the step
   */
  stepId?: string | undefined;
  /**
   * Name of the step
   */
  name: string;
  /**
   * Type of the step
   */
  type: StepTypeEnum;
  /**
   * Control values for the Custom step.
   */
  controlValues?: CustomControlDto | { [k: string]: any } | undefined;
};

/** @internal */
export const CustomStepUpsertDtoControlValues$inboundSchema: z.ZodType<
  CustomStepUpsertDtoControlValues,
  z.ZodTypeDef,
  unknown
> = z.union([CustomControlDto$inboundSchema, z.record(z.any())]);

/** @internal */
export type CustomStepUpsertDtoControlValues$Outbound = CustomControlDto$Outbound | { [k: string]: any };

/** @internal */
export const CustomStepUpsertDtoControlValues$outboundSchema: z.ZodType<
  CustomStepUpsertDtoControlValues$Outbound,
  z.ZodTypeDef,
  CustomStepUpsertDtoControlValues
> = z.union([CustomControlDto$outboundSchema, z.record(z.any())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CustomStepUpsertDtoControlValues$ {
  /** @deprecated use `CustomStepUpsertDtoControlValues$inboundSchema` instead. */
  export const inboundSchema = CustomStepUpsertDtoControlValues$inboundSchema;
  /** @deprecated use `CustomStepUpsertDtoControlValues$outboundSchema` instead. */
  export const outboundSchema = CustomStepUpsertDtoControlValues$outboundSchema;
  /** @deprecated use `CustomStepUpsertDtoControlValues$Outbound` instead. */
  export type Outbound = CustomStepUpsertDtoControlValues$Outbound;
}

export function customStepUpsertDtoControlValuesToJSON(
  customStepUpsertDtoControlValues: CustomStepUpsertDtoControlValues
): string {
  return JSON.stringify(CustomStepUpsertDtoControlValues$outboundSchema.parse(customStepUpsertDtoControlValues));
}

export function customStepUpsertDtoControlValuesFromJSON(
  jsonString: string
): SafeParseResult<CustomStepUpsertDtoControlValues, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CustomStepUpsertDtoControlValues$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CustomStepUpsertDtoControlValues' from JSON`
  );
}

/** @internal */
export const CustomStepUpsertDto$inboundSchema: z.ZodType<CustomStepUpsertDto, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().optional(),
    stepId: z.string().optional(),
    name: z.string(),
    type: StepTypeEnum$inboundSchema,
    controlValues: z.union([CustomControlDto$inboundSchema, z.record(z.any())]).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      _id: 'id',
    });
  });

/** @internal */
export type CustomStepUpsertDto$Outbound = {
  _id?: string | undefined;
  stepId?: string | undefined;
  name: string;
  type: string;
  controlValues?: CustomControlDto$Outbound | { [k: string]: any } | undefined;
};

/** @internal */
export const CustomStepUpsertDto$outboundSchema: z.ZodType<
  CustomStepUpsertDto$Outbound,
  z.ZodTypeDef,
  CustomStepUpsertDto
> = z
  .object({
    id: z.string().optional(),
    stepId: z.string().optional(),
    name: z.string(),
    type: StepTypeEnum$outboundSchema,
    controlValues: z.union([CustomControlDto$outboundSchema, z.record(z.any())]).optional(),
  })
  .transform((v) => {
    return remap$(v, {
      id: '_id',
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CustomStepUpsertDto$ {
  /** @deprecated use `CustomStepUpsertDto$inboundSchema` instead. */
  export const inboundSchema = CustomStepUpsertDto$inboundSchema;
  /** @deprecated use `CustomStepUpsertDto$outboundSchema` instead. */
  export const outboundSchema = CustomStepUpsertDto$outboundSchema;
  /** @deprecated use `CustomStepUpsertDto$Outbound` instead. */
  export type Outbound = CustomStepUpsertDto$Outbound;
}

export function customStepUpsertDtoToJSON(customStepUpsertDto: CustomStepUpsertDto): string {
  return JSON.stringify(CustomStepUpsertDto$outboundSchema.parse(customStepUpsertDto));
}

export function customStepUpsertDtoFromJSON(
  jsonString: string
): SafeParseResult<CustomStepUpsertDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CustomStepUpsertDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CustomStepUpsertDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - customStepUpsertDtoControlValuesToJSON(customStepUpsertDtoControlValues: CustomStepUpsertDtoControlValues)
 - customStepUpsertDtoControlValuesFromJSON(jsonString: string)
 - customStepUpsertDtoToJSON(customStepUpsertDto: CustomStepUpsertDto)
 - customStepUpsertDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(CustomStepUpsertDtoControlValues$Outbound;
}

export function customStepUpsertDtoControlValuesToJSON...)
 - Outbound(CustomStepUpsertDto$Outbound;
}

export function customStepUpsertDtoToJSON(customStepUpsertDto: Cust...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function customStepUpsertDtoControlValuesToJSON
- export function customStepUpsertDtoControlValuesFromJSON
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function customStepUpsertDtoToJSON
- export function customStepUpsertDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/delaycontroldto.ts
Tamaño: 4656 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

/**
 * Type of the delay. Currently only 'regular' is supported by the schema.
 */
export const Type = {
  Regular: 'regular',
  Timed: 'timed',
} as const;
/**
 * Type of the delay. Currently only 'regular' is supported by the schema.
 */
export type Type = ClosedEnum<typeof Type>;

/**
 * Unit of time for the delay amount.
 */
export const Unit = {
  Seconds: 'seconds',
  Minutes: 'minutes',
  Hours: 'hours',
  Days: 'days',
  Weeks: 'weeks',
  Months: 'months',
} as const;
/**
 * Unit of time for the delay amount.
 */
export type Unit = ClosedEnum<typeof Unit>;

export type DelayControlDto = {
  /**
   * JSONLogic filter conditions for conditionally skipping the step execution. Supports complex logical operations with AND, OR, and comparison operators. See https://jsonlogic.com/ for full typing reference.
   */
  skip?: { [k: string]: any } | undefined;
  /**
   * Type of the delay. Currently only 'regular' is supported by the schema.
   */
  type?: Type | undefined;
  /**
   * Amount of time to delay.
   */
  amount?: number | undefined;
  /**
   * Unit of time for the delay amount.
   */
  unit?: Unit | undefined;
  /**
   * Cron expression for the delay. Min length 1.
   */
  cron?: string | undefined;
};

/** @internal */
export const Type$inboundSchema: z.ZodNativeEnum<typeof Type> = z.nativeEnum(Type);

/** @internal */
export const Type$outboundSchema: z.ZodNativeEnum<typeof Type> = Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Type$ {
  /** @deprecated use `Type$inboundSchema` instead. */
  export const inboundSchema = Type$inboundSchema;
  /** @deprecated use `Type$outboundSchema` instead. */
  export const outboundSchema = Type$outboundSchema;
}

/** @internal */
export const Unit$inboundSchema: z.ZodNativeEnum<typeof Unit> = z.nativeEnum(Unit);

/** @internal */
export const Unit$outboundSchema: z.ZodNativeEnum<typeof Unit> = Unit$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Unit$ {
  /** @deprecated use `Unit$inboundSchema` instead. */
  export const inboundSchema = Unit$inboundSchema;
  /** @deprecated use `Unit$outboundSchema` instead. */
  export const outboundSchema = Unit$outboundSchema;
}

/** @internal */
export const DelayControlDto$inboundSchema: z.ZodType<DelayControlDto, z.ZodTypeDef, unknown> = z.object({
  skip: z.record(z.any()).optional(),
  type: Type$inboundSchema.default('regular'),
  amount: z.number().optional(),
  unit: Unit$inboundSchema.optional(),
  cron: z.string().optional(),
});

/** @internal */
export type DelayControlDto$Outbound = {
  skip?: { [k: string]: any } | undefined;
  type: string;
  amount?: number | undefined;
  unit?: string | undefined;
  cron?: string | undefined;
};

/** @internal */
export const DelayControlDto$outboundSchema: z.ZodType<DelayControlDto$Outbound, z.ZodTypeDef, DelayControlDto> =
  z.object({
    skip: z.record(z.any()).optional(),
    type: Type$outboundSchema.default('regular'),
    amount: z.number().optional(),
    unit: Unit$outboundSchema.optional(),
    cron: z.string().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DelayControlDto$ {
  /** @deprecated use `DelayControlDto$inboundSchema` instead. */
  export const inboundSchema = DelayControlDto$inboundSchema;
  /** @deprecated use `DelayControlDto$outboundSchema` instead. */
  export const outboundSchema = DelayControlDto$outboundSchema;
  /** @deprecated use `DelayControlDto$Outbound` instead. */
  export type Outbound = DelayControlDto$Outbound;
}

export function delayControlDtoToJSON(delayControlDto: DelayControlDto): string {
  return JSON.stringify(DelayControlDto$outboundSchema.parse(delayControlDto));
}

export function delayControlDtoFromJSON(jsonString: string): SafeParseResult<DelayControlDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DelayControlDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DelayControlDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - delayControlDtoToJSON(delayControlDto: DelayControlDto)
 - delayControlDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(DelayControlDto$Outbound;
}

export function delayControlDtoToJSON(delayControlDto: DelayControlDto)...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function delayControlDtoToJSON
- export function delayControlDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/delaycontrolsmetadataresponsedto.ts
Tamaño: 2979 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';
import {
  DelayControlDto,
  DelayControlDto$inboundSchema,
  DelayControlDto$Outbound,
  DelayControlDto$outboundSchema,
} from './delaycontroldto.js';
import { UiSchema, UiSchema$inboundSchema, UiSchema$Outbound, UiSchema$outboundSchema } from './uischema.js';

export type DelayControlsMetadataResponseDto = {
  /**
   * JSON Schema for data
   */
  dataSchema?: { [k: string]: any } | undefined;
  /**
   * UI Schema for rendering
   */
  uiSchema?: UiSchema | undefined;
  /**
   * Control values specific to Delay
   */
  values: DelayControlDto;
};

/** @internal */
export const DelayControlsMetadataResponseDto$inboundSchema: z.ZodType<
  DelayControlsMetadataResponseDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  dataSchema: z.record(z.any()).optional(),
  uiSchema: UiSchema$inboundSchema.optional(),
  values: DelayControlDto$inboundSchema,
});

/** @internal */
export type DelayControlsMetadataResponseDto$Outbound = {
  dataSchema?: { [k: string]: any } | undefined;
  uiSchema?: UiSchema$Outbound | undefined;
  values: DelayControlDto$Outbound;
};

/** @internal */
export const DelayControlsMetadataResponseDto$outboundSchema: z.ZodType<
  DelayControlsMetadataResponseDto$Outbound,
  z.ZodTypeDef,
  DelayControlsMetadataResponseDto
> = z.object({
  dataSchema: z.record(z.any()).optional(),
  uiSchema: UiSchema$outboundSchema.optional(),
  values: DelayControlDto$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DelayControlsMetadataResponseDto$ {
  /** @deprecated use `DelayControlsMetadataResponseDto$inboundSchema` instead. */
  export const inboundSchema = DelayControlsMetadataResponseDto$inboundSchema;
  /** @deprecated use `DelayControlsMetadataResponseDto$outboundSchema` instead. */
  export const outboundSchema = DelayControlsMetadataResponseDto$outboundSchema;
  /** @deprecated use `DelayControlsMetadataResponseDto$Outbound` instead. */
  export type Outbound = DelayControlsMetadataResponseDto$Outbound;
}

export function delayControlsMetadataResponseDtoToJSON(
  delayControlsMetadataResponseDto: DelayControlsMetadataResponseDto
): string {
  return JSON.stringify(DelayControlsMetadataResponseDto$outboundSchema.parse(delayControlsMetadataResponseDto));
}

export function delayControlsMetadataResponseDtoFromJSON(
  jsonString: string
): SafeParseResult<DelayControlsMetadataResponseDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DelayControlsMetadataResponseDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DelayControlsMetadataResponseDto' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - delayControlsMetadataResponseDtoToJSON(delayControlsMetadataResponseDto: DelayControlsMetadataResponseDto)
 - delayControlsMetadataResponseDtoFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(DelayControlsMetadataResponseDto$Outbound;
}

export function delayControlsMetadataResponseDtoToJSON...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function delayControlsMetadataResponseDtoToJSON
- export function delayControlsMetadataResponseDtoFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/delayregularmetadata.ts
Tamaño: 4381 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export const DelayRegularMetadataUnit = {
  Seconds: 'seconds',
  Minutes: 'minutes',
  Hours: 'hours',
  Days: 'days',
  Weeks: 'weeks',
  Months: 'months',
} as const;
export type DelayRegularMetadataUnit = ClosedEnum<typeof DelayRegularMetadataUnit>;

export const DelayRegularMetadataType = {
  Regular: 'regular',
} as const;
export type DelayRegularMetadataType = ClosedEnum<typeof DelayRegularMetadataType>;

export type DelayRegularMetadata = {
  amount?: number | undefined;
  unit?: DelayRegularMetadataUnit | undefined;
  type: DelayRegularMetadataType;
};

/** @internal */
export const DelayRegularMetadataUnit$inboundSchema: z.ZodNativeEnum<typeof DelayRegularMetadataUnit> =
  z.nativeEnum(DelayRegularMetadataUnit);

/** @internal */
export const DelayRegularMetadataUnit$outboundSchema: z.ZodNativeEnum<typeof DelayRegularMetadataUnit> =
  DelayRegularMetadataUnit$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DelayRegularMetadataUnit$ {
  /** @deprecated use `DelayRegularMetadataUnit$inboundSchema` instead. */
  export const inboundSchema = DelayRegularMetadataUnit$inboundSchema;
  /** @deprecated use `DelayRegularMetadataUnit$outboundSchema` instead. */
  export const outboundSchema = DelayRegularMetadataUnit$outboundSchema;
}

/** @internal */
export const DelayRegularMetadataType$inboundSchema: z.ZodNativeEnum<typeof DelayRegularMetadataType> =
  z.nativeEnum(DelayRegularMetadataType);

/** @internal */
export const DelayRegularMetadataType$outboundSchema: z.ZodNativeEnum<typeof DelayRegularMetadataType> =
  DelayRegularMetadataType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DelayRegularMetadataType$ {
  /** @deprecated use `DelayRegularMetadataType$inboundSchema` instead. */
  export const inboundSchema = DelayRegularMetadataType$inboundSchema;
  /** @deprecated use `DelayRegularMetadataType$outboundSchema` instead. */
  export const outboundSchema = DelayRegularMetadataType$outboundSchema;
}

/** @internal */
export const DelayRegularMetadata$inboundSchema: z.ZodType<DelayRegularMetadata, z.ZodTypeDef, unknown> = z.object({
  amount: z.number().optional(),
  unit: DelayRegularMetadataUnit$inboundSchema.optional(),
  type: DelayRegularMetadataType$inboundSchema,
});

/** @internal */
export type DelayRegularMetadata$Outbound = {
  amount?: number | undefined;
  unit?: string | undefined;
  type: string;
};

/** @internal */
export const DelayRegularMetadata$outboundSchema: z.ZodType<
  DelayRegularMetadata$Outbound,
  z.ZodTypeDef,
  DelayRegularMetadata
> = z.object({
  amount: z.number().optional(),
  unit: DelayRegularMetadataUnit$outboundSchema.optional(),
  type: DelayRegularMetadataType$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DelayRegularMetadata$ {
  /** @deprecated use `DelayRegularMetadata$inboundSchema` instead. */
  export const inboundSchema = DelayRegularMetadata$inboundSchema;
  /** @deprecated use `DelayRegularMetadata$outboundSchema` instead. */
  export const outboundSchema = DelayRegularMetadata$outboundSchema;
  /** @deprecated use `DelayRegularMetadata$Outbound` instead. */
  export type Outbound = DelayRegularMetadata$Outbound;
}

export function delayRegularMetadataToJSON(delayRegularMetadata: DelayRegularMetadata): string {
  return JSON.stringify(DelayRegularMetadata$outboundSchema.parse(delayRegularMetadata));
}

export function delayRegularMetadataFromJSON(
  jsonString: string
): SafeParseResult<DelayRegularMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DelayRegularMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DelayRegularMetadata' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - delayRegularMetadataToJSON(delayRegularMetadata: DelayRegularMetadata)
 - delayRegularMetadataFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(DelayRegularMetadata$Outbound;
}

export function delayRegularMetadataToJSON(delayRegularMetadata: D...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function delayRegularMetadataToJSON
- export function delayRegularMetadataFromJSON

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/libs/internal-sdk/src/models/components/delayscheduledmetadata.ts
Tamaño: 3153 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from 'zod/v3';
import { safeParse } from '../../lib/schemas.js';
import { ClosedEnum } from '../../types/enums.js';
import { Result as SafeParseResult } from '../../types/fp.js';
import { SDKValidationError } from '../errors/sdkvalidationerror.js';

export const DelayScheduledMetadataType = {
  Scheduled: 'scheduled',
} as const;
export type DelayScheduledMetadataType = ClosedEnum<typeof DelayScheduledMetadataType>;

export type DelayScheduledMetadata = {
  type: DelayScheduledMetadataType;
  delayPath: string;
};

/** @internal */
export const DelayScheduledMetadataType$inboundSchema: z.ZodNativeEnum<typeof DelayScheduledMetadataType> =
  z.nativeEnum(DelayScheduledMetadataType);

/** @internal */
export const DelayScheduledMetadataType$outboundSchema: z.ZodNativeEnum<typeof DelayScheduledMetadataType> =
  DelayScheduledMetadataType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DelayScheduledMetadataType$ {
  /** @deprecated use `DelayScheduledMetadataType$inboundSchema` instead. */
  export const inboundSchema = DelayScheduledMetadataType$inboundSchema;
  /** @deprecated use `DelayScheduledMetadataType$outboundSchema` instead. */
  export const outboundSchema = DelayScheduledMetadataType$outboundSchema;
}

/** @internal */
export const DelayScheduledMetadata$inboundSchema: z.ZodType<DelayScheduledMetadata, z.ZodTypeDef, unknown> = z.object({
  type: DelayScheduledMetadataType$inboundSchema,
  delayPath: z.string(),
});

/** @internal */
export type DelayScheduledMetadata$Outbound = {
  type: string;
  delayPath: string;
};

/** @internal */
export const DelayScheduledMetadata$outboundSchema: z.ZodType<
  DelayScheduledMetadata$Outbound,
  z.ZodTypeDef,
  DelayScheduledMetadata
> = z.object({
  type: DelayScheduledMetadataType$outboundSchema,
  delayPath: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DelayScheduledMetadata$ {
  /** @deprecated use `DelayScheduledMetadata$inboundSchema` instead. */
  export const inboundSchema = DelayScheduledMetadata$inboundSchema;
  /** @deprecated use `DelayScheduledMetadata$outboundSchema` instead. */
  export const outboundSchema = DelayScheduledMetadata$outboundSchema;
  /** @deprecated use `DelayScheduledMetadata$Outbound` instead. */
  export type Outbound = DelayScheduledMetadata$Outbound;
}

export function delayScheduledMetadataToJSON(delayScheduledMetadata: DelayScheduledMetadata): string {
  return JSON.stringify(DelayScheduledMetadata$outboundSchema.parse(delayScheduledMetadata));
}

export function delayScheduledMetadataFromJSON(
  jsonString: string
): SafeParseResult<DelayScheduledMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DelayScheduledMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DelayScheduledMetadata' from JSON`
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - delayScheduledMetadataToJSON(delayScheduledMetadata: DelayScheduledMetadata)
 - delayScheduledMetadataFromJSON(jsonString: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - Outbound(DelayScheduledMetadata$Outbound;
}

export function delayScheduledMetadataToJSON(delayScheduledMetad...)
Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type
- export  const
- export  const
- export  namespace
- export  const
- export  const
- export  const
- export  type
- export  const
- export  namespace
- export  const
- export  const
- export  type
- export function delayScheduledMetadataToJSON
- export function delayScheduledMetadataFromJSON

