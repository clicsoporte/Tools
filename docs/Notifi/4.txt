

### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - useCase(moduleRef.get<GetApiRateLimitAlgorithmConfig>(GetApiRateLimitAlgorithmConfig);
  });

  it('should u...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/rate-limiting/usecases/get-api-rate-limit-algorithm-config/get-api-rate-limit-algorithm-config.usecase.ts
Tamaño: 1230 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import {
  ApiRateLimitAlgorithmEnum,
  ApiRateLimitAlgorithmEnvVarFormat,
  DEFAULT_API_RATE_LIMIT_ALGORITHM_CONFIG,
  IApiRateLimitAlgorithm,
} from '@novu/shared';

@Injectable()
export class GetApiRateLimitAlgorithmConfig {
  public default: IApiRateLimitAlgorithm;

  constructor() {
    this.loadDefault();
  }

  public loadDefault(): void {
    this.default = this.createDefault();
  }

  private createDefault(): IApiRateLimitAlgorithm {
    const mergedConfig: IApiRateLimitAlgorithm = { ...DEFAULT_API_RATE_LIMIT_ALGORITHM_CONFIG };

    // Read process environment only once for performance
    const processEnv = process.env;

    Object.values(ApiRateLimitAlgorithmEnum).forEach((algorithmOption) => {
      const envVarName = this.getEnvVarName(algorithmOption);
      const envVarValue = processEnv[envVarName];

      if (envVarValue) {
        mergedConfig[algorithmOption] = Number(envVarValue);
      }
    });

    return mergedConfig;
  }

  private getEnvVarName(algorithmOption: ApiRateLimitAlgorithmEnum): ApiRateLimitAlgorithmEnvVarFormat {
    return `API_RATE_LIMIT_ALGORITHM_${algorithmOption.toUpperCase() as Uppercase<ApiRateLimitAlgorithmEnum>}`;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - processEnv(process.env;

    Object.values(ApiRateLimitAlgorithmEnum).forEach((algorithmOption))
Declaraciones 'export' encontradas:
- export class GetApiRateLimitAlgorithmConfig

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/rate-limiting/usecases/get-api-rate-limit-algorithm-config/index.ts
Tamaño: 63 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './get-api-rate-limit-algorithm-config.usecase';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/rate-limiting/usecases/get-api-rate-limit-cost-config/get-api-rate-limit-cost-config.spec.ts
Tamaño: 1525 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Test } from '@nestjs/testing';
import { ApiRateLimitCostEnum, ApiRateLimitCostEnvVarFormat, DEFAULT_API_RATE_LIMIT_COST_CONFIG } from '@novu/shared';
import { expect } from 'chai';
import { GetApiRateLimitCostConfig } from './get-api-rate-limit-cost-config.usecase';

describe('GetApiRateLimitCostConfig', () => {
  let useCase: GetApiRateLimitCostConfig;

  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      providers: [GetApiRateLimitCostConfig],
    }).compile();

    useCase = moduleRef.get<GetApiRateLimitCostConfig>(GetApiRateLimitCostConfig);
  });

  it('should use the default rate limit cost configuration when no environment variables are set', () => {
    expect(useCase.default).to.deep.equal(DEFAULT_API_RATE_LIMIT_COST_CONFIG);
  });

  it('should override default rate limit cost configuration with environment variables', () => {
    const mockOverrideBulkCost = 15;
    const mockApiRateLimitConfigurationKey = ApiRateLimitCostEnum.BULK;

    const envVarName: ApiRateLimitCostEnvVarFormat = `API_RATE_LIMIT_COST_${
      mockApiRateLimitConfigurationKey.toUpperCase() as Uppercase<ApiRateLimitCostEnum>
    }`;
    process.env[envVarName] = `${mockOverrideBulkCost}`;

    // Re-initialize the defaultApiRateLimits after setting the environment variable
    useCase.loadDefault();
    const result = useCase.default;

    expect(result[mockApiRateLimitConfigurationKey]).to.equal(mockOverrideBulkCost);
    delete process.env[envVarName]; // cleanup
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - useCase(moduleRef.get<GetApiRateLimitCostConfig>(GetApiRateLimitCostConfig);
  });

  it('should use the def...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/rate-limiting/usecases/get-api-rate-limit-cost-config/get-api-rate-limit-cost-config.usecase.ts
Tamaño: 1135 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import {
  ApiRateLimitCostEnum,
  ApiRateLimitCostEnvVarFormat,
  DEFAULT_API_RATE_LIMIT_COST_CONFIG,
  IApiRateLimitCost,
} from '@novu/shared';

@Injectable()
export class GetApiRateLimitCostConfig {
  public default: IApiRateLimitCost;

  constructor() {
    this.loadDefault();
  }

  public loadDefault(): void {
    this.default = this.createDefault();
  }

  private createDefault(): IApiRateLimitCost {
    const mergedConfig: IApiRateLimitCost = { ...DEFAULT_API_RATE_LIMIT_COST_CONFIG };

    // Read process environment only once for performance
    const processEnv = process.env;

    Object.values(ApiRateLimitCostEnum).forEach((costOption) => {
      const envVarName = this.getEnvVarName(costOption);
      const envVarValue = processEnv[envVarName];

      if (envVarValue) {
        mergedConfig[costOption] = Number(envVarValue);
      }
    });

    return mergedConfig;
  }

  private getEnvVarName(costOption: ApiRateLimitCostEnum): ApiRateLimitCostEnvVarFormat {
    return `API_RATE_LIMIT_COST_${costOption.toUpperCase() as Uppercase<ApiRateLimitCostEnum>}`;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - processEnv(process.env;

    Object.values(ApiRateLimitCostEnum).forEach((costOption))
Declaraciones 'export' encontradas:
- export class GetApiRateLimitCostConfig

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/rate-limiting/usecases/get-api-rate-limit-cost-config/index.ts
Tamaño: 58 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './get-api-rate-limit-cost-config.usecase';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/rate-limiting/usecases/get-api-rate-limit-maximum/get-api-rate-limit-maximum.command.ts
Tamaño: 365 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiRateLimitCategoryEnum } from '@novu/shared';
import { IsDefined, IsEnum } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';

export class GetApiRateLimitMaximumCommand extends EnvironmentCommand {
  @IsDefined()
  @IsEnum(ApiRateLimitCategoryEnum)
  apiRateLimitCategory: ApiRateLimitCategoryEnum;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetApiRateLimitMaximumCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/rate-limiting/usecases/get-api-rate-limit-maximum/get-api-rate-limit-maximum.dto.ts
Tamaño: 384 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiServiceLevelEnum } from '@novu/shared';

export const CUSTOM_API_SERVICE_LEVEL = 'custom';

export type ApiServiceLevel = ApiServiceLevelEnum | typeof CUSTOM_API_SERVICE_LEVEL;

// Array type to keep the cached entity as small as possible for more performant caching
export type GetApiRateLimitMaximumDto = [apiRateLimitMaximum: number, apiServiceLevel: ApiServiceLevel];


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/rate-limiting/usecases/get-api-rate-limit-maximum/get-api-rate-limit-maximum.spec.ts
Tamaño: 8012 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Test } from '@nestjs/testing';
import { CacheService, MockCacheService } from '@novu/application-generic';
import { CommunityOrganizationRepository, EnvironmentRepository } from '@novu/dal';
import {
  ApiRateLimitCategoryEnum,
  ApiRateLimitCategoryToFeatureName,
  ApiServiceLevelEnum,
  FeatureFlagsKeysEnum,
  getFeatureForTierAsNumber,
} from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import sinon from 'sinon';
import { SharedModule } from '../../../shared/shared.module';
import { RateLimitingModule } from '../../rate-limiting.module';
import { CUSTOM_API_SERVICE_LEVEL } from './get-api-rate-limit-maximum.dto';
import { GetApiRateLimitMaximum, GetApiRateLimitMaximumCommand } from './index';

const mockDefaultApiRateLimits = {
  [ApiServiceLevelEnum.FREE]: {
    [ApiRateLimitCategoryEnum.GLOBAL]: 60,
    [ApiRateLimitCategoryEnum.TRIGGER]: 60,
    [ApiRateLimitCategoryEnum.CONFIGURATION]: 60,
  },
  [ApiServiceLevelEnum.UNLIMITED]: {
    [ApiRateLimitCategoryEnum.GLOBAL]: 600,
    [ApiRateLimitCategoryEnum.TRIGGER]: 600,
    [ApiRateLimitCategoryEnum.CONFIGURATION]: 600,
  },
};

describe('GetApiRateLimitMaximum', async () => {
  let useCase: GetApiRateLimitMaximum;
  let session: UserSession;
  let organizationRepository: CommunityOrganizationRepository;
  let environmentRepository: EnvironmentRepository;

  let findOneEnvironmentStub: sinon.SinonStub;
  let findOneOrganizationStub: sinon.SinonStub;

  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [SharedModule, RateLimitingModule],
      providers: [],
    })
      .overrideProvider(CacheService)
      .useValue(MockCacheService.createClient())
      .compile();
    await moduleRef.init(); // Trigger OnModuleInit

    session = new UserSession();
    await session.initialize();

    useCase = moduleRef.get<GetApiRateLimitMaximum>(GetApiRateLimitMaximum);
    organizationRepository = moduleRef.get<CommunityOrganizationRepository>(CommunityOrganizationRepository);
    environmentRepository = moduleRef.get<EnvironmentRepository>(EnvironmentRepository);

    findOneEnvironmentStub = sinon.stub(environmentRepository, 'findOne');
    findOneOrganizationStub = sinon.stub(organizationRepository, 'findById');
  });

  afterEach(() => {
    findOneEnvironmentStub.restore();
    findOneOrganizationStub.restore();
  });

  it('should throw error when environment is not found', async () => {
    findOneEnvironmentStub.resolves(undefined);

    try {
      await useCase.execute(
        GetApiRateLimitMaximumCommand.create({
          organizationId: session.organization._id,
          environmentId: session.environment._id,
          apiRateLimitCategory: ApiRateLimitCategoryEnum.GLOBAL,
        })
      );
      throw new Error('Should not reach here');
    } catch (e) {
      expect(e.message).to.equal(`Environment id: ${session.environment._id} not found`);
    }
  });

  describe('Environment DOES have rate limits specified', () => {
    const mockGlobalLimit = 65;
    const mockApiRateLimitCategory = ApiRateLimitCategoryEnum.GLOBAL;

    beforeEach(() => {
      findOneEnvironmentStub.resolves({
        apiRateLimits: {
          [mockApiRateLimitCategory]: mockGlobalLimit,
        },
      });
    });

    it('should return api rate limit for the category set on environment', async () => {
      const [rateLimit] = await useCase.execute(
        GetApiRateLimitMaximumCommand.create({
          organizationId: session.organization._id,
          environmentId: session.environment._id,
          apiRateLimitCategory: mockApiRateLimitCategory,
        })
      );

      expect(rateLimit).to.equal(mockGlobalLimit);
    });

    it('should return api service level of CUSTOM', async () => {
      const [, apiServiceLevel] = await useCase.execute(
        GetApiRateLimitMaximumCommand.create({
          organizationId: session.organization._id,
          environmentId: session.environment._id,
          apiRateLimitCategory: mockApiRateLimitCategory,
        })
      );

      expect(apiServiceLevel).to.equal(CUSTOM_API_SERVICE_LEVEL);
    });
  });

  describe('Environment DOES NOT have rate limits specified', () => {
    const mockApiRateLimitCategory = ApiRateLimitCategoryEnum.GLOBAL;

    beforeEach(() => {
      findOneEnvironmentStub.resolves({
        apiRateLimits: undefined,
      });
    });

    describe('Organization DOES have api service level specified', () => {
      const mockApiServiceLevel = ApiServiceLevelEnum.FREE;

      beforeEach(() => {
        findOneOrganizationStub.resolves({
          apiServiceLevel: mockApiServiceLevel,
        });
      });

      it('should return default api rate limit for the organizations apiServiceLevel when apiServiceLevel IS set on organization', async () => {
        const defaultApiRateLimit = getFeatureForTierAsNumber(
          ApiRateLimitCategoryToFeatureName[mockApiRateLimitCategory],
          mockApiServiceLevel,
          false
        );
        const [rateLimit] = await useCase.execute(
          GetApiRateLimitMaximumCommand.create({
            organizationId: session.organization._id,
            environmentId: session.environment._id,
            apiRateLimitCategory: mockApiRateLimitCategory,
          })
        );

        expect(rateLimit).to.equal(defaultApiRateLimit);
      });

      it('should return the api service level set on organization when apiServiceLevel IS set on organization', async () => {
        const [, apiServiceLevel] = await useCase.execute(
          GetApiRateLimitMaximumCommand.create({
            organizationId: session.organization._id,
            environmentId: session.environment._id,
            apiRateLimitCategory: mockApiRateLimitCategory,
          })
        );

        expect(apiServiceLevel).to.equal(mockApiServiceLevel);
      });
    });

    describe('Organization DOES NOT have api service level specified', () => {
      beforeEach(() => {
        findOneOrganizationStub.resolves({
          apiServiceLevel: undefined,
        });
      });

      it('should return default api rate limit for the UNLIMITED service level when apiServiceLevel IS NOT set on organization', async () => {
        const defaultApiRateLimit = getFeatureForTierAsNumber(
          ApiRateLimitCategoryToFeatureName[mockApiRateLimitCategory],
          ApiServiceLevelEnum.UNLIMITED,
          false
        );

        const [rateLimit] = await useCase.execute(
          GetApiRateLimitMaximumCommand.create({
            organizationId: session.organization._id,
            environmentId: session.environment._id,
            apiRateLimitCategory: mockApiRateLimitCategory,
          })
        );

        expect(rateLimit).to.equal(defaultApiRateLimit);
      });

      it('should return the default api service level of UNLIMITED when apiServiceLevel IS NOT set on organization', async () => {
        const defaultApiServiceLevel = ApiServiceLevelEnum.UNLIMITED;

        const [, apiServiceLevel] = await useCase.execute(
          GetApiRateLimitMaximumCommand.create({
            organizationId: session.organization._id,
            environmentId: session.environment._id,
            apiRateLimitCategory: mockApiRateLimitCategory,
          })
        );

        expect(apiServiceLevel).to.equal(defaultApiServiceLevel);
      });
    });

    it('should throw an error when the organization is not found', async () => {
      findOneOrganizationStub.resolves(undefined);

      try {
        await useCase.execute(
          GetApiRateLimitMaximumCommand.create({
            organizationId: session.organization._id,
            environmentId: session.environment._id,
            apiRateLimitCategory: mockApiRateLimitCategory,
          })
        );
        throw new Error('Should not reach here');
      } catch (e) {
        expect(e.message).to.equal(`Organization id: ${session.organization._id} not found`);
      }
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - mockDefaultApiRateLimits({
  [ApiServiceLevelEnum.FREE]: {
    [ApiRateLimitCategoryEnum.GLOBAL]: 60,
    [ApiRateLimitCatego...)
 - findOneOrganizationStub(sinon.stub(organizationRepository, 'findById');
  });

  afterEach(())
 - mockApiRateLimitCategory(ApiRateLimitCategoryEnum.GLOBAL;

    beforeEach(())
 - mockApiRateLimitCategory(ApiRateLimitCategoryEnum.GLOBAL;

    beforeEach(())
 - mockApiServiceLevel(ApiServiceLevelEnum.FREE;

      beforeEach(())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/rate-limiting/usecases/get-api-rate-limit-maximum/get-api-rate-limit-maximum.usecase.ts
Tamaño: 4727 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, InternalServerErrorException, OnModuleInit } from '@nestjs/common';
import {
  buildMaximumApiRateLimitKey,
  CachedResponse,
  Instrument,
  InstrumentUsecase,
  PinoLogger,
} from '@novu/application-generic';
import { CommunityOrganizationRepository, EnvironmentRepository } from '@novu/dal';
import {
  ApiRateLimitCategoryEnum,
  ApiRateLimitCategoryToFeatureName,
  ApiRateLimitServiceMaximumEnvVarFormat,
  ApiServiceLevelEnum,
  getFeatureForTierAsNumber,
  IApiRateLimitServiceMaximum,
} from '@novu/shared';
import { GetApiRateLimitMaximumCommand } from './get-api-rate-limit-maximum.command';
import { CUSTOM_API_SERVICE_LEVEL, GetApiRateLimitMaximumDto } from './get-api-rate-limit-maximum.dto';

@Injectable()
export class GetApiRateLimitMaximum implements OnModuleInit {
  private apiRateLimitRecord: IApiRateLimitServiceMaximum;
  constructor(
    private environmentRepository: EnvironmentRepository,
    private organizationRepository: CommunityOrganizationRepository,
    private logger: PinoLogger
  ) {
    this.logger.setContext(this.constructor.name);
  }

  onModuleInit() {
    this.apiRateLimitRecord = this.buildApiRateLimitRecord();
  }

  @InstrumentUsecase()
  async execute(command: GetApiRateLimitMaximumCommand): Promise<GetApiRateLimitMaximumDto> {
    return await this.getApiRateLimit({
      apiRateLimitCategory: command.apiRateLimitCategory,
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
    });
  }

  @CachedResponse({
    builder: (command: { apiRateLimitCategory: ApiRateLimitCategoryEnum; _environmentId: string }) =>
      buildMaximumApiRateLimitKey({
        _environmentId: command._environmentId,
        apiRateLimitCategory: command.apiRateLimitCategory,
      }),
  })
  private async getApiRateLimit({
    apiRateLimitCategory,
    _environmentId,
    _organizationId,
  }: {
    apiRateLimitCategory: ApiRateLimitCategoryEnum;
    _environmentId: string;
    _organizationId: string;
  }): Promise<GetApiRateLimitMaximumDto> {
    const environment = await this.getEnvironment(_environmentId);

    if (environment.apiRateLimits) {
      return [environment.apiRateLimits[apiRateLimitCategory], CUSTOM_API_SERVICE_LEVEL];
    }
    const apiServiceLevel = await this.getOrganizationApiServiceLevel(_organizationId);
    const apiRateLimitRecord = this.apiRateLimitRecord[apiServiceLevel];

    return [apiRateLimitRecord[apiRateLimitCategory], apiServiceLevel];
  }

  private async getOrganizationApiServiceLevel(_organizationId: string): Promise<ApiServiceLevelEnum> {
    const organization = await this.organizationRepository.findById(_organizationId);

    if (!organization) {
      const message = `Organization id: ${_organizationId} not found`;
      this.logger.error(message);
      throw new InternalServerErrorException(message);
    }

    if (organization.apiServiceLevel) {
      return organization.apiServiceLevel;
    }

    return ApiServiceLevelEnum.UNLIMITED;
  }

  private async getEnvironment(_environmentId: string) {
    const environment = await this.environmentRepository.findOne({ _id: _environmentId });

    if (!environment) {
      const message = `Environment id: ${_environmentId} not found`;
      this.logger.error(message);
      throw new InternalServerErrorException(message);
    }

    return environment;
  }
  @Instrument()
  private buildApiRateLimitRecord(): IApiRateLimitServiceMaximum {
    // Read process environment only once for performance
    const processEnv = process.env;

    return Object.values(ApiServiceLevelEnum).reduce((acc, apiServiceLevel) => {
      acc[apiServiceLevel] = Object.values(ApiRateLimitCategoryEnum).reduce(
        (categoryAcc, apiRateLimitCategory) => {
          const featureName = ApiRateLimitCategoryToFeatureName[apiRateLimitCategory];
          const featureForTierAsNumber = getFeatureForTierAsNumber(featureName, apiServiceLevel);
          const envVarName = this.getEnvVarName(apiServiceLevel, apiRateLimitCategory);
          const envVarValue = processEnv[envVarName];

          categoryAcc[apiRateLimitCategory] = envVarValue ? Number(envVarValue) : featureForTierAsNumber;

          return categoryAcc;
        },
        {} as Record<ApiRateLimitCategoryEnum, number>
      );

      return acc;
    }, {} as IApiRateLimitServiceMaximum);
  }

  private getEnvVarName(
    apiServiceLevel: ApiServiceLevelEnum,
    apiRateLimitCategory: ApiRateLimitCategoryEnum
  ): ApiRateLimitServiceMaximumEnvVarFormat {
    return `API_RATE_LIMIT_MAXIMUM_${apiServiceLevel.toUpperCase() as Uppercase<ApiServiceLevelEnum>}_${
      apiRateLimitCategory.toUpperCase() as Uppercase<ApiRateLimitCategoryEnum>
    }`;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - apiRateLimitRecord(this.buildApiRateLimitRecord();
  }

  @InstrumentUsecase()
  async execute(command: GetApiRateLimit...)
 - processEnv(process.env;

    return Object.values(ApiServiceLevelEnum).reduce((acc, apiServiceLevel))
Declaraciones 'export' encontradas:
- export class GetApiRateLimitMaximum

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/rate-limiting/usecases/get-api-rate-limit-maximum/index.ts
Tamaño: 108 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './get-api-rate-limit-maximum.command';
export * from './get-api-rate-limit-maximum.usecase';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/constants.ts
Tamaño: 139 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export const DAL_SERVICE = 'DalService';
export const EXCEPTION_MESSAGE_ON_WEBHOOK_FILTER = 'Exception while performing webhook request.';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/shared.module.ts
Tamaño: 4530 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import {
  analyticsService,
  CacheServiceHealthIndicator,
  ComputeJobWaitDurationService,
  CreateExecutionDetails,
  cacheService,
  clickHouseService,
  createNestLoggingModuleOptions,
  DalServiceHealthIndicator,
  ExecuteBridgeRequest,
  featureFlagsService,
  GetDecryptedSecretKey,
  InvalidateCacheService,
  LoggerModule,
  QueuesModule,
  RequestLogRepository,
  StepRunRepository,
  storageService,
  TraceLogRepository,
  WorkflowRunRepository,
} from '@novu/application-generic';
import {
  ChangeRepository,
  CommunityMemberRepository,
  CommunityOrganizationRepository,
  CommunityUserRepository,
  ControlValuesRepository,
  DalService,
  EnvironmentRepository,
  ExecutionDetailsRepository,
  FeedRepository,
  IntegrationRepository,
  JobRepository,
  LayoutRepository,
  MemberRepository,
  MessageRepository,
  MessageTemplateRepository,
  NotificationGroupRepository,
  NotificationRepository,
  NotificationTemplateRepository,
  OrganizationRepository,
  PreferencesRepository,
  SubscriberRepository,
  TenantRepository,
  TopicRepository,
  TopicSubscribersRepository,
  UserRepository,
  WorkflowOverrideRepository,
} from '@novu/dal';
import { isClerkEnabled, JobTopicNameEnum } from '@novu/shared';
import packageJson from '../../../package.json';

function getDynamicAuthProviders() {
  if (isClerkEnabled()) {
    const eeAuthPackage = require('@novu/ee-auth');

    return eeAuthPackage.injectEEAuthProviders();
  } else {
    const userRepositoryProvider = {
      provide: 'USER_REPOSITORY',
      useClass: CommunityUserRepository,
    };

    const memberRepositoryProvider = {
      provide: 'MEMBER_REPOSITORY',
      useClass: CommunityMemberRepository,
    };

    const organizationRepositoryProvider = {
      provide: 'ORGANIZATION_REPOSITORY',
      useClass: CommunityOrganizationRepository,
    };

    return [userRepositoryProvider, memberRepositoryProvider, organizationRepositoryProvider];
  }
}

const DAL_MODELS = [
  UserRepository,
  OrganizationRepository,
  CommunityOrganizationRepository,
  EnvironmentRepository,
  ExecutionDetailsRepository,
  NotificationTemplateRepository,
  SubscriberRepository,
  NotificationRepository,
  MessageRepository,
  MessageTemplateRepository,
  NotificationGroupRepository,
  MemberRepository,
  LayoutRepository,
  IntegrationRepository,
  ChangeRepository,
  JobRepository,
  FeedRepository,
  TopicRepository,
  TopicSubscribersRepository,
  TenantRepository,
  WorkflowOverrideRepository,
  ControlValuesRepository,
  PreferencesRepository,
];

const dalService = {
  provide: DalService,
  useFactory: async () => {
    const service = new DalService();
    await service.connect(process.env.MONGO_URL || '.');

    return service;
  },
};

const ANALYTICS_PROVIDERS = [
  // Repositories
  RequestLogRepository,
  TraceLogRepository,
  StepRunRepository,
  WorkflowRunRepository,

  // Services
  clickHouseService,
];

const PROVIDERS = [
  analyticsService,
  cacheService,
  CacheServiceHealthIndicator,
  ComputeJobWaitDurationService,
  dalService,
  DalServiceHealthIndicator,
  featureFlagsService,
  InvalidateCacheService,
  storageService,
  ...DAL_MODELS,
  CreateExecutionDetails,
  ExecuteBridgeRequest,
  GetDecryptedSecretKey,
  ...ANALYTICS_PROVIDERS,
];

const IMPORTS = [
  QueuesModule.forRoot([
    JobTopicNameEnum.WEB_SOCKETS,
    JobTopicNameEnum.WORKFLOW,
    JobTopicNameEnum.INBOUND_PARSE_MAIL,
    JobTopicNameEnum.STANDARD,
  ]),
  LoggerModule.forRoot(
    createNestLoggingModuleOptions({
      serviceName: packageJson.name,
      version: packageJson.version,
    })
  ),
];

if (process.env.NODE_ENV === 'test') {
  /**
   * This is here only because of the tests. These providers are available at AppModule level,
   * but since in tests we are often importing just the SharedModule and not the entire AppModule
   * we need to make sure these providers are available.
   *
   * TODO: modify tests to either import all services they need explicitly, or remove repositories from SharedModule,
   * and then import SharedModule + repositories explicitly.
   */
  PROVIDERS.push(...getDynamicAuthProviders());
  IMPORTS.push(
    JwtModule.register({
      secret: `${process.env.JWT_SECRET}`,
      signOptions: {
        expiresIn: 360000,
      },
    })
  );
}

@Module({
  imports: [...IMPORTS],
  providers: [...PROVIDERS],
  exports: [...PROVIDERS, LoggerModule, QueuesModule],
})
export class SharedModule {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getDynamicAuthProviders()
Asignaciones con arrow functions encontradas (posibles funciones):
 - dalService({
  provide: DalService,
  useFactory: async ())
Declaraciones 'export' encontradas:
- export class SharedModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/types.ts
Tamaño: 152 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export type Constructor<I> = new (...args: any[]) => I;

export type CursorPaginationParams = {
  limit: number;
  after?: string;
  offset: number;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/commands/authenticated.command.ts
Tamaño: 221 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BaseCommand } from '@novu/application-generic';
import { IsNotEmpty } from 'class-validator';

export abstract class AuthenticatedCommand extends BaseCommand {
  @IsNotEmpty()
  public readonly userId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  abstract

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/commands/commandValidationException.ts
Tamaño: 245 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException } from '@nestjs/common';

export class CommandValidationException extends BadRequestException {
  constructor(public mappedErrors: string[]) {
    super({ message: 'Validation failed', errors: mappedErrors });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CommandValidationException

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/commands/organization.command.ts
Tamaño: 237 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsNotEmpty } from 'class-validator';
import { AuthenticatedCommand } from './authenticated.command';

export abstract class OrganizationCommand extends AuthenticatedCommand {
  @IsNotEmpty()
  readonly organizationId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  abstract

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/commands/project.command.ts
Tamaño: 751 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BaseCommand } from '@novu/application-generic';
import { IsArray, IsNotEmpty, IsOptional, IsString } from 'class-validator';

export abstract class EnvironmentCommand extends BaseCommand {
  @IsNotEmpty()
  readonly environmentId: string;

  @IsNotEmpty()
  readonly organizationId: string;
}

export abstract class EnvironmentWithUserCommand extends EnvironmentCommand {
  @IsNotEmpty()
  readonly userId: string;
}

export abstract class EnvironmentWithSubscriber extends EnvironmentCommand {
  @IsNotEmpty()
  readonly environmentId: string;

  @IsNotEmpty()
  readonly organizationId: string;

  @IsNotEmpty()
  readonly subscriberId: string;

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  readonly contextKeys?: string[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  abstract
- export  abstract
- export  abstract

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/containers/workflow-data.container.ts
Tamaño: 9524 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  ControlValuesEntity,
  ControlValuesRepository,
  NotificationTemplateEntity,
  NotificationTemplateRepository,
  PreferencesEntity,
  PreferencesRepository,
} from '@novu/dal';
import {
  buildWorkflowPreferences,
  ControlValuesLevelEnum,
  PreferencesTypeEnum,
  WorkflowPreferences,
} from '@novu/shared';
import { StepResponseDto } from '../../workflows-v2/dtos';
import { WorkflowResponseDto } from '../../workflows-v2/dtos/workflow-response.dto';
import { toResponseWorkflowDto } from '../../workflows-v2/mappers/notification-template-mapper';
import { BuildStepDataUsecase } from '../../workflows-v2/usecases/build-step-data/build-step-data.usecase';
import { emptyJsonSchema } from '../../workflows-v2/util/jsonToSchema';

export interface IWorkflowPreferences {
  workflowResourcePreference?: PreferencesEntity;
  workflowUserPreference?: PreferencesEntity;
}

export interface IWorkflowWithControlValues {
  workflow: NotificationTemplateEntity;
  identifier: string;
  controlValuesByStep: Map<string, ControlValuesEntity>;
  preferences?: IWorkflowPreferences;
  workflowDto?: WorkflowResponseDto;
  steps?: Map<string, StepResponseDto>;
}

type WorkflowLookupData = {
  objectId: string;
  identifier: string;
  environmentId: string;
};

export class WorkflowDataContainer {
  private workflowsByIdentifier = new Map<string, IWorkflowWithControlValues>();
  private isDataLoaded = false;

  constructor(
    private controlValuesRepository: ControlValuesRepository,
    private preferencesRepository: PreferencesRepository
  ) {}

  async loadWorkflowsWithControlValues(
    workflows: NotificationTemplateEntity[],
    environmentId: string,
    organizationId: string,
    targetEnvironmentId: string
  ): Promise<void> {
    if (this.isDataLoaded) {
      return;
    }

    if (workflows.length === 0) {
      this.isDataLoaded = true;
      return;
    }

    const environmentIds = [environmentId, targetEnvironmentId];

    const lookupMaps = this.buildLookupMaps(workflows);

    const [controlValues, preferences] = await this.fetchRelatedData(
      Array.from(lookupMaps.workflowLookup.values()).map((data) => data.objectId),
      environmentIds,
      organizationId
    );

    const controlValuesByWorkflowAndStep = this.organizeControlValues(controlValues, lookupMaps.objectIdToKey);
    const preferencesByWorkflow = this.organizePreferences(preferences, lookupMaps.objectIdToKey);

    this.processWorkflows(workflows, controlValuesByWorkflowAndStep, preferencesByWorkflow);
    this.isDataLoaded = true;
  }

  private buildLookupMaps(workflows: NotificationTemplateEntity[]) {
    const workflowLookup = new Map<string, WorkflowLookupData>();
    const objectIdToKey = new Map<string, string>();

    for (const workflow of workflows) {
      const identifier = workflow.triggers?.[0]?.identifier;
      if (!identifier || !workflow._id) continue;

      const lookupKey = this.makeKey(workflow._environmentId, identifier);
      const objectIdKey = `${workflow._id}:${workflow._environmentId}`;

      workflowLookup.set(lookupKey, {
        objectId: workflow._id,
        identifier,
        environmentId: workflow._environmentId,
      });
      objectIdToKey.set(objectIdKey, lookupKey);
    }

    return { workflowLookup, objectIdToKey };
  }

  private async fetchRelatedData(
    workflowObjectIds: string[],
    environmentIds: string[],
    organizationId: string
  ): Promise<[ControlValuesEntity[], PreferencesEntity[]]> {
    return Promise.all([
      this.controlValuesRepository.find({
        _environmentId: { $in: environmentIds },
        _organizationId: organizationId,
        _workflowId: { $in: workflowObjectIds },
        level: ControlValuesLevelEnum.STEP_CONTROLS,
      }),
      this.preferencesRepository.find({
        _environmentId: { $in: environmentIds },
        _organizationId: organizationId,
        _templateId: { $in: workflowObjectIds },
        type: { $in: [PreferencesTypeEnum.WORKFLOW_RESOURCE, PreferencesTypeEnum.USER_WORKFLOW] },
      }),
    ]);
  }

  private organizeControlValues(controlValues: ControlValuesEntity[], objectIdToKey: Map<string, string>) {
    const byWorkflowAndStep = new Map<string, Map<string, ControlValuesEntity>>();

    for (const cv of controlValues) {
      if (!cv._workflowId || !cv._stepId) continue;

      const lookupKey = objectIdToKey.get(`${cv._workflowId}:${cv._environmentId}`);
      if (!lookupKey) continue;

      this.ensureMapEntry(byWorkflowAndStep, lookupKey, new Map()).set(cv._stepId, cv);
    }

    return byWorkflowAndStep;
  }

  private organizePreferences(
    preferences: PreferencesEntity[],
    objectIdToKey: Map<string, string>
  ): Map<string, IWorkflowPreferences> {
    const byWorkflow = new Map<string, IWorkflowPreferences>();

    for (const pref of preferences) {
      if (!pref._templateId) continue;

      const lookupKey = objectIdToKey.get(`${pref._templateId}:${pref._environmentId}`);
      if (!lookupKey) continue;

      const workflowPrefs = this.ensureMapEntry(byWorkflow, lookupKey, {});

      if (pref.type === PreferencesTypeEnum.WORKFLOW_RESOURCE) {
        workflowPrefs.workflowResourcePreference = pref;
      } else if (pref.type === PreferencesTypeEnum.USER_WORKFLOW) {
        workflowPrefs.workflowUserPreference = pref;
      }
    }

    return byWorkflow;
  }

  private processWorkflows(
    workflows: NotificationTemplateEntity[],
    controlValuesByWorkflowAndStep: Map<string, Map<string, ControlValuesEntity>>,
    preferencesByWorkflow: Map<string, IWorkflowPreferences>
  ) {
    for (const workflow of workflows) {
      const identifier = workflow.triggers?.[0]?.identifier;
      if (!identifier) continue;

      const key = this.makeKey(workflow._environmentId, identifier);
      const controlValuesByStep = controlValuesByWorkflowAndStep.get(key) || new Map();
      const preferences = preferencesByWorkflow.get(key);

      const workflowWithPreferences = this.buildWorkflowWithPreferences(workflow, preferences);
      const stepDtos = this.buildStepDtos(workflow, workflowWithPreferences, controlValuesByStep);

      this.storeWorkflowData(key, workflow, identifier, {
        controlValuesByStep,
        preferences,
        workflowDto: toResponseWorkflowDto(workflowWithPreferences, stepDtos),
        steps: new Map(stepDtos.map((step) => [step._id, step])),
      });
    }
  }

  private buildWorkflowWithPreferences(workflow: NotificationTemplateEntity, preferences?: IWorkflowPreferences) {
    const userPreferences = preferences?.workflowUserPreference?.preferences
      ? buildWorkflowPreferences(preferences.workflowUserPreference.preferences)
      : null;

    const defaultPreferences = preferences?.workflowResourcePreference?.preferences
      ? buildWorkflowPreferences(preferences.workflowResourcePreference.preferences)
      : buildWorkflowPreferences(null);

    return {
      ...workflow,
      userPreferences,
      defaultPreferences,
    };
  }

  private buildStepDtos(
    workflow: NotificationTemplateEntity,
    workflowWithPreferences: NotificationTemplateEntity & {
      userPreferences: WorkflowPreferences | null;
      defaultPreferences: WorkflowPreferences;
    },
    controlValuesByStep: Map<string, ControlValuesEntity>
  ): StepResponseDto[] {
    return workflowWithPreferences.steps.map((step) => {
      const controlValues = controlValuesByStep.get(step._templateId);

      return BuildStepDataUsecase.mapToStepResponse(workflow, step, controlValues?.controls || {}, emptyJsonSchema());
    });
  }

  private storeWorkflowData(
    key: string,
    workflow: NotificationTemplateEntity,
    identifier: string,
    data: Omit<IWorkflowWithControlValues, 'workflow' | 'identifier'>
  ) {
    this.workflowsByIdentifier.set(key, {
      workflow,
      identifier,
      ...data,
    });
  }

  private ensureMapEntry<K, V>(map: Map<K, V>, key: K, defaultValue: V): V {
    if (!map.has(key)) {
      map.set(key, defaultValue);
    }

    return map.get(key) ?? defaultValue;
  }

  private makeKey(environmentId: string, identifier: string): string {
    return `${environmentId}:${identifier}`;
  }

  getWorkflowData(identifier: string, environmentId: string): IWorkflowWithControlValues | undefined {
    // First try to find by identifier
    const data = this.workflowsByIdentifier.get(this.makeKey(environmentId, identifier));
    if (data) {
      return data;
    }

    // Fallback: search by MongoDB workflow ID
    for (const workflowData of this.workflowsByIdentifier.values()) {
      if (workflowData.workflow._id === identifier && workflowData.workflow._environmentId === environmentId) {
        return workflowData;
      }
    }

    return undefined;
  }

  getWorkflowDto(identifier: string, environmentId: string): WorkflowResponseDto | undefined {
    const data = this.getWorkflowData(identifier, environmentId);
    return data?.workflowDto;
  }

  getStepData(identifier: string, stepId: string, environmentId: string): StepResponseDto | undefined {
    const data = this.getWorkflowData(identifier, environmentId);
    return data?.steps?.get(stepId);
  }

  getWorkflowsByEnvironment(environmentId: string): NotificationTemplateEntity[] {
    const workflows: NotificationTemplateEntity[] = [];

    for (const workflowData of this.workflowsByIdentifier.values()) {
      if (workflowData.workflow._environmentId === environmentId) {
        workflows.push(workflowData.workflow);
      }
    }

    return workflows;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - stepDtos(this.buildStepDtos(workflow, workflowWithPreferences, controlValuesByStep);

      this.storeWorkflo...)
 - defaultPreferences(preferences?.workflowResourcePreference?.preferences
      ? buildWorkflowPreferences(preferences.wo...)
Declaraciones 'export' encontradas:
- export  interface
- export  interface
- export class WorkflowDataContainer

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/dtos/api-key.ts
Tamaño: 140 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';

export class ApiKey {
  @ApiProperty()
  key: string;
  @ApiProperty()
  _userId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ApiKey

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/dtos/base-responses.ts
Tamaño: 2906 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';

export enum DirectionEnum {
  ASC = 'ASC',
  DESC = 'DESC',
}

export class ResponseError {
  @ApiProperty({
    description: 'The error code or identifier.',
    type: String,
  })
  error: string;

  @ApiProperty({
    description: 'Detailed error message.',
    type: String,
  })
  message: string;

  @ApiProperty({
    description: 'HTTP status code associated with the error.',
    type: Number,
  })
  statusCode: number;
}

export class PaginatedResponse<T> {
  @ApiProperty({
    description: 'Array of data items of type T.',
    type: 'array', // Use 'array' instead of Array
    items: { type: 'object' }, // Define the type of items in the array
  })
  data: T[];

  @ApiProperty({
    description: 'Indicates if there are more items available.',
    type: Boolean,
  })
  hasMore: boolean;

  @ApiProperty({
    description: 'Total number of items available.',
    type: Number,
  })
  totalCount: number;

  @ApiProperty({
    description: 'Number of items per page.',
    type: Number,
  })
  pageSize: number;

  @ApiProperty({
    description: 'Current page number.',
    type: Number,
  })
  page: number;
}

export type KeysOfT<T> = keyof T;

export class CursorPaginationQueryDto<T, K extends keyof T> {
  @ApiProperty({
    description: 'Maximum number of items to return.',
    type: Number,
  })
  limit?: number;

  @ApiProperty({
    description: 'Cursor for pagination, used to fetch the next set of results.',
    type: String,
  })
  cursor?: string;

  @ApiProperty({
    description: 'Direction for ordering results.',
    enum: DirectionEnum,
  })
  orderDirection?: DirectionEnum;

  @ApiProperty({
    description: 'Field by which to order the results.',
    type: String,
  })
  orderBy?: K;
}

export class LimitOffsetPaginationDto<T, K extends KeysOfT<T>> {
  @ApiProperty({
    description: 'Maximum number of items to return.',
    type: String,
  })
  limit: string;

  @ApiProperty({
    description: 'Number of items to skip before starting to collect the result set.',
    type: String,
  })
  offset: string;

  @ApiProperty({
    description: 'Direction for ordering results.',
    enum: DirectionEnum,
  })
  orderDirection?: DirectionEnum;

  @ApiProperty({
    description: 'Field by which to order the results.',
    type: String,
  })
  orderBy?: K;
}

export class PaginationParams {
  @ApiProperty({
    description: 'Current page number.',
    type: Number,
  })
  page: number;

  @ApiProperty({
    description: 'Number of items per page.',
    type: Number,
  })
  limit: number;
}

export class PaginationWithQueryParams extends PaginationParams {
  @ApiProperty({
    description: 'Optional search query string.',
    type: String,
    required: false,
  })
  query?: string;
}

export enum OrderDirectionEnum {
  ASC = 1,
  DESC = -1,
}

export enum OrderByEnum {
  ASC = 'ASC',
  DESC = 'DESC',
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  enum
- export class ResponseError
- export class PaginatedResponse
- export  type
- export class CursorPaginationQueryDto
- export class LimitOffsetPaginationDto
- export class PaginationParams
- export class PaginationWithQueryParams
- export  enum
- export  enum

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/dtos/channel-preference.ts
Tamaño: 568 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { ChannelTypeEnum } from '@novu/shared';
import { IsBoolean, IsDefined, IsEnum } from 'class-validator';

export class ChannelPreference {
  @ApiProperty({
    enum: [...Object.values(ChannelTypeEnum)],
    enumName: 'ChannelTypeEnum',
    description: 'The type of channel that is enabled or not',
  })
  @IsDefined()
  @IsEnum(ChannelTypeEnum)
  type: ChannelTypeEnum;

  @ApiProperty({
    type: Boolean,
    description: 'If channel is enabled or not',
  })
  @IsBoolean()
  @IsDefined()
  enabled: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ChannelPreference

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/dtos/cursor-paginated-response.ts
Tamaño: 1363 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { mixin } from '@nestjs/common';
import { ApiProperty, ApiPropertyOptions } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { ValidateNested } from 'class-validator';

type Constructor<T = {}> = new (...args: any[]) => T;

export function withCursorPagination<TBase extends Constructor>(Base: TBase, options?: ApiPropertyOptions | undefined) {
  class ResponseDTO {
    @ApiProperty({
      isArray: true,
      type: Base,
      ...options,
    })
    @Type(() => Base)
    @ValidateNested({ each: true })
    data!: Array<InstanceType<TBase>>;

    @ApiProperty({
      description: 'The cursor for the next page of results, or null if there are no more pages.',
      type: String,
      nullable: true,
    })
    next: string | null;

    @ApiProperty({
      description: 'The cursor for the previous page of results, or null if this is the first page.',
      type: String,
      nullable: true,
    })
    previous: string | null;

    @ApiProperty({
      description: 'The total count of items (up to 50,000)',
      type: Number,
    })
    totalCount: number;

    @ApiProperty({
      description: 'Whether there are more than 50,000 results available',
      type: Boolean,
    })
    totalCountCapped: boolean;
  }

  return mixin(ResponseDTO); // This is important otherwise you will get always the same instance
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export function withCursorPagination

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/dtos/cursor-pagination-request.ts
Tamaño: 946 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { IsInt, IsMongoId, IsOptional, Max, Min } from 'class-validator';

import type { Constructor, CursorPaginationParams } from '../types';

export function CursorPaginationRequestDto(defaultLimit = 10, maxLimit = 100): Constructor<CursorPaginationParams> {
  class CursorPaginationRequest {
    @ApiPropertyOptional({
      type: Number,
      required: false,
      default: defaultLimit,
      maximum: maxLimit,
    })
    @IsOptional()
    @Type(() => Number)
    @IsInt()
    @Min(1)
    @Max(maxLimit)
    limit = defaultLimit;

    @ApiPropertyOptional()
    @IsOptional()
    @IsMongoId({
      message: 'The after cursor must be a valid MongoDB ObjectId',
    })
    after?: string;

    @ApiPropertyOptional()
    @IsOptional()
    @Type(() => Number)
    @IsInt()
    @Min(0)
    offset = 0;
  }

  return CursorPaginationRequest;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - CursorPaginationRequestDto(defaultLimit = 10, maxLimit = 100)
Asignaciones con arrow functions encontradas (posibles funciones):
 - maxLimit(100): Constructor<CursorPaginationParams> {
  class CursorPaginationRequest {
    @ApiPropertyOption...)
 - limit(defaultLimit;

    @ApiPropertyOptional()
    @IsOptional()
    @IsMongoId({
      message: 'The aft...)
Declaraciones 'export' encontradas:
- export function CursorPaginationRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/dtos/data-wrapper-dto.ts
Tamaño: 243 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';

export class DataWrapperDto<T> {
  @ApiProperty()
  data: T;
}

export class DataBooleanDto {
  @ApiProperty()
  data: boolean;
}

export class DataNumberDto {
  @ApiProperty()
  data: number;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DataWrapperDto
- export class DataBooleanDto
- export class DataNumberDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/dtos/json-schema.dto.ts
Tamaño: 7923 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiExtraModels, ApiPropertyOptional } from '@nestjs/swagger';
import { JsonSchemaFormatEnum, JsonSchemaTypeEnum } from '@novu/dal';
import { Type } from 'class-transformer';
import { IsArray, IsBoolean, IsEnum, IsNumber, IsOptional, IsString, ValidateNested } from 'class-validator';

@ApiExtraModels()
export class JSONSchemaDto {
  @ApiPropertyOptional({
    description: 'JSON Schema type',
    enum: [...Object.values(JsonSchemaTypeEnum)],
    enumName: 'JsonSchemaTypeEnum',
  })
  @IsOptional()
  @IsEnum(JsonSchemaTypeEnum)
  type?: JsonSchemaTypeEnum;

  @ApiPropertyOptional({
    description: 'Format validation for strings',
    enum: [...Object.values(JsonSchemaFormatEnum)],
    enumName: 'JsonSchemaFormatEnum',
    type: 'string',
  })
  @IsOptional()
  @IsEnum(JsonSchemaFormatEnum)
  format?: JsonSchemaFormatEnum;

  @ApiPropertyOptional({
    description: 'Title of the schema',
    type: 'string',
  })
  @IsOptional()
  @IsString()
  title?: string;

  @ApiPropertyOptional({
    description: 'Description of the schema',
    type: 'string',
  })
  @IsOptional()
  @IsString()
  description?: string;

  @ApiPropertyOptional({
    description: 'Default value',
    oneOf: [{ type: 'string' }, { type: 'number' }, { type: 'boolean' }],
    required: false,
  })
  @IsOptional()
  default?: string | number | boolean;

  @ApiPropertyOptional({
    description: 'Const value (exact match required)',
  })
  @IsOptional()
  const?: any;

  @ApiPropertyOptional({
    description: 'Minimum value for numbers',
    type: 'number',
  })
  @IsOptional()
  @IsNumber()
  minimum?: number;

  @ApiPropertyOptional({
    description: 'Maximum value for numbers',
    type: 'number',
  })
  @IsOptional()
  @IsNumber()
  maximum?: number;

  @ApiPropertyOptional({
    description: 'Exclusive minimum',
    type: 'boolean',
  })
  @IsOptional()
  @IsBoolean()
  exclusiveMinimum?: boolean;

  @ApiPropertyOptional({
    description: 'Exclusive maximum',
    type: 'boolean',
  })
  @IsOptional()
  @IsBoolean()
  exclusiveMaximum?: boolean;

  @ApiPropertyOptional({
    description: 'Minimum length for strings',
    type: 'number',
  })
  @IsOptional()
  @IsNumber()
  minLength?: number;

  @ApiPropertyOptional({
    description: 'Maximum length for strings',
    type: 'number',
  })
  @IsOptional()
  @IsNumber()
  maxLength?: number;

  @ApiPropertyOptional({
    description: 'Regular expression pattern',
    type: 'string',
  })
  @IsOptional()
  @IsString()
  pattern?: string;

  @ApiPropertyOptional({
    description: 'Minimum number of items in array',
    type: 'number',
  })
  @IsOptional()
  @IsNumber()
  minItems?: number;

  @ApiPropertyOptional({
    description: 'Maximum number of items in array',
    type: 'number',
  })
  @IsOptional()
  @IsNumber()
  maxItems?: number;

  @ApiPropertyOptional({
    description: 'Items must be unique',
    type: 'boolean',
  })
  @IsOptional()
  @IsBoolean()
  uniqueItems?: boolean;

  @ApiPropertyOptional({
    description: 'Schema for array items',
    oneOf: [{ $ref: '#/components/schemas/JSONSchemaDto' }],
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => JSONSchemaDto)
  items?: JSONSchemaDto;

  @ApiPropertyOptional({
    description: 'Required properties for object',
    type: 'array',
    items: {
      type: 'string',
    },
  })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  required?: string[];

  @ApiPropertyOptional({
    description: 'Object properties',
    type: 'object',
    additionalProperties: {
      oneOf: [{ $ref: '#/components/schemas/JSONSchemaDto' }],
    },
  })
  @IsOptional()
  @ValidateNested({ each: true })
  @Type(() => JSONSchemaDto)
  properties?: Record<string, JSONSchemaDto>;

  @ApiPropertyOptional({
    description: 'Additional properties schema',
    oneOf: [{ $ref: '#/components/schemas/JSONSchemaDto' }, { type: 'boolean' }],
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => JSONSchemaDto)
  additionalProperties?: JSONSchemaDto | boolean;

  @ApiPropertyOptional({
    description: 'Enumeration of possible values',
    type: 'array',
    items: {
      type: 'string', // or use a more specific type
    },
  })
  @IsOptional()
  @IsArray()
  enum?: string[];

  @ApiPropertyOptional({
    description: 'Combination of schemas (allOf)',
    type: 'array',
    items: {
      oneOf: [{ $ref: '#/components/schemas/JSONSchemaDto' }],
    },
  })
  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => JSONSchemaDto)
  allOf?: JSONSchemaDto[];

  @ApiPropertyOptional({
    description: 'At least one schema must match (anyOf)',
    type: 'array',
    items: {
      oneOf: [{ $ref: '#/components/schemas/JSONSchemaDto' }],
    },
  })
  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => JSONSchemaDto)
  anyOf?: JSONSchemaDto[];

  @ApiPropertyOptional({
    description: 'Only one schema must match (oneOf)',
    type: 'array',
    items: {
      oneOf: [{ $ref: '#/components/schemas/JSONSchemaDto' }],
    },
  })
  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => JSONSchemaDto)
  oneOf?: JSONSchemaDto[];

  @ApiPropertyOptional({
    description: 'Schema must not match (not)',
    oneOf: [{ $ref: '#/components/schemas/JSONSchemaDto' }],
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => JSONSchemaDto)
  not?: JSONSchemaDto;

  @ApiPropertyOptional({
    description: 'Conditional validation schema (if condition)',
    oneOf: [{ $ref: '#/components/schemas/JSONSchemaDto' }],
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => JSONSchemaDto)
  if?: JSONSchemaDto;

  @ApiPropertyOptional({
    description: 'Schema to apply if "if" condition is true',
    oneOf: [{ $ref: '#/components/schemas/JSONSchemaDto' }],
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => JSONSchemaDto)
  then?: JSONSchemaDto;

  @ApiPropertyOptional({
    description: 'Schema to apply if "if" condition is false',
    oneOf: [{ $ref: '#/components/schemas/JSONSchemaDto' }],
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => JSONSchemaDto)
  else?: JSONSchemaDto;

  @ApiPropertyOptional({
    description: 'Content encoding (e.g., base64)',
    type: 'string',
  })
  @IsOptional()
  @IsString()
  contentEncoding?: string;

  @ApiPropertyOptional({
    description: 'Content media type',
    type: 'string',
  })
  @IsOptional()
  @IsString()
  contentMediaType?: string;

  @ApiPropertyOptional({
    description: 'Dependent required properties',
    type: 'object',
    additionalProperties: {
      type: 'array',
      items: {
        type: 'string',
      },
    },
  })
  @IsOptional()
  @ValidateNested()
  dependentRequired?: Record<string, string[]>;

  @ApiPropertyOptional({
    description: 'Dependent schemas',
    type: 'object',
    additionalProperties: {
      oneOf: [{ $ref: '#/components/schemas/JSONSchemaDto' }],
    },
  })
  @IsOptional()
  @ValidateNested({ each: true })
  @Type(() => JSONSchemaDto)
  dependentSchemas?: Record<string, JSONSchemaDto>;

  @ApiPropertyOptional({
    description: 'JSON Schema version',
    type: 'string',
  })
  @IsOptional()
  @IsString()
  $schema?: string;

  @ApiPropertyOptional({
    description: 'Unique identifier for the schema',
    type: 'string',
  })
  @IsOptional()
  @IsString()
  $id?: string;

  @ApiPropertyOptional({
    description: 'Content schema for specific types',
    oneOf: [{ $ref: '#/components/schemas/JSONSchemaDto' }],
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => JSONSchemaDto)
  contentSchema?: JSONSchemaDto;

  @ApiPropertyOptional({
    description: 'Example values',
    type: 'array',
    items: {
      type: 'object', // or use a more specific type
    },
  })
  @IsOptional()
  @IsArray()
  examples?: any[];

  @ApiPropertyOptional({
    description: 'Minimum number of decimal places',
    type: 'number',
  })
  @IsOptional()
  @IsNumber()
  multipleOf?: number;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class JSONSchemaDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/dtos/limit-offset-pagination.dto.ts
Tamaño: 2043 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { Transform } from 'class-transformer';
import { IsEnum, IsInt, IsNumber, IsOptional, IsString, Min } from 'class-validator';

// Enum for sorting direction
export enum DirectionEnum {
  ASC = 'ASC',
  DESC = 'DESC',
}

export function LimitOffsetPaginationQueryDto<T, K extends keyof T>(
  BaseClass: new (...args: any[]) => T,
  allowedFields: K[]
): new () => {
  limit?: number;
  offset?: number;
  orderDirection?: DirectionEnum;
  orderBy?: K;
} {
  class PaginationDto {
    @ApiProperty({
      description: 'Number of items to return per page',
      type: 'number',
      required: false,
    })
    @Transform(({ value }) => {
      // Convert to number, handle different input types
      const parsed = Number(value);

      return !Number.isNaN(parsed) ? parsed : undefined;
    })
    @IsNumber()
    @IsInt()
    @Min(1) // Optional: ensure minimum limit
    @IsOptional()
    limit?: number;

    @ApiProperty({
      description: 'Number of items to skip before starting to return results',
      type: 'number',
      required: false,
    })
    @Transform(({ value }) => {
      // Convert to number, handle different input types
      const parsed = Number(value);

      return !Number.isNaN(parsed) ? parsed : undefined;
    })
    @IsInt()
    @IsNumber()
    @Min(0) // Ensure non-negative offset
    @IsOptional()
    offset?: number;

    @ApiPropertyOptional({
      description: 'Direction of sorting',
      enum: DirectionEnum,
      enumName: 'DirectionEnum',
      required: false,
    })
    @IsOptional()
    @IsEnum(DirectionEnum)
    orderDirection?: DirectionEnum;

    @ApiPropertyOptional({
      description: 'Field to sort the results by',
      enum: allowedFields,
      enumName: `${BaseClass.name}SortField`,
      type: 'string',
      required: false,
    })
    @IsOptional()
    @IsString()
    @IsEnum(Object.fromEntries(allowedFields.map((field) => [field, field])))
    orderBy?: K;
  }

  return PaginationDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - DESC('DESC',
}

export function LimitOffsetPaginationQueryDto<T, K extends keyof T>(
  BaseClass: new (.....)
 - parsed(Number(value);

      return !Number.isNaN(parsed) ? parsed : undefined;
    })
    @IsNumber()
    ...)
 - parsed(Number(value);

      return !Number.isNaN(parsed) ? parsed : undefined;
    })
    @IsInt()
    @Is...)
Declaraciones 'export' encontradas:
- export  enum
- export function LimitOffsetPaginationQueryDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/dtos/message-template.ts
Tamaño: 990 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  ActorTypeEnum,
  IActor,
  IEmailBlock,
  IMessageCTA,
  ITemplateVariable,
  MessageTemplateContentType,
  StepTypeEnum,
} from '@novu/shared';
import { IsDefined, IsEnum, IsOptional, IsString, ValidateNested } from 'class-validator';

export class MessageTemplate {
  @IsOptional()
  @IsEnum(StepTypeEnum)
  type: StepTypeEnum;

  @IsOptional()
  variables?: ITemplateVariable[];

  @IsDefined()
  content: string | IEmailBlock[];

  @IsOptional()
  contentType?: MessageTemplateContentType;

  @IsOptional()
  @ValidateNested()
  cta?: IMessageCTA;

  @IsOptional()
  @IsString()
  feedId?: string;

  @IsOptional()
  layoutId?: string | null;

  @IsOptional()
  @IsString()
  name?: string;

  @IsOptional()
  @IsString()
  subject?: string;

  @IsOptional()
  @IsString()
  title?: string;

  @IsOptional()
  @IsString()
  preheader?: string;

  @IsOptional()
  @IsString()
  senderName?: string;

  @IsOptional()
  actor?: IActor;

  @IsOptional()
  _creatorId?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class MessageTemplate

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/dtos/message.template.dto.ts
Tamaño: 598 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  ActorTypeEnum,
  IEmailBlock,
  IMessageCTADto,
  ITemplateVariable,
  MessageTemplateContentType,
  StepTypeEnum,
} from '@novu/shared';

export class MessageTemplateDto {
  type: StepTypeEnum;

  content: string | IEmailBlock[];

  contentType?: MessageTemplateContentType;

  cta?: IMessageCTADto;

  actor?: {
    type: ActorTypeEnum;
    data: string | null;
  };

  variables?: ITemplateVariable[];

  _feedId?: string;

  _layoutId?: string | null;

  name?: string;

  subject?: string;

  title?: string;

  preheader?: string;

  senderName?: string;

  _creatorId?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class MessageTemplateDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/dtos/notification-step-dto.ts
Tamaño: 5539 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiExtraModels, ApiProperty, ApiPropertyOptional, getSchemaPath } from '@nestjs/swagger';
import {
  DaysEnum,
  DelayTypeEnum,
  DigestTypeEnum,
  DigestUnitEnum,
  IDelayRegularMetadata,
  IDelayScheduledMetadata,
  IDigestBaseMetadata,
  IDigestRegularMetadata,
  IDigestTimedMetadata,
  ITimedConfig,
  IWorkflowStepMetadata,
  MonthlyTypeEnum,
  OrdinalEnum,
  OrdinalValueEnum,
  StepVariantDto,
} from '@novu/shared';
import { Type } from 'class-transformer';
import { IsBoolean, IsString, ValidateNested } from 'class-validator';
import { MessageTemplate } from './message-template';
import { StepFilterDto } from './step-filter-dto';

class TimedConfig implements ITimedConfig {
  @ApiPropertyOptional()
  atTime?: string;

  @ApiPropertyOptional({ enum: [...Object.values(DaysEnum)], isArray: true })
  weekDays?: DaysEnum[];

  @ApiPropertyOptional()
  monthDays?: number[];

  @ApiPropertyOptional({ enum: [...Object.values(OrdinalEnum)] })
  ordinal?: OrdinalEnum;

  @ApiPropertyOptional({ enum: [...Object.values(OrdinalValueEnum)] })
  ordinalValue?: OrdinalValueEnum;

  @ApiPropertyOptional({ enum: [...Object.values(MonthlyTypeEnum)] })
  monthlyType?: MonthlyTypeEnum;
}

class AmountAndUnit {
  @ApiPropertyOptional()
  amount: number;

  @ApiPropertyOptional({
    enum: [...Object.values(DigestUnitEnum)],
  })
  unit: DigestUnitEnum;
}

class DigestBaseMetadata extends AmountAndUnit implements IDigestBaseMetadata {
  @ApiPropertyOptional()
  digestKey?: string;
}

class DigestRegularMetadata extends DigestBaseMetadata implements IDigestRegularMetadata {
  @ApiProperty({ enum: [DigestTypeEnum.REGULAR, DigestTypeEnum.BACKOFF] })
  type: DigestTypeEnum.REGULAR | DigestTypeEnum.BACKOFF;

  @ApiPropertyOptional()
  backoff?: boolean;

  @ApiPropertyOptional()
  backoffAmount?: number;

  @ApiPropertyOptional({
    enum: [...Object.values(DigestUnitEnum)],
  })
  backoffUnit?: DigestUnitEnum;

  @ApiPropertyOptional()
  updateMode?: boolean;
}

class DigestTimedMetadata extends DigestBaseMetadata implements IDigestTimedMetadata {
  @ApiProperty({
    enum: [DigestTypeEnum.TIMED],
  })
  type: DigestTypeEnum.TIMED;

  @ApiPropertyOptional()
  @ValidateNested()
  timed?: TimedConfig;
}

class DelayRegularMetadata extends AmountAndUnit implements IDelayRegularMetadata {
  @ApiProperty({
    enum: [DelayTypeEnum.REGULAR],
  })
  type: DelayTypeEnum.REGULAR;
}

class DelayScheduledMetadata implements IDelayScheduledMetadata {
  @ApiProperty({
    enum: [DelayTypeEnum.SCHEDULED],
  })
  type: DelayTypeEnum.SCHEDULED;

  @ApiProperty()
  delayPath: string;
}

// Define the ReplyCallback type with OpenAPI annotations
export class ReplyCallback {
  @ApiPropertyOptional({
    description: 'Indicates whether the reply callback is active.',
    type: Boolean,
  })
  @IsBoolean()
  active: boolean;

  @ApiPropertyOptional({
    description: 'The URL to which replies should be sent.',
    type: String,
  })
  @IsString()
  url: string;
}

@ApiExtraModels(DigestRegularMetadata, DigestTimedMetadata, DelayRegularMetadata, DelayScheduledMetadata)
export class NotificationStepData implements StepVariantDto {
  @ApiPropertyOptional({
    description: 'Unique identifier for the notification step.',
    type: String,
  })
  _id?: string;

  @ApiPropertyOptional({
    description: 'Universally unique identifier for the notification step.',
    type: String,
  })
  uuid?: string;

  @ApiPropertyOptional({
    description: 'Name of the notification step.',
    type: String,
  })
  name?: string;

  @ApiPropertyOptional({
    description: 'ID of the template associated with this notification step.',
    type: String,
  })
  _templateId?: string;

  @ApiPropertyOptional({
    description: 'Indicates whether the notification step is active.',
    type: Boolean,
  })
  @IsBoolean()
  active?: boolean;

  @ApiPropertyOptional({
    description: 'Determines if the process should stop on failure.',
    type: Boolean,
  })
  shouldStopOnFail?: boolean;

  @ApiPropertyOptional({
    description: 'Message template used in this notification step.',
    type: () => MessageTemplate, // Assuming MessageTemplate is a class
  })
  @ValidateNested()
  template?: MessageTemplate;

  @ApiPropertyOptional({
    description: 'Filters applied to this notification step.',
    type: [StepFilterDto],
  })
  @ValidateNested({ each: true })
  filters?: StepFilterDto[];

  @ApiPropertyOptional({
    description: 'ID of the parent notification step, if applicable.',
    type: String,
  })
  _parentId?: string | null;

  @ApiPropertyOptional({
    description: 'Metadata associated with the workflow step. Can vary based on the type of step.',
    oneOf: [
      { $ref: getSchemaPath(DigestRegularMetadata) },
      { $ref: getSchemaPath(DigestTimedMetadata) },
      { $ref: getSchemaPath(DelayRegularMetadata) },
      { $ref: getSchemaPath(DelayScheduledMetadata) },
    ],
  })
  metadata?: IWorkflowStepMetadata;

  @ApiPropertyOptional({
    description: 'Callback information for replies, including whether it is active and the callback URL.',
    type: () => ReplyCallback,
  })
  replyCallback?: ReplyCallback;
}

export class NotificationStepDto extends NotificationStepData {
  @ApiPropertyOptional({
    type: () => [NotificationStepData], // Specify that this is an array of NotificationStepData
  })
  @ValidateNested({ each: true }) // Validate each nested variant
  @Type(() => NotificationStepData) // Transform to NotificationStepData instances
  variants?: NotificationStepData[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ReplyCallback
- export class NotificationStepData
- export class NotificationStepDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/dtos/pagination-request.ts
Tamaño: 763 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional } from '@nestjs/swagger';
import { IPaginationParams } from '@novu/shared';
import { Type } from 'class-transformer';
import { IsInt, Max, Min } from 'class-validator';

import { Constructor } from '../types';

export function PaginationRequestDto(defaultLimit = 10, maxLimit = 100): Constructor<IPaginationParams> {
  class PaginationRequest {
    @ApiPropertyOptional({
      type: Number,
      required: false,
    })
    @Type(() => Number)
    @IsInt()
    page = 0;

    @ApiPropertyOptional({
      type: Number,
      required: false,
      default: defaultLimit,
      maximum: maxLimit,
    })
    @Type(() => Number)
    @IsInt()
    @Min(1)
    @Max(maxLimit)
    limit = defaultLimit;
  }

  return PaginationRequest;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - PaginationRequestDto(defaultLimit = 10, maxLimit = 100)
Asignaciones con arrow functions encontradas (posibles funciones):
 - maxLimit(100): Constructor<IPaginationParams> {
  class PaginationRequest {
    @ApiPropertyOptional({
      ...)
 - page(0;

    @ApiPropertyOptional({
      type: Number,
      required: false,
      default: defaultLimi...)
Declaraciones 'export' encontradas:
- export function PaginationRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/dtos/pagination-response.ts
Tamaño: 604 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IPaginatedResponseDto } from '@novu/shared';

export class PaginatedResponseDto<T> implements IPaginatedResponseDto<T> {
  @ApiProperty({
    description: 'The current page of the paginated response',
  })
  page: number;

  @ApiProperty({
    description: 'Does the list have more items to fetch',
  })
  hasMore: boolean;

  @ApiProperty({
    description: 'Number of items on each page',
  })
  pageSize: number;

  @ApiProperty({
    description: 'The list of items matching the query',
    isArray: true,
    type: Object,
  })
  data: T[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class PaginatedResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/dtos/pagination-with-filters-request.ts
Tamaño: 854 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional } from '@nestjs/swagger';
import { IPaginationWithQueryParams } from '@novu/shared';
import { IsOptional, IsString } from 'class-validator';

import { Constructor } from '../types';
import { PaginationRequestDto } from './pagination-request';

export function PaginationWithFiltersRequestDto({
  defaultLimit = 10,
  maxLimit = 100,
  queryDescription,
}: {
  defaultLimit: number;
  maxLimit: number;
  queryDescription: string;
}): Constructor<IPaginationWithQueryParams> {
  class PaginationWithFiltersRequest extends PaginationRequestDto(defaultLimit, maxLimit) {
    @ApiPropertyOptional({
      type: String,
      required: false,
      description: `A query string to filter the results. ${queryDescription}`,
    })
    @IsOptional()
    @IsString()
    query?: string;
  }

  return PaginationWithFiltersRequest;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - PaginationWithFiltersRequestDto({
  defaultLimit = 10,
  maxLimit = 100,
  queryDescription,
}: {
  defaultLimit: number;
  maxLimit: number;
  queryDescription: string;
})
Declaraciones 'export' encontradas:
- export function PaginationWithFiltersRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/dtos/preference-channels.ts
Tamaño: 987 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional } from '@nestjs/swagger';
import { IsBoolean, IsOptional } from 'class-validator';

export class SubscriberPreferenceChannels {
  @ApiPropertyOptional({
    type: Boolean,
    description: 'Email channel preference',
    example: true,
  })
  @IsBoolean()
  @IsOptional()
  email?: boolean;

  @ApiPropertyOptional({
    type: Boolean,
    description: 'SMS channel preference',
    example: false,
  })
  @IsBoolean()
  @IsOptional()
  sms?: boolean;

  @ApiPropertyOptional({
    type: Boolean,
    description: 'In-app channel preference',
    example: true,
  })
  @IsBoolean()
  @IsOptional()
  in_app?: boolean;

  @ApiPropertyOptional({
    type: Boolean,
    description: 'Chat channel preference',
    example: false,
  })
  @IsBoolean()
  @IsOptional()
  chat?: boolean;

  @ApiPropertyOptional({
    type: Boolean,
    description: 'Push notification channel preference',
    example: true,
  })
  @IsBoolean()
  @IsOptional()
  push?: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SubscriberPreferenceChannels

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/dtos/schedule.ts
Tamaño: 4445 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { IsBoolean, IsOptional, IsString, ValidateNested } from 'class-validator';
import { IsTime12HourFormat } from '../validators/is-time-12-hour-format.validator';
import { WeeklyScheduleValidation } from '../validators/weekly-schedule-disabled.validator';

export class TimeRangeDto {
  @ApiProperty({
    type: String,
    description: 'Start time',
    example: '09:00 AM',
  })
  @IsString()
  @IsTime12HourFormat()
  readonly start: string;

  @ApiProperty({
    type: String,
    description: 'End time',
    example: '05:00 PM',
  })
  @IsString()
  @IsTime12HourFormat()
  readonly end: string;
}
export class DayScheduleDto {
  @ApiProperty({
    type: Boolean,
    description: 'Day schedule enabled',
    example: true,
  })
  @IsBoolean()
  readonly isEnabled: boolean;

  @ApiPropertyOptional({
    type: [TimeRangeDto],
    description: 'Hours',
    example: [{ start: '09:00 AM', end: '05:00 PM' }],
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => TimeRangeDto)
  readonly hours?: TimeRangeDto[];
}

export class WeeklyScheduleDto {
  @ApiPropertyOptional({
    type: DayScheduleDto,
    description: 'Monday schedule',
    example: {
      isEnabled: true,
      hours: [{ start: '09:00 AM', end: '05:00 PM' }],
    },
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => DayScheduleDto)
  readonly monday?: DayScheduleDto;

  @ApiPropertyOptional({
    type: DayScheduleDto,
    description: 'Tuesday schedule',
    example: {
      isEnabled: true,
      hours: [{ start: '09:00 AM', end: '05:00 PM' }],
    },
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => DayScheduleDto)
  readonly tuesday?: DayScheduleDto;

  @ApiPropertyOptional({
    type: DayScheduleDto,
    description: 'Wednesday schedule',
    example: {
      isEnabled: true,
      hours: [{ start: '09:00 AM', end: '05:00 PM' }],
    },
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => DayScheduleDto)
  readonly wednesday?: DayScheduleDto;

  @ApiPropertyOptional({
    type: DayScheduleDto,
    description: 'Thursday schedule',
    example: {
      isEnabled: true,
      hours: [{ start: '09:00 AM', end: '05:00 PM' }],
    },
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => DayScheduleDto)
  readonly thursday?: DayScheduleDto;

  @ApiPropertyOptional({
    type: DayScheduleDto,
    description: 'Friday schedule',
    example: {
      isEnabled: true,
      hours: [{ start: '09:00 AM', end: '05:00 PM' }],
    },
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => DayScheduleDto)
  readonly friday?: DayScheduleDto;

  @ApiPropertyOptional({
    type: DayScheduleDto,
    description: 'Saturday schedule',
    example: {
      isEnabled: true,
      hours: [{ start: '09:00 AM', end: '05:00 PM' }],
    },
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => DayScheduleDto)
  readonly saturday?: DayScheduleDto;

  @ApiPropertyOptional({
    type: DayScheduleDto,
    description: 'Sunday schedule',
    example: {
      isEnabled: true,
      hours: [{ start: '09:00 AM', end: '05:00 PM' }],
    },
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => DayScheduleDto)
  readonly sunday?: DayScheduleDto;
}

export class ScheduleDto {
  @ApiProperty({
    type: Boolean,
    description: 'Schedule enabled',
    example: true,
  })
  @IsBoolean()
  readonly isEnabled: boolean;

  @ApiPropertyOptional({
    type: WeeklyScheduleDto,
    description: 'Weekly schedule',
    example: {
      monday: {
        isEnabled: true,
        hours: [{ start: '09:00 AM', end: '05:00 PM' }],
      },
      tuesday: {
        isEnabled: true,
        hours: [{ start: '09:00 AM', end: '05:00 PM' }],
      },
      wednesday: {
        isEnabled: true,
        hours: [{ start: '09:00 AM', end: '05:00 PM' }],
      },
      thursday: {
        isEnabled: true,
        hours: [{ start: '09:00 AM', end: '05:00 PM' }],
      },
      friday: {
        isEnabled: true,
        hours: [{ start: '09:00 AM', end: '05:00 PM' }],
      },
      saturday: {
        isEnabled: true,
        hours: [{ start: '09:00 AM', end: '05:00 PM' }],
      },
      sunday: {
        isEnabled: true,
        hours: [{ start: '09:00 AM', end: '05:00 PM' }],
      },
    },
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => WeeklyScheduleDto)
  @WeeklyScheduleValidation()
  readonly weeklySchedule?: WeeklyScheduleDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class TimeRangeDto
- export class DayScheduleDto
- export class WeeklyScheduleDto
- export class ScheduleDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/dtos/step-filter-dto.ts
Tamaño: 2980 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import {
  BuilderFieldOperator,
  BuilderFieldType,
  BuilderFieldTypeEnum,
  BuilderGroupValues,
  FilterPartTypeEnum,
  PreviousStepTypeEnum,
  TimeOperatorEnum,
} from '@novu/shared';

class BaseFilterPart {
  on: FilterPartTypeEnum;
}

class BaseFieldFilterPart extends BaseFilterPart {
  @ApiProperty()
  field: string;

  @ApiProperty()
  value: string;

  @ApiProperty({
    enum: [
      'LARGER',
      'SMALLER',
      'LARGER_EQUAL',
      'SMALLER_EQUAL',
      'EQUAL',
      'NOT_EQUAL',
      'ALL_IN',
      'ANY_IN',
      'NOT_IN',
      'BETWEEN',
      'NOT_BETWEEN',
      'LIKE',
      'NOT_LIKE',
      'IN',
    ],
  })
  operator: BuilderFieldOperator;
}

export class FieldFilterPartDto extends BaseFieldFilterPart {
  @ApiProperty({
    enum: [FilterPartTypeEnum.SUBSCRIBER, FilterPartTypeEnum.PAYLOAD],
  })
  on: FilterPartTypeEnum.SUBSCRIBER | FilterPartTypeEnum.PAYLOAD;
}

export class WebhookFilterPartDto extends BaseFieldFilterPart {
  @ApiProperty({
    enum: [FilterPartTypeEnum.WEBHOOK],
  })
  on: FilterPartTypeEnum.WEBHOOK;

  @ApiPropertyOptional()
  webhookUrl: string;
}

export class RealtimeOnlineFilterPartDto extends BaseFilterPart {
  @ApiProperty({
    enum: [FilterPartTypeEnum.IS_ONLINE],
  })
  on: FilterPartTypeEnum.IS_ONLINE;

  @ApiProperty()
  value: boolean;
}

export class OnlineInLastFilterPartDto extends BaseFilterPart {
  @ApiProperty({
    enum: [FilterPartTypeEnum.IS_ONLINE_IN_LAST],
  })
  on: FilterPartTypeEnum.IS_ONLINE_IN_LAST;

  @ApiProperty({
    enum: TimeOperatorEnum,
  })
  timeOperator: TimeOperatorEnum;

  @ApiProperty()
  value: number;
}

export class PreviousStepFilterPartDto extends BaseFilterPart {
  @ApiProperty({
    enum: [FilterPartTypeEnum.PREVIOUS_STEP],
  })
  on: FilterPartTypeEnum.PREVIOUS_STEP;

  @ApiProperty()
  step: string;

  @ApiProperty({
    enum: PreviousStepTypeEnum,
  })
  stepType: PreviousStepTypeEnum;
}

export class TenantFilterPartDto extends BaseFieldFilterPart {
  @ApiProperty({
    enum: [FilterPartTypeEnum.TENANT],
    description: 'Only on integrations right now',
  })
  on: FilterPartTypeEnum.TENANT;
}

export type FilterPartsDto =
  | FieldFilterPartDto
  | WebhookFilterPartDto
  | RealtimeOnlineFilterPartDto
  | OnlineInLastFilterPartDto
  | PreviousStepFilterPartDto
  | TenantFilterPartDto;

export class StepFilterDto {
  @ApiProperty()
  isNegated?: boolean;

  @ApiProperty({
    enum: ['BOOLEAN', 'TEXT', 'DATE', 'NUMBER', 'STATEMENT', 'LIST', 'MULTI_LIST', 'GROUP'],
    enumName: 'BuilderFieldTypeEnum',
  })
  type?: BuilderFieldType;

  @ApiProperty({
    enum: ['AND', 'OR'],
  })
  value: BuilderGroupValues;

  @ApiProperty({
    type: [
      FieldFilterPartDto,
      WebhookFilterPartDto,
      RealtimeOnlineFilterPartDto,
      OnlineInLastFilterPartDto,
      PreviousStepFilterPartDto,
      TenantFilterPartDto,
    ],
  })
  children: FilterPartsDto[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class FieldFilterPartDto
- export class WebhookFilterPartDto
- export class RealtimeOnlineFilterPartDto
- export class OnlineInLastFilterPartDto
- export class PreviousStepFilterPartDto
- export class TenantFilterPartDto
- export  type
- export class StepFilterDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/dtos/subscriber-channel.ts
Tamaño: 1617 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional } from '@nestjs/swagger';

export class ChannelCredentials {
  @ApiPropertyOptional({
    description:
      'Webhook URL used by chat app integrations. The webhook should be obtained from the chat app provider.',
    example: 'https://example.com/webhook',
    type: String,
  })
  webhookUrl?: string;

  @ApiPropertyOptional({
    description: 'Channel specification for Mattermost chat notifications.',
    example: 'general',
    type: String,
  })
  channel?: string;

  @ApiPropertyOptional({
    description: 'Contains an array of the subscriber device tokens for a given provider. Used on Push integrations.',
    example: ['token1', 'token2', 'token3'],
    type: [String],
  })
  deviceTokens?: string[];

  @ApiPropertyOptional({
    description: 'Alert UID for Grafana on-call webhook payload.',
    example: '12345-abcde',
    type: String,
  })
  alertUid?: string;

  @ApiPropertyOptional({
    description: 'Title to be used with Grafana on-call webhook.',
    example: 'Critical Alert',
    type: String,
  })
  title?: string;

  @ApiPropertyOptional({
    description: 'Image URL property for Grafana on-call webhook.',
    example: 'https://example.com/image.png',
    type: String,
  })
  imageUrl?: string;

  @ApiPropertyOptional({
    description: 'State property for Grafana on-call webhook.',
    example: 'resolved',
    type: String,
  })
  state?: string;

  @ApiPropertyOptional({
    description: 'Link to upstream details property for Grafana on-call webhook.',
    example: 'https://example.com/details',
    type: String,
  })
  externalUrl?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ChannelCredentials

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/dtos/widget-settings.ts
Tamaño: 138 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';

export class WidgetSettings {
  @ApiProperty()
  notificationCenterEncryption: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class WidgetSettings

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/errors/non-existing-file.error.ts
Tamaño: 164 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export class NonExistingFileError extends Error {
  constructor() {
    super('File not found for the key provided');
    this.name = 'NonExistingFileError';
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class NonExistingFileError

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/framework/analytics-logs.guard.ts
Tamaño: 2133 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
import { Reflector } from '@nestjs/core';

const LOG_ANALYTICS_KEY = 'logAnalytics';

/**
 * Analytics Logs Guard
 *
 * This guard sets the `_shouldLogAnalytics` flag on incoming requests early in the NestJS lifecycle.
 * It runs BEFORE interceptors, ensuring the flag is available even if interceptors throw exceptions.
 *
 * Why use a Guard instead of an Interceptor?
 * - Guards execute before interceptors in the NestJS request lifecycle
 * - If any interceptor throws an exception, subsequent interceptors never run, so the flag
 *   cannot be reliably set by an interceptor that might not execute
 * - By setting the flag in a guard, AllExceptionsFilter can always check for analytics logging
 *   regardless of which interceptor threw the exception
 * - AllExceptionsFilter cannot access decorator metadata directly since it operates outside
 *   the normal request lifecycle and doesn't have access to the original ExecutionContext
 *
 * Example execution order:
 * 1. Guard runs → sets _shouldLogAnalytics = true
 * 2. QuotaThrottlerInterceptor runs → throws exception
 * 3. AllExceptionsFilter runs → finds _shouldLogAnalytics = true → logs analytics
 */
@Injectable()
export class AnalyticsLogsGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const shouldLogAnalytics = this.shouldLogAnalytics(context);

    if (shouldLogAnalytics) {
      const request = context.switchToHttp().getRequest();
      request._shouldLogAnalytics = true;
    }

    // Always return true - this guard never blocks requests, it only sets metadata
    return true;
  }

  private shouldLogAnalytics(context: ExecutionContext): boolean {
    // Check if @LogAnalytics() decorator is present on the handler or controller
    const handlerMetadata = this.reflector.get(LOG_ANALYTICS_KEY, context.getHandler());
    const classMetadata = this.reflector.get(LOG_ANALYTICS_KEY, context.getClass());

    return handlerMetadata !== undefined || classMetadata !== undefined;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class AnalyticsLogsGuard

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/framework/analytics-logs.interceptor.ts
Tamaño: 5077 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  applyDecorators,
  CallHandler,
  ExecutionContext,
  Injectable,
  NestInterceptor,
  SetMetadata,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { PinoLogger, RequestLog, RequestLogRepository } from '@novu/application-generic';
import { UserSessionData } from '@novu/shared';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';
import { TriggerEventResponseDto } from '../../events/dtos/trigger-event-response.dto';
import { buildLog } from '../utils/mappers';

const LOG_ANALYTICS_KEY = 'logAnalytics';

export enum AnalyticsStrategyEnum {
  BASIC = 'basic',
  EVENTS = 'events',
  EVENTS_BULK = 'events_bulk',
}

export function LogAnalytics(strategy: AnalyticsStrategyEnum = AnalyticsStrategyEnum.BASIC): MethodDecorator {
  return applyDecorators(SetMetadata(LOG_ANALYTICS_KEY, strategy));
}

@Injectable()
export class AnalyticsLogsInterceptor implements NestInterceptor {
  constructor(
    private readonly requestLogRepository: RequestLogRepository,
    private readonly logger: PinoLogger,
    private readonly reflector: Reflector
  ) {
    this.logger.setContext(this.constructor.name);
  }

  private shouldLogAnalytics(context: ExecutionContext): boolean {
    const strategy = this.getAnalyticsStrategy(context);

    this.logger.debug(`Analytics logs should log strategy: ${strategy}`);

    return strategy !== undefined;
  }

  private getAnalyticsStrategy(context: ExecutionContext): AnalyticsStrategyEnum {
    const globalHandler = context.getHandler && Reflect.getMetadata(LOG_ANALYTICS_KEY, context.getHandler());
    const handlerMetadata = this.reflector.get(LOG_ANALYTICS_KEY, context.getHandler());
    const handler = context.getHandler();
    const customDecorator = handler && (handler as any)._analyticsStrategy;

    this.logger.debug(`Analytics logs globalHandler strategy: ${globalHandler}`);
    this.logger.debug(`Analytics logs handlerMetadata strategy: ${handlerMetadata}`);
    this.logger.debug(`Analytics logs customDecorator strategy: ${customDecorator}`);

    return globalHandler || handlerMetadata || customDecorator;
  }

  async intercept(context: ExecutionContext, next: CallHandler): Promise<Observable<any>> {
    const shouldRun = await this.shouldRun(context);

    this.logger.debug(`Analytics logs should run LOG_ANALYTICS_KEY: ${shouldRun}`);

    if (!shouldRun) {
      return next.handle();
    }

    const req = context.switchToHttp().getRequest();
    const user = req.user as UserSessionData;
    const start = Date.now();
    const res = context.switchToHttp().getResponse();

    this.logger.debug('Analytics logs interceptor started');

    return next.handle().pipe(
      tap(async (data) => {
        const duration = Date.now() - start;
        const basicLog = buildLog(req, res.statusCode, data, user, duration);
        if (!basicLog) {
          this.logger.warn('Analytics log construction failed - unable to track request metrics');

          return;
        }

        const analyticsLog = this.buildLogByStrategy(context, basicLog, data);

        try {
          this.logger.debug({ analyticsLog }, 'Analytics log Inserting');
          await this.requestLogRepository.create(analyticsLog, {
            organizationId: user?.organizationId,
            environmentId: user?.environmentId,
            userId: user?._id,
          });
          this.logger.debug('Analytics log Inserted');
        } catch (err) {
          this.logger.error({ err }, 'Failed to log analytics to ClickHouse after retries');
        }
      })
    );
  }

  private async shouldRun(context: ExecutionContext): Promise<boolean> {
    const shouldLog = this.shouldLogAnalytics(context);

    if (!shouldLog) return false;

    const isEnabled = process.env.IS_ANALYTICS_LOGS_ENABLED === 'true';

    this.logger.debug(
      `Analytics logs should run IS_ANALYTICS_LOGS_ENABLED: ${process.env.IS_ANALYTICS_LOGS_ENABLED}, isEnabled: ${isEnabled}`
    );

    if (!isEnabled) return false;

    return true;
  }

  private buildLogByStrategy(
    context: ExecutionContext,
    analyticsLog: Omit<RequestLog, 'expires_at'>,
    res: unknown
  ): Omit<RequestLog, 'expires_at'> {
    const strategy = this.getAnalyticsStrategy(context);

    if (strategy === AnalyticsStrategyEnum.EVENTS) {
      const eventResponse = (res as any).data as TriggerEventResponseDto;

      if (eventResponse.transactionId) {
        return {
          ...analyticsLog,
          transaction_id: eventResponse.transactionId,
        };
      }
    }

    if (strategy === AnalyticsStrategyEnum.EVENTS_BULK) {
      const bulkEventResponse = (res as any).data as TriggerEventResponseDto[];

      if (Array.isArray(bulkEventResponse)) {
        const transactionIds = bulkEventResponse
          .map((response) => response.transactionId)
          .filter(Boolean)
          .join(',');

        if (transactionIds) {
          return {
            ...analyticsLog,
            transaction_id: transactionIds,
          };
        }
      }
    }

    return analyticsLog;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - LogAnalytics(strategy: AnalyticsStrategyEnum = AnalyticsStrategyEnum.BASIC)
Asignaciones con arrow functions encontradas (posibles funciones):
 - res(context.switchToHttp().getResponse();

    this.logger.debug('Analytics logs interceptor started');
...)
 - transactionIds(bulkEventResponse
          .map((response))
Declaraciones 'export' encontradas:
- export  enum
- export function LogAnalytics
- export class AnalyticsLogsInterceptor

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/framework/exclude-from-idempotency.ts
Tamaño: 249 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { applyDecorators, SetMetadata } from '@nestjs/common';

export const EXCLUDE_FROM_IDEMPOTENCY = 'exclude_from_idempotency';

export function ExcludeFromIdempotency() {
  return applyDecorators(SetMetadata(EXCLUDE_FROM_IDEMPOTENCY, true));
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - ExcludeFromIdempotency()
Declaraciones 'export' encontradas:
- export  const
- export function ExcludeFromIdempotency

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/framework/idempotency.e2e.ts
Tamaño: 8690 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CacheService, HttpResponseHeaderKeysEnum } from '@novu/application-generic';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import {
  IdempotenceTestingResponse,
  IdempotencyBehaviorEnum,
  IdempotencyTestingDto,
} from '../../testing/dtos/idempotency.dto';
import { expectSdkExceptionGeneric } from '../helpers/e2e/sdk/e2e-sdk.helper';

const DOCS_LINK = 'https://docs.novu.co/additional-resources/idempotency';
// @ts-ignore
process.env.LAUNCH_DARKLY_SDK_KEY = ''; // disable Launch Darkly to allow test to define FF state

const idempotancyKey = HttpResponseHeaderKeysEnum.IDEMPOTENCY_KEY.toLowerCase();
const retryAfterHeaderKey = HttpResponseHeaderKeysEnum.RETRY_AFTER.toLowerCase();
const IDEMPOTENCE_IMMEDIATE_EXCEPTION = {
  expectedBehavior: IdempotencyBehaviorEnum.IMMEDIATE_EXCEPTION,
};
const IDEMPOTENCE_IMMEDIATE_RESPONSE = {
  expectedBehavior: IdempotencyBehaviorEnum.IMMEDIATE_RESPONSE,
};
const IDEMPOTENCE_DELAYED_RESPONSE = {
  expectedBehavior: IdempotencyBehaviorEnum.DELAYED_RESPONSE,
};
const idempotancyReplayKey = HttpResponseHeaderKeysEnum.IDEMPOTENCY_REPLAY.toLowerCase();

describe('Idempotency Test', async () => {
  let session: UserSession;
  const path = '/v1/health-check/test-idempotency';
  let cacheService: CacheService | null = null;

  async function testIdempotencyPost(
    idempotencyTestingDto: IdempotencyTestingDto,
    key: string
  ): Promise<{ body: IdempotenceTestingResponse; headers: Record<string, string> }> {
    const { body, headers } = await session.testAgent
      .post(path)
      .set(HttpResponseHeaderKeysEnum.IDEMPOTENCY_KEY, key)
      .set('authorization', `ApiKey ${session.apiKey}`)
      .send(idempotencyTestingDto);

    return { body: body.data, headers };
  }
  async function testIdempotencyGet(
    key: string
  ): Promise<{ body: IdempotenceTestingResponse; headers: Record<string, string> }> {
    const { body, headers } = await session.testAgent
      .get(path)
      .set(HttpResponseHeaderKeysEnum.IDEMPOTENCY_KEY, key)
      .set('authorization', `ApiKey ${session.apiKey}`)
      .send();

    return { body: body.data, headers };
  }

  before(async () => {
    session = new UserSession();
    await session.initialize();
    cacheService = session.testServer?.getService(CacheService);
    process.env.IS_API_IDEMPOTENCY_ENABLED = 'true';
  });

  it('should return cached same response for duplicate requests', async () => {
    const key = `IdempotencyKey1`;
    const res1 = await testIdempotencyPost(IDEMPOTENCE_IMMEDIATE_RESPONSE, key);
    const res2 = await testIdempotencyPost(IDEMPOTENCE_IMMEDIATE_RESPONSE, key);
    expect(res1.body.number).to.equal(res2.body.number);
    expect(res1.headers[idempotancyKey]).to.eq(key);
    expect(res2.headers[idempotancyKey]).to.eq(key);
    expect(res2.headers[idempotancyReplayKey]).to.eq('true');
  });
  it('should return cached and use correct cache key when apiKey is used', async () => {
    const key = `IdempotencyKey2`;
    const res1 = await testIdempotencyPost(IDEMPOTENCE_IMMEDIATE_RESPONSE, key);
    const cacheKey = `test-${session.organization._id}-${key}`;
    session.testServer?.getHttpServer();

    const cacheVal = JSON.stringify(JSON.parse(await cacheService?.get(cacheKey)!).data);
    expect(res1.body.number, cacheVal).to.eq(JSON.parse(cacheVal).data.number);
    const res2 = await testIdempotencyPost(IDEMPOTENCE_IMMEDIATE_RESPONSE, key);
    expect(res1.body.number).to.equal(res2.body.number);
    expect(res1.headers[idempotancyKey]).to.eq(key);
    expect(res2.headers[idempotancyKey]).to.eq(key);
    expect(res2.headers[idempotancyReplayKey]).to.eq('true');
  });
  it('should return cached and use correct cache key when authToken and apiKey combination is used', async () => {
    const key = `3`;
    const res1 = await testIdempotencyPost(IDEMPOTENCE_IMMEDIATE_RESPONSE, key);
    const cacheKey = `test-${session.organization._id}-${key}`;
    session.testServer?.getHttpServer();

    const cacheVal = JSON.stringify(JSON.parse(await cacheService?.get(cacheKey)!).data);
    expect(res1.body.number).to.eq(JSON.parse(cacheVal).data.number);
    const res2 = await testIdempotencyPost(IDEMPOTENCE_IMMEDIATE_RESPONSE, key);
    expect(res1.body.number).to.equal(res2.body.number);
    expect(res1.headers[idempotancyKey]).to.eq(key);
    expect(res2.headers[idempotancyKey]).to.eq(key);
    expect(res2.headers[idempotancyReplayKey]).to.eq('true');
  });
  it('should return conflict when concurrent requests are made', async () => {
    const key = `4`;
    const [{ headers, body, status }, { headers: headerDupe, body: bodyDupe, status: statusDupe }] = await Promise.all([
      session.testAgent
        .post(path)
        .set(HttpResponseHeaderKeysEnum.IDEMPOTENCY_KEY, key)
        .send(IDEMPOTENCE_DELAYED_RESPONSE),
      session.testAgent
        .post(path)
        .set(HttpResponseHeaderKeysEnum.IDEMPOTENCY_KEY, key)
        .send(IDEMPOTENCE_DELAYED_RESPONSE),
    ]);
    const oneSuccess = status === 201 || statusDupe === 201;
    const oneConflict = status === 409 || statusDupe === 409;
    const conflictBody = status === 201 ? bodyDupe : body;
    const retryHeader = headers[retryAfterHeaderKey] || headerDupe[retryAfterHeaderKey];
    expect(oneSuccess).to.be.true;
    expect(oneConflict).to.be.true;
    expect(headers[idempotancyKey]).to.eq(key);
    expect(headerDupe[idempotancyKey], JSON.stringify(headerDupe)).to.eq(key);
    expect(headerDupe[HttpResponseHeaderKeysEnum.LINK.toLowerCase()], JSON.stringify(headerDupe)).to.eq(DOCS_LINK);
    expect(retryHeader).to.eq(`1`);
    expect(conflictBody.message).to.eq(
      `Request with key "${key}" is currently being processed. Please retry after 1 second`
    );
    expect(conflictBody.error).to.eq('Conflict');
    expect(conflictBody.statusCode).to.eq(409);
  });
  it('should return UnprocessableEntity when different body is sent for same key', async () => {
    const key = '5';
    await testIdempotencyPost(IDEMPOTENCE_IMMEDIATE_RESPONSE, key);
    const { error } = await expectSdkExceptionGeneric(() => testIdempotencyPost(IDEMPOTENCE_IMMEDIATE_EXCEPTION, key));
    expect(error?.statusCode).to.eq(422);
  });
  it('should return non cached response for unique requests', async () => {
    const key = '6';
    const key1 = '7';
    const response = await testIdempotencyPost(IDEMPOTENCE_IMMEDIATE_RESPONSE, key);
    const response2 = await testIdempotencyPost(IDEMPOTENCE_IMMEDIATE_RESPONSE, key1);
    expect(response.body.number).to.not.eq(response2.body.number);
    expect(response.headers[idempotancyKey]).to.eq(key);
    expect(response2.headers[idempotancyKey]).to.eq(key1);
  });
  it('should return non cached response for GET requests', async () => {
    const key = '8';
    const response = await testIdempotencyGet(key);
    const response2 = await testIdempotencyGet(key);
    expect(response.body.number).to.not.eq(response2.body.number);
  });
  it('should return cached error response for duplicate requests', async () => {
    const key = '9';
    const { error } = await expectSdkExceptionGeneric(() => testIdempotencyPost(IDEMPOTENCE_IMMEDIATE_EXCEPTION, key));
    const { error: error2 } = await expectSdkExceptionGeneric(() =>
      testIdempotencyPost(IDEMPOTENCE_IMMEDIATE_EXCEPTION, key)
    );
    expect(error?.message).to.eq(error2?.message);
  });
  it('should return 400 when key bigger than allowed limit', async () => {
    const key = Array.from({ length: 256 })
      .fill(0)
      .map((i) => i)
      .join('');
    const { error } = await expectSdkExceptionGeneric(() => testIdempotencyPost(IDEMPOTENCE_IMMEDIATE_EXCEPTION, key));
    expect(error?.statusCode).to.eq(400);
    expect(error?.message).to.include(`has exceeded`);
  });

  describe('Allowed Authentication Security Schemes', () => {
    it('should set Idempotency-Key header when ApiKey security scheme is used to authenticate', async () => {
      const key = '10';
      const { headers } = await testIdempotencyPost(IDEMPOTENCE_IMMEDIATE_RESPONSE, key);
      expect(headers[idempotancyKey]).to.exist;
    });

    it('should set rate limit headers when a Bearer security scheme is used to authenticate', async () => {
      const key = '10';
      const { headers } = await testIdempotencyPost(IDEMPOTENCE_IMMEDIATE_RESPONSE, key);
      expect(headers[idempotancyKey]).to.exist;
    });

    it('should NOT set rate limit headers when NO authorization header is present', async () => {
      const key = '10';
      const { headers } = await testIdempotencyPost(IDEMPOTENCE_IMMEDIATE_RESPONSE, key);
      expect(headers[idempotancyKey]).not.to.exist;
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - testIdempotencyPost(idempotencyTestingDto: IdempotencyTestingDto,
    key: string)
 - testIdempotencyGet(key: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - idempotancyReplayKey(HttpResponseHeaderKeysEnum.IDEMPOTENCY_REPLAY.toLowerCase();

describe('Idempotency Test', async ())
 - IS_API_IDEMPOTENCY_ENABLED('true';
  });

  it('should return cached same response for duplicate requests', async ())
 - res2(await testIdempotencyPost(IDEMPOTENCE_IMMEDIATE_RESPONSE, key);
    expect(res1.body.number).to.equa...)
 - res2(await testIdempotencyPost(IDEMPOTENCE_IMMEDIATE_RESPONSE, key);
    expect(res1.body.number).to.equa...)
 - res2(await testIdempotencyPost(IDEMPOTENCE_IMMEDIATE_RESPONSE, key);
    expect(res1.body.number).to.equa...)
 - retryHeader(headers[retryAfterHeaderKey] || headerDupe[retryAfterHeaderKey];
    expect(oneSuccess).to.be.true;
...)
 - response2(await testIdempotencyPost(IDEMPOTENCE_IMMEDIATE_RESPONSE, key1);
    expect(response.body.number).to...)
 - response2(await testIdempotencyGet(key);
    expect(response.body.number).to.not.eq(response2.body.number);
  ...)
 - key(Array.from({ length: 256 })
      .fill(0)
      .map((i))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/framework/idempotency.interceptor.ts
Tamaño: 9231 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  BadRequestException,
  CallHandler,
  ConflictException,
  ExecutionContext,
  HttpException,
  Injectable,
  InternalServerErrorException,
  NestInterceptor,
  ServiceUnavailableException,
  UnprocessableEntityException,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import {
  CacheService,
  FeatureFlagsService,
  HttpResponseHeaderKeysEnum,
  Instrument,
  PinoLogger,
} from '@novu/application-generic';
import { ApiAuthSchemeEnum, FeatureFlagsKeysEnum, UserSessionData } from '@novu/shared';
import { createHash } from 'crypto';
import { Observable, of, throwError } from 'rxjs';
import { catchError, map } from 'rxjs/operators';
import { EXCLUDE_FROM_IDEMPOTENCY } from './exclude-from-idempotency';

const IDEMPOTENCY_CACHE_TTL = 60 * 60 * 24; // 24h
const IDEMPOTENCY_PROGRESS_TTL = 60 * 5; // 5min

enum ReqStatusEnum {
  PROGRESS = 'in-progress',
  SUCCESS = 'success',
  ERROR = 'error',
}

export const DOCS_LINK = 'https://docs.novu.co/additional-resources/idempotency';
export const ALLOWED_AUTH_SCHEMES = [ApiAuthSchemeEnum.API_KEY];
const ALLOWED_METHODS = ['post', 'patch'];

@Injectable()
export class IdempotencyInterceptor implements NestInterceptor {
  constructor(
    private readonly reflector: Reflector,
    private readonly cacheService: CacheService,
    private featureFlagService: FeatureFlagsService,
    private logger: PinoLogger
  ) {
    this.logger.setContext(this.constructor.name);
  }

  protected async isEnabled(context: ExecutionContext): Promise<boolean> {
    const isExcluded = this.reflector.getAllAndOverride<boolean>(EXCLUDE_FROM_IDEMPOTENCY, [
      context.getHandler(),
      context.getClass(),
    ]);
    if (isExcluded) {
      return false;
    }

    const isAllowedAuthScheme = this.isAllowedAuthScheme(context);
    if (!isAllowedAuthScheme) {
      return true;
    }

    const user = this.getReqUser(context);
    const { organizationId, environmentId, _id } = user;

    return await this.featureFlagService.getFlag({
      key: FeatureFlagsKeysEnum.IS_API_IDEMPOTENCY_ENABLED,
      defaultValue: false,
      environment: { _id: environmentId },
      organization: { _id: organizationId },
      user: { _id },
    });
  }

  @Instrument()
  async intercept(context: ExecutionContext, next: CallHandler): Promise<Observable<any>> {
    const request = context.switchToHttp().getRequest();
    const isAllowedMethod = ALLOWED_METHODS.includes(request.method.toLowerCase());
    const idempotencyKey = this.getIdempotencyKey(context);
    const isEnabled = await this.isEnabled(context);
    if (!idempotencyKey || !isAllowedMethod || !isEnabled) {
      return next.handle();
    }

    if (idempotencyKey?.length > 255) {
      return throwError(
        () =>
          new BadRequestException(
            `idempotencyKey "${idempotencyKey}" has exceeded the maximum allowed length of 255 characters`
          )
      );
    }
    const cacheKey = this.getCacheKey(context);

    try {
      const bodyHash = this.hashRequestBody(request.body);
      // if 1st time we are seeing the request, marks the request as in-progress if not, does nothing
      const isNewReq = await this.setCache(
        cacheKey,
        { status: ReqStatusEnum.PROGRESS, bodyHash },
        IDEMPOTENCY_PROGRESS_TTL,
        true
      );
      // Check if the idempotency key is in the cache
      if (isNewReq) {
        return await this.handleNewRequest(context, next, bodyHash);
      } else {
        return await this.handlerDuplicateRequest(context, bodyHash);
      }
    } catch (err) {
      this.logger.warn(
        `An error occurred while making idempotency check, key:${idempotencyKey}. error: ${err.message}`
      );
      if (err instanceof HttpException) {
        return throwError(() => err);
      }
    }

    // something unexpected happened, both cached response and handler did not execute as expected
    return throwError(() => new ServiceUnavailableException());
  }

  private getIdempotencyKey(context: ExecutionContext): string | undefined {
    const request = context.switchToHttp().getRequest();

    return request.headers[HttpResponseHeaderKeysEnum.IDEMPOTENCY_KEY.toLocaleLowerCase()];
  }

  private getReqUser(context: ExecutionContext): UserSessionData {
    const req = context.switchToHttp().getRequest();

    return req.user;
  }

  private isAllowedAuthScheme(context: ExecutionContext): boolean {
    const req = context.switchToHttp().getRequest();
    const { authScheme } = req;

    return ALLOWED_AUTH_SCHEMES.some((scheme) => authScheme === scheme);
  }

  private getCacheKey(context: ExecutionContext): string {
    const user = this.getReqUser(context);
    if (user === undefined) {
      const message = 'Cannot build idempotency cache key without user';
      this.logger.error(message);
      throw new InternalServerErrorException(message);
    }
    const env = process.env.NODE_ENV;

    return `${env}-${user.organizationId}-${this.getIdempotencyKey(context)}`;
  }

  async setCache(
    key: string,
    val: { status: ReqStatusEnum; bodyHash: string; data?: any; statusCode?: number },
    ttl: number,
    ifNotExists?: boolean
  ): Promise<string | null> {
    try {
      if (ifNotExists) {
        return await this.cacheService.setIfNotExist(key, JSON.stringify(val), { ttl });
      }
      await this.cacheService.set(key, JSON.stringify(val), { ttl });
    } catch (err) {
      this.logger.warn(`An error occurred while setting idempotency cache, key:${key} error: ${err.message}`);
    }

    return null;
  }

  private setHeaders(response: any, headers: Record<string, string>) {
    Object.keys(headers).forEach((key) => {
      if (headers[key]) {
        response.set(key, headers[key]);
      }
    });
  }

  private hashRequestBody(body: object): string {
    const hash = createHash('blake2s256');
    hash.update(Buffer.from(JSON.stringify(body)));

    return hash.digest('hex');
  }

  private async handlerDuplicateRequest(context: ExecutionContext, bodyHash: string): Promise<Observable<any>> {
    const cacheKey = this.getCacheKey(context);
    const idempotencyKey = this.getIdempotencyKey(context)!;
    const data = await this.cacheService.get(cacheKey);
    this.setHeaders(context.switchToHttp().getResponse(), {
      [HttpResponseHeaderKeysEnum.IDEMPOTENCY_KEY]: idempotencyKey,
    });
    const parsed = JSON.parse(data);
    if (parsed.status === ReqStatusEnum.PROGRESS) {
      // api call is in progress, so client need to handle this case
      this.logger.trace(`previous api call in progress rejecting the request. key: "${idempotencyKey}"`);
      this.setHeaders(context.switchToHttp().getResponse(), {
        [HttpResponseHeaderKeysEnum.RETRY_AFTER]: `1`,
        [HttpResponseHeaderKeysEnum.LINK]: DOCS_LINK,
      });

      throw new ConflictException(
        `Request with key "${idempotencyKey}" is currently being processed. Please retry after 1 second`
      );
    }
    if (bodyHash !== parsed.bodyHash) {
      // different body sent than before
      this.logger.trace(`idempotency key is being reused for different bodies. key: "${idempotencyKey}"`);
      this.setHeaders(context.switchToHttp().getResponse(), {
        [HttpResponseHeaderKeysEnum.LINK]: DOCS_LINK,
      });

      throw new UnprocessableEntityException(
        `Request with key "${idempotencyKey}" is being reused for a different body`
      );
    }
    this.setHeaders(context.switchToHttp().getResponse(), { [HttpResponseHeaderKeysEnum.IDEMPOTENCY_REPLAY]: 'true' });

    // already seen the request return cached response
    if (parsed.status === ReqStatusEnum.ERROR) {
      this.logger.trace(`returning cached error response. key: "${idempotencyKey}"`);

      throw parsed.data;
    }

    return of(parsed.data);
  }

  private async handleNewRequest(
    context: ExecutionContext,
    next: CallHandler,
    bodyHash: string
  ): Promise<Observable<any>> {
    const cacheKey = this.getCacheKey(context);
    const idempotencyKey = this.getIdempotencyKey(context)!;

    return next.handle().pipe(
      map(async (response) => {
        const httpResponse = context.switchToHttp().getResponse();
        const { statusCode } = httpResponse;

        // Cache the success response and return it
        await this.setCache(
          cacheKey,
          { status: ReqStatusEnum.SUCCESS, bodyHash, statusCode, data: response },
          IDEMPOTENCY_CACHE_TTL
        );
        this.logger.trace(`cached the success response for idempotency key: "${idempotencyKey}"`);
        this.setHeaders(httpResponse, { [HttpResponseHeaderKeysEnum.IDEMPOTENCY_KEY]: idempotencyKey });

        return response;
      }),
      catchError((err) => {
        this.setCache(
          cacheKey,
          {
            status: ReqStatusEnum.ERROR,
            bodyHash,
            data: err,
          },
          IDEMPOTENCY_CACHE_TTL
        ).catch(() => {});
        this.logger.trace(`cached the error response for idempotency key: "${idempotencyKey}"`);
        this.setHeaders(context.switchToHttp().getResponse(), {
          [HttpResponseHeaderKeysEnum.IDEMPOTENCY_KEY]: idempotencyKey,
        });

        throw err;
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - isEnabled(await this.isEnabled(context);
    if (!idempotencyKey || !isAllowedMethod || !isEnabled) {
      re...)
 - isNewReq(await this.setCache(
        cacheKey,
        { status: ReqStatusEnum.PROGRESS, bodyHash },
       ...)
 - env(process.env.NODE_ENV;

    return `${env}-${user.organizationId}-${this.getIdempotencyKey(context)}`...)
 - idempotencyKey(this.getIdempotencyKey(context)!;

    return next.handle().pipe(
      map(async (response))
Declaraciones 'export' encontradas:
- export  const
- export  const
- export class IdempotencyInterceptor

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/framework/paginated-ok-response.decorator.ts
Tamaño: 740 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { applyDecorators, Type } from '@nestjs/common';
import { ApiExtraModels, getSchemaPath } from '@nestjs/swagger';
import { PaginatedResponseDto } from '../dtos/pagination-response';
import { ApiOkResponse } from './response.decorator';

export const ApiOkPaginatedResponse = <DataDto extends Type<unknown>>(dataDto: DataDto) =>
  applyDecorators(
    ApiExtraModels(PaginatedResponseDto, dataDto),
    ApiOkResponse({
      schema: {
        allOf: [
          { $ref: getSchemaPath(PaginatedResponseDto) },
          {
            properties: {
              data: {
                type: 'array',
                items: { $ref: getSchemaPath(dataDto) },
              },
            },
          },
        ],
      },
    })
  );


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - ApiOkPaginatedResponse(<DataDto extends Type<unknown>>(dataDto: DataDto))
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/framework/response.decorator.ts
Tamaño: 12144 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { applyDecorators, Type } from '@nestjs/common';
import {
  ApiExpectationFailedResponse,
  ApiExtraModels,
  ApiHttpVersionNotSupportedResponse,
  ApiLengthRequiredResponse,
  ApiNonAuthoritativeInformationResponse,
  ApiNotModifiedResponse,
  ApiPartialContentResponse,
  ApiPaymentRequiredResponse,
  ApiPermanentRedirectResponse,
  ApiProxyAuthenticationRequiredResponse,
  ApiRequestedRangeNotSatisfiableResponse,
  ApiResetContentResponse,
  ApiResponseOptions,
  ApiSeeOtherResponse,
  ApiUriTooLongResponse,
  getSchemaPath,
} from '@nestjs/swagger';
import { ErrorDto, ValidationErrorDto } from '../../../error-dto';
import { DataWrapperDto } from '../dtos/data-wrapper-dto';
import { COMMON_RESPONSES } from './constants/responses.schema';
import { customResponseDecorators } from './swagger/responses.decorator';

export const { ApiOkResponse }: { ApiOkResponse: (options?: ApiResponseOptions) => MethodDecorator } =
  customResponseDecorators;
export const { ApiCreatedResponse }: { ApiCreatedResponse: (options?: ApiResponseOptions) => MethodDecorator } =
  customResponseDecorators;
export const { ApiAcceptedResponse }: { ApiAcceptedResponse: (options?: ApiResponseOptions) => MethodDecorator } =
  customResponseDecorators;
export const { ApiNoContentResponse }: { ApiNoContentResponse: (options?: ApiResponseOptions) => MethodDecorator } =
  customResponseDecorators;
export const {
  ApiMovedPermanentlyResponse,
}: { ApiMovedPermanentlyResponse: (options?: ApiResponseOptions) => MethodDecorator } = customResponseDecorators;
export const {
  ApiTemporaryRedirectResponse,
}: { ApiTemporaryRedirectResponse: (options?: ApiResponseOptions) => MethodDecorator } = customResponseDecorators;
export const { ApiFoundResponse }: { ApiFoundResponse: (options?: ApiResponseOptions) => MethodDecorator } =
  customResponseDecorators;
export const { ApiBadRequestResponse }: { ApiBadRequestResponse: (options?: ApiResponseOptions) => MethodDecorator } =
  customResponseDecorators;
export const {
  ApiUnauthorizedResponse,
}: { ApiUnauthorizedResponse: (options?: ApiResponseOptions) => MethodDecorator } = customResponseDecorators;
export const {
  ApiTooManyRequestsResponse,
}: { ApiTooManyRequestsResponse: (options?: ApiResponseOptions) => MethodDecorator } = customResponseDecorators;
export const { ApiNotFoundResponse }: { ApiNotFoundResponse: (options?: ApiResponseOptions) => MethodDecorator } =
  customResponseDecorators;
export const {
  ApiInternalServerErrorResponse,
}: { ApiInternalServerErrorResponse: (options?: ApiResponseOptions) => MethodDecorator } = customResponseDecorators;
export const { ApiBadGatewayResponse }: { ApiBadGatewayResponse: (options?: ApiResponseOptions) => MethodDecorator } =
  customResponseDecorators;
export const { ApiConflictResponse }: { ApiConflictResponse: (options?: ApiResponseOptions) => MethodDecorator } =
  customResponseDecorators;
export const { ApiForbiddenResponse }: { ApiForbiddenResponse: (options?: ApiResponseOptions) => MethodDecorator } =
  customResponseDecorators;
export const {
  ApiGatewayTimeoutResponse,
}: { ApiGatewayTimeoutResponse: (options?: ApiResponseOptions) => MethodDecorator } = customResponseDecorators;
export const { ApiGoneResponse }: { ApiGoneResponse: (options?: ApiResponseOptions) => MethodDecorator } =
  customResponseDecorators;
export const {
  ApiMethodNotAllowedResponse,
}: { ApiMethodNotAllowedResponse: (options?: ApiResponseOptions) => MethodDecorator } = customResponseDecorators;
export const {
  ApiNotAcceptableResponse,
}: { ApiNotAcceptableResponse: (options?: ApiResponseOptions) => MethodDecorator } = customResponseDecorators;
export const {
  ApiNotImplementedResponse,
}: { ApiNotImplementedResponse: (options?: ApiResponseOptions) => MethodDecorator } = customResponseDecorators;
export const {
  ApiPreconditionFailedResponse,
}: { ApiPreconditionFailedResponse: (options?: ApiResponseOptions) => MethodDecorator } = customResponseDecorators;
export const {
  ApiPayloadTooLargeResponse,
}: { ApiPayloadTooLargeResponse: (options?: ApiResponseOptions) => MethodDecorator } = customResponseDecorators;
export const {
  ApiRequestTimeoutResponse,
}: { ApiRequestTimeoutResponse: (options?: ApiResponseOptions) => MethodDecorator } = customResponseDecorators;
export const {
  ApiServiceUnavailableResponse,
}: { ApiServiceUnavailableResponse: (options?: ApiResponseOptions) => MethodDecorator } = customResponseDecorators;
export const {
  ApiUnprocessableEntityResponse,
}: { ApiUnprocessableEntityResponse: (options?: ApiResponseOptions) => MethodDecorator } = customResponseDecorators;
export const {
  ApiUnsupportedMediaTypeResponse,
}: { ApiUnsupportedMediaTypeResponse: (options?: ApiResponseOptions) => MethodDecorator } = customResponseDecorators;
export const { ApiDefaultResponse }: { ApiDefaultResponse: (options?: ApiResponseOptions) => MethodDecorator } =
  customResponseDecorators;

function buildEnvelopeProperties<DataDto extends Type<unknown>>(isResponseArray: boolean, dataDto: DataDto) {
  if (isResponseArray) {
    return {
      data: {
        type: 'array',
        items: { $ref: getSchemaPath(dataDto) },
      },
    };
  } else {
    return { data: { $ref: getSchemaPath(dataDto) } };
  }
}

function buildSchema<DataDto extends Type<unknown>>(
  shouldEnvelope: boolean,
  isResponseArray: boolean,
  dataDto: DataDto
) {
  if (shouldEnvelope) {
    return {
      properties: buildEnvelopeProperties(isResponseArray, dataDto),
    };
  }

  return { $ref: getSchemaPath(dataDto) };
}
export const ApiResponse = <DataDto extends Type<unknown>>(
  dataDto: DataDto,
  statusCode: number = 200,
  isResponseArray = false,
  shouldEnvelope = true,
  options?: ApiResponseOptions
) => {
  let responseDecoratorFunction;
  let description = 'Ok'; // Default description

  switch (statusCode) {
    // 2XX Success
    case 200:
      responseDecoratorFunction = ApiOkResponse;
      description = 'OK';
      break;
    case 201:
      responseDecoratorFunction = ApiCreatedResponse;
      description = 'Created';
      break;
    case 202:
      responseDecoratorFunction = ApiAcceptedResponse;
      description = 'Accepted';
      break;
    case 203:
      responseDecoratorFunction = ApiNonAuthoritativeInformationResponse;
      description = 'Non-Authoritative Information';
      break;
    case 204:
      responseDecoratorFunction = ApiNoContentResponse;
      description = 'No Content';
      break;
    case 205:
      responseDecoratorFunction = ApiResetContentResponse;
      description = 'Reset Content';
      break;
    case 206:
      responseDecoratorFunction = ApiPartialContentResponse;
      description = 'Partial Content';
      break;

    // 3XX Redirection
    case 301:
      responseDecoratorFunction = ApiMovedPermanentlyResponse;
      description = 'Moved Permanently';
      break;
    case 302:
      responseDecoratorFunction = ApiFoundResponse;
      description = 'Found';
      break;
    case 303:
      responseDecoratorFunction = ApiSeeOtherResponse;
      description = 'See Other';
      break;
    case 304:
      responseDecoratorFunction = ApiNotModifiedResponse;
      description = 'Not Modified';
      break;
    case 305:
      responseDecoratorFunction = ApiProxyAuthenticationRequiredResponse;
      description = 'Use Proxy';
      break;
    case 307:
      responseDecoratorFunction = ApiTemporaryRedirectResponse;
      description = 'Temporary Redirect';
      break;
    case 308:
      responseDecoratorFunction = ApiPermanentRedirectResponse;
      description = 'Permanent Redirect';
      break;

    // 4XX Client Errors
    case 400:
      responseDecoratorFunction = ApiBadRequestResponse;
      description = 'Bad Request';
      break;
    case 401:
      responseDecoratorFunction = ApiUnauthorizedResponse;
      description = 'Unauthorized';
      break;
    case 402:
      responseDecoratorFunction = ApiPaymentRequiredResponse;
      description = 'Payment Required';
      break;
    case 403:
      responseDecoratorFunction = ApiForbiddenResponse;
      description = 'Forbidden';
      break;
    case 404:
      responseDecoratorFunction = ApiNotFoundResponse;
      description = 'Not Found';
      break;
    case 405:
      responseDecoratorFunction = ApiMethodNotAllowedResponse;
      description = 'Method Not Allowed';
      break;
    case 406:
      responseDecoratorFunction = ApiNotAcceptableResponse;
      description = 'Not Acceptable';
      break;
    case 407:
      responseDecoratorFunction = ApiProxyAuthenticationRequiredResponse;
      description = 'Proxy Authentication Required';
      break;
    case 408:
      responseDecoratorFunction = ApiRequestTimeoutResponse;
      description = 'Request Timeout';
      break;
    case 409:
      responseDecoratorFunction = ApiConflictResponse;
      description = 'Conflict';
      break;
    case 410:
      responseDecoratorFunction = ApiGoneResponse;
      description = 'Gone';
      break;
    case 411:
      responseDecoratorFunction = ApiLengthRequiredResponse;
      description = 'Length Required';
      break;
    case 412:
      responseDecoratorFunction = ApiPreconditionFailedResponse;
      description = 'Precondition Failed';
      break;
    case 413:
      responseDecoratorFunction = ApiPayloadTooLargeResponse;
      description = 'Payload Too Large';
      break;
    case 414:
      responseDecoratorFunction = ApiUriTooLongResponse;
      description = 'URI Too Long';
      break;
    case 415:
      responseDecoratorFunction = ApiUnsupportedMediaTypeResponse;
      description = 'Unsupported Media Type';
      break;
    case 416:
      responseDecoratorFunction = ApiRequestedRangeNotSatisfiableResponse;
      description = 'Range Not Satisfiable';
      break;
    case 417:
      responseDecoratorFunction = ApiExpectationFailedResponse;
      description = 'Expectation Failed';
      break;
    case 422:
      responseDecoratorFunction = ApiUnprocessableEntityResponse;
      description = 'Unprocessable Entity';
      break;

    // 5XX Server Errors
    case 500:
      responseDecoratorFunction = ApiInternalServerErrorResponse;
      description = 'Internal Server Error';
      break;
    case 501:
      responseDecoratorFunction = ApiNotImplementedResponse;
      description = 'Not Implemented';
      break;
    case 502:
      responseDecoratorFunction = ApiBadGatewayResponse;
      description = 'Bad Gateway';
      break;
    case 503:
      responseDecoratorFunction = ApiServiceUnavailableResponse;
      description = 'Service Unavailable';
      break;
    case 504:
      responseDecoratorFunction = ApiGatewayTimeoutResponse;
      description = 'Gateway Timeout';
      break;
    case 505:
      responseDecoratorFunction = ApiHttpVersionNotSupportedResponse;
      description = 'HTTP Version Not Supported';
      break;

    // Default case
    default:
      responseDecoratorFunction = ApiOkResponse; // Fallback to a default response
      description = 'OK'; // Default description
      break;
  }

  return applyDecorators(
    ApiExtraModels(DataWrapperDto, dataDto),
    responseDecoratorFunction({
      description,
      schema: buildSchema(shouldEnvelope, isResponseArray, dataDto),
      ...options,
    })
  );
};
export const ApiCommonResponses = () => {
  const decorators: any = [];

  for (const [decoratorName, responseOptions] of Object.entries(COMMON_RESPONSES)) {
    const decorator = customResponseDecorators[decoratorName](responseOptions);
    decorators.push(decorator);
  }

  return applyDecorators(
    ...decorators,
    ApiResponse(ErrorDto, 400, false, false),
    ApiResponse(ErrorDto, 401, false, false),
    ApiResponse(ErrorDto, 403, false, false),
    ApiResponse(ErrorDto, 404, false, false),
    ApiResponse(ErrorDto, 405, false, false),
    ApiResponse(ErrorDto, 409, false, false),
    ApiResponse(ErrorDto, 413, false, false),
    ApiResponse(ErrorDto, 414, false, false),
    ApiResponse(ErrorDto, 415, false, false),
    ApiResponse(ErrorDto, 500, false, false),
    ApiResponse(ValidationErrorDto, 422, false, false)
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - shouldEnvelope(true,
  options?: ApiResponseOptions
))
 - ApiCommonResponses())
Declaraciones 'export' encontradas:
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/framework/response.interceptor.ts
Tamaño: 1730 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CallHandler, ExecutionContext, Injectable, NestInterceptor } from '@nestjs/common';
import { instanceToPlain } from 'class-transformer';
import { isArray, isObject } from 'lodash';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

export interface Response<T> {
  data: T;
}

@Injectable()
export class ResponseInterceptor<T> implements NestInterceptor<T, Response<T>> {
  intercept(context, next: CallHandler): Observable<Response<T>> {
    if (context.getType() === 'graphql') return next.handle();

    return next.handle().pipe(
      map((data) => {
        if (this.returnWholeObject(data)) {
          return {
            ...data,
            data: isObject(data.data) ? this.transformResponse(data.data) : data.data,
          };
        }

        return {
          data: isObject(data) ? this.transformResponse(data) : data,
        };
      })
    );
  }

  /**
   * This method is used to determine if the entire object should be returned or just the data property
   *   for paginated results that already contain the data wrapper, true.
   *   for single entity result that *could* contain data object, false.
   * @param data
   * @private
   */
  private returnWholeObject(data) {
    const isPaginatedResult = data?.data;
    const isEntityObject = data?._id || data?.id;

    return isPaginatedResult && !isEntityObject;
  }

  private transformResponse(response) {
    if (isArray(response)) {
      return response.map((item) => this.transformToPlain(item));
    }

    return this.transformToPlain(response);
  }

  private transformToPlain(plainOrClass) {
    return plainOrClass && plainOrClass.constructor !== Object ? instanceToPlain(plainOrClass) : plainOrClass;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - isEntityObject(data?._id || data?.id;

    return isPaginatedResult && !isEntityObject;
  }

  private transformRes...)
Declaraciones 'export' encontradas:
- export  interface
- export class ResponseInterceptor

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/framework/user.decorator.ts
Tamaño: 970 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { createParamDecorator, UnauthorizedException } from '@nestjs/common';
import { UserSession } from '@novu/application-generic';
import { SubscriberEntity } from '@novu/dal';
import { ApiAuthSchemeEnum } from '@novu/shared';
import jwt from 'jsonwebtoken';

export { UserSession };

export interface SubscriberSession extends SubscriberEntity {
  organizationId: string;
  environmentId: string;
  contextKeys?: string[];
  scheme: ApiAuthSchemeEnum;
}

export const SubscriberSession = createParamDecorator((data, ctx) => {
  const req = ctx.getType() === 'graphql' ? ctx.getArgs()[2].req : ctx.switchToHttp().getRequest();

  if (req.user) {
    return req.user;
  }

  const authorization = req.headers?.authorization;
  if (!authorization) {
    return null;
  }

  const tokenParts = authorization.split(' ');
  if (tokenParts[0] !== 'Bearer' || !tokenParts[1]) {
    throw new UnauthorizedException('bad_token');
  }

  return jwt.decode(tokenParts[1]);
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - SubscriberSession(createParamDecorator((data, ctx))
Declaraciones 'export' encontradas:
- export
- export  interface
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/framework/constants/headers.schema.ts
Tamaño: 2593 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { HeaderObject, HttpResponseHeaderKeysEnum } from '@novu/application-generic';

export const COMMON_RESPONSE_HEADERS: Array<HttpResponseHeaderKeysEnum> = [
  HttpResponseHeaderKeysEnum.CONTENT_TYPE,
  HttpResponseHeaderKeysEnum.RATELIMIT_LIMIT,
  HttpResponseHeaderKeysEnum.RATELIMIT_REMAINING,
  HttpResponseHeaderKeysEnum.RATELIMIT_RESET,
  HttpResponseHeaderKeysEnum.RATELIMIT_POLICY,
  HttpResponseHeaderKeysEnum.IDEMPOTENCY_KEY,
  HttpResponseHeaderKeysEnum.IDEMPOTENCY_REPLAY,
];

export const RESPONSE_HEADER_CONFIG: Record<HttpResponseHeaderKeysEnum, HeaderObject> = {
  [HttpResponseHeaderKeysEnum.CONTENT_TYPE]: {
    required: true,
    description: 'The MIME type of the response body.',
    schema: { type: 'string' },
    example: 'application/json',
  },
  [HttpResponseHeaderKeysEnum.RATELIMIT_LIMIT]: {
    required: false,
    description:
      'The number of requests that the client is permitted to make per second. The actual maximum may differ when burst is enabled.',
    schema: { type: 'string' },
    example: '100',
  },
  [HttpResponseHeaderKeysEnum.RATELIMIT_REMAINING]: {
    required: false,
    description: 'The number of requests remaining until the next window.',
    schema: { type: 'string' },
    example: '93',
  },
  [HttpResponseHeaderKeysEnum.RATELIMIT_RESET]: {
    required: false,
    description: 'The remaining seconds until a request of the same cost will be refreshed.',
    schema: { type: 'string' },
    example: '8',
  },
  [HttpResponseHeaderKeysEnum.RATELIMIT_POLICY]: {
    required: false,
    description: 'The rate limit policy that was used to evaluate the request.',
    schema: { type: 'string' },
    example: '100;w=1;burst=110;comment="token bucket";category="trigger";cost="single"',
  },
  [HttpResponseHeaderKeysEnum.RETRY_AFTER]: {
    required: false,
    description: 'The number of seconds after which the client may retry the request that was previously rejected.',
    schema: { type: 'string' },
    example: '8',
  },
  [HttpResponseHeaderKeysEnum.IDEMPOTENCY_KEY]: {
    required: false,
    description: 'The idempotency key used to evaluate the request.',
    schema: { type: 'string' },
    example: '8',
  },
  [HttpResponseHeaderKeysEnum.IDEMPOTENCY_REPLAY]: {
    required: false,
    description: 'Whether the request was a replay of a previous request.',
    schema: { type: 'string' },
    example: 'true',
  },
  [HttpResponseHeaderKeysEnum.LINK]: {
    required: false,
    description: 'A link to the documentation.',
    schema: { type: 'string' },
    example: 'https://docs.novu.co/',
  },
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/framework/constants/index.ts
Tamaño: 70 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './headers.schema';
export * from './responses.schema';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/framework/constants/responses.schema.ts
Tamaño: 1479 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiResponseOptions } from '@nestjs/swagger';
import { ApiResponseDecoratorName, HttpResponseHeaderKeysEnum } from '@novu/application-generic';
import { THROTTLED_EXCEPTION_MESSAGE } from '../../../rate-limiting/guards';
import { createReusableHeaders } from '../swagger';

export const COMMON_RESPONSES: Partial<Record<ApiResponseDecoratorName, ApiResponseOptions>> = {
  ApiConflictResponse: {
    description: 'The request could not be completed due to a conflict with the current state of the target resource.',
    schema: {
      type: 'string',
      example:
        'Request with key 3909d656-d4fe-4e80-ba86-90d3861afcd7 is currently being processed. Please retry after 1 second',
    },
    headers: createReusableHeaders([HttpResponseHeaderKeysEnum.RETRY_AFTER, HttpResponseHeaderKeysEnum.LINK]),
  },
  ApiTooManyRequestsResponse: {
    description: 'The client has sent too many requests in a given amount of time. ',
    schema: { type: 'string', example: THROTTLED_EXCEPTION_MESSAGE },
    headers: createReusableHeaders([HttpResponseHeaderKeysEnum.RETRY_AFTER]),
  },
  ApiServiceUnavailableResponse: {
    description:
      'The server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.',
    schema: { type: 'string', example: 'Please wait some time, then try again.' },
    headers: createReusableHeaders([HttpResponseHeaderKeysEnum.RETRY_AFTER]),
  },
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/framework/swagger/context-payload.decorator.ts
Tamaño: 1101 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { applyDecorators } from '@nestjs/common';
import { ApiPropertyOptional } from '@nestjs/swagger';
import { ApiPropertyOptions } from '@nestjs/swagger/dist/decorators/api-property.decorator';

const CONTEXT_PAYLOAD_SWAGGER_OPTIONS: ApiPropertyOptions = {
  type: 'object',
  additionalProperties: {
    oneOf: [
      {
        type: 'string',
        description: 'Simple context id',
        example: 'org-acme',
      },
      {
        type: 'object',
        description: 'Rich context object with id and optional data',
        properties: {
          id: { type: 'string', example: 'org-acme' },
          data: {
            type: 'object',
            description: 'Optional additional context data',
            additionalProperties: true,
            example: { name: 'Acme Corp', region: 'us-east-1' },
          },
        },
        required: ['id'],
      },
    ],
  },
};

export function ApiContextPayload(overrides?: Partial<ApiPropertyOptions>) {
  return applyDecorators(
    ApiPropertyOptional({
      ...CONTEXT_PAYLOAD_SWAGGER_OPTIONS,
      ...overrides,
    })
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - ApiContextPayload(overrides?: Partial<ApiPropertyOptions>)
Declaraciones 'export' encontradas:
- export function ApiContextPayload

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/framework/swagger/headers.decorator.ts
Tamaño: 866 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { OpenAPIObject } from '@nestjs/swagger';
import { HeaderObjects, HttpResponseHeaderKeysEnum } from '@novu/application-generic';
import { RESPONSE_HEADER_CONFIG } from '../constants/headers.schema';

export const injectReusableHeaders = (document: OpenAPIObject): OpenAPIObject => {
  const newDocument = { ...document };
  newDocument.components = {
    ...document.components,
    headers: Object.entries(RESPONSE_HEADER_CONFIG).reduce((acc, [name, header]) => {
      return {
        ...acc,
        [name]: header,
      };
    }, {} as HeaderObjects),
  };

  return newDocument;
};

export const createReusableHeaders = (headers: Array<HttpResponseHeaderKeysEnum>) => {
  return headers.reduce((acc, header) => {
    return {
      ...acc,
      [header]: {
        $ref: `#/components/headers/${header}`,
      },
    };
  }, {} as HeaderObjects);
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - injectReusableHeaders(document: OpenAPIObject): OpenAPIObject)
 - components({
    ...document.components,
    headers: Object.entries(RESPONSE_HEADER_CONFIG).reduce((acc, [name...)
 - createReusableHeaders(headers: Array<HttpResponseHeaderKeysEnum>))
Declaraciones 'export' encontradas:
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/framework/swagger/index.ts
Tamaño: 150 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './context-payload.decorator';
export * from './headers.decorator';
export * from './injection';
export * from './responses.decorator';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/framework/swagger/injection.ts
Tamaño: 318 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { OpenAPIObject } from '@nestjs/swagger';
import { injectReusableHeaders } from './headers.decorator';

export const injectDocumentComponents = (document: OpenAPIObject): OpenAPIObject => {
  const injectedResponseHeadersDocument = injectReusableHeaders(document);

  return injectedResponseHeadersDocument;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - injectDocumentComponents(document: OpenAPIObject): OpenAPIObject)
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/framework/swagger/keyless.security.ts
Tamaño: 226 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { applyDecorators, SetMetadata } from '@nestjs/common';

export const KEYLESS_ACCESSIBLE = 'keyless_accessible';

export function KeylessAccessible() {
  return applyDecorators(SetMetadata(KEYLESS_ACCESSIBLE, true));
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - KeylessAccessible()
Declaraciones 'export' encontradas:
- export  const
- export function KeylessAccessible

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/framework/swagger/open.api.manipulation.component.ts
Tamaño: 6702 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { OpenAPIObject } from '@nestjs/swagger';
import { OperationObject, PathItemObject, PathsObject } from '@nestjs/swagger/dist/interfaces/open-api-spec.interface';
import { API_KEY_SWAGGER_SECURITY_NAME } from '@novu/application-generic';
import Nimma from 'nimma';

const jpath = '$.paths..responses["200","201"].content["application/json"]';

/**
 * @param {import("nimma").EmittedScope} scope
 */
function liftDataProperty(scope) {
  if (
    typeof scope.value !== 'object' ||
    !scope.value ||
    !('schema' in scope.value) ||
    typeof scope.value.schema !== 'object' ||
    !scope.value.schema
  ) {
    return;
  }

  const { schema } = scope.value;
  const data =
    'properties' in schema &&
    typeof schema.properties === 'object' &&
    schema.properties &&
    'data' in schema.properties &&
    typeof schema.properties.data === 'object'
      ? schema.properties.data
      : null;
  if (!data) {
    return;
  }

  scope.value.schema = data;
}

export function removeEndpointsWithoutApiKey<T>(openApiDocument: T): T {
  const parsedDocument = JSON.parse(JSON.stringify(openApiDocument));

  if (!parsedDocument.paths) {
    throw new Error('Invalid OpenAPI document');
  }

  for (const path in parsedDocument.paths) {
    const operations = parsedDocument.paths[path];
    for (const method in operations) {
      const operation = operations[method];
      if (operation.security) {
        const hasApiKey = operation.security.some((sec: { [key: string]: string[] }) =>
          Object.keys(sec).includes(API_KEY_SWAGGER_SECURITY_NAME)
        );
        operation.security = operation.security.filter((sec: { [key: string]: string[] }) =>
          Object.keys(sec).includes(API_KEY_SWAGGER_SECURITY_NAME)
        );
        if (!hasApiKey) {
          delete operations[method];
        }
      }
    }
    if (Object.keys(operations).length === 0) {
      delete parsedDocument.paths[path];
    }
  }

  return parsedDocument;
}

function unwrapDataAttribute(inputDocument: OpenAPIObject) {
  Nimma.query(inputDocument, {
    [jpath]: liftDataProperty,
  });
}

function filterBearerOnlyIfExternal(isForInternalSdk: boolean, inputDocument: OpenAPIObject) {
  let openAPIObject: OpenAPIObject;
  if (isForInternalSdk) {
    return inputDocument;
  } else {
    return removeEndpointsWithoutApiKey(inputDocument) as OpenAPIObject;
  }
}

export function overloadDocumentForSdkGeneration(inputDocument: OpenAPIObject, isForInternalSdk: boolean = false) {
  unwrapDataAttribute(inputDocument);
  const openAPIObject = filterBearerOnlyIfExternal(isForInternalSdk, inputDocument);

  return addIdempotencyKeyHeader(openAPIObject) as OpenAPIObject;
}

export function addIdempotencyKeyHeader<T>(openApiDocument: T): T {
  const parsedDocument = JSON.parse(JSON.stringify(openApiDocument));

  if (!parsedDocument.paths) {
    throw new Error('Invalid OpenAPI document');
  }

  const idempotencyKeyHeader = {
    name: 'idempotency-key',
    in: 'header',
    description: 'A header for idempotency purposes',
    required: false,
    schema: {
      type: 'string',
    },
  };

  const paths = Object.keys(parsedDocument.paths);
  for (const path of paths) {
    const operations = parsedDocument.paths[path];
    const methods = Object.keys(operations);
    for (const method of methods) {
      const operation = operations[method];

      if (!operation.parameters) {
        operation.parameters = [];
      }

      const hasIdempotencyKey = operation.parameters.some(
        (param) => param.name === 'Idempotency-Key' && param.in === 'header'
      );
      if (!hasIdempotencyKey) {
        operation.parameters.push(idempotencyKeyHeader);
      }
    }
  }

  return parsedDocument;
}
export function sortOpenAPIDocument(openApiDoc: OpenAPIObject): OpenAPIObject {
  // Create a deep copy of the original document
  const sortedDoc: OpenAPIObject = JSON.parse(JSON.stringify(openApiDoc));

  // Remove empty tag references
  if (sortedDoc.tags) {
    sortedDoc.tags = sortedDoc.tags.filter((tag) => tag.name && tag.name.trim() !== '');
  }

  // Sort paths
  if (sortedDoc.paths) {
    const sortedPaths: PathsObject = {};

    // Sort path keys based on version (v2 before v1) and then alphabetically
    const sortedPathKeys = Object.keys(sortedDoc.paths).sort((a, b) => {
      // Extract version from path
      const getVersion = (path: string) => {
        const versionMatch = path.match(/\/v(\d+)/);

        return versionMatch ? parseInt(versionMatch[1], 10) : 0;
      };

      const versionA = getVersion(a);
      const versionB = getVersion(b);

      // Sort by version (newer first)
      if (versionA !== versionB) {
        return versionB - versionA;
      }

      // If versions are the same, sort alphabetically
      return a.localeCompare(b);
    });

    // Debugging function to extract operation details
    const extractOperationDetails = (method: string, url: string, operation?: OperationObject) => {
      if (!operation) return null;

      return {
        method: method.toUpperCase(),
        url,
        operationId: operation.operationId || 'N/A',
        tags: operation.tags || [],
        summary: operation.summary || 'N/A',
      };
    };

    // Debugging array to collect all operations
    const debugOperations: any[] = [];

    // Reconstruct paths with sorted keys and sorted methods within each path
    sortedPathKeys.forEach((pathKey) => {
      const pathItem = sortedDoc.paths[pathKey];

      // Define method order priority
      const methodPriority = ['post', 'put', 'patch', 'get', 'delete', 'options', 'head', 'trace'];

      // Collect operations for debugging
      methodPriority.forEach((method) => {
        const operation = pathItem[method as keyof PathItemObject] as OperationObject | undefined;
        const operationDetails = extractOperationDetails(method, pathKey, operation);
        if (operationDetails) {
          debugOperations.push(operationDetails);
        }
      });

      // Sort methods within the path item
      sortedPaths[pathKey] = {
        ...pathItem,
        ...Object.fromEntries(
          methodPriority
            .map((method) => {
              const operation = pathItem[method as keyof PathItemObject];

              return operation ? [method, operation] : null;
            })
            .filter((entry): entry is [string, OperationObject] => entry !== null)
            .sort((a, b) => {
              const opIdA = a[1].operationId || '';
              const opIdB = b[1].operationId || '';

              return opIdA.localeCompare(opIdB);
            })
        ),
      };
    });

    sortedDoc.paths = sortedPaths;
  }

  return sortedDoc;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - liftDataProperty(scope)
 - unwrapDataAttribute(inputDocument: OpenAPIObject)
 - filterBearerOnlyIfExternal(isForInternalSdk: boolean, inputDocument: OpenAPIObject)
 - overloadDocumentForSdkGeneration(inputDocument: OpenAPIObject, isForInternalSdk: boolean = false)
 - sortOpenAPIDocument(openApiDoc: OpenAPIObject)
Asignaciones con arrow functions encontradas (posibles funciones):
 - hasApiKey(operation.security.some((sec: { [key: string]: string[] }))
 - security(operation.security.filter((sec: { [key: string]: string[] }))
 - hasIdempotencyKey(operation.parameters.some(
        (param))
 - tags(sortedDoc.tags.filter((tag))
 - sortedPathKeys(Object.keys(sortedDoc.paths).sort((a, b))
 - getVersion(path: string))
 - extractOperationDetails(method: string, url: string, operation?: OperationObject))
 - methodPriority(['post', 'put', 'patch', 'get', 'delete', 'options', 'head', 'trace'];

      // Collect operations ...)
 - operation(pathItem[method as keyof PathItemObject];

              return operation ? [method, operation] : nu...)
Declaraciones 'export' encontradas:
- export function removeEndpointsWithoutApiKey
- export function overloadDocumentForSdkGeneration
- export function addIdempotencyKeyHeader
- export function sortOpenAPIDocument

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/framework/swagger/responses.decorator.ts
Tamaño: 1257 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { applyDecorators } from '@nestjs/common';
import * as nestSwagger from '@nestjs/swagger';
import { ApiResponseOptions } from '@nestjs/swagger';
import type { ApiResponseDecoratorName } from '@novu/application-generic';
import { COMMON_RESPONSE_HEADERS, COMMON_RESPONSES } from '../constants';
import { createReusableHeaders } from './headers.decorator';

const createCustomResponseDecorator = (decoratorName: ApiResponseDecoratorName) => {
  return (options?: ApiResponseOptions) => {
    return applyDecorators(
      nestSwagger[decoratorName]({
        ...COMMON_RESPONSES[decoratorName],
        ...options,
        headers: {
          ...createReusableHeaders(COMMON_RESPONSE_HEADERS),
          ...options?.headers,
        },
      })
    );
  };
};

const nestSwaggerResponseExports = Object.keys(nestSwagger).filter(
  (key) => key.match(/^Api([a-zA-Z]+)Response$/) !== null
) as Array<ApiResponseDecoratorName>;

export const customResponseDecorators = nestSwaggerResponseExports.reduce(
  (acc, decoratorName) => {
    return {
      ...acc,
      [decoratorName]: createCustomResponseDecorator(decoratorName),
    };
  },
  {} as Record<ApiResponseDecoratorName, (options?: ApiResponseOptions) => ReturnType<typeof applyDecorators>>
);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - createCustomResponseDecorator(decoratorName: ApiResponseDecoratorName))
 - nestSwaggerResponseExports(Object.keys(nestSwagger).filter(
  (key))
 - customResponseDecorators(nestSwaggerResponseExports.reduce(
  (acc, decoratorName))
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/framework/swagger/sdk.decorators.ts
Tamaño: 4201 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { applyDecorators } from '@nestjs/common';
import { ApiExtension, ApiParam, ApiProperty } from '@nestjs/swagger';
import { ApiParamOptions } from '@nestjs/swagger/dist/decorators/api-param.decorator';
import { ApiPropertyOptions } from '@nestjs/swagger/dist/decorators/api-property.decorator';

/**
 * Sets the method name for the SDK.
 * @param {string} methodName - The name of the method.
 * @returns {Decorator} The decorator to be used on the method.
 */

export function SdkMethodName(methodName: string) {
  return applyDecorators(ApiExtension('x-speakeasy-name-override', methodName));
}

/**
 * Sets the group name for the SDK.
 * @param {string} methodName - The name of the group.
 * @returns {Decorator} The decorator to be used on the method.
 */

export function SdkGroupName(methodName: string) {
  return applyDecorators(ApiExtension('x-speakeasy-group', methodName));
}
/**
 * A decorator function that marks a path or operation to be ignored in OpenAPI documentation.
 *
 * This function applies the `x-ignore` extension to the OpenAPI specification,
 * indicating that the decorated path or operation should not be included in the generated documentation.
 *
 * @returns {Function} A decorator function that applies the `x-ignore` extension.
 */
export function DocumentationIgnore() {
  return applyDecorators(ApiExtension('x-ignore', true));
}

/**
 * Ignores the path for the SDK.
 * @param {string} methodName - The name of the method.
 * @returns {Decorator} The decorator to be used on the method.
 */

export function SdkIgnorePath(methodName: string) {
  return applyDecorators(ApiExtension('x-speakeasy-ignore', 'true'));
}

/**
 * Sets the usage example for the SDK.
 * @param {string} title - The title of the example.
 * @param {string} description - The description of the example.
 * @param {number} position - The position of the example.
 * @returns {Decorator} The decorator to be used on the method.
 */

export function SdkUsageExample(title?: string, description?: string, position?: number) {
  return applyDecorators(ApiExtension('x-speakeasy-usage-example', { title, description, position }));
}

/**
 * Sets the maximum number of parameters for the SDK method.
 * @param {number} maxParamsBeforeCollapseToObject - The maximum number of parameters before they are collapsed into an object.
 * @returns {Decorator} The decorator to be used on the method.
 */

export function SdkMethodMaxParamsOverride(maxParamsBeforeCollapseToObject?: number) {
  return applyDecorators(ApiExtension('x-speakeasy-max-method-params', maxParamsBeforeCollapseToObject));
}

class SDKOverrideOptions {
  nameOverride?: string;
}

export function SdkApiParam(options: ApiParamOptions, sdkOverrideOptions?: SDKOverrideOptions) {
  let finalOptions: ApiParamOptions;
  if (sdkOverrideOptions) {
    finalOptions = sdkOverrideOptions.nameOverride
      ? ({ ...options, 'x-speakeasy-name-override': sdkOverrideOptions.nameOverride } as unknown as ApiParamOptions)
      : options;
  } else {
    finalOptions = options;
  }

  return applyDecorators(ApiParam(finalOptions));
}
export function SdkApiProperty(options: ApiPropertyOptions, sdkOverrideOptions?: SDKOverrideOptions) {
  let finalOptions: ApiPropertyOptions;
  if (sdkOverrideOptions) {
    finalOptions = sdkOverrideOptions.nameOverride
      ? ({ ...options, 'x-speakeasy-name-override': sdkOverrideOptions.nameOverride } as unknown as ApiPropertyOptions)
      : options;
  } else {
    finalOptions = options;
  }

  return applyDecorators(ApiProperty(finalOptions));
}
/**
 * Sets the pagination for the SDK.
 * @param {string} override - The override for the limit parameter.
 * @returns {Decorator} The decorator to be used on the method.
 */

export function SdkUsePagination(override?: string) {
  return applyDecorators(
    ApiExtension('x-speakeasy-pagination', {
      type: 'offsetLimit',
      inputs: [
        {
          name: 'page',
          in: 'parameters',
          type: 'page',
        },
        {
          name: override || 'limit',
          in: 'parameters',
          type: 'limit',
        },
      ],
      outputs: {
        results: '$.data.resultArray',
      },
    })
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - SdkMethodName(methodName: string)
 - SdkGroupName(methodName: string)
 - DocumentationIgnore()
 - SdkIgnorePath(methodName: string)
 - SdkUsageExample(title?: string, description?: string, position?: number)
 - SdkMethodMaxParamsOverride(maxParamsBeforeCollapseToObject?: number)
 - SdkApiParam(options: ApiParamOptions, sdkOverrideOptions?: SDKOverrideOptions)
 - SdkApiProperty(options: ApiPropertyOptions, sdkOverrideOptions?: SDKOverrideOptions)
 - SdkUsePagination(override?: string)
Declaraciones 'export' encontradas:
- export function SdkMethodName
- export function SdkGroupName
- export function DocumentationIgnore
- export function SdkIgnorePath
- export function SdkUsageExample
- export function SdkMethodMaxParamsOverride
- export function SdkApiParam
- export function SdkApiProperty
- export function SdkUsePagination

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/framework/swagger/swagger.controller.ts
Tamaño: 11681 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { INestApplication } from '@nestjs/common';
import { DocumentBuilder, OpenAPIObject, SwaggerModule } from '@nestjs/swagger';
import { SecuritySchemeObject } from '@nestjs/swagger/dist/interfaces/open-api-spec.interface';
import { API_KEY_SWAGGER_SECURITY_NAME, BEARER_SWAGGER_SECURITY_NAME } from '@novu/application-generic';
import packageJson from '../../../../../package.json';
import metadata from '../../../../metadata';
import { webhookEvents } from '../../../outbound-webhooks/webhooks.const';
import { injectDocumentComponents } from './injection';
import {
  overloadDocumentForSdkGeneration,
  removeEndpointsWithoutApiKey,
  sortOpenAPIDocument,
} from './open.api.manipulation.component';

export const API_KEY_SECURITY_DEFINITIONS: SecuritySchemeObject = {
  type: 'apiKey',
  name: 'Authorization',
  in: 'header',
  description: 'API key authentication. Allowed headers-- "Authorization: ApiKey <api_key>".',
  'x-speakeasy-example': 'YOUR_SECRET_KEY_HERE',
} as unknown as SecuritySchemeObject;
export const BEARER_SECURITY_DEFINITIONS: SecuritySchemeObject = {
  type: 'http',
  scheme: 'bearer',
  bearerFormat: 'JWT',
};

function buildBaseOptions() {
  const options = new DocumentBuilder()
    .setTitle('Novu API')
    .setDescription('Novu REST API. Please see https://docs.novu.co/api-reference for more details.')
    .setVersion(packageJson.version)
    .setContact('Novu Support', 'https://discord.gg/novu', 'support@novu.co')
    .setExternalDoc('Novu Documentation', 'https://docs.novu.co')
    .setTermsOfService('https://novu.co/terms')
    .setLicense('MIT', 'https://opensource.org/license/mit')
    .addServer('https://api.novu.co')
    .addServer('https://eu.api.novu.co')
    .addSecurity(API_KEY_SWAGGER_SECURITY_NAME, API_KEY_SECURITY_DEFINITIONS)
    .addSecurityRequirements(API_KEY_SWAGGER_SECURITY_NAME)
    .addTag(
      'Events',
      `Events represent a change in state of a subscriber. They are used to trigger workflows, and enable you to send notifications to subscribers based on their actions.`,
      { url: 'https://docs.novu.co/workflows' }
    )
    .addTag(
      'Subscribers',
      `A subscriber in Novu represents someone who should receive a message. A subscriber's profile information contains important attributes about the subscriber that will be used in messages (name, email). The subscriber object can contain other key-value pairs that can be used to further personalize your messages.`,
      { url: 'https://docs.novu.co/subscribers/subscribers' }
    )
    .addTag(
      'Topics',
      `Topics are a way to group subscribers together so that they can be notified of events at once. A topic is identified by a custom key. This can be helpful for things like sending out marketing emails or notifying users of new features. Topics can also be used to send notifications to the subscribers who have been grouped together based on their interests, location, activities and much more.`,
      { url: 'https://docs.novu.co/subscribers/topics' }
    )
    .addTag(
      'Integrations',
      `With the help of the Integration Store, you can easily integrate your favorite delivery provider. During the runtime of the API, the Integrations Store is responsible for storing the configurations of all the providers.`,
      { url: 'https://docs.novu.co/platform/integrations/overview' }
    )
    .addTag(
      'Workflows',
      `All notifications are sent via a workflow. Each workflow acts as a container for the logic and blueprint that are associated with a type of notification in your system.`,
      { url: 'https://docs.novu.co/workflows' }
    )
    .addTag(
      'Messages',
      `A message in Novu represents a notification delivered to a recipient on a particular channel. Messages contain information about the request that triggered its delivery, a view of the data sent to the recipient, and a timeline of its lifecycle events. Learn more about messages.`,
      { url: 'https://docs.novu.co/workflows/messages' }
    )
    .addTag(
      'Environments',
      `Environments allow you to manage different stages of your application development lifecycle. Each environment has its own set of API keys and configurations, enabling you to separate development, staging, and production workflows.`,
      { url: 'https://docs.novu.co/platform/environments' }
    )
    .addTag('Layouts', `Layouts are reusable wrappers for your email notifications.`, {
      url: 'https://docs.novu.co/platform/workflow/layouts',
    })
    .addTag('Translations', `Used to localize your notifications to different languages.`, {
      url: 'https://docs.novu.co/platform/workflow/translations',
    });

  return options;
}

function buildOpenApiBaseDocument(internalSdkGeneration: boolean | undefined) {
  const options = buildBaseOptions();
  if (internalSdkGeneration) {
    options.addSecurity(BEARER_SWAGGER_SECURITY_NAME, BEARER_SECURITY_DEFINITIONS);
    options.addSecurityRequirements(BEARER_SWAGGER_SECURITY_NAME);
  }

  return options.build();
}

function buildFullDocumentWithPath(app: INestApplication<any>, baseDocument: Omit<OpenAPIObject, 'paths'>) {
  // Define extraModels to ensure webhook payload DTOs are included in the schema definitions
  // Add other relevant payload DTOs here if more webhooks are defined
  const allWebhookPayloadDtos = [...new Set(webhookEvents.map((event) => event.payloadDto))];

  const document = injectDocumentComponents(
    SwaggerModule.createDocument(app, baseDocument, {
      operationIdFactory: (controllerKey: string, methodKey: string) => `${controllerKey}_${methodKey}`,
      deepScanRoutes: true,
      ignoreGlobalPrefix: false,
      include: [],
      extraModels: [...allWebhookPayloadDtos], // Make sure payload DTOs are processed
    })
  );
  return document;
}

function publishDeprecatedDocument(app: INestApplication<any>, document: OpenAPIObject) {
  SwaggerModule.setup('api', app, {
    ...document,
    info: {
      ...document.info,
      title: `DEPRECATED: ${document.info.title}. Use /openapi.{json,yaml} instead.`,
    },
  });
}

function publishLegacyOpenApiDoc(app: INestApplication<any>, document: OpenAPIObject) {
  SwaggerModule.setup('openapi', app, removeEndpointsWithoutApiKey(document), {
    jsonDocumentUrl: 'openapi.json',
    yamlDocumentUrl: 'openapi.yaml',
    explorer: process.env.NODE_ENV !== 'production',
  });
}

/**
 * Generates the `x-webhooks` section for the OpenAPI document based on defined events and DTOs.
 * Follows the OpenAPI specification for webhooks: https://spec.openapis.org/oas/v3.1.0#fixed-fields-1:~:text=Webhooks%20Object
 */
function generateWebhookDefinitions(document: OpenAPIObject) {
  const webhooksDefinition: Record<string, any> = {}; // Structure matches Path Item Object

  webhookEvents.forEach((webhook) => {
    // Assume the schema name matches the DTO class name (generated by Swagger)
    const payloadSchemaRef = `#/components/schemas/${(webhook.payloadDto as Function).name}`;
    const wrapperSchemaName = `${(webhook.payloadDto as Function).name}WebhookPayloadWrapper`; // Unique name for the wrapper schema

    // Define the wrapper schema in components/schemas if it doesn't exist
    if (document.components && !document.components.schemas?.[wrapperSchemaName]) {
      if (!document.components.schemas) {
        document.components.schemas = {};
      }
      document.components.schemas[wrapperSchemaName] = {
        type: 'object',
        properties: {
          id: {
            type: 'string',
            description: 'Unique identifier of the webhook event (evt_✱).',
          },
          type: { type: 'string', enum: [webhook.event], description: 'The type of the webhook event.' },
          data: {
            description: 'The actual event data payload.',
            allOf: [{ $ref: payloadSchemaRef }], // Use allOf to correctly reference the payload schema
          },
          timestamp: { type: 'string', format: 'date-time', description: 'ISO timestamp of when the event occurred.' },
          environmentId: { type: 'string', description: 'The ID of the environment associated with the event.' },
          object: {
            type: 'string',
            enum: [webhook.objectType],
            description: 'The type of object the event relates to.',
          },
        },
        required: ['type', 'data', 'timestamp', 'environmentId', 'object'],
      };
    }

    webhooksDefinition[webhook.event] = {
      // This structure represents a Path Item Object, describing the webhook POST request.
      post: {
        summary: `Event: ${webhook.event}`,
        description: `This webhook is triggered when a \`${webhook.objectType}\` event (\`${
          webhook.event
        }\`) occurs. The payload contains the details of the event. Configure your webhook endpoint URL in the Novu dashboard.`,
        requestBody: {
          description: `Webhook payload for the \`${webhook.event}\` event.`,
          required: true,
          content: {
            'application/json': {
              schema: { $ref: `#/components/schemas/${wrapperSchemaName}` }, // Reference the wrapper schema
            },
          },
        },
        responses: {
          '200': {
            description: 'Acknowledges successful receipt of the webhook. No response body is expected.',
          },
          // Consider adding other responses (e.g., 4xx for signature validation failure, 5xx for processing errors)
        },
        tags: ['Webhooks'], // Assign to a 'Webhooks' tag
      },
    };
  });

  document['x-webhooks'] = webhooksDefinition;
}

export const setupSwagger = async (app: INestApplication, internalSdkGeneration?: boolean) => {
  await SwaggerModule.loadPluginMetadata(metadata);
  const baseDocument = buildOpenApiBaseDocument(internalSdkGeneration);
  const document = buildFullDocumentWithPath(app, baseDocument);

  // Generate and add x-webhooks section FIRST
  generateWebhookDefinitions(document);

  publishDeprecatedDocument(app, document);
  publishLegacyOpenApiDoc(app, document);

  return publishSdkSpecificDocumentAndReturnDocument(app, document, internalSdkGeneration);
};

function overloadNamingGuidelines(document: OpenAPIObject) {
  document['x-speakeasy-name-override'] = [
    { operationId: '^.*get.*', methodNameOverride: 'retrieve' },
    { operationId: '^.*retrieve.*', methodNameOverride: 'retrieve' },
    { operationId: '^.*create.*', methodNameOverride: 'create' },
    { operationId: '^.*update.*', methodNameOverride: 'update' },
    { operationId: '^.*list.*', methodNameOverride: 'list' },
    { operationId: '^.*delete.*', methodNameOverride: 'delete' },
    { operationId: '^.*remove.*', methodNameOverride: 'delete' },
  ];
}

function overloadGlobalSdkRetrySettings(document: OpenAPIObject) {
  document['x-speakeasy-retries'] = {
    strategy: 'backoff',
    backoff: {
      initialInterval: 1000,
      maxInterval: 30000,
      maxElapsedTime: 3600000,
      exponent: 1.5,
    },
    statusCodes: [408, 409, 429, '5XX'],
    retryConnectionErrors: true,
  };
}

function publishSdkSpecificDocumentAndReturnDocument(
  app: INestApplication,
  document: OpenAPIObject,
  internalSdkGeneration?: boolean
) {
  overloadNamingGuidelines(document);
  overloadGlobalSdkRetrySettings(document);

  let sdkDocument: OpenAPIObject = overloadDocumentForSdkGeneration(document, internalSdkGeneration);
  sdkDocument = sortOpenAPIDocument(sdkDocument);
  SwaggerModule.setup('openapi.sdk', app, sdkDocument, {
    jsonDocumentUrl: 'openapi.sdk.json',
    yamlDocumentUrl: 'openapi.sdk.yaml',
    explorer: process.env.NODE_ENV !== 'production',
  });
  return sdkDocument;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - buildBaseOptions()
 - buildOpenApiBaseDocument(internalSdkGeneration: boolean | undefined)
 - buildFullDocumentWithPath(app: INestApplication<any>, baseDocument: Omit<OpenAPIObject, 'paths'>)
 - publishDeprecatedDocument(app: INestApplication<any>, document: OpenAPIObject)
 - publishLegacyOpenApiDoc(app: INestApplication<any>, document: OpenAPIObject)
 - generateWebhookDefinitions(document: OpenAPIObject)
 - overloadNamingGuidelines(document: OpenAPIObject)
 - overloadGlobalSdkRetrySettings(document: OpenAPIObject)
 - publishSdkSpecificDocumentAndReturnDocument(app: INestApplication,
  document: OpenAPIObject,
  internalSdkGeneration?: boolean)
Asignaciones con arrow functions encontradas (posibles funciones):
 - allWebhookPayloadDtos([...new Set(webhookEvents.map((event))
 - document(injectDocumentComponents(
    SwaggerModule.createDocument(app, baseDocument, {
      operationIdFac...)
 - setupSwagger(async (app: INestApplication, internalSdkGeneration?: boolean))
Declaraciones 'export' encontradas:
- export  const
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/helpers/build-slug.ts
Tamaño: 545 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { encodeBase62 } from '@novu/application-generic';
import { ShortIsPrefixEnum, Slug, slugify } from '@novu/shared';

const SLUG_DELIMITER = '_';

/**
 * Builds a slug for a step based on the step name, the short prefix and the internal ID.
 * @returns The slug for the entity, example:  slug: "workflow-name_wf_AbC1Xyz9KlmNOpQr"
 */
export function buildSlug(entityName: string, shortIsPrefix: ShortIsPrefixEnum, internalId: string): Slug {
  return `${slugify(entityName)}${SLUG_DELIMITER}${shortIsPrefix}${encodeBase62(internalId)}`;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - buildSlug(entityName: string, shortIsPrefix: ShortIsPrefixEnum, internalId: string)
Declaraciones 'export' encontradas:
- export function buildSlug

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/helpers/content.service.spec.ts
Tamaño: 14319 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ContentService } from '@novu/application-generic';
import {
  DelayTypeEnum,
  DigestTypeEnum,
  DigestUnitEnum,
  FieldLogicalOperatorEnum,
  FieldOperatorEnum,
  FilterPartTypeEnum,
  INotificationTemplateStep,
  StepTypeEnum,
  TriggerContextTypeEnum,
} from '@novu/shared';
import { expect } from 'chai';

describe('ContentService', () => {
  describe('replaceVariables', () => {
    it('should replace duplicates entries', () => {
      const variables = {
        firstName: 'Name',
        lastName: 'Last Name',
      };

      const contentService = new ContentService();
      const modified = contentService.replaceVariables(
        '{{firstName}} is the first {{firstName}} of {{firstName}}',
        variables
      );
      expect(modified).to.equal('Name is the first Name of Name');
    });

    it('should replace multiple variables', () => {
      const variables = {
        firstName: 'Name',
        $last_name: 'Last Name',
      };

      const contentService = new ContentService();
      const modified = contentService.replaceVariables(
        '{{firstName}} is the first {{$last_name}} of {{firstName}}',
        variables
      );
      expect(modified).to.equal('Name is the first Last Name of Name');
    });

    it('should not manipulate variables for text without them', () => {
      const variables = {
        firstName: 'Name',
        lastName: 'Last Name',
      };

      const contentService = new ContentService();
      const modified = contentService.replaceVariables('This is a text without variables', variables);
      expect(modified).to.equal('This is a text without variables');
    });
  });

  describe('extractVariables', () => {
    it('should not find any variables', () => {
      const contentService = new ContentService();
      try {
        contentService.extractVariables('This is a text without variables {{ invalid }} {{ not valid{ {var}}');
        expect(true).to.equal(false);
      } catch (e) {
        expect(e.response.message).to.equal('Failed to extract variables');
      }
    });

    it('should extract all valid variables', () => {
      const contentService = new ContentService();
      const extractVariables = contentService.extractVariables(
        ' {{name}} d {{lastName}} dd {{_validName}} {{not valid}} aa {{0notValid}}tr {{organization_name}}'
      );
      const variablesNames = extractVariables.map((variable) => variable.name);

      expect(extractVariables.length).to.equal(4);
      expect(variablesNames).to.include('_validName');
      expect(variablesNames).to.include('lastName');
      expect(variablesNames).to.include('name');
      expect(variablesNames).to.include('organization_name');
    });

    it('should correctly extract variables related to registered handlebar helpers', () => {
      const contentService = new ContentService();
      const extractVariables = contentService.extractVariables(' {{titlecase word}}');

      expect(extractVariables.length).to.equal(1);
      expect(extractVariables[0].name).to.include('word');
    });

    it('should not show @data variables ', () => {
      const contentService = new ContentService();
      const extractVariables = contentService.extractVariables(
        ' {{#each array}} {{@index}} {{#if @first}} First {{/if}} {{name}} {{/each}}'
      );

      expect(extractVariables.length).to.equal(2);
      expect(extractVariables[0].name).to.include('array');
      expect(extractVariables[0].type).to.eq('Array');
      expect(extractVariables[1].name).to.include('name');
    });
  });

  describe('extractMessageVariables', () => {
    it('should not extract variables', () => {
      const contentService = new ContentService();
      const { variables } = contentService.extractMessageVariables([
        {
          template: {
            type: StepTypeEnum.IN_APP,
            subject: 'Test',
            content: 'Text',
          },
        },
      ]);
      expect(variables.length).to.equal(0);
    });

    it('should extract subject variables', () => {
      const contentService = new ContentService();
      const { variables } = contentService.extractMessageVariables([
        {
          template: {
            type: StepTypeEnum.EMAIL,
            subject: 'Test {{firstName}}',
            content: [],
          },
        },
      ]);
      expect(variables.length).to.equal(1);
      expect(variables[0].name).to.include('firstName');
    });

    it('should extract reserved variables', () => {
      const contentService = new ContentService();
      const { variables, reservedVariables } = contentService.extractMessageVariables([
        {
          template: {
            type: StepTypeEnum.EMAIL,
            subject: 'Test {{firstName}} {{tenant.name}}',
            content: [],
          },
        },
      ]);
      expect(variables.length).to.equal(1);
      expect(variables[0].name).to.include('firstName');
      expect(reservedVariables.length).to.equal(1);
      expect(reservedVariables[0].type).to.eq(TriggerContextTypeEnum.TENANT);
      expect(reservedVariables[0].variables[0].name).to.include('identifier');
    });

    it('should add phone when SMS channel Exists', () => {
      const contentService = new ContentService();
      const variables = contentService.extractSubscriberMessageVariables([
        {
          template: {
            type: StepTypeEnum.IN_APP,
            subject: 'Test',
            content: 'Text',
          },
        },
        {
          template: {
            type: StepTypeEnum.SMS,
            content: 'Text',
          },
        },
      ]);
      expect(variables.length).to.equal(1);
      expect(variables[0]).to.equal('phone');
    });

    it('should add email when EMAIL channel Exists', () => {
      const contentService = new ContentService();
      const variables = contentService.extractSubscriberMessageVariables([
        {
          template: {
            type: StepTypeEnum.EMAIL,
            subject: 'Test',
            content: 'Text',
          },
        },
        {
          template: {
            type: StepTypeEnum.IN_APP,
            content: 'Text',
          },
        },
      ]);
      expect(variables.length).to.equal(1);
      expect(variables[0]).to.equal('email');
    });

    it('should extract email content variables', () => {
      const contentService = new ContentService();
      const messages = [
        {
          template: {
            type: StepTypeEnum.EMAIL,
            subject: 'Test {{firstName}}',
            content: [
              {
                content: 'Test of {{lastName}}',
                type: 'text',
              },
              {
                content: 'Test of {{lastName}}',
                type: 'text',
                url: 'Test of {{url}}',
              },
            ],
          },
        },
        {
          template: {
            type: StepTypeEnum.EMAIL,
            subject: 'Test {{email}}',
            content: [
              {
                content: 'Test of {{lastName}}',
                type: 'text',
              },
              {
                content: 'Test of {{lastName}}',
                type: 'text',
                url: 'Test of {{url}}',
              },
            ],
          },
        },
      ] as INotificationTemplateStep[];

      const { variables } = contentService.extractMessageVariables(messages);
      const subscriberVariables = contentService.extractSubscriberMessageVariables(messages);
      const variablesNames = variables.map((variable) => variable.name);

      expect(variables.length).to.equal(4);
      expect(subscriberVariables.length).to.equal(1);
      expect(variablesNames).to.include('lastName');
      expect(variablesNames).to.include('url');
      expect(variablesNames).to.include('firstName');
      expect(subscriberVariables).to.include('email');
    });

    it('should extract in-app content variables', () => {
      const contentService = new ContentService();
      const { variables } = contentService.extractMessageVariables([
        {
          template: {
            type: StepTypeEnum.IN_APP,
            content: '{{customVariables}}',
          },
        },
      ]);

      expect(variables.length).to.equal(1);
      expect(variables[0].name).to.include('customVariables');
    });

    it('should extract i18n content variables', () => {
      const contentService = new ContentService();
      const { variables } = contentService.extractMessageVariables([
        {
          template: {
            type: StepTypeEnum.IN_APP,
            content: '{{i18n "group.key" var=customVar.subVar var2=secVar}}',
          },
        },
      ]);

      expect(variables.length).to.equal(2);

      const variablesNames = variables.map((variable) => variable.name);
      expect(variablesNames).to.include('customVar.subVar');
      expect(variablesNames).to.include('secVar');
    });

    it('should extract action steps variables', () => {
      const contentService = new ContentService();
      const { variables } = contentService.extractMessageVariables([
        {
          template: {
            type: StepTypeEnum.DELAY,
            content: '',
          },
          metadata: { type: DelayTypeEnum.SCHEDULED, delayPath: 'sendAt' },
        },
        {
          template: {
            type: StepTypeEnum.DIGEST,
            content: '',
          },
          metadata: { type: DigestTypeEnum.REGULAR, digestKey: 'path', unit: DigestUnitEnum.SECONDS, amount: 1 },
        },
      ]);

      const variablesNames = variables.map((variable) => variable.name);

      expect(variables.length).to.equal(2);
      expect(variablesNames).to.include('sendAt');
      expect(variablesNames).to.include('path');
    });

    it('should extract filter variables on payload', () => {
      const contentService = new ContentService();
      const { variables } = contentService.extractMessageVariables([
        {
          template: {
            type: StepTypeEnum.EMAIL,
            content: '{{name}}',
          },
          filters: [
            {
              isNegated: false,
              type: 'GROUP',
              value: FieldLogicalOperatorEnum.AND,
              children: [
                {
                  on: FilterPartTypeEnum.PAYLOAD,
                  field: 'counter',
                  value: 'test value',
                  operator: FieldOperatorEnum.EQUAL,
                },
              ],
            },
          ],
        },
      ]);

      const variablesNames = variables.map((variable) => variable.name);

      expect(variables.length).to.equal(2);
      expect(variablesNames).to.include('name');
      expect(variablesNames).to.include('counter');
    });

    it('should not extract variables reserved for the system', () => {
      const contentService = new ContentService();
      const messages = [
        {
          template: {
            type: StepTypeEnum.EMAIL,
            subject: 'Test {{subscriber.firstName}}',
            content: [
              {
                content: 'Test of {{subscriber.firstName}} {{lastName}}',
                type: 'text',
              },
            ],
          },
        },
      ] as INotificationTemplateStep[];
      const { variables: extractVariables } = contentService.extractMessageVariables(messages);

      expect(extractVariables.length).to.equal(1);
      expect(extractVariables[0].name).to.include('lastName');
    });
  });

  describe('extractStepVariables', () => {
    it('should not fail if no filters available', () => {
      const contentService = new ContentService();
      const messages = [
        {
          template: {
            type: StepTypeEnum.EMAIL,
            subject: 'Test {{subscriber.firstName}}',
            content: [
              {
                content: 'Test of {{subscriber.firstName}} {{lastName}}',
                type: 'text',
              },
            ],
          },
        },
      ] as INotificationTemplateStep[];
      const variables = contentService.extractStepVariables(messages);

      expect(variables.length).to.equal(0);
    });

    it('should not fail if filters are set as non array', () => {
      const contentService = new ContentService();
      const messages = [
        {
          template: {
            type: StepTypeEnum.EMAIL,
            subject: 'Test {{subscriber.firstName}}',
            content: [
              {
                content: 'Test of {{subscriber.firstName}} {{lastName}}',
                type: 'text',
              },
            ],
          },
          filters: {},
        },
      ] as INotificationTemplateStep[];
      const variables = contentService.extractStepVariables(messages);

      expect(variables.length).to.equal(0);
    });

    it('should not fail if filters are an empty array', () => {
      const contentService = new ContentService();
      const messages = [
        {
          template: {
            type: StepTypeEnum.EMAIL,
            subject: 'Test {{subscriber.firstName}}',
            content: [
              {
                content: 'Test of {{subscriber.firstName}} {{lastName}}',
                type: 'text',
              },
            ],
          },
          filters: [],
        },
      ] as INotificationTemplateStep[];
      const variables = contentService.extractStepVariables(messages);

      expect(variables.length).to.equal(0);
    });

    it('should not fail if filters have some wrong settings like missing children in filters', () => {
      const contentService = new ContentService();
      const messages = [
        {
          template: {
            type: StepTypeEnum.EMAIL,
            subject: 'Test {{subscriber.firstName}}',
            content: [
              {
                content: 'Test of {{subscriber.firstName}} {{lastName}}',
                type: 'text',
              },
            ],
          },
          filters: [
            {
              isNegated: false,
              type: 'GROUP',
              value: FieldLogicalOperatorEnum.AND,
            },
          ],
        },
      ] as INotificationTemplateStep[];
      const variables = contentService.extractStepVariables(messages);

      expect(variables.length).to.equal(0);
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - modified(contentService.replaceVariables(
        '{{firstName}} is the first {{firstName}} of {{firstName}}'...)
 - modified(contentService.replaceVariables(
        '{{firstName}} is the first {{$last_name}} of {{firstName}}...)
 - modified(contentService.replaceVariables('This is a text without variables', variables);
      expect(modifie...)
 - contentService(new ContentService();
      try {
        contentService.extractVariables('This is a text without va...)
 - variablesNames(extractVariables.map((variable))
 - extractVariables(contentService.extractVariables(' {{titlecase word}}');

      expect(extractVariables.length).to.eq...)
 - extractVariables(contentService.extractVariables(
        ' {{#each array}} {{@index}} {{#if @first}} First {{/if}} {...)
 - variables(contentService.extractSubscriberMessageVariables([
        {
          template: {
            type:...)
 - variables(contentService.extractSubscriberMessageVariables([
        {
          template: {
            type:...)
 - variablesNames(variables.map((variable))
 - variablesNames(variables.map((variable))
 - variablesNames(variables.map((variable))
 - variablesNames(variables.map((variable))
 - variables(contentService.extractStepVariables(messages);

      expect(variables.length).to.equal(0);
    });
...)
 - variables(contentService.extractStepVariables(messages);

      expect(variables.length).to.equal(0);
    });
...)
 - variables(contentService.extractStepVariables(messages);

      expect(variables.length).to.equal(0);
    });
...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/helpers/generate-transaction-id.ts
Tamaño: 145 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { generateObjectId } from '@novu/application-generic';

export function generateTransactionId() {
  return `txn_${generateObjectId()}`;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - generateTransactionId()
Declaraciones 'export' encontradas:
- export function generateTransactionId

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/helpers/index.ts
Tamaño: 68 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './generate-transaction-id';
export * from './utils';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/helpers/is-valid-hmac.ts
Tamaño: 751 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { createContextHash, createHash, decryptApiKey } from '@novu/application-generic';
import { ContextPayload } from '@novu/shared';

export function isHmacValid(secretKey: string, subscriberId: string, hmacHash: string | undefined) {
  if (!hmacHash) {
    return false;
  }

  const key = decryptApiKey(secretKey);
  const computedHmacHash = createHash(key, subscriberId);

  return computedHmacHash === hmacHash;
}

export function isContextHmacValid(
  secretKey: string,
  context: ContextPayload,
  contextHash: string | undefined
): boolean {
  if (!contextHash) {
    return false;
  }

  const key = decryptApiKey(secretKey);
  const computedContextHash = createContextHash(key, context);

  return computedContextHash === contextHash;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - isHmacValid(secretKey: string, subscriberId: string, hmacHash: string | undefined)
 - isContextHmacValid(secretKey: string,
  context: ContextPayload,
  contextHash: string | undefined)
Declaraciones 'export' encontradas:
- export function isHmacValid
- export function isContextHmacValid

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/helpers/maily-utils.ts
Tamaño: 14311 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { JSONContent as MailyJSONContent } from '@maily-to/render';
import { TRANSLATION_KEY_SINGLE_REGEX } from '@novu/shared';

import { MAILY_FIRST_CITIZEN_VARIABLE_KEY, MailyAttrsEnum, MailyContentTypeEnum } from './maily.types';

export const isStringifiedMailyJSONContent = (value: unknown): value is string => {
  if (typeof value !== 'string') return false;

  try {
    const parsed = JSON.parse(value);

    return isObjectMailyJSONContent(parsed);
  } catch {
    return false;
  }
};

export const isObjectMailyJSONContent = (value: unknown): value is MailyJSONContent => {
  if (!value || typeof value !== 'object') return false;

  const doc = value as MailyJSONContent;
  if (doc.type !== 'doc' || !Array.isArray(doc.content)) return false;

  return true;
};

export const isRepeatNode = (
  node: MailyJSONContent
): node is MailyJSONContent & { attrs: { [MailyAttrsEnum.EACH_KEY]: string } } => {
  return !!(
    (node.type === MailyContentTypeEnum.REPEAT || node.type === MailyContentTypeEnum.FOR) &&
    node.attrs &&
    node.attrs[MailyAttrsEnum.EACH_KEY] !== undefined &&
    typeof node.attrs[MailyAttrsEnum.EACH_KEY] === 'string'
  );
};

export const isVariableNode = (
  node: MailyJSONContent
): node is MailyJSONContent & { attrs: { [MailyAttrsEnum.ID]: string } } => {
  return !!(
    node.type === MailyContentTypeEnum.VARIABLE &&
    node.attrs &&
    node.attrs[MailyAttrsEnum.ID] !== undefined &&
    typeof node.attrs[MailyAttrsEnum.ID] === 'string'
  );
};

export const isButtonNode = (
  node: MailyJSONContent
): node is MailyJSONContent & { attrs: { [MailyAttrsEnum.ID]: string } } => {
  return !!(
    node.type === MailyContentTypeEnum.BUTTON &&
    node.attrs &&
    ((node.attrs[MailyAttrsEnum.TEXT] !== undefined && typeof node.attrs[MailyAttrsEnum.TEXT] === 'string') ||
      (node.attrs[MailyAttrsEnum.URL] !== undefined && typeof node.attrs[MailyAttrsEnum.URL] === 'string'))
  );
};

export const isImageNode = (
  node: MailyJSONContent
): node is MailyJSONContent & { attrs: { [MailyAttrsEnum.ID]: string } } => {
  return !!(
    (node.type === MailyContentTypeEnum.IMAGE || node.type === MailyContentTypeEnum.INLINE_IMAGE) &&
    node.attrs &&
    ((node.attrs[MailyAttrsEnum.SRC] !== undefined && typeof node.attrs[MailyAttrsEnum.SRC] === 'string') ||
      (node.attrs[MailyAttrsEnum.EXTERNAL_LINK] !== undefined &&
        typeof node.attrs[MailyAttrsEnum.EXTERNAL_LINK] === 'string'))
  );
};

export const isLinkNode = (
  node: MailyJSONContent
): node is MailyJSONContent & { attrs: { [MailyAttrsEnum.ID]: string } } => {
  return !!(
    node.type === MailyContentTypeEnum.LINK &&
    node.attrs &&
    node.attrs[MailyAttrsEnum.HREF] !== undefined &&
    typeof node.attrs[MailyAttrsEnum.HREF] === 'string'
  );
};

export const hasShow = (
  node: MailyJSONContent
): node is MailyJSONContent & { attrs: { [MailyAttrsEnum.SHOW_IF_KEY]: string } } => {
  return node.attrs?.[MailyAttrsEnum.SHOW_IF_KEY] !== undefined && node.attrs?.[MailyAttrsEnum.SHOW_IF_KEY] !== null;
};

export const hasAttrs = (node: MailyJSONContent): node is MailyJSONContent & { attrs: Record<string, any> } => {
  return !!node.attrs;
};

export const hasMarks = (node: MailyJSONContent): node is MailyJSONContent & { marks: Record<string, any>[] } => {
  return !!node.marks;
};

export const variableAttributeConfig = (type: MailyContentTypeEnum) => {
  const commonConfig = [
    /*
     * Maily Variable Map
     * * maily_id equals to maily_variable
     * * https://github.com/arikchakma/maily.to/blob/ebcf233eb1d4b16fb568fb702bf0756678db38d0/packages/render/src/maily.tsx#L787
     */
    { attr: MailyAttrsEnum.ID, flag: MailyAttrsEnum.ID },
    /*
     * showIfKey is always a maily_variable
     */
    { attr: MailyAttrsEnum.SHOW_IF_KEY, flag: MailyAttrsEnum.SHOW_IF_KEY },
    { attr: MailyAttrsEnum.EACH_KEY, flag: MailyAttrsEnum.EACH_KEY },
  ];

  if (type === MailyContentTypeEnum.BUTTON) {
    return [
      { attr: MailyAttrsEnum.TEXT, flag: MailyAttrsEnum.IS_TEXT_VARIABLE },
      { attr: MailyAttrsEnum.URL, flag: MailyAttrsEnum.IS_URL_VARIABLE },
      ...commonConfig,
    ];
  }

  if (type === MailyContentTypeEnum.IMAGE) {
    return [
      { attr: MailyAttrsEnum.SRC, flag: MailyAttrsEnum.IS_SRC_VARIABLE },
      {
        attr: MailyAttrsEnum.EXTERNAL_LINK,
        flag: MailyAttrsEnum.IS_EXTERNAL_LINK_VARIABLE,
      },
      ...commonConfig,
    ];
  }

  if (type === MailyContentTypeEnum.INLINE_IMAGE) {
    return [
      { attr: MailyAttrsEnum.SRC, flag: MailyAttrsEnum.IS_SRC_VARIABLE },
      {
        attr: MailyAttrsEnum.EXTERNAL_LINK,
        flag: MailyAttrsEnum.IS_EXTERNAL_LINK_VARIABLE,
      },
      ...commonConfig,
    ];
  }

  if (type === MailyContentTypeEnum.LINK) {
    return [{ attr: MailyAttrsEnum.HREF, flag: MailyAttrsEnum.IS_URL_VARIABLE }, ...commonConfig];
  }

  return commonConfig;
};

const wrapInLiquidOutput = (variableName: string, fallback?: string, aliasFor?: string): string => {
  const actualVariableName = aliasFor || variableName;
  const fallbackSuffix = fallback ? ` | default: '${fallback}'` : '';

  return `{{ ${actualVariableName}${fallbackSuffix} }}`;
};

type ProcessAttributesArgs = {
  attrValue: string;
  attrKey: MailyAttrsEnum;
  attrs: Record<string, any>;
};
type ProcessAttributesFunction = (args: ProcessAttributesArgs) => string | boolean | number;
type ShouldProcessAttrFunction = (args: ProcessAttributesArgs) => boolean;

type ProcessFlagArgs = {
  flagValue: string;
  flagKey: MailyAttrsEnum;
  attrs: Record<string, any>;
};
type ProcessFlagFunction = (args: ProcessFlagArgs) => string | boolean | number;
type ShouldProcessFlagFunction = (args: ProcessFlagArgs) => boolean;

const processVariableNodeAttributes = ({
  node,
  shouldProcessAttr,
  shouldProcessFlag,
  processAttr,
  processFlag,
}: {
  node: MailyJSONContent & { attrs: Record<string, string> };
  shouldProcessAttr?: ShouldProcessAttrFunction;
  shouldProcessFlag?: ShouldProcessFlagFunction;
  processAttr?: ProcessAttributesFunction;
  processFlag?: ProcessFlagFunction;
}) => {
  const { attrs, type } = node;
  const config = variableAttributeConfig(type as MailyContentTypeEnum);
  const processedAttrs = { ...attrs };

  config.forEach(({ attr, flag }) => {
    const attrValue = attrs[attr];
    const flagValue = attrs[flag];

    if (!flagValue || !attrValue || typeof attrValue !== 'string') {
      return;
    }

    const attrArgs = { attrValue, attrKey: attr, attrs };
    if (shouldProcessAttr?.(attrArgs) && processAttr) {
      processedAttrs[attr] = processAttr(attrArgs);
    }

    const flagArgs = { flagValue, flagKey: flag, attrs };
    if (shouldProcessFlag?.(flagArgs) && processFlag) {
      processedAttrs[flag] = processFlag(flagArgs);
    }
  });

  return processedAttrs;
};

const processNodeMarks = ({
  node,
  shouldProcessAttr,
  shouldProcessFlag,
  processAttr,
  processFlag,
}: {
  node: MailyJSONContent & { marks: Record<string, any>[] };
  shouldProcessAttr?: ShouldProcessAttrFunction;
  shouldProcessFlag?: ShouldProcessFlagFunction;
  processAttr?: ProcessAttributesFunction;
  processFlag?: ProcessFlagFunction;
}) => {
  return node.marks.map((mark) => {
    if (!mark.attrs) {
      return mark;
    }

    const { attrs } = mark;
    const processedMark = {
      ...mark,
      attrs: { ...attrs },
    };

    const config = variableAttributeConfig(mark.type as MailyContentTypeEnum);

    config.forEach(({ attr, flag }) => {
      const attrValue = attrs[attr];
      const flagValue = attrs[flag];

      if (!flagValue || !attrValue || typeof attrValue !== 'string') {
        return;
      }

      const attrArgs = { attrValue, attrKey: attr, attrs };
      if (shouldProcessAttr?.(attrArgs) && processAttr) {
        processedMark.attrs[attr] = processAttr(attrArgs);
      }

      const flagArgs = { flagValue, flagKey: flag, attrs };
      if (shouldProcessFlag?.(flagValue) && processFlag) {
        processedMark.attrs[flag] = processFlag(flagArgs);
      }
    });

    return processedMark;
  });
};

const processMailyNodes = ({
  node,
  shouldProcessAttr,
  shouldProcessFlag,
  processAttr,
  processFlag,
}: {
  node: MailyJSONContent;
  shouldProcessAttr?: ShouldProcessAttrFunction;
  shouldProcessFlag?: ShouldProcessFlagFunction;
  processAttr?: ProcessAttributesFunction;
  processFlag?: ProcessFlagFunction;
}): MailyJSONContent => {
  const newNode = { ...node } as MailyJSONContent & { attrs: Record<string, any> };

  if (node.content) {
    newNode.content = node.content.map((child) =>
      processMailyNodes({
        node: child,
        shouldProcessAttr,
        shouldProcessFlag,
        processAttr,
        processFlag,
      })
    );
  }

  if (hasAttrs(node)) {
    newNode.attrs = processVariableNodeAttributes({
      node,
      shouldProcessAttr,
      shouldProcessFlag,
      processAttr,
      processFlag,
    });
  }

  if (hasMarks(node)) {
    newNode.marks = processNodeMarks({
      node,
      shouldProcessAttr,
      shouldProcessFlag,
      processAttr,
      processFlag,
    });
  }

  return newNode;
};

/**
 * Replaces Maily nodes based on a condition function.
 *
 * @param content - The stringified Maily JSON content
 * @param conditionFn - Function that determines which nodes to replace
 * @param replacementFn - Function that returns the replacement node or nodes
 * @returns The modified Maily JSON content
 *
 * @example
 * Input:
 * {
 *   type: "doc",
 *   content: [
 *     { type: "variable", attrs: { id: "user.name" } },
 *     { type: "paragraph", content: [{ type: "text", text: "Hello" }] }
 *   ]
 * }
 *
 * replaceMailyNodesByCondition(
 *   content,
 *   (node) => node.type === "variable" && node.attrs?.id === "user.name",
 *   (node) => ({ type: "text", text: "John Doe" })
 * )
 *
 * Output:
 * {
 *   type: "doc",
 *   content: [
 *     { type: "text", text: "John Doe" },
 *     { type: "paragraph", content: [{ type: "text", text: "Hello" }] }
 *   ]
 * }
 */
export const replaceMailyNodesByCondition = (
  content: string,
  conditionFn: (node: MailyJSONContent) => boolean,
  replacementFn: (node: MailyJSONContent) => MailyJSONContent | MailyJSONContent[] | null
): MailyJSONContent => {
  const mailyJSONContent: MailyJSONContent = JSON.parse(content);

  const processNodes = (node: MailyJSONContent): MailyJSONContent | MailyJSONContent[] | null => {
    // Check if this node should be replaced
    if (conditionFn(node)) {
      return replacementFn(node);
    }

    // Process children if they exist
    if (node.content && Array.isArray(node.content)) {
      const processedContent: MailyJSONContent[] = [];

      for (const child of node.content) {
        const processedChild = processNodes(child);

        if (processedChild === null) {
        } else if (Array.isArray(processedChild)) {
          // Handle multiple replacement nodes
          processedContent.push(...processedChild);
        } else {
          // Handle single replacement node
          processedContent.push(processedChild);
        }
      }

      return {
        ...node,
        content: processedContent,
      };
    }

    return node;
  };

  const result = processNodes(mailyJSONContent);

  // Ensure we always return a single node (should be the root doc)
  return Array.isArray(result) ? result[0] : result || mailyJSONContent;
};

/**
 * Replaces Maily variables in the content with a replacement string.
 *
 * @example
 * Input:
 * {
 *   type: "repeat",
 *   attrs: { each: "payload.comments" },
 *   content: [{
 *     type: "variable",
 *     attrs: { id: "payload.comments.name" }
 *   }]
 * },
 * 'payload.comments.name',
 * 'FOO'
 *
 * Output:
 * {
 *   type: "repeat",
 *   attrs: { each: "payload.comments" },
 *   content: [{
 *     type: "variable",
 *     attrs: { id: "FOO" }
 *   }]
 * },
 */
export const replaceMailyVariables = (content: string, variableToReplace: string, replacement: string) => {
  const mailyJSONContent: MailyJSONContent = JSON.parse(content);

  return processMailyNodes({
    node: mailyJSONContent,
    shouldProcessAttr: ({ attrValue }) => attrValue === variableToReplace,
    processAttr: () => replacement,
  });
};

/**
 * Enriches Maily JSON content with Liquid syntax.
 *
 * @example
 * Input:
 * {
 *   type: "repeat",
 *   attrs: { each: "payload.comments" },
 *   content: [{
 *     type: "variable",
 *     attrs: { id: "payload.comments.name" }
 *   }]
 * },
 * {
 *   type: "variable",
 *   attrs: { id: "payload.test" }
 * }
 *
 * Output:
 * {
 *   type: "paragraph",
 *   attrs: { each: "{{ payload.comments }}" },
 *   content: [{
 *     type: "variable",
 *     text: "{{ payload.comments.name }}"
 *   }]
 * },
 * {
 *   type: "variable",
 *   text: "{{ payload.test }}"
 * }
 */
export const wrapMailyInLiquid = (content: string) => {
  const mailyJSONContent: MailyJSONContent = JSON.parse(content);

  return processMailyNodes({
    node: mailyJSONContent,
    shouldProcessAttr: ({ attrValue, attrKey, attrs }) => {
      // Don't process button variable by Liquid if it's a translation key
      if (
        attrKey === MailyAttrsEnum.TEXT &&
        attrs.isTextVariable === true &&
        TRANSLATION_KEY_SINGLE_REGEX.test(attrValue)
      ) {
        return false;
      }

      return true;
    },
    processAttr: ({ attrValue, attrs }) => {
      const { fallback, aliasFor } = attrs;

      return wrapInLiquidOutput(attrValue, fallback, aliasFor);
    },
    shouldProcessFlag: ({ flagKey }) => !MAILY_FIRST_CITIZEN_VARIABLE_KEY.includes(flagKey),
    processFlag: () => {
      return false;
    },
  });
};

export const hasMailyVariable = (content: string, variable: string): boolean => {
  const mailyJSONContent: MailyJSONContent = JSON.parse(content);
  let result = false;

  processMailyNodes({
    node: mailyJSONContent,
    shouldProcessAttr: ({ attrKey }) => attrKey === MailyAttrsEnum.ID,
    processAttr: ({ attrValue }) => {
      if (attrValue === variable) {
        result = true;
      }

      return attrValue;
    },
    shouldProcessFlag: ({ flagKey }) => flagKey === MailyAttrsEnum.ID,
    processFlag: ({ flagValue }) => {
      if (flagValue === variable) {
        result = true;
      }

      return flagValue;
    },
  });

  return result;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - isStringifiedMailyJSONContent(value: unknown): value is string)
 - isObjectMailyJSONContent(value: unknown): value is MailyJSONContent)
 - isRepeatNode(node: MailyJSONContent
): node is MailyJSONContent & { attrs: { [MailyAttrsEnum.EACH_KEY]: string } ...)
 - isVariableNode(node: MailyJSONContent
): node is MailyJSONContent & { attrs: { [MailyAttrsEnum.ID]: string } })
 - isButtonNode(node: MailyJSONContent
): node is MailyJSONContent & { attrs: { [MailyAttrsEnum.ID]: string } })
 - isImageNode(node: MailyJSONContent
): node is MailyJSONContent & { attrs: { [MailyAttrsEnum.ID]: string } })
 - isLinkNode(node: MailyJSONContent
): node is MailyJSONContent & { attrs: { [MailyAttrsEnum.ID]: string } })
 - hasShow(node: MailyJSONContent
): node is MailyJSONContent & { attrs: { [MailyAttrsEnum.SHOW_IF_KEY]: string...)
 - hasAttrs(node: MailyJSONContent): node is MailyJSONContent & { attrs: Record<string, any> })
 - hasMarks(node: MailyJSONContent): node is MailyJSONContent & { marks: Record<string, any>[] })
 - variableAttributeConfig(type: MailyContentTypeEnum))
 - wrapInLiquidOutput(variableName: string, fallback?: string, aliasFor?: string): string)
 - ProcessAttributesFunction(args: ProcessAttributesArgs))
 - ShouldProcessAttrFunction(args: ProcessAttributesArgs))
 - ProcessFlagFunction(args: ProcessFlagArgs))
 - ShouldProcessFlagFunction(args: ProcessFlagArgs))
 - processVariableNodeAttributes({
  node,
  shouldProcessAttr,
  shouldProcessFlag,
  processAttr,
  processFlag,
}: {
  node: Maily...)
 - processedAttrs({ ...attrs };

  config.forEach(({ attr, flag }))
 - processNodeMarks({
  node,
  shouldProcessAttr,
  shouldProcessFlag,
  processAttr,
  processFlag,
}: {
  node: Maily...)
 - config(variableAttributeConfig(mark.type as MailyContentTypeEnum);

    config.forEach(({ attr, flag }))
 - processMailyNodes({
  node,
  shouldProcessAttr,
  shouldProcessFlag,
  processAttr,
  processFlag,
}: {
  node: Maily...)
 - content(node.content.map((child))
 - marks(processNodeMarks({
      node,
      shouldProcessAttr,
      shouldProcessFlag,
      processAttr,
...)
 - replaceMailyNodesByCondition(content: string,
  conditionFn: (node: MailyJSONContent))
 - processNodes(node: MailyJSONContent): MailyJSONContent | MailyJSONContent[] | null)
 - replaceMailyVariables(content: string, variableToReplace: string, replacement: string))
 - MailyJSONContent(JSON.parse(content);

  return processMailyNodes({
    node: mailyJSONContent,
    shouldProcessAttr...)
 - wrapMailyInLiquid(content: string))
 - MailyJSONContent(JSON.parse(content);

  return processMailyNodes({
    node: mailyJSONContent,
    shouldProcessAttr...)
 - hasMailyVariable(content: string, variable: string): boolean)
 - result(false;

  processMailyNodes({
    node: mailyJSONContent,
    shouldProcessAttr: ({ attrKey }))
 - result(true;
      }

      return attrValue;
    },
    shouldProcessFlag: ({ flagKey }))
Declaraciones 'export' encontradas:
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/helpers/maily.types.ts
Tamaño: 856 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export enum MailyContentTypeEnum {
  VARIABLE = 'variable',
  REPEAT = 'repeat',
  /**
   * Legacy enum value maintained for backwards compatibility
   * @deprecated
   */
  FOR = 'for',
  BUTTON = 'button',
  IMAGE = 'image',
  INLINE_IMAGE = 'inlineImage',
  LINK = 'link',
}

export enum MailyAttrsEnum {
  ID = 'id',
  SHOW_IF_KEY = 'showIfKey',
  EACH_KEY = 'each',
  ITERATIONS_KEY = 'iterations',
  FALLBACK = 'fallback',
  ALIAS_FOR = 'aliasFor',
  IS_SRC_VARIABLE = 'isSrcVariable',
  IS_EXTERNAL_LINK_VARIABLE = 'isExternalLinkVariable',
  IS_TEXT_VARIABLE = 'isTextVariable',
  IS_URL_VARIABLE = 'isUrlVariable',
  TEXT = 'text',
  URL = 'url',
  SRC = 'src',
  EXTERNAL_LINK = 'externalLink',
  HREF = 'href',
}

export const MAILY_FIRST_CITIZEN_VARIABLE_KEY = [
  MailyAttrsEnum.ID,
  MailyAttrsEnum.SHOW_IF_KEY,
  MailyAttrsEnum.EACH_KEY,
];


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  enum
- export  enum
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/helpers/regex.service.ts
Tamaño: 136 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export function escapeRegExp(text: string): string {
  if (!text) return text;

  return text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - escapeRegExp(text: string)
Declaraciones 'export' encontradas:
- export function escapeRegExp

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/helpers/e2e/sdk/e2e-sdk.helper.ts
Tamaño: 4801 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { NovuCore } from '@novu/api/core';
import { SDKOptions } from '@novu/api/lib/config';
import { HTTPClient, HTTPClientOptions } from '@novu/api/lib/http';
import { ErrorDto, SDKValidationError, ValidationErrorDto } from '@novu/api/models/errors';
import { HttpRequestHeaderKeysEnum } from '@novu/application-generic';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

export function initNovuClassSdk(session: UserSession, shouldRetry: boolean = false): Novu {
  const options: SDKOptions = {
    security: { secretKey: session.apiKey },
    serverURL: session.serverUrl,
    debugLogger: process.env.LOG_LEVEL === 'debug' ? console : undefined,
  };
  if (!shouldRetry) {
    options.retryConfig = { strategy: 'none' };
  }

  return new Novu(options);
}
export function initNovuClassSdkInternalAuth(session: UserSession, shouldRetry: boolean = false): Novu {
  const options: SDKOptions = {
    security: { bearerAuth: session.token },
    serverURL: session.serverUrl,
    httpClient: new CustomHeaderHTTPClient({
      [HttpRequestHeaderKeysEnum.NOVU_ENVIRONMENT_ID]: session.environment._id,
    }),
    // debugLogger: console,
  };
  if (!shouldRetry) {
    options.retryConfig = { strategy: 'none' };
  }

  return new Novu(options);
}
export function initNovuFunctionSdk(session: UserSession): NovuCore {
  return new NovuCore({ security: { secretKey: session.apiKey }, serverURL: session.serverUrl });
}

function isErrorDto(error: unknown): error is ErrorDto {
  return typeof error === 'object' && error !== null && 'name' in error && error.name === 'ErrorDto';
}
function isValidationErrorDto(error: unknown): error is ValidationErrorDto {
  return typeof error === 'object' && error !== null && 'name' in error && error.name === 'ValidationErrorDto';
}

function isSDKValidationError(error: unknown): error is SDKValidationError {
  return (
    error instanceof SDKValidationError &&
    error.name === 'SDKValidationError' &&
    'rawValue' in error &&
    'rawMessage' in error &&
    'cause' in error
  );
}

export function handleSdkError(error: unknown): ErrorDto {
  if (!isErrorDto(error)) {
    throw new Error(`Provided error is not an ErrorDto error found:\n ${JSON.stringify(error, null, 2)}`);
  }
  expect(error.name).to.equal('ErrorDto');

  return error;
}

export function handleSdkZodFailure(error: unknown): SDKValidationError {
  if (!isSDKValidationError(error)) {
    throw new Error(`Provided error is not an ErrorDto error found:\n ${JSON.stringify(error, null, 2)}`);
  }
  expect(error.name).to.equal('SDKValidationError');

  return error;
}
export function handleValidationErrorDto(error: unknown): ValidationErrorDto {
  if (!isValidationErrorDto(error)) {
    throw new Error(`Provided error is not an ValidationErrorDto error found:\n ${JSON.stringify(error, null, 2)}`);
  }
  expect(error.name).to.equal('ValidationErrorDto');
  expect(error.ctx).to.be.ok;

  return error;
}

type AsyncAction<U> = () => Promise<U>;

export async function expectSdkExceptionGeneric<U>(
  action: AsyncAction<U>
): Promise<{ error?: ErrorDto; successfulBody?: U }> {
  try {
    const response = await action();

    return { successfulBody: response };
  } catch (e) {
    return { error: handleSdkError(e) };
  }
}
export async function expectSdkZodError<U>(
  action: AsyncAction<U>
): Promise<{ error?: SDKValidationError; successfulBody?: U }> {
  try {
    const response = await action();

    return { successfulBody: response };
  } catch (e) {
    return { error: handleSdkZodFailure(e) };
  }
}

export async function expectSdkValidationExceptionGeneric<U>(
  action: AsyncAction<U>
): Promise<{ error?: ValidationErrorDto; successfulBody?: U }> {
  try {
    const response = await action();

    return { successfulBody: response };
  } catch (e) {
    return { error: handleValidationErrorDto(e) };
  }
}
export class CustomHeaderHTTPClient extends HTTPClient {
  private defaultHeaders: HeadersInit;

  constructor(defaultHeaders: HeadersInit = {}, options: HTTPClientOptions = {}) {
    super(options);
    this.defaultHeaders = defaultHeaders;
  }

  async request(request: Request): Promise<Response> {
    // Create a new request with merged headers
    const mergedHeaders = new Headers(this.defaultHeaders);

    /*
     * Merge existing request headers with default headers
     * Existing request headers take precedence
     */
    request.headers.forEach((value, key) => {
      mergedHeaders.set(key, value);
    });

    // Create a new request with merged headers
    const modifiedRequest = new Request(request, {
      headers: mergedHeaders,
    });

    // Call the parent class's request method with the modified request
    return super.request(modifiedRequest);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - initNovuClassSdk(session: UserSession, shouldRetry: boolean = false)
 - initNovuClassSdkInternalAuth(session: UserSession, shouldRetry: boolean = false)
 - initNovuFunctionSdk(session: UserSession)
 - isErrorDto(error: unknown)
 - isValidationErrorDto(error: unknown)
 - isSDKValidationError(error: unknown)
 - handleSdkError(error: unknown)
 - handleSdkZodFailure(error: unknown)
 - handleValidationErrorDto(error: unknown)
Asignaciones con arrow functions encontradas (posibles funciones):
 - mergedHeaders(new Headers(this.defaultHeaders);

    /*
     * Merge existing request headers with default headers...)
Declaraciones 'export' encontradas:
- export function initNovuClassSdk
- export function initNovuClassSdkInternalAuth
- export function initNovuFunctionSdk
- export function handleSdkError
- export function handleSdkZodFailure
- export function handleValidationErrorDto
- export  async
- export  async
- export  async
- export class CustomHeaderHTTPClient

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/helpers/utils/index.ts
Tamaño: 50 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './mapMarkMessageToWebSocketEvent';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/helpers/utils/mapMarkMessageToWebSocketEvent.ts
Tamaño: 457 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { MessagesStatusEnum, WebSocketEventEnum } from '@novu/shared';

export function mapMarkMessageToWebSocketEvent(markAs: MessagesStatusEnum): WebSocketEventEnum | undefined {
  if (markAs === MessagesStatusEnum.READ || markAs === MessagesStatusEnum.UNREAD) {
    return WebSocketEventEnum.UNREAD;
  }

  if (markAs === MessagesStatusEnum.SEEN || markAs === MessagesStatusEnum.UNSEEN) {
    return WebSocketEventEnum.UNSEEN;
  }

  return undefined;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - mapMarkMessageToWebSocketEvent(markAs: MessagesStatusEnum)
Declaraciones 'export' encontradas:
- export function mapMarkMessageToWebSocketEvent

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/interceptors/product-feature.interceptor.ts
Tamaño: 1818 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  CallHandler,
  ExecutionContext,
  HttpException,
  Injectable,
  NestInterceptor,
  UnauthorizedException,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { ProductFeature } from '@novu/application-generic';
import { CommunityOrganizationRepository } from '@novu/dal';
import {
  ApiServiceLevelEnum,
  ProductFeatureKeyEnum,
  productFeatureEnabledForServiceLevel,
  UserSessionData,
} from '@novu/shared';
import { Observable } from 'rxjs';

@Injectable()
export class ProductFeatureInterceptor implements NestInterceptor {
  constructor(
    private reflector: Reflector,
    private organizationRepository: CommunityOrganizationRepository
  ) {}

  async intercept(context: ExecutionContext, next: CallHandler): Promise<Observable<any>> {
    const handler = context.getHandler();
    const classRef = context.getClass();
    const requestedFeature: ProductFeatureKeyEnum | undefined = this.reflector.getAllAndOverride(ProductFeature, [
      handler,
      classRef,
    ]);

    if (requestedFeature === undefined) {
      return next.handle();
    }

    const user = this.getReqUser(context);

    if (!user) {
      throw new UnauthorizedException();
    }

    const { organizationId } = user;

    const organization = await this.organizationRepository.findById(organizationId);

    const enabled = productFeatureEnabledForServiceLevel[requestedFeature].includes(
      organization?.apiServiceLevel || ApiServiceLevelEnum.FREE
    );

    if (!enabled) {
      // TODO: Reuse PaymentRequiredException from EE billing module.
      throw new HttpException('Payment Required', 402);
    }

    return next.handle();
  }

  private getReqUser(context: ExecutionContext): UserSessionData {
    const req = context.switchToHttp().getRequest();

    return req.user;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ProductFeatureInterceptor

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/middleware/request-id.middleware.ts
Tamaño: 475 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NestMiddleware } from '@nestjs/common';
import { generateObjectId } from '@novu/application-generic';
import { NextFunction, Request, Response } from 'express';

export interface RequestWithReqId extends Request {
  _nvRequestId: string;
}

@Injectable()
export class RequestIdMiddleware implements NestMiddleware {
  use(req: RequestWithReqId, _res: Response, next: NextFunction) {
    req._nvRequestId = `req_${generateObjectId()}`;

    next();
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  interface
- export class RequestIdMiddleware

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/services/control-value-sanitizer.service.ts
Tamaño: 6182 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import {
  dashboardSanitizeControlValues,
  layoutControlSchema,
  PinoLogger,
  SanitizationType,
} from '@novu/application-generic';
import { actionStepSchemas, channelStepSchemas } from '@novu/framework/internal';
import { ResourceOriginEnum } from '@novu/shared';
import Ajv, { ErrorObject } from 'ajv';
import addFormats from 'ajv-formats';
import { cloneDeep, get, merge, set } from 'es-toolkit/compat';
import { previewControlValueDefault } from '../../workflows-v2/usecases/preview/preview.constants';
import { ControlValueProcessingResult, PreviewTemplateData } from '../../workflows-v2/usecases/preview/preview.types';
import { replaceAll } from '../../workflows-v2/usecases/preview/utils/variable-helpers';
import { JSONSchemaDto } from '../dtos/json-schema.dto';
import { isObjectMailyJSONContent, isStringifiedMailyJSONContent, replaceMailyVariables } from '../helpers/maily-utils';
import { buildVariables } from '../utils/build-variables';
import { buildLiquidParser } from '../utils/template-parser/liquid-engine';
import type { Variable } from '../utils/template-parser/types';

@Injectable()
export class ControlValueSanitizerService {
  constructor(private readonly logger: PinoLogger) {}

  sanitizeControlsForPreview(
    initialControlValues: Record<string, unknown>,
    type: SanitizationType,
    resourceOrigin: ResourceOriginEnum
  ): Record<string, unknown> {
    if (resourceOrigin !== ResourceOriginEnum.NOVU_CLOUD) {
      return initialControlValues;
    }

    const sanitizedValues = dashboardSanitizeControlValues(this.logger, initialControlValues, type);
    const sanitizedByOutputSchema = this.sanitizeControlValuesByOutputSchema(sanitizedValues || {}, type);

    if (!sanitizedByOutputSchema) {
      throw new Error(
        'Control values normalization failed, normalizeControlValues function requires maintenance to sanitize the provided type or data structure correctly'
      );
    }

    return sanitizedByOutputSchema;
  }

  processControlValues(
    controlValues: Record<string, unknown>,
    variableSchema: JSONSchemaDto,
    variablesObject: Record<string, unknown>
  ): ControlValueProcessingResult {
    let previewTemplateData: PreviewTemplateData = {
      payloadExample: {},
      controlValues: {},
    };

    const sanitizedControls: Record<string, unknown> = {};

    for (const [controlKey, controlValue] of Object.entries(controlValues || {})) {
      const variables = buildVariables({
        variableSchema,
        controlValue,
        logger: this.logger,
      });

      const controlValueWithFixedVariables = this.fixControlValueInvalidVariables(
        controlValue,
        variables.invalidVariables
      );

      const processedControlValues = this.sanitizeControlValuesByLiquidCompilationFailure(
        controlKey,
        controlValueWithFixedVariables
      );

      sanitizedControls[controlKey] = processedControlValues;

      previewTemplateData = {
        payloadExample: merge(previewTemplateData.payloadExample, variablesObject),
        controlValues: {
          ...previewTemplateData.controlValues,
          [controlKey]: isObjectMailyJSONContent(processedControlValues)
            ? JSON.stringify(processedControlValues)
            : processedControlValues,
        },
      };
    }

    return { sanitizedControls, previewTemplateData };
  }

  private sanitizeControlValuesByOutputSchema(
    controlValues: Record<string, unknown>,
    type: SanitizationType
  ): Record<string, unknown> {
    let outputSchema = channelStepSchemas[type]?.output || actionStepSchemas[type]?.output;
    if (type === 'layout') {
      outputSchema = layoutControlSchema;
    }

    if (!outputSchema || !controlValues) {
      return controlValues;
    }

    const ajv = new Ajv({ allErrors: true });
    addFormats(ajv);
    const validate = ajv.compile(outputSchema);
    const isValid = validate(controlValues);
    const errors = validate.errors as null | ErrorObject[];

    if (isValid || !errors || errors?.length === 0) {
      return controlValues;
    }

    return this.replaceInvalidControlValues(controlValues, errors);
  }

  private replaceInvalidControlValues(
    normalizedControlValues: Record<string, unknown>,
    errors: ErrorObject[]
  ): Record<string, unknown> {
    const fixedValues = cloneDeep(normalizedControlValues);

    for (const error of errors) {
      if (error.keyword === 'additionalProperties') {
        continue;
      }

      const path = this.getErrorPath(error);
      const defaultValue = get(previewControlValueDefault, path);
      set(fixedValues, path, defaultValue);
    }

    return fixedValues;
  }

  private getErrorPath(error: ErrorObject): string {
    return (error.instancePath.substring(1) || error.params.missingProperty)?.replace(/\//g, '.');
  }

  private fixControlValueInvalidVariables(controlValue: unknown, invalidVariables: Variable[]): unknown {
    try {
      const EMPTY_STRING = '';
      const isMailyJSONContent = isStringifiedMailyJSONContent(controlValue);
      let controlValuesString = isMailyJSONContent ? controlValue : JSON.stringify(controlValue);

      for (const invalidVariable of invalidVariables) {
        let variableOutput = invalidVariable.output;

        if (isMailyJSONContent) {
          variableOutput = variableOutput.replace(/\{\{|\}\}/g, '').trim();
          controlValuesString = JSON.stringify(
            replaceMailyVariables(controlValuesString, variableOutput, EMPTY_STRING)
          );
          continue;
        }

        if (!controlValuesString.includes(variableOutput)) {
          continue;
        }

        controlValuesString = replaceAll(controlValuesString, variableOutput, EMPTY_STRING);
      }

      return JSON.parse(controlValuesString);
    } catch (error) {
      return controlValue;
    }
  }

  private sanitizeControlValuesByLiquidCompilationFailure(key: string, value: unknown): unknown {
    const parserEngine = buildLiquidParser();

    try {
      parserEngine.parse(JSON.stringify(value));

      return value;
    } catch (error) {
      return get(previewControlValueDefault, key);
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ControlValueSanitizerService

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/services/encryption/index.ts
Tamaño: 84 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export { decryptCredentials, encryptCredentials } from '@novu/application-generic';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/services/helper/helper.service.spec.ts
Tamaño: 588 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect } from 'chai';
import { toSentenceCase } from './helper.service';

describe('Helper Service', () => {
  describe('toSentenceCase', () => {
    it('should return an empty string if the input is empty', () => {
      expect(toSentenceCase('')).to.equal('');
    });

    it('should capitalize the first letter of the first word', () => {
      expect(toSentenceCase('hello world')).to.equal('Hello world');
    });

    it('should format camel cased text to sentence case', () => {
      expect(toSentenceCase('primaryAction')).to.equal('Primary action');
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

No se detectaron funciones/exportaciones con heurística JS/TS.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/services/helper/helper.service.ts
Tamaño: 990 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { v1 as uuidv1 } from 'uuid';

export function createGuid(): string {
  return uuidv1();
}

export function capitalize(text: string) {
  if (typeof text !== 'string') return '';

  return text.charAt(0).toUpperCase() + text.slice(1);
}

/**
 * Formats a string to sentence case.
 * @param text - The string to format.
 * @returns The formatted string.
 *
 * @example
 * ```typescript
 * toSentenceCase('camelCaseText') // 'Camel case text'
 * ```
 */
export function toSentenceCase(text: string) {
  if (!text) return '';

  // Insert spaces before uppercase letters and convert the entire string to lowercase
  const formattedText = text.replace(/([A-Z])/g, ' $1').toLowerCase();

  // Capitalize the first character
  return formattedText.charAt(0).toUpperCase() + formattedText.slice(1);
}

export function getFileExtensionFromPath(filePath: string) {
  const regexp = /\.([0-9a-z]+)(?:[?#]|$)/i;
  const extension = filePath.match(regexp);

  return extension && extension[1];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - createGuid()
 - capitalize(text: string)
 - toSentenceCase(text: string)
 - getFileExtensionFromPath(filePath: string)
Declaraciones 'export' encontradas:
- export function createGuid
- export function capitalize
- export function toSentenceCase
- export function getFileExtensionFromPath

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/services/mail/mail.service.ts
Tamaño: 1182 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import sgApi from '@sendgrid/mail';

export type IEmailRecipient = string | { name?: string; email: string };

export interface ISendMail {
  to: IEmailRecipient | IEmailRecipient[];
  from: {
    name: string;
    email: string;
  };
  subject?: string;
  text?: string;
  html?: string;
  templateId?: string;
  params?: {};
}

export class MailService {
  private sendgrid = sgApi;

  constructor() {
    this.sendgrid.setApiKey(process.env.SENDGRID_API_KEY ?? '');
  }

  async sendMail(mail: ISendMail) {
    if (!mail.templateId && !mail.subject) throw new Error('Either templateId or subject must be present');
    if (process.env.NODE_ENV === 'test') return null;

    const mailObject: any = {
      subject: mail.subject,
      dynamicTemplateData: mail.params,
      to: mail.to,
      from: {
        name: mail.from.name,
        email: mail.from.email,
      },
      templateId: undefined,
    };

    if (mail.templateId) {
      mailObject.templateId = mail.templateId;
    }

    if (mail.text) {
      mailObject.text = mail.text;
    }

    if (mail.html) {
      mailObject.html = mail.html;
    }

    return await this.sendgrid.send(mailObject, false);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export  interface
- export class MailService

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/services/query-parser/query-parser.service.spec.ts
Tamaño: 26119 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect } from 'chai';
import { AdditionalOperation, RulesLogic } from 'json-logic-js';

import { evaluateRules } from './query-parser.service';

describe('QueryParserService', () => {
  describe('Smoke Tests', () => {
    it('should evaluate a simple equality rule', () => {
      const rule: RulesLogic<AdditionalOperation> = { '=': [{ var: 'value' }, 42] };
      const data = { value: 42 };
      const { result, error } = evaluateRules(rule, data);
      expect(error).to.be.undefined;
      expect(result).to.be.true;
    });

    it('should evaluate a complex nested rule', () => {
      const rule: RulesLogic<AdditionalOperation> = {
        and: [
          { '=': [{ var: 'value' }, 42] },
          { startsWith: [{ var: 'text' }, 'hello'] },
          { notBetween: [{ var: 'number' }, [1, 5]] },
        ],
      };
      const data = { value: 42, text: 'hello world', number: 10 };
      const { result, error } = evaluateRules(rule, data);
      expect(error).to.be.undefined;
      expect(result).to.be.true;
    });

    describe('Error Handling', () => {
      it('should handle invalid data types gracefully', () => {
        const rule: RulesLogic<AdditionalOperation> = { startsWith: [{ var: 'text' }, 123] };
        const data = { text: 'hello' };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.false;
      });

      it('should throw error when safe mode is disabled', () => {
        const rule: RulesLogic<AdditionalOperation> = { invalid: 'operator' };
        const data = { text: 'hello' };
        expect(() => evaluateRules(rule, data, false)).to.throw('Failed to evaluate rule');
      });

      it('should return false and error when safe mode is enabled', () => {
        const rule: RulesLogic<AdditionalOperation> = { invalid: 'operator' };
        const data = { text: 'hello' };
        const { result, error } = evaluateRules(rule, data, true);
        expect(error).to.not.be.undefined;
        expect(result).to.be.false;
      });
    });
  });

  describe('Custom Operators', () => {
    describe('= operator', () => {
      it('should return true when values are equal', () => {
        const rule: RulesLogic<AdditionalOperation> = { '=': [{ var: 'value' }, 42] };
        const data = { value: 42 };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.true;
      });

      it('should return true when strings are equal', () => {
        const rule: RulesLogic<AdditionalOperation> = { '=': [{ var: 'text' }, 'hello'] };
        const data = { text: 'hello' };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.true;
      });

      it('should return true when comparing number and string (type coercion)', () => {
        const rule: RulesLogic<AdditionalOperation> = { '=': [{ var: 'value' }, '42'] };
        const data = { value: 42 };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.true;
      });

      it('should return false when values are not equal', () => {
        const rule: RulesLogic<AdditionalOperation> = { '=': [{ var: 'value' }, 42] };
        const data = { value: 43 };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.false;
      });

      it('should return false when types are different and values cannot be coerced', () => {
        const rule: RulesLogic<AdditionalOperation> = { '=': [{ var: 'value' }, 'not a number'] };
        const data = { value: 42 };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.false;
      });
    });

    describe('startsWith operator', () => {
      it('should return true when string begins with given value', () => {
        const rule: RulesLogic<AdditionalOperation> = { startsWith: [{ var: 'text' }, 'hello'] };
        const data = { text: 'hello world' };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.true;
      });

      it('should return false when string does not begin with given value', () => {
        const rule: RulesLogic<AdditionalOperation> = { startsWith: [{ var: 'text' }, 'world'] };
        const data = { text: 'hello world' };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.false;
      });
    });

    describe('endsWith operator', () => {
      it('should return true when string ends with given value', () => {
        const rule: RulesLogic<AdditionalOperation> = { endsWith: [{ var: 'text' }, 'world'] };
        const data = { text: 'hello world' };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.true;
      });

      it('should return false when string does not end with given value', () => {
        const rule: RulesLogic<AdditionalOperation> = { endsWith: [{ var: 'text' }, 'hello'] };
        const data = { text: 'hello world' };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.false;
      });
    });

    describe('contains operator', () => {
      it('should return true when string contains given value', () => {
        const rule: RulesLogic<AdditionalOperation> = { contains: [{ var: 'text' }, 'llo wo'] };
        const data = { text: 'hello world' };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.true;
      });

      it('should return false when string does not contain given value', () => {
        const rule: RulesLogic<AdditionalOperation> = { contains: [{ var: 'text' }, 'xyz'] };
        const data = { text: 'hello world' };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.false;
      });
    });

    describe('doesNotContain operator', () => {
      it('should return true when string does not contain given value', () => {
        const rule: RulesLogic<AdditionalOperation> = { doesNotContain: [{ var: 'text' }, 'xyz'] };
        const data = { text: 'hello world' };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.true;
      });

      it('should return false when string contains given value', () => {
        const rule: RulesLogic<AdditionalOperation> = { doesNotContain: [{ var: 'text' }, 'llo'] };
        const data = { text: 'hello world' };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.false;
      });
    });

    describe('doesNotBeginWith operator', () => {
      it('should return true when string does not begin with given value', () => {
        const rule: RulesLogic<AdditionalOperation> = { doesNotBeginWith: [{ var: 'text' }, 'world'] };
        const data = { text: 'hello world' };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.true;
      });

      it('should return false when string begins with given value', () => {
        const rule: RulesLogic<AdditionalOperation> = { doesNotBeginWith: [{ var: 'text' }, 'hello'] };
        const data = { text: 'hello world' };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.false;
      });
    });

    describe('doesNotEndWith operator', () => {
      it('should return true when string does not end with given value', () => {
        const rule: RulesLogic<AdditionalOperation> = { doesNotEndWith: [{ var: 'text' }, 'hello'] };
        const data = { text: 'hello world' };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.true;
      });

      it('should return false when string ends with given value', () => {
        const rule: RulesLogic<AdditionalOperation> = { doesNotEndWith: [{ var: 'text' }, 'world'] };
        const data = { text: 'hello world' };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.false;
      });
    });

    describe('null operator', () => {
      it('should return true when value is null', () => {
        const rule: RulesLogic<AdditionalOperation> = { null: [{ var: 'value' }] };
        const data = { value: null };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.true;
      });

      it('should return false when value is not null', () => {
        const rule: RulesLogic<AdditionalOperation> = { null: [{ var: 'value' }] };
        const data = { value: 'hello' };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.false;
      });
    });

    describe('notNull operator', () => {
      it('should return true when value is not null', () => {
        const rule: RulesLogic<AdditionalOperation> = { notNull: [{ var: 'value' }] };
        const data = { value: 'hello' };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.true;
      });

      it('should return false when value is null', () => {
        const rule: RulesLogic<AdditionalOperation> = { notNull: [{ var: 'value' }] };
        const data = { value: null };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.false;
      });
    });

    describe('notIn operator', () => {
      it('should return true when value is not in array', () => {
        const rule: RulesLogic<AdditionalOperation> = { notIn: [{ var: 'value' }, ['a', 'b', 'c']] };
        const data = { value: 'd' };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.true;
      });

      it('should return false when value is in array', () => {
        const rule: RulesLogic<AdditionalOperation> = { notIn: [{ var: 'value' }, ['a', 'b', 'c']] };
        const data = { value: 'b' };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.false;
      });

      it('should return false when ruleValue is not an array', () => {
        const rule: RulesLogic<AdditionalOperation> = { notIn: [{ var: 'value' }, 'not an array'] };
        const data = { value: 'b' };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.false;
      });
    });

    describe('between operator', () => {
      it('should return true when number is between min and max', () => {
        const rule: RulesLogic<AdditionalOperation> = { between: [{ var: 'value' }, [5, 10]] };
        const data = { value: 7 };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.true;
      });

      it('should return true when number equals min', () => {
        const rule: RulesLogic<AdditionalOperation> = { between: [{ var: 'value' }, [5, 10]] };
        const data = { value: 5 };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.true;
      });

      it('should return true when number equals max', () => {
        const rule: RulesLogic<AdditionalOperation> = { between: [{ var: 'value' }, [5, 10]] };
        const data = { value: 10 };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.true;
      });

      it('should return false when number is less than min', () => {
        const rule: RulesLogic<AdditionalOperation> = { between: [{ var: 'value' }, [5, 10]] };
        const data = { value: 4 };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.false;
      });

      it('should return false when number is greater than max', () => {
        const rule: RulesLogic<AdditionalOperation> = { between: [{ var: 'value' }, [5, 10]] };
        const data = { value: 11 };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.false;
      });

      it('should return false when value is not a number', () => {
        const rule: RulesLogic<AdditionalOperation> = { between: [{ var: 'value' }, [5, 10]] };
        const data = { value: 'not a number' };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.false;
      });

      it('should return false when range is not valid', () => {
        const rule: RulesLogic<AdditionalOperation> = { between: [{ var: 'value' }, [5]] };
        const data = { value: 7 };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.false;
      });
    });

    describe('notBetween operator', () => {
      it('should return true when number is less than min', () => {
        const rule: RulesLogic<AdditionalOperation> = { notBetween: [{ var: 'value' }, [5, 10]] };
        const data = { value: 4 };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.true;
      });

      it('should return true when number is greater than max', () => {
        const rule: RulesLogic<AdditionalOperation> = { notBetween: [{ var: 'value' }, [5, 10]] };
        const data = { value: 11 };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.true;
      });

      it('should return false when number is between min and max', () => {
        const rule: RulesLogic<AdditionalOperation> = { notBetween: [{ var: 'value' }, [5, 10]] };
        const data = { value: 7 };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.false;
      });

      it('should return false when number equals min', () => {
        const rule: RulesLogic<AdditionalOperation> = { notBetween: [{ var: 'value' }, [5, 10]] };
        const data = { value: 5 };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.false;
      });

      it('should return false when number equals max', () => {
        const rule: RulesLogic<AdditionalOperation> = { notBetween: [{ var: 'value' }, [5, 10]] };
        const data = { value: 10 };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.false;
      });

      it('should return false when value is not a number', () => {
        const rule: RulesLogic<AdditionalOperation> = { notBetween: [{ var: 'value' }, [5, 10]] };
        const data = { value: 'not a number' };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.false;
      });

      it('should return false when range is not valid', () => {
        const rule: RulesLogic<AdditionalOperation> = { notBetween: [{ var: 'value' }, [5]] };
        const data = { value: 7 };
        const { result, error } = evaluateRules(rule, data);
        expect(error).to.be.undefined;
        expect(result).to.be.false;
      });
    });

    describe('Relative Date Operators', () => {
      describe('moreThanXAgo operator', () => {
        it('should return true when date is more than 5 days ago', () => {
          const sevenDaysAgo = new Date();
          sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

          const rule: RulesLogic<AdditionalOperation> = {
            moreThanXAgo: [{ var: 'createdAt' }, { amount: 5, unit: 'days' }],
          };
          const data = { createdAt: sevenDaysAgo.toISOString() };
          const { result, error } = evaluateRules(rule, data);
          expect(error).to.be.undefined;
          expect(result).to.be.true;
        });

        it('should return false when date is less than 5 days ago', () => {
          const threeDaysAgo = new Date();
          threeDaysAgo.setDate(threeDaysAgo.getDate() - 3);

          const rule: RulesLogic<AdditionalOperation> = {
            moreThanXAgo: [{ var: 'createdAt' }, { amount: 5, unit: 'days' }],
          };
          const data = { createdAt: threeDaysAgo.toISOString() };
          const { result, error } = evaluateRules(rule, data);
          expect(error).to.be.undefined;
          expect(result).to.be.false;
        });

        it('should return false with invalid date input', () => {
          const rule: RulesLogic<AdditionalOperation> = {
            moreThanXAgo: [{ var: 'createdAt' }, { amount: 5, unit: 'days' }],
          };
          const data = { createdAt: 'invalid-date' };
          const { result, error } = evaluateRules(rule, data);
          expect(error).to.be.undefined;
          expect(result).to.be.false;
        });

        it('should return false with invalid rule value', () => {
          const rule: RulesLogic<AdditionalOperation> = {
            moreThanXAgo: [{ var: 'createdAt' }, { amount: 'invalid', unit: 'days' }],
          };
          const data = { createdAt: new Date().toISOString() };
          const { result, error } = evaluateRules(rule, data);
          expect(error).to.be.undefined;
          expect(result).to.be.false;
        });
      });

      describe('lessThanXAgo operator', () => {
        it('should return true when date is less than 5 days ago', () => {
          const threeDaysAgo = new Date();
          threeDaysAgo.setDate(threeDaysAgo.getDate() - 3);

          const rule: RulesLogic<AdditionalOperation> = {
            lessThanXAgo: [{ var: 'createdAt' }, { amount: 5, unit: 'days' }],
          };
          const data = { createdAt: threeDaysAgo.toISOString() };
          const { result, error } = evaluateRules(rule, data);
          expect(error).to.be.undefined;
          expect(result).to.be.true;
        });

        it('should return false when date is more than 5 days ago', () => {
          const sevenDaysAgo = new Date();
          sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

          const rule: RulesLogic<AdditionalOperation> = {
            lessThanXAgo: [{ var: 'createdAt' }, { amount: 5, unit: 'days' }],
          };
          const data = { createdAt: sevenDaysAgo.toISOString() };
          const { result, error } = evaluateRules(rule, data);
          expect(error).to.be.undefined;
          expect(result).to.be.false;
        });
      });

      describe('withinLast operator', () => {
        it('should return true when date is within last 5 days', () => {
          const threeDaysAgo = new Date();
          threeDaysAgo.setDate(threeDaysAgo.getDate() - 3);

          const rule: RulesLogic<AdditionalOperation> = {
            withinLast: [{ var: 'createdAt' }, { amount: 5, unit: 'days' }],
          };
          const data = { createdAt: threeDaysAgo.toISOString() };
          const { result, error } = evaluateRules(rule, data);
          expect(error).to.be.undefined;
          expect(result).to.be.true;
        });

        it('should return false when date is more than 5 days ago', () => {
          const sevenDaysAgo = new Date();
          sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

          const rule: RulesLogic<AdditionalOperation> = {
            withinLast: [{ var: 'createdAt' }, { amount: 5, unit: 'days' }],
          };
          const data = { createdAt: sevenDaysAgo.toISOString() };
          const { result, error } = evaluateRules(rule, data);
          expect(error).to.be.undefined;
          expect(result).to.be.false;
        });

        it('should return false when date is in the future', () => {
          const tomorrow = new Date();
          tomorrow.setDate(tomorrow.getDate() + 1);

          const rule: RulesLogic<AdditionalOperation> = {
            withinLast: [{ var: 'createdAt' }, { amount: 5, unit: 'days' }],
          };
          const data = { createdAt: tomorrow.toISOString() };
          const { result, error } = evaluateRules(rule, data);
          expect(error).to.be.undefined;
          expect(result).to.be.false;
        });
      });

      describe('notWithinLast operator', () => {
        it('should return true when date is more than 5 days ago', () => {
          const sevenDaysAgo = new Date();
          sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

          const rule: RulesLogic<AdditionalOperation> = {
            notWithinLast: [{ var: 'createdAt' }, { amount: 5, unit: 'days' }],
          };
          const data = { createdAt: sevenDaysAgo.toISOString() };
          const { result, error } = evaluateRules(rule, data);
          expect(error).to.be.undefined;
          expect(result).to.be.true;
        });

        it('should return false when date is within last 5 days', () => {
          const threeDaysAgo = new Date();
          threeDaysAgo.setDate(threeDaysAgo.getDate() - 3);

          const rule: RulesLogic<AdditionalOperation> = {
            notWithinLast: [{ var: 'createdAt' }, { amount: 5, unit: 'days' }],
          };
          const data = { createdAt: threeDaysAgo.toISOString() };
          const { result, error } = evaluateRules(rule, data);
          expect(error).to.be.undefined;
          expect(result).to.be.false;
        });
      });

      describe('exactlyXAgo operator', () => {
        it('should return true when date is exactly (within tolerance) 5 days ago', () => {
          const fiveDaysAgo = new Date();
          fiveDaysAgo.setDate(fiveDaysAgo.getDate() - 5);

          const rule: RulesLogic<AdditionalOperation> = {
            exactlyXAgo: [{ var: 'createdAt' }, { amount: 5, unit: 'days' }],
          };
          const data = { createdAt: fiveDaysAgo.toISOString() };
          const { result, error } = evaluateRules(rule, data);
          expect(error).to.be.undefined;
          expect(result).to.be.true;
        });

        it('should return false when date is significantly different from 5 days ago', () => {
          const tenDaysAgo = new Date();
          tenDaysAgo.setDate(tenDaysAgo.getDate() - 10);

          const rule: RulesLogic<AdditionalOperation> = {
            exactlyXAgo: [{ var: 'createdAt' }, { amount: 5, unit: 'days' }],
          };
          const data = { createdAt: tenDaysAgo.toISOString() };
          const { result, error } = evaluateRules(rule, data);
          expect(error).to.be.undefined;
          expect(result).to.be.false;
        });
      });

      describe('Different time units', () => {
        it('should work with hours', () => {
          const threeHoursAgo = new Date();
          threeHoursAgo.setHours(threeHoursAgo.getHours() - 3);

          const rule: RulesLogic<AdditionalOperation> = {
            withinLast: [{ var: 'createdAt' }, { amount: 5, unit: 'hours' }],
          };
          const data = { createdAt: threeHoursAgo.toISOString() };
          const { result, error } = evaluateRules(rule, data);
          expect(error).to.be.undefined;
          expect(result).to.be.true;
        });

        it('should work with minutes', () => {
          const tenMinutesAgo = new Date();
          tenMinutesAgo.setMinutes(tenMinutesAgo.getMinutes() - 10);

          const rule: RulesLogic<AdditionalOperation> = {
            moreThanXAgo: [{ var: 'createdAt' }, { amount: 5, unit: 'minutes' }],
          };
          const data = { createdAt: tenMinutesAgo.toISOString() };
          const { result, error } = evaluateRules(rule, data);
          expect(error).to.be.undefined;
          expect(result).to.be.true;
        });

        it('should work with weeks', () => {
          const threeWeeksAgo = new Date();
          threeWeeksAgo.setDate(threeWeeksAgo.getDate() - 21);

          const rule: RulesLogic<AdditionalOperation> = {
            moreThanXAgo: [{ var: 'createdAt' }, { amount: 2, unit: 'weeks' }],
          };
          const data = { createdAt: threeWeeksAgo.toISOString() };
          const { result, error } = evaluateRules(rule, data);
          expect(error).to.be.undefined;
          expect(result).to.be.true;
        });

        it('should work with months', () => {
          const threeMonthsAgo = new Date();
          threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);

          const rule: RulesLogic<AdditionalOperation> = {
            moreThanXAgo: [{ var: 'createdAt' }, { amount: 2, unit: 'months' }],
          };
          const data = { createdAt: threeMonthsAgo.toISOString() };
          const { result, error } = evaluateRules(rule, data);
          expect(error).to.be.undefined;
          expect(result).to.be.true;
        });

        it('should work with years', () => {
          const twoYearsAgo = new Date();
          twoYearsAgo.setFullYear(twoYearsAgo.getFullYear() - 2);

          const rule: RulesLogic<AdditionalOperation> = {
            moreThanXAgo: [{ var: 'createdAt' }, { amount: 1, unit: 'years' }],
          };
          const data = { createdAt: twoYearsAgo.toISOString() };
          const { result, error } = evaluateRules(rule, data);
          expect(error).to.be.undefined;
          expect(result).to.be.true;
        });
      });
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - data({ text: 'hello' };
        expect(())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/services/query-parser/query-parser.service.ts
Tamaño: 12478 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import jsonLogic, { AdditionalOperation, RulesLogic } from 'json-logic-js';

type RangeValidation =
  | {
      isValid: true;
      min: number;
      max: number;
    }
  | {
      isValid: false;
    };

type StringValidation =
  | {
      isValid: true;
      input: string;
      value: string;
    }
  | {
      isValid: false;
    };

type BooleanValidation =
  | {
      isValid: true;
      input: boolean;
    }
  | {
      isValid: false;
    };

type RelativeDateValidation =
  | {
      isValid: true;
      amount: number;
      unit: 'minutes' | 'hours' | 'days' | 'weeks' | 'months' | 'years';
    }
  | {
      isValid: false;
    };

function validateStringInput(dataInput: unknown, ruleValue: unknown): StringValidation {
  if (typeof dataInput !== 'string' || typeof ruleValue !== 'string') {
    return { isValid: false };
  }

  return { isValid: true, input: dataInput, value: ruleValue };
}

function validateRangeInput(dataInput: unknown, ruleValue: unknown): RangeValidation {
  if (!Array.isArray(ruleValue) || ruleValue.length !== 2) {
    return { isValid: false };
  }

  if (typeof dataInput !== 'number') {
    return { isValid: false };
  }

  const [min, max] = ruleValue;
  const valid = typeof min === 'number' && typeof max === 'number';

  return { isValid: valid, min, max };
}

function validateBooleanInput(dataInput: unknown): BooleanValidation {
  if (typeof dataInput !== 'boolean' && dataInput !== 'true' && dataInput !== 'false') {
    return { isValid: false };
  }

  return { isValid: true, input: typeof dataInput === 'boolean' ? dataInput : dataInput === 'true' };
}

function validateRelativeDateInput(ruleValue: unknown): RelativeDateValidation {
  if (typeof ruleValue !== 'object' || ruleValue === null) {
    return { isValid: false };
  }

  const value = ruleValue as { amount?: unknown; unit?: unknown };
  if (typeof value.amount !== 'number' || value.amount <= 0) {
    return { isValid: false };
  }

  const validUnits = ['minutes', 'hours', 'days', 'weeks', 'months', 'years'];
  if (typeof value.unit !== 'string' || !validUnits.includes(value.unit)) {
    return { isValid: false };
  }

  return {
    isValid: true,
    amount: value.amount,
    unit: value.unit as 'minutes' | 'hours' | 'days' | 'weeks' | 'months' | 'years',
  };
}

function calculateRelativeDate(amount: number, unit: string, fromDate = new Date()): Date {
  const date = new Date(fromDate);

  switch (unit) {
    case 'minutes':
      date.setMinutes(date.getMinutes() - amount);
      break;
    case 'hours':
      date.setHours(date.getHours() - amount);
      break;
    case 'days':
      date.setDate(date.getDate() - amount);
      break;
    case 'weeks':
      date.setDate(date.getDate() - amount * 7);
      break;
    case 'months':
      date.setMonth(date.getMonth() - amount);
      break;
    case 'years':
      date.setFullYear(date.getFullYear() - amount);
      break;
    default:
      // fallback to days if unit is not recognized
      date.setDate(date.getDate() - amount);
      break;
  }

  return date;
}

function getToleranceMs(unit: string): number {
  switch (unit) {
    case 'minutes':
      return 60 * 1000; // ±1 minute tolerance
    case 'hours':
      return 60 * 60 * 1000; // ±1 hour tolerance
    case 'days':
    case 'weeks':
    case 'months':
      return 24 * 60 * 60 * 1000; // ±1 day tolerance
    case 'years':
      return 7 * 24 * 60 * 60 * 1000; // ±1 week tolerance
    default:
      return 24 * 60 * 60 * 1000; // default to 1 day
  }
}

function validateComparison(
  a: unknown,
  b: unknown
): { isValid: true; a: number | string | boolean; b: number | string | boolean } | { isValid: false } {
  // handle boolean values and string representations of booleans
  const booleanA = validateBooleanInput(a);
  const booleanB = validateBooleanInput(b);
  if (booleanA.isValid && booleanB.isValid) {
    return { isValid: true, a: booleanA.input, b: booleanB.input };
  }

  // try to convert to numbers if possible
  const numA = Number(a);
  const numB = Number(b);
  if (!Number.isNaN(numA) && !Number.isNaN(numB)) {
    return { isValid: true, a: numA, b: numB };
  }

  // handle dates
  if (typeof a === 'string' && typeof b === 'string') {
    const dateA = new Date(a);
    const dateB = new Date(b);

    if (!Number.isNaN(dateA.getTime()) && !Number.isNaN(dateB.getTime())) {
      return { isValid: true, a: dateA.getTime(), b: dateB.getTime() };
    }
  }

  return { isValid: false };
}

function createStringOperator(evaluator: (input: string, value: string) => boolean) {
  return (dataInput: unknown, ruleValue: unknown): boolean => {
    const validation = validateStringInput(dataInput, ruleValue);
    if (!validation.isValid) return false;

    return evaluator(validation.input, validation.value);
  };
}

const initializeCustomOperators = (): void => {
  jsonLogic.add_operation('=', (dataInput: unknown, ruleValue: unknown): boolean => {
    const result = jsonLogic.apply({ '==': [dataInput, ruleValue] }, {});

    return typeof result === 'boolean' ? result : false;
  });

  jsonLogic.add_operation(
    'startsWith',
    createStringOperator((input, value) => input.startsWith(value))
  );

  jsonLogic.add_operation(
    'endsWith',
    createStringOperator((input, value) => input.endsWith(value))
  );

  jsonLogic.add_operation(
    'contains',
    createStringOperator((input, value) => input.includes(value))
  );

  jsonLogic.add_operation(
    'doesNotContain',
    createStringOperator((input, value) => !input.includes(value))
  );

  jsonLogic.add_operation(
    'doesNotBeginWith',
    createStringOperator((input, value) => !input.startsWith(value))
  );

  jsonLogic.add_operation(
    'doesNotEndWith',
    createStringOperator((input, value) => !input.endsWith(value))
  );

  jsonLogic.add_operation('null', (dataInput: unknown): boolean => dataInput === null);

  jsonLogic.add_operation('notNull', (dataInput: unknown): boolean => dataInput !== null);

  jsonLogic.add_operation(
    'notIn',
    (dataInput: unknown, ruleValue: unknown[]): boolean => Array.isArray(ruleValue) && !ruleValue.includes(dataInput)
  );

  jsonLogic.add_operation('between', (dataInput, ruleValue) => {
    const validation = validateRangeInput(dataInput, ruleValue);

    if (!validation.isValid) {
      return false;
    }

    return dataInput >= validation.min && dataInput <= validation.max;
  });

  jsonLogic.add_operation('notBetween', (dataInput, ruleValue) => {
    const validation = validateRangeInput(dataInput, ruleValue);

    if (!validation.isValid) {
      return false;
    }

    return dataInput < validation.min || dataInput > validation.max;
  });

  jsonLogic.rm_operation('<');
  jsonLogic.add_operation('<', (a: unknown, b: unknown) => {
    const validation = validateComparison(a, b);
    if (!validation.isValid) return false;

    return validation.a < validation.b;
  });

  jsonLogic.rm_operation('>');
  jsonLogic.add_operation('>', (a: unknown, b: unknown) => {
    const validation = validateComparison(a, b);
    if (!validation.isValid) return false;

    return validation.a > validation.b;
  });

  jsonLogic.rm_operation('<=');
  jsonLogic.add_operation('<=', (first: unknown, second: unknown, third?: unknown) => {
    // handle three argument case (typically used in between operations)
    if (third !== undefined) {
      const validation1 = validateComparison(first, second);
      const validation2 = validateComparison(second, third);
      if (!validation1.isValid || !validation2.isValid) return false;

      return validation1.a <= validation1.b && validation1.b <= validation2.b;
    }

    const validation = validateComparison(first, second);
    if (!validation.isValid) return false;

    return validation.a <= validation.b;
  });

  jsonLogic.rm_operation('>=');
  jsonLogic.add_operation('>=', (a: unknown, b: unknown) => {
    const validation = validateComparison(a, b);
    if (!validation.isValid) return false;

    return validation.a >= validation.b;
  });

  jsonLogic.rm_operation('==');
  jsonLogic.add_operation('==', (a: unknown, b: unknown) => {
    const validation = validateComparison(a, b);
    if (!validation.isValid) {
      // fall back to strict equality for other types
      return a === b;
    }

    return validation.a === validation.b;
  });

  jsonLogic.rm_operation('!=');
  jsonLogic.add_operation('!=', (a: unknown, b: unknown) => {
    const validation = validateComparison(a, b);
    if (!validation.isValid) {
      // fall back to strict inequality for other types
      return a !== b;
    }

    return validation.a !== validation.b;
  });

  jsonLogic.add_operation('moreThanXAgo', (dataInput: unknown, ruleValue: unknown): boolean => {
    const validation = validateRelativeDateInput(ruleValue);
    if (!validation.isValid) return false;

    const inputDate = new Date(dataInput as string);
    if (Number.isNaN(inputDate.getTime())) return false;

    const targetDate = calculateRelativeDate(validation.amount, validation.unit);

    return inputDate < targetDate;
  });

  jsonLogic.add_operation('lessThanXAgo', (dataInput: unknown, ruleValue: unknown): boolean => {
    const validation = validateRelativeDateInput(ruleValue);
    if (!validation.isValid) return false;

    const inputDate = new Date(dataInput as string);
    if (Number.isNaN(inputDate.getTime())) return false;

    const targetDate = calculateRelativeDate(validation.amount, validation.unit);

    return inputDate >= targetDate;
  });

  jsonLogic.add_operation('withinLast', (dataInput: unknown, ruleValue: unknown): boolean => {
    const validation = validateRelativeDateInput(ruleValue);
    if (!validation.isValid) return false;

    const inputDate = new Date(dataInput as string);
    if (Number.isNaN(inputDate.getTime())) return false;

    const targetDate = calculateRelativeDate(validation.amount, validation.unit);
    const now = new Date();

    return inputDate >= targetDate && inputDate <= now;
  });

  jsonLogic.add_operation('notWithinLast', (dataInput: unknown, ruleValue: unknown): boolean => {
    const validation = validateRelativeDateInput(ruleValue);
    if (!validation.isValid) return false;

    const inputDate = new Date(dataInput as string);
    if (Number.isNaN(inputDate.getTime())) return false;

    const targetDate = calculateRelativeDate(validation.amount, validation.unit);

    return inputDate < targetDate;
  });

  jsonLogic.add_operation('exactlyXAgo', (dataInput: unknown, ruleValue: unknown): boolean => {
    const validation = validateRelativeDateInput(ruleValue);
    if (!validation.isValid) return false;

    const inputDate = new Date(dataInput as string);
    if (Number.isNaN(inputDate.getTime())) return false;

    const targetDate = calculateRelativeDate(validation.amount, validation.unit);
    const tolerance = getToleranceMs(validation.unit);

    return Math.abs(inputDate.getTime() - targetDate.getTime()) <= tolerance;
  });
};

initializeCustomOperators();

export function evaluateRules(
  rule: RulesLogic<AdditionalOperation>,
  data: unknown,
  safe = false
): { result: boolean; error: string | undefined } {
  try {
    return { result: jsonLogic.apply(rule, data), error: undefined };
  } catch (error) {
    if (safe) {
      return { result: false, error };
    }

    throw new Error(`Failed to evaluate rule: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

export function isValidRule(rule: RulesLogic<AdditionalOperation>): boolean {
  try {
    return jsonLogic.is_logic(rule);
  } catch {
    return false;
  }
}

export function extractFieldsFromRules(rules: RulesLogic<AdditionalOperation>): string[] {
  const variables = new Set<string>();

  const collectVariables = (node: RulesLogic<AdditionalOperation>) => {
    if (!node || typeof node !== 'object') {
      return;
    }

    const entries = Object.entries(node);

    for (const [key, value] of entries) {
      if (key === 'var' && typeof value === 'string') {
        variables.add(value);
        continue;
      }

      if (Array.isArray(value)) {
        value.forEach((item) => {
          if (typeof item === 'object') {
            collectVariables(item);
          }
        });
        continue;
      }

      if (typeof value === 'object') {
        collectVariables(value as RulesLogic<AdditionalOperation>);
      }
    }
  };

  collectVariables(rules);

  return Array.from(variables);
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - validateStringInput(dataInput: unknown, ruleValue: unknown)
 - validateRangeInput(dataInput: unknown, ruleValue: unknown)
 - validateBooleanInput(dataInput: unknown)
 - validateRelativeDateInput(ruleValue: unknown)
 - calculateRelativeDate(amount: number, unit: string, fromDate = new Date()
 - getToleranceMs(unit: string)
 - validateComparison(a: unknown,
  b: unknown)
 - createStringOperator(evaluator: (input: string, value: string)
 - evaluateRules(rule: RulesLogic<AdditionalOperation>,
  data: unknown,
  safe = false)
 - isValidRule(rule: RulesLogic<AdditionalOperation>)
 - extractFieldsFromRules(rules: RulesLogic<AdditionalOperation>)
Asignaciones con arrow functions encontradas (posibles funciones):
 - dateB(new Date(b);

    if (!Number.isNaN(dateA.getTime()) && !Number.isNaN(dateB.getTime())) {
      retu...)
 - initializeCustomOperators(): void)
 - boolean(> Array.isArray(ruleValue) && !ruleValue.includes(dataInput)
  );

  jsonLogic.add_operation('betwee...)
 - validation(validateRangeInput(dataInput, ruleValue);

    if (!validation.isValid) {
      return false;
    }
...)
 - validation(validateComparison(a, b);
    if (!validation.isValid) return false;

    return validation.a < vali...)
 - targetDate(calculateRelativeDate(validation.amount, validation.unit);

    return inputDate < targetDate;
  });...)
 - targetDate(calculateRelativeDate(validation.amount, validation.unit);

    return inputDate < targetDate;
  });...)
 - collectVariables(node: RulesLogic<AdditionalOperation>))
Declaraciones 'export' encontradas:
- export function evaluateRules
- export function isValidRule
- export function extractFieldsFromRules

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/services/query-parser/query-validator.service.spec.ts
Tamaño: 19655 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect } from 'chai';
import { AdditionalOperation, RulesLogic } from 'json-logic-js';

import { QueryIssueTypeEnum, QueryValidatorService } from './query-validator.service';
import { COMPARISON_OPERATORS, JsonLogicOperatorEnum } from './types';

describe('QueryValidatorService', () => {
  let queryValidatorService: QueryValidatorService;

  beforeEach(() => {
    const allowedVariables = [
      'payload.foo',
      'payload.bar',
      'subscriber.firstName',
      'subscriber.email',
      'allowed.field',
    ];
    const allowedNamespaces = ['payload.', 'subscriber.data.'];
    queryValidatorService = new QueryValidatorService(allowedVariables, allowedNamespaces);
  });

  describe('validateQueryRules', () => {
    it('should validate a invalid node structure', () => {
      const rule: RulesLogic<AdditionalOperation> = null;

      const issues = queryValidatorService.validateQueryRules(rule);

      expect(issues).to.have.lengthOf(1);
      expect(issues[0].message).to.include('Invalid node structure');
      expect(issues[0].path).to.deep.equal([]);
    });

    describe('logical operators', () => {
      [JsonLogicOperatorEnum.AND, JsonLogicOperatorEnum.OR].forEach((operator) => {
        it(`should validate valid ${operator} operation`, () => {
          const rule: RulesLogic<AdditionalOperation> = {
            [operator]: [{ '==': [{ var: 'payload.foo' }, 'value1'] }, { '==': [{ var: 'payload.bar' }, 'value2'] }],
          };

          const issues = queryValidatorService.validateQueryRules(rule);

          expect(issues).to.be.empty;
        });

        it(`should detect invalid ${operator} structure`, () => {
          const rule: any = {
            [operator]: { '==': [{ var: 'payload.foo' }, 'value'] }, // Invalid: and should be an array
          };

          const issues = queryValidatorService.validateQueryRules(rule);

          expect(issues).to.have.lengthOf(1);
          expect(issues[0].message).to.include(`Invalid logical operator "${operator}"`);
          expect(issues[0].path).to.deep.equal([]);
          expect(issues[0].type).to.equal(QueryIssueTypeEnum.INVALID_STRUCTURE);
        });
      });

      it('should validate NOT operation', () => {
        const rule: RulesLogic<AdditionalOperation> = {
          '!': { '==': [{ var: 'payload.foo' }, 'value'] },
        };

        const issues = queryValidatorService.validateQueryRules(rule);

        expect(issues).to.be.empty;
      });

      it('should detect invalid NOT operation', () => {
        const rule: RulesLogic<AdditionalOperation> = {
          '!': { '==': [{ var: 'payload.foo' }, ''] },
        };

        const issues = queryValidatorService.validateQueryRules(rule);

        expect(issues).to.have.lengthOf(1);
        expect(issues[0].message).to.include('Value is required');
        expect(issues[0].path).to.deep.equal([]);
        expect(issues[0].type).to.equal(QueryIssueTypeEnum.MISSING_VALUE);
      });
    });

    describe('in operation', () => {
      it('should detect invalid array in operation', () => {
        const rule: any = {
          in: [],
        };

        const issues = queryValidatorService.validateQueryRules(rule);

        expect(issues).to.have.lengthOf(1);
        expect(issues[0].message).to.include('Invalid operation structure');
        expect(issues[0].path).to.deep.equal([]);
        expect(issues[0].type).to.equal(QueryIssueTypeEnum.INVALID_STRUCTURE);
      });

      describe('"in" operation', () => {
        it('should validate valid "in" operation', () => {
          const rule: RulesLogic<AdditionalOperation> = {
            in: [{ var: 'subscriber.firstName' }, ['value1', 'value2']],
          };

          const issues = queryValidatorService.validateQueryRules(rule);

          expect(issues).to.be.empty;
        });

        it('should detect invalid field reference in "in" operation', () => {
          const rule: RulesLogic<AdditionalOperation> = {
            in: [{}, [1, 2]],
          };

          const issues = queryValidatorService.validateQueryRules(rule);

          expect(issues).to.have.lengthOf(1);
          expect(issues[0].message).to.include('Invalid field reference in comparison');
          expect(issues[0].path).to.deep.equal([]);
          expect(issues[0].type).to.equal(QueryIssueTypeEnum.INVALID_STRUCTURE);
        });

        it('should detect empty array in "in" operation', () => {
          const rule: RulesLogic<AdditionalOperation> = {
            in: [{ var: 'payload.foo' }, []],
          };

          const issues = queryValidatorService.validateQueryRules(rule);

          expect(issues).to.have.lengthOf(1);
          expect(issues[0].message).to.include('Value is required');
          expect(issues[0].path).to.deep.equal([]);
          expect(issues[0].type).to.equal(QueryIssueTypeEnum.MISSING_VALUE);
        });
      });

      describe('"contains" operation', () => {
        it('should validate valid "contains" operation', () => {
          const rule: RulesLogic<AdditionalOperation> = {
            in: ['search', { var: 'payload.foo' }],
          };

          const issues = queryValidatorService.validateQueryRules(rule);

          expect(issues).to.be.empty;
        });

        it('should detect invalid field reference in "contains" operation', () => {
          const rule: RulesLogic<AdditionalOperation> = {
            in: ['search', {}],
          };

          const issues = queryValidatorService.validateQueryRules(rule);

          expect(issues).to.have.lengthOf(1);
          expect(issues[0].message).to.include('Invalid field reference in comparison');
          expect(issues[0].path).to.deep.equal([]);
          expect(issues[0].type).to.equal(QueryIssueTypeEnum.INVALID_STRUCTURE);
        });

        it('should detect invalid value in "contains" operation', () => {
          const rule: RulesLogic<AdditionalOperation> = {
            in: ['', { var: 'payload.foo' }],
          };

          const issues = queryValidatorService.validateQueryRules(rule);

          expect(issues).to.have.lengthOf(1);
          expect(issues[0].message).to.include('Value is required');
          expect(issues[0].path).to.deep.equal([]);
          expect(issues[0].type).to.equal(QueryIssueTypeEnum.MISSING_VALUE);
        });
      });
    });

    describe('between operation', () => {
      it('should validate valid between operation', () => {
        const rule: RulesLogic<AdditionalOperation> = {
          '<=': [1, { var: 'payload.foo' }, 10],
        };

        const issues = queryValidatorService.validateQueryRules(rule);

        expect(issues).to.be.empty;
      });

      it('should detect invalid between structure from lower bound', () => {
        const rule: any = {
          '<=': [undefined, { var: 'payload.foo' }, 10], // Missing lower bound
        };

        const issues = queryValidatorService.validateQueryRules(rule);

        expect(issues).to.have.lengthOf(1);
        expect(issues[0].message).to.include('Value is required');
        expect(issues[0].path).to.deep.equal([]);
        expect(issues[0].type).to.equal(QueryIssueTypeEnum.MISSING_VALUE);
      });

      it('should detect invalid between structure from upper bound', () => {
        const rule: any = {
          '<=': [1, { var: 'payload.foo' }, undefined], // Missing upper bound
        };

        const issues = queryValidatorService.validateQueryRules(rule);

        expect(issues).to.have.lengthOf(1);
        expect(issues[0].message).to.include('Value is required');
        expect(issues[0].path).to.deep.equal([]);
        expect(issues[0].type).to.equal(QueryIssueTypeEnum.MISSING_VALUE);
      });

      it('should detect invalid field reference in "contains" operation', () => {
        const rule: any = {
          '<=': [1, {}, 1], // invalid field reference
        };

        const issues = queryValidatorService.validateQueryRules(rule);

        expect(issues).to.have.lengthOf(1);
        expect(issues[0].message).to.include('Invalid field reference in comparison');
        expect(issues[0].path).to.deep.equal([]);
        expect(issues[0].type).to.equal(QueryIssueTypeEnum.INVALID_STRUCTURE);
      });
    });

    describe('comparison operators', () => {
      COMPARISON_OPERATORS.forEach((operator) => {
        it(`should validate a valid simple ${operator} rule`, () => {
          const rule: RulesLogic<AdditionalOperation> = {
            [operator]: [{ var: 'subscriber.firstName' }, 'value'],
          };

          const issues = queryValidatorService.validateQueryRules(rule);

          expect(issues).to.be.empty;
        });

        it(`should detect invalid ${operator} structure`, () => {
          const rule: any = {
            [operator]: [{ var: 'subscriber.firstName' }], // Missing second operand
          };

          const issues = queryValidatorService.validateQueryRules(rule);

          expect(issues).to.have.lengthOf(1);
          expect(issues[0].message).to.include('Invalid operation structure');
          expect(issues[0].type).to.equal(QueryIssueTypeEnum.INVALID_STRUCTURE);
        });

        it(`should detect invalid field reference in "${operator}" operation`, () => {
          const rule: RulesLogic<AdditionalOperation> = {
            [operator]: [{}, 'value'],
          };

          const issues = queryValidatorService.validateQueryRules(rule);

          expect(issues).to.have.lengthOf(1);
          expect(issues[0].message).to.include('Invalid field reference in comparison');
          expect(issues[0].path).to.deep.equal([]);
          expect(issues[0].type).to.equal(QueryIssueTypeEnum.INVALID_STRUCTURE);
        });
      });

      it('should validate valid comparison operations', () => {
        const validOperations: RulesLogic<AdditionalOperation>[] = [
          { '<': [{ var: 'payload.foo' }, 5] },
          { '>': [{ var: 'payload.foo' }, 5] },
          { '<=': [{ var: 'payload.foo' }, 5] },
          { '>=': [{ var: 'payload.foo' }, 5] },
          { '==': [{ var: 'payload.foo' }, 'value'] },
          { '!=': [{ var: 'payload.foo' }, 'value'] },
        ];

        validOperations.forEach((operation) => {
          const issues = queryValidatorService.validateQueryRules(operation);
          expect(issues).to.be.empty;
        });
      });

      it('should handle null values correctly for isNull', () => {
        const rule: RulesLogic<AdditionalOperation> = {
          '==': [{ var: 'payload.foo' }, null],
        };

        const issues = queryValidatorService.validateQueryRules(rule);

        expect(issues).to.be.empty;
      });

      it('should handle null values correctly for !isNull', () => {
        const rule: RulesLogic<AdditionalOperation> = {
          '!=': [{ var: 'payload.foo' }, null],
        };

        const issues = queryValidatorService.validateQueryRules(rule);

        expect(issues).to.be.empty;
      });

      it('should detect null values for non-equality operators', () => {
        const rule: RulesLogic<AdditionalOperation> = {
          '>': [{ var: 'payload.foo' }, null],
        };

        const issues = queryValidatorService.validateQueryRules(rule);

        expect(issues).to.have.lengthOf(1);
        expect(issues[0].message).to.include('Value is required');
        expect(issues[0].type).to.equal(QueryIssueTypeEnum.MISSING_VALUE);
      });
    });

    describe('path calculation', () => {
      const tests = [
        {
          name: 'single rule',
          rule: {
            and: [
              {
                '==': [
                  {
                    var: 'subscriber.email',
                  },
                  '',
                ],
              },
            ],
          },
          path: [0],
        },
        {
          name: 'second rule',
          rule: {
            and: [
              {
                '==': [
                  {
                    var: 'subscriber.email',
                  },
                  'asdf',
                ],
              },
              {
                '==': [
                  {
                    var: 'subscriber.email',
                  },
                  '',
                ],
              },
            ],
          },
          path: [1],
        },
        {
          name: 'nested rule',
          rule: {
            and: [
              {
                and: [
                  {
                    '==': [
                      {
                        var: 'subscriber.email',
                      },
                      '',
                    ],
                  },
                ],
              },
            ],
          },
          path: [0, 0],
        },
        {
          name: 'nested second rule',
          rule: {
            and: [
              {
                and: [
                  {
                    '==': [
                      {
                        var: 'subscriber.email',
                      },
                      'asdf',
                    ],
                  },
                  {
                    '!=': [
                      {
                        var: 'subscriber.email',
                      },
                      undefined,
                    ],
                  },
                ],
              },
            ],
          },
          path: [0, 1],
        },
        {
          name: 'second or operator first rule',
          rule: {
            or: [
              {
                and: [
                  {
                    '==': [
                      {
                        var: 'subscriber.email',
                      },
                      'asdf',
                    ],
                  },
                  {
                    '!=': [
                      {
                        var: 'subscriber.email',
                      },
                      '22',
                    ],
                  },
                ],
              },
              {
                or: [
                  {
                    '==': [
                      {
                        var: 'subscriber.email',
                      },
                      '',
                    ],
                  },
                ],
              },
            ],
          },
          path: [1, 0],
        },
        {
          name: 'nested not in operation',
          rule: {
            or: [
              {
                and: [
                  {
                    '==': [
                      {
                        var: 'subscriber.email',
                      },
                      'asdf',
                    ],
                  },
                  {
                    '!': {
                      in: [
                        '',
                        {
                          var: 'subscriber.firstName',
                        },
                      ],
                    },
                  },
                ],
              },
            ],
          },
          path: [0, 1],
        },
      ];

      tests.forEach((test) => {
        it(`should return the correct path for ${test.name}`, () => {
          const { rule, path } = test;

          const issues = queryValidatorService.validateQueryRules(rule as any);

          expect(issues).to.have.lengthOf(1);
          expect(issues[0].message).to.include('Value is required');
          expect(issues[0].path).to.deep.equal(path);
          expect(issues[0].type).to.equal(QueryIssueTypeEnum.MISSING_VALUE);
        });
      });
    });
  });

  describe('field validation', () => {
    it('should validate allowed fields', () => {
      const rule: RulesLogic<AdditionalOperation> = {
        '==': [{ var: 'allowed.field' }, 'value'],
      };

      const issues = queryValidatorService.validateQueryRules(rule);

      expect(issues).to.be.empty;
    });

    it('should validate fields with allowed prefixes', () => {
      const rule: RulesLogic<AdditionalOperation> = {
        '==': [{ var: 'subscriber.data.foo' }, 'value'],
      };

      const issues = queryValidatorService.validateQueryRules(rule);

      expect(issues).to.be.empty;
    });

    it('should validate namespace field itself (subscriber.data)', () => {
      const rule: RulesLogic<AdditionalOperation> = {
        '==': [{ var: 'subscriber.data' }, 'value'],
      };

      const issues = queryValidatorService.validateQueryRules(rule);

      expect(issues).to.be.empty;
    });

    it('should detect invalid namespace field (payload)', () => {
      const rule: RulesLogic<AdditionalOperation> = {
        '==': [{ var: 'payload' }, 'value'],
      };

      const issues = queryValidatorService.validateQueryRules(rule);

      expect(issues).to.have.lengthOf(1);
      expect(issues[0].message).to.include('Value is not valid');
      expect(issues[0].path).to.deep.equal([]);
      expect(issues[0].type).to.equal(QueryIssueTypeEnum.INVALID_FIELD_VALUE);
    });

    it('should detect invalid field that is not in allowed list', () => {
      const rule: RulesLogic<AdditionalOperation> = {
        '==': [{ var: 'not_allowed_field' }, 'value'],
      };

      const issues = queryValidatorService.validateQueryRules(rule);

      expect(issues).to.have.lengthOf(1);
      expect(issues[0].message).to.include('Value is not valid');
      expect(issues[0].path).to.deep.equal([]);
      expect(issues[0].type).to.equal(QueryIssueTypeEnum.INVALID_FIELD_VALUE);
    });

    it('should detect empty field value', () => {
      const rule: RulesLogic<AdditionalOperation> = {
        '==': [{ var: '' }, 'value'],
      };

      const issues = queryValidatorService.validateQueryRules(rule);

      expect(issues).to.have.lengthOf(1);
      expect(issues[0].message).to.include('Value is not valid');
      expect(issues[0].path).to.deep.equal([]);
      expect(issues[0].type).to.equal(QueryIssueTypeEnum.INVALID_FIELD_VALUE);
    });

    it('should detect invalid prefix', () => {
      const rule: RulesLogic<AdditionalOperation> = {
        '==': [{ var: 'invalid.prefix.field' }, 'value'],
      };

      const issues = queryValidatorService.validateQueryRules(rule);

      expect(issues).to.have.lengthOf(1);
      expect(issues[0].message).to.include('Value is not valid');
      expect(issues[0].path).to.deep.equal([]);
      expect(issues[0].type).to.equal(QueryIssueTypeEnum.INVALID_FIELD_VALUE);
    });

    it('should detect invalid field with allowed prefixes', () => {
      const rule: RulesLogic<AdditionalOperation> = {
        '==': [{ var: 'payload.' }, 'value'],
      };

      const issues = queryValidatorService.validateQueryRules(rule);

      expect(issues).to.have.lengthOf(1);
      expect(issues[0].message).to.include('Value is not valid');
      expect(issues[0].path).to.deep.equal([]);
      expect(issues[0].type).to.equal(QueryIssueTypeEnum.INVALID_FIELD_VALUE);
    });

    it('should validate complex query with multiple field references', () => {
      const rule: RulesLogic<AdditionalOperation> = {
        and: [
          { '==': [{ var: 'payload.foo' }, 'value1'] },
          { '==': [{ var: 'subscriber.data.bar' }, 'value2'] },
          { '!=': [{ var: 'invalid.field' }, 'value3'] },
        ],
      };

      const issues = queryValidatorService.validateQueryRules(rule);

      expect(issues).to.have.lengthOf(1);
      expect(issues[0].message).to.include('Value is not valid');
      expect(issues[0].path).to.deep.equal([2]);
      expect(issues[0].type).to.equal(QueryIssueTypeEnum.INVALID_FIELD_VALUE);
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - queryValidatorService(new QueryValidatorService(allowedVariables, allowedNamespaces);
  });

  describe('validateQueryRule...)
 - issues(queryValidatorService.validateQueryRules(rule);

      expect(issues).to.have.lengthOf(1);
      exp...)
 - issues(queryValidatorService.validateQueryRules(rule);

          expect(issues).to.be.empty;
        });

...)
 - issues(queryValidatorService.validateQueryRules(rule);

          expect(issues).to.have.lengthOf(1);
     ...)
 - issues(queryValidatorService.validateQueryRules(rule);

        expect(issues).to.be.empty;
      });

    ...)
 - issues(queryValidatorService.validateQueryRules(rule);

        expect(issues).to.have.lengthOf(1);
       ...)
 - issues(queryValidatorService.validateQueryRules(rule);

        expect(issues).to.have.lengthOf(1);
       ...)
 - issues(queryValidatorService.validateQueryRules(rule);

          expect(issues).to.be.empty;
        });

...)
 - issues(queryValidatorService.validateQueryRules(rule);

          expect(issues).to.have.lengthOf(1);
     ...)
 - issues(queryValidatorService.validateQueryRules(rule);

          expect(issues).to.have.lengthOf(1);
     ...)
 - issues(queryValidatorService.validateQueryRules(rule);

          expect(issues).to.be.empty;
        });

...)
 - issues(queryValidatorService.validateQueryRules(rule);

          expect(issues).to.have.lengthOf(1);
     ...)
 - issues(queryValidatorService.validateQueryRules(rule);

          expect(issues).to.have.lengthOf(1);
     ...)
 - issues(queryValidatorService.validateQueryRules(rule);

        expect(issues).to.be.empty;
      });

    ...)
 - issues(queryValidatorService.validateQueryRules(rule);

        expect(issues).to.have.lengthOf(1);
       ...)
 - issues(queryValidatorService.validateQueryRules(rule);

        expect(issues).to.have.lengthOf(1);
       ...)
 - issues(queryValidatorService.validateQueryRules(rule);

        expect(issues).to.have.lengthOf(1);
       ...)
 - issues(queryValidatorService.validateQueryRules(rule);

          expect(issues).to.be.empty;
        });

...)
 - issues(queryValidatorService.validateQueryRules(rule);

          expect(issues).to.have.lengthOf(1);
     ...)
 - issues(queryValidatorService.validateQueryRules(rule);

          expect(issues).to.have.lengthOf(1);
     ...)
 - issues(queryValidatorService.validateQueryRules(operation);
          expect(issues).to.be.empty;
        }...)
 - issues(queryValidatorService.validateQueryRules(rule);

        expect(issues).to.be.empty;
      });

    ...)
 - issues(queryValidatorService.validateQueryRules(rule);

        expect(issues).to.be.empty;
      });

    ...)
 - issues(queryValidatorService.validateQueryRules(rule);

        expect(issues).to.have.lengthOf(1);
       ...)
 - issues(queryValidatorService.validateQueryRules(rule as any);

          expect(issues).to.have.lengthOf(1)...)
 - issues(queryValidatorService.validateQueryRules(rule);

      expect(issues).to.be.empty;
    });

    it('...)
 - issues(queryValidatorService.validateQueryRules(rule);

      expect(issues).to.be.empty;
    });

    it('...)
 - issues(queryValidatorService.validateQueryRules(rule);

      expect(issues).to.be.empty;
    });

    it('...)
 - issues(queryValidatorService.validateQueryRules(rule);

      expect(issues).to.have.lengthOf(1);
      exp...)
 - issues(queryValidatorService.validateQueryRules(rule);

      expect(issues).to.have.lengthOf(1);
      exp...)
 - issues(queryValidatorService.validateQueryRules(rule);

      expect(issues).to.have.lengthOf(1);
      exp...)
 - issues(queryValidatorService.validateQueryRules(rule);

      expect(issues).to.have.lengthOf(1);
      exp...)
 - issues(queryValidatorService.validateQueryRules(rule);

      expect(issues).to.have.lengthOf(1);
      exp...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/services/query-parser/query-validator.service.ts
Tamaño: 8619 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { AdditionalOperation, RulesLogic } from 'json-logic-js';

import { COMPARISON_OPERATORS, JsonComparisonOperatorEnum, JsonLogicOperatorEnum } from './types';

type QueryIssue = {
  message: string;
  path: number[];
  type: QueryIssueTypeEnum;
};

export enum QueryIssueTypeEnum {
  INVALID_STRUCTURE = 'INVALID_STRUCTURE',
  MISSING_VALUE = 'MISSING_VALUE',
  INVALID_FIELD_VALUE = 'INVALID_FIELD_VALUE',
}

export class QueryValidatorService {
  constructor(
    private allowedVariables: string[],
    private allowedNamespaces: string[]
  ) {}

  private isInvalidFieldReference(field: unknown) {
    return !field || typeof field !== 'object' || !('var' in field);
  }

  private isInvalidFieldValue(field: unknown) {
    const fieldValue = (field as { var: string })?.var ?? '';

    // Special case: allow 'subscriber.data' specifically as we want the user to check for null values
    if (fieldValue === 'subscriber.data') {
      return false;
    }

    // Check if field is within allowed namespaces (nested properties only)
    const isWithinAllowedPrefixes = this.allowedNamespaces.some(
      (prefix) => fieldValue.startsWith(prefix) && fieldValue.length > prefix.length
    );

    return !fieldValue || (!this.allowedVariables.includes(fieldValue) && !isWithinAllowedPrefixes);
  }

  private getLogicalOperatorIssue(operator: string, path: number[]): QueryIssue {
    return {
      message: `Invalid logical operator "${operator}" structure`,
      path,
      type: QueryIssueTypeEnum.INVALID_STRUCTURE,
    };
  }

  private getFieldReferenceIssue(path: number[]): QueryIssue {
    return {
      message: 'Invalid field reference in comparison',
      path,
      type: QueryIssueTypeEnum.INVALID_STRUCTURE,
    };
  }

  private getOperationIssue(operator: string, path: number[]): QueryIssue {
    return {
      message: `Invalid operation structure for operator "${operator}"`,
      path,
      type: QueryIssueTypeEnum.INVALID_STRUCTURE,
    };
  }

  private getValueIssue(path: number[]): QueryIssue {
    return {
      message: 'Value is required',
      path,
      type: QueryIssueTypeEnum.MISSING_VALUE,
    };
  }

  private getFieldValueNotValidIssue(path: number[]): QueryIssue {
    return {
      message: 'Value is not valid',
      path,
      type: QueryIssueTypeEnum.INVALID_FIELD_VALUE,
    };
  }

  private validateFieldReference(field: unknown, issues: QueryIssue[], path: number[]) {
    if (this.isInvalidFieldReference(field)) {
      issues.push(this.getFieldReferenceIssue(path));
    } else if (this.isInvalidFieldValue(field)) {
      issues.push(this.getFieldValueNotValidIssue(path));
    }
  }

  private validateNode({
    node,
    issues,
    path = [],
  }: {
    node: RulesLogic<AdditionalOperation>;
    issues: QueryIssue[];
    path?: number[];
  }) {
    if (!node || typeof node !== 'object') {
      issues.push({
        message: 'Invalid node structure',
        path,
        type: QueryIssueTypeEnum.INVALID_STRUCTURE,
      });

      return;
    }

    const entries = Object.entries(node);

    for (const [key, value] of entries) {
      // handle logical operators "and" and "or"
      if ([JsonLogicOperatorEnum.AND, JsonLogicOperatorEnum.OR].includes(key as JsonLogicOperatorEnum)) {
        if (!Array.isArray(value)) {
          issues.push(this.getLogicalOperatorIssue(key, path));
          continue;
        }

        value.forEach((item, index) => {
          this.validateNode({ node: item, issues, path: [...path, index] });
        });
        continue;
      }

      // handle negation '!' operator
      if (key === JsonLogicOperatorEnum.NOT) {
        this.validateNode({ node: value as RulesLogic<AdditionalOperation>, issues, path });
        continue;
      }

      // handle 'in' and 'contains' operators
      if (key === JsonComparisonOperatorEnum.IN) {
        this.validateInOperation({ value, issues, path });
        continue;
      }

      const isBetween =
        key === JsonComparisonOperatorEnum.LESS_THAN_OR_EQUAL && Array.isArray(value) && value.length === 3;
      if (isBetween) {
        this.validateBetweenOperation({ value: value as [unknown, unknown, unknown], issues, path });
        continue;
      }

      // handle the rest of the comparison operators
      if (COMPARISON_OPERATORS.includes(key as JsonComparisonOperatorEnum)) {
        this.validateComparisonOperation({ operator: key as JsonComparisonOperatorEnum, value, issues, path });
        continue;
      }

      // handle field variable
      if (key === 'var') {
        if (!value) {
          issues.push({
            message: 'Field variable is required',
            path,
            type: QueryIssueTypeEnum.MISSING_VALUE,
          });
        }
      }
    }
  }

  private validateBetweenOperation({
    value,
    issues,
    path,
  }: {
    value: [unknown, unknown, unknown];
    issues: QueryIssue[];
    path: number[];
  }) {
    const [lowerBound, field, upperBound] = value;

    this.validateFieldReference(field, issues, path);

    const lowerBoundIsUndefined = lowerBound === undefined || lowerBound === null;
    const upperBoundIsUndefined = upperBound === undefined || upperBound === null;
    if (lowerBoundIsUndefined || upperBoundIsUndefined) {
      issues.push(this.getValueIssue(path));
    }
  }

  private validateComparisonOperation({
    operator,
    value,
    issues,
    path,
  }: {
    operator: JsonComparisonOperatorEnum;
    value: unknown;
    issues: QueryIssue[];
    path: number[];
  }) {
    if (!Array.isArray(value) || value.length !== 2) {
      issues.push(this.getOperationIssue(operator, path));

      return;
    }

    const [field, comparisonValue] = value;

    // Validate field reference
    this.validateFieldReference(field, issues, path);

    // Validate comparison value exists
    const valueIsUndefinedOrEmptyCase =
      (comparisonValue === undefined || comparisonValue === '') &&
      [
        JsonComparisonOperatorEnum.EQUAL,
        JsonComparisonOperatorEnum.NOT_EQUAL,
        JsonComparisonOperatorEnum.LESS_THAN,
        JsonComparisonOperatorEnum.GREATER_THAN,
        JsonComparisonOperatorEnum.LESS_THAN_OR_EQUAL,
        JsonComparisonOperatorEnum.GREATER_THAN_OR_EQUAL,
        JsonComparisonOperatorEnum.STARTS_WITH,
        JsonComparisonOperatorEnum.ENDS_WITH,
      ].includes(operator);
    const valueIsNullCase =
      comparisonValue === null &&
      ![JsonComparisonOperatorEnum.EQUAL, JsonComparisonOperatorEnum.NOT_EQUAL].includes(operator);

    if (valueIsUndefinedOrEmptyCase || valueIsNullCase) {
      issues.push(this.getValueIssue(path));
    }

    // Validate array for 'in' operations
    const invalidComparisonValue = operator === 'in' && !Array.isArray(comparisonValue);
    if (invalidComparisonValue) {
      issues.push(this.getOperationIssue(operator, path));
    }
  }

  /*
   * in operator has field and the array as operands
   * but as contains it has the search value and the field as operands
   */
  private validateInOperation({ value, issues, path }: { value: unknown; issues: QueryIssue[]; path: number[] }) {
    if (!Array.isArray(value) || value.length !== 2) {
      issues.push(this.getOperationIssue('in', path));

      return;
    }

    const [firstOperand, secondOperand] = value;
    const isContains = typeof firstOperand === 'string';

    if (isContains) {
      // Validate search value exists
      const searchValueExists = firstOperand === undefined || firstOperand === '';
      if (searchValueExists) {
        issues.push(this.getValueIssue(path));
      }

      // Validate field reference
      const secondOperandInvalid = !secondOperand || typeof secondOperand !== 'object' || !('var' in secondOperand);
      if (secondOperandInvalid) {
        issues.push(this.getFieldReferenceIssue(path));
      }
    } else {
      // Validate field reference
      const firstOperandInvalid = !firstOperand || typeof firstOperand !== 'object' || !('var' in firstOperand);
      if (firstOperandInvalid) {
        issues.push(this.getFieldReferenceIssue(path));
      }

      // Validate the in array is not empty
      const secondOperandEmpty =
        secondOperand === undefined ||
        secondOperand === null ||
        (Array.isArray(secondOperand) && secondOperand.length === 0);
      if (secondOperandEmpty) {
        issues.push(this.getValueIssue(path));
      }
    }
  }

  public validateQueryRules(node: RulesLogic<AdditionalOperation>): QueryIssue[] {
    const issues: QueryIssue[] = [];

    this.validateNode({ node, issues });

    return issues;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - isWithinAllowedPrefixes(this.allowedNamespaces.some(
      (prefix))
 - entries(Object.entries(node);

    for (const [key, value] of entries) {
      // handle logical operators "...)
Declaraciones 'export' encontradas:
- export  enum
- export class QueryValidatorService

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/services/query-parser/types.ts
Tamaño: 890 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export enum JsonComparisonOperatorEnum {
  EQUAL = '==',
  NOT_EQUAL = '!=',
  GREATER_THAN = '>',
  LESS_THAN = '<',
  GREATER_THAN_OR_EQUAL = '>=',
  LESS_THAN_OR_EQUAL = '<=',
  IN = 'in',
  STARTS_WITH = 'startsWith',
  ENDS_WITH = 'endsWith',
}

export enum JsonLogicOperatorEnum {
  NOT = '!',
  AND = 'and',
  OR = 'or',
}

export const COMPARISON_OPERATORS = [
  JsonComparisonOperatorEnum.EQUAL,
  JsonComparisonOperatorEnum.NOT_EQUAL,
  JsonComparisonOperatorEnum.GREATER_THAN,
  JsonComparisonOperatorEnum.LESS_THAN,
  JsonComparisonOperatorEnum.GREATER_THAN_OR_EQUAL,
  JsonComparisonOperatorEnum.LESS_THAN_OR_EQUAL,
  JsonComparisonOperatorEnum.IN,
  JsonComparisonOperatorEnum.STARTS_WITH,
  JsonComparisonOperatorEnum.ENDS_WITH,
] as const;

export const LOGICAL_OPERATORS = [
  JsonLogicOperatorEnum.AND,
  JsonLogicOperatorEnum.OR,
  JsonLogicOperatorEnum.NOT,
] as const;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  enum
- export  enum
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/transformers/to-boolean.spec.ts
Tamaño: 1438 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect } from 'chai';
import { plainToInstance } from 'class-transformer';
import { TransformToBoolean } from './to-boolean';

function transform(input: { isSomething: any }) {
  return plainToInstance(TestDto, input);
}

class TestDto {
  constructor(isSomething: any) {
    this.isSomething = isSomething;
  }

  @TransformToBoolean()
  isSomething: boolean;
}

describe('@TransformToBoolean() transformer', () => {
  it('should transform "true" to true', () => {
    const result = transform({ isSomething: 'true' });
    expect(result.isSomething).to.equal(true);
  });

  it('should transform "false" to false', () => {
    const result = transform({ isSomething: 'false' });
    expect(result.isSomething).to.equal(false);
  });

  it('should not transform any other string values', () => {
    const result = transform({ isSomething: 'truez' });
    expect(typeof result.isSomething).not.equal('boolean');
  });

  it('should not transform numbers', () => {
    const result = transform({ isSomething: 1 });
    expect(typeof result.isSomething).not.equal('boolean');
  });

  it('should not transform objects', () => {
    const result = transform({ isSomething: { true: false } });
    expect(typeof result.isSomething).not.equal('boolean');
  });

  it('should not transform null value', () => {
    const result = transform({ isSomething: null });
    expect(typeof result.isSomething).not.equal('boolean');
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - transform(input: { isSomething: any })
Asignaciones con arrow functions encontradas (posibles funciones):
 - isSomething(isSomething;
  }

  @TransformToBoolean()
  isSomething: boolean;
}

describe('@TransformToBoolean()...)
 - result(transform({ isSomething: 'true' });
    expect(result.isSomething).to.equal(true);
  });

  it('shou...)
 - result(transform({ isSomething: 'false' });
    expect(result.isSomething).to.equal(false);
  });

  it('sh...)
 - result(transform({ isSomething: 'truez' });
    expect(typeof result.isSomething).not.equal('boolean');
  }...)
 - result(transform({ isSomething: 1 });
    expect(typeof result.isSomething).not.equal('boolean');
  });

  ...)
 - result(transform({ isSomething: { true: false } });
    expect(typeof result.isSomething).not.equal('boolea...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/transformers/to-boolean.ts
Tamaño: 346 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Transform } from 'class-transformer';

// use this transformer in combination with @IsBoolean validator.

export const TransformToBoolean = () =>
  Transform(({ value }) => {
    if (value === 'true') return true;
    if (value === 'false') return false;

    return value; // @IsBoolean validator should reject non-boolean value.
  });


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - TransformToBoolean())
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/transformers/trim.ts
Tamaño: 115 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Transform } from 'class-transformer';

export const Trim = () => Transform(({ value }) => value?.trim());


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - Trim())
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/usecases/index.ts
Tamaño: 43 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './create-variables-object';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/usecases/create-variables-object/create-variables-object.command.ts
Tamaño: 459 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentCommand } from '@novu/application-generic';
import { IsArray, IsDefined, IsObject, IsOptional } from 'class-validator';
import { JSONSchemaDto } from '../../dtos/json-schema.dto';

export class CreateVariablesObjectCommand extends EnvironmentCommand {
  @IsDefined()
  @IsArray()
  controlValues: unknown[];

  @IsObject()
  @IsOptional()
  payloadSchema?: JSONSchemaDto;

  @IsObject()
  @IsOptional()
  variableSchema?: JSONSchemaDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateVariablesObjectCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/usecases/create-variables-object/create-variables-object.usecase.ts
Tamaño: 8430 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { Instrument, InstrumentUsecase } from '@novu/application-generic';
import { merge } from 'es-toolkit/compat';
import { JsonSchemaMock } from '../../../workflows-v2/util/json-schema-mock';
import { collectKeys, keysToObject } from '../../../workflows-v2/util/utils';
import { JSONSchemaDto } from '../../dtos/json-schema.dto';
import { MailyAttrsEnum } from '../../helpers/maily.types';
import { isStringifiedMailyJSONContent } from '../../helpers/maily-utils';
import { buildVariables } from '../../utils/build-variables';
import { CreateVariablesObjectCommand } from './create-variables-object.command';
export type ArrayVariable = {
  path: string;
  iterations: number;
};

export const DEFAULT_ARRAY_ELEMENTS = 3;
/**
 * Creates the object representation of variables from the values.
 */
@Injectable()
export class CreateVariablesObject {
  @InstrumentUsecase()
  async execute(command: CreateVariablesObjectCommand): Promise<Record<string, unknown>> {
    const variables = this.extractAllVariables({
      controlValues: command.controlValues,
      variableSchema: command.variableSchema,
    });
    const arrayVariables = this.extractArrayVariables(command.controlValues);
    const showIfVariables = this.extractMailyAttribute(command.controlValues, MailyAttrsEnum.SHOW_IF_KEY);

    const variablesObject = keysToObject(variables, arrayVariables, showIfVariables);

    return await this.ensureEventsVariableIsAnArray(variablesObject, command);
  }

  private async ensureEventsVariableIsAnArray(
    variablesObject: Record<string, unknown>,
    command: CreateVariablesObjectCommand
  ) {
    const stepsObject = (variablesObject.steps as Record<string, unknown>) ?? {};

    // Check if we have steps with events and a payload schema to work with
    const hasStepsWithEvents = Object.keys(stepsObject).length > 0;
    const hasPayloadSchema = !!command.payloadSchema;

    const isPayloadSchemaEnabled = hasStepsWithEvents && hasPayloadSchema;

    Object.keys(stepsObject).forEach((stepId) => {
      const step = stepsObject[stepId] as Record<string, unknown>;
      const hasUsedEventCount = !!step.eventCount;
      const hasUsedEventsLength = !!(
        step.events &&
        typeof step.events === 'object' &&
        !Array.isArray(step.events) &&
        'length' in step.events
      );

      const hasUsedEvents = !!(step.events && typeof step.events === 'string') || Array.isArray(step.events);
      /**
       * Check if events is an object and has a payload property, for example used in the repeat block like this:
       * steps.digest-step.events.payload which is valid variable
       */
      const hasUsedEventsWithPayload = !!(
        step.events &&
        typeof step.events === 'object' &&
        !Array.isArray(step.events) &&
        'payload' in step.events
      );

      if (hasUsedEventCount || hasUsedEventsLength || hasUsedEvents || hasUsedEventsWithPayload) {
        let payload = {};

        // Use JsonSchemaMock if payload schema is available and feature flag is enabled
        if (isPayloadSchemaEnabled && command.payloadSchema) {
          try {
            const schema = {
              type: 'object' as const,
              properties: { payload: command.payloadSchema },
              additionalProperties: false,
            };
            const mockData = JsonSchemaMock.generate(schema) as Record<string, unknown>;
            payload = mockData.payload as Record<string, unknown>;
          } catch (error) {
            payload = this.generateFallbackPayload(step, hasUsedEventsWithPayload);
          }
        } else {
          // Original fallback method when no payload schema or feature flag is disabled
          payload = this.generateFallbackPayload(step, hasUsedEventsWithPayload);
        }

        step.events = Array.from({ length: DEFAULT_ARRAY_ELEMENTS }, (unused, index) => {
          const eventDate = new Date();
          eventDate.setDate(eventDate.getDate() - 1);
          eventDate.setHours(12, 0, 0, 0);
          eventDate.setMinutes(eventDate.getMinutes() + index); // Slightly different times for each event

          return {
            id: `example-id-${index + 1}`,
            time: eventDate.toISOString(),
            payload,
          };
        });
      }
    });

    return variablesObject;
  }

  private generateFallbackPayload(
    step: Record<string, unknown>,
    hasUsedEventsWithPayload: boolean
  ): Record<string, unknown> {
    let payload = {};

    if (Array.isArray(step.events)) {
      const hasPayloadInEvents = step.events.every((evt) => {
        return typeof evt === 'object' && 'payload' in evt;
      });
      if (hasPayloadInEvents) {
        payload = step.events[0].payload;
      }
    } else if (hasUsedEventsWithPayload) {
      const variableNameAfterPayload = collectKeys((step.events as Record<string, unknown>).payload);
      for (const variableName of variableNameAfterPayload) {
        const key = variableName.split('.').pop() ?? variableName;

        payload = { ...payload, ...this.setNestedValue(payload, variableName, key) };
      }
    }

    return payload;
  }

  private setNestedValue(obj: Record<string, unknown>, path: string, value: string) {
    const keys = path.split('.');

    const val = keys.reduceRight((acc, key, index) => {
      if (index === keys.length - 1) {
        return { [key]: value };
      } else {
        return { [key]: acc };
      }
    }, {});

    return merge(obj, val);
  }

  /**
   * Extracts all variables from control values by parsing handlebars syntax {{variable}}.
   * Removes duplicates from the final result.
   *
   * @example
   * values = [ "John {{name}}", "Address {{address}} {{address}}", "nothing", 123, true ]
   * returns = [ "name", "address" ]
   */
  @Instrument()
  private extractAllVariables({
    controlValues,
    variableSchema,
  }: {
    controlValues: unknown[];
    variableSchema?: JSONSchemaDto;
  }): string[] {
    const variables = controlValues.flatMap((value) => {
      const templateVariables = buildVariables({
        variableSchema,
        controlValue: value,
      });

      return templateVariables.validVariables.map((variable) => variable.name);
    });

    return [...new Set(variables)];
  }

  /**
   * Extracts variables from Maily JSON content by looking for attribute patterns.
   * Can optionally transform the extracted values.
   *
   * @example
   * For EACH_KEY: '{"each": "payload.comments"}' returns ["payload.comments"]
   * For ID with array transform: '{"id": "payload.foo[0].bar"}' returns ["payload.foo"]
   * For SHOW_IF_KEY: '{"showIfKey": "payload.isHidden"}' returns ["payload.isHidden"]
   */
  private extractMailyAttribute(
    controlValues: unknown[],
    attributeType: MailyAttrsEnum,
    transform: (value: string) => string | undefined = (value) => value
  ): string[] {
    const variables = new Set<string>();
    const pattern = new RegExp(`"${attributeType}"\\s*:\\s*"([^"]+)"`, 'g');

    controlValues.forEach((value) => {
      if (!isStringifiedMailyJSONContent(value)) return;

      const unescapedString = unescape(value);
      const matches = unescapedString.matchAll(pattern);

      for (const match of matches) {
        const extractedValue = match[1];
        if (extractedValue) {
          const transformed = transform(extractedValue);
          if (transformed) variables.add(transformed);
        }
      }
    });

    return Array.from(variables);
  }

  private extractArrayVariables(controlValues: unknown[]): ArrayVariable[] {
    // Extract 'Repeat' block iterable variables ('each' key) together with their set iterations
    const eachKeyVars = this.extractMailyAttribute(controlValues, MailyAttrsEnum.EACH_KEY).map((path) => ({
      path,
      iterations: DEFAULT_ARRAY_ELEMENTS,
    }));

    // Extract iterable variables outside of 'Repeat' blocks, always with 3 iterations
    const idVars = this.extractMailyAttribute(controlValues, MailyAttrsEnum.ID, this.extractArrayPath).map((path) => ({
      path,
      iterations: DEFAULT_ARRAY_ELEMENTS,
    }));

    return [...eachKeyVars, ...idVars];
  }

  /**
   * Extracts the base path from an array notation path
   * @example
   * "payload.items[0].bar" returns "payload.items"
   */
  private extractArrayPath(value: string): string | undefined {
    return value.match(/([^[]+)\[\d+\]/)?.[1];
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - isPayloadSchemaEnabled(hasStepsWithEvents && hasPayloadSchema;

    Object.keys(stepsObject).forEach((stepId))
 - events(Array.from({ length: DEFAULT_ARRAY_ELEMENTS }, (unused, index))
 - hasPayloadInEvents(step.events.every((evt))
 - val(keys.reduceRight((acc, key, index))
 - variables(controlValues.flatMap((value))
 - templateVariables(buildVariables({
        variableSchema,
        controlValue: value,
      });

      return templa...)
 - undefined(value))
 - pattern(new RegExp(`"${attributeType}"\\s*:\\s*"([^"]+)"`, 'g');

    controlValues.forEach((value))
 - eachKeyVars(this.extractMailyAttribute(controlValues, MailyAttrsEnum.EACH_KEY).map((path))
 - idVars(this.extractMailyAttribute(controlValues, MailyAttrsEnum.ID, this.extractArrayPath).map((path))
Declaraciones 'export' encontradas:
- export  type
- export  const
- export class CreateVariablesObject

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/usecases/create-variables-object/index.ts
Tamaño: 102 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './create-variables-object.command';
export * from './create-variables-object.usecase';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/utils/auth.utils.ts
Tamaño: 533 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/**
 * Checks if the authorization header contains a keyless token
 * @param authorizationHeader - The authorization header value
 * @returns boolean indicating if the header contains a keyless token
 */
export function checkIsKeylessHeader(authorizationHeader: string | undefined): boolean {
  if (!authorizationHeader) {
    return false;
  }

  /*
   * 'authorization' header 'Keyless pk_keyless_<token>'
   * 'novu-application-identifier' header 'pk_keyless_<token>'
   */
  return authorizationHeader.includes('pk_keyless_');
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - checkIsKeylessHeader(authorizationHeader: string | undefined)
Declaraciones 'export' encontradas:
- export function checkIsKeylessHeader

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/utils/build-variables.ts
Tamaño: 2052 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { PinoLogger } from '@novu/application-generic';
import { AdditionalOperation, RulesLogic } from 'json-logic-js';
import { JSONSchemaDto } from '../dtos/json-schema.dto';
import { isStringifiedMailyJSONContent, wrapMailyInLiquid } from '../helpers/maily-utils';
import { extractFieldsFromRules, isValidRule } from '../services/query-parser/query-parser.service';
import { extractLiquidTemplateVariables as newExtractLiquidTemplateVariables } from './template-parser/new-liquid-parser';
import type { VariableDetails } from './template-parser/types';

export function buildVariables({
  variableSchema,
  controlValue,
  logger,
  suggestPayloadNamespace = true,
}: {
  variableSchema: JSONSchemaDto | undefined;
  controlValue: unknown | Record<string, unknown>;
  logger?: PinoLogger;
  suggestPayloadNamespace?: boolean;
}): VariableDetails {
  let variableControlValue = controlValue;

  if (isStringifiedMailyJSONContent(variableControlValue)) {
    try {
      variableControlValue = wrapMailyInLiquid(variableControlValue);
    } catch (error) {
      logger?.error(
        {
          err: error as Error,
          controlKey: 'unknown',
          message: 'Failed to transform maily content to liquid syntax',
        },
        'BuildVariables'
      );
    }
  } else if (isValidRule(variableControlValue as RulesLogic<AdditionalOperation>)) {
    const fields = extractFieldsFromRules(variableControlValue as RulesLogic<AdditionalOperation>)
      .filter(
        (field) => field.startsWith('payload.') || field.startsWith('subscriber.data.') || field.startsWith('context.')
      )
      .map((field) => `{{${field}}}`);

    variableControlValue = {
      rules: variableControlValue,
      fields,
    };
  }

  const { validVariables, invalidVariables } = newExtractLiquidTemplateVariables({
    template: typeof variableControlValue === 'string' ? variableControlValue : JSON.stringify(variableControlValue),
    variableSchema,
    suggestPayloadNamespace,
  });

  return {
    validVariables,
    invalidVariables,
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - buildVariables({
  variableSchema,
  controlValue,
  logger,
  suggestPayloadNamespace = true,
}: {
  variableSchema: JSONSchemaDto | undefined;
  controlValue: unknown | Record<string, unknown>;
  logger?: PinoLogger;
  suggestPayloadNamespace?: boolean;
})
Asignaciones con arrow functions encontradas (posibles funciones):
 - fields(extractFieldsFromRules(variableControlValue as RulesLogic<AdditionalOperation>)
      .filter(
     ...)
Declaraciones 'export' encontradas:
- export function buildVariables

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/utils/create-schema.ts
Tamaño: 6346 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { JsonSchemaFormatEnum, JsonSchemaTypeEnum } from '@novu/dal';
import { SeverityLevelEnum } from '@novu/shared';
import { JSONSchemaDto } from '../dtos/json-schema.dto';

function determineSchemaType(value: unknown): JSONSchemaDto {
  if (value === null) {
    return { type: JsonSchemaTypeEnum.NULL };
  }

  if (Array.isArray(value)) {
    return {
      type: JsonSchemaTypeEnum.ARRAY,
      items: value.length > 0 ? determineSchemaType(value[0]) : { type: JsonSchemaTypeEnum.ARRAY },
    };
  }

  switch (typeof value) {
    case 'string':
      return { type: JsonSchemaTypeEnum.STRING, default: value };
    case 'number':
      return { type: JsonSchemaTypeEnum.NUMBER, default: value };
    case 'boolean':
      return { type: JsonSchemaTypeEnum.BOOLEAN, default: value };
    case 'object':
      return {
        type: JsonSchemaTypeEnum.OBJECT,
        properties: Object.entries(value).reduce(
          (acc, [key, val]) => {
            acc[key] = determineSchemaType(val);

            return acc;
          },
          {} as { [key: string]: JSONSchemaDto }
        ),
        required: Object.keys(value),
      };

    default:
      return { type: JsonSchemaTypeEnum.NULL };
  }
}

export function buildVariablesSchema(object: unknown) {
  const schema: JSONSchemaDto = {
    type: JsonSchemaTypeEnum.OBJECT,
    properties: {},
    required: [],
    additionalProperties: true,
  };

  if (object) {
    for (const [key, value] of Object.entries(object)) {
      if (schema.properties && schema.required) {
        schema.properties[key] = determineSchemaType(value);
        schema.required.push(key);
      }
    }
  }

  return schema;
}

export const buildSubscriberSchema = (subscriber: unknown) => {
  return {
    type: JsonSchemaTypeEnum.OBJECT,
    description: 'Schema representing the subscriber entity',
    properties: {
      firstName: { type: JsonSchemaTypeEnum.STRING, description: "Subscriber's first name" },
      lastName: { type: JsonSchemaTypeEnum.STRING, description: "Subscriber's last name" },
      email: { type: JsonSchemaTypeEnum.STRING, description: "Subscriber's email address" },
      phone: { type: JsonSchemaTypeEnum.STRING, description: "Subscriber's phone number (optional)" },
      avatar: { type: JsonSchemaTypeEnum.STRING, description: "URL to the subscriber's avatar image (optional)" },
      locale: { type: JsonSchemaTypeEnum.STRING, description: 'Locale for the subscriber (optional)' },
      timezone: { type: JsonSchemaTypeEnum.STRING, description: 'Timezone for the subscriber (optional)' },
      subscriberId: { type: JsonSchemaTypeEnum.STRING, description: 'Unique identifier for the subscriber' },
      isOnline: {
        type: JsonSchemaTypeEnum.BOOLEAN,
        description: 'Indicates if the subscriber is online (optional)',
      },
      lastOnlineAt: {
        type: JsonSchemaTypeEnum.STRING,
        format: JsonSchemaFormatEnum.DATETIME,
        description: 'The last time the subscriber was online (optional)',
      },
      data: buildVariablesSchema(
        subscriber && typeof subscriber === 'object' && 'data' in subscriber ? subscriber.data : {}
      ),
    },
    required: ['subscriberId'],
    additionalProperties: false,
  };
};

export const buildWorkflowSchema = () => {
  return {
    type: JsonSchemaTypeEnum.OBJECT,
    description: 'Schema representing the workflow entity',
    properties: {
      workflowId: { type: JsonSchemaTypeEnum.STRING, description: 'Workflow identifier' },
      name: { type: JsonSchemaTypeEnum.STRING, description: 'Name of the workflow' },
      description: { type: JsonSchemaTypeEnum.STRING, description: 'Description of the workflow' },
      tags: { type: JsonSchemaTypeEnum.ARRAY, items: { type: JsonSchemaTypeEnum.STRING } },
      severity: {
        type: JsonSchemaTypeEnum.STRING,
        enum: [...Object.values(SeverityLevelEnum)],
        enumName: 'SeverityLevelEnum',
        description: 'Severity of the workflow',
      },
    },
    required: ['workflowId', 'name'],
  };
};

export const buildContextSchema = (context?: unknown) => {
  const baseSchema = {
    type: JsonSchemaTypeEnum.OBJECT,
    description: 'Context data passed at trigger time following ContextPayload structure',
    properties: {} as Record<string, JSONSchemaDto>,
    required: [],
    additionalProperties: {
      type: JsonSchemaTypeEnum.OBJECT,
      description: 'Context value - can be accessed as string or object',
      properties: {
        id: {
          type: JsonSchemaTypeEnum.STRING,
          description: 'Context identifier',
        },
        data: {
          type: JsonSchemaTypeEnum.OBJECT,
          description: 'Additional context data',
          properties: {},
          additionalProperties: true,
        },
      },
      required: [],
      additionalProperties: false,
    },
  };

  // If no context data provided, return the base schema with additionalProperties
  if (!context || typeof context !== 'object' || Object.keys(context).length === 0) {
    return baseSchema;
  }

  // Build specific properties for each context entity
  const contextProperties: Record<string, JSONSchemaDto> = {};

  for (const [entityType, entityValue] of Object.entries(context)) {
    if (entityValue && typeof entityValue === 'object') {
      const entity = entityValue as Record<string, unknown>;

      // Each context entity should have id and data properties
      const entitySchema: JSONSchemaDto = {
        type: JsonSchemaTypeEnum.OBJECT,
        properties: {
          id: {
            type: JsonSchemaTypeEnum.STRING,
            description: 'Context identifier',
          },
          data:
            entity.data && typeof entity.data === 'object'
              ? buildVariablesSchema(entity.data) // Dynamic schema for entity.data
              : {
                  type: JsonSchemaTypeEnum.OBJECT,
                  description: 'Additional context data',
                  additionalProperties: true,
                },
        },
        required: ['id'],
        additionalProperties: false, // Only allow id and data
      };

      contextProperties[entityType] = entitySchema;
    }
  }

  // Return schema with both specific properties AND additionalProperties for new entities
  return {
    ...baseSchema,
    properties: contextProperties,
  };
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - determineSchemaType(value: unknown)
 - buildVariablesSchema(object: unknown)
Asignaciones con arrow functions encontradas (posibles funciones):
 - buildSubscriberSchema(subscriber: unknown))
 - buildWorkflowSchema())
 - buildContextSchema(context?: unknown))
Declaraciones 'export' encontradas:
- export function buildVariablesSchema
- export  const
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/utils/html.ts
Tamaño: 210 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export const removeBrandingFromHtml = (html: string): string => {
  try {
    return html.replace(/<table[^>]*data-novu-branding[^>]*>[\s\S]*?<\/table>(\s*)/gi, '');
  } catch (error) {
    return html;
  }
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - removeBrandingFromHtml(html: string): string)
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/utils/issues.ts
Tamaño: 5911 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ContentIssueEnum, RuntimeIssue, StepTypeEnum } from '@novu/shared';
import Ajv, { ErrorObject } from 'ajv';
import addFormats from 'ajv-formats';

import { JSONSchemaDto } from '../dtos/json-schema.dto';
import { capitalize } from '../services/helper/helper.service';
import { buildVariables } from './build-variables';
import { buildLiquidParser } from './template-parser/liquid-engine';

const getErrorPath = (error: ErrorObject): string => {
  const path = error.instancePath.substring(1);
  const { missingProperty } = error.params;

  if (!path || path.trim().length === 0) {
    return missingProperty;
  }

  const fullPath = missingProperty ? `${path}/${missingProperty}` : path;

  return fullPath?.replace(/\//g, '.');
};

const mapAjvErrorToMessage = (
  error: ErrorObject<string, Record<string, unknown>, unknown>,
  stepType?: StepTypeEnum
): string => {
  if (stepType === StepTypeEnum.IN_APP) {
    if (error.keyword === 'required') {
      return 'Subject or body is required';
    }
    if (error.keyword === 'minLength') {
      return `${capitalize(error.instancePath.replace('/', ''))} is required`;
    }
  }

  if (error.keyword === 'required') {
    return `${capitalize(error.params.missingProperty as string)} is required`;
  }
  if (error.keyword === 'minLength') {
    return `${capitalize(error.instancePath.replace('/', ''))} is required`;
  }
  if (
    error.keyword === 'pattern' &&
    error.message?.includes('must match pattern') &&
    error.message?.includes('mailto') &&
    error.message?.includes('https')
  ) {
    return `Invalid URL. Must be a valid full URL, path starting with /, or {{variable}}`;
  }

  return error.message || 'Invalid value';
};

const mapAjvErrorToIssueType = (error: ErrorObject): ContentIssueEnum => {
  switch (error.keyword) {
    case 'required':
      return ContentIssueEnum.MISSING_VALUE;
    case 'type':
      return ContentIssueEnum.MISSING_VALUE;
    default:
      return ContentIssueEnum.MISSING_VALUE;
  }
};

export type ControlIssues = {
  controls?: Record<string, RuntimeIssue[]>;
};

export const processControlValuesBySchema = ({
  controlSchema,
  controlValues,
  stepType,
}: {
  controlSchema: JSONSchemaDto | undefined;
  controlValues: Record<string, unknown> | null;
  stepType?: StepTypeEnum;
}): ControlIssues => {
  let issues: ControlIssues = {};

  if (!controlSchema || !controlValues) {
    return issues;
  }

  const ajv = new Ajv({ allErrors: true });
  addFormats(ajv);
  const validate = ajv.compile(controlSchema);
  const isValid = validate(controlValues);
  const errors = validate.errors as null | ErrorObject[];

  if (!isValid && errors && errors?.length !== 0 && controlValues) {
    issues = {
      controls: errors.reduce(
        (acc, error) => {
          const path = getErrorPath(error);
          if (!acc[path]) {
            acc[path] = [];
          }
          acc[path].push({
            message: mapAjvErrorToMessage(error, stepType),
            issueType: mapAjvErrorToIssueType(error),
            variableName: path,
          });

          return acc;
        },
        {} as Record<string, RuntimeIssue[]>
      ),
    };

    return issues;
  }

  return issues;
};

const validateContentCompilation = (controlKey: string, currentValue: unknown): RuntimeIssue | null => {
  try {
    const parserEngine = buildLiquidParser();
    parserEngine.parse(typeof currentValue === 'string' ? currentValue : JSON.stringify(currentValue));

    return null;
  } catch (error) {
    const message = error.message ? error.message.split(', line:1')[0] || error.message.split(' line:1')[0] : '';

    return {
      message: `Content compilation error: ${message}`.trim(),
      issueType: ContentIssueEnum.ILLEGAL_VARIABLE_IN_CONTROL_VALUE,
      variableName: controlKey,
    };
  }
};

export const processControlValuesByLiquid = ({
  currentValue,
  currentPath,
  issues,
  variableSchema,
}: {
  currentValue: unknown;
  currentPath: string[];
  issues: ControlIssues;
  variableSchema: JSONSchemaDto | undefined;
}) => {
  if (!currentValue || typeof currentValue !== 'object') {
    const liquidTemplateIssues = buildVariables({
      variableSchema,
      controlValue: currentValue,
      suggestPayloadNamespace: false,
    });

    // Prioritize invalid variable validation over content compilation since it provides more granular error details
    if (liquidTemplateIssues.invalidVariables.length > 0) {
      const controlKey = currentPath.join('.');

      issues.controls = issues.controls || {};

      issues.controls[controlKey] = liquidTemplateIssues.invalidVariables.map((invalidVariable) => {
        const message = invalidVariable.message ? invalidVariable.message.split(' line:')[0] : '';
        const variableName = invalidVariable.name === 'unknown' ? '{{}}' : invalidVariable.name;

        if ('filterMessage' in invalidVariable) {
          return {
            message: `Filter "${invalidVariable.filterMessage}" in "${variableName}"`,
            issueType: ContentIssueEnum.INVALID_FILTER_ARG_IN_VARIABLE,
            variableName: variableName,
          };
        }

        return {
          message: `Variable "${variableName}" ${message}`.trim(),
          issueType: ContentIssueEnum.ILLEGAL_VARIABLE_IN_CONTROL_VALUE,
          variableName: variableName,
        };
      });
    } else {
      const contentControlKey = currentPath.join('.');
      const contentIssue = validateContentCompilation(contentControlKey, currentValue);
      if (contentIssue) {
        issues.controls = issues.controls || {};
        issues.controls[contentControlKey] = [contentIssue];

        return;
      }
    }

    return;
  }

  for (const [key, value] of Object.entries(currentValue)) {
    processControlValuesByLiquid({
      currentValue: value,
      currentPath: [...currentPath, key],
      issues,
      variableSchema,
    });
  }
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - getErrorPath(error: ErrorObject): string)
 - mapAjvErrorToMessage(error: ErrorObject<string, Record<string, unknown>, unknown>,
  stepType?: StepTypeEnum
): string)
 - mapAjvErrorToIssueType(error: ErrorObject): ContentIssueEnum)
 - processControlValuesBySchema({
  controlSchema,
  controlValues,
  stepType,
}: {
  controlSchema: JSONSchemaDto | undefined;
  c...)
 - issues({
      controls: errors.reduce(
        (acc, error))
 - validateContentCompilation(controlKey: string, currentValue: unknown): RuntimeIssue | null)
 - processControlValuesByLiquid({
  currentValue,
  currentPath,
  issues,
  variableSchema,
}: {
  currentValue: unknown;
  current...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/utils/mappers.ts
Tamaño: 1510 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { LogRepository, RequestLog } from '@novu/application-generic';
import { UserSessionData } from '@novu/shared';
import { getClientIp } from 'request-ip';
import { sanitizePayload } from '../../../utils/payload-sanitizer';
import { generateTransactionId } from '../helpers/generate-transaction-id';
import { RequestWithReqId } from '../middleware/request-id.middleware';
import { getRequestId } from './request-transaction.util';

export function buildLog(
  req: RequestWithReqId,
  statusCode: number,
  data: any,
  user: UserSessionData | null,
  duration: number = 0
): Omit<RequestLog, 'expires_at'> | null {
  // Skip logging when user data is incomplete to prevent orphaned log entries
  if (!user?._id || !user?.organizationId || !user?.environmentId || !user?.scheme) return null;

  const requestId = getRequestId(req);

  if (!requestId) {
    return null;
  }

  return {
    id: requestId,
    created_at: LogRepository.formatDateTime64(new Date()),
    path: req.path,
    url: req.originalUrl,
    url_pattern: req.route.path,
    hostname: req.hostname,
    status_code: statusCode,
    method: req.method,
    transaction_id: generateTransactionId(),
    ip: getClientIp(req) || '',
    user_agent: req.headers['user-agent'] || '',
    request_body: sanitizePayload(req.body),
    response_body: sanitizePayload(data),
    user_id: user._id,
    organization_id: user.organizationId,
    environment_id: user.environmentId,
    auth_type: user.scheme,
    duration_ms: duration,
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - buildLog(req: RequestWithReqId,
  statusCode: number,
  data: any,
  user: UserSessionData | null,
  duration: number = 0)
Declaraciones 'export' encontradas:
- export function buildLog

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/utils/request-transaction.util.ts
Tamaño: 319 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { RequestWithReqId } from '../middleware/request-id.middleware';

/**
 * Extracts the request ID from the request object without fallback.
 * Returns undefined if no request ID is attached to the request.
 */
export function getRequestId(req: RequestWithReqId): string | undefined {
  return req._nvRequestId;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getRequestId(req: RequestWithReqId)
Declaraciones 'export' encontradas:
- export function getRequestId

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/utils/template-parser/liquid-engine.ts
Tamaño: 241 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { createLiquidEngine } from '@novu/framework/internal';

export const buildLiquidParser = () => {
  return createLiquidEngine({
    strictVariables: true,
    strictFilters: true,
    greedy: false,
    catchAllErrors: true,
  });
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - buildLiquidParser())
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/utils/template-parser/new-liquid-parser.spec.ts
Tamaño: 31891 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { JsonSchemaTypeEnum } from '@novu/dal';
import { expect } from 'chai';
import { JSONSchemaDto } from '../../dtos/json-schema.dto';
import { extractLiquidTemplateVariables } from './new-liquid-parser';

describe('extractLiquidTemplateVariables', () => {
  // Define a common schema that can be used across multiple describe blocks
  const commonSchema: JSONSchemaDto = {
    type: JsonSchemaTypeEnum.OBJECT,
    properties: {
      user: {
        type: JsonSchemaTypeEnum.OBJECT,
        properties: {
          name: { type: JsonSchemaTypeEnum.STRING },
          email: { type: JsonSchemaTypeEnum.STRING },
          items: {
            type: JsonSchemaTypeEnum.ARRAY,
            items: {
              type: JsonSchemaTypeEnum.OBJECT,
              properties: {
                name: { type: JsonSchemaTypeEnum.STRING },
              },
            },
          },
        },
      },
      payload: {
        type: JsonSchemaTypeEnum.OBJECT,
        properties: {
          items: {
            type: JsonSchemaTypeEnum.ARRAY,
            items: {
              type: JsonSchemaTypeEnum.OBJECT,
              properties: {
                name: { type: JsonSchemaTypeEnum.STRING },
              },
            },
          },
        },
      },
    },
  };

  describe('Basic output variables without schema', () => {
    it('should extract simple variables', () => {
      const template = '{{payload.title}} {{test}}';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });

      expect(validVariables).to.have.lengthOf(1);
      expect(invalidVariables).to.have.lengthOf(1);
      expect(validVariables[0].name).to.equal('payload.title');
      expect(invalidVariables[0].name).to.equal('test');
    });

    it('should handle nested properties', () => {
      const template = '{{payload.title}} {{user.profile.address.street}}';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });

      expect(validVariables).to.have.lengthOf(1);
      expect(invalidVariables).to.have.lengthOf(1);
      expect(validVariables[0].name).to.equal('payload.title');
      expect(invalidVariables[0].name).to.equal('user.profile.address.street');
    });

    it('should handle array notation', () => {
      const template = '{{payload.items[0].name}} {{users[1].email}}';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });

      expect(validVariables).to.have.lengthOf(1);
      expect(invalidVariables).to.have.lengthOf(1);
      expect(validVariables[0].name).to.equal('payload.items[0].name');
      expect(invalidVariables[0].name).to.equal('users[1].email');
    });
  });

  describe('Basic output variables with schema', () => {
    const variableSchema: JSONSchemaDto = {
      type: JsonSchemaTypeEnum.OBJECT,
      properties: {
        payload: {
          type: JsonSchemaTypeEnum.OBJECT,
          properties: {
            phone: { type: JsonSchemaTypeEnum.STRING },
            job: {
              type: JsonSchemaTypeEnum.OBJECT,
              properties: {
                title: { type: JsonSchemaTypeEnum.STRING },
              },
            },
            items: {
              type: JsonSchemaTypeEnum.ARRAY,
              items: {
                type: JsonSchemaTypeEnum.OBJECT,
                properties: {
                  email: { type: JsonSchemaTypeEnum.STRING },
                },
              },
            },
          },
        },
      },
    };

    it('should extract simple variables', () => {
      const template = '{{payload.phone}} {{test}}';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template, variableSchema });

      expect(validVariables).to.have.lengthOf(1);
      expect(invalidVariables).to.have.lengthOf(1);
      expect(validVariables[0].name).to.equal('payload.phone');
      expect(invalidVariables[0].name).to.equal('test');
    });

    it('should handle nested properties', () => {
      const template = '{{payload.phone}} {{user.profile.address.street}}';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template, variableSchema });

      expect(validVariables).to.have.lengthOf(1);
      expect(invalidVariables).to.have.lengthOf(1);
      expect(validVariables[0].name).to.equal('payload.phone');
      expect(invalidVariables[0].name).to.equal('user.profile.address.street');
    });

    it('should handle array notation', () => {
      const template = '{{payload.items[1].email}} {{items[0].name}}';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template, variableSchema });

      expect(validVariables).to.have.lengthOf(1);
      expect(invalidVariables).to.have.lengthOf(1);
      expect(validVariables[0].name).to.equal('payload.items[1].email');
      expect(invalidVariables[0].name).to.equal('items[0].name');
    });

    it('should handle invalid payload variables', () => {
      const template = '{{payload.test}} {{items[0].name}}';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template, variableSchema });

      expect(validVariables).to.have.lengthOf(0);
      expect(invalidVariables).to.have.lengthOf(2);
      expect(invalidVariables[0].name).to.equal('payload.test');
      expect(invalidVariables[1].name).to.equal('items[0].name');
    });
  });

  describe('Variables with filters', () => {
    it('should handle variables with filters', () => {
      const template = '{{payload.name | upcase}} {{user.email | downcase}}';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });

      expect(validVariables).to.have.lengthOf(1);
      expect(invalidVariables).to.have.lengthOf(1);
      expect(validVariables[0].name).to.equal('payload.name');
      expect(invalidVariables[0].name).to.equal('user.email');
    });

    it('should handle toSentence filter with arguments', () => {
      const template = `{{ steps.digest-step.events | toSentence: 'payload.name', 2, 'other' }}`;
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });

      expect(validVariables).to.have.lengthOf(2);
      expect(invalidVariables).to.have.lengthOf(0);
      expect(validVariables[0].name).to.equal('steps.digest-step.events.payload.name');
      expect(validVariables[1].name).to.equal('steps.digest-step.events');
    });
  });

  describe('For loops', () => {
    it('should handle for loops with valid collection variable', () => {
      const template = '{% for item in payload.items %}{{item.name}}{{invalid}}{% endfor %}';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });

      expect(validVariables).to.have.lengthOf(1);
      expect(invalidVariables).to.have.lengthOf(1);
      expect(validVariables[0].name).to.equal('payload.items');
      expect(invalidVariables[0].name).to.equal('invalid');
    });

    it('should handle for loops with invalid collection variable', () => {
      const template = '{% for item in invalidCollection %}{{item.name}}{{payload.foo}}{% endfor %}';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });

      expect(validVariables).to.have.lengthOf(1);
      expect(invalidVariables).to.have.lengthOf(1);
      expect(validVariables[0].name).to.equal('payload.foo');
      expect(invalidVariables[0].name).to.equal('invalidCollection');
    });

    it('should handle for loops with ranges (literal)', () => {
      const template = '{% for i in (1..5) %}{{i}}{{payload.foo}}{% endfor %}';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });

      expect(validVariables).to.have.lengthOf(1);
      expect(validVariables[0].name).to.equal('payload.foo');
      expect(invalidVariables).to.have.lengthOf(0);
    });

    it('should handle for loops with ranges (variables)', () => {
      const template = '{% for i in (payload.start..payload.end) %}{{i}}{{payload.foo}}{{test}}{% endfor %}';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });

      const variableNames = validVariables.map((variable) => variable.name);
      expect(validVariables).to.have.lengthOf(3);
      expect(invalidVariables).to.have.lengthOf(1);
      expect(variableNames).to.include('payload.start');
      expect(variableNames).to.include('payload.end');
      expect(variableNames).to.include('payload.foo');
      expect(invalidVariables[0].name).to.equal('test');
    });

    it('should handle nested for loops', () => {
      const template = `
        {% for user in payload.users %}
          {% for post in user.posts %}
            {{post.title}}
            {{invalid}}
          {% endfor %}
          {{invalid2}}
        {% endfor %}
      `;
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });

      const variableNames = validVariables.map((variable) => variable.name);
      const invalidVariableNames = invalidVariables.map((variable) => variable.name);
      expect(validVariables).to.have.lengthOf(1);
      expect(invalidVariables).to.have.lengthOf(2);
      expect(variableNames).to.include('payload.users');
      expect(invalidVariableNames).to.include('invalid');
      expect(invalidVariableNames).to.include('invalid2');
    });
  });

  describe('Conditional tags', () => {
    it('should handle if statements with valid condition', () => {
      const template = '{% if payload.isActive %}Welcome!{{invalid}}{% endif %}';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });

      expect(validVariables).to.have.lengthOf(1);
      expect(invalidVariables).to.have.lengthOf(1);
      expect(validVariables[0].name).to.equal('payload.isActive');
      expect(invalidVariables[0].name).to.equal('invalid');
    });

    it('should handle if statements with invalid condition', () => {
      const template = '{% if user.isActive %}Welcome!{{invalid}}{% endif %}';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });
      const invalidVariableNames = invalidVariables.map((variable) => variable.name);

      expect(validVariables).to.have.lengthOf(0);
      expect(invalidVariables).to.have.lengthOf(2);
      expect(invalidVariableNames).to.include('user.isActive');
      expect(invalidVariableNames).to.include('invalid');
    });

    it('should handle unless statements with valid condition', () => {
      const template = '{% unless payload.banned %}Show content{{invalid}}{% endunless %}';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });

      expect(validVariables).to.have.lengthOf(1);
      expect(invalidVariables).to.have.lengthOf(1);
      expect(validVariables[0].name).to.equal('payload.banned');
      expect(invalidVariables[0].name).to.equal('invalid');
    });

    it('should handle variables with hyphens in if conditions', () => {
      const template = '{% if steps.digest-step.events[0].id %}Hello{% endif %}';
      const variableSchema: JSONSchemaDto = {
        type: JsonSchemaTypeEnum.OBJECT,
        properties: {
          steps: {
            type: JsonSchemaTypeEnum.OBJECT,
            additionalProperties: true,
          },
        },
      };
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template, variableSchema });

      expect(validVariables).to.have.lengthOf(1);
      expect(invalidVariables).to.have.lengthOf(0);
      expect(validVariables[0].name).to.equal('steps.digest-step.events[0].id');
    });

    it('should handle unless statements with invalid condition', () => {
      const template = '{% unless user.banned %}Show content{{invalid}}{% endunless %}';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });
      const invalidVariableNames = invalidVariables.map((variable) => variable.name);

      expect(validVariables).to.have.lengthOf(0);
      expect(invalidVariables).to.have.lengthOf(2);
      expect(invalidVariableNames).to.include('user.banned');
      expect(invalidVariableNames).to.include('invalid');
    });

    it('should handle complex conditions', () => {
      const template =
        '{% if user.age > 18 and payload.country == "US" %}Adult US user{{invalid}}{{payload.foo}}{% endif %}';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });

      const validVariableNames = validVariables.map((variable) => variable.name);
      const invalidVariableNames = invalidVariables.map((variable) => variable.name);

      expect(validVariables).to.have.lengthOf(2);
      expect(invalidVariables).to.have.lengthOf(2);
      expect(validVariableNames).to.include('payload.country');
      expect(validVariableNames).to.include('payload.foo');
      expect(invalidVariableNames).to.include('user.age');
      expect(invalidVariableNames).to.include('invalid');
    });

    it('should handle elsif branches', () => {
      const template = `
        {% if payload.role == "admin" %}
          Admin
        {% elsif user.role == "moderator" %}
          Mod
        {% else %}
          User
        {% endif %}
      `;
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });

      expect(validVariables).to.have.lengthOf(1);
      expect(invalidVariables).to.have.lengthOf(1);
      expect(validVariables[0].name).to.equal('payload.role');
      expect(invalidVariables[0].name).to.equal('user.role');
    });

    it('should handle multiple conditions', () => {
      const template = `
        {% if payload.title == "Awesome Shoes" and product.name == "hello" %}
          These shoes are awesome!
        {% endif %}
      `;
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });

      expect(validVariables).to.have.lengthOf(1);
      expect(invalidVariables).to.have.lengthOf(1);
      expect(validVariables[0].name).to.equal('payload.title');
      expect(invalidVariables[0].name).to.equal('product.name');
    });

    it('should handle if statements without treating variables as filter names', () => {
      const template = '{% if payload.isActive %}Hello!{% endif %}';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });

      expect(validVariables).to.have.lengthOf(1);
      expect(invalidVariables).to.have.lengthOf(0);
      expect(validVariables[0].name).to.equal('payload.isActive');
    });
  });

  describe('Assign tags', () => {
    it('should handle assign statements with valid variable', () => {
      const template = '{% assign fullName = payload.firstName %}{{fullName}}{{invalid}}';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });

      expect(validVariables).to.have.lengthOf(1);
      expect(invalidVariables).to.have.lengthOf(1);
      expect(validVariables[0].name).to.equal('payload.firstName');
      expect(invalidVariables[0].name).to.equal('invalid');
    });

    it('should handle assign statements with invalid variable', () => {
      const template = '{% assign fullName = user.firstName %}{{fullName}}{{payload.foo}}';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });

      expect(validVariables).to.have.lengthOf(1);
      expect(invalidVariables).to.have.lengthOf(1);
      expect(validVariables[0].name).to.equal('payload.foo');
      expect(invalidVariables[0].name).to.equal('user.firstName');
    });

    it('should handle assign statements with filters without treating filter names as variables', () => {
      const template = '{% assign uppercaseName = payload.firstName | upcase %}{{uppercaseName}}';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });

      expect(validVariables).to.have.lengthOf(1);
      expect(invalidVariables).to.have.lengthOf(0);
      expect(validVariables[0].name).to.equal('payload.firstName');
    });

    it('should handle assign statements with multiple filters', () => {
      const template = '{% assign processedName = payload.firstName | upcase | truncate: 10 %}{{processedName}}';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });

      expect(validVariables).to.have.lengthOf(1);
      expect(invalidVariables).to.have.lengthOf(0);
      expect(validVariables[0].name).to.equal('payload.firstName');
    });

    it('should handle assign statements with whitespace control - both sides', () => {
      const template = '{%- assign first_name = payload.first_name -%} Hello {{first_name}}';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });

      expect(validVariables).to.have.lengthOf(1);
      expect(invalidVariables).to.have.lengthOf(0);
      expect(validVariables[0].name).to.equal('payload.first_name');
    });

    it('should handle assign statements with whitespace control - left side only', () => {
      const template = '{%- assign first_name = payload.first_name %} Hello {{first_name}}';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });

      expect(validVariables).to.have.lengthOf(1);
      expect(invalidVariables).to.have.lengthOf(0);
      expect(validVariables[0].name).to.equal('payload.first_name');
    });

    it('should handle assign statements with whitespace control - right side only', () => {
      const template = '{% assign first_name = payload.first_name -%} Hello {{first_name}}';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });

      expect(validVariables).to.have.lengthOf(1);
      expect(invalidVariables).to.have.lengthOf(0);
      expect(validVariables[0].name).to.equal('payload.first_name');
    });
  });

  describe('Capture tags', () => {
    it('should handle capture blocks', () => {
      const template = `
        {% capture greeting %}
          Hello {{payload.name}}!
        {% endcapture %}
        {{greeting}}
      `;
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });

      expect(validVariables).to.have.lengthOf(1);
      expect(invalidVariables).to.have.lengthOf(0);
      expect(validVariables[0].name).to.equal('payload.name');
    });
  });

  describe('Tablerow tags', () => {
    it('should handle tablerow loops', () => {
      const template =
        '{% tablerow product in payload.products %}{{product.name}}{{invalid}}{{payload.foo}}{% endtablerow %}';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });
      const validVariableNames = validVariables.map((variable) => variable.name);

      expect(validVariableNames).to.have.lengthOf(2);
      expect(validVariableNames).to.include('payload.products');
      expect(validVariableNames).to.include('payload.foo');
      expect(invalidVariables).to.have.lengthOf(1);
      expect(invalidVariables[0].name).to.equal('invalid');
    });

    it('should handle tablerow with ranges', () => {
      const template = '{% tablerow i in (1..payload.count) %}{{i}}{{invalid}}{{payload.foo}}{% endtablerow %}';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });

      const validVariableNames = validVariables.map((variable) => variable.name);
      expect(validVariableNames).to.have.lengthOf(2);
      expect(validVariableNames).to.include('payload.count');
      expect(validVariableNames).to.include('payload.foo');
      expect(invalidVariables).to.have.lengthOf(1);
      expect(invalidVariables[0].name).to.equal('invalid');
    });
  });

  describe('Case/when tags', () => {
    it('should handle case statements', () => {
      const template = `
        {% case user.status %}
          {% when "active" %}
            Active user
          {% when "pending" %}
            Pending user
          {% else %}
            Unknown status
        {% endcase %}
        {% case payload.status %}
          {% when "active" %}
            Active user
          {% when "pending" %}
            Pending user
          {% else %}
            Unknown status
        {% endcase %}
      `;
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });

      expect(validVariables).to.have.lengthOf(1);
      expect(invalidVariables).to.have.lengthOf(1);
      expect(validVariables[0].name).to.equal('payload.status');
      expect(invalidVariables[0].name).to.equal('user.status');
    });

    it('should handle case with variable when conditions', () => {
      const template = `
        {% case payload.role %}
          {% when payload.adminRole %}
            Admin
          {% when settings.modRole %}
            Moderator
        {% endcase %}
      `;
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });
      const variableNames = validVariables.map((variable) => variable.name);

      expect(validVariables).to.have.lengthOf(2);
      expect(invalidVariables).to.have.lengthOf(1);
      expect(variableNames).to.include('payload.role');
      expect(variableNames).to.include('payload.adminRole');
      expect(invalidVariables[0].name).to.equal('settings.modRole');
    });
  });

  describe('Schema validation', () => {
    it('should validate variables against schema', () => {
      const template = '{{user.name}} {{user.invalidField}}';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({
        template,
        variableSchema: commonSchema,
      });

      expect(validVariables).to.have.lengthOf(1);
      expect(validVariables[0].name).to.equal('user.name');
      expect(invalidVariables).to.have.lengthOf(1);
      expect(invalidVariables[0].name).to.equal('user.invalidField');
      expect(invalidVariables[0].message).to.equal('is not supported');
    });

    it('should validate array access', () => {
      const template = '{{payload.items[0].name}} {{user.items[0].name}}';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({
        template,
        variableSchema: commonSchema,
      });

      expect(validVariables).to.have.lengthOf(2);
      expect(invalidVariables).to.have.lengthOf(0);
      expect(validVariables[0].name).to.equal('payload.items[0].name');
      expect(validVariables[1].name).to.equal('user.items[0].name');
    });
  });

  describe('Edge cases and error handling', () => {
    it('should handle empty template', () => {
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template: '' });

      expect(validVariables).to.have.lengthOf(0);
      expect(invalidVariables).to.have.lengthOf(0);
    });

    it('should handle template with only text', () => {
      const template = 'Hello world, no variables here!';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });

      expect(validVariables).to.have.lengthOf(0);
      expect(invalidVariables).to.have.lengthOf(0);
    });

    it('should handle invalid liquid syntax', () => {
      const template = '{{user..name}} {{invalid syntax}}';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });

      expect(validVariables).to.have.lengthOf(0);
      expect(invalidVariables.length).to.be.greaterThan(0);
    });

    it('should handle mixed HTML and Liquid', () => {
      const template = `
        <div>
          <h1>{{user.name}}</h1>
          {% if user.premium %}
            <span class="premium">Premium User</span>
          {% endif %}
          {% if payload.premium %}
            <span class="premium">Premium User</span>
          {% endif %}
          <ul>
            {% for item in payload.items %}
              <li>{{item.title}}</li>
              <li>{{invalid}}</li>
            {% endfor %}
          </ul>
        </div>
      `;
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });
      const validVariableNames = validVariables.map((variable) => variable.name);
      const invalidVariableNames = invalidVariables.map((variable) => variable.name);

      expect(validVariables).to.have.lengthOf(2);
      expect(invalidVariables).to.have.lengthOf(3);
      expect(validVariableNames).to.include('payload.premium');
      expect(validVariableNames).to.include('payload.items');
      expect(invalidVariableNames).to.include('user.name');
      expect(invalidVariableNames).to.include('user.premium');
      expect(invalidVariableNames).to.include('invalid');
    });

    it('should deduplicate variables', () => {
      const template = '{{user.name}} {{user.name}} {{payload.name}} {{payload.name}}';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });

      expect(validVariables).to.have.lengthOf(1);
      expect(validVariables[0].name).to.equal('payload.name');
      expect(invalidVariables).to.have.lengthOf(1);
      expect(invalidVariables[0].name).to.equal('user.name');
    });
  });

  describe('Complex real-world scenarios', () => {
    it('should handle complex template', () => {
      const template = `
        {% assign firstName = payload.firstName %}
        {% assign customerName = customer.firstName %}
        <h1>Hello {{customerName}}!</h1>
        
        {% if payload.items.length > 0 %}
          <h2>Your Cart ({{payload.items.length}} items)</h2>
          {% for item in payload.items %}
            <div>
              {{item.product.name}} - {{item.quantity}} x {{item.price}}
              {% if item.discountPercentage > 0 %}
                <span>{{item.discountPercentage}}% off!</span>
              {% endif %}
            </div>
          {% endfor %}
          
          <div>
            Subtotal: {{cart.subtotal}}
            {% if cart.discount > 0 %}
              Discount: -{{cart.discount}}
            {% endif %}
            Total: {{cart.total}}
          </div>
        {% else %}
          <p>Your cart is empty</p>
        {% endif %}
        
        {% case customer.loyaltyTier %}
          {% when "gold" %}
            <p>Gold member benefits apply!</p>
          {% when "silver" %}
            <p>Silver member benefits apply!</p>
        {% endcase %}
      `;

      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });
      const validVariableNames = validVariables.map((variable) => variable.name);
      const invalidVariableNames = invalidVariables.map((variable) => variable.name);

      expect(validVariables).to.have.lengthOf(3);
      expect(invalidVariables).to.have.lengthOf(5);

      expect(validVariableNames).to.include('payload.firstName');
      expect(validVariableNames).to.include('payload.items.length');
      expect(validVariableNames).to.include('payload.items');
      expect(invalidVariableNames).to.include('customer.firstName');
      expect(invalidVariableNames).to.include('cart.subtotal');
      expect(invalidVariableNames).to.include('cart.discount');
      expect(invalidVariableNames).to.include('cart.total');
      expect(invalidVariableNames).to.include('customer.loyaltyTier');
    });

    it('should handle complex template with defined', () => {
      const template = `
        {% assign firstName = payload.firstName %}
        {% assign customerName = payload.invalid %}
        <h1>Hello {{customerName}}!</h1>
        
        {% if payload.items.length > 0 %}
          <h2>Your Cart ({{payload.items.length}} items)</h2>
          {% for item in payload.items %}
            <div>
              {{item.product.name}} - {{item.quantity}} x {{item.price}}
              {% if item.discountPercentage > 0 %}
                <span>{{item.discountPercentage}}% off!</span>
              {% endif %}
            </div>
          {% endfor %}
          
          <div>
            Subtotal: {{payload.subtotal}}
            {% if payload.discount > 0 %}
              Discount: -{{payload.discount}}
            {% endif %}
            Total: {{payload.total}}
          </div>
        {% else %}
          <p>Your cart is empty</p>
        {% endif %}
        
        {% case customer.loyaltyTier %}
          {% when "gold" %}
            <p>Gold member benefits apply!</p>
          {% when "silver" %}
            <p>Silver member benefits apply!</p>
        {% endcase %}
      `;
      const variableSchema: JSONSchemaDto = {
        type: JsonSchemaTypeEnum.OBJECT,
        properties: {
          payload: {
            type: JsonSchemaTypeEnum.OBJECT,
            properties: {
              firstName: { type: JsonSchemaTypeEnum.STRING },
              items: {
                type: JsonSchemaTypeEnum.ARRAY,
                properties: {
                  length: { type: JsonSchemaTypeEnum.NUMBER },
                },
                items: {
                  type: JsonSchemaTypeEnum.OBJECT,
                  properties: {
                    name: { type: JsonSchemaTypeEnum.STRING },
                  },
                },
              },
            },
          },
        },
      };

      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({
        template,
        variableSchema,
      });
      const validVariableNames = validVariables.map((variable) => variable.name);
      const invalidVariableNames = invalidVariables.map((variable) => variable.name);

      expect(validVariables).to.have.lengthOf(3);
      expect(invalidVariables).to.have.lengthOf(5);

      expect(validVariableNames).to.include('payload.firstName');
      expect(validVariableNames).to.include('payload.items.length');
      expect(validVariableNames).to.include('payload.items');
      expect(invalidVariableNames).to.include('payload.invalid');
      expect(invalidVariableNames).to.include('payload.subtotal');
      expect(invalidVariableNames).to.include('payload.discount');
      expect(invalidVariableNames).to.include('payload.total');
      expect(invalidVariableNames).to.include('customer.loyaltyTier');
    });

    it('should handle undefined filters as invalid', () => {
      const template = '{{item.price | currency}}';
      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });

      expect(validVariables).to.have.lengthOf(0);
      expect(invalidVariables).to.have.lengthOf(1);
      expect(invalidVariables[0].name).to.equal('item.price');
      expect(invalidVariables[0].message).to.exist;
      expect(invalidVariables[0].message).to.include('undefined filter: currency');
    });

    it('should validate variables in the loops independently', () => {
      const template = `
        {% for item in payload.items %}
          <div>{{item.product.name}}</div>
        {% endfor %}

        {% for otherItem in payload.items2 %}
          <div>{{otherItem.product.name}}</div>
          <div>{{item.product.name}}</div>
        {% endfor %}
      `;

      const { validVariables, invalidVariables } = extractLiquidTemplateVariables({ template });
      const validVariableNames = validVariables.map((variable) => variable.name);
      const invalidVariableNames = invalidVariables.map((variable) => variable.name);

      expect(validVariables).to.have.lengthOf(2);
      expect(invalidVariables).to.have.lengthOf(1);
      expect(validVariableNames).to.include('payload.items');
      expect(validVariableNames).to.include('payload.items2');
      expect(invalidVariableNames).to.include('item.product.name');
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - JSONSchemaDto({
    type: JsonSchemaTypeEnum.OBJECT,
    properties: {
      user: {
        type: JsonSchemaTypeE...)
 - JSONSchemaDto({
      type: JsonSchemaTypeEnum.OBJECT,
      properties: {
        payload: {
          type: Json...)
 - variableNames(validVariables.map((variable))
 - variableNames(validVariables.map((variable))
 - invalidVariableNames(invalidVariables.map((variable))
 - invalidVariableNames(invalidVariables.map((variable))
 - invalidVariableNames(invalidVariables.map((variable))
 - validVariableNames(validVariables.map((variable))
 - invalidVariableNames(invalidVariables.map((variable))
 - validVariableNames(validVariables.map((variable))
 - validVariableNames(validVariables.map((variable))
 - variableNames(validVariables.map((variable))
 - validVariableNames(validVariables.map((variable))
 - invalidVariableNames(invalidVariables.map((variable))
 - validVariableNames(validVariables.map((variable))
 - invalidVariableNames(invalidVariables.map((variable))
 - validVariableNames(validVariables.map((variable))
 - invalidVariableNames(invalidVariables.map((variable))
 - validVariableNames(validVariables.map((variable))
 - invalidVariableNames(invalidVariables.map((variable))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/utils/template-parser/new-liquid-parser.ts
Tamaño: 28335 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { FILTER_VALIDATORS, LiquidFilterIssue } from '@novu/framework/internal';
import { LAYOUT_CONTENT_VARIABLE, TRANSLATION_NAMESPACE_SEPARATOR } from '@novu/shared';

import {
  AssignTag,
  CaptureTag,
  CaseTag,
  Filter,
  ForTag,
  IfTag,
  LiquidError,
  Output,
  RenderError,
  TablerowTag,
  Tag,
  Template,
  TokenKind,
  UnlessTag,
} from 'liquidjs';
import { JSONSchemaDto } from '../../dtos/json-schema.dto';
import { buildLiquidParser } from './liquid-engine';
import { DIGEST_EVENTS_VARIABLE_PATTERN, isLiquidErrors, isValidDynamicPath, isValidTemplate } from './parser-utils';
import type { ProcessContext, Variable, VariableDetails } from './types';

const parserEngine = buildLiquidParser();

/**
 * Parses a Liquid template string and extracts all variable names, including nested, variables used in the tags and conditions.
 * Validates the syntax and separates valid variables from invalid ones based on the variable schema.
 * The local variables are not added to the valid variables, for example iterator variables, because they are not part of the schema.
 *
 * @param template - The Liquid template string to parse
 * @param variableSchema - The schema to validate the variables against
 * @returns Object containing arrays of valid and invalid variables found in the template
 */
export function extractLiquidTemplateVariables({
  template,
  variableSchema,
  suggestPayloadNamespace = true,
}: {
  template: string;
  variableSchema?: JSONSchemaDto;
  suggestPayloadNamespace?: boolean;
}): VariableDetails {
  if (!isValidTemplate(template)) {
    return { validVariables: [], invalidVariables: [] };
  }

  return processLiquidRawOutput({ template, variableSchema, suggestPayloadNamespace });
}

function processLiquidRawOutput({
  template,
  variableSchema,
  suggestPayloadNamespace = true,
}: {
  template: string;
  variableSchema?: JSONSchemaDto;
  suggestPayloadNamespace?: boolean;
}): VariableDetails {
  const validVariables: Array<Variable> = [];
  const invalidVariables: Array<Variable> = [];
  const processedOutputs = new Set<string>();

  function addVariable(variable: Variable, isValid: boolean) {
    if (!processedOutputs.has(variable.name)) {
      processedOutputs.add(variable.name);
      (isValid ? validVariables : invalidVariables).push(variable);
    }
  }

  try {
    const result = parseByLiquid({ template, variableSchema, suggestPayloadNamespace });
    result.validVariables.forEach((variable) => {
      addVariable(variable, true);
    });
    result.invalidVariables.forEach((variable) => {
      addVariable(variable, false);
    });
  } catch (error: unknown) {
    if (isLiquidErrors(error)) {
      error.errors.forEach((e: RenderError) => {
        const { token } = e;
        if (token) {
          addVariable(
            {
              name: extractVariableFromOutput(token.input) || 'unknown',
              message: e.message,
              context: e.context,
              output: token.input,
              outputStart: token.begin,
              outputEnd: token.end,
            },
            false
          );
        }
      });
    } else if (error instanceof LiquidError) {
      const { token } = error as any;
      if (token) {
        addVariable(
          {
            name: extractVariableFromOutput(token.input) || 'unknown',
            message: error.message,
            output: token.input,
            outputStart: token.begin,
            outputEnd: token.end,
          },
          false
        );
      }
    }
  }

  return { validVariables, invalidVariables };
}

function parseByLiquid({
  template,
  variableSchema,
  suggestPayloadNamespace = true,
}: {
  template: string;
  variableSchema?: JSONSchemaDto;
  suggestPayloadNamespace?: boolean;
}): VariableDetails {
  const validVariables: Array<Variable> = [];
  const invalidVariables: Array<Variable> = [];
  const parsed = parserEngine.parse(template);

  processTemplates({
    templates: parsed,
    validVariables,
    invalidVariables,
    variableSchema,
    localVariables: new Set(),
    suggestPayloadNamespace,
  });

  return { validVariables, invalidVariables };
}

function processTemplates(context: ProcessContext) {
  const {
    templates,
    validVariables,
    invalidVariables,
    variableSchema,
    localVariables = new Set(),
    suggestPayloadNamespace,
  } = context;

  templates.forEach((template: Template) => {
    if (isOutputToken(template)) {
      validateOutputToken({
        template,
        validVariables,
        invalidVariables,
        variableSchema,
        localVariables,
        suggestPayloadNamespace,
      });
    } else if (isTagToken(template)) {
      processTagToken({
        template,
        validVariables,
        invalidVariables,
        variableSchema,
        localVariables,
      });
    }
  });
}

function isPropertyAllowed(schema: JSONSchemaDto | undefined, propertyPath: string) {
  if (!schema) {
    return true;
  }

  let currentSchema = { ...schema };
  if (typeof currentSchema !== 'object') {
    return false;
  }

  const pathParts = propertyPath.split('.').flatMap((part) => {
    // Split array notation into [propName, index]
    const arrayMatch = part.match(/^(.+?)\[(\d+)\]$/);

    return arrayMatch ? [arrayMatch[1], arrayMatch[2]] : [part];
  });

  for (const part of pathParts) {
    const { properties, additionalProperties, type } = currentSchema;

    // Handle direct property access
    if (properties?.[part]) {
      currentSchema = properties[part] as JSONSchemaDto;
      continue;
    }

    // Handle array paths - valid if schema is array type
    if (type === 'array') {
      // Valid array index or property access
      const isArrayIndex = !Number.isNaN(Number(part)) && Number(part) >= 0;
      const arrayItemSchema = currentSchema.items as Record<string, unknown>;

      if (isArrayIndex) {
        currentSchema = arrayItemSchema;
        continue;
      }

      if (arrayItemSchema?.properties?.[part]) {
        currentSchema = arrayItemSchema.properties[part];
        continue;
      }
    }

    if (additionalProperties === true) {
      return true;
    }

    // Check if additionalProperties is a schema object (for complex schemas)
    if (typeof additionalProperties === 'object' && additionalProperties !== null) {
      // Set the current schema to the additionalProperties schema and continue validation
      currentSchema = additionalProperties as JSONSchemaDto;
      continue;
    }

    return false;
  }

  return true;
}

function validateVariable({
  variableName,
  validVariables,
  invalidVariables,
  variableSchema,
  localVariables,
  output,
  outputStart,
  outputEnd,
  suggestPayloadNamespace,
}: {
  variableName: string;
  validVariables: Array<Variable>;
  invalidVariables: Array<Variable>;
  variableSchema?: JSONSchemaDto;
  localVariables: Set<string>;
  output: string;
  outputStart: number;
  outputEnd: number;
  suggestPayloadNamespace?: boolean;
}) {
  // Check if this variable has no namespace (single part)
  const hasNoNamespace = variableName.split('.').length === 1;
  const isNotStepVariable =
    !hasNoNamespace && !isValidDynamicPath(variableName) && !DIGEST_EVENTS_VARIABLE_PATTERN.test(variableName);
  const isLocalVariable = Array.from(localVariables).some(
    (localVar) => variableName === localVar || variableName.startsWith(`${localVar}.`)
  );

  const isAllowedVariable = isPropertyAllowed(variableSchema, variableName);
  const isContentVariable = variableName === LAYOUT_CONTENT_VARIABLE && isAllowedVariable;
  const isTranslationVariable = variableName.startsWith(TRANSLATION_NAMESPACE_SEPARATOR);

  if (isLocalVariable) {
    return;
  }

  if ((hasNoNamespace && !isContentVariable) || (!variableSchema && isNotStepVariable)) {
    // Otherwise, it's invalid (missing namespace)
    invalidVariables.push({
      name: variableName,
      message: suggestPayloadNamespace
        ? `invalid or missing namespace. Did you mean {{payload.${variableName}}}?`
        : 'invalid or missing namespace',
      output,
      outputStart,
      outputEnd,
    });

    return;
  }

  if (isAllowedVariable || isTranslationVariable) {
    validVariables.push({
      name: variableName,
      output,
      outputStart,
      outputEnd,
    });
  } else {
    invalidVariables.push({
      name: variableName,
      message: 'is not supported',
      output,
      outputStart,
      outputEnd,
    });
  }
}

function validateOutputToken({
  template,
  validVariables,
  invalidVariables,
  variableSchema,
  localVariables,
  suggestPayloadNamespace,
}: {
  template: Template;
  validVariables: Array<Variable>;
  invalidVariables: Array<Variable>;
  variableSchema?: JSONSchemaDto;
  localVariables: Set<string>;
  suggestPayloadNamespace?: boolean;
}) {
  const result = extractProps(template);
  const variableName = buildVariable(result.props);
  const { token } = template;
  const outputStart = token.begin;
  const outputEnd = token.end;
  const output = token.input.slice(outputStart, outputEnd);

  if (!result.valid) {
    invalidVariables.push({
      name: variableName || output,
      message: result.error,
      output,
      outputStart,
      outputEnd,
    });

    return;
  }

  const isDigestEventsVariable = !!variableName.match(/^steps\..+\.events$/);
  const filters = extractFilters(template);
  const filterIssues = validateFilters(filters, isDigestEventsVariable);
  const hasValidFilters = filterIssues.length === 0;

  if (!hasValidFilters) {
    invalidVariables.push({
      name: variableName,
      filterMessage: filterIssues[0].message,
      output,
      outputStart,
      outputEnd,
    });

    return;
  }

  // Handle filter arguments (like toSentence)
  if (filters.length > 0) {
    filters.forEach((filter) => {
      const { args } = filter;
      const firstArg = args[0];
      if (
        filter.name === 'toSentence' &&
        args.length > 0 &&
        'content' in firstArg &&
        typeof firstArg.content === 'string'
      ) {
        /**
         * Check if the parent variable with the first argument is allowed
         * basically forcing it to check if additionalProperties is true by checking for final variable name
         * and if the parent variable is a valid dynamic path as variableSchema can be undefined.
         * OR
         * Check if the variable is a digest events array variable
         * and the first argument starts with payload.
         */
        if (
          (isValidDynamicPath(variableName) &&
            isPropertyAllowed(variableSchema, `${variableName}.${firstArg.content}`)) ||
          (firstArg.content.startsWith('payload.') && DIGEST_EVENTS_VARIABLE_PATTERN.test(variableName))
        ) {
          const isFirstArgValid = isPropertyAllowed(variableSchema, firstArg.content);
          if (isFirstArgValid) {
            validVariables.push({
              name: `${variableName}.${firstArg.content}`,
              output: firstArg.content,
              outputStart,
              outputEnd,
            });
          } else {
            invalidVariables.push({
              name: `${variableName}.${firstArg.content}`,
              message: 'is not supported',
              output: firstArg.content,
              outputStart,
              outputEnd,
            });
          }
        }
      }
    });
  }

  validateVariable({
    variableName,
    validVariables,
    invalidVariables,
    variableSchema,
    localVariables,
    output,
    outputStart,
    outputEnd,
    suggestPayloadNamespace,
  });
}

function processTagToken({
  template,
  validVariables,
  invalidVariables,
  variableSchema,
  localVariables,
}: {
  template: Tag;
  validVariables: Array<Variable>;
  invalidVariables: Array<Variable>;
  variableSchema?: JSONSchemaDto;
  localVariables: Set<string>;
}) {
  const { token } = template;
  const outputStart = token.begin;
  const outputEnd = token.end;
  const output = token.input.slice(outputStart, outputEnd);

  if (template instanceof ForTag) {
    // Extract iterator variable from token content: {% for item in collection %}
    const forMatch = output.match(/^\s*{%\s*for\s+(\w+)\s+in\s+(.+?)\s*%}/);
    if (forMatch) {
      const [, iteratorVariable, collectionExpression] = forMatch;

      // Check if it's a range expression
      if (collectionExpression.trim().match(/^\(.+?\.\..+?\)$/)) {
        // Extract variables from range
        const rangeVariables = extractVariablesFromRange(collectionExpression.trim());
        rangeVariables.forEach((variableName) => {
          validateVariable({
            variableName,
            validVariables,
            invalidVariables,
            variableSchema,
            localVariables,
            output,
            outputStart,
            outputEnd,
          });
        });
      } else {
        // Extract collection variable (non-range)
        const collectionVariable = extractVariableFromExpression(collectionExpression);
        if (collectionVariable) {
          validateVariable({
            variableName: collectionVariable,
            validVariables,
            invalidVariables,
            variableSchema,
            localVariables,
            output,
            outputStart,
            outputEnd,
          });
        }
      }

      const newLocalVariables = new Set(localVariables);
      newLocalVariables.add(iteratorVariable);
      newLocalVariables.add('forloop'); // Add forloop built-in variable

      // process nested templates with new local variables
      processTemplates({
        templates: (template as any).templates || [],
        validVariables,
        invalidVariables,
        variableSchema,
        localVariables: newLocalVariables,
      });
    }
  } else if (template instanceof IfTag || template instanceof UnlessTag) {
    // Extract variables from condition
    const tagName = template instanceof IfTag ? 'if' : 'unless';
    const conditionMatch = output.match(new RegExp(`^\\s*{%\\s*${tagName}\\s+(.+?)\\s*%}`));
    if (conditionMatch) {
      const condition = conditionMatch[1];
      const variables = extractVariablesFromCondition(condition);

      variables.forEach((variableName) => {
        validateVariable({
          variableName,
          validVariables,
          invalidVariables,
          variableSchema,
          localVariables,
          output,
          outputStart,
          outputEnd,
        });
      });
    }

    // Process branches
    const branches = (template as any).branches || [];
    for (const branch of branches) {
      // Extract variables from branch condition (elsif conditions)
      if (branch.value) {
        const branchVariables = extractVariablesFromValue(branch.value);
        branchVariables.forEach((variableName) => {
          validateVariable({
            variableName,
            validVariables,
            invalidVariables,
            variableSchema,
            localVariables,
            output: variableName, // Using variable name as output since we don't have the exact token
            outputStart: 0,
            outputEnd: variableName.length,
          });
        });
      }

      processTemplates({
        templates: branch.templates || [],
        validVariables,
        invalidVariables,
        variableSchema,
        localVariables,
      });
    }

    // Process else templates
    const elseTemplates = (template as any).elseTemplates || [];
    if (elseTemplates.length > 0) {
      processTemplates({
        templates: elseTemplates,
        validVariables,
        invalidVariables,
        variableSchema,
        localVariables,
      });
    }
  } else if (template instanceof AssignTag) {
    // Extract assigned variable from token content: {% assign myVar = value %} or {%- assign myVar = value -%}
    const assignMatch = output.match(/^\s*{%-?\s*assign\s+(\w+)\s*=\s*(.+?)\s*-?%}/);
    if (assignMatch) {
      const [, assignedVariable, valueExpression] = assignMatch;

      // Add to local variables BEFORE processing the value expression
      const newLocalVariables = new Set(localVariables);
      newLocalVariables.add(assignedVariable);

      // Extract variables from value expression
      const variables = extractVariablesFromCondition(valueExpression);
      variables.forEach((variableName) => {
        validateVariable({
          variableName,
          validVariables,
          invalidVariables,
          variableSchema,
          localVariables: newLocalVariables, // Use the new set with the assigned variable
          output,
          outputStart,
          outputEnd,
        });
      });

      // Update the original set
      localVariables.add(assignedVariable);
    }
  } else if (template instanceof CaptureTag) {
    // Extract captured variable: {% capture myVar %}...{% endcapture %}
    const captureMatch = output.match(/^\s*{%\s*capture\s+(\w+)\s*%}/);
    if (captureMatch) {
      const capturedVariable = captureMatch[1];

      // Add to local variables BEFORE processing the content
      const newLocalVariables = new Set(localVariables);
      newLocalVariables.add(capturedVariable);

      // Process captured content
      const templates = (template as any).templates || [];
      processTemplates({
        templates,
        validVariables,
        invalidVariables,
        variableSchema,
        localVariables: newLocalVariables,
      });

      // Update the original set
      localVariables.add(capturedVariable);
    }
  } else if (template instanceof TablerowTag) {
    // Similar to for loop - also needs range handling
    const tablerowMatch = output.match(/^\s*{%\s*tablerow\s+(\w+)\s+in\s+(.+?)\s*%}/);
    if (tablerowMatch) {
      const [, iteratorVariable, collectionExpression] = tablerowMatch;

      // Check if it's a range expression
      if (collectionExpression.trim().match(/^\(.+?\.\..+?\)$/)) {
        // Extract variables from range
        const rangeVariables = extractVariablesFromRange(collectionExpression.trim());
        rangeVariables.forEach((variableName) => {
          validateVariable({
            variableName,
            validVariables,
            invalidVariables,
            variableSchema,
            localVariables,
            output,
            outputStart,
            outputEnd,
          });
        });
      } else {
        // Extract collection variable (non-range)
        const collectionVariable = extractVariableFromExpression(collectionExpression);
        if (collectionVariable) {
          validateVariable({
            variableName: collectionVariable,
            validVariables,
            invalidVariables,
            variableSchema,
            localVariables,
            output,
            outputStart,
            outputEnd,
          });
        }
      }

      // Process nested templates with new local variables
      const newLocalVariables = new Set(localVariables);
      newLocalVariables.add(iteratorVariable);
      newLocalVariables.add('tablerowloop'); // Add tablerowloop built-in variable

      const templates = (template as any).templates || [];
      processTemplates({
        templates,
        validVariables,
        invalidVariables,
        variableSchema,
        localVariables: newLocalVariables,
      });
    }
  } else if (template instanceof CaseTag) {
    // Extract case variable: {% case variable %}
    const caseMatch = output.match(/^\s*{%\s*case\s+(.+?)\s*%}/);
    if (caseMatch) {
      const caseExpression = caseMatch[1];

      // Extract variables from the case expression
      const variables = extractVariablesFromCondition(caseExpression);
      variables.forEach((variableName) => {
        validateVariable({
          variableName,
          validVariables,
          invalidVariables,
          variableSchema,
          localVariables,
          output,
          outputStart,
          outputEnd,
        });
      });
    }

    // Process branches (when clauses)
    const branches = (template as any).branches || [];
    for (const branch of branches) {
      // Extract variables from when values if they exist
      if (branch.values) {
        branch.values.forEach((valueToken: any) => {
          // Check if the value token is a variable (not a literal)
          if (valueToken.kind === TokenKind.PropertyAccess || valueToken.kind === TokenKind.Word) {
            const variableName = valueToken.input.slice(valueToken.begin, valueToken.end).trim();
            if (variableName && /^[a-zA-Z_]/.test(variableName)) {
              // Ensure it starts with a letter
              validateVariable({
                variableName,
                validVariables,
                invalidVariables,
                variableSchema,
                localVariables,
                output: variableName,
                outputStart: valueToken.begin,
                outputEnd: valueToken.end,
              });
            }
          }
        });
      }

      // Process templates within this when branch
      processTemplates({
        templates: branch.templates || [],
        validVariables,
        invalidVariables,
        variableSchema,
        localVariables,
      });
    }

    // Process else templates
    const elseTemplates = (template as any).elseTemplates || [];
    if (elseTemplates.length > 0) {
      processTemplates({
        templates: elseTemplates,
        validVariables,
        invalidVariables,
        variableSchema,
        localVariables,
      });
    }
  }
  // Add more tag types as needed
}

function extractVariableFromOutput(output: string): string | null {
  const cleanOutput = output.trim().replace(/^{{/, '').replace(/}}$/, '');

  return extractVariableFromExpression(cleanOutput);
}

function extractVariableFromExpression(expression: string): string | null {
  // Remove filters if any (everything after |)
  const cleanExpression = expression.split('|')[0].trim();

  // Check for range syntax (start..end)
  const rangeMatch = cleanExpression.match(/^\((.+?)\.\.(.+?)\)$/);
  if (rangeMatch) {
    // This is a range, we'll handle it in extractVariablesFromRange
    return null;
  }

  // Match simple variable patterns
  const match = cleanExpression.match(/^([a-zA-Z_][a-zA-Z0-9_]*(?:\.[a-zA-Z_][a-zA-Z0-9_]*)*(?:\[\d+\])*)$/);

  return match ? match[1] : null;
}

function extractVariablesFromRange(rangeExpression: string): string[] {
  const variables: string[] = [];

  // Match range syntax (start..end)
  const rangeMatch = rangeExpression.match(/^\((.+?)\.\.(.+?)\)$/);
  if (rangeMatch) {
    const [, start, end] = rangeMatch;

    // Extract variables from start
    if (!/^\d+$/.test(start.trim())) {
      // Not a pure number
      const startVars = extractVariablesFromCondition(start);
      variables.push(...startVars);
    }

    // Extract variables from end
    if (!/^\d+$/.test(end.trim())) {
      // Not a pure number
      const endVars = extractVariablesFromCondition(end);
      variables.push(...endVars);
    }
  }

  return variables;
}

function extractVariablesFromCondition(condition: string): string[] {
  const variables: string[] = [];

  // First, temporarily replace string literals with placeholders to avoid matching their contents
  let processedCondition = condition;
  const stringLiterals: string[] = [];

  // Replace all string literals (both single and double quoted) with placeholders
  processedCondition = processedCondition.replace(/(["'])(?:(?=(\\?))\2.)*?\1/g, (match) => {
    stringLiterals.push(match);

    return `__STRING_LITERAL_${stringLiterals.length - 1}__`;
  });

  // Strip filter segments to avoid treating filter names as variables
  processedCondition = processedCondition.replace(/\|\s*[a-zA-Z_][a-zA-Z0-9_]*(?:\s*:[^|%}]*)?/g, '');

  // Now match variable patterns from the processed condition
  const variableMatches = processedCondition.match(/[a-zA-Z_][a-zA-Z0-9_[\].-]+/g);

  if (variableMatches) {
    variables.push(
      ...variableMatches.filter(
        (variable) =>
          // Filter out common keywords/operators
          ![
            'true',
            'false',
            'null',
            'nil',
            'and',
            'or',
            'not',
            'contains',
            'eq',
            'ne',
            'lt',
            'le',
            'gt',
            'ge',
          ].includes(variable.toLowerCase()) &&
          // Filter out our placeholder patterns
          !variable.startsWith('__STRING_LITERAL_')
      )
    );
  }

  return [...new Set(variables)]; // Remove duplicates
}

function isTagToken(template: Template): template is Tag {
  return template.token?.kind === TokenKind.Tag;
}

const buildVariable = (parts: string[]) => {
  if (parts.length === 0) return '';

  return parts.reduce((acc, prop, i) => {
    // if the prop is a number, preserve array notation (.[idx])
    if (typeof prop === 'number') {
      return `${acc}[${prop}]`;
    }

    return i === 0 ? prop : `${acc}.${prop}`;
  }, '');
};

function isOutputToken(template: Template): boolean {
  return template.token?.kind === TokenKind.Output;
}

function extractProps(template: any): { valid: boolean; props: string[]; error?: string } {
  const initial = template.value?.initial;

  // Handle case where there's no initial value
  if (!initial) {
    return { valid: true, props: [] };
  }

  // If it's a simple word without namespace
  if (initial.kind === TokenKind.Word && !initial.postfix?.length) {
    // Return the word as a single prop (no namespace)
    return {
      valid: true,
      props: [initial.content],
      error: undefined, // We'll handle namespace validation in processOutputToken
    };
  }

  if (!initial?.postfix?.[0]?.props) {
    // Single variable without properties
    if (initial.content) {
      return {
        valid: true,
        props: [initial.content],
        error: undefined,
      };
    }

    return { valid: true, props: [] };
  }

  /**
   * If initial.postfix length is greater than 1, it means the variable contains spaces
   * which is not supported in Novu's variable syntax.
   */
  if (initial.postfix.length > 1) {
    return {
      valid: false,
      props: [],
      error: `contains whitespaces`,
    };
  }

  const validProps: string[] = [];

  // Add the initial identifier/word
  if (initial.content) {
    validProps.push(initial.content);
  }

  for (const prop of initial.postfix[0].props) {
    validProps.push(prop.content);
  }

  return { valid: true, props: validProps };
}

function extractFilters(template: Template): Filter[] {
  if (template instanceof Output) {
    return template.value.filters;
  }

  return [];
}

function validateFilters(filters: Filter[], isDigestEventsVariable: boolean): LiquidFilterIssue[] {
  return filters.reduce((acc, filter) => {
    const validator = FILTER_VALIDATORS[filter.name];
    if (!validator) return acc;

    let args: unknown[] = [...filter.args];
    if (filter.name === 'toSentence') {
      args = [{ requireKeyPath: isDigestEventsVariable }, ...filter.args];
    }

    const filterIssues = validator(...args);

    return [...acc, ...filterIssues];
  }, [] as LiquidFilterIssue[]);
}

function extractVariablesFromValue(value: any): string[] {
  const variables: string[] = [];

  function processValue(val: any) {
    if (!val) return;

    // If it has an initial property, it's likely a variable reference
    if (val.initial) {
      const varName = buildVariableFromValue(val);
      if (varName) {
        variables.push(varName);
      }
    }

    // Process operands for binary expressions
    if (val.lhs) processValue(val.lhs);
    if (val.rhs) processValue(val.rhs);

    // Process array/object values
    if (Array.isArray(val)) {
      val.forEach(processValue);
    }
  }

  processValue(value);

  return variables;
}

function buildVariableFromValue(value: any): string | null {
  if (!value?.initial) return null;

  const parts: string[] = [];

  // Add initial content
  if (value.initial.content) {
    parts.push(value.initial.content);
  }

  // Add postfix properties
  if (value.initial.postfix?.[0]?.props) {
    for (const prop of value.initial.postfix[0].props) {
      parts.push(prop.content);
    }
  }

  return parts.length > 0 ? buildVariable(parts) : null;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - extractLiquidTemplateVariables({
  template,
  variableSchema,
  suggestPayloadNamespace = true,
}: {
  template: string;
  variableSchema?: JSONSchemaDto;
  suggestPayloadNamespace?: boolean;
})
 - processLiquidRawOutput({
  template,
  variableSchema,
  suggestPayloadNamespace = true,
}: {
  template: string;
  variableSchema?: JSONSchemaDto;
  suggestPayloadNamespace?: boolean;
})
 - addVariable(variable: Variable, isValid: boolean)
 - parseByLiquid({
  template,
  variableSchema,
  suggestPayloadNamespace = true,
}: {
  template: string;
  variableSchema?: JSONSchemaDto;
  suggestPayloadNamespace?: boolean;
})
 - processTemplates(context: ProcessContext)
 - isPropertyAllowed(schema: JSONSchemaDto | undefined, propertyPath: string)
 - validateVariable({
  variableName,
  validVariables,
  invalidVariables,
  variableSchema,
  localVariables,
  output,
  outputStart,
  outputEnd,
  suggestPayloadNamespace,
}: {
  variableName: string;
  validVariables: Array<Variable>;
  invalidVariables: Array<Variable>;
  variableSchema?: JSONSchemaDto;
  localVariables: Set<string>;
  output: string;
  outputStart: number;
  outputEnd: number;
  suggestPayloadNamespace?: boolean;
})
 - validateOutputToken({
  template,
  validVariables,
  invalidVariables,
  variableSchema,
  localVariables,
  suggestPayloadNamespace,
}: {
  template: Template;
  validVariables: Array<Variable>;
  invalidVariables: Array<Variable>;
  variableSchema?: JSONSchemaDto;
  localVariables: Set<string>;
  suggestPayloadNamespace?: boolean;
})
 - processTagToken({
  template,
  validVariables,
  invalidVariables,
  variableSchema,
  localVariables,
}: {
  template: Tag;
  validVariables: Array<Variable>;
  invalidVariables: Array<Variable>;
  variableSchema?: JSONSchemaDto;
  localVariables: Set<string>;
})
 - extractVariableFromOutput(output: string)
 - extractVariableFromExpression(expression: string)
 - extractVariablesFromRange(rangeExpression: string)
 - extractVariablesFromCondition(condition: string)
 - isTagToken(template: Template)
 - isOutputToken(template: Template)
 - extractProps(template: any)
 - extractFilters(template: Template)
 - validateFilters(filters: Filter[], isDigestEventsVariable: boolean)
 - extractVariablesFromValue(value: any)
 - processValue(val: any)
 - buildVariableFromValue(value: any)
Asignaciones con arrow functions encontradas (posibles funciones):
 - result(parseByLiquid({ template, variableSchema, suggestPayloadNamespace });
    result.validVariables.forE...)
 - pathParts(propertyPath.split('.').flatMap((part))
 - isLocalVariable(Array.from(localVariables).some(
    (localVar))
 - rangeVariables(extractVariablesFromRange(collectionExpression.trim());
        rangeVariables.forEach((variableName...)
 - variables(extractVariablesFromCondition(condition);

      variables.forEach((variableName))
 - branchVariables(extractVariablesFromValue(branch.value);
        branchVariables.forEach((variableName))
 - variables(extractVariablesFromCondition(valueExpression);
      variables.forEach((variableName))
 - rangeVariables(extractVariablesFromRange(collectionExpression.trim());
        rangeVariables.forEach((variableName...)
 - variables(extractVariablesFromCondition(caseExpression);
      variables.forEach((variableName))
 - branches(template as any).branches || [];
    for (const branch of branches) {
      // Extract variables fro...)
 - variableMatches(processedCondition.match(/[a-zA-Z_][a-zA-Z0-9_[\].-]+/g);

  if (variableMatches) {
    variables.pu...)
 - buildVariable(parts: string[]))
Declaraciones 'export' encontradas:
- export function extractLiquidTemplateVariables

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/utils/template-parser/parser-utils.spec.ts
Tamaño: 2396 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect } from 'chai';
import { extractLiquidExpressions, isValidTemplate } from './parser-utils';

describe('extractLiquidExpressions', () => {
  it('should extract simple liquid expressions', () => {
    const template = '{{name}} {{age}}';
    const expressions = extractLiquidExpressions(template);

    expect(expressions).to.deep.equal(['{{name}}', '{{age}}']);
  });

  it('should handle expressions with filters', () => {
    const template = '{{name | upcase}} {{age | plus: 1}}';
    const expressions = extractLiquidExpressions(template);

    expect(expressions).to.deep.equal(['{{name | upcase}}', '{{age | plus: 1}}']);
  });

  it('should handle expressions with whitespace', () => {
    const template = '{{ name   }} {{   age    }}';
    const expressions = extractLiquidExpressions(template);

    expect(expressions).to.deep.equal(['{{ name   }}', '{{   age    }}']);
  });

  it('should handle expressions in HTML context', () => {
    const template = '<div>{{name}}</div><span>{{age}}</span>';
    const expressions = extractLiquidExpressions(template);

    expect(expressions).to.deep.equal(['{{name}}', '{{age}}']);
  });

  it('should return empty array for invalid inputs', () => {
    expect(extractLiquidExpressions('')).to.deep.equal([]);
    expect(extractLiquidExpressions(null as any)).to.deep.equal([]);
    expect(extractLiquidExpressions(undefined as any)).to.deep.equal([]);
    expect(extractLiquidExpressions('no expressions here')).to.deep.equal([]);
  });

  it('should handle expressions with nested properties', () => {
    const template = '{{user.name}} {{address.street.number}}';
    const expressions = extractLiquidExpressions(template);

    expect(expressions).to.deep.equal(['{{user.name}}', '{{address.street.number}}']);
  });
});

describe('isValidTemplate', () => {
  it('should return true for non-empty strings', () => {
    expect(isValidTemplate('test')).to.be.true;
    expect(isValidTemplate(' ')).to.be.true;
  });

  it('should return false for empty strings', () => {
    expect(isValidTemplate('')).to.be.false;
  });

  it('should return false for non-string values', () => {
    expect(isValidTemplate(null)).to.be.false;
    expect(isValidTemplate(undefined)).to.be.false;
    expect(isValidTemplate(123)).to.be.false;
    expect(isValidTemplate({})).to.be.false;
    expect(isValidTemplate([])).to.be.false;
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - expressions(extractLiquidExpressions(template);

    expect(expressions).to.deep.equal(['{{name}}', '{{age}}']);...)
 - expressions(extractLiquidExpressions(template);

    expect(expressions).to.deep.equal(['{{name | upcase}}', '{{...)
 - expressions(extractLiquidExpressions(template);

    expect(expressions).to.deep.equal(['{{ name   }}', '{{   ag...)
 - expressions(extractLiquidExpressions(template);

    expect(expressions).to.deep.equal(['{{name}}', '{{age}}']);...)
 - expressions(extractLiquidExpressions(template);

    expect(expressions).to.deep.equal(['{{user.name}}', '{{addr...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/utils/template-parser/parser-utils.ts
Tamaño: 1313 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { LiquidError } from 'liquidjs';
import { LiquidErrors } from './types';

/**
 * Validates if the provided template is a non-empty string
 */
export function isValidTemplate(template: unknown): template is string {
  return typeof template === 'string' && template.length > 0;
}

/**
 * Extracts all Liquid expressions wrapped in {{ }} from a given string
 * @example
 * "{{ username | append: 'hi' }}" => ["{{ username | append: 'hi' }}"]
 * "<input value='{{username}}'>" => ["{{username}}"]
 */
export function extractLiquidExpressions(str: string): string[] {
  if (!str) return [];

  const LIQUID_EXPRESSION_PATTERN = /{{\s*[^{}]*}}/g;

  return str.match(LIQUID_EXPRESSION_PATTERN) || [];
}

export const DIGEST_EVENTS_VARIABLE_PATTERN = /^steps\.[^.]+\.events$/;
export const VALID_DYNAMIC_PATHS = [
  'subscriber.data.',
  'payload.',
  'context.',
  /^steps\.[^.]+\.events\[\d+\]\.payload\./,
] as const;

export function isValidDynamicPath(variableName: string): boolean {
  return VALID_DYNAMIC_PATHS.some((path) =>
    typeof path === 'string' ? variableName.startsWith(path) : path.test(variableName)
  );
}

export function isLiquidErrors(error: unknown): error is LiquidErrors {
  return error instanceof LiquidError && 'errors' in error && Array.isArray((error as LiquidErrors).errors);
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - isValidTemplate(template: unknown)
 - extractLiquidExpressions(str: string)
 - isValidDynamicPath(variableName: string)
 - isLiquidErrors(error: unknown)
Asignaciones con arrow functions encontradas (posibles funciones):
 - value('{{username}}'>")
 - VALID_DYNAMIC_PATHS([
  'subscriber.data.',
  'payload.',
  'context.',
  /^steps\.[^.]+\.events\[\d+\]\.payload\./,
] a...)
Declaraciones 'export' encontradas:
- export function isValidTemplate
- export function extractLiquidExpressions
- export  const
- export  const
- export function isValidDynamicPath
- export function isLiquidErrors

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/utils/template-parser/types.ts
Tamaño: 1489 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { LiquidError, RenderError, Template } from 'liquidjs';
import { JSONSchemaDto } from '../../dtos/json-schema.dto';

export type Variable = {
  /**
   * The variable name/path (e.g. for valid variables "user.name",
   * for invalid variables will fallback to output "{{user.name | upcase}}")
   */
  name: string;

  /** The surrounding context where the variable was found, useful for error messages */
  context?: string;

  /** Error message if the variable is invalid */
  message?: string;

  /** Error message if the variable filter is invalid */
  filterMessage?: string;

  /** The full liquid output string (e.g. "{{user.name | upcase}}") */
  output: string;

  /** The start index of the output */
  outputStart: number;

  /** The end index of the output */
  outputEnd: number;
};

export type VariableDetails = {
  validVariables: Array<Variable>;
  invalidVariables: Array<Variable>;
};

/**
 * Copy of LiquidErrors type from liquidjs since it's not exported.
 * Used to handle multiple render errors that can occur during template parsing.
 * @see https://github.com/harttle/liquidjs/blob/d61855bf725a6deba203201357f7455f6f9b4a32/src/util/error.ts#L65
 */
export class LiquidErrors extends LiquidError {
  errors: RenderError[];
}

export type ProcessContext = {
  templates: Template[];
  validVariables: Array<Variable>;
  invalidVariables: Array<Variable>;
  variableSchema?: JSONSchemaDto;
  localVariables?: Set<string>;
  suggestPayloadNamespace?: boolean;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export  type
- export class LiquidErrors
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/validators/image.validator.ts
Tamaño: 684 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { registerDecorator, ValidationArguments, ValidationOptions } from 'class-validator';

export function IsImageUrl(validationOptions?: ValidationOptions) {
  return (object: object, propertyName: string) => {
    registerDecorator({
      name: 'isImageUrl',
      target: object.constructor,
      propertyName,
      options: validationOptions,
      validator: {
        validate(value: any, args: ValidationArguments) {
          const validExtensions = ['jpg', 'jpeg', 'png', 'gif', 'svg'];
          const extension = value.split('.').pop();
          if (!extension) return false;

          return validExtensions.includes(extension);
        },
      },
    });
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - IsImageUrl(validationOptions?: ValidationOptions)
Declaraciones 'export' encontradas:
- export function IsImageUrl

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/validators/is-enum-or-array.ts
Tamaño: 744 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { registerDecorator, ValidationArguments, ValidationOptions } from 'class-validator';

export function IsEnumOrArray(enumObj: object, options?: ValidationOptions) {
  return (object: unknown, propertyName: string) => {
    registerDecorator({
      name: 'isEnumOrArray',
      target: (object as any).constructor,
      propertyName,
      constraints: [enumObj],
      options,
      validator: {
        validate(value: any, args: ValidationArguments) {
          const allowed = Object.values(args.constraints[0] as object);
          if (value === undefined || value === null) return true;
          return Array.isArray(value) ? value.every((v) => allowed.includes(v)) : allowed.includes(value);
        },
      },
    });
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - IsEnumOrArray(enumObj: object, options?: ValidationOptions)
Declaraciones 'export' encontradas:
- export function IsEnumOrArray

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/validators/is-time-12-hour-format.validator.ts
Tamaño: 984 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { registerDecorator, ValidationArguments, ValidationOptions } from 'class-validator';

export function IsTime12HourFormat(validationOptions?: ValidationOptions) {
  return (object: any, propertyName: string) => {
    registerDecorator({
      name: 'isTime12HourFormat',
      target: object.constructor,
      propertyName,
      options: validationOptions,
      validator: {
        validate(value: unknown) {
          if (typeof value !== 'string') {
            return false;
          }

          // Regex pattern for 12-hour format: HH:MM AM/PM
          // Accepts: 01:00 AM through 12:59 PM
          // With optional leading zero: 1:00 AM or 01:00 AM
          const time12HourRegex = /^(0?[1-9]|1[0-2]):[0-5][0-9]\s?(AM|PM)$/i;

          return time12HourRegex.test(value);
        },
        defaultMessage(args: ValidationArguments) {
          return `${args.property} must be in 12-hour format (e.g., 09:00 AM or 9:00 AM)`;
        },
      },
    });
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - IsTime12HourFormat(validationOptions?: ValidationOptions)
Declaraciones 'export' encontradas:
- export function IsTime12HourFormat

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/validators/json-schema.validator.ts
Tamaño: 1106 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import Ajv from 'ajv';
import addFormats from 'ajv-formats';
import { registerDecorator, ValidationArguments, ValidationOptions } from 'class-validator';

export function IsValidJsonSchema(validationOptions?: ValidationOptions & { nullable?: boolean }) {
  return (object: object, propertyName: string) => {
    registerDecorator({
      name: 'isValidJsonSchema',
      target: object.constructor,
      propertyName,
      options: validationOptions,
      validator: {
        validate(value: any, args: ValidationArguments) {
          if (!value || typeof value !== 'object') {
            if (validationOptions?.nullable && !value) {
              return true;
            }

            return false;
          }

          try {
            const ajv = new Ajv({ strict: false });
            addFormats(ajv);

            ajv.compile(value);

            return true;
          } catch (error) {
            return false;
          }
        },
        defaultMessage(args: ValidationArguments) {
          return `${args.property} must be a valid JSON schema`;
        },
      },
    });
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - IsValidJsonSchema(validationOptions?: ValidationOptions & { nullable?: boolean })
Declaraciones 'export' encontradas:
- export function IsValidJsonSchema

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/validators/resource-key.validator.ts
Tamaño: 748 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

// libs/nest-validators/is-resource-key.decorator.ts

import { isResourceKey } from '@novu/shared';
import {
  registerDecorator,
  ValidationOptions,
  ValidatorConstraint,
  ValidatorConstraintInterface,
} from 'class-validator';

@ValidatorConstraint({ name: 'IsResourceKey', async: false })
export class IsResourceKeyConstraint implements ValidatorConstraintInterface {
  validate(value: any) {
    return isResourceKey(value);
  }
  defaultMessage() {
    return 'resource must be "<type>:<id>" where type ∈ {subscriber}';
  }
}

export const IsResourceKey = (opts?: ValidationOptions) => (obj: object, prop: string) =>
  registerDecorator({ target: obj.constructor, propertyName: prop, options: opts, validator: IsResourceKeyConstraint });


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - IsResourceKey(opts?: ValidationOptions))
Declaraciones 'export' encontradas:
- export class IsResourceKeyConstraint
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/shared/validators/weekly-schedule-disabled.validator.ts
Tamaño: 1713 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { registerDecorator, ValidationArguments, ValidationOptions } from 'class-validator';

const weekdays = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];

export function WeeklyScheduleValidation(validationOptions?: ValidationOptions) {
  return (object: object, propertyName: string) => {
    registerDecorator({
      name: 'weeklyScheduleDisabled',
      target: object.constructor,
      propertyName,
      options: validationOptions,
      validator: {
        validate(value: unknown, args: ValidationArguments) {
          const obj = args.object as { isEnabled?: boolean };

          if (obj.isEnabled === true && value && Object.keys(value).length === 0) {
            return false;
          }
          if (obj.isEnabled === true && value && Object.keys(value).some((key) => !weekdays.includes(key))) {
            return false;
          }

          return true;
        },
        defaultMessage(args: ValidationArguments) {
          const obj = args.object as { isEnabled?: boolean };
          const value = args.value;

          if (obj.isEnabled === true && value && Object.keys(value).length === 0) {
            return 'weeklySchedule must contain at least one day configuration when isEnabled is true';
          }

          if (obj.isEnabled === true && value && Object.keys(value).some((key) => !weekdays.includes(key))) {
            const invalidKeys = Object.keys(value).filter((key) => !weekdays.includes(key));
            return `weeklySchedule contains invalid day names: ${invalidKeys.join(', ')}. Valid days are: ${weekdays.join(', ')}`;
          }

          return 'weeklySchedule validation failed';
        },
      },
    });
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - WeeklyScheduleValidation(validationOptions?: ValidationOptions)
Asignaciones con arrow functions encontradas (posibles funciones):
 - weekdays(['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];

export function Wee...)
 - invalidKeys(Object.keys(value).filter((key))
Declaraciones 'export' encontradas:
- export function WeeklyScheduleValidation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/storage/storage.controller.ts
Tamaño: 1667 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ClassSerializerInterceptor, Controller, Get, Query, UseInterceptors } from '@nestjs/common';
import { ApiExcludeController, ApiOperation, ApiTags } from '@nestjs/swagger';
import { UploadTypesEnum, UserSessionData } from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { ExternalApiAccessible } from '../auth/framework/external-api.decorator';
import { ApiCommonResponses, ApiResponse } from '../shared/framework/response.decorator';
import { UserSession } from '../shared/framework/user.decorator';
import { UploadUrlResponse } from './dtos/upload-url-response.dto';
import { GetSignedUrlCommand } from './usecases/get-signed-url/get-signed-url.command';
import { GetSignedUrl } from './usecases/get-signed-url/get-signed-url.usecase';

@ApiCommonResponses()
@Controller('/storage')
@ApiTags('Storage')
@UseInterceptors(ClassSerializerInterceptor)
@RequireAuthentication()
@ApiExcludeController()
export class StorageController {
  constructor(private getSignedUrlUsecase: GetSignedUrl) {}

  @Get('/upload-url')
  @ApiOperation({
    summary: 'Get upload url',
  })
  @ApiResponse(UploadUrlResponse)
  @ExternalApiAccessible()
  async signedUrl(
    @UserSession() user: UserSessionData,
    @Query('extension') extension: string,
    @Query('type') type: string
  ): Promise<UploadUrlResponse> {
    return await this.getSignedUrlUsecase.execute(
      GetSignedUrlCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
        extension,
        type: (type as UploadTypesEnum) || UploadTypesEnum.BRANDING,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class StorageController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/storage/storage.module.ts
Tamaño: 331 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Module } from '@nestjs/common';
import { SharedModule } from '../shared/shared.module';
import { StorageController } from './storage.controller';
import { USE_CASES } from './usecases';

@Module({
  imports: [SharedModule],
  providers: [...USE_CASES],
  controllers: [StorageController],
})
export class StorageModule {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class StorageModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/storage/dtos/upload-url-response.dto.ts
Tamaño: 154 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';

export class UploadUrlResponse {
  @ApiProperty()
  signedUrl: string;
  @ApiProperty()
  path: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UploadUrlResponse

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/storage/e2e/get-signed-url.e2e.ts
Tamaño: 638 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Get Signed Url - /storage/upload-url (GET) #novu-v0', () => {
  let session: UserSession;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should return an S3 signed URL', async () => {
    const {
      body: { data },
    } = await session.testAgent.get('/v1/storage/upload-url?extension=jpg');

    expect(data.path).to.contain('.jpg');
    expect(data.signedUrl).to.contain('.jpg');
    expect(data.signedUrl).to.contain(`${session.organization._id}/${session.environment._id}`);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
    await session.initialize();
  });

  it('should return an S3 signed URL', asy...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/storage/usecases/index.ts
Tamaño: 114 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { GetSignedUrl } from './get-signed-url/get-signed-url.usecase';

export const USE_CASES = [GetSignedUrl];


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/storage/usecases/get-signed-url/get-signed-url.command.ts
Tamaño: 413 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UploadTypesEnum } from '@novu/shared';
import { IsDefined, IsEnum, IsIn, IsString } from 'class-validator';

import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class GetSignedUrlCommand extends EnvironmentWithUserCommand {
  @IsString()
  @IsIn(['jpg', 'png', 'jpeg'])
  extension: string;

  @IsDefined()
  @IsEnum(UploadTypesEnum)
  type: UploadTypesEnum;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetSignedUrlCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/storage/usecases/get-signed-url/get-signed-url.usecase.ts
Tamaño: 1154 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { StorageService } from '@novu/application-generic';
import { FILE_EXTENSION_TO_MIME_TYPE, UploadTypesEnum } from '@novu/shared';
import { randomBytes } from 'crypto';

import { UploadUrlResponse } from '../../dtos/upload-url-response.dto';
import { GetSignedUrlCommand } from './get-signed-url.command';

@Injectable()
export class GetSignedUrl {
  constructor(private storageService: StorageService) {}

  private mapTypeToPath(command: GetSignedUrlCommand) {
    const randomId = randomBytes(16).toString('hex');
    switch (command.type) {
      case UploadTypesEnum.USER_PROFILE:
        return `users/${command.userId}/profile-pictures/${randomId}.${command.extension}`;
      case UploadTypesEnum.BRANDING:
      default:
        return `${command.organizationId}/${command.environmentId}/${randomId}.${command.extension}`;
    }
  }

  async execute(command: GetSignedUrlCommand): Promise<UploadUrlResponse> {
    const response = await this.storageService.getSignedUrl(
      this.mapTypeToPath(command),
      FILE_EXTENSION_TO_MIME_TYPE[command.extension]
    );

    return response;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetSignedUrl

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/channel-connections.controller.ts
Tamaño: 9064 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  Body,
  ClassSerializerInterceptor,
  Controller,
  Delete,
  Get,
  HttpCode,
  NotFoundException,
  Param,
  Patch,
  Post,
  Query,
  UseInterceptors,
} from '@nestjs/common';
import { ApiExcludeController, ApiOperation, ApiParam, ApiTags } from '@nestjs/swagger';
import { FeatureFlagsService, RequirePermissions } from '@novu/application-generic';
import {
  ApiRateLimitCategoryEnum,
  FeatureFlagsKeysEnum,
  makeResourceKey,
  PermissionsEnum,
  RESOURCE,
  UserSessionData,
} from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { CreateChannelConnectionRequestDto } from '../channel-connections/dtos/create-channel-connection-request.dto';
import { mapChannelConnectionEntityToDto } from '../channel-connections/dtos/dto.mapper';
import { GetChannelConnectionResponseDto } from '../channel-connections/dtos/get-channel-connection-response.dto';
import { GetChannelConnectionsQueryDto } from '../channel-connections/dtos/get-channel-connections-query.dto';
import { UpdateChannelConnectionRequestDto } from '../channel-connections/dtos/update-channel-connection-request.dto';
import { CreateChannelConnectionCommand } from '../channel-connections/usecases/create-channel-connection/create-channel-connection.command';
import { CreateChannelConnection } from '../channel-connections/usecases/create-channel-connection/create-channel-connection.usecase';
import { DeleteChannelConnectionCommand } from '../channel-connections/usecases/delete-channel-connection/delete-channel-connection.command';
import { DeleteChannelConnection } from '../channel-connections/usecases/delete-channel-connection/delete-channel-connection.usecase';
import { GetChannelConnectionCommand } from '../channel-connections/usecases/get-channel-connection/get-channel-connection.command';
import { GetChannelConnection } from '../channel-connections/usecases/get-channel-connection/get-channel-connection.usecase';
import { GetChannelConnectionsCommand } from '../channel-connections/usecases/get-channel-connections/get-channel-connections.command';
import { GetChannelConnections } from '../channel-connections/usecases/get-channel-connections/get-channel-connections.usecase';
import { UpdateChannelConnectionCommand } from '../channel-connections/usecases/update-channel-connection/update-channel-connection.command';
import { UpdateChannelConnection } from '../channel-connections/usecases/update-channel-connection/update-channel-connection.usecase';
import { ThrottlerCategory } from '../rate-limiting/guards/throttler.decorator';
import { ApiCommonResponses, ApiResponse } from '../shared/framework/response.decorator';
import { UserSession } from '../shared/framework/user.decorator';

@ThrottlerCategory(ApiRateLimitCategoryEnum.CONFIGURATION)
@Controller({ path: '/subscribers', version: '2' })
@UseInterceptors(ClassSerializerInterceptor)
@ApiExcludeController()
@ApiTags('Channel Connections')
@ApiCommonResponses()
export class ChannelConnectionsController {
  constructor(
    private readonly getChannelConnectionUsecase: GetChannelConnection,
    private readonly createChannelConnectionUsecase: CreateChannelConnection,
    private readonly updateChannelConnectionUsecase: UpdateChannelConnection,
    private readonly deleteChannelConnectionUsecase: DeleteChannelConnection,
    private readonly featureFlagsService: FeatureFlagsService,
    private readonly getChannelConnectionsUsecase: GetChannelConnections
  ) {}

  private async checkFeatureEnabled(user: UserSessionData) {
    const isEnabled = await this.featureFlagsService.getFlag({
      key: FeatureFlagsKeysEnum.IS_SLACK_TEAMS_ENABLED,
      defaultValue: false,
      organization: { _id: user.organizationId },
    });

    if (!isEnabled) {
      throw new NotFoundException('Feature not enabled');
    }
  }

  @Get('/:subscriberId/channel-connections/:integrationIdentifier')
  @ApiOperation({
    summary: 'Retrieve channel connection for a subscriber for given integration',
    description: `Retrieve a channel connection belonging to a subscriber for given integration.`,
  })
  @ApiResponse(GetChannelConnectionResponseDto, 200)
  @RequirePermissions(PermissionsEnum.SUBSCRIBER_READ)
  @RequireAuthentication()
  async getChannelConnection(
    @UserSession() user: UserSessionData,
    @Param('subscriberId') subscriberId: string,
    @Param('integrationIdentifier') integrationIdentifier: string
  ): Promise<GetChannelConnectionResponseDto> {
    await this.checkFeatureEnabled(user);

    const channelConnection = await this.getChannelConnectionUsecase.execute(
      GetChannelConnectionCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        resource: makeResourceKey(RESOURCE.SUBSCRIBER, subscriberId),
        integrationIdentifier,
      })
    );

    return mapChannelConnectionEntityToDto(channelConnection);
  }

  @Get('/:subscriberId/channel-connections')
  @ApiOperation({
    summary: 'Retrieve channel connections for a subscriber',
    description: `Retrieve all channel connections for a subscriber.`,
  })
  @ApiResponse(GetChannelConnectionResponseDto, 200)
  @RequirePermissions(PermissionsEnum.SUBSCRIBER_READ)
  @RequireAuthentication()
  async getChannelConnections(
    @UserSession() user: UserSessionData,
    @Param('subscriberId') subscriberId: string,
    @Query() query: GetChannelConnectionsQueryDto
  ): Promise<GetChannelConnectionResponseDto[]> {
    await this.checkFeatureEnabled(user);

    const channelConnections = await this.getChannelConnectionsUsecase.execute(
      GetChannelConnectionsCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        resource: makeResourceKey(RESOURCE.SUBSCRIBER, subscriberId),
        channel: query.channel,
        provider: query.provider,
      })
    );

    return channelConnections.map((connection) => mapChannelConnectionEntityToDto(connection));
  }

  @Post('/:subscriberId/channel-connections')
  @ApiOperation({
    summary: 'Create channel connection for a subscriber for given integration',
    description: `Create a new channel connection for a subscriber for given integration.`,
  })
  @ApiResponse(GetChannelConnectionResponseDto, 201)
  @RequirePermissions(PermissionsEnum.SUBSCRIBER_WRITE)
  @RequireAuthentication()
  async createChannelConnection(
    @UserSession() user: UserSessionData,
    @Param('subscriberId') subscriberId: string,
    @Body() body: CreateChannelConnectionRequestDto
  ): Promise<GetChannelConnectionResponseDto> {
    await this.checkFeatureEnabled(user);

    const channelConnection = await this.createChannelConnectionUsecase.execute(
      CreateChannelConnectionCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        identifier: body.identifier,
        integrationIdentifier: body.integrationIdentifier,
        resource: makeResourceKey(RESOURCE.SUBSCRIBER, subscriberId),
        workspace: body.workspace,
        auth: body.auth,
      })
    );

    return mapChannelConnectionEntityToDto(channelConnection);
  }

  @Patch('channel-connections/:identifier')
  @ApiOperation({
    summary: 'Update channel connection',
    description: `Update an existing channel connection by its unique identifier.`,
  })
  @ApiParam({ name: 'identifier', description: 'The unique identifier of the channel connection', type: String })
  @ApiResponse(GetChannelConnectionResponseDto, 200)
  @RequirePermissions(PermissionsEnum.SUBSCRIBER_WRITE)
  @RequireAuthentication()
  async updateChannelConnection(
    @UserSession() user: UserSessionData,
    @Param('identifier') identifier: string,
    @Body() body: UpdateChannelConnectionRequestDto
  ): Promise<GetChannelConnectionResponseDto> {
    await this.checkFeatureEnabled(user);

    const channelConnection = await this.updateChannelConnectionUsecase.execute(
      UpdateChannelConnectionCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        identifier,
        workspace: body.workspace,
        auth: body.auth,
      })
    );

    return mapChannelConnectionEntityToDto(channelConnection);
  }

  @Delete('channel-connections/:identifier')
  @HttpCode(204)
  @ApiOperation({
    summary: 'Delete channel connection',
    description: `Delete a specific channel connection by its unique identifier.`,
  })
  @ApiParam({ name: 'identifier', description: 'The unique identifier of the channel connection', type: String })
  @RequirePermissions(PermissionsEnum.SUBSCRIBER_WRITE)
  @RequireAuthentication()
  async deleteChannelConnection(
    @UserSession() user: UserSessionData,
    @Param('identifier') identifier: string
  ): Promise<void> {
    await this.checkFeatureEnabled(user);

    await this.deleteChannelConnectionUsecase.execute(
      DeleteChannelConnectionCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        identifier,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - channelConnections(await this.getChannelConnectionsUsecase.execute(
      GetChannelConnectionsCommand.create({
       ...)
Declaraciones 'export' encontradas:
- export class ChannelConnectionsController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/channel-endpoints.controller.ts
Tamaño: 8687 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  Body,
  ClassSerializerInterceptor,
  Controller,
  Delete,
  Get,
  HttpCode,
  NotFoundException,
  Param,
  Patch,
  Post,
  Query,
  UseInterceptors,
} from '@nestjs/common';
import { ApiExcludeController, ApiOperation, ApiParam, ApiTags } from '@nestjs/swagger';
import { FeatureFlagsService, RequirePermissions } from '@novu/application-generic';
import {
  ApiRateLimitCategoryEnum,
  FeatureFlagsKeysEnum,
  makeResourceKey,
  PermissionsEnum,
  RESOURCE,
  UserSessionData,
} from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { CreateChannelEndpointRequestDto } from '../channel-endpoints/dtos/create-channel-endpoint-request.dto';
import { mapChannelEndpointEntityToDto } from '../channel-endpoints/dtos/dto.mapper';
import { GetChannelEndpointResponseDto } from '../channel-endpoints/dtos/get-channel-endpoint-response.dto';
import { GetChannelEndpointsQueryDto } from '../channel-endpoints/dtos/get-channel-endpoints-query.dto';
import { UpdateChannelEndpointRequestDto } from '../channel-endpoints/dtos/update-channel-endpoint-request.dto';
import { CreateChannelEndpointCommand } from '../channel-endpoints/usecases/create-channel-endpoint/create-channel-endpoint.command';
import { CreateChannelEndpoint } from '../channel-endpoints/usecases/create-channel-endpoint/create-channel-endpoint.usecase';
import { DeleteChannelEndpointCommand } from '../channel-endpoints/usecases/delete-channel-endpoint/delete-channel-endpoint.command';
import { DeleteChannelEndpoint } from '../channel-endpoints/usecases/delete-channel-endpoint/delete-channel-endpoint.usecase';
import { GetChannelEndpointCommand } from '../channel-endpoints/usecases/get-channel-endpoint/get-channel-endpoint.command';
import { GetChannelEndpoint } from '../channel-endpoints/usecases/get-channel-endpoint/get-channel-endpoint.usecase';
import { GetChannelEndpointsCommand } from '../channel-endpoints/usecases/get-channel-endpoints/get-channel-endpoints.command';
import { GetChannelEndpoints } from '../channel-endpoints/usecases/get-channel-endpoints/get-channel-endpoints.usecase';
import { UpdateChannelEndpointCommand } from '../channel-endpoints/usecases/update-channel-endpoint/update-channel-endpoint.command';
import { UpdateChannelEndpoint } from '../channel-endpoints/usecases/update-channel-endpoint/update-channel-endpoint.usecase';
import { ThrottlerCategory } from '../rate-limiting/guards/throttler.decorator';
import { ApiCommonResponses, ApiResponse } from '../shared/framework/response.decorator';
import { UserSession } from '../shared/framework/user.decorator';

@ThrottlerCategory(ApiRateLimitCategoryEnum.CONFIGURATION)
@Controller({ path: '/subscribers', version: '2' })
@UseInterceptors(ClassSerializerInterceptor)
@ApiExcludeController()
@ApiTags('Channel Endpoints')
@ApiCommonResponses()
export class ChannelEndpointsController {
  constructor(
    private readonly getChannelEndpointsUsecase: GetChannelEndpoints,
    private readonly getChannelEndpointUsecase: GetChannelEndpoint,
    private readonly createChannelEndpointUsecase: CreateChannelEndpoint,
    private readonly updateChannelEndpointUsecase: UpdateChannelEndpoint,
    private readonly deleteChannelEndpointUsecase: DeleteChannelEndpoint,
    private readonly featureFlagsService: FeatureFlagsService
  ) {}

  private async checkFeatureEnabled(user: UserSessionData) {
    const isEnabled = await this.featureFlagsService.getFlag({
      key: FeatureFlagsKeysEnum.IS_SLACK_TEAMS_ENABLED,
      defaultValue: false,
      organization: { _id: user.organizationId },
    });

    if (!isEnabled) {
      throw new NotFoundException('Feature not enabled');
    }
  }

  @Get('/:subscriberId/channel-endpoints')
  @ApiOperation({
    summary: 'Retrieve channel endpoints',
    description: `Retrieve all channel endpoints based on query filters.`,
  })
  @ApiResponse(GetChannelEndpointResponseDto, 200, true)
  @RequirePermissions(PermissionsEnum.SUBSCRIBER_READ)
  @RequireAuthentication()
  async getChannelEndpoints(
    @UserSession() user: UserSessionData,
    @Param('subscriberId') subscriberId: string,
    @Query() query: GetChannelEndpointsQueryDto
  ): Promise<GetChannelEndpointResponseDto[]> {
    await this.checkFeatureEnabled(user);

    const channelEndpoints = await this.getChannelEndpointsUsecase.execute(
      GetChannelEndpointsCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        resource: makeResourceKey(RESOURCE.SUBSCRIBER, subscriberId),
        channel: query.channel,
        provider: query.provider,
        type: query.type,
      })
    );

    return channelEndpoints.map((endpoint) => mapChannelEndpointEntityToDto(endpoint));
  }

  @Get('/channel-endpoints/:identifier')
  @ApiOperation({
    summary: 'Retrieve channel endpoint by identifier',
    description: `Retrieve a specific channel endpoint by its unique identifier.`,
  })
  @ApiParam({ name: 'identifier', description: 'The unique identifier of the channel endpoint', type: String })
  @ApiResponse(GetChannelEndpointResponseDto, 200)
  @RequirePermissions(PermissionsEnum.SUBSCRIBER_READ)
  @RequireAuthentication()
  async getChannelEndpoint(
    @UserSession() user: UserSessionData,
    @Param('identifier') identifier: string
  ): Promise<GetChannelEndpointResponseDto> {
    await this.checkFeatureEnabled(user);

    const channelEndpoint = await this.getChannelEndpointUsecase.execute(
      GetChannelEndpointCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        identifier,
      })
    );

    return mapChannelEndpointEntityToDto(channelEndpoint);
  }

  @Post('/:subscriberId/channel-endpoints')
  @ApiOperation({
    summary: 'Create channel endpoint',
    description: `Create a new channel endpoint.`,
  })
  @ApiResponse(GetChannelEndpointResponseDto, 201)
  @RequirePermissions(PermissionsEnum.SUBSCRIBER_WRITE)
  @RequireAuthentication()
  async createChannelEndpoint(
    @UserSession() user: UserSessionData,
    @Param('subscriberId') subscriberId: string,
    @Body() body: CreateChannelEndpointRequestDto
  ): Promise<GetChannelEndpointResponseDto> {
    await this.checkFeatureEnabled(user);

    const channelEndpoint = await this.createChannelEndpointUsecase.execute(
      CreateChannelEndpointCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        identifier: body.identifier,
        integrationIdentifier: body.integrationIdentifier,
        connectionIdentifier: body.connectionIdentifier,
        resource: makeResourceKey(RESOURCE.SUBSCRIBER, subscriberId),
        type: body.type,
        endpoint: body.endpoint,
      })
    );

    return mapChannelEndpointEntityToDto(channelEndpoint);
  }

  @Patch('/channel-endpoints/:identifier')
  @ApiOperation({
    summary: 'Update channel endpoint',
    description: `Update an existing channel endpoint by its unique identifier.`,
  })
  @ApiParam({ name: 'identifier', description: 'The unique identifier of the channel endpoint', type: String })
  @ApiResponse(GetChannelEndpointResponseDto, 200)
  @RequirePermissions(PermissionsEnum.SUBSCRIBER_WRITE)
  @RequireAuthentication()
  async updateChannelEndpoint(
    @UserSession() user: UserSessionData,
    @Param('identifier') identifier: string,
    @Body() body: UpdateChannelEndpointRequestDto
  ): Promise<GetChannelEndpointResponseDto> {
    await this.checkFeatureEnabled(user);

    const channelEndpoint = await this.updateChannelEndpointUsecase.execute(
      UpdateChannelEndpointCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        identifier,
        endpoint: body.endpoint,
      })
    );

    return mapChannelEndpointEntityToDto(channelEndpoint);
  }

  @Delete('/channel-endpoints/:identifier')
  @HttpCode(204)
  @ApiOperation({
    summary: 'Delete channel endpoint',
    description: `Delete a specific channel endpoint by its unique identifier.`,
  })
  @ApiParam({ name: 'identifier', description: 'The unique identifier of the channel endpoint', type: String })
  @RequirePermissions(PermissionsEnum.SUBSCRIBER_WRITE)
  @RequireAuthentication()
  async deleteChannelEndpoint(
    @UserSession() user: UserSessionData,
    @Param('identifier') identifier: string
  ): Promise<void> {
    await this.checkFeatureEnabled(user);

    await this.deleteChannelEndpointUsecase.execute(
      DeleteChannelEndpointCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        identifier,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - channelEndpoints(await this.getChannelEndpointsUsecase.execute(
      GetChannelEndpointsCommand.create({
        env...)
Declaraciones 'export' encontradas:
- export class ChannelEndpointsController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/subscribers.controller.e2e.ts
Tamaño: 13984 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { SubscriberResponseDto } from '@novu/api/models/components';
import { OrderDirection } from '@novu/api/models/operations';
import { SubscribersControllerSearchSubscribersRequest } from '@novu/api/src/models/operations';
import { SubscriberRepository } from '@novu/dal';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { randomBytes } from 'crypto';
import { initNovuClassSdk } from '../shared/helpers/e2e/sdk/e2e-sdk.helper';

let session: UserSession;

describe('Subscriber Controller E2E API Testing #novu-v2', () => {
  const subscriberRepository = new SubscriberRepository();
  let novuClient: Novu;
  beforeEach(async () => {
    session = new UserSession();
    await session.initialize({ noWidgetSession: true });
    novuClient = initNovuClassSdk(session);
  });
  describe('List Subscriber', () => {
    describe('List Subscriber Permutations', () => {
      it('should not return subscribers if not matching search params', async () => {
        await createSubscriberAndValidate('XYZ');
        await createSubscriberAndValidate('XYZ2');
        const subscribers = await getAllAndValidate({
          searchParams: { email: 'nonexistent@email.com' },
          expectedTotalResults: 0,
          expectedArraySize: 0,
        });
        expect(subscribers).to.be.empty;
      });

      it('should return results without any filter params', async () => {
        const uuid = generateUUID();
        await createSubscribers(uuid, 10);
        await getAllAndValidate({
          limit: 15,
          expectedTotalResults: 10,
          expectedArraySize: 10,
        });
      });

      it('should page subscribers without overlap using cursors', async () => {
        const uuid = generateUUID();
        await createSubscribers(uuid, 10);

        const firstPage = await getListSubscribers({
          limit: 5,
        });

        const secondPage = await getListSubscribers({
          after: firstPage.next || undefined,
          limit: 5,
        });

        const idsDeduplicated = buildIdSet(firstPage.data, secondPage.data);
        expect(idsDeduplicated.size).to.be.equal(10);
      });
    });

    describe('List Subscriber Search Filters', () => {
      it('should find subscriber by email', async () => {
        const uuid = generateUUID();
        await createSubscriberAndValidate(uuid);

        const subscribers = await getAllAndValidate({
          searchParams: { email: `test-${uuid}@subscriber.com` },
          expectedTotalResults: 1,
          expectedArraySize: 1,
        });

        expect(subscribers[0].email).to.contain(uuid);
      });

      it('should find subscriber by phone', async () => {
        const uuid = generateUUID();
        await createSubscriberAndValidate(uuid);

        const subscribers = await getAllAndValidate({
          searchParams: { phone: '1234567' },
          expectedTotalResults: 1,
          expectedArraySize: 1,
        });

        await getAllAndValidate({
          searchParams: { phone: '7145' },
          expectedTotalResults: 0,
          expectedArraySize: 0,
        });

        const subscribers3 = await getAllAndValidate({
          searchParams: { phone: '+1234567890' },
          expectedTotalResults: 1,
          expectedArraySize: 1,
        });

        expect(subscribers[0].phone).to.equal('+1234567890');
        expect(subscribers3[0].phone).to.equal('+1234567890');
      });

      it('should find subscriber by full name', async () => {
        const uuid = generateUUID();
        await createSubscriberAndValidate(uuid);

        const subscribers = await getAllAndValidate({
          searchParams: { name: `Test ${uuid} Subscriber` },
          expectedTotalResults: 1,
          expectedArraySize: 1,
        });

        expect(subscribers[0].firstName).to.equal(`Test ${uuid}`);
        expect(subscribers[0].lastName).to.equal('Subscriber');
      });

      it('should find subscriber by subscriberId', async () => {
        const uuid = generateUUID();
        await createSubscriberAndValidate(uuid);

        const subscribers = await getAllAndValidate({
          searchParams: { subscriberId: `test-subscriber-${uuid}` },
          expectedTotalResults: 1,
          expectedArraySize: 1,
        });

        expect(subscribers[0].subscriberId).to.equal(`test-subscriber-${uuid}`);
      });

      it('should find subscriber by partial email match', async () => {
        const uuid = generateUUID();
        await createSubscriberAndValidate(uuid);

        const subscribers = await getAllAndValidate({
          searchParams: { email: `test-${uuid.substring(0, 5)}` },
          expectedTotalResults: 1,
          expectedArraySize: 1,
        });

        expect(subscribers[0].email).to.contain(uuid);
      });

      it('should find subscriber by partial phone match', async () => {
        const uuid = generateUUID();
        await createSubscriberAndValidate(uuid);

        const subscribers = await getAllAndValidate({
          searchParams: { phone: '123456' },
          expectedTotalResults: 1,
          expectedArraySize: 1,
        });

        expect(subscribers[0].phone).to.equal('+1234567890');
      });

      it('should find subscriber by partial name match', async () => {
        const uuid = generateUUID();
        await createSubscriberAndValidate(uuid);

        const subscribers = await getAllAndValidate({
          searchParams: { name: `Test ${uuid.substring(0, 5)}` },
          expectedTotalResults: 1,
          expectedArraySize: 1,
        });

        expect(subscribers[0].firstName).to.contain(uuid.substring(0, 5));
        expect(subscribers[0].lastName).to.equal('Subscriber');
      });

      it('should find subscriber by partial subscriberId match', async () => {
        const uuid = generateUUID();
        await createSubscriberAndValidate(uuid);

        const subscribers = await getAllAndValidate({
          searchParams: { subscriberId: `test-sub` },
          expectedTotalResults: 1,
          expectedArraySize: 1,
        });

        expect(subscribers[0].subscriberId).to.equal(`test-subscriber-${uuid}`);
      });
    });

    describe('List Subscriber Cursor Pagination', () => {
      it('should paginate forward using after cursor', async () => {
        const uuid = generateUUID();
        await createSubscribers(uuid, 10);

        const firstPage = await getListSubscribers({
          limit: 5,
        });

        const secondPage = await getListSubscribers({
          after: firstPage.next || undefined,
          limit: 5,
        });

        expect(firstPage.data).to.have.lengthOf(5);
        expect(secondPage.data).to.have.lengthOf(5);
        expect(firstPage.next).to.exist;
        expect(secondPage.previous).to.exist;

        const idsDeduplicated = buildIdSet(firstPage.data, secondPage.data);
        expect(idsDeduplicated.size).to.equal(10);
      });

      it('should paginate backward using before cursor', async () => {
        const uuid = generateUUID();
        await createSubscribers(uuid, 10);

        const firstPage = await getListSubscribers({
          limit: 5,
        });

        const secondPage = await getListSubscribers({
          after: firstPage.next || undefined,
          limit: 5,
        });

        const previousPage = await getListSubscribers({
          before: secondPage.previous || undefined,
          limit: 5,
        });

        expect(previousPage.data).to.have.lengthOf(5);
        expect(previousPage.next).to.exist;
        expect(previousPage.data).to.deep.equal(firstPage.data);
      });

      it('should handle pagination with limit=1', async () => {
        const uuid = generateUUID();
        await createSubscribers(uuid, 10);

        const firstPage = await getListSubscribers({
          limit: 1,
        });

        expect(firstPage.data).to.have.lengthOf(1);
        expect(firstPage.next).to.exist;
        expect(firstPage.previous).to.not.exist;
      });
    });

    describe('List Subscriber Sorting', () => {
      it('should sort subscribers by _id in ascending order', async () => {
        const uuid = generateUUID();
        await createSubscribers(uuid, 10);

        const response = await getListSubscribers({
          orderBy: '_id',
          orderDirection: OrderDirection.Asc,
          limit: 10,
        });

        const ids = response.data.map((sub) => sub.id).filter((id) => id !== undefined);
        const sortedIds = [...ids].sort((a, b) => a.localeCompare(b));
        expect(ids).to.deep.equal(sortedIds);
      });

      it('should sort subscribers by _id in descending order', async () => {
        const uuid = generateUUID();
        await createSubscribers(uuid, 10);

        const response = await getListSubscribers({
          orderBy: '_id',
          orderDirection: OrderDirection.Desc,
          limit: 10,
        });

        const ids = response.data.map((sub) => sub.id).filter((id) => id !== undefined);
        const sortedIds = [...ids].sort((a, b) => b.localeCompare(a));
        expect(ids).to.deep.equal(sortedIds);
      });

      it('should maintain sort order across pages', async () => {
        const uuid = generateUUID();
        await createSubscribers(uuid, 10);

        const firstPage = await getListSubscribers({
          orderBy: '_id',
          orderDirection: OrderDirection.Desc,
          limit: 5,
        });

        const secondPage = await getListSubscribers({
          orderBy: '_id',
          orderDirection: OrderDirection.Desc,
          after: firstPage.next || undefined,
          limit: 5,
        });

        const allIds = [...firstPage.data.map((sub) => sub.id), ...secondPage.data.map((sub) => sub.id)];
        const sortedIds = [...allIds].sort((a, b) => (!a || !b ? 0 : b.localeCompare(a)));
        expect(allIds).to.deep.equal(sortedIds);
      });
    });
  });
  describe('Create Subscriber', () => {
    it.skip(`should not create multiple subscribers when multiple triggers are made        
         with the same not created subscribers `, async () => {
      for (let i = 0; i < 2; i += 1) {
        const subscriberId = `not-created-twice-subscriber${i}`;
        await Promise.all([
          novuClient.subscribers.create({ subscriberId, firstName: 'TestSubFName', lastName: 'TestSubLName' }),
          novuClient.subscribers.create({ subscriberId, firstName: 'TestSubFName', lastName: 'TestSubLName' }),
        ]);

        const subscribers = await subscriberRepository.find({
          _environmentId: session.environment._id,
          subscriberId,
        });

        expect(subscribers.length).to.equal(1);
      }
    });
  });

  async function createSubscriberAndValidate(nameSuffix: string = '') {
    const createSubscriberDto = {
      subscriberId: `test-subscriber-${nameSuffix}`,
      firstName: `Test ${nameSuffix}`,
      lastName: 'Subscriber',
      email: `test-${nameSuffix}@subscriber.com`,
      phone: '+1234567890',
    };

    const res = await novuClient.subscribers.create(createSubscriberDto);

    const subscriber = res.result;
    validateCreateSubscriberResponse(subscriber, createSubscriberDto);

    return subscriber;
  }

  async function createSubscribers(uuid: string, numberOfSubscribers: number) {
    for (let i = 0; i < numberOfSubscribers; i += 1) {
      await createSubscriberAndValidate(`${uuid}-${i}`);
    }
  }

  async function getListSubscribers(params: SubscribersControllerSearchSubscribersRequest = {}) {
    const res = await novuClient.subscribers.search(params);

    return res.result;
  }

  interface IAllAndValidate {
    msgPrefix?: string;
    searchParams?: SubscribersControllerSearchSubscribersRequest;
    limit?: number;
    expectedTotalResults: number;
    expectedArraySize: number;
  }

  async function getAllAndValidate({
    msgPrefix = '',
    searchParams = {},
    limit = 15,
    expectedTotalResults,
    expectedArraySize,
  }: IAllAndValidate) {
    const listResponse = await getListSubscribers({
      ...searchParams,
      limit,
    });
    const summary = buildLogMsg(
      {
        msgPrefix,
        searchParams,
        expectedTotalResults,
        expectedArraySize,
      },
      listResponse
    );

    expect(listResponse.data).to.be.an('array', summary);
    expect(listResponse.data).lengthOf(expectedArraySize, `subscribers length ${summary}`);

    return listResponse.data;
  }

  function buildLogMsg(params: IAllAndValidate, listResponse: any): string {
    return `Log - msgPrefix: ${params.msgPrefix}, 
  searchParams: ${JSON.stringify(params.searchParams || 'Not specified', null, 2)}, 
  expectedTotalResults: ${params.expectedTotalResults ?? 'Not specified'}, 
  expectedArraySize: ${params.expectedArraySize ?? 'Not specified'}
  response: 
  ${JSON.stringify(listResponse || 'Not specified', null, 2)}`;
  }

  function buildIdSet(listResponse1: any[], listResponse2: any[]) {
    const extractIDs1 = extractIDs(listResponse1);
    const extractIDs2 = extractIDs(listResponse2);

    return new Set([...extractIDs1, ...extractIDs2]);
  }

  function extractIDs(subscribers: SubscriberResponseDto[]) {
    return subscribers.map((subscriber) => subscriber.id);
  }

  function generateUUID(): string {
    const randomHex = () => randomBytes(2).toString('hex');

    return `${randomHex()}${randomHex()}-${randomHex()}-${randomHex()}-${randomHex()}-${randomHex()}${randomHex()}${randomHex()}`;
  }

  function validateCreateSubscriberResponse(subscriber: SubscriberResponseDto, createDto: any) {
    expect(subscriber).to.be.ok;
    expect(subscriber.id).to.be.ok;
    expect(subscriber.subscriberId).to.equal(createDto.subscriberId);
    expect(subscriber.firstName).to.equal(createDto.firstName);
    expect(subscriber.lastName).to.equal(createDto.lastName);
    expect(subscriber.email).to.equal(createDto.email);
    expect(subscriber.phone).to.equal(createDto.phone);
  }
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - createSubscriberAndValidate(nameSuffix: string = '')
 - createSubscribers(uuid: string, numberOfSubscribers: number)
 - getListSubscribers(params: SubscribersControllerSearchSubscribersRequest = {})
 - getAllAndValidate({
    msgPrefix = '',
    searchParams = {},
    limit = 15,
    expectedTotalResults,
    expectedArraySize,
  }: IAllAndValidate)
 - buildLogMsg(params: IAllAndValidate, listResponse: any)
 - buildIdSet(listResponse1: any[], listResponse2: any[])
 - extractIDs(subscribers: SubscriberResponseDto[])
 - generateUUID()
 - validateCreateSubscriberResponse(subscriber: SubscriberResponseDto, createDto: any)
Asignaciones con arrow functions encontradas (posibles funciones):
 - subscriberRepository(new SubscriberRepository();
  let novuClient: Novu;
  beforeEach(async ())
 - novuClient(initNovuClassSdk(session);
  });
  describe('List Subscriber', ())
 - subscribers(await getAllAndValidate({
          searchParams: { email: 'nonexistent@email.com' },
          expe...)
 - uuid(generateUUID();
        await createSubscribers(uuid, 10);
        await getAllAndValidate({
       ...)
 - idsDeduplicated(buildIdSet(firstPage.data, secondPage.data);
        expect(idsDeduplicated.size).to.be.equal(10);
 ...)
 - subscribers(await getAllAndValidate({
          searchParams: { email: `test-${uuid}@subscriber.com` },
        ...)
 - subscribers3(await getAllAndValidate({
          searchParams: { phone: '+1234567890' },
          expectedTotalR...)
 - subscribers(await getAllAndValidate({
          searchParams: { name: `Test ${uuid} Subscriber` },
          exp...)
 - subscribers(await getAllAndValidate({
          searchParams: { subscriberId: `test-subscriber-${uuid}` },
     ...)
 - subscribers(await getAllAndValidate({
          searchParams: { email: `test-${uuid.substring(0, 5)}` },
       ...)
 - subscribers(await getAllAndValidate({
          searchParams: { phone: '123456' },
          expectedTotalResult...)
 - subscribers(await getAllAndValidate({
          searchParams: { name: `Test ${uuid.substring(0, 5)}` },
        ...)
 - subscribers(await getAllAndValidate({
          searchParams: { subscriberId: `test-sub` },
          expectedTo...)
 - idsDeduplicated(buildIdSet(firstPage.data, secondPage.data);
        expect(idsDeduplicated.size).to.equal(10);
    ...)
 - limit(1', async ())
 - firstPage(await getListSubscribers({
          limit: 1,
        });

        expect(firstPage.data).to.have.l...)
 - ids(response.data.map((sub))
 - sortedIds([...ids].sort((a, b))
 - ids(response.data.map((sub))
 - sortedIds([...ids].sort((a, b))
 - allIds([...firstPage.data.map((sub))
 - sortedIds([...allIds].sort((a, b))
 - extractIDs2(extractIDs(listResponse2);

    return new Set([...extractIDs1, ...extractIDs2]);
  }

  function ex...)
 - randomHex())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/subscribers.controller.ts
Tamaño: 20038 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  BadRequestException,
  Body,
  ClassSerializerInterceptor,
  Controller,
  Delete,
  Get,
  NotFoundException,
  Param,
  Patch,
  Post,
  Query,
  Res,
  UseInterceptors,
} from '@nestjs/common';
import { ApiExcludeEndpoint, ApiOperation, ApiParam, ApiQuery, ApiTags } from '@nestjs/swagger';
import {
  CreateOrUpdateSubscriberCommand,
  CreateOrUpdateSubscriberUseCase,
  ExternalApiAccessible,
  FeatureFlagsService,
  RequirePermissions,
  UserSession,
} from '@novu/application-generic';
import {
  ApiRateLimitCategoryEnum,
  DirectionEnum,
  FeatureFlagsKeysEnum,
  PermissionsEnum,
  SubscriberCustomData,
  UserSessionData,
} from '@novu/shared';
import { Response } from 'express';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { GetPreferencesResponseDto } from '../inbox/dtos/get-preferences-response.dto';
import { BulkUpdatePreferencesCommand } from '../inbox/usecases/bulk-update-preferences/bulk-update-preferences.command';
import { BulkUpdatePreferences } from '../inbox/usecases/bulk-update-preferences/bulk-update-preferences.usecase';
import { ThrottlerCategory } from '../rate-limiting/guards/throttler.decorator';
import { ApiCommonResponses, ApiResponse } from '../shared/framework/response.decorator';
import { SdkGroupName, SdkMethodName } from '../shared/framework/swagger/sdk.decorators';
import { SubscriberResponseDto } from '../subscribers/dtos';
import {
  GetSubscriberGlobalPreference,
  GetSubscriberGlobalPreferenceCommand,
} from '../subscribers/usecases/get-subscriber-global-preference';
import { ListSubscriberSubscriptionsQueryDto } from '../topics-v2/dtos/list-subscriber-subscriptions-query.dto';
import { ListTopicSubscriptionsResponseDto } from '../topics-v2/dtos/list-topic-subscriptions-response.dto';
import { ListSubscriberSubscriptionsCommand } from '../topics-v2/usecases/list-subscriber-subscriptions/list-subscriber-subscriptions.command';
import { ListSubscriberSubscriptionsUseCase } from '../topics-v2/usecases/list-subscriber-subscriptions/list-subscriber-subscriptions.usecase';
import { BulkUpdateSubscriberPreferencesDto } from './dtos/bulk-update-subscriber-preferences.dto';
import { CreateSubscriberRequestDto } from './dtos/create-subscriber.dto';
import { GenerateChatOauthUrlRequestDto } from './dtos/generate-chat-oauth-url.dto';
import { GetSubscriberPreferencesDto } from './dtos/get-subscriber-preferences.dto';
import { GetSubscriberPreferencesRequestDto } from './dtos/get-subscriber-preferences-request.dto';
import { ListSubscribersQueryDto } from './dtos/list-subscribers-query.dto';
import { ListSubscribersResponseDto } from './dtos/list-subscribers-response.dto';
import { PatchSubscriberRequestDto } from './dtos/patch-subscriber.dto';
import { PatchSubscriberPreferencesDto } from './dtos/patch-subscriber-preferences.dto';
import { RemoveSubscriberResponseDto } from './dtos/remove-subscriber.dto';
import { SubscriberGlobalPreferenceDto } from './dtos/subscriber-global-preference.dto';
import { ChatOauthCallbackCommand } from './usecases/chat-oauth-callback/chat-oauth-callback.command';
import { ResponseTypeEnum } from './usecases/chat-oauth-callback/chat-oauth-callback.response';
import { ChatOauthCallback } from './usecases/chat-oauth-callback/chat-oauth-callback.usecase';
import { GenerateChatOauthUrlCommand } from './usecases/generate-chat-oath-url/generate-chat-oauth-url.command';
import { GenerateChatOauthUrl } from './usecases/generate-chat-oath-url/generate-chat-oauth-url.usecase';
import { GetSubscriberCommand } from './usecases/get-subscriber/get-subscriber.command';
import { GetSubscriber } from './usecases/get-subscriber/get-subscriber.usecase';
import { GetSubscriberPreferencesCommand } from './usecases/get-subscriber-preferences/get-subscriber-preferences.command';
import { GetSubscriberPreferences } from './usecases/get-subscriber-preferences/get-subscriber-preferences.usecase';
import { ListSubscribersCommand } from './usecases/list-subscribers/list-subscribers.command';
import { ListSubscribersUseCase } from './usecases/list-subscribers/list-subscribers.usecase';
import { mapSubscriberEntityToDto } from './usecases/list-subscribers/map-subscriber-entity-to.dto';
import { PatchSubscriberCommand } from './usecases/patch-subscriber/patch-subscriber.command';
import { PatchSubscriber } from './usecases/patch-subscriber/patch-subscriber.usecase';
import { RemoveSubscriberCommand } from './usecases/remove-subscriber/remove-subscriber.command';
import { RemoveSubscriber } from './usecases/remove-subscriber/remove-subscriber.usecase';
import { UpdateSubscriberPreferencesCommand } from './usecases/update-subscriber-preferences/update-subscriber-preferences.command';
import { UpdateSubscriberPreferences } from './usecases/update-subscriber-preferences/update-subscriber-preferences.usecase';

@ThrottlerCategory(ApiRateLimitCategoryEnum.CONFIGURATION)
@Controller({ path: '/subscribers', version: '2' })
@UseInterceptors(ClassSerializerInterceptor)
@ApiTags('Subscribers')
@SdkGroupName('Subscribers')
@ApiCommonResponses()
export class SubscribersController {
  constructor(
    private listSubscribersUsecase: ListSubscribersUseCase,
    private getSubscriberUsecase: GetSubscriber,
    private patchSubscriberUsecase: PatchSubscriber,
    private removeSubscriberUsecase: RemoveSubscriber,
    private getSubscriberPreferencesUsecase: GetSubscriberPreferences,
    private updateSubscriberPreferencesUsecase: UpdateSubscriberPreferences,
    private bulkUpdatePreferencesUsecase: BulkUpdatePreferences,
    private createOrUpdateSubscriberUsecase: CreateOrUpdateSubscriberUseCase,
    private listSubscriberSubscriptionsUsecase: ListSubscriberSubscriptionsUseCase,
    private chatOauthCallbackUsecase: ChatOauthCallback,
    private generateChatOauthUrlUsecase: GenerateChatOauthUrl,
    private featureFlagsService: FeatureFlagsService,
    private getSubscriberGlobalPreference: GetSubscriberGlobalPreference
  ) {}

  @Get('')
  @ExternalApiAccessible()
  @SdkMethodName('search')
  @ApiOperation({
    summary: 'Search subscribers',
    description: `Search subscribers by their **email**, **phone**, **subscriberId** and **name**. 
    The search is case sensitive and supports pagination.Checkout all available filters in the query section.`,
  })
  @ApiResponse(ListSubscribersResponseDto)
  @RequirePermissions(PermissionsEnum.SUBSCRIBER_READ)
  @RequireAuthentication()
  async searchSubscribers(
    @UserSession() user: UserSessionData,
    @Query() query: ListSubscribersQueryDto
  ): Promise<ListSubscribersResponseDto> {
    return await this.listSubscribersUsecase.execute(
      ListSubscribersCommand.create({
        user,
        limit: Number(query.limit || '10'),
        after: query.after,
        before: query.before,
        orderDirection: query.orderDirection || DirectionEnum.DESC,
        orderBy: query.orderBy || '_id',
        email: query.email,
        phone: query.phone,
        subscriberId: query.subscriberId,
        name: query.name,
        includeCursor: query.includeCursor,
      })
    );
  }

  @Get('/:subscriberId')
  @ExternalApiAccessible()
  @ApiOperation({
    summary: 'Retrieve a subscriber',
    description: `Retrieve a subscriber by its unique key identifier **subscriberId**. 
    **subscriberId** field is required.`,
  })
  @ApiResponse(SubscriberResponseDto)
  @SdkMethodName('retrieve')
  @RequirePermissions(PermissionsEnum.SUBSCRIBER_READ)
  @RequireAuthentication()
  async getSubscriber(
    @UserSession() user: UserSessionData,
    @Param('subscriberId') subscriberId: string
  ): Promise<SubscriberResponseDto> {
    return await this.getSubscriberUsecase.execute(
      GetSubscriberCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        subscriberId,
      })
    );
  }

  @Post('')
  @ExternalApiAccessible()
  @ApiOperation({
    summary: 'Create a subscriber',
    description: `Create a subscriber with the subscriber attributes. 
      **subscriberId** is a required field, rest other fields are optional, if the subscriber already exists, it will be updated`,
  })
  @ApiQuery({
    name: 'failIfExists',
    required: false,
    type: Boolean,
    description: 'If true, the request will fail if a subscriber with the same subscriberId already exists',
  })
  @ApiResponse(SubscriberResponseDto, 201)
  @ApiResponse(SubscriberResponseDto, 409, false, false, {
    description: 'Subscriber already exists (when query param failIfExists=true)',
  })
  @SdkMethodName('create')
  @RequirePermissions(PermissionsEnum.SUBSCRIBER_WRITE)
  @RequireAuthentication()
  async createSubscriber(
    @UserSession() user: UserSessionData,
    @Body() body: CreateSubscriberRequestDto,
    @Query('failIfExists') failIfExists?: boolean
  ): Promise<SubscriberResponseDto> {
    const subscriberEntity = await this.createOrUpdateSubscriberUsecase.execute(
      CreateOrUpdateSubscriberCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        subscriberId: body.subscriberId,
        email: body.email || undefined,
        firstName: body.firstName || undefined,
        lastName: body.lastName || undefined,
        phone: body.phone || undefined,
        avatar: body.avatar || undefined,
        locale: body.locale || undefined,
        timezone: body.timezone || undefined,
        // TODO: Change shared type to
        data: (body.data || {}) as SubscriberCustomData,
        /*
         * TODO: In Subscriber V2 API endpoint we haven't added channels yet.
         * channels: body.channels || [],
         */
        failIfExists,
      })
    );

    return mapSubscriberEntityToDto(subscriberEntity);
  }

  @Patch('/:subscriberId')
  @ExternalApiAccessible()
  @ApiOperation({
    summary: 'Update a subscriber',
    description: `Update a subscriber by its unique key identifier **subscriberId**. 
    **subscriberId** is a required field, rest other fields are optional`,
  })
  @ApiResponse(SubscriberResponseDto)
  @SdkMethodName('patch')
  @RequirePermissions(PermissionsEnum.SUBSCRIBER_WRITE)
  @RequireAuthentication()
  async patchSubscriber(
    @UserSession() user: UserSessionData,
    @Param('subscriberId') subscriberId: string,
    @Body() body: PatchSubscriberRequestDto
  ): Promise<SubscriberResponseDto> {
    return await this.patchSubscriberUsecase.execute(
      PatchSubscriberCommand.create({
        subscriberId,
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        patchSubscriberRequestDto: body,
        userId: user._id,
      })
    );
  }

  @Delete('/:subscriberId')
  @ApiResponse(RemoveSubscriberResponseDto, 200)
  @ExternalApiAccessible()
  @ApiOperation({
    summary: 'Delete a subscriber',
    description: `Deletes a subscriber entity from the Novu platform along with associated messages, preferences, and topic subscriptions. 
      **subscriberId** is a required field.`,
  })
  @SdkMethodName('delete')
  @RequirePermissions(PermissionsEnum.SUBSCRIBER_WRITE)
  @RequireAuthentication()
  async removeSubscriber(
    @UserSession() user: UserSessionData,
    @Param('subscriberId') subscriberId: string
  ): Promise<RemoveSubscriberResponseDto> {
    return await this.removeSubscriberUsecase.execute(
      RemoveSubscriberCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        subscriberId,
      })
    );
  }

  @Get('/:subscriberId/preferences')
  @ExternalApiAccessible()
  @ApiOperation({
    summary: 'Retrieve subscriber preferences',
    description: `Retrieve subscriber channel preferences by its unique key identifier **subscriberId**. 
    This API returns all five channels preferences for all workflows and global preferences.`,
  })
  @ApiResponse(GetSubscriberPreferencesDto)
  @SdkGroupName('Subscribers.Preferences')
  @SdkMethodName('list')
  @RequirePermissions(PermissionsEnum.SUBSCRIBER_READ)
  @RequireAuthentication()
  async getSubscriberPreferences(
    @UserSession() user: UserSessionData,
    @Param('subscriberId') subscriberId: string,
    @Query() query: GetSubscriberPreferencesRequestDto
  ): Promise<GetSubscriberPreferencesDto> {
    return await this.getSubscriberPreferencesUsecase.execute(
      GetSubscriberPreferencesCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        subscriberId,
        criticality: query.criticality,
      })
    );
  }

  @Get('/:subscriberId/preferences/global')
  @ExternalApiAccessible()
  @ApiOperation({
    summary: 'Retrieve subscriber global preference',
    description: `Retrieve subscriber global preference. This API returns all five global channels preferences and subscriber schedule.`,
  })
  @ApiResponse(SubscriberGlobalPreferenceDto)
  @SdkGroupName('Subscribers.Preferences')
  @RequirePermissions(PermissionsEnum.SUBSCRIBER_READ)
  @RequireAuthentication()
  @SdkMethodName('globalPreference')
  @ApiExcludeEndpoint()
  async getGlobalPreference(
    @UserSession() user: UserSessionData,
    @Param('subscriberId') subscriberId: string
  ): Promise<SubscriberGlobalPreferenceDto> {
    const globalPreference = await this.getSubscriberGlobalPreference.execute(
      GetSubscriberGlobalPreferenceCommand.create({
        organizationId: user.organizationId,
        environmentId: user.environmentId,
        subscriberId: subscriberId,
        includeInactiveChannels: false,
      })
    );

    return globalPreference.preference;
  }

  @Patch('/:subscriberId/preferences/bulk')
  @ExternalApiAccessible()
  @ApiOperation({
    summary: 'Bulk update subscriber preferences',
    description: `Bulk update subscriber preferences by its unique key identifier **subscriberId**. 
    This API allows updating multiple workflow preferences in a single request.`,
  })
  @ApiResponse(GetPreferencesResponseDto, 200, true)
  @SdkGroupName('Subscribers.Preferences')
  @SdkMethodName('bulkUpdate')
  @RequirePermissions(PermissionsEnum.SUBSCRIBER_WRITE)
  @RequireAuthentication()
  async bulkUpdateSubscriberPreferences(
    @UserSession() user: UserSessionData,
    @Param('subscriberId') subscriberId: string,
    @Body() body: BulkUpdateSubscriberPreferencesDto
  ): Promise<GetPreferencesResponseDto[]> {
    const preferences = body.preferences.map((preference) => ({
      workflowId: preference.workflowId,
      email: preference.channels.email,
      sms: preference.channels.sms,
      in_app: preference.channels.in_app,
      push: preference.channels.push,
      chat: preference.channels.chat,
    }));

    return await this.bulkUpdatePreferencesUsecase.execute(
      BulkUpdatePreferencesCommand.create({
        organizationId: user.organizationId,
        subscriberId,
        environmentId: user.environmentId,
        preferences,
      })
    );
  }

  @Patch('/:subscriberId/preferences')
  @ExternalApiAccessible()
  @ApiOperation({
    summary: 'Update subscriber preferences',
    description: `Update subscriber preferences by its unique key identifier **subscriberId**. 
    **workflowId** is optional field, if provided, this API will update that workflow preference, 
    otherwise it will update global preferences`,
  })
  @ApiResponse(GetSubscriberPreferencesDto)
  @SdkGroupName('Subscribers.Preferences')
  @SdkMethodName('update')
  @RequirePermissions(PermissionsEnum.SUBSCRIBER_WRITE)
  @RequireAuthentication()
  async updateSubscriberPreferences(
    @UserSession() user: UserSessionData,
    @Param('subscriberId') subscriberId: string,
    @Body() body: PatchSubscriberPreferencesDto
  ): Promise<GetSubscriberPreferencesDto> {
    return await this.updateSubscriberPreferencesUsecase.execute(
      UpdateSubscriberPreferencesCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        subscriberId,
        workflowIdOrInternalId: body.workflowId,
        channels: body.channels,
        schedule: body.schedule,
      })
    );
  }

  @Get('/:subscriberId/subscriptions')
  @ExternalApiAccessible()
  @ApiOperation({
    summary: 'Retrieve subscriber subscriptions',
    description: `Retrieve subscriber's topic subscriptions by its unique key identifier **subscriberId**. 
    Checkout all available filters in the query section.`,
  })
  @ApiParam({ name: 'subscriberId', description: 'The identifier of the subscriber', type: String })
  @ApiResponse(ListTopicSubscriptionsResponseDto)
  @SdkGroupName('Subscribers.Topics')
  @SdkMethodName('list')
  @RequirePermissions(PermissionsEnum.SUBSCRIBER_READ)
  @RequireAuthentication()
  async listSubscriberTopics(
    @UserSession() user: UserSessionData,
    @Param('subscriberId') subscriberId: string,
    @Query() query: ListSubscriberSubscriptionsQueryDto
  ): Promise<ListTopicSubscriptionsResponseDto> {
    return await this.listSubscriberSubscriptionsUsecase.execute(
      ListSubscriberSubscriptionsCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        subscriberId,
        topicKey: query.key,
        limit: query.limit ? Number(query.limit) : 10,
        after: query.after,
        before: query.before,
        orderDirection: query.orderDirection === DirectionEnum.ASC ? 1 : -1,
        orderBy: query.orderBy || '_id',
        includeCursor: query.includeCursor,
      })
    );
  }

  @Post('/chat/oauth')
  @ApiOperation({
    summary: 'Generate chat OAuth URL',
    description: `Generate an OAuth URL for chat integrations like Slack. 
    The subscriber will use this URL to authorize the chat integration.`,
  })
  @ApiResponse(String)
  @ApiExcludeEndpoint()
  @RequirePermissions(PermissionsEnum.SUBSCRIBER_WRITE)
  @RequireAuthentication()
  async getChatOAuthUrl(
    @UserSession() user: UserSessionData,
    @Body() body: GenerateChatOauthUrlRequestDto
  ): Promise<string> {
    await this.checkFeatureEnabled(user);

    return await this.generateChatOauthUrlUsecase.execute(
      GenerateChatOauthUrlCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        subscriberId: body.subscriberId,
        integrationIdentifier: body.integrationIdentifier,
        providerId: body.providerId,
      })
    );
  }

  @Get('/chat/oauth/callback')
  @ApiOperation({
    summary: 'Handle chat OAuth callback',
    description: `Generic OAuth callback handler for all chat integrations (Slack, Teams, Discord, etc.). 
    This endpoint processes the authorization code and stores the connection for any supported chat provider.`,
  })
  @ApiExcludeEndpoint()
  async handleChatOAuthCallback(
    @Res() res: Response,
    @Query('code') providerCode: string,
    @Query('state') state: string,
    @Query('error') error?: string,
    @Query('error_description') errorDescription?: string
  ): Promise<void> {
    if (error) {
      throw new BadRequestException(`OAuth error: ${error}${errorDescription ? ` - ${errorDescription}` : ''}`);
    }

    if (!providerCode || !state) {
      throw new BadRequestException('Missing required OAuth parameters: code and state');
    }

    const result = await this.chatOauthCallbackUsecase.execute(
      ChatOauthCallbackCommand.create({
        providerCode,
        state,
      })
    );

    if (result.type === ResponseTypeEnum.HTML) {
      res.setHeader('Content-Type', 'text/html');
      res.setHeader('Content-Security-Policy', "default-src 'self'; script-src 'self' 'unsafe-inline'");
      res.send(result.result);

      return;
    }

    res.redirect(result.result);
  }

  private async checkFeatureEnabled(user: UserSessionData) {
    const isEnabled = await this.featureFlagsService.getFlag({
      key: FeatureFlagsKeysEnum.IS_SLACK_TEAMS_ENABLED,
      defaultValue: false,
      organization: { _id: user.organizationId },
    });

    if (!isEnabled) {
      throw new NotFoundException('Feature not enabled');
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - preferences(body.preferences.map((preference))
Declaraciones 'export' encontradas:
- export class SubscribersController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/subscribers.module.ts
Tamaño: 4153 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Module } from '@nestjs/common';
import {
  analyticsService,
  CacheInMemoryProviderService,
  CalculateLimitNovuIntegration,
  CreateOrUpdateSubscriberUseCase,
  cacheService,
  featureFlagsService,
  GetNovuProviderCredentials,
  GetPreferences,
  GetSubscriberTemplatePreference,
  GetWorkflowByIdsUseCase,
  InvalidateCacheService,
  UpdateSubscriber,
  UpdateSubscriberChannel,
  UpsertPreferences,
} from '@novu/application-generic';
import {
  CommunityOrganizationRepository,
  EnvironmentRepository,
  IntegrationRepository,
  MessageRepository,
  MessageTemplateRepository,
  NotificationTemplateRepository,
  PreferencesRepository,
  SubscriberRepository,
  TenantRepository,
  TopicSubscribersRepository,
  WorkflowOverrideRepository,
} from '@novu/dal';
import { ChannelConnectionsModule } from '../channel-connections/channel-connections.module';
import { ChannelEndpointsModule } from '../channel-endpoints/channel-endpoints.module';
import { InboxModule } from '../inbox/inbox.module';
import { UpdatePreferences } from '../inbox/usecases/update-preferences/update-preferences.usecase';
import { OutboundWebhooksModule } from '../outbound-webhooks/outbound-webhooks.module';
import { GetSubscriberGlobalPreference } from '../subscribers/usecases/get-subscriber-global-preference';
import { GetSubscriberPreference } from '../subscribers/usecases/get-subscriber-preference';
import { TopicsV2Module } from '../topics-v2/topics-v2.module';
import { ChannelConnectionsController } from './channel-connections.controller';
import { ChannelEndpointsController } from './channel-endpoints.controller';
import { SubscribersController } from './subscribers.controller';
import { ChatOauthCallback } from './usecases/chat-oauth-callback/chat-oauth-callback.usecase';
import { SlackOauthCallback } from './usecases/chat-oauth-callback/slack-oauth-callback/slack-oauth-callback.usecase';
import { GenerateChatOauthUrl } from './usecases/generate-chat-oath-url/generate-chat-oauth-url.usecase';
import { GenerateSlackOauthUrl } from './usecases/generate-chat-oath-url/generate-slack-oath-url/generate-slack-oauth-url.usecase';
import { GetSubscriber } from './usecases/get-subscriber/get-subscriber.usecase';
import { GetSubscriberPreferences } from './usecases/get-subscriber-preferences/get-subscriber-preferences.usecase';
import { ListSubscribersUseCase } from './usecases/list-subscribers/list-subscribers.usecase';
import { PatchSubscriber } from './usecases/patch-subscriber/patch-subscriber.usecase';
import { RemoveSubscriber } from './usecases/remove-subscriber/remove-subscriber.usecase';
import { UpdateSubscriberPreferences } from './usecases/update-subscriber-preferences/update-subscriber-preferences.usecase';

const USE_CASES = [
  ListSubscribersUseCase,
  UpdateSubscriber,
  UpdateSubscriberChannel,
  IntegrationRepository,
  CreateOrUpdateSubscriberUseCase,
  UpdateSubscriber,
  CacheInMemoryProviderService,
  GetSubscriber,
  PatchSubscriber,
  RemoveSubscriber,
  GetSubscriberPreferences,
  GetSubscriberGlobalPreference,
  GetSubscriberPreference,
  GetPreferences,
  UpdateSubscriberPreferences,
  UpdatePreferences,
  GetSubscriberTemplatePreference,
  UpsertPreferences,
  GetWorkflowByIdsUseCase,
  ChatOauthCallback,
  SlackOauthCallback,
  GenerateSlackOauthUrl,
  GenerateChatOauthUrl,
];

const DAL_MODELS = [
  SubscriberRepository,
  NotificationTemplateRepository,
  PreferencesRepository,
  TopicSubscribersRepository,
  MessageTemplateRepository,
  WorkflowOverrideRepository,
  TenantRepository,
  MessageRepository,
];

@Module({
  imports: [
    TopicsV2Module,
    InboxModule,
    OutboundWebhooksModule.forRoot(),
    ChannelConnectionsModule,
    ChannelEndpointsModule,
  ],
  controllers: [SubscribersController, ChannelEndpointsController, ChannelConnectionsController],
  providers: [
    ...USE_CASES,
    ...DAL_MODELS,
    cacheService,
    InvalidateCacheService,
    analyticsService,
    CommunityOrganizationRepository,
    featureFlagsService,
    EnvironmentRepository,
    GetNovuProviderCredentials,
    CalculateLimitNovuIntegration,
  ],
})
export class SubscribersModule {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SubscribersModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/dtos/bulk-update-subscriber-preferences.dto.ts
Tamaño: 1195 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { parseSlugId } from '@novu/application-generic';
import { Transform, Type } from 'class-transformer';
import { ArrayMaxSize, IsArray, IsDefined, IsString, ValidateNested } from 'class-validator';
import { PatchPreferenceChannelsDto } from './patch-subscriber-preferences.dto';

export class BulkUpdateSubscriberPreferenceItemDto {
  @ApiProperty({ description: 'Channel-specific preference settings', type: PatchPreferenceChannelsDto })
  @Type(() => PatchPreferenceChannelsDto)
  channels: PatchPreferenceChannelsDto;

  @ApiProperty({
    description: 'Workflow internal _id, identifier or slug',
  })
  @IsDefined()
  @IsString()
  @Transform(({ value }) => parseSlugId(value))
  readonly workflowId: string;
}

export class BulkUpdateSubscriberPreferencesDto {
  @ApiProperty({
    description: 'Array of workflow preferences to update (maximum 100 items)',
    type: [BulkUpdateSubscriberPreferenceItemDto],
    maxItems: 100,
  })
  @IsDefined()
  @IsArray()
  @ArrayMaxSize(100)
  @Type(() => BulkUpdateSubscriberPreferenceItemDto)
  @ValidateNested({ each: true })
  readonly preferences: BulkUpdateSubscriberPreferenceItemDto[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class BulkUpdateSubscriberPreferenceItemDto
- export class BulkUpdateSubscriberPreferencesDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/dtos/create-subscriber.dto.ts
Tamaño: 2371 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { Transform } from 'class-transformer';
import {
  IsDefined,
  IsEmail,
  IsLocale,
  IsNotEmpty,
  IsObject,
  IsOptional,
  IsString,
  IsTimeZone,
  ValidateIf,
} from 'class-validator';

export class CreateSubscriberRequestDto {
  @ApiProperty({
    type: String,
    description: 'Unique identifier of the subscriber',
  })
  @IsString()
  @IsDefined()
  @IsNotEmpty({
    message: 'SubscriberId is required',
  })
  @Transform(({ value }) => value.trim())
  subscriberId: string;

  @ApiPropertyOptional({
    type: String,
    description: 'First name of the subscriber',
    nullable: true,
  })
  @IsOptional()
  @ValidateIf((obj) => obj.firstName !== null)
  @IsString()
  firstName?: string | null;

  @ApiPropertyOptional({
    type: String,
    description: 'Last name of the subscriber',
    nullable: true,
  })
  @IsOptional()
  @ValidateIf((obj) => obj.lastName !== null)
  @IsString()
  lastName?: string | null;

  @ApiPropertyOptional({
    type: String,
    description: 'Email address of the subscriber',
    nullable: true,
  })
  @IsOptional()
  @ValidateIf((obj) => obj.email !== null)
  @IsEmail()
  email?: string | null;

  @ApiPropertyOptional({
    type: String,
    description: 'Phone number of the subscriber',
    nullable: true,
  })
  @IsOptional()
  @ValidateIf((obj) => obj.phone !== null)
  @IsString()
  phone?: string | null;

  @ApiPropertyOptional({
    type: String,
    description: 'Avatar URL or identifier',
    nullable: true,
  })
  @IsOptional()
  @ValidateIf((obj) => obj.avatar !== null)
  @IsString()
  avatar?: string | null;

  @ApiPropertyOptional({
    type: String,
    description: 'Timezone of the subscriber',
    nullable: true,
  })
  @IsOptional()
  @ValidateIf((obj) => obj.timezone !== null)
  @IsTimeZone()
  timezone?: string | null;

  @ApiPropertyOptional({
    type: String,
    description: 'Locale of the subscriber',
    nullable: true,
  })
  @IsOptional()
  @ValidateIf((obj) => obj.locale !== null)
  @IsLocale()
  locale?: string | null;

  @ApiPropertyOptional({
    type: Object,
    description: 'Additional custom data for the subscriber',
    nullable: true,
    additionalProperties: true,
  })
  @IsOptional()
  @ValidateIf((obj) => obj.data !== null)
  @IsObject()
  data?: Record<string, unknown> | null;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateSubscriberRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/dtos/cursor-pagination-query.dto.ts
Tamaño: 1342 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { DirectionEnum } from '@novu/shared';
import { Transform, Type } from 'class-transformer';
import { IsOptional, IsString } from 'class-validator';

export class CursorPaginationQueryDto<T, K extends keyof T> {
  @ApiProperty({
    description: 'Cursor for pagination indicating the starting point after which to fetch results.',
    type: String,
    required: false,
  })
  @IsString()
  @IsOptional()
  after?: string;

  @ApiProperty({
    description: 'Cursor for pagination indicating the ending point before which to fetch results.',
    type: String,
    required: false,
  })
  @IsString()
  @IsOptional()
  before?: string;

  @ApiPropertyOptional({
    description: 'Limit the number of items to return',
    type: Number,
  })
  @IsOptional()
  @Type(() => Number)
  limit?: number;

  @ApiPropertyOptional({
    description: 'Direction of sorting',
    enum: DirectionEnum,
  })
  @IsOptional()
  orderDirection?: DirectionEnum;

  @ApiPropertyOptional({
    description: 'Field to order by',
    type: String,
  })
  @IsString()
  @IsOptional()
  orderBy?: K;

  @ApiPropertyOptional({
    description: 'Include cursor item in response',
    type: Boolean,
  })
  @Transform(({ value }) => value === 'true')
  @IsOptional()
  includeCursor?: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CursorPaginationQueryDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/dtos/generate-chat-oauth-url.dto.ts
Tamaño: 1043 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { ChatProviderIdEnum } from '@novu/shared';
import { Transform } from 'class-transformer';
import { IsDefined, IsEnum, IsNotEmpty, IsString } from 'class-validator';

export class GenerateChatOauthUrlRequestDto {
  @ApiProperty({
    type: String,
    description: 'Integration identifier',
  })
  @IsString()
  @IsDefined()
  @IsNotEmpty({
    message: 'Integration identifier is required',
  })
  integrationIdentifier: string;

  @ApiProperty({
    description: 'Provider ID',
    enum: [...Object.values(ChatProviderIdEnum)],
    enumName: 'ChatProviderIdEnum',
    example: 'slack',
  })
  @IsEnum(ChatProviderIdEnum)
  @IsDefined()
  @IsNotEmpty({
    message: 'Provider ID is required',
  })
  providerId: ChatProviderIdEnum;

  @ApiProperty({
    type: String,
    description: 'Unique identifier of the subscriber',
  })
  @IsString()
  @IsDefined()
  @IsNotEmpty({
    message: 'SubscriberId is required',
  })
  @Transform(({ value }) => value.trim())
  subscriberId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GenerateChatOauthUrlRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/dtos/get-subscriber-preferences-request.dto.ts
Tamaño: 465 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional } from '@nestjs/swagger';
import { WorkflowCriticalityEnum } from '@novu/shared';
import { IsEnum, IsOptional } from 'class-validator';

export class GetSubscriberPreferencesRequestDto {
  @IsEnum(WorkflowCriticalityEnum)
  @IsOptional()
  @ApiPropertyOptional({
    enum: WorkflowCriticalityEnum,
    default: WorkflowCriticalityEnum.NON_CRITICAL,
  })
  criticality?: WorkflowCriticalityEnum = WorkflowCriticalityEnum.NON_CRITICAL;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetSubscriberPreferencesRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/dtos/get-subscriber-preferences.dto.ts
Tamaño: 702 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { SubscriberGlobalPreferenceDto } from './subscriber-global-preference.dto';
import { SubscriberWorkflowPreferenceDto } from './subscriber-workflow-preference.dto';

export class GetSubscriberPreferencesDto {
  @ApiProperty({ description: 'Global preference settings', type: SubscriberGlobalPreferenceDto })
  @Type(() => SubscriberGlobalPreferenceDto)
  global: SubscriberGlobalPreferenceDto;

  @ApiProperty({ description: 'Workflow-specific preference settings', type: [SubscriberWorkflowPreferenceDto] })
  @Type(() => SubscriberWorkflowPreferenceDto)
  workflows: SubscriberWorkflowPreferenceDto[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetSubscriberPreferencesDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/dtos/list-subscribers-query.dto.ts
Tamaño: 1083 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IsOptional, IsString } from 'class-validator';
import { SubscriberResponseDto } from '../../subscribers/dtos';
import { CursorPaginationQueryDto } from './cursor-pagination-query.dto';

export class ListSubscribersQueryDto extends CursorPaginationQueryDto<SubscriberResponseDto, 'updatedAt' | '_id'> {
  @ApiProperty({
    description: 'Email address of the subscriber to filter results.',
    type: String,
    required: false,
  })
  @IsOptional()
  @IsString()
  email?: string;

  @ApiProperty({
    description: 'Name of the subscriber to filter results.',
    type: String,
    required: false,
  })
  @IsOptional()
  @IsString()
  name?: string;

  @ApiProperty({
    description: 'Phone number of the subscriber to filter results.',
    type: String,
    required: false,
  })
  @IsOptional()
  @IsString()
  phone?: string;

  @ApiProperty({
    description: 'Unique identifier of the subscriber to filter results.',
    type: String,
    required: false,
  })
  @IsOptional()
  @IsString()
  subscriberId?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ListSubscribersQueryDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/dtos/list-subscribers-response.dto.ts
Tamaño: 296 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { withCursorPagination } from '../../shared/dtos/cursor-paginated-response';
import { SubscriberResponseDto } from '../../subscribers/dtos';

export class ListSubscribersResponseDto extends withCursorPagination(SubscriberResponseDto, {
  description: 'List of returned Subscribers',
}) {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ListSubscribersResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/dtos/patch-subscriber-preferences.dto.ts
Tamaño: 1523 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { parseSlugId } from '@novu/application-generic';
import { IPreferenceChannels } from '@novu/shared';
import { Transform, Type } from 'class-transformer';
import { IsOptional, ValidateNested } from 'class-validator';
import { ScheduleDto } from '../../shared/dtos/schedule';

export class PatchPreferenceChannelsDto implements IPreferenceChannels {
  @ApiProperty({ description: 'Email channel preference' })
  email?: boolean;

  @ApiProperty({ description: 'SMS channel preference' })
  sms?: boolean;

  @ApiProperty({ description: 'In-app channel preference' })
  in_app?: boolean;

  @ApiProperty({ description: 'Push channel preference' })
  push?: boolean;

  @ApiProperty({ description: 'Chat channel preference' })
  chat?: boolean;
}

export class PatchSubscriberPreferencesDto {
  @ApiPropertyOptional({ description: 'Channel-specific preference settings', type: PatchPreferenceChannelsDto })
  @Type(() => PatchPreferenceChannelsDto)
  channels?: PatchPreferenceChannelsDto;

  @ApiProperty({
    description:
      'Workflow internal _id, identifier or slug. If provided, update workflow specific preferences, otherwise update global preferences',
    required: false,
  })
  @IsOptional()
  @Transform(({ value }) => parseSlugId(value))
  workflowId?: string;

  @ApiPropertyOptional({ description: 'Subscriber schedule', type: ScheduleDto })
  @IsOptional()
  @ValidateNested()
  @Type(() => ScheduleDto)
  schedule?: ScheduleDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class PatchPreferenceChannelsDto
- export class PatchSubscriberPreferencesDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/dtos/patch-subscriber.dto.ts
Tamaño: 2016 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional } from '@nestjs/swagger';
import { IsEmail, IsLocale, IsObject, IsOptional, IsString, IsTimeZone, ValidateIf } from 'class-validator';

export class PatchSubscriberRequestDto {
  @ApiPropertyOptional({
    type: String,
    description: 'First name of the subscriber',
    nullable: true,
  })
  @IsOptional()
  @ValidateIf((obj) => obj.firstName !== null)
  @IsString()
  firstName?: string | null;

  @ApiPropertyOptional({
    type: String,
    description: 'Last name of the subscriber',
    nullable: true,
  })
  @IsOptional()
  @ValidateIf((obj) => obj.lastName !== null)
  @IsString()
  lastName?: string | null;

  @ApiPropertyOptional({
    type: String,
    description: 'Email address of the subscriber',
    nullable: true,
  })
  @IsOptional()
  @ValidateIf((obj) => obj.email !== null)
  @IsEmail()
  email?: string | null;

  @ApiPropertyOptional({
    type: String,
    description: 'Phone number of the subscriber',
    nullable: true,
  })
  @IsOptional()
  @ValidateIf((obj) => obj.phone !== null)
  @IsString()
  phone?: string | null;

  @ApiPropertyOptional({
    type: String,
    description: 'Avatar URL or identifier',
    nullable: true,
  })
  @IsOptional()
  @ValidateIf((obj) => obj.avatar !== null)
  @IsString()
  avatar?: string | null;

  @ApiPropertyOptional({
    type: String,
    description: 'Timezone of the subscriber',
    nullable: true,
  })
  @IsOptional()
  @ValidateIf((obj) => obj.timezone !== null)
  @IsTimeZone()
  timezone?: string | null;

  @ApiPropertyOptional({
    type: String,
    description: 'Locale of the subscriber',
    nullable: true,
  })
  @IsOptional()
  @ValidateIf((obj) => obj.locale !== null)
  @IsLocale()
  locale?: string | null;

  @ApiPropertyOptional({
    type: 'object',
    description: 'Additional custom data for the subscriber',
    nullable: true,
    additionalProperties: true,
  })
  @IsOptional()
  @ValidateIf((obj) => obj.data !== null)
  @IsObject()
  data?: Record<string, unknown> | null;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class PatchSubscriberRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/dtos/remove-subscriber.dto.ts
Tamaño: 370 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';

export class RemoveSubscriberResponseDto {
  @ApiProperty({
    description: 'Indicates whether the operation was acknowledged by the server',
    example: true,
  })
  acknowledged: boolean;

  @ApiProperty({
    description: 'Status of the subscriber removal operation',
    example: 'success',
  })
  status: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RemoveSubscriberResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/dtos/subscriber-global-preference.dto.ts
Tamaño: 962 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { IsBoolean, IsNotEmpty, ValidateNested } from 'class-validator';
import { SubscriberPreferenceChannels } from '../../shared/dtos/preference-channels';
import { ScheduleDto } from '../../shared/dtos/schedule';

export class SubscriberGlobalPreferenceDto {
  @ApiProperty({ description: 'Whether notifications are enabled globally' })
  @IsBoolean({ message: 'Enabled must be a boolean value' })
  @IsNotEmpty({ message: 'Enabled status is required' })
  enabled: boolean;

  @ApiProperty({ description: 'Channel-specific preference settings', type: SubscriberPreferenceChannels })
  @ValidateNested()
  @Type(() => SubscriberPreferenceChannels)
  channels: SubscriberPreferenceChannels;

  @ApiPropertyOptional({ description: 'Subscriber schedule', type: ScheduleDto })
  @ValidateNested()
  @Type(() => ScheduleDto)
  schedule?: ScheduleDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SubscriberGlobalPreferenceDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/dtos/subscriber-preferences-workflow-info.dto.ts
Tamaño: 452 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';

export class SubscriberPreferencesWorkflowInfoDto {
  @ApiProperty({ description: 'Workflow slug' })
  slug: string;

  @ApiProperty({ description: 'Unique identifier of the workflow' })
  identifier: string;

  @ApiProperty({ description: 'Display name of the workflow' })
  name: string;

  @ApiPropertyOptional({
    description: 'last updated date',
  })
  updatedAt?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SubscriberPreferencesWorkflowInfoDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/dtos/subscriber-workflow-preference.dto.ts
Tamaño: 1133 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { SubscriberPreferenceChannels } from '../../shared/dtos/preference-channels';
import { SubscriberPreferenceOverrideDto } from '../../subscribers/dtos';
import { SubscriberPreferencesWorkflowInfoDto } from './subscriber-preferences-workflow-info.dto';

export class SubscriberWorkflowPreferenceDto {
  @ApiProperty({ description: 'Whether notifications are enabled for this workflow' })
  enabled: boolean;

  @ApiProperty({
    description: 'Channel-specific preference settings for this workflow',
    type: SubscriberPreferenceChannels,
  })
  @Type(() => SubscriberPreferenceChannels)
  channels: SubscriberPreferenceChannels;

  @ApiProperty({ description: 'List of preference overrides', type: [SubscriberPreferenceOverrideDto] })
  @Type(() => SubscriberPreferenceOverrideDto)
  overrides: SubscriberPreferenceOverrideDto[];

  @ApiProperty({ description: 'Workflow information', type: SubscriberPreferencesWorkflowInfoDto })
  @Type(() => SubscriberPreferencesWorkflowInfoDto)
  workflow: SubscriberPreferencesWorkflowInfoDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SubscriberWorkflowPreferenceDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/e2e/create-subscriber.e2e.ts
Tamaño: 3314 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { randomBytes } from 'crypto';
import { expectSdkExceptionGeneric, initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

let session: UserSession;

describe('Create Subscriber - /subscribers (POST) #novu-v2', () => {
  let novuClient: Novu;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    novuClient = initNovuClassSdk(session);
  });

  it('should create the subscriber', async () => {
    const subscriberId = `test-subscriber-${`${randomBytes(4).toString('hex')}`}`;
    const payload = {
      subscriberId,
      firstName: 'First Name',
      lastName: 'Last Name',
      locale: 'en_US',
      timezone: 'America/New_York',
      data: { test1: 'test value1', test2: 'test value2' },
    };

    const { result: subscriber } = await novuClient.subscribers.create(payload);

    expect(subscriber.subscriberId).to.equal(payload.subscriberId);
    expect(subscriber.firstName).to.equal(payload.firstName);
    expect(subscriber.lastName).to.equal(payload.lastName);
    expect(subscriber.locale).to.equal(payload.locale);
    expect(subscriber.timezone).to.equal(payload.timezone);
    expect(subscriber.data).to.deep.equal(payload.data);
  });

  it('should upsert an existing subscriber if the subscriberId matches', async () => {
    const subscriberId = `test-subscriber-${`${randomBytes(4).toString('hex')}`}`;
    const payload1 = {
      subscriberId,
      firstName: 'First Name',
      locale: 'en_US',
      data: { foo: 42 },
    };

    const { result: subscriber } = await novuClient.subscribers.create(payload1);

    expect(subscriber.subscriberId).to.equal(payload1.subscriberId);
    expect(subscriber.firstName).to.equal(payload1.firstName);
    expect(subscriber.lastName).to.be.undefined;
    expect(subscriber.locale).to.equal(payload1.locale);
    expect(subscriber.timezone).to.be.undefined;
    expect(subscriber.data).to.deep.equal(payload1.data);

    const payload2 = {
      subscriberId,
      firstName: 'First Name 2',
      lastName: 'Last Name 2',
      timezone: 'America/New_York',
      data: { foo: 42, bar: '42' },
    };

    const { result: updatedSubscriber } = await novuClient.subscribers.create(payload2);

    expect(updatedSubscriber.subscriberId).to.equal(payload2.subscriberId);
    expect(updatedSubscriber.firstName).to.equal(payload2.firstName);
    expect(updatedSubscriber.lastName).to.equal(payload2.lastName);
    expect(updatedSubscriber.timezone).to.equal(payload2.timezone);

    expect(updatedSubscriber.data).to.deep.equal(payload2.data);

    const {
      result: { data: subscribers },
    } = await novuClient.subscribers.search({ subscriberId });
    expect(subscribers.length).to.equal(1);
  });

  it('should create the subscriber with null values', async () => {
    const subscriberId = `test-subscriber-${`${randomBytes(4).toString('hex')}`}`;
    const payload = {
      subscriberId,
    };

    const { result: subscriber } = await novuClient.subscribers.create(payload);

    expect(subscriber.subscriberId).to.equal(payload.subscriberId);

    expect(subscriber.firstName).to.be.undefined;
    expect(subscriber.lastName).to.be.undefined;
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - novuClient(initNovuClassSdk(session);
  });

  it('should create the subscriber', async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/e2e/delete-subscriber.e2e.ts
Tamaño: 4001 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import {
  MessageEntity,
  MessageRepository,
  PreferencesRepository,
  SubscriberEntity,
  SubscriberRepository,
  TopicRepository,
  TopicSubscribersRepository,
} from '@novu/dal';
import { ChannelTypeEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { randomBytes } from 'crypto';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Delete Subscriber - /subscribers/:subscriberId (DELETE) #novu-v2', () => {
  let session: UserSession;
  let novuClient: Novu;
  let messageRepository: MessageRepository;
  let subscriberRepository: SubscriberRepository;
  let topicRepository: TopicRepository;
  let topicSubscribersRepository: TopicSubscribersRepository;
  let preferencesRepository: PreferencesRepository;
  let subscriberId: string;
  let environmentId: string;
  let organizationId: string;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    novuClient = initNovuClassSdk(session);

    messageRepository = new MessageRepository();
    subscriberRepository = new SubscriberRepository();
    topicRepository = new TopicRepository();
    topicSubscribersRepository = new TopicSubscribersRepository();
    preferencesRepository = new PreferencesRepository();

    subscriberId = `test-subscriber-${randomBytes(4).toString('hex')}`;
    environmentId = session.environment._id;
    organizationId = session.organization._id;
  });

  it('should delete subscriber and all associated data', async () => {
    const { result: subscriberResult } = await novuClient.subscribers.create({
      subscriberId,
      firstName: 'Test',
      lastName: 'Subscriber',
      email: 'test@example.com',
      data: { test: 'value' },
    });

    const subscriberEntity = await subscriberRepository.findOne({
      _environmentId: environmentId,
      subscriberId,
    });
    expect(subscriberEntity).to.not.be.null;
    const subscriberInternalId = subscriberEntity?._id;

    const topicKey = `topic-${randomBytes(4).toString('hex')}`;
    const createTopicResponse = await novuClient.topics.create({
      key: topicKey,
      name: 'Test Topic',
    });

    await novuClient.topics.subscriptions.create(
      {
        subscriberIds: [subscriberId],
      },
      topicKey
    );

    const topicSubscriptions = await topicSubscribersRepository.find({
      _environmentId: environmentId,
      _organizationId: organizationId,
      externalSubscriberId: subscriberId,
    });
    expect(topicSubscriptions.length).to.be.greaterThan(0);

    const testMessages: MessageEntity[] = [];
    for (let i = 0; i < 3; i += 1) {
      const message = await messageRepository.create({
        _environmentId: environmentId,
        _organizationId: organizationId,
        _subscriberId: subscriberInternalId,
        content: `Test message ${i}`,
        channel: ChannelTypeEnum.IN_APP,
        transactionId: `transaction-${i}`,
      });
      testMessages.push(message);
    }

    const messagesBeforeDeletion = await messageRepository.find({
      _environmentId: environmentId,
      _subscriberId: subscriberInternalId,
    });
    expect(messagesBeforeDeletion.length).to.equal(3);

    await novuClient.subscribers.delete(subscriberId);

    const subscriberAfterDeletion = await subscriberRepository.findOne({
      _environmentId: environmentId,
      subscriberId,
    });
    expect(subscriberAfterDeletion).to.be.null;

    const messagesAfterDeletion = await messageRepository.find({
      _environmentId: environmentId,
      _subscriberId: subscriberInternalId,
    });
    expect(messagesAfterDeletion.length).to.equal(0);

    const topicSubscriptionsAfterDeletion = await topicSubscribersRepository.find({
      _environmentId: environmentId,
      _organizationId: organizationId,
      externalSubscriberId: subscriberId,
    });
    expect(topicSubscriptionsAfterDeletion.length).to.equal(0);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - organizationId(session.organization._id;
  });

  it('should delete subscriber and all associated data', async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/e2e/get-subscriber-preferences.e2e.ts
Tamaño: 4050 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { SubscriberResponseDto } from '@novu/api/models/components';
import { NotificationTemplateEntity } from '@novu/dal';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { randomBytes } from 'crypto';
import { expectSdkExceptionGeneric, initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

let session: UserSession;

describe('Get Subscriber Preferences - /subscribers/:subscriberId/preferences (GET) #novu-v2', () => {
  let novuClient: Novu;
  let subscriber: SubscriberResponseDto;
  let workflow: NotificationTemplateEntity;

  beforeEach(async () => {
    const uuid = randomBytes(4).toString('hex');
    session = new UserSession();
    await session.initialize();
    novuClient = initNovuClassSdk(session);
    subscriber = await createSubscriberAndValidate(uuid);
    workflow = await session.createTemplate({
      noFeedId: true,
    });
  });

  it('should fetch subscriber preferences with default values', async () => {
    const response = await novuClient.subscribers.preferences.list(subscriber.subscriberId);

    const { global, workflows } = response.result;

    expect(global.enabled).to.be.true;
    expect(workflows).to.be.an('array');
    expect(workflows).to.have.lengthOf(1);
  });

  it('should return 404 if subscriber does not exist', async () => {
    const invalidSubscriberId = `non-existent-${randomBytes(2).toString('hex')}`;
    const { error } = await expectSdkExceptionGeneric(() =>
      novuClient.subscribers.preferences.list(invalidSubscriberId)
    );

    expect(error?.statusCode).to.equal(404);
  });

  it('should show all available workflowsin preferences response', async () => {
    // Create multiple templates
    const workflow2 = await session.createTemplate({ noFeedId: true });
    const workflow3 = await session.createTemplate({ noFeedId: true });

    const response = await novuClient.subscribers.preferences.list(subscriber.subscriberId);

    const { workflows } = response.result;

    expect(workflows).to.have.lengthOf(3); // Should show all available workflows
    const workflowIdentifiers = workflows.map((_wf) => _wf.workflow.identifier);
    expect(workflowIdentifiers).to.include(workflow.triggers[0].identifier);
    expect(workflowIdentifiers).to.include(workflow2.triggers[0].identifier);
    expect(workflowIdentifiers).to.include(workflow3.triggers[0].identifier);
  });

  it('should inherit channel preferences from global settings when no workflow override exists', async () => {
    // First set global preferences
    await novuClient.subscribers.preferences.update(
      {
        channels: {
          email: false,
          inApp: true,
        },
      },
      subscriber.subscriberId
    );

    // Then create a new template
    const newWorkflow = await session.createTemplate({ noFeedId: true });

    // Check preferences
    const response = await novuClient.subscribers.preferences.list(subscriber.subscriberId);

    const { workflows } = response.result;

    const newWorkflowPreferences = workflows.find(
      (_wf) => _wf.workflow.identifier === newWorkflow.triggers[0].identifier
    );
    // New workflow should inherit global settings
    expect(newWorkflowPreferences?.channels).to.deep.equal({ email: false, inApp: true });
  });
});

async function createSubscriberAndValidate(id: string = '') {
  const payload = {
    subscriberId: `test-subscriber-${id}`,
    firstName: `Test ${id}`,
    lastName: 'Subscriber',
    email: `test-${id}@subscriber.com`,
    phone: '+1234567890',
  };

  const res = await session.testAgent.post(`/v1/subscribers`).send(payload);
  expect(res.status).to.equal(201);

  const subscriber = res.body.data;

  expect(subscriber.subscriberId).to.equal(payload.subscriberId);
  expect(subscriber.firstName).to.equal(payload.firstName);
  expect(subscriber.lastName).to.equal(payload.lastName);
  expect(subscriber.email).to.equal(payload.email);
  expect(subscriber.phone).to.equal(payload.phone);

  return subscriber;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - createSubscriberAndValidate(id: string = '')
Asignaciones con arrow functions encontradas (posibles funciones):
 - workflow(await session.createTemplate({
      noFeedId: true,
    });
  });

  it('should fetch subscriber pr...)
 - workflowIdentifiers(workflows.map((_wf))
 - newWorkflowPreferences(workflows.find(
      (_wf))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/e2e/get-subscriber.e2e.ts
Tamaño: 2596 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { SubscriberResponseDto } from '@novu/api/models/components';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { randomBytes } from 'crypto';
import { expectSdkExceptionGeneric, initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

let session: UserSession;

describe('Get Subscriber - /subscribers/:subscriberId (GET) #novu-v2', () => {
  let subscriber: SubscriberResponseDto;
  let novuClient: Novu;

  beforeEach(async () => {
    const uuid = randomBytes(4).toString('hex');
    session = new UserSession();
    await session.initialize();
    subscriber = await createSubscriberAndValidate(uuid);
    novuClient = initNovuClassSdk(session);
  });

  it('should fetch subscriber by subscriberId', async () => {
    const res = await novuClient.subscribers.retrieve(subscriber.subscriberId);

    validateSubscriber(res.result, subscriber);
  });

  it('should return 404 if subscriberId does not exist', async () => {
    const invalidSubscriberId = `non-existent-${randomBytes(2).toString('hex')}`;
    const { error } = await expectSdkExceptionGeneric(() => novuClient.subscribers.retrieve(invalidSubscriberId));

    expect(error?.statusCode).to.equal(404);
  });

  it('should return null values if subscriber has null or undefined values', async () => {
    const subscriberId = `test-subscriber-${`${randomBytes(4).toString('hex')}`}`;
    const payload = {
      subscriberId,
    };

    await novuClient.subscribers.create(payload);

    const res = await novuClient.subscribers.retrieve(subscriberId);

    expect(res.result.firstName).to.be.undefined;
    expect(res.result.lastName).to.be.undefined;
  });
});

async function createSubscriberAndValidate(id: string = '') {
  const payload = {
    subscriberId: `test-subscriber-${id}`,
    firstName: `Test ${id}`,
    lastName: 'Subscriber',
    email: `test-${id}@subscriber.com`,
    phone: '+1234567890',
  };

  const res = await session.testAgent.post(`/v1/subscribers`).send(payload);
  expect(res.status).to.equal(201);

  const subscriber = res.body.data;

  validateSubscriber(subscriber, payload);

  return subscriber;
}

function validateSubscriber(subscriber: SubscriberResponseDto, expected: Partial<SubscriberResponseDto>) {
  expect(subscriber.subscriberId).to.equal(expected.subscriberId);
  expect(subscriber.firstName).to.equal(expected.firstName);
  expect(subscriber.lastName).to.equal(expected.lastName);
  expect(subscriber.email).to.equal(expected.email);
  expect(subscriber.phone).to.equal(expected.phone);
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - createSubscriberAndValidate(id: string = '')
 - validateSubscriber(subscriber: SubscriberResponseDto, expected: Partial<SubscriberResponseDto>)
Asignaciones con arrow functions encontradas (posibles funciones):
 - novuClient(initNovuClassSdk(session);
  });

  it('should fetch subscriber by subscriberId', async ())
 - res(await novuClient.subscribers.retrieve(subscriber.subscriberId);

    validateSubscriber(res.result, ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/e2e/list-subscriber-subscriptions.e2e.ts
Tamaño: 6383 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { SubscriberEntity, TopicSubscribersRepository } from '@novu/dal';
import { SubscribersService, UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('List subscriber subscriptions - /v2/subscribers/:subscriberId/subscriptions (GET) #novu-v2', async () => {
  let session: UserSession;
  let novuClient: Novu;
  let subscriber: SubscriberEntity;
  let topicSubscribersRepository: TopicSubscribersRepository;
  const topicKeys: string[] = [];

  before(async () => {
    session = new UserSession();
    await session.initialize();
    novuClient = initNovuClassSdk(session);
    topicSubscribersRepository = new TopicSubscribersRepository();

    // Create a subscriber
    const subscribersService = new SubscribersService(session.organization._id, session.environment._id);
    subscriber = await subscribersService.createSubscriber();

    // Create multiple topics
    for (let i = 0; i < 3; i++) {
      const topicKey = `topic-key-${Date.now()}-${i}`;
      topicKeys.push(topicKey);

      await novuClient.topics.create({
        key: topicKey,
        name: `Test Topic ${i}`,
      });
    }

    // Add subscriber to topics
    for (const topicKey of topicKeys) {
      await novuClient.topics.subscriptions.create(
        {
          subscriberIds: [subscriber.subscriberId],
        },
        topicKey
      );
    }
  });

  it('should list all topic subscriptions for a subscriber', async () => {
    const response = await novuClient.subscribers.topics.list({
      subscriberId: subscriber.subscriberId,
    });

    expect(response).to.exist;
    expect(response.result.data.length).to.equal(topicKeys.length);

    // Check response structure for each subscription
    response.result.data.forEach((subscription) => {
      expect(subscription).to.have.property('id');
      expect(subscription).to.have.property('topic');
      expect(subscription).to.have.property('subscriber');
      expect(subscription.subscriber.subscriberId).to.equal(subscriber.subscriberId);
      expect(topicKeys).to.include(subscription.topic.key);
    });
  });

  it('should filter subscriptions by topic key', async () => {
    const targetTopicKey = topicKeys[0];
    const response = await novuClient.subscribers.topics.list({
      subscriberId: subscriber.subscriberId,
      key: targetTopicKey,
    });

    expect(response).to.exist;
    expect(response.result.data.length).to.equal(1);
    expect(response.result.data[0].topic.key).to.equal(targetTopicKey);
    expect(response.result.data[0].subscriber.subscriberId).to.equal(subscriber.subscriberId);
  });

  it('should paginate subscriptions with limit parameter and provide correct cursors', async () => {
    const limit = 1;

    // First page
    const firstPageResponse = await novuClient.subscribers.topics.list({
      subscriberId: subscriber.subscriberId,
      limit,
    });

    expect(firstPageResponse).to.exist;
    expect(firstPageResponse.result.data.length).to.equal(limit);
    expect(firstPageResponse.result.next).to.be.a('string');
    expect(firstPageResponse.result.previous).to.be.null;

    // Second page using 'after' cursor
    const secondPageResponse = await novuClient.subscribers.topics.list({
      subscriberId: subscriber.subscriberId,
      limit,
      after: firstPageResponse.result.next as string,
    });

    expect(secondPageResponse).to.exist;
    expect(secondPageResponse.result.data.length).to.be.at.most(limit);
    expect(secondPageResponse.result.previous).to.be.a('string'); // This should now be set correctly

    if (topicKeys.length > 2) {
      expect(secondPageResponse.result.next).to.be.a('string');

      // Third page using 'after' cursor
      const thirdPageResponse = await novuClient.subscribers.topics.list({
        subscriberId: subscriber.subscriberId,
        limit,
        after: secondPageResponse.result.next as string,
      });

      expect(thirdPageResponse).to.exist;
      expect(thirdPageResponse.result.data.length).to.be.at.most(limit);
      expect(thirdPageResponse.result.previous).to.be.a('string');

      // Go back to second page using 'before' cursor from third page
      const backToSecondResponse = await novuClient.subscribers.topics.list({
        subscriberId: subscriber.subscriberId,
        limit,
        before: thirdPageResponse.result.previous as string,
      });

      expect(backToSecondResponse).to.exist;
      expect(backToSecondResponse.result.data.length).to.be.at.most(limit);
      expect(backToSecondResponse.result.next).to.be.a('string');
      expect(backToSecondResponse.result.previous).to.be.a('string');

      // IDs should match the second page we got earlier
      expect(backToSecondResponse.result.data[0].id).to.equal(secondPageResponse.result.data[0].id);
    }

    // Verify different items on each page
    const firstPageIds = firstPageResponse.result.data.map((sub) => sub.id);
    const secondPageIds = secondPageResponse.result.data.map((sub) => sub.id);

    // No duplicate items between pages
    const intersection = firstPageIds.filter((id) => secondPageIds.includes(id));
    expect(intersection.length).to.equal(0);
  });

  it('should return 404 for non-existent subscriber', async () => {
    const nonExistentId = 'non-existent-subscriber-id';

    try {
      await novuClient.subscribers.topics.list({
        subscriberId: nonExistentId,
      });
      throw new Error('Should have failed to list subscriptions for non-existent subscriber');
    } catch (error) {
      expect(error.statusCode).to.equal(404);
      expect(error.message).to.include('Subscriber not found');
    }
  });

  it('should return empty array for subscriber with no subscriptions', async () => {
    // Create a subscriber with no subscriptions
    const subscribersService = new SubscribersService(session.organization._id, session.environment._id);
    const newSubscriber = await subscribersService.createSubscriber();

    const response = await novuClient.subscribers.topics.list({
      subscriberId: newSubscriber.subscriberId,
    });

    expect(response).to.exist;
    expect(response.result.data).to.be.an('array').that.is.empty;
    expect(response.result.next).to.be.null;
    expect(response.result.previous).to.be.null;
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - topicKey(`topic-key-${Date.now()}-${i}`;
      topicKeys.push(topicKey);

      await novuClient.topics.creat...)
 - response(await novuClient.subscribers.topics.list({
      subscriberId: subscriber.subscriberId,
    });

   ...)
 - response(await novuClient.subscribers.topics.list({
      subscriberId: subscriber.subscriberId,
      key: t...)
 - firstPageIds(firstPageResponse.result.data.map((sub))
 - secondPageIds(secondPageResponse.result.data.map((sub))
 - intersection(firstPageIds.filter((id))
 - nonExistentId('non-existent-subscriber-id';

    try {
      await novuClient.subscribers.topics.list({
        su...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/e2e/patch-subscriber-preferences.e2e.ts
Tamaño: 9068 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import {
  BulkUpdateSubscriberPreferencesDto,
  PatchSubscriberPreferencesDto,
  SubscriberResponseDto,
} from '@novu/api/models/components';
import { NotificationTemplateEntity } from '@novu/dal';
import { ShortIsPrefixEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { randomBytes } from 'crypto';
import { buildSlug } from '../../shared/helpers/build-slug';
import {
  expectSdkExceptionGeneric,
  expectSdkValidationExceptionGeneric,
  initNovuClassSdk,
} from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

let session: UserSession;

describe('Patch Subscriber Preferences - /subscribers/:subscriberId/preferences (PATCH) #novu-v2', () => {
  let novuClient: Novu;
  let subscriber: SubscriberResponseDto;
  let workflow: NotificationTemplateEntity;

  beforeEach(async () => {
    const uuid = randomBytes(4).toString('hex');
    session = new UserSession();
    await session.initialize();
    novuClient = initNovuClassSdk(session);
    subscriber = await createSubscriberAndValidate(uuid);
    workflow = await session.createTemplate({
      noFeedId: true,
    });
  });

  it('should patch workflow channel preferences', async () => {
    // Patch with workflow id
    const workflowId = workflow._id;
    const patchWithWorkflowId: PatchSubscriberPreferencesDto = {
      channels: {
        email: false,
        inApp: true,
      },
      workflowId,
    };

    const responseOne = await novuClient.subscribers.preferences.update(patchWithWorkflowId, subscriber.subscriberId);
    const { global, workflows: workflowsOne } = responseOne.result;

    expect(global.channels).to.deep.equal({ inApp: true, email: true });
    expect(workflowsOne).to.have.lengthOf(1);
    expect(workflowsOne[0].channels).to.deep.equal({ inApp: true, email: false });
    expect(workflowsOne[0].workflow).to.deep.include({
      name: workflow.name,
      identifier: workflow.triggers[0].identifier,
    });

    // Patch with trigger identifier
    const triggerIdentifier = workflow.triggers[0].identifier;
    const patchWithTriggerIdentifier: PatchSubscriberPreferencesDto = {
      channels: {
        email: true,
        inApp: false,
      },
      workflowId: triggerIdentifier,
    };

    const responseTwo = await novuClient.subscribers.preferences.update(
      patchWithTriggerIdentifier,
      subscriber.subscriberId
    );
    const { workflows: workflowsTwo } = responseTwo.result;

    expect(workflowsTwo[0].channels).to.deep.equal({ inApp: false, email: true });

    // Patch with slug
    const slug = buildSlug(workflow.name, ShortIsPrefixEnum.WORKFLOW, workflow._id);
    const patchData: PatchSubscriberPreferencesDto = {
      channels: {
        email: false,
        inApp: true,
      },
      workflowId: slug,
    };

    const response = await novuClient.subscribers.preferences.update(patchData, subscriber.subscriberId);
    const { workflows: workflowsThree } = response.result;

    expect(workflowsThree[0].channels).to.deep.equal({ inApp: true, email: false });
  });

  it('should patch global channel preferences', async () => {
    const patchData: PatchSubscriberPreferencesDto = {
      channels: {
        email: false,
        inApp: false,
      },
    };

    const response = await novuClient.subscribers.preferences.update(patchData, subscriber.subscriberId);

    const { global, workflows } = response.result;

    expect(global.channels).to.deep.equal({ inApp: false, email: false });
    expect(workflows).to.have.lengthOf(1);
    expect(workflows[0].channels).to.deep.equal({ inApp: false, email: false });
    expect(workflows[0].workflow).to.deep.include({ name: workflow.name, identifier: workflow.triggers[0].identifier });
  });

  it('should return 404 when patching non-existent subscriber preferences', async () => {
    const invalidSubscriberId = `non-existent-${randomBytes(2).toString('hex')}`;
    const patchData: PatchSubscriberPreferencesDto = {
      channels: {
        email: false,
      },
    };

    const { error } = await expectSdkExceptionGeneric(() =>
      novuClient.subscribers.preferences.update(patchData, invalidSubscriberId)
    );

    expect(error?.statusCode).to.equal(404);
  });

  it('should return 400 when patching with invalid workflow id', async () => {
    const patchData: PatchSubscriberPreferencesDto = {
      channels: {
        email: false,
      },
      workflowId: 'invalid-workflow-id',
    };

    try {
      await expectSdkValidationExceptionGeneric(() =>
        novuClient.subscribers.preferences.update(patchData, subscriber.subscriberId)
      );
    } catch (e) {
      // TODO: fix in SDK util
      expect(e).to.be.an.instanceOf(Error);
    }
  });

  it('should bulk update multiple workflow preferences', async () => {
    const workflow2 = await session.createTemplate({
      noFeedId: true,
    });
    const workflow3 = await session.createTemplate({
      noFeedId: true,
    });

    const bulkUpdateData: BulkUpdateSubscriberPreferencesDto = {
      preferences: [
        {
          workflowId: workflow._id,
          channels: {
            email: false,
            inApp: true,
            sms: false,
          },
        },
        {
          workflowId: workflow2._id,
          channels: {
            email: true,
            inApp: false,
            push: true,
          },
        },
        {
          workflowId: workflow3.triggers[0].identifier, // Test with trigger identifier
          channels: {
            email: false,
            inApp: true,
            chat: true,
          },
        },
      ],
    };

    const response = await novuClient.subscribers.preferences.bulkUpdate(bulkUpdateData, subscriber.subscriberId);

    expect(response.result).to.be.an('array');
    expect(response.result).to.have.lengthOf(3);

    // Verify each preference was updated correctly
    const preferences = response.result;

    const pref1 = preferences.find((p) => p.workflow?.id === workflow._id);
    expect(pref1).to.exist;
    expect(pref1?.channels.email).to.equal(false);
    expect(pref1?.channels.inApp).to.equal(true);

    const pref2 = preferences.find((p) => p.workflow?.id === workflow2._id);
    expect(pref2).to.exist;
    expect(pref2?.channels.email).to.equal(true);
    expect(pref2?.channels.inApp).to.equal(false);

    const pref3 = preferences.find((p) => p.workflow?.id === workflow3._id);
    expect(pref3).to.exist;
    expect(pref3?.channels.email).to.equal(false);
    expect(pref3?.channels.inApp).to.equal(true);
  });

  it('should return 422 when bulk updating with more than 100 preferences', async () => {
    const preferences = Array.from({ length: 101 }, (_, i) => ({
      workflowId: workflow._id,
      channels: {
        email: i % 2 === 0,
      },
    }));

    const bulkUpdateData = { preferences };

    const { error } = await expectSdkValidationExceptionGeneric(() =>
      novuClient.subscribers.preferences.bulkUpdate(bulkUpdateData, subscriber.subscriberId)
    );

    expect(error?.statusCode).to.equal(422);
    expect(error?.message).to.include('Validation Error');
  });

  it('should return 404 when bulk updating preferences for non-existent subscriber', async () => {
    const invalidSubscriberId = `non-existent-${randomBytes(2).toString('hex')}`;
    const bulkUpdateData = {
      preferences: [
        {
          workflowId: workflow._id,
          channels: {
            email: false,
          },
        },
      ],
    };

    const { error } = await expectSdkExceptionGeneric(() =>
      novuClient.subscribers.preferences.bulkUpdate(bulkUpdateData, invalidSubscriberId)
    );

    expect(error?.statusCode).to.equal(404);
  });

  it('should return 404 when bulk updating with non-existent workflow ids', async () => {
    const bulkUpdateData = {
      preferences: [
        {
          workflowId: 'non-existent-workflow-id',
          channels: {
            email: false,
          },
        },
      ],
    };

    const { error } = await expectSdkExceptionGeneric(() =>
      novuClient.subscribers.preferences.bulkUpdate(bulkUpdateData, subscriber.subscriberId)
    );

    expect(error?.statusCode).to.equal(404);
    expect(error?.message).to.include('Workflows with ids: non-existent-workflow-id not found');
  });
});

async function createSubscriberAndValidate(id: string = '') {
  const payload = {
    subscriberId: `test-subscriber-${id}`,
    firstName: `Test ${id}`,
    lastName: 'Subscriber',
    email: `test-${id}@subscriber.com`,
    phone: '+1234567890',
  };

  const res = await session.testAgent.post(`/v1/subscribers`).send(payload);
  expect(res.status).to.equal(201);

  const subscriber = res.body.data;

  expect(subscriber.subscriberId).to.equal(payload.subscriberId);
  expect(subscriber.firstName).to.equal(payload.firstName);
  expect(subscriber.lastName).to.equal(payload.lastName);
  expect(subscriber.email).to.equal(payload.email);
  expect(subscriber.phone).to.equal(payload.phone);

  return subscriber;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - createSubscriberAndValidate(id: string = '')
Asignaciones con arrow functions encontradas (posibles funciones):
 - workflow(await session.createTemplate({
      noFeedId: true,
    });
  });

  it('should patch workflow chan...)
 - PatchSubscriberPreferencesDto({
      channels: {
        email: false,
      },
      workflowId: 'invalid-workflow-id',
    };

...)
 - pref1(preferences.find((p))
 - pref2(preferences.find((p))
 - pref3(preferences.find((p))
 - preferences(Array.from({ length: 101 }, (_, i))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/e2e/patch-subscriber.e2e.ts
Tamaño: 3189 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { randomBytes } from 'crypto';
import { expectSdkExceptionGeneric, initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';
import { SubscriberResponseDto } from '../../subscribers/dtos';

let session: UserSession;

describe('Update Subscriber - /subscribers/:subscriberId (PATCH) #novu-v2', () => {
  let subscriber: SubscriberResponseDto;
  let novuClient: Novu;

  beforeEach(async () => {
    const uuid = randomBytes(4).toString('hex');
    session = new UserSession();
    await session.initialize();
    subscriber = await createSubscriberAndValidate(uuid);
    novuClient = initNovuClassSdk(session);
  });

  it('should update the fields of the subscriber', async () => {
    const payload = {
      firstName: 'Updated First Name',
      lastName: 'Updated Last Name',
    };

    const res = await novuClient.subscribers.patch(payload, subscriber.subscriberId);

    const updatedSubscriber = res.result;

    expect(subscriber.firstName).to.not.equal(updatedSubscriber.firstName);
    expect(updatedSubscriber.firstName).to.equal(payload.firstName);
    expect(subscriber.lastName).to.not.equal(updatedSubscriber.lastName);
    expect(updatedSubscriber.lastName).to.equal(payload.lastName);

    expect(subscriber.subscriberId).to.equal(updatedSubscriber.subscriberId);
    expect(subscriber.email).to.equal(updatedSubscriber.email);
    expect(subscriber.phone).to.equal(updatedSubscriber.phone);
  });

  it('should return 404 if subscriberId does not exist', async () => {
    const payload = {
      firstName: 'Updated First Name',
      lastName: 'Updated Last Name',
    };

    const invalidSubscriberId = `non-existent-${randomBytes(2).toString('hex')}`;
    const { error } = await expectSdkExceptionGeneric(() => novuClient.subscribers.patch(payload, invalidSubscriberId));

    expect(error?.statusCode).to.equal(404);
  });

  it('should return the original subscriber if no fields are updated', async () => {
    const res = await novuClient.subscribers.patch({}, subscriber.subscriberId);

    const updatedSubscriber = res.result;

    expect(subscriber.firstName).to.equal(updatedSubscriber.firstName);
    expect(subscriber.lastName).to.equal(updatedSubscriber.lastName);
    expect(subscriber.email).to.equal(updatedSubscriber.email);
    expect(subscriber.phone).to.equal(updatedSubscriber.phone);
  });
});

async function createSubscriberAndValidate(id: string = '') {
  const payload = {
    subscriberId: `test-subscriber-${id}`,
    firstName: `Test ${id}`,
    lastName: 'Subscriber',
    email: `test-${id}@subscriber.com`,
    phone: '+1234567890',
  };

  const res = await session.testAgent.post(`/v1/subscribers`).send(payload);
  expect(res.status).to.equal(201);

  const subscriber = res.body.data;

  expect(subscriber.subscriberId).to.equal(payload.subscriberId);
  expect(subscriber.firstName).to.equal(payload.firstName);
  expect(subscriber.lastName).to.equal(payload.lastName);
  expect(subscriber.email).to.equal(payload.email);
  expect(subscriber.phone).to.equal(payload.phone);

  return subscriber;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - createSubscriberAndValidate(id: string = '')
Asignaciones con arrow functions encontradas (posibles funciones):
 - novuClient(initNovuClassSdk(session);
  });

  it('should update the fields of the subscriber', async ())
 - updatedSubscriber(res.result;

    expect(subscriber.firstName).to.not.equal(updatedSubscriber.firstName);
    expect(...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/usecases/chat-oauth-callback/chat-oauth-callback.command.ts
Tamaño: 296 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BaseCommand } from '@novu/application-generic';
import { IsNotEmpty, IsString } from 'class-validator';

export class ChatOauthCallbackCommand extends BaseCommand {
  @IsNotEmpty()
  @IsString()
  readonly providerCode: string;

  @IsNotEmpty()
  @IsString()
  readonly state: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ChatOauthCallbackCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/usecases/chat-oauth-callback/chat-oauth-callback.response.ts
Tamaño: 151 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export enum ResponseTypeEnum {
  HTML = 'HTML',
  URL = 'URL',
}

export class ChatOauthCallbackResult {
  type: ResponseTypeEnum;
  result: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  enum
- export class ChatOauthCallbackResult

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/usecases/chat-oauth-callback/chat-oauth-callback.usecase.ts
Tamaño: 1799 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable } from '@nestjs/common';
import { ChatProviderIdEnum } from '@novu/shared';
import { ChatOauthCallbackCommand } from './chat-oauth-callback.command';
import { ChatOauthCallbackResult } from './chat-oauth-callback.response';
import { SlackOauthCallbackCommand } from './slack-oauth-callback/slack-oauth-callback.command';
import { SlackOauthCallback } from './slack-oauth-callback/slack-oauth-callback.usecase';

@Injectable()
export class ChatOauthCallback {
  constructor(private slackOauthCallback: SlackOauthCallback) {}

  async execute(command: ChatOauthCallbackCommand): Promise<ChatOauthCallbackResult> {
    const providerId = this.extractProviderIdFromState(command.state);

    switch (providerId) {
      case ChatProviderIdEnum.Slack:
      case ChatProviderIdEnum.Novu:
        return await this.slackOauthCallback.execute(
          SlackOauthCallbackCommand.create({
            providerCode: command.providerCode,
            state: command.state,
          })
        );

      default:
        throw new BadRequestException(`OAuth callback not supported for provider: ${providerId}`);
    }
  }

  private extractProviderIdFromState(state: string): ChatProviderIdEnum {
    try {
      const decoded = Buffer.from(state, 'base64url').toString();
      const [payload] = decoded.split('.');
      const preliminaryData = JSON.parse(payload);

      if (!preliminaryData.providerId) {
        throw new BadRequestException('Invalid state: missing providerId');
      }

      return preliminaryData.providerId as ChatProviderIdEnum;
    } catch (error) {
      if (error instanceof BadRequestException) {
        throw error;
      }
      throw new BadRequestException('Invalid OAuth state parameter - cannot extract provider');
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ChatOauthCallback

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/usecases/chat-oauth-callback/slack-oauth-callback/slack-oauth-callback.command.ts
Tamaño: 297 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BaseCommand } from '@novu/application-generic';
import { IsNotEmpty, IsString } from 'class-validator';

export class SlackOauthCallbackCommand extends BaseCommand {
  @IsNotEmpty()
  @IsString()
  readonly providerCode: string;

  @IsNotEmpty()
  @IsString()
  readonly state: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SlackOauthCallbackCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/usecases/chat-oauth-callback/slack-oauth-callback/slack-oauth-callback.usecase.ts
Tamaño: 7193 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import {
  decryptCredentials,
  GetNovuProviderCredentials,
  GetNovuProviderCredentialsCommand,
} from '@novu/application-generic';
import {
  ChannelTypeEnum,
  EnvironmentRepository,
  ICredentialsEntity,
  IntegrationEntity,
  IntegrationRepository,
} from '@novu/dal';
import { ChatProviderIdEnum, ENDPOINT_TYPES, makeResourceKey, RESOURCE } from '@novu/shared';
import axios from 'axios';
import { CreateChannelConnectionCommand } from '../../../../channel-connections/usecases/create-channel-connection/create-channel-connection.command';
import { CreateChannelConnection } from '../../../../channel-connections/usecases/create-channel-connection/create-channel-connection.usecase';
import { CreateChannelEndpointCommand } from '../../../../channel-endpoints/usecases/create-channel-endpoint/create-channel-endpoint.command';
import { CreateChannelEndpoint } from '../../../../channel-endpoints/usecases/create-channel-endpoint/create-channel-endpoint.usecase';
import {
  GenerateSlackOauthUrl,
  StateData,
} from '../../generate-chat-oath-url/generate-slack-oath-url/generate-slack-oauth-url.usecase';
import { ChatOauthCallbackResult, ResponseTypeEnum } from '../chat-oauth-callback.response';
import { SlackOauthCallbackCommand } from './slack-oauth-callback.command';

@Injectable()
export class SlackOauthCallback {
  private readonly SLACK_ACCESS_URL = 'https://slack.com/api/oauth.v2.access';
  private readonly SCRIPT_CLOSE_TAB = '<script>window.close();</script>';

  constructor(
    private integrationRepository: IntegrationRepository,
    private environmentRepository: EnvironmentRepository,
    private getNovuProviderCredentials: GetNovuProviderCredentials,
    private createChannelConnection: CreateChannelConnection,
    private createChannelEndpoint: CreateChannelEndpoint
  ) {}

  async execute(command: SlackOauthCallbackCommand): Promise<ChatOauthCallbackResult> {
    const stateData = await this.decodeSlackState(command.state);
    const integration = await this.getIntegration(stateData);
    const credentials = await this.getIntegrationCredentials(integration);

    const authData = await this.exchangeCodeForAuthData(command.providerCode, credentials);

    const channelConnection = await this.createChannelConnection.execute(
      CreateChannelConnectionCommand.create({
        organizationId: stateData.organizationId,
        environmentId: stateData.environmentId,
        integrationIdentifier: integration.identifier,
        resource: makeResourceKey(RESOURCE.SUBSCRIBER, stateData.subscriberId),
        auth: {
          accessToken: authData.access_token,
        },
        workspace: {
          id: authData.team.id,
          name: authData.team.name,
        },
      })
    );

    await this.createChannelEndpoint.execute(
      CreateChannelEndpointCommand.create({
        organizationId: stateData.organizationId,
        environmentId: stateData.environmentId,
        integrationIdentifier: integration.identifier,
        connectionIdentifier: channelConnection.identifier,
        resource: makeResourceKey(RESOURCE.SUBSCRIBER, stateData.subscriberId),
        type: ENDPOINT_TYPES.SLACK_USER,
        endpoint: {
          userId: authData.authed_user.id,
        },
      })
    );

    return {
      type: ResponseTypeEnum.HTML,
      result: this.SCRIPT_CLOSE_TAB,
    };
  }

  private async getIntegration(stateData: StateData): Promise<IntegrationEntity> {
    const integration = await this.integrationRepository.findOne({
      _environmentId: stateData.environmentId,
      _organizationId: stateData.organizationId,
      channel: ChannelTypeEnum.CHAT,
      providerId: { $in: [ChatProviderIdEnum.Slack, ChatProviderIdEnum.Novu] },
      identifier: stateData.integrationIdentifier,
    });

    if (!integration) {
      throw new NotFoundException(
        `Slack integration not found: ${stateData.integrationIdentifier} in environment ${stateData.environmentId}`
      );
    }

    return integration;
  }

  private async getIntegrationCredentials(integration: IntegrationEntity): Promise<ICredentialsEntity> {
    if (integration.providerId === ChatProviderIdEnum.Novu) {
      return this.getDemoNovuSlackCredentials(integration);
    }

    if (!integration.credentials) {
      throw new NotFoundException(`Slack integration missing credentials `);
    }

    if (!integration.credentials.clientId || !integration.credentials.secretKey) {
      throw new NotFoundException(`Slack integration missing required OAuth credentials (clientId/clientSecret) `);
    }

    return integration.credentials;
  }

  private async getDemoNovuSlackCredentials(integration: IntegrationEntity): Promise<ICredentialsEntity> {
    return await this.getNovuProviderCredentials.execute(
      GetNovuProviderCredentialsCommand.create({
        channelType: integration.channel,
        providerId: integration.providerId,
        environmentId: integration._environmentId,
        organizationId: integration._organizationId,
        userId: 'system',
      })
    );
  }

  private async exchangeCodeForAuthData(providerCode: string, integrationCredentials: ICredentialsEntity) {
    const credentials = decryptCredentials(integrationCredentials);

    const body = {
      redirect_uri: GenerateSlackOauthUrl.buildRedirectUri(),
      code: providerCode,
      client_id: credentials.clientId,
      client_secret: credentials.secretKey,
    };

    const config = {
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
    };

    const res = await axios.post(this.SLACK_ACCESS_URL, body, config);

    if (res?.data?.ok === false) {
      const metaData = res?.data?.response_metadata?.messages?.join(', ');

      throw new BadRequestException(`Slack OAuth error: ${res.data.error}${metaData ? `, metadata: ${metaData}` : ''}`);
    }

    return res.data;
  }

  private async decodeSlackState(state: string): Promise<StateData> {
    try {
      const decoded = Buffer.from(state, 'base64url').toString();
      const [payload] = decoded.split('.');
      const preliminaryData = JSON.parse(payload);

      if (!preliminaryData.environmentId) {
        throw new BadRequestException('Invalid Slack state: missing environmentId');
      }

      const environment = await this.environmentRepository.findOne({
        _id: preliminaryData.environmentId,
        _organizationId: preliminaryData.organizationId,
      });

      if (!environment) {
        throw new NotFoundException(`Environment not found: ${preliminaryData.environmentId}`);
      }

      if (!environment.apiKeys?.length) {
        throw new NotFoundException(`Environment ${preliminaryData.environmentId} has no API keys`);
      }

      const environmentApiKey = environment.apiKeys[0].key;

      return await GenerateSlackOauthUrl.validateAndDecodeState(state, environmentApiKey);
    } catch (error) {
      if (error instanceof BadRequestException || error instanceof NotFoundException) {
        throw error;
      }
      throw new BadRequestException('Invalid or expired Slack OAuth state parameter');
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SlackOauthCallback

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/usecases/generate-chat-oath-url/chat-oauth.constants.ts
Tamaño: 79 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export const CHAT_OAUTH_CALLBACK_PATH = '/v2/subscribers/chat/oauth/callback';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/usecases/generate-chat-oath-url/generate-chat-oauth-url.command.ts
Tamaño: 443 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChatProviderIdEnum } from '@novu/shared';
import { IsEnum, IsNotEmpty, IsString } from 'class-validator';
import { EnvironmentWithSubscriber } from '../../../shared/commands/project.command';

export class GenerateChatOauthUrlCommand extends EnvironmentWithSubscriber {
  @IsNotEmpty()
  @IsString()
  readonly integrationIdentifier: string;

  @IsNotEmpty()
  @IsEnum(ChatProviderIdEnum)
  readonly providerId: ChatProviderIdEnum;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GenerateChatOauthUrlCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/usecases/generate-chat-oath-url/generate-chat-oauth-url.usecase.ts
Tamaño: 787 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable } from '@nestjs/common';
import { ChatProviderIdEnum } from '@novu/shared';
import { GenerateChatOauthUrlCommand } from './generate-chat-oauth-url.command';
import { GenerateSlackOauthUrl } from './generate-slack-oath-url/generate-slack-oauth-url.usecase';

@Injectable()
export class GenerateChatOauthUrl {
  constructor(private generateSlackOAuthUrl: GenerateSlackOauthUrl) {}

  async execute(command: GenerateChatOauthUrlCommand): Promise<string> {
    switch (command.providerId) {
      case ChatProviderIdEnum.Slack:
      case ChatProviderIdEnum.Novu:
        return this.generateSlackOAuthUrl.execute(command);

      default:
        throw new BadRequestException(`OAuth not supported for provider: ${command.providerId}`);
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GenerateChatOauthUrl

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/usecases/generate-chat-oath-url/generate-slack-oath-url/generate-slack-oauth-url.command.ts
Tamaño: 298 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsNotEmpty, IsString } from 'class-validator';
import { EnvironmentWithSubscriber } from '../../../../shared/commands/project.command';

export class GenerateSlackOauthUrlCommand extends EnvironmentWithSubscriber {
  @IsNotEmpty()
  @IsString()
  readonly integrationIdentifier: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GenerateSlackOauthUrlCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/usecases/generate-chat-oath-url/generate-slack-oath-url/generate-slack-oauth-url.usecase.ts
Tamaño: 5946 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import { createHash, GetNovuProviderCredentials, GetNovuProviderCredentialsCommand } from '@novu/application-generic';
import { EnvironmentRepository, ICredentialsEntity, IntegrationEntity, IntegrationRepository } from '@novu/dal';
import { ChatProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum } from '@novu/stateless';
import { CHAT_OAUTH_CALLBACK_PATH } from '../chat-oauth.constants';
import { GenerateSlackOauthUrlCommand } from './generate-slack-oauth-url.command';

export type StateData = {
  subscriberId: string;
  environmentId: string;
  organizationId: string;
  integrationIdentifier: string;
  providerId: ChatProviderIdEnum;
  timestamp: number;
};

@Injectable()
export class GenerateSlackOauthUrl {
  private readonly SLACK_OAUTH_URL = 'https://slack.com/oauth/v2/authorize?';

  private readonly SLACK_OAUTH_SCOPES = [
    'chat:write',
    'chat:write.public',
    'channels:read',
    'groups:read',
    'users:read',
    'users:read.email',
  ] as const;

  constructor(
    private integrationRepository: IntegrationRepository,
    private environmentRepository: EnvironmentRepository,
    private getNovuProviderCredentials: GetNovuProviderCredentials
  ) {}

  async execute(command: GenerateSlackOauthUrlCommand): Promise<string> {
    const integration = await this.getIntegration(command);
    const { clientId } = await this.getIntegrationCredentials(integration);
    const secureState = await this.createSecureState(integration, command.subscriberId);

    return this.getOAuthUrl(clientId!, secureState);
  }

  private async getOAuthUrl(clientId: string, secureState: string): Promise<string> {
    const oauthParams = new URLSearchParams({
      state: secureState,
      client_id: clientId,
      scope: this.SLACK_OAUTH_SCOPES.join(','),
      redirect_uri: GenerateSlackOauthUrl.buildRedirectUri(),
    });

    return `${this.SLACK_OAUTH_URL}${oauthParams.toString()}`;
  }

  private async createSecureState(integration: IntegrationEntity, subscriberId: string): Promise<string> {
    const { _environmentId, _organizationId, identifier, providerId } = integration;

    const stateData: StateData = {
      subscriberId,
      environmentId: _environmentId,
      organizationId: _organizationId,
      integrationIdentifier: identifier,
      providerId: providerId as ChatProviderIdEnum,
      timestamp: Date.now(),
    };

    const payload = JSON.stringify(stateData);
    const secret = await this.getEnvironmentApiKey(_environmentId);
    const signature = createHash(secret, payload);

    return Buffer.from(`${payload}.${signature}`).toString('base64url');
  }

  static async validateAndDecodeState(
    state: string,
    environmentApiKey: string
  ): Promise<{
    subscriberId: string;
    environmentId: string;
    organizationId: string;
    integrationIdentifier: string;
    providerId: ChatProviderIdEnum;
    timestamp: number;
  }> {
    try {
      const decoded = Buffer.from(state, 'base64url').toString();
      const [payload, signature] = decoded.split('.');

      const expectedSignature = createHash(environmentApiKey, payload);
      if (signature !== expectedSignature) {
        throw new Error('Invalid state signature');
      }

      const data = JSON.parse(payload);

      // Validate timestamp (24 hours expiry)
      const TWENTY_FOUR_HOURS = 24 * 60 * 60 * 1000;
      if (Date.now() - data.timestamp > TWENTY_FOUR_HOURS) {
        throw new Error('OAuth state expired');
      }

      return data;
    } catch (error) {
      throw new BadRequestException('Invalid OAuth state parameter');
    }
  }

  static buildRedirectUri(): string {
    if (!process.env.API_ROOT_URL) {
      throw new Error('API_ROOT_URL environment variable is required');
    }

    const baseUrl = process.env.API_ROOT_URL.replace(/\/$/, ''); // Remove trailing slash
    return `${baseUrl}${CHAT_OAUTH_CALLBACK_PATH}`;
  }

  private async getIntegrationCredentials(integration: IntegrationEntity): Promise<ICredentialsEntity> {
    if (integration.providerId === ChatProviderIdEnum.Novu) {
      return this.getDemoNovuSlackCredentials(integration);
    }

    if (!integration.credentials) {
      throw new NotFoundException(`Slack integration missing credentials `);
    }

    if (!integration.credentials.clientId) {
      throw new NotFoundException(`Slack integration missing required OAuth credentials (clientId) `);
    }

    return integration.credentials;
  }

  private async getDemoNovuSlackCredentials(integration: IntegrationEntity): Promise<ICredentialsEntity> {
    return await this.getNovuProviderCredentials.execute(
      GetNovuProviderCredentialsCommand.create({
        channelType: integration.channel,
        providerId: integration.providerId,
        environmentId: integration._environmentId,
        organizationId: integration._organizationId,
        userId: 'system',
      })
    );
  }

  private async getIntegration(command: GenerateSlackOauthUrlCommand): Promise<IntegrationEntity> {
    const integration = await this.integrationRepository.findOne({
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
      channel: ChannelTypeEnum.CHAT,
      providerId: { $in: [ChatProviderIdEnum.Slack, ChatProviderIdEnum.Novu] },
      identifier: command.integrationIdentifier,
    });

    if (!integration) {
      throw new NotFoundException(
        `Slack integration not found: ${command.integrationIdentifier} in environment ${command.environmentId}`
      );
    }

    return integration;
  }

  private async getEnvironmentApiKey(environmentId: string): Promise<string> {
    const apiKeys = await this.environmentRepository.getApiKeys(environmentId);

    if (!apiKeys.length) {
      throw new NotFoundException(`Environment ID: ${environmentId} not found`);
    }

    return apiKeys[0].key;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export class GenerateSlackOauthUrl

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/usecases/get-subscriber-preferences/get-subscriber-preferences.command.ts
Tamaño: 411 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { WorkflowCriticalityEnum } from '@novu/shared';
import { IsEnum, IsOptional } from 'class-validator';
import { EnvironmentWithSubscriber } from '../../../shared/commands/project.command';

export class GetSubscriberPreferencesCommand extends EnvironmentWithSubscriber {
  @IsEnum(WorkflowCriticalityEnum)
  @IsOptional()
  criticality?: WorkflowCriticalityEnum = WorkflowCriticalityEnum.NON_CRITICAL;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetSubscriberPreferencesCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/usecases/get-subscriber-preferences/get-subscriber-preferences.usecase.ts
Tamaño: 3177 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { ISubscriberPreferenceResponse, ShortIsPrefixEnum, WorkflowCriticalityEnum } from '@novu/shared';
import { plainToInstance } from 'class-transformer';
import { buildSlug } from '../../../shared/helpers/build-slug';
import {
  GetSubscriberGlobalPreference,
  GetSubscriberGlobalPreferenceCommand,
} from '../../../subscribers/usecases/get-subscriber-global-preference';
import {
  GetSubscriberPreference,
  GetSubscriberPreferenceCommand,
} from '../../../subscribers/usecases/get-subscriber-preference';
import { GetSubscriberPreferencesDto } from '../../dtos/get-subscriber-preferences.dto';
import { SubscriberGlobalPreferenceDto } from '../../dtos/subscriber-global-preference.dto';
import { SubscriberWorkflowPreferenceDto } from '../../dtos/subscriber-workflow-preference.dto';
import { GetSubscriberPreferencesCommand } from './get-subscriber-preferences.command';

@Injectable()
export class GetSubscriberPreferences {
  constructor(
    private getSubscriberGlobalPreference: GetSubscriberGlobalPreference,
    private getSubscriberPreference: GetSubscriberPreference
  ) {}

  async execute(command: GetSubscriberPreferencesCommand): Promise<GetSubscriberPreferencesDto> {
    const globalPreference = await this.fetchGlobalPreference(command);
    const workflowPreferences = await this.fetchWorkflowPreferences(command);

    return plainToInstance(GetSubscriberPreferencesDto, {
      global: globalPreference,
      workflows: workflowPreferences,
    });
  }

  private async fetchGlobalPreference(
    command: GetSubscriberPreferencesCommand
  ): Promise<SubscriberGlobalPreferenceDto> {
    const { preference } = await this.getSubscriberGlobalPreference.execute(
      GetSubscriberGlobalPreferenceCommand.create({
        organizationId: command.organizationId,
        environmentId: command.environmentId,
        subscriberId: command.subscriberId,
        includeInactiveChannels: false,
      })
    );

    return {
      ...preference,
    };
  }

  private async fetchWorkflowPreferences(command: GetSubscriberPreferencesCommand) {
    const subscriberWorkflowPreferences = await this.getSubscriberPreference.execute(
      GetSubscriberPreferenceCommand.create({
        environmentId: command.environmentId,
        subscriberId: command.subscriberId,
        organizationId: command.organizationId,
        includeInactiveChannels: false,
        criticality: command.criticality ?? WorkflowCriticalityEnum.NON_CRITICAL,
      })
    );

    return subscriberWorkflowPreferences.map(this.mapToWorkflowPreference);
  }

  private mapToWorkflowPreference(
    subscriberWorkflowPreference: ISubscriberPreferenceResponse
  ): SubscriberWorkflowPreferenceDto {
    const { preference, template } = subscriberWorkflowPreference;

    return {
      enabled: preference.enabled,
      channels: preference.channels,
      overrides: preference.overrides,
      workflow: {
        slug: buildSlug(template.name, ShortIsPrefixEnum.WORKFLOW, template._id),
        identifier: template.triggers[0].identifier,
        name: template.name,
        updatedAt: template.updatedAt,
      },
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetSubscriberPreferences

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/usecases/get-subscriber/get-subscriber.command.ts
Tamaño: 253 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsString } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';

export class GetSubscriberCommand extends EnvironmentCommand {
  @IsString()
  @IsDefined()
  subscriberId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetSubscriberCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/usecases/get-subscriber/get-subscriber.usecase.ts
Tamaño: 1252 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { SubscriberEntity, SubscriberRepository } from '@novu/dal';
import { SubscriberResponseDto } from '../../../subscribers/dtos';
import { mapSubscriberEntityToDto } from '../list-subscribers/map-subscriber-entity-to.dto';
import { GetSubscriberCommand } from './get-subscriber.command';

@Injectable()
export class GetSubscriber {
  constructor(private subscriberRepository: SubscriberRepository) {}

  async execute(command: GetSubscriberCommand): Promise<SubscriberResponseDto> {
    const subscriber = await this.fetchSubscriber({
      _environmentId: command.environmentId,
      subscriberId: command.subscriberId,
      _organizationId: command.organizationId,
    });

    if (!subscriber) {
      throw new NotFoundException(`Subscriber: ${command.subscriberId} was not found`);
    }

    return mapSubscriberEntityToDto(subscriber);
  }

  private async fetchSubscriber({
    subscriberId,
    _environmentId,
    _organizationId,
  }: {
    subscriberId: string;
    _environmentId: string;
    _organizationId: string;
  }): Promise<SubscriberEntity | null> {
    return await this.subscriberRepository.findOne({ _environmentId, subscriberId, _organizationId });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetSubscriber

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/usecases/list-subscribers/list-subscribers.command.ts
Tamaño: 485 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CursorBasedPaginatedCommand } from '@novu/application-generic';
import { ISubscriber } from '@novu/shared';
import { IsOptional, IsString } from 'class-validator';

export class ListSubscribersCommand extends CursorBasedPaginatedCommand<ISubscriber, 'updatedAt' | '_id'> {
  @IsString()
  @IsOptional()
  email?: string;

  @IsString()
  @IsOptional()
  phone?: string;

  @IsString()
  @IsOptional()
  subscriberId?: string;

  @IsString()
  @IsOptional()
  name?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ListSubscribersCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/usecases/list-subscribers/list-subscribers.usecase.ts
Tamaño: 1506 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { InstrumentUsecase } from '@novu/application-generic';
import { SubscriberRepository } from '@novu/dal';
import { DirectionEnum } from '../../../shared/dtos/base-responses';
import { ListSubscribersResponseDto } from '../../dtos/list-subscribers-response.dto';
import { ListSubscribersCommand } from './list-subscribers.command';
import { mapSubscriberEntityToDto } from './map-subscriber-entity-to.dto';

@Injectable()
export class ListSubscribersUseCase {
  constructor(private subscriberRepository: SubscriberRepository) {}

  @InstrumentUsecase()
  async execute(command: ListSubscribersCommand): Promise<ListSubscribersResponseDto> {
    const pagination = await this.subscriberRepository.listSubscribers({
      after: command.after,
      before: command.before,
      limit: command.limit,
      sortDirection: command.orderDirection || DirectionEnum.DESC,
      sortBy: command.orderBy,
      email: command.email,
      name: command.name,
      phone: command.phone,
      subscriberId: command.subscriberId,
      environmentId: command.user.environmentId,
      organizationId: command.user.organizationId,
      includeCursor: command.includeCursor,
    });

    return {
      data: pagination.subscribers.map((subscriber) => mapSubscriberEntityToDto(subscriber)),
      next: pagination.next,
      previous: pagination.previous,
      totalCount: pagination.totalCount,
      totalCountCapped: pagination.totalCountCapped,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - pagination(await this.subscriberRepository.listSubscribers({
      after: command.after,
      before: command....)
Declaraciones 'export' encontradas:
- export class ListSubscribersUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/usecases/list-subscribers/map-subscriber-entity-to.dto.ts
Tamaño: 897 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SubscriberEntity } from '@novu/dal';
import { SubscriberResponseDto } from '../../../subscribers/dtos';

export function mapSubscriberEntityToDto(subscriber: SubscriberEntity): SubscriberResponseDto {
  return {
    _id: subscriber._id,
    firstName: subscriber.firstName,
    lastName: subscriber.lastName,
    email: subscriber.email,
    phone: subscriber.phone,
    avatar: subscriber.avatar,
    subscriberId: subscriber.subscriberId,
    createdAt: subscriber.createdAt,
    updatedAt: subscriber.updatedAt,
    _environmentId: subscriber._environmentId,
    _organizationId: subscriber._organizationId,
    deleted: subscriber.deleted,
    data: subscriber.data,
    lastOnlineAt: subscriber.lastOnlineAt,
    isOnline: subscriber.isOnline,
    topics: subscriber.topics,
    channels: subscriber.channels,
    locale: subscriber.locale,
    timezone: subscriber.timezone,
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - mapSubscriberEntityToDto(subscriber: SubscriberEntity)
Declaraciones 'export' encontradas:
- export function mapSubscriberEntityToDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/usecases/patch-subscriber/patch-subscriber.command.ts
Tamaño: 524 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Type } from 'class-transformer';
import { IsDefined, IsString, ValidateNested } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';
import { PatchSubscriberRequestDto } from '../../dtos/patch-subscriber.dto';

export class PatchSubscriberCommand extends EnvironmentWithUserCommand {
  @IsString()
  @IsDefined()
  subscriberId: string;

  @ValidateNested()
  @Type(() => PatchSubscriberRequestDto)
  patchSubscriberRequestDto: PatchSubscriberRequestDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class PatchSubscriberCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/usecases/patch-subscriber/patch-subscriber.usecase.ts
Tamaño: 3721 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import { FeatureFlagsService, PinoLogger } from '@novu/application-generic';
import {
  CommunityOrganizationRepository,
  EnvironmentEntity,
  EnvironmentRepository,
  OrganizationEntity,
  SubscriberEntity,
  SubscriberRepository,
  UserEntity,
} from '@novu/dal';
import { FeatureFlagsKeysEnum } from '@novu/shared';
import { subscriberIdSchema } from '../../../events/utils/trigger-recipient-validation';
import { SubscriberResponseDto } from '../../../subscribers/dtos';
import { mapSubscriberEntityToDto } from '../list-subscribers/map-subscriber-entity-to.dto';
import { PatchSubscriberCommand } from './patch-subscriber.command';

@Injectable()
export class PatchSubscriber {
  constructor(
    private subscriberRepository: SubscriberRepository,
    private featureFlagService: FeatureFlagsService,
    private environmentRepository: EnvironmentRepository,
    private communityOrganizationRepository: CommunityOrganizationRepository,
    private logger: PinoLogger
  ) {
    this.logger.setContext(this.constructor.name);
  }

  async execute(command: PatchSubscriberCommand): Promise<SubscriberResponseDto> {
    const nonUndefinedEntries = Object.entries(command.patchSubscriberRequestDto).filter(
      ([_key, value]) => value !== undefined
    );
    const payload: Partial<SubscriberEntity> = Object.fromEntries(nonUndefinedEntries);

    const [environment, organization] = await Promise.all([
      this.environmentRepository.findOne({ _id: command.environmentId }),
      this.communityOrganizationRepository.findOne({ _id: command.organizationId }),
    ]);

    if (!organization) {
      throw new BadRequestException('Organization not found');
    }

    if (!environment) {
      throw new BadRequestException('Environment not found');
    }

    await this.validateItem({
      itemId: command.subscriberId,
      environment,
      organization,
      userId: command.userId,
    });

    const updatedSubscriber = await this.subscriberRepository.findOneAndUpdate(
      {
        subscriberId: command.subscriberId,
        _environmentId: command.environmentId,
        _organizationId: command.organizationId,
      },
      { ...payload },
      {
        new: true,
        projection: {
          _environmentId: 1,
          _id: 1,
          _organizationId: 1,
          avatar: 1,
          data: 1,
          email: 1,
          firstName: 1,
          lastName: 1,
          locale: 1,
          phone: 1,
          subscriberId: 1,
          timezone: 1,
          createdAt: 1,
          updatedAt: 1,
          deleted: 1,
        },
      }
    );

    if (!updatedSubscriber) {
      throw new NotFoundException(`Subscriber: ${command.subscriberId} was not found`);
    }

    return mapSubscriberEntityToDto(updatedSubscriber);
  }

  private async validateItem({
    itemId,
    userId,
    environment,
    organization,
  }: {
    itemId: string;
    environment?: EnvironmentEntity;
    organization?: OrganizationEntity;
    userId: string;
  }) {
    const isDryRun = await this.featureFlagService.getFlag({
      environment,
      organization,
      user: { _id: userId } as UserEntity,
      key: FeatureFlagsKeysEnum.IS_SUBSCRIBER_ID_VALIDATION_DRY_RUN_ENABLED,
      defaultValue: true,
    });
    const result = subscriberIdSchema.safeParse(itemId);

    if (result.success) {
      return;
    }

    if (isDryRun) {
      this.logger.warn(`[Dry run] Invalid recipients: ${itemId}`);
    } else {
      throw new BadRequestException(
        `Invalid subscriberId: ${itemId}, only alphanumeric characters, -, _, and . or valid email addresses are allowed`
      );
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - nonUndefinedEntries(Object.entries(command.patchSubscriberRequestDto).filter(
      ([_key, value]))
Declaraciones 'export' encontradas:
- export class PatchSubscriber

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/usecases/remove-subscriber/remove-subscriber.command.ts
Tamaño: 230 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsString } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';

export class RemoveSubscriberCommand extends EnvironmentCommand {
  @IsString()
  subscriberId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RemoveSubscriberCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/usecases/remove-subscriber/remove-subscriber.usecase.ts
Tamaño: 2747 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import {
  buildFeedKey,
  buildMessageCountKey,
  buildSubscriberKey,
  InvalidateCacheService,
} from '@novu/application-generic';
import { MessageRepository, PreferencesRepository, SubscriberRepository, TopicSubscribersRepository } from '@novu/dal';

import { RemoveSubscriberCommand } from './remove-subscriber.command';

@Injectable()
export class RemoveSubscriber {
  constructor(
    private invalidateCache: InvalidateCacheService,
    private subscriberRepository: SubscriberRepository,
    private topicSubscribersRepository: TopicSubscribersRepository,
    private preferenceRepository: PreferencesRepository,
    private messageRepository: MessageRepository
  ) {}

  async execute({ environmentId: _environmentId, subscriberId }: RemoveSubscriberCommand) {
    await Promise.all([
      this.invalidateCache.invalidateByKey({
        key: buildSubscriberKey({
          subscriberId,
          _environmentId,
        }),
      }),
      this.invalidateCache.invalidateQuery({
        key: buildFeedKey().invalidate({
          subscriberId,
          _environmentId,
        }),
      }),
      this.invalidateCache.invalidateQuery({
        key: buildMessageCountKey().invalidate({
          subscriberId,
          _environmentId,
        }),
      }),
    ]);

    const subscriberInternalIds = await this.subscriberRepository._model.distinct('_id', {
      subscriberId,
      _environmentId,
    });

    if (subscriberInternalIds.length === 0) {
      throw new NotFoundException({ message: 'Subscriber was not found', externalSubscriberId: subscriberId });
    }

    await this.subscriberRepository.withTransaction(async () => {
      /*
       * Note about parallelism in transactions
       *
       * Running operations in parallel is not supported during a transaction.
       * The use of Promise.all, Promise.allSettled, Promise.race, etc. to parallelize operations
       * inside a transaction is undefined behaviour and should be avoided.
       *
       * Refer to https://mongoosejs.com/docs/transactions.html#note-about-parallelism-in-transactions
       */
      await this.subscriberRepository.delete({
        subscriberId,
        _environmentId,
      });

      await this.topicSubscribersRepository.delete({
        _environmentId,
        externalSubscriberId: subscriberId,
      });
      await this.preferenceRepository.delete({
        _environmentId,
        _subscriberId: { $in: subscriberInternalIds },
      });

      await this.messageRepository.delete({
        _subscriberId: { $in: subscriberInternalIds },
        _environmentId,
      });
    });

    return {
      acknowledged: true,
      status: 'deleted',
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RemoveSubscriber

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/usecases/update-subscriber-preferences/update-subscriber-preferences.command.ts
Tamaño: 684 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Type } from 'class-transformer';
import { IsOptional, IsString } from 'class-validator';
import { EnvironmentWithSubscriber } from '../../../shared/commands/project.command';
import { ScheduleDto } from '../../../shared/dtos/schedule';
import { PatchPreferenceChannelsDto } from '../../dtos/patch-subscriber-preferences.dto';

export class UpdateSubscriberPreferencesCommand extends EnvironmentWithSubscriber {
  @IsOptional()
  @IsString()
  readonly workflowIdOrInternalId?: string;

  @IsOptional()
  @Type(() => PatchPreferenceChannelsDto)
  readonly channels?: PatchPreferenceChannelsDto;

  @IsOptional()
  @Type(() => ScheduleDto)
  readonly schedule?: ScheduleDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateSubscriberPreferencesCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/usecases/update-subscriber-preferences/update-subscriber-preferences.usecase.ts
Tamaño: 2516 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { GetWorkflowByIdsCommand, GetWorkflowByIdsUseCase } from '@novu/application-generic';
import { PreferenceLevelEnum, WorkflowCriticalityEnum } from '@novu/shared';
import { plainToInstance } from 'class-transformer';
import { UpdatePreferencesCommand } from '../../../inbox/usecases/update-preferences/update-preferences.command';
import { UpdatePreferences } from '../../../inbox/usecases/update-preferences/update-preferences.usecase';
import { GetSubscriberPreferencesDto } from '../../dtos/get-subscriber-preferences.dto';
import { GetSubscriberPreferences } from '../get-subscriber-preferences/get-subscriber-preferences.usecase';
import { UpdateSubscriberPreferencesCommand } from './update-subscriber-preferences.command';

@Injectable()
export class UpdateSubscriberPreferences {
  constructor(
    private updatePreferencesUsecase: UpdatePreferences,
    private getSubscriberPreferences: GetSubscriberPreferences,
    private getWorkflowByIdsUseCase: GetWorkflowByIdsUseCase
  ) {}

  async execute(command: UpdateSubscriberPreferencesCommand): Promise<GetSubscriberPreferencesDto> {
    let workflowId: string | undefined;
    if (command.workflowIdOrInternalId) {
      const workflowEntity = await this.getWorkflowByIdsUseCase.execute(
        GetWorkflowByIdsCommand.create({
          environmentId: command.environmentId,
          organizationId: command.organizationId,
          workflowIdOrInternalId: command.workflowIdOrInternalId,
        })
      );
      workflowId = workflowEntity._id;
    }

    await this.updatePreferencesUsecase.execute(
      UpdatePreferencesCommand.create({
        organizationId: command.organizationId,
        environmentId: command.environmentId,
        subscriberId: command.subscriberId,
        level: command.workflowIdOrInternalId ? PreferenceLevelEnum.TEMPLATE : PreferenceLevelEnum.GLOBAL,
        workflowIdOrIdentifier: workflowId,
        includeInactiveChannels: false,
        ...command.channels,
        schedule: command.schedule,
      })
    );

    const subscriberPreferences = await this.getSubscriberPreferences.execute({
      environmentId: command.environmentId,
      organizationId: command.organizationId,
      subscriberId: command.subscriberId,
      criticality: WorkflowCriticalityEnum.NON_CRITICAL,
    });

    return plainToInstance(GetSubscriberPreferencesDto, {
      global: subscriberPreferences.global,
      workflows: subscriberPreferences.workflows,
    });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateSubscriberPreferences

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers-v2/utils/create-subscriber.mapper.ts
Tamaño: 1683 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SubscriberEntity } from '@novu/dal';
import { IChannelCredentials, IChannelSettings } from '@novu/shared';
import { ChannelCredentials } from '../../shared/dtos/subscriber-channel';
import { ChannelSettingsDto, SubscriberResponseDto } from '../../subscribers/dtos';

export function mapSubscriberEntityToResponseDto(entity: SubscriberEntity): SubscriberResponseDto {
  return {
    _id: entity._id,
    firstName: entity.firstName,
    lastName: entity.lastName,
    email: entity.email ?? null,
    phone: entity.phone,
    avatar: entity.avatar,
    subscriberId: entity.subscriberId,
    channels: entity.channels?.map(mapChannelSettings),
    topics: entity.topics,
    isOnline: entity.isOnline,
    lastOnlineAt: entity.lastOnlineAt,
    _organizationId: entity._organizationId,
    _environmentId: entity._environmentId,
    deleted: entity.deleted,
    createdAt: entity.createdAt,
    updatedAt: entity.updatedAt,
    __v: entity.__v,
    data: entity.data,
    locale: entity.locale,
    timezone: entity.timezone,
  };
}

function mapChannelSettings(settings: IChannelSettings): ChannelSettingsDto {
  return {
    _integrationId: settings._integrationId,
    providerId: settings.providerId,
    credentials: mapChannelCredentials(settings.credentials),
  };
}
function mapChannelCredentials(input: IChannelCredentials): ChannelCredentials {
  return {
    webhookUrl: input.webhookUrl,
    channel: input.channel,
    deviceTokens: input.deviceTokens,
    // Additional fields not in original IChannelCredentials are left undefined
    alertUid: undefined,
    title: undefined,
    imageUrl: undefined,
    state: undefined,
    externalUrl: undefined,
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - mapSubscriberEntityToResponseDto(entity: SubscriberEntity)
 - mapChannelSettings(settings: IChannelSettings)
 - mapChannelCredentials(input: IChannelCredentials)
Declaraciones 'export' encontradas:
- export function mapSubscriberEntityToResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/subscribersV1.controller.ts
Tamaño: 32323 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  BadRequestException,
  Body,
  Controller,
  Delete,
  Get,
  HttpCode,
  HttpStatus,
  NotFoundException,
  Param,
  Patch,
  Post,
  Put,
  Query,
  Res,
} from '@nestjs/common';
import { ApiExcludeEndpoint, ApiOperation, ApiQuery, ApiTags } from '@nestjs/swagger';
import {
  CreateOrUpdateSubscriberCommand,
  CreateOrUpdateSubscriberUseCase,
  OAuthHandlerEnum,
  UpdateSubscriber,
  UpdateSubscriberChannel,
  UpdateSubscriberChannelCommand,
  UpdateSubscriberCommand,
} from '@novu/application-generic';
import { MessageEntity } from '@novu/dal';
import {
  ApiRateLimitCategoryEnum,
  ApiRateLimitCostEnum,
  ButtonTypeEnum,
  ChatProviderIdEnum,
  IPreferenceChannels,
  PreferenceLevelEnum,
  TriggerTypeEnum,
  UserSessionData,
} from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { ExternalApiAccessible } from '../auth/framework/external-api.decorator';
import { UpdatePreferencesCommand } from '../inbox/usecases/update-preferences/update-preferences.command';
import { UpdatePreferences } from '../inbox/usecases/update-preferences/update-preferences.usecase';
import { ThrottlerCategory, ThrottlerCost } from '../rate-limiting/guards';
import { PaginatedResponseDto } from '../shared/dtos/pagination-response';
import { ApiOkPaginatedResponse } from '../shared/framework/paginated-ok-response.decorator';
import {
  ApiCommonResponses,
  ApiCreatedResponse,
  ApiFoundResponse,
  ApiNoContentResponse,
  ApiResponse,
} from '../shared/framework/response.decorator';
import { SdkGroupName, SdkMethodName, SdkUsePagination } from '../shared/framework/swagger/sdk.decorators';
import { UserSession } from '../shared/framework/user.decorator';
import { FeedResponseDto } from '../widgets/dtos/feeds-response.dto';
import { MessageMarkAsRequestDto } from '../widgets/dtos/mark-as-request.dto';
import { MarkMessageActionAsSeenDto } from '../widgets/dtos/mark-message-action-as-seen.dto';
import { MarkMessageAsRequestDto } from '../widgets/dtos/mark-message-as-request.dto';
import { MessageResponseDto } from '../widgets/dtos/message-response.dto';
import { UnseenCountResponse } from '../widgets/dtos/unseen-count-response.dto';
import { UpdateSubscriberPreferenceRequestDto } from '../widgets/dtos/update-subscriber-preference-request.dto';
import {
  UpdateSubscriberPreferenceGlobalResponseDto,
  UpdateSubscriberPreferenceResponseDto,
} from '../widgets/dtos/update-subscriber-preference-response.dto';
import { GetFeedCountCommand } from '../widgets/usecases/get-feed-count/get-feed-count.command';
import { GetFeedCount } from '../widgets/usecases/get-feed-count/get-feed-count.usecase';
import { GetNotificationsFeedCommand } from '../widgets/usecases/get-notifications-feed/get-notifications-feed.command';
import { GetNotificationsFeed } from '../widgets/usecases/get-notifications-feed/get-notifications-feed.usecase';
import { UpdateMessageActionsCommand } from '../widgets/usecases/mark-action-as-done/update-message-actions.command';
import { UpdateMessageActions } from '../widgets/usecases/mark-action-as-done/update-message-actions.usecase';
import { MarkAllMessagesAsCommand } from '../widgets/usecases/mark-all-messages-as/mark-all-messages-as.command';
import { MarkAllMessagesAs } from '../widgets/usecases/mark-all-messages-as/mark-all-messages-as.usecase';
import { MarkMessageAsCommand } from '../widgets/usecases/mark-message-as/mark-message-as.command';
import { MarkMessageAs } from '../widgets/usecases/mark-message-as/mark-message-as.usecase';
import { MarkMessageAsByMarkCommand } from '../widgets/usecases/mark-message-as-by-mark/mark-message-as-by-mark.command';
import { MarkMessageAsByMark } from '../widgets/usecases/mark-message-as-by-mark/mark-message-as-by-mark.usecase';
import {
  BulkSubscriberCreateDto,
  CreateSubscriberRequestDto,
  DeleteSubscriberResponseDto,
  GetSubscriberPreferencesResponseDto,
  SubscriberResponseDto,
  UpdateSubscriberChannelRequestDto,
  UpdateSubscriberGlobalPreferencesRequestDto,
  UpdateSubscriberRequestDto,
} from './dtos';
import { BulkCreateSubscriberResponseDto } from './dtos/bulk-create-subscriber-response.dto';
import { ChatOauthCallbackRequestDto, ChatOauthRequestDto } from './dtos/chat-oauth-request.dto';
import { GetInAppNotificationsFeedForSubscriberDto } from './dtos/get-in-app-notification-feed-for-subscriber.dto';
import { GetSubscribersDto } from './dtos/get-subscribers.dto';
import { MarkAllMessageAsRequestDto } from './dtos/mark-all-messages-as-request.dto';
import { UpdateSubscriberOnlineFlagRequestDto } from './dtos/update-subscriber-online-flag-request.dto';
import { GetSubscriberPreferencesByLevelParams } from './params';
import { UnseenCountQueryDto } from './query-objects/unseen-count.query';
import { BulkCreateSubscribersCommand } from './usecases/bulk-create-subscribers';
import { BulkCreateSubscribers } from './usecases/bulk-create-subscribers/bulk-create-subscribers.usecase';
import { ChatOauthCommand } from './usecases/chat-oauth/chat-oauth.command';
import { ChatOauth } from './usecases/chat-oauth/chat-oauth.usecase';
import { ChatOauthCallbackCommand } from './usecases/chat-oauth-callback/chat-oauth-callback.command';
import { ResponseTypeEnum } from './usecases/chat-oauth-callback/chat-oauth-callback.result';
import { ChatOauthCallback } from './usecases/chat-oauth-callback/chat-oauth-callback.usecase';
import {
  DeleteSubscriberCredentials,
  DeleteSubscriberCredentialsCommand,
} from './usecases/delete-subscriber-credentials';
import { GetPreferencesByLevelCommand } from './usecases/get-preferences-by-level/get-preferences-by-level.command';
import { GetPreferencesByLevel } from './usecases/get-preferences-by-level/get-preferences-by-level.usecase';
import { GetSubscriber, GetSubscriberCommand } from './usecases/get-subscriber';
import { GetSubscribers, GetSubscribersCommand } from './usecases/get-subscribers';
import { RemoveSubscriber, RemoveSubscriberCommand } from './usecases/remove-subscriber';
import {
  UpdateSubscriberOnlineFlag,
  UpdateSubscriberOnlineFlagCommand,
} from './usecases/update-subscriber-online-flag';

@ThrottlerCategory(ApiRateLimitCategoryEnum.CONFIGURATION)
@ApiCommonResponses()
@ApiTags('Subscribers')
@Controller('/subscribers')
export class SubscribersV1Controller {
  constructor(
    private createSubscriberUsecase: CreateOrUpdateSubscriberUseCase,
    private bulkCreateSubscribersUsecase: BulkCreateSubscribers,
    private updateSubscriberUsecase: UpdateSubscriber,
    private updateSubscriberChannelUsecase: UpdateSubscriberChannel,
    private removeSubscriberUsecase: RemoveSubscriber,
    private getSubscriberUseCase: GetSubscriber,
    private getSubscribersUsecase: GetSubscribers,
    private getPreferenceUsecase: GetPreferencesByLevel,
    private updatePreferencesUsecase: UpdatePreferences,
    private getNotificationsFeedUsecase: GetNotificationsFeed,
    private getFeedCountUsecase: GetFeedCount,
    private markMessageAsUsecase: MarkMessageAs,
    private markMessageAsByMarkUsecase: MarkMessageAsByMark,
    private updateMessageActionsUsecase: UpdateMessageActions,
    private updateSubscriberOnlineFlagUsecase: UpdateSubscriberOnlineFlag,
    private chatOauthCallbackUsecase: ChatOauthCallback,
    private chatOauthUsecase: ChatOauth,
    private deleteSubscriberCredentialsUsecase: DeleteSubscriberCredentials,
    private markAllMessagesAsUsecase: MarkAllMessagesAs
  ) {}

  @Get('')
  @ExternalApiAccessible()
  @ApiExcludeEndpoint()
  @RequireAuthentication()
  @ApiOkPaginatedResponse(SubscriberResponseDto)
  @ApiOperation({
    summary: 'List all subscribers',
    description: `Returns a list of subscribers, could be paginated using the **page** and **limit** query parameter. 
    This API is deprecated, use v2 API instead.`,
    deprecated: true,
  })
  @SdkUsePagination()
  async listSubscribers(
    @UserSession() user: UserSessionData,
    @Query() query: GetSubscribersDto
  ): Promise<PaginatedResponseDto<SubscriberResponseDto>> {
    return await this.getSubscribersUsecase.execute(
      GetSubscribersCommand.create({
        organizationId: user.organizationId,
        environmentId: user.environmentId,
        page: query.page,
        limit: query.limit,
      })
    );
  }

  @Get('/:subscriberId')
  @ExternalApiAccessible()
  @RequireAuthentication()
  @ApiExcludeEndpoint()
  @ApiResponse(SubscriberResponseDto)
  @ApiOperation({
    summary: 'Retrieve a subscriber',
    description: `Retrieve a subscriber by its unique key identifier **subscriberId**. 
    This API is deprecated, use v2 API instead.`,
    deprecated: true,
  })
  @ApiQuery({
    name: 'includeTopics',
    type: Boolean,
    description: 'Includes the topics associated with the subscriber',
    required: false,
  })
  async getSubscriber(
    @UserSession() user: UserSessionData,
    @Param('subscriberId') subscriberId: string,
    @Query('includeTopics') includeTopics: string
  ): Promise<SubscriberResponseDto> {
    return this.getSubscriberUseCase.execute(
      GetSubscriberCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        subscriberId,
        includeTopics: includeTopics === 'true',
      })
    );
  }

  @Post('/')
  @ExternalApiAccessible()
  @ApiExcludeEndpoint()
  @ApiOperation({
    summary: 'Create a subscriber',
    description: `Create a new subscriber if it does not exist, or update an existing subscriber if it already exists. 
    This API is deprecated, use v2 API instead.`,
    deprecated: true,
  })
  @RequireAuthentication()
  async createSubscriber(
    @UserSession() user: UserSessionData,
    @Body() body: CreateSubscriberRequestDto
  ): Promise<SubscriberResponseDto> {
    return await this.createSubscriberUsecase.execute(
      CreateOrUpdateSubscriberCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        subscriberId: body.subscriberId,
        firstName: body.firstName,
        lastName: body.lastName,
        email: body.email,
        phone: body.phone,
        avatar: body.avatar,
        locale: body.locale,
        data: body.data,
        channels: body.channels,
      })
    );
  }

  @ThrottlerCost(ApiRateLimitCostEnum.BULK)
  @Post('/bulk')
  @ExternalApiAccessible()
  @RequireAuthentication()
  @ApiOperation({
    summary: 'Bulk create subscribers',
    description: `
      Using this endpoint multiple subscribers can be created at once. The bulk API is limited to 500 subscribers per request.
    `,
  })
  @ApiResponse(BulkCreateSubscriberResponseDto, 201)
  @SdkMethodName('createBulk')
  async bulkCreateSubscribers(
    @UserSession() user: UserSessionData,
    @Body() body: BulkSubscriberCreateDto
  ): Promise<BulkCreateSubscriberResponseDto> {
    return await this.bulkCreateSubscribersUsecase.execute(
      BulkCreateSubscribersCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        subscribers: body.subscribers,
      })
    );
  }

  @Put('/:subscriberId')
  @ExternalApiAccessible()
  @ApiExcludeEndpoint()
  @RequireAuthentication()
  @ApiResponse(SubscriberResponseDto)
  @ApiOperation({
    summary: 'Update a subscriber',
    description: `Update a subscriber by its unique key identifier **subscriberId**. 
    **firstName**, **lastName**, **email**, **phone**, **avatar**, **locale**, **data**, **channels** fields are optional. 
    This API is deprecated, use v2 API instead.`,
    deprecated: true,
  })
  @SdkMethodName('upsert')
  async updateSubscriber(
    @UserSession() user: UserSessionData,
    @Param('subscriberId') subscriberId: string,
    @Body() body: UpdateSubscriberRequestDto
  ): Promise<SubscriberResponseDto> {
    return await this.updateSubscriberUsecase.execute(
      UpdateSubscriberCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        subscriberId,
        firstName: body.firstName,
        lastName: body.lastName,
        email: body.email,
        phone: body.phone,
        avatar: body.avatar,
        locale: body.locale,
        data: body.data,
        channels: body.channels,
      })
    );
  }

  @Put('/:subscriberId/credentials')
  @ExternalApiAccessible()
  @RequireAuthentication()
  @ApiResponse(SubscriberResponseDto)
  @ApiOperation({
    summary: 'Upsert provider credentials',
    description: `Upsert credentials for a provider such as slack and push tokens. 
      **providerId** is required field. This API creates **deviceTokens** or appends to the existing ones.`,
  })
  @SdkGroupName('Subscribers.Credentials')
  async updateSubscriberChannel(
    @UserSession() user: UserSessionData,
    @Param('subscriberId') subscriberId: string,
    @Body() body: UpdateSubscriberChannelRequestDto
  ): Promise<SubscriberResponseDto> {
    return await this.updateSubscriberChannelUsecase.execute(
      UpdateSubscriberChannelCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        subscriberId,
        providerId: body.providerId,
        credentials: body.credentials,
        integrationIdentifier: body.integrationIdentifier,
        oauthHandler: OAuthHandlerEnum.EXTERNAL,
        isIdempotentOperation: true,
      })
    );
  }

  @Patch('/:subscriberId/credentials')
  @ExternalApiAccessible()
  @RequireAuthentication()
  @ApiResponse(SubscriberResponseDto)
  @ApiOperation({
    summary: 'Update provider credentials',
    description: `Update credentials for a provider such as **slack** and **FCM**. 
      **providerId** is required field. This API creates the **deviceTokens** or replaces the existing ones.`,
  })
  @SdkGroupName('Subscribers.Credentials')
  @SdkMethodName('append')
  async modifySubscriberChannel(
    @UserSession() user: UserSessionData,
    @Param('subscriberId') subscriberId: string,
    @Body() body: UpdateSubscriberChannelRequestDto
  ): Promise<SubscriberResponseDto> {
    return await this.updateSubscriberChannelUsecase.execute(
      UpdateSubscriberChannelCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        subscriberId,
        providerId: body.providerId,
        credentials: body.credentials,
        integrationIdentifier: body.integrationIdentifier,
        oauthHandler: OAuthHandlerEnum.EXTERNAL,
        isIdempotentOperation: false,
      })
    );
  }

  @Delete('/:subscriberId/credentials/:providerId')
  @ExternalApiAccessible()
  @RequireAuthentication()
  @ApiNoContentResponse()
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({
    summary: 'Delete provider credentials',
    description: `Delete subscriber credentials for a provider such as **slack** and **FCM** by **providerId**. 
    This action is irreversible and will remove the credentials for the provider for particular **subscriberId**.`,
  })
  @SdkGroupName('Subscribers.Credentials')
  async deleteSubscriberCredentials(
    @UserSession() user: UserSessionData,
    @Param('subscriberId') subscriberId: string,
    @Param('providerId') providerId: string
  ): Promise<void> {
    return await this.deleteSubscriberCredentialsUsecase.execute(
      DeleteSubscriberCredentialsCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        subscriberId,
        providerId,
      })
    );
  }

  @Patch('/:subscriberId/online-status')
  @ExternalApiAccessible()
  @RequireAuthentication()
  @ApiResponse(SubscriberResponseDto)
  @ApiOperation({
    summary: 'Update subscriber online status',
    description: 'Update the subscriber online status by its unique key identifier **subscriberId**',
  })
  @SdkGroupName('Subscribers.properties')
  @SdkMethodName('updateOnlineFlag')
  async updateSubscriberOnlineFlag(
    @UserSession() user: UserSessionData,
    @Param('subscriberId') subscriberId: string,
    @Body() body: UpdateSubscriberOnlineFlagRequestDto
  ): Promise<SubscriberResponseDto> {
    return await this.updateSubscriberOnlineFlagUsecase.execute(
      UpdateSubscriberOnlineFlagCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        subscriberId,
        isOnline: body.isOnline,
      })
    );
  }

  @Delete('/:subscriberId')
  @ExternalApiAccessible()
  @RequireAuthentication()
  @ApiResponse(DeleteSubscriberResponseDto)
  @ApiOperation({
    summary: 'Delete a subscriber',
    description: `Delete a subscriber by its unique key identifier **subscriberId**. 
    This action is irreversible. 
    This API is deprecated, use v2 API instead.`,
    deprecated: true,
  })
  @ApiExcludeEndpoint()
  async removeSubscriber(
    @UserSession() user: UserSessionData,
    @Param('subscriberId') subscriberId: string
  ): Promise<DeleteSubscriberResponseDto> {
    return await this.removeSubscriberUsecase.execute(
      RemoveSubscriberCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        subscriberId,
      })
    );
  }

  @Get('/:subscriberId/preferences')
  @ExternalApiAccessible()
  @RequireAuthentication()
  @ApiResponse(UpdateSubscriberPreferenceResponseDto, 200, true)
  @ApiOperation({
    summary: 'Retrieve subscriber preferences',
    description: `Retrieve subscriber channel preferences by its unique key identifier **subscriberId**. 
      This API returns all five channels preferences for all workflows.`,
    deprecated: true,
  })
  @ApiQuery({
    name: 'includeInactiveChannels',
    type: Boolean,
    required: false,
    description:
      'A flag which specifies if the inactive workflow channels should be included in the retrieved preferences. Default is true',
  })
  @SdkGroupName('Subscribers.Preferences')
  @ApiExcludeEndpoint()
  async listSubscriberPreferences(
    @UserSession() user: UserSessionData,
    @Param('subscriberId') subscriberId: string,
    @Query('includeInactiveChannels') includeInactiveChannels: boolean
  ): Promise<UpdateSubscriberPreferenceResponseDto[]> {
    const command = GetPreferencesByLevelCommand.create({
      organizationId: user.organizationId,
      subscriberId,
      environmentId: user.environmentId,
      level: PreferenceLevelEnum.TEMPLATE,
      includeInactiveChannels: includeInactiveChannels ?? true,
    });

    return (await this.getPreferenceUsecase.execute(command)) as UpdateSubscriberPreferenceResponseDto[];
  }

  @Get('/:subscriberId/preferences/:parameter')
  @ExternalApiAccessible()
  @RequireAuthentication()
  @ApiExcludeEndpoint()
  @ApiOperation({
    summary: 'Retrieve subscriber preferences',
    description: `Retrieve subscriber channel preferences by its unique key identifier **subscriberId** and level field **parameter**. 
      **parameter** field can be **global** or **template**. **template** value is default value, it is synonym with workflow. 
      This API is deprecated, use v2 API instead.`,
    deprecated: true,
  })
  async getSubscriberPreferenceByLevel(
    @UserSession() user: UserSessionData,
    @Param() { parameter, subscriberId }: GetSubscriberPreferencesByLevelParams,
    @Query('includeInactiveChannels') includeInactiveChannels: boolean
  ): Promise<GetSubscriberPreferencesResponseDto[]> {
    const command = GetPreferencesByLevelCommand.create({
      organizationId: user.organizationId,
      subscriberId,
      environmentId: user.environmentId,
      level: parameter,
      includeInactiveChannels: includeInactiveChannels ?? true,
    });

    return await this.getPreferenceUsecase.execute(command);
  }

  // @ts-ignore
  @Patch('/:subscriberId/preferences/:parameter')
  @ExternalApiAccessible()
  @RequireAuthentication()
  @ApiExcludeEndpoint()
  @ApiOperation({
    summary: 'Update subscriber preferences',
    description: `Update subscriber channel preferences by its unique key identifier **subscriberId** and level field **parameter**. 
      **parameter** field can be **global** or **template**. **template** value is default value, it is synonym with workflow. 
      This API is deprecated, use v2 API instead.`,
    deprecated: true,
  })
  async updateSubscriberPreference(
    @UserSession() user: UserSessionData,
    @Param('subscriberId') subscriberId: string,
    @Param('parameter') workflowId: string,
    @Body() body: UpdateSubscriberPreferenceRequestDto
  ): Promise<UpdateSubscriberPreferenceResponseDto> {
    const result = await this.updatePreferencesUsecase.execute(
      UpdatePreferencesCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        subscriberId,
        workflowIdOrIdentifier: workflowId,
        level: PreferenceLevelEnum.TEMPLATE,
        includeInactiveChannels: true,
        ...(body.channel && { [body.channel.type]: body.channel.enabled }),
      })
    );

    if (!result.workflow) throw new NotFoundException('Workflow not found');

    return {
      preference: {
        channels: result.channels,
        enabled: result.enabled,
      },
      template: {
        _id: result.workflow.id,
        name: result.workflow.name,
        critical: result.workflow.critical,
        tags: result.workflow.tags,
        data: result.workflow.data,
        triggers: [
          {
            identifier: result.workflow.identifier,
            type: TriggerTypeEnum.EVENT,
            variables: [],
          },
        ],
      },
    };
  }

  @Patch('/:subscriberId/preferences')
  @ExternalApiAccessible()
  @RequireAuthentication()
  @ApiExcludeEndpoint()
  @ApiOperation({
    summary: 'Update subscriber global preferences',
    description: `Update subscriber global preferences by its unique key identifier **subscriberId**. 
    This API is deprecated, use v2 API instead.`,
    deprecated: true,
  })
  async updateSubscriberGlobalPreferences(
    @UserSession() user: UserSessionData,
    @Param('subscriberId') subscriberId: string,
    @Body() body: UpdateSubscriberGlobalPreferencesRequestDto
  ): Promise<UpdateSubscriberPreferenceGlobalResponseDto> {
    const channels = body.preferences?.reduce((acc, curr) => {
      acc[curr.type] = curr.enabled;

      return acc;
    }, {} as IPreferenceChannels);

    const result = await this.updatePreferencesUsecase.execute(
      UpdatePreferencesCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        subscriberId,
        level: PreferenceLevelEnum.GLOBAL,
        includeInactiveChannels: true,
        ...channels,
      })
    );

    return {
      preference: {
        channels: result.channels,
        enabled: result.enabled,
      },
    };
  }

  @ExternalApiAccessible()
  @RequireAuthentication()
  @Get('/:subscriberId/notifications/feed')
  @ApiOperation({
    summary: 'Retrieve subscriber notifications',
    description: `Retrieve subscriber in-app (inbox) notifications by its unique key identifier **subscriberId**.`,
  })
  @ApiResponse(FeedResponseDto)
  @SdkGroupName('Subscribers.Notifications')
  @SdkMethodName('feed')
  async getNotificationsFeed(
    @UserSession() user: UserSessionData,
    @Param('subscriberId') subscriberId: string,
    @Query() query: GetInAppNotificationsFeedForSubscriberDto
  ): Promise<FeedResponseDto> {
    let feedsQuery: string[] | undefined;
    if (query.feedIdentifier) {
      feedsQuery = Array.isArray(query.feedIdentifier) ? query.feedIdentifier : [query.feedIdentifier];
    }

    const command = GetNotificationsFeedCommand.create({
      organizationId: user.organizationId,
      environmentId: user.environmentId,
      subscriberId,
      page: query.page,
      feedId: feedsQuery,
      query: { seen: query.seen, read: query.read },
      limit: query.limit,
      payload: query.payload,
    });

    return await this.getNotificationsFeedUsecase.execute(command);
  }

  @ExternalApiAccessible()
  @RequireAuthentication()
  @Get('/:subscriberId/notifications/unseen')
  @ApiResponse(UnseenCountResponse)
  @ApiOperation({
    summary: 'Retrieve unseen notifications count',
    description: `Retrieve unseen in-app (inbox) notifications count for a subscriber by its unique key identifier **subscriberId**.`,
  })
  @SdkGroupName('Subscribers.Notifications')
  @SdkMethodName('unseenCount')
  async getUnseenCount(
    @UserSession() user: UserSessionData,
    @Param('subscriberId') subscriberId: string,
    @Query() query: UnseenCountQueryDto
  ): Promise<UnseenCountResponse> {
    let feedsQuery: string[] | undefined;

    if (query.feedId) {
      feedsQuery = Array.isArray(query.feedId) ? query.feedId : [query.feedId];
    }

    if (query.seen === undefined) {
      query.seen = false;
    }

    const command = GetFeedCountCommand.create({
      organizationId: user.organizationId,
      subscriberId,
      environmentId: user.environmentId,
      feedId: feedsQuery,
      seen: query.seen,
      limit: query.limit || 100,
    });

    return await this.getFeedCountUsecase.execute(command);
  }

  @ApiExcludeEndpoint()
  @ExternalApiAccessible()
  @RequireAuthentication()
  @Post('/:subscriberId/messages/markAs')
  @ApiOperation({
    summary: 'Mark a subscriber feed messages as seen or as read',
    description: `Introducing '/:subscriberId/messages/mark-as endpoint for consistent read and seen message handling,
     deprecating old legacy endpoint.`,
    deprecated: true,
  })
  @SdkGroupName('Subscribers.Messages')
  @SdkMethodName('markAs')
  @ApiResponse(MessageResponseDto, 201, true)
  async markMessageAs(
    @UserSession() user: UserSessionData,
    @Param('subscriberId') subscriberId: string,
    @Body() body: MarkMessageAsRequestDto
  ): Promise<MessageEntity[]> {
    if (!body.messageId) throw new BadRequestException('messageId is required');

    const messageIds = this.toArray(body.messageId);
    if (!messageIds) throw new BadRequestException('messageId is required');

    const command = MarkMessageAsCommand.create({
      organizationId: user.organizationId,
      subscriberId,
      environmentId: user.environmentId,
      messageIds,
      mark: body.mark,
    });

    return await this.markMessageAsUsecase.execute(command);
  }

  @ApiOperation({
    summary: 'Update notifications state',
    description: `Update subscriber's multiple in-app (inbox) notifications state such as seen, read, unseen or unread by **subscriberId**. 
      **messageId** is of type mongodbId of notifications`,
  })
  @ExternalApiAccessible()
  @RequireAuthentication()
  @Post('/:subscriberId/messages/mark-as')
  @SdkGroupName('Subscribers.Messages')
  @SdkMethodName('markAllAs')
  @ApiResponse(MessageResponseDto, 201, true)
  async markMessagesAs(
    @UserSession() user: UserSessionData,
    @Param('subscriberId') subscriberId: string,
    @Body() body: MessageMarkAsRequestDto
  ): Promise<MessageResponseDto[]> {
    const messageIds = this.toArray(body.messageId);
    if (!messageIds || messageIds.length === 0) throw new BadRequestException('messageId is required');

    return await this.markMessageAsByMarkUsecase.execute(
      MarkMessageAsByMarkCommand.create({
        organizationId: user.organizationId,
        subscriberId,
        environmentId: user.environmentId,
        messageIds,
        markAs: body.markAs,
        __source: 'api',
      })
    );
  }

  @ExternalApiAccessible()
  @RequireAuthentication()
  @Post('/:subscriberId/messages/mark-all')
  @ApiOperation({
    summary: 'Update all notifications state',
    description: `Update all subscriber in-app (inbox) notifications state such as read, unread, seen or unseen by **subscriberId**.`,
  })
  @ApiCreatedResponse({
    type: Number,
  })
  @SdkGroupName('Subscribers.Messages')
  @SdkMethodName('markAll')
  async markAllUnreadAsRead(
    @UserSession() user: UserSessionData,
    @Param('subscriberId') subscriberId: string,
    @Body() body: MarkAllMessageAsRequestDto
  ): Promise<number> {
    const feedIdentifiers = this.toArray(body.feedIdentifier);

    return await this.markAllMessagesAsUsecase.execute(
      MarkAllMessagesAsCommand.create({
        organizationId: user.organizationId,
        subscriberId,
        environmentId: user.environmentId,
        markAs: body.markAs,
        feedIdentifiers,
      })
    );
  }

  @ExternalApiAccessible()
  @RequireAuthentication()
  @Post('/:subscriberId/messages/:messageId/actions/:type')
  @ApiOperation({
    summary: 'Update notification action status',
    description: `Update in-app (inbox) notification's action status by its unique key identifier **messageId** and type field **type**. 
      **type** field can be **primary** or **secondary**`,
  })
  @ApiResponse(MessageResponseDto, 201)
  @SdkGroupName('Subscribers.Messages')
  @SdkMethodName('updateAsSeen')
  async markActionAsSeen(
    @UserSession() user: UserSessionData,
    @Param('messageId') messageId: string,
    @Param('type') type: ButtonTypeEnum,
    @Body() body: MarkMessageActionAsSeenDto,
    @Param('subscriberId') subscriberId: string
  ): Promise<MessageResponseDto> {
    return await this.updateMessageActionsUsecase.execute(
      UpdateMessageActionsCommand.create({
        organizationId: user.organizationId,
        environmentId: user.environmentId,
        subscriberId,
        messageId,
        type,
        payload: body.payload,
        status: body.status,
      })
    );
  }

  @ExternalApiAccessible()
  @Get('/:subscriberId/credentials/:providerId/oauth/callback')
  @ApiExcludeEndpoint()
  @ApiOperation({
    summary: 'Handle slack oauth redirect',
    description: `Handle slack oauth redirect by its unique key identifier **subscriberId** and providerId **providerId**.`,
  })
  @ApiResponse(String, 200, false, false, {
    status: 200,
    description: 'Returns plain text response.',
    schema: undefined,
    content: {
      'text/html': {
        schema: {
          type: 'string',
        },
      },
    },
  })
  @ApiFoundResponse({
    type: String,
    status: 302,
    description: 'Redirects to the specified URL.',
    headers: {
      Location: { description: 'The URL to redirect to.', schema: { type: 'string', example: 'https://www.novu.co' } },
    },
  }) // Link to the interface
  @SdkGroupName('Subscribers.Authentication')
  @SdkMethodName('chatAccessOauthCallBack')
  async chatOauthCallback(
    @Param('subscriberId') subscriberId: string,
    @Param('providerId') providerId: ChatProviderIdEnum,
    @Query() query: ChatOauthCallbackRequestDto,
    @Res() res: any
  ): Promise<void> {
    const callbackResult = await this.chatOauthCallbackUsecase.execute(
      ChatOauthCallbackCommand.create({
        providerCode: query?.code,
        hmacHash: query?.hmacHash,
        environmentId: query?.environmentId,
        integrationIdentifier: query?.integrationIdentifier,
        subscriberId,
        providerId,
      })
    );
    if (callbackResult.typeOfResponse !== ResponseTypeEnum.URL) {
      res.setHeader('Content-Type', 'text/html');
      res.setHeader('Content-Security-Policy', "default-src 'self'; script-src 'self' 'unsafe-inline'");
      res.send(callbackResult.resultString);

      return;
    }
    res.redirect(callbackResult.resultString); // Return the URL to redirect to
  }

  @ExternalApiAccessible()
  @ApiExcludeEndpoint()
  @Get('/:subscriberId/credentials/:providerId/oauth')
  @ApiOperation({
    summary: 'Handle chat oauth',
  })
  @SdkGroupName('Subscribers.Authentication')
  @SdkMethodName('chatAccessOauth')
  async chatAccessOauth(
    @Param('subscriberId') subscriberId: string,
    @Param('providerId') providerId: ChatProviderIdEnum,
    @Res() res,
    @Query() query: ChatOauthRequestDto
  ): Promise<void> {
    const data = await this.chatOauthUsecase.execute(
      ChatOauthCommand.create({
        hmacHash: query?.hmacHash,
        environmentId: query?.environmentId,
        integrationIdentifier: query?.integrationIdentifier,
        subscriberId,
        providerId,
      })
    );

    res.redirect(data);
  }

  private toArray(param?: string[] | string): string[] | undefined {
    let paramArray: string[] | undefined;
    if (param) {
      paramArray = Array.isArray(param) ? param : param.split(',');
    }

    return paramArray;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - channels(body.preferences?.reduce((acc, curr))
Declaraciones 'export' encontradas:
- export class SubscribersV1Controller

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/subscribersV1.module.ts
Tamaño: 838 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { forwardRef, Module } from '@nestjs/common';
import { TerminusModule } from '@nestjs/terminus';
import { AuthModule } from '../auth/auth.module';

import { OutboundWebhooksModule } from '../outbound-webhooks/outbound-webhooks.module';
import { PreferencesModule } from '../preferences';
import { SharedModule } from '../shared/shared.module';
import { WidgetsModule } from '../widgets/widgets.module';
import { SubscribersV1Controller } from './subscribersV1.controller';
import { USE_CASES } from './usecases';

@Module({
  imports: [
    SharedModule,
    AuthModule,
    TerminusModule,
    forwardRef(() => WidgetsModule),
    PreferencesModule,
    OutboundWebhooksModule.forRoot(),
  ],
  controllers: [SubscribersV1Controller],
  providers: [...USE_CASES],
  exports: [...USE_CASES],
})
export class SubscribersV1Module {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SubscribersV1Module

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/dtos/bulk-create-subscriber-response.dto.ts
Tamaño: 1274 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';

export class FailedOperationDto {
  @ApiPropertyOptional({
    description: 'The error message associated with the failed operation.',
  })
  message: string;

  @ApiPropertyOptional({
    description: 'The subscriber ID associated with the failed operation. This field is optional.',
    required: false,
  })
  subscriberId?: string;
}

export class UpdatedSubscriberDto {
  @ApiProperty({
    description: 'The ID of the subscriber that was updated.',
  })
  subscriberId: string;
}

export class CreatedSubscriberDto {
  @ApiProperty({
    description: 'The ID of the subscriber that was created.',
  })
  subscriberId: string;
}

export class BulkCreateSubscriberResponseDto {
  @ApiProperty({
    description: 'An array of subscribers that were successfully updated.',
    type: [UpdatedSubscriberDto],
  })
  updated: UpdatedSubscriberDto[];

  @ApiProperty({
    description: 'An array of subscribers that were successfully created.',
    type: [CreatedSubscriberDto],
  })
  created: CreatedSubscriberDto[];

  @ApiProperty({
    description: 'An array of failed operations with error messages and optional subscriber IDs.',
    type: [FailedOperationDto],
  })
  failed: FailedOperationDto[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class FailedOperationDto
- export class UpdatedSubscriberDto
- export class CreatedSubscriberDto
- export class BulkCreateSubscriberResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/dtos/channelSettingsDto.ts
Tamaño: 376 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { UpdateSubscriberChannelRequestDto } from './update-subscriber-channel-request.dto';

export class ChannelSettingsDto extends UpdateSubscriberChannelRequestDto {
  @ApiProperty({
    description: 'The unique identifier of the integration associated with this channel.',
    type: String,
  })
  _integrationId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ChannelSettingsDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/dtos/chat-oauth-request.dto.ts
Tamaño: 870 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IsOptional, IsString } from 'class-validator';

export class ChatOauthRequestDto {
  @ApiProperty({
    description: 'HMAC hash for the request',
    type: String,
  })
  hmacHash: string;

  @ApiProperty({
    description: 'The ID of the environment, must be a valid MongoDB ID',
    type: String,
    required: true,
  })
  environmentId: string;

  @ApiProperty({
    description: 'Optional integration identifier',
    type: String,
    required: false,
  })
  @IsOptional()
  @IsString()
  integrationIdentifier?: string;
}

export class ChatOauthCallbackRequestDto extends ChatOauthRequestDto {
  @ApiProperty({
    description: 'Optional authorization code returned from the OAuth provider',
    type: String,
    required: true,
  })
  @IsString()
  code: string; // Make sure to define code as optional
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ChatOauthRequestDto
- export class ChatOauthCallbackRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/dtos/create-subscriber-request.dto.ts
Tamaño: 3807 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { ChatProviderIdEnum, IChannelCredentials, PushProviderIdEnum, SubscriberCustomData } from '@novu/shared';
import { Type } from 'class-transformer';
import {
  ArrayNotEmpty,
  IsArray,
  IsDefined,
  IsEmail,
  IsLocale,
  IsNotEmpty,
  IsObject,
  IsOptional,
  IsString,
  IsTimeZone,
  Matches,
  ValidateNested,
} from 'class-validator';

export class ChannelCredentialsDto implements IChannelCredentials {
  @ApiPropertyOptional({
    description: 'The URL for the webhook associated with the channel.',
    type: String,
  })
  @IsOptional()
  @IsString()
  webhookUrl?: string;

  @ApiPropertyOptional({
    description: 'An array of device tokens for push notifications.',
    type: [String],
  })
  @IsOptional()
  @IsArray()
  deviceTokens?: string[];
}

export class SubscriberChannelDto {
  @ApiProperty({
    description: 'The ID of the chat or push provider.',
    enum: [...Object.values(ChatProviderIdEnum), ...Object.values(PushProviderIdEnum)],
  })
  providerId: ChatProviderIdEnum | PushProviderIdEnum;

  @ApiPropertyOptional({
    description: 'An optional identifier for the integration.',
    type: String,
  })
  @IsOptional()
  integrationIdentifier?: string;

  @ApiProperty({
    description: 'Credentials for the channel.',
    type: ChannelCredentialsDto,
  })
  @ValidateNested()
  @Type(() => ChannelCredentialsDto)
  credentials: ChannelCredentialsDto;
}

export class CreateSubscriberRequestDto {
  @ApiProperty({
    description:
      'The internal identifier you used to create this subscriber, usually correlates to the id the user in your systems',
  })
  @IsString()
  @IsDefined()
  @IsNotEmpty({
    message: 'SubscriberId is required',
  })
  subscriberId: string;

  @ApiPropertyOptional({
    description: 'The email address of the subscriber.',
  })
  @IsEmail()
  @IsOptional()
  email?: string;

  @ApiPropertyOptional({
    description: 'The first name of the subscriber.',
  })
  @IsString()
  @IsOptional()
  firstName?: string;

  @ApiPropertyOptional({
    description: 'The last name of the subscriber.',
  })
  @IsString()
  @IsOptional()
  lastName?: string;

  @ApiPropertyOptional({
    description: 'The phone number of the subscriber.',
  })
  @IsString()
  @IsOptional()
  phone?: string;

  @ApiPropertyOptional({
    description: 'An HTTP URL to the profile image of your subscriber.',
  })
  @IsString()
  @IsOptional()
  avatar?: string;

  @ApiPropertyOptional({
    description: 'The locale of the subscriber.',
  })
  @IsLocale()
  @IsOptional()
  locale?: string;

  @ApiPropertyOptional({
    type: 'object',
    description: 'An optional payload object that can contain any properties.',
    required: false,
    additionalProperties: {
      oneOf: [
        { type: 'string' },
        { type: 'array', items: { type: 'string' } },
        { type: 'boolean' },
        { type: 'number' },
      ],
    },
  })
  @IsOptional()
  @IsObject()
  data?: SubscriberCustomData;

  @ApiPropertyOptional({
    type: [SubscriberChannelDto],
    description: 'An optional array of subscriber channels.',
  })
  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => SubscriberChannelDto)
  channels?: SubscriberChannelDto[];

  @ApiPropertyOptional({
    type: 'string',
    description: 'The timezone of the subscriber.',
  })
  @IsOptional()
  @IsTimeZone()
  timezone?: string;
}

export class BulkSubscriberCreateDto {
  @ApiProperty({
    description: 'An array of subscribers to be created in bulk.',
    type: [CreateSubscriberRequestDto], // Specify the type of the array elements
  })
  @IsArray()
  @ArrayNotEmpty()
  @ValidateNested({ each: true })
  @Type(() => CreateSubscriberRequestDto)
  subscribers: CreateSubscriberRequestDto[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ChannelCredentialsDto
- export class SubscriberChannelDto
- export class CreateSubscriberRequestDto
- export class BulkSubscriberCreateDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/dtos/delete-subscriber-response.dto.ts
Tamaño: 454 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IsBoolean, IsDefined, IsString } from 'class-validator';

export class DeleteSubscriberResponseDto {
  @ApiProperty({
    description: 'A boolean stating the success of the action',
  })
  @IsBoolean()
  @IsDefined()
  acknowledged: boolean;

  @ApiProperty({
    description: 'The status enum for the performed action',
    enum: ['deleted'],
  })
  @IsString()
  @IsDefined()
  status: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DeleteSubscriberResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/dtos/get-in-app-notification-feed-for-subscriber.dto.ts
Tamaño: 951 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional } from '@nestjs/swagger';
import { PaginationRequestDto } from '../../shared/dtos/pagination-request';

const LIMIT = {
  DEFAULT: 10,
  MAX: 100,
};

export class GetInAppNotificationsFeedForSubscriberDto extends PaginationRequestDto(LIMIT.DEFAULT, LIMIT.MAX) {
  @ApiPropertyOptional({
    required: false,
    oneOf: [
      { type: 'string' },
      {
        type: 'array',
        items: {
          type: 'string',
        },
      },
    ],
  })
  feedIdentifier: string | string[];

  @ApiPropertyOptional({ required: false, type: Boolean })
  read: boolean;

  @ApiPropertyOptional({ required: false, type: Boolean })
  seen: boolean;

  @ApiPropertyOptional({
    required: false,
    type: 'string',
    description: 'Base64 encoded string of the partial payload JSON object',
    example: 'btoa(JSON.stringify({ foo: 123 })) results in base64 encoded string like eyJmb28iOjEyM30=',
  })
  payload?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetInAppNotificationsFeedForSubscriberDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/dtos/get-subscriber-preferences-response.dto.ts
Tamaño: 689 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { SubscriberPreferenceDto } from './subscriber-preference.dto';
import { SubscriberPreferenceTemplateResponseDto } from './subscriber-preference-template-response.dto';

export class GetSubscriberPreferencesResponseDto {
  @ApiPropertyOptional({
    type: SubscriberPreferenceTemplateResponseDto,
    description: 'The workflow information and if it is critical or not',
  })
  template?: SubscriberPreferenceTemplateResponseDto;

  @ApiProperty({
    type: SubscriberPreferenceDto,
    description: 'The preferences of the subscriber regarding the related workflow',
  })
  preference: SubscriberPreferenceDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetSubscriberPreferencesResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/dtos/get-subscribers.dto.ts
Tamaño: 214 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { PaginationRequestDto } from '../../shared/dtos/pagination-request';

const LIMIT = {
  DEFAULT: 10,
  MAX: 100,
};

export class GetSubscribersDto extends PaginationRequestDto(LIMIT.DEFAULT, LIMIT.MAX) {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetSubscribersDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/dtos/index.ts
Tamaño: 667 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './channelSettingsDto';
export * from './create-subscriber-request.dto';
export * from './delete-subscriber-response.dto';
export * from './get-subscriber-preferences-response.dto';
export * from './subscriber-feed-response.dto';
export * from './subscriber-preference.dto';
export * from './subscriber-preference-override.dto';
export * from './subscriber-preference-template-response.dto';
export * from './subscriber-response.dto';
export * from './subscribers-response.dto';
export * from './update-subscriber-channel-request.dto';
export * from './update-subscriber-global-preferences-request.dto';
export * from './update-subscriber-request.dto';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/dtos/mark-all-messages-as-request.dto.ts
Tamaño: 610 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { MessagesStatusEnum } from '@novu/shared';

export class MarkAllMessageAsRequestDto {
  @ApiPropertyOptional({
    oneOf: [
      { type: 'string' },
      {
        type: 'array',
        items: {
          type: 'string',
        },
      },
    ],
    description: 'Optional feed identifier or array of feed identifiers',
  })
  feedIdentifier?: string | string[];

  @ApiProperty({
    enum: MessagesStatusEnum,
    description: 'Mark all subscriber messages as read, unread, seen or unseen',
  })
  markAs: MessagesStatusEnum;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class MarkAllMessageAsRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/dtos/subscriber-feed-response.dto.ts
Tamaño: 936 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';

export class SubscriberFeedResponseDto {
  @ApiPropertyOptional({
    description:
      'The internal ID generated by Novu for your subscriber. ' +
      'This ID does not match the `subscriberId` used in your queries. Refer to `subscriberId` for that identifier.',
    type: String,
  })
  _id?: string;

  @ApiProperty({
    description: 'The first name of the subscriber.',
    type: String,
  })
  firstName?: string;

  @ApiProperty({
    description: 'The last name of the subscriber.',
    type: String,
  })
  lastName?: string;

  @ApiPropertyOptional({
    description: "The URL of the subscriber's avatar image.",
    type: String,
  })
  avatar?: string;

  @ApiProperty({
    description:
      'The identifier used to create this subscriber, which typically corresponds to the user ID in your system.',
    type: String,
  })
  subscriberId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SubscriberFeedResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/dtos/subscriber-preference-override.dto.ts
Tamaño: 626 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { ChannelTypeEnum, IPreferenceOverride, PreferenceOverrideSourceEnum } from '@novu/shared';

export class SubscriberPreferenceOverrideDto implements IPreferenceOverride {
  @ApiProperty({
    enum: [...Object.values(ChannelTypeEnum)],
    enumName: 'ChannelTypeEnum',
    description: 'The channel type which is overridden',
  })
  channel: ChannelTypeEnum;
  @ApiProperty({
    enum: [...Object.values(PreferenceOverrideSourceEnum)],
    enumName: 'PreferenceOverrideSourceEnum',
    description: 'The source of overrides',
  })
  source: PreferenceOverrideSourceEnum;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SubscriberPreferenceOverrideDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/dtos/subscriber-preference-template-response.dto.ts
Tamaño: 521 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';

export class SubscriberPreferenceTemplateResponseDto {
  @ApiProperty({
    description: 'Unique identifier of the workflow',
    type: String,
  })
  _id: string;

  @ApiProperty({
    description: 'Name of the workflow',
    type: String,
  })
  name: string;

  @ApiProperty({
    description:
      'Critical templates will always be delivered to the end user and should be hidden from the subscriber preferences screen',
    type: Boolean,
  })
  critical: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SubscriberPreferenceTemplateResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/dtos/subscriber-preference.dto.ts
Tamaño: 879 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { SubscriberPreferenceChannels } from '../../shared/dtos/preference-channels';
import { SubscriberPreferenceOverrideDto } from './subscriber-preference-override.dto';

export class SubscriberPreferenceDto {
  @ApiProperty({
    description: 'Sets if the workflow is fully enabled for all channels or not for the subscriber.',
    type: Boolean,
  })
  enabled: boolean;

  @ApiProperty({
    type: SubscriberPreferenceChannels,
    description: 'Subscriber preferences for the different channels regarding this workflow',
  })
  channels: SubscriberPreferenceChannels;

  @ApiPropertyOptional({
    type: [SubscriberPreferenceOverrideDto],
    description: 'Overrides for subscriber preferences for the different channels regarding this workflow',
  })
  overrides?: SubscriberPreferenceOverrideDto[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SubscriberPreferenceDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/dtos/subscriber-response.dto.ts
Tamaño: 3625 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { ChannelSettingsDto } from './channelSettingsDto';

export class SubscriberResponseDtoOptional {
  @ApiPropertyOptional({
    description:
      'The internal ID generated by Novu for your subscriber. ' +
      'This ID does not match the `subscriberId` used in your queries. Refer to `subscriberId` for that identifier.',
    type: String,
  })
  _id?: string;

  @ApiProperty({
    description: 'The first name of the subscriber.',
    type: String,
    nullable: true,
  })
  firstName?: string | null;

  @ApiProperty({
    description: 'The last name of the subscriber.',
    type: String,
    nullable: true,
  })
  lastName?: string | null;

  @ApiPropertyOptional({
    description: 'The email address of the subscriber.',
    type: String,
    nullable: true,
  })
  email?: string | null;

  @ApiPropertyOptional({
    description: 'The phone number of the subscriber.',
    type: String,
    nullable: true,
  })
  phone?: string | null;

  @ApiPropertyOptional({
    description: "The URL of the subscriber's avatar image.",
    type: String,
    nullable: true,
  })
  avatar?: string | null;

  @ApiPropertyOptional({
    description: 'The locale setting of the subscriber, indicating their preferred language or region.',
    type: String,
    nullable: true,
  })
  locale?: string | null;

  @ApiPropertyOptional({
    type: [ChannelSettingsDto],
    description: 'An array of channel settings associated with the subscriber.',
  })
  channels?: ChannelSettingsDto[];

  @ApiPropertyOptional({
    description: 'An array of topics that the subscriber is subscribed to.',
    type: [String],
    deprecated: true,
  })
  topics?: string[];

  @ApiProperty({
    description: 'Indicates whether the subscriber is currently online.',
    type: Boolean,
    nullable: true,
  })
  isOnline?: boolean | null;

  @ApiProperty({
    description: 'The timestamp indicating when the subscriber was last online, in ISO 8601 format.',
    type: String,
    nullable: true,
  })
  lastOnlineAt?: string | null;

  @ApiPropertyOptional({
    description: 'The version of the subscriber document.',
    type: Number,
  })
  __v?: number;

  @ApiPropertyOptional({
    type: 'object',
    description: 'Additional custom data for the subscriber',
    additionalProperties: true,
    nullable: true,
  })
  data?: Record<string, unknown> | null;

  @ApiPropertyOptional({
    description: 'Timezone of the subscriber',
    type: String,
    nullable: true,
  })
  timezone?: string | null;
}

export class SubscriberResponseDto extends SubscriberResponseDtoOptional {
  @ApiProperty({
    description:
      'The identifier used to create this subscriber, which typically corresponds to the user ID in your system.',
    type: String,
  })
  subscriberId: string;

  @ApiProperty({
    description: 'The unique identifier of the organization to which the subscriber belongs.',
    type: String,
  })
  _organizationId: string;

  @ApiProperty({
    description: 'The unique identifier of the environment associated with this subscriber.',
    type: String,
  })
  _environmentId: string;

  @ApiProperty({
    description: 'Indicates whether the subscriber has been deleted.',
    type: Boolean,
  })
  deleted: boolean;

  @ApiProperty({
    description: 'The timestamp indicating when the subscriber was created, in ISO 8601 format.',
    type: String,
  })
  createdAt: string;

  @ApiProperty({
    description: 'The timestamp indicating when the subscriber was last updated, in ISO 8601 format.',
    type: String,
  })
  updatedAt: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SubscriberResponseDtoOptional
- export class SubscriberResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/dtos/subscribers-response.dto.ts
Tamaño: 237 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { PaginatedResponseDto } from '../../shared/dtos/pagination-response';
import { SubscriberResponseDto } from './subscriber-response.dto';

export class SubscribersResponseDto extends PaginatedResponseDto<SubscriberResponseDto> {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SubscribersResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/dtos/update-subscriber-channel-request.dto.ts
Tamaño: 1237 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { ChatProviderIdEnum, ISubscriberChannel, PushProviderIdEnum } from '@novu/shared';
import { IsDefined, IsEnum, IsObject, IsOptional, IsString } from 'class-validator';

import { ChannelCredentials } from '../../shared/dtos/subscriber-channel';

export function getEnumValues<T>(enumObj: T): Array<T[keyof T]> {
  return Object.values(enumObj || {}) as Array<T[keyof T]>;
}
export class UpdateSubscriberChannelRequestDto implements ISubscriberChannel {
  @ApiProperty({
    enum: [...getEnumValues(ChatProviderIdEnum), ...getEnumValues(PushProviderIdEnum)],
    enumName: 'ChatOrPushProviderEnum',
    description: 'The provider identifier for the credentials',
  })
  @IsEnum(
    { ...ChatProviderIdEnum, ...PushProviderIdEnum },
    {
      message: 'providerId must be a valid provider ID',
    }
  )
  @IsDefined()
  providerId: ChatProviderIdEnum | PushProviderIdEnum;

  @ApiProperty({
    type: String,
    description: 'The integration identifier',
  })
  @IsString()
  @IsOptional()
  integrationIdentifier?: string;

  @ApiProperty({
    description: 'Credentials payload for the specified provider',
  })
  @IsDefined()
  @IsObject()
  credentials: ChannelCredentials;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export function getEnumValues
- export class UpdateSubscriberChannelRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/dtos/update-subscriber-global-preferences-request.dto.ts
Tamaño: 729 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { IsBoolean, IsOptional, ValidateNested } from 'class-validator';
import { ChannelPreference } from '../../shared/dtos/channel-preference';

export class UpdateSubscriberGlobalPreferencesRequestDto {
  @ApiPropertyOptional({
    description: 'Enable or disable the subscriber global preferences.',
    type: Boolean,
  })
  @IsBoolean()
  @IsOptional()
  enabled?: boolean;

  @ApiPropertyOptional({
    type: [ChannelPreference],
    description: 'The subscriber global preferences for every ChannelTypeEnum.',
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => ChannelPreference)
  preferences?: ChannelPreference[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateSubscriberGlobalPreferencesRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/dtos/update-subscriber-online-flag-request.dto.ts
Tamaño: 226 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IsBoolean, IsDefined } from 'class-validator';

export class UpdateSubscriberOnlineFlagRequestDto {
  @ApiProperty()
  @IsDefined()
  @IsBoolean()
  isOnline: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateSubscriberOnlineFlagRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/dtos/update-subscriber-request.dto.ts
Tamaño: 2180 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { Transform } from 'class-transformer';
import { IsArray, IsEmail, IsLocale, IsOptional, IsString } from 'class-validator';
import { SubscriberChannelDto } from './create-subscriber-request.dto';

// Define the type for custom data, allowing for additional properties
export class UpdateSubscriberRequestDto {
  @ApiProperty({
    description: 'The email address of the subscriber.',
    example: 'john.doe@example.com',
    required: false,
  })
  @Transform((params) => (params.value === '' ? null : params.value))
  @IsOptional()
  @IsEmail()
  email?: string;

  @ApiProperty({
    description: 'The first name of the subscriber.',
    example: 'John',
    required: false,
  })
  @IsString()
  @IsOptional()
  firstName?: string;

  @ApiProperty({
    description: 'The last name of the subscriber.',
    example: 'Doe',
    required: false,
  })
  @IsString()
  @IsOptional()
  lastName?: string;

  @ApiProperty({
    description: 'The phone number of the subscriber.',
    example: '+1234567890',
    required: false,
  })
  @IsString()
  @IsOptional()
  phone?: string;

  @ApiProperty({
    description: 'The avatar URL of the subscriber.',
    example: 'https://example.com/avatar.jpg',
    required: false,
  })
  @IsString()
  @IsOptional()
  avatar?: string;

  @ApiProperty({
    description: 'The locale of the subscriber, for example "en-US".',
    example: 'en-US',
    required: false,
  })
  @IsLocale()
  @IsOptional()
  locale?: string;

  @ApiProperty({
    description: 'Custom data associated with the subscriber. Can contain any additional properties.',
    type: 'object',
    additionalProperties: true, // Allow additional properties
    example: {
      preferences: {
        notifications: true,
        theme: 'dark',
      },
      tags: ['premium', 'newsletter'],
    },
    required: false,
  })
  @IsOptional()
  data?: {
    [key: string]: any;
  };

  @ApiProperty({
    description: 'An array of communication channels for the subscriber.',
    type: SubscriberChannelDto,
    isArray: true,
    required: false,
  })
  @IsOptional()
  @IsArray()
  channels?: SubscriberChannelDto[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateSubscriberRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/e2e/bulk-create-subscribers.e2e.ts
Tamaño: 5714 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { SubscriberEntity, SubscriberRepository } from '@novu/dal';
import { SubscribersService, UserSession } from '@novu/testing';
import { expect } from 'chai';
import { expectSdkValidationExceptionGeneric, initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Bulk create subscribers - /v1/subscribers/bulk (POST) #novu-v2', () => {
  let session: UserSession;
  let subscriber: SubscriberEntity;
  let subscriberService: SubscribersService;
  const subscriberRepository = new SubscriberRepository();
  let novuClient: Novu;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    subscriberService = new SubscribersService(session.organization._id, session.environment._id);
    subscriber = await subscriberService.createSubscriber();
    novuClient = initNovuClassSdk(session);
  });

  it('should return the response array in correct format', async () => {
    const bulkResult = await novuClient.subscribers.createBulk({
      subscribers: [
        {
          subscriberId: 'test1',
          firstName: 'sub1',
          email: 'sub1@test.co',
        },
        {
          subscriberId: 'test2',
          firstName: 'sub2',
          email: 'sub2@test.co',
        },
        { subscriberId: subscriber.subscriberId, firstName: 'update name' },
        { subscriberId: 'test2', firstName: 'update name' },
      ],
    });

    expect(bulkResult.result).to.be.ok;
    const { updated, created, failed } = bulkResult.result;

    expect(updated?.length).to.equal(2);
    expect(updated[0].subscriberId).to.equal(subscriber.subscriberId);
    expect(updated[1].subscriberId).to.equal('test2');

    expect(created?.length).to.equal(2);
    expect(created[0].subscriberId).to.equal('test1');
    expect(created[1].subscriberId).to.equal('test2');

    expect(failed?.length).to.equal(0);
  });

  it('should create and update subscribers', async () => {
    const res = await novuClient.subscribers.createBulk({
      subscribers: [
        {
          subscriberId: 'sub1',
          firstName: 'John',
          lastName: 'Doe',
          email: 'john@doe.com',
          phone: '+972523333333',
          locale: 'en',
          data: { test1: 'test value1', test2: 'test value2' },
        },
        {
          subscriberId: 'test2',
          firstName: 'sub2',
          email: 'sub2@test.co',
        },
        {
          subscriberId: 'test3',
          firstName: 'sub3',
          email: 'sub3@test.co',
        },
        { subscriberId: subscriber.subscriberId, firstName: 'update' },
        {
          subscriberId: 'test4',
          firstName: 'sub4',
          email: 'sub4@test.co',
        },
      ],
    });
    expect(res.result).to.be.ok;

    const createdSubscriber = await subscriberRepository.findBySubscriberId(session.environment._id, 'sub1');
    const updatedSubscriber = await subscriberRepository.findBySubscriberId(
      session.environment._id,
      subscriber.subscriberId
    );

    expect(updatedSubscriber?.firstName).to.equal('update');
    expect(createdSubscriber?.firstName).to.equal('John');
    expect(createdSubscriber?.email).to.equal('john@doe.com');
    expect(createdSubscriber?.phone).to.equal('+972523333333');
    expect(createdSubscriber?.locale).to.equal('en');
    expect(createdSubscriber?.data?.test1).to.equal('test value1');
  });

  it('should throw an error when sending more than 500 subscribers', async () => {
    const payload = {
      subscriberId: 'test2',
      firstName: 'sub2',
      email: 'sub2@test.co',
    };

    const { error } = await expectSdkValidationExceptionGeneric(() =>
      novuClient.subscribers.createBulk({
        subscribers: Array.from({ length: 501 }, () => payload),
      })
    );

    expect(error?.statusCode, JSON.stringify(error)).to.equal(422);
    expect(error?.errors.subscribers.messages[0], JSON.stringify(error)).to.equal(
      'subscribers must contain no more than 500 elements'
    );
  });

  it('should recreate deleted subscribers', async () => {
    const existingSubscriber = { subscriberId: subscriber.subscriberId, firstName: 'existingSubscriber' };
    const newSubscriber1 = {
      subscriberId: 'test1',
      firstName: 'sub1',
      email: 'sub1@test.co',
    };
    const newSubscriber2 = {
      subscriberId: 'test2',
      firstName: 'sub2',
      email: 'sub2@test.co',
    };
    let bulkResponse = await novuClient.subscribers.createBulk({
      subscribers: [existingSubscriber, newSubscriber1, newSubscriber2],
    });

    const { result } = bulkResponse;
    expect(result.created?.length).to.equal(2);
    expect(result.updated?.length).to.equal(1);
    expect(result.created[0].subscriberId).to.equal(newSubscriber1.subscriberId);
    expect(result.created[1].subscriberId).to.equal(newSubscriber2.subscriberId);
    expect(result.updated[0].subscriberId).to.equal(existingSubscriber.subscriberId);

    await novuClient.subscribers.delete(newSubscriber1.subscriberId);
    await novuClient.subscribers.delete(newSubscriber2.subscriberId);

    bulkResponse = await novuClient.subscribers.createBulk({
      subscribers: [existingSubscriber, newSubscriber1, newSubscriber2],
    });
    const secondResponseData = bulkResponse.result;
    expect(secondResponseData.created?.length).to.equal(2);
    expect(secondResponseData.updated?.length).to.equal(1);
    expect(secondResponseData.created[0].subscriberId).to.equal(newSubscriber1.subscriberId);
    expect(secondResponseData.created[1].subscriberId).to.equal(newSubscriber2.subscriberId);
    expect(secondResponseData.updated[0].subscriberId).to.equal(existingSubscriber.subscriberId);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - subscriberRepository(new SubscriberRepository();
  let novuClient: Novu;

  beforeEach(async ())
 - novuClient(initNovuClassSdk(session);
  });

  it('should return the response array in correct format', async (...)
 - updatedSubscriber(await subscriberRepository.findBySubscriberId(
      session.environment._id,
      subscriber.subsc...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/e2e/create-subscriber.e2e.ts
Tamaño: 1390 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { SubscriberRepository } from '@novu/dal';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Create Subscriber - /subscribers (POST) #novu-v2', () => {
  let session: UserSession;
  const subscriberRepository = new SubscriberRepository();
  let novuClient: Novu;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    novuClient = initNovuClassSdk(session);
  });

  it('should create a new subscriber', async () => {
    const response = await novuClient.subscribers.create({
      subscriberId: '123',
      firstName: 'John',
      lastName: 'Doe',
      email: 'john@doe.com',
      phone: '+972523333333',
      locale: 'en',
      data: { test1: 'test value1', test2: 'test value2' },
    });

    const body = response.result;

    expect(body).to.be.ok;
    const createdSubscriber = await subscriberRepository.findBySubscriberId(session.environment._id, '123');

    expect(createdSubscriber?.firstName).to.equal('John');
    expect(createdSubscriber?.email).to.equal('john@doe.com');
    expect(createdSubscriber?.phone).to.equal('+972523333333');
    expect(createdSubscriber?.locale).to.equal('en');
    expect(createdSubscriber?.data?.test1).to.equal('test value1');
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - subscriberRepository(new SubscriberRepository();
  let novuClient: Novu;

  beforeEach(async ())
 - novuClient(initNovuClassSdk(session);
  });

  it('should create a new subscriber', async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/e2e/get-notifications-feed.e2e.ts
Tamaño: 3871 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { NotificationTemplateEntity, SubscriberRepository } from '@novu/dal';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { expectSdkExceptionGeneric, initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Get Notifications feed - /:subscriberId/notifications/feed (GET) #novu-v2', () => {
  let session: UserSession;
  let template: NotificationTemplateEntity;
  let subscriberId: string;
  let novuClient: Novu;
  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    novuClient = initNovuClassSdk(session);

    template = await session.createTemplate({
      noFeedId: false,
    });

    subscriberId = SubscriberRepository.createObjectId();
  });

  it('should throw exception on invalid subscriber id', async () => {
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    const notificationsFeedResponse = (await novuClient.subscribers.notifications.feed({ limit: 5, subscriberId }))
      .result;
    expect(notificationsFeedResponse.pageSize).to.equal(5);
    const { error } = await expectSdkExceptionGeneric(() =>
      novuClient.subscribers.notifications.feed({
        subscriberId: `${subscriberId}111`,
        seen: false,
        limit: 5,
      })
    );
    expect(error).to.be.ok;
    expect(error?.statusCode).to.equals(400);
    expect(error?.message).to.eq(
      `Subscriber not found for this environment with the id: ${`${subscriberId}111`}. Make sure to create a subscriber before fetching the feed.`
    );
  });

  it('should throw exception when invalid payload query param is passed', async () => {
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    const { error: err } = await expectSdkExceptionGeneric(() =>
      novuClient.subscribers.notifications.feed({
        limit: 5,
        payload: 'invalid',
        subscriberId,
      })
    );
    expect(err?.statusCode).to.equals(400);
    expect(err?.message).to.eq(`Invalid payload, the JSON object should be encoded to base64 string.`);
  });

  it('should allow filtering by custom data from the payload', async () => {
    const partialPayload = { foo: 123 };
    const payload = { ...partialPayload, bar: 'bar' };

    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId, payload });
    await session.waitForJobCompletion(template._id);

    const payloadQueryValue = Buffer.from(JSON.stringify(partialPayload)).toString('base64');
    const { data } = (
      await novuClient.subscribers.notifications.feed({ limit: 5, payload: payloadQueryValue, subscriberId })
    ).result;

    expect(data.length).to.equal(1);
    expect(data[0].payload).to.deep.equal(payload);
  });

  it('should allow filtering by custom nested data from the payload', async () => {
    const partialPayload = { foo: { bar: 123 } };
    const payload = { ...partialPayload, baz: 'baz' };

    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId, payload });
    await session.waitForJobCompletion(template._id);

    const payloadQueryValue = Buffer.from(JSON.stringify(partialPayload)).toString('base64');
    const { data } = (
      await novuClient.subscribers.notifications.feed({
        limit: 5,
        payload: payloadQueryValue,
        subscriberId,
      })
    ).result;

    expect(data.length).to.equal(1);
    expect(data[0].payload).to.deep.equal(payload);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - subscriberId(SubscriberRepository.createObjectId();
  });

  it('should throw exception on invalid subscriber id'...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/e2e/get-subscriber.e2e.ts
Tamaño: 946 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Get Subscriber - /subscribers/:id (GET) #novu-v2', () => {
  let session: UserSession;
  let novuClient: Novu;
  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    novuClient = initNovuClassSdk(session);
  });

  const subscriberId = 'sub_42';
  it('should return a subscriber by id', async () => {
    const createResponse = await novuClient.subscribers.create({
      subscriberId,
      firstName: 'John',
      lastName: 'Doe',
      email: 'john@doe.com',
    });

    const response = await novuClient.subscribers.retrieve(subscriberId);

    const subscriber = response.result;
    expect(subscriber.subscriberId).to.equal(subscriberId);
    expect(subscriber.topics).to.be.undefined;
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - subscriberId('sub_42';
  it('should return a subscriber by id', async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/e2e/get-unseen-count.e2e.ts
Tamaño: 1785 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { SubscribersV1ControllerGetUnseenCountRequest } from '@novu/api/models/operations';
import { NotificationTemplateEntity, SubscriberRepository } from '@novu/dal';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { expectSdkExceptionGeneric, initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Get Unseen Count - /:subscriberId/notifications/unseen (GET) #novu-v2', () => {
  let session: UserSession;
  let template: NotificationTemplateEntity;
  let subscriberId: string;
  let novuClient: Novu;
  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    novuClient = initNovuClassSdk(session);

    template = await session.createTemplate({
      noFeedId: true,
    });

    subscriberId = SubscriberRepository.createObjectId();
  });

  it('should throw exception on invalid subscriber id', async () => {
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    const seenCount = await getUnSeenCount({ seen: false, subscriberId });
    expect(seenCount).to.equal(1);

    const { error } = await expectSdkExceptionGeneric(() =>
      getUnSeenCount({ seen: false, subscriberId: `${subscriberId}111` })
    );
    expect(error?.statusCode, JSON.stringify(error)).to.equals(400);
    expect(error?.message, JSON.stringify(error)).to.contain(
      `Subscriber ${`${subscriberId}111`} is not exist in environment`
    );
  });
  async function getUnSeenCount(query: SubscribersV1ControllerGetUnseenCountRequest) {
    const response = await novuClient.subscribers.notifications.unseenCount(query);

    return response.result.count;
  }
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getUnSeenCount(query: SubscribersV1ControllerGetUnseenCountRequest)
Asignaciones con arrow functions encontradas (posibles funciones):
 - subscriberId(SubscriberRepository.createObjectId();
  });

  it('should throw exception on invalid subscriber id'...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/e2e/mark-all-subscriber-messages.e2e.ts
Tamaño: 10353 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { MessageRepository, NotificationTemplateEntity, SubscriberRepository } from '@novu/dal';
import { ChannelTypeEnum, MessagesStatusEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { expectSdkExceptionGeneric, initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Mark All Subscriber Messages - /subscribers/:subscriberId/messages/mark-all (POST) #novu-v2', () => {
  let session: UserSession;
  let template: NotificationTemplateEntity;
  const messageRepository = new MessageRepository();
  const subscriberRepository = new SubscriberRepository();
  let novuClient: Novu;
  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    template = await session.createTemplate();
    novuClient = initNovuClassSdk(session);
    await messageRepository.delete({
      _environmentId: session.environment._id,
      _subscriberId: session.subscriberId,
    });
  });

  it("should throw not found when subscriberId doesn't exist", async () => {
    const fakeSubscriberId = 'fake-subscriber-id';
    const { error } = await expectSdkExceptionGeneric(() =>
      markAllSubscriberMessagesAs(fakeSubscriberId, MessagesStatusEnum.READ)
    );
    if (!error) {
      throw new Error('Call Should fail');
    }
    expect(error.statusCode).to.equal(404);
    expect(error.message, JSON.stringify(error)).to.equal(
      `Subscriber ${fakeSubscriberId} does not exist in environment ${session.environment._id}, ` +
        'please provide a valid subscriber identifier'
    );
  });

  it('should mark all the subscriber messages as read', async () => {
    const { subscriberId } = session;
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    const notificationsFeedResponse = await getSubscriberNotifications(subscriberId);
    expect(notificationsFeedResponse.totalCount, 'notificationsFeedResponse.totalCount').to.equal(5);

    const messagesMarkedAsReadResponse = await markAllSubscriberMessagesAs(subscriberId, MessagesStatusEnum.READ);
    expect(messagesMarkedAsReadResponse, 'messagesMarkedAsReadResponse').to.equal(5);

    const subscriber = await subscriberRepository.findBySubscriberId(session.environment._id, subscriberId);
    const feed = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber?._id,
      channel: ChannelTypeEnum.IN_APP,
      seen: true,
      read: true,
    });

    expect(feed.length, 'feed.length').to.equal(5);
    for (const message of feed) {
      expect(message.seen, 'message.seen').to.equal(true);
      expect(message.read, 'message.read').to.equal(true);
    }
  });

  it('should not mark all the messages as read if they are already read', async () => {
    const { subscriberId } = session;
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    const notificationsFeedResponse = await getSubscriberNotifications(subscriberId);
    expect(notificationsFeedResponse.totalCount).to.equal(5);

    const subscriber = await subscriberRepository.findBySubscriberId(session.environment._id, subscriberId);
    await messageRepository.update(
      {
        _environmentId: session.environment._id,
        _subscriberId: subscriber?._id,
        channel: ChannelTypeEnum.IN_APP,
        seen: false,
        read: false,
      },
      { $set: { read: true, seen: true } }
    );

    const messagesMarkedAsReadResponse = await markAllSubscriberMessagesAs(subscriberId, MessagesStatusEnum.READ);
    expect(messagesMarkedAsReadResponse).to.equal(0);

    const feed = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber?._id,
      channel: ChannelTypeEnum.IN_APP,
      seen: true,
      read: true,
    });

    expect(feed.length).to.equal(5);
    for (const message of feed) {
      expect(message.seen).to.equal(true);
      expect(message.read).to.equal(true);
    }
  });

  it('should mark all the subscriber messages as unread', async () => {
    const { subscriberId } = session;
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    const notificationsFeedResponse = await getSubscriberNotifications(subscriberId);
    expect(notificationsFeedResponse.totalCount).to.equal(5);

    const subscriber = await subscriberRepository.findBySubscriberId(session.environment._id, subscriberId);
    await messageRepository.update(
      {
        _environmentId: session.environment._id,
        _subscriberId: subscriber?._id,
        channel: ChannelTypeEnum.IN_APP,
        seen: false,
        read: false,
      },
      { $set: { read: true, seen: true } }
    );

    const messagesMarkedAsReadResponse = await markAllSubscriberMessagesAs(subscriberId, MessagesStatusEnum.UNREAD);
    expect(messagesMarkedAsReadResponse).to.equal(5);

    const feed = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber?._id,
      channel: ChannelTypeEnum.IN_APP,
      seen: true,
      read: false,
    });

    expect(feed.length).to.equal(5);
    for (const message of feed) {
      expect(message.seen).to.equal(true);
      expect(message.read).to.equal(false);
    }
  });

  it('should mark all the subscriber messages as seen', async () => {
    const { subscriberId } = session;
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    const notificationsFeedResponse = await getSubscriberNotifications(subscriberId);
    expect(notificationsFeedResponse.totalCount).to.equal(5);

    const messagesMarkedAsReadResponse = await markAllSubscriberMessagesAs(subscriberId, MessagesStatusEnum.SEEN);
    expect(messagesMarkedAsReadResponse).to.equal(5);

    const subscriber = await subscriberRepository.findBySubscriberId(session.environment._id, subscriberId);
    const feed = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber?._id,
      channel: ChannelTypeEnum.IN_APP,
      seen: true,
      read: false,
    });

    expect(feed.length).to.equal(5);
    for (const message of feed) {
      expect(message.seen).to.equal(true);
      expect(message.read).to.equal(false);
    }
  });

  it('should mark all the subscriber messages as unseen', async () => {
    const { subscriberId } = session;
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    const notificationsFeedResponse = await getSubscriberNotifications(subscriberId);
    expect(notificationsFeedResponse.totalCount).to.equal(5);

    const subscriber = await subscriberRepository.findBySubscriberId(session.environment._id, subscriberId);
    await messageRepository.update(
      {
        _environmentId: session.environment._id,
        _subscriberId: subscriber?._id,
        channel: ChannelTypeEnum.IN_APP,
        seen: false,
        read: false,
      },
      { $set: { seen: true } }
    );

    const messagesMarkedAsReadResponse = await markAllSubscriberMessagesAs(subscriberId, MessagesStatusEnum.UNSEEN);
    expect(messagesMarkedAsReadResponse).to.equal(5);

    const feed = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriber?._id,
      channel: ChannelTypeEnum.IN_APP,
      seen: false,
      read: false,
    });

    expect(feed.length).to.equal(5);
    for (const message of feed) {
      expect(message.seen).to.equal(false);
      expect(message.read).to.equal(false);
    }
  });
  async function markAllSubscriberMessagesAs(subscriberId: string, markAs: MessagesStatusEnum) {
    const res = await novuClient.subscribers.messages.markAll({ markAs }, subscriberId);

    return res.result;
  }
  async function getSubscriberNotifications(subscriberId: string) {
    const res = await novuClient.subscribers.notifications.feed({
      subscriberId,
      limit: 100,
    });

    return res.result;
  }
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - markAllSubscriberMessagesAs(subscriberId: string, markAs: MessagesStatusEnum)
 - getSubscriberNotifications(subscriberId: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - subscriberRepository(new SubscriberRepository();
  let novuClient: Novu;
  beforeEach(async ())
 - novuClient(initNovuClassSdk(session);
    await messageRepository.delete({
      _environmentId: session.enviro...)
 - feed(await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: s...)
 - feed(await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: s...)
 - feed(await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: s...)
 - feed(await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: s...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/e2e/mark-as-by-mark.e2e.ts
Tamaño: 6964 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import {
  MessageEntity,
  MessageRepository,
  NotificationTemplateEntity,
  SubscriberEntity,
  SubscriberRepository,
} from '@novu/dal';
import { ChannelTypeEnum, MessagesStatusEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import axios from 'axios';
import { expect } from 'chai';
import { expectSdkExceptionGeneric, initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

const axiosInstance = axios.create();

describe('Mark as Seen - /widgets/messages/mark-as (POST) #novu-v2', async () => {
  const messageRepository = new MessageRepository();
  const subscriberRepository = new SubscriberRepository();
  let session: UserSession;
  let template: NotificationTemplateEntity;
  let subscriberId;
  let subscriber: SubscriberEntity;
  let message: MessageEntity;
  let novuClient: Novu;
  before(async () => {
    session = new UserSession();
    await session.initialize();
    subscriberId = SubscriberRepository.createObjectId();

    template = await session.createTemplate();
    novuClient = initNovuClassSdk(session);
  });

  beforeEach(async () => {
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await session.waitForJobCompletion(template._id);

    subscriber = await getSubscriber(session, subscriberRepository, subscriberId);
    message = await getMessage(session, messageRepository, subscriber);

    expect(message.seen).to.equal(false);
    expect(message.read).to.equal(false);
    expect(message.lastSeenDate).to.be.not.ok;
    expect(message.lastReadDate).to.be.not.ok;
  });

  afterEach(async () => {
    await pruneMessages(messageRepository);
  });

  it('should change the seen status', async () => {
    await novuClient.subscribers.messages.markAllAs(
      {
        messageId: message._id,
        markAs: MessagesStatusEnum.SEEN,
      },
      subscriberId
    );

    const updatedMessage = await getMessage(session, messageRepository, subscriber);

    expect(updatedMessage.seen).to.equal(true);
    expect(updatedMessage.read).to.equal(false);
    expect(updatedMessage.lastSeenDate).to.be.ok;
    expect(updatedMessage.lastReadDate).to.be.not.ok;
  });

  it('should change the read status', async () => {
    await novuClient.subscribers.messages.markAllAs(
      {
        messageId: message._id,
        markAs: MessagesStatusEnum.READ,
      },
      subscriberId
    );

    const updatedMessage = await getMessage(session, messageRepository, subscriber);

    expect(updatedMessage.seen).to.equal(true);
    expect(updatedMessage.read).to.equal(true);
    expect(updatedMessage.lastSeenDate).to.be.ok;
    expect(updatedMessage.lastReadDate).to.be.ok;
  });

  it('should change the seen status to unseen', async () => {
    // simulate user seen
    await novuClient.subscribers.messages.markAllAs(
      {
        messageId: message._id,
        markAs: MessagesStatusEnum.SEEN,
      },
      subscriberId
    );

    const seenMessage = await getMessage(session, messageRepository, subscriber);
    expect(seenMessage.seen).to.equal(true);
    expect(seenMessage.read).to.equal(false);
    expect(seenMessage.lastSeenDate).to.be.ok;
    expect(seenMessage.lastReadDate).to.be.not.ok;

    await novuClient.subscribers.messages.markAllAs(
      {
        messageId: message._id,
        markAs: MessagesStatusEnum.UNSEEN,
      },
      subscriberId
    );

    const updatedMessage = await getMessage(session, messageRepository, subscriber);
    expect(updatedMessage.seen).to.equal(false);
    expect(updatedMessage.read).to.equal(false);
    expect(updatedMessage.lastSeenDate).to.be.ok;
    expect(updatedMessage.lastReadDate).to.be.not.ok;
  });

  it('should change the read status to unread', async () => {
    // simulate user read
    await novuClient.subscribers.messages.markAllAs(
      {
        messageId: message._id,
        markAs: MessagesStatusEnum.READ,
      },
      subscriberId
    );

    const readMessage = await getMessage(session, messageRepository, subscriber);
    expect(readMessage.seen).to.equal(true);
    expect(readMessage.read).to.equal(true);
    expect(readMessage.lastSeenDate).to.be.ok;
    expect(readMessage.lastReadDate).to.be.ok;

    await novuClient.subscribers.messages.markAllAs(
      {
        messageId: message._id,
        markAs: MessagesStatusEnum.UNREAD,
      },
      subscriberId
    );
    const updateMessage = await getMessage(session, messageRepository, subscriber);
    expect(updateMessage.seen).to.equal(true);
    expect(updateMessage.read).to.equal(false);
    expect(updateMessage.lastSeenDate).to.be.ok;
    expect(updateMessage.lastReadDate).to.be.ok;
  });

  it('should throw exception if messages were not provided', async () => {
    const failureMessage = 'should not reach here, should throw error';

    try {
      await markAs(session.apiKey, undefined, MessagesStatusEnum.SEEN, subscriberId);

      expect.fail(failureMessage);
    } catch (e) {
      if (e.message === failureMessage) {
        expect(e.message).to.be.empty;
      }

      expect(e.response.data.message).to.equal('messageId is required');
      expect(e.response.data.statusCode).to.equal(400);
    }
    const { error } = await expectSdkExceptionGeneric(() =>
      novuClient.subscribers.messages.markAllAs(
        {
          messageId: [],
          markAs: MessagesStatusEnum.SEEN,
        },
        subscriberId
      )
    );

    expect(error?.message).to.equal('messageId is required');
    expect(error?.statusCode).to.equal(400);
  });
});

async function getMessage(
  session: UserSession,
  messageRepository: MessageRepository,
  subscriber: SubscriberEntity
): Promise<MessageEntity> {
  const message = await messageRepository.findOne({
    _environmentId: session.environment._id,
    _subscriberId: subscriber._id,
    channel: ChannelTypeEnum.IN_APP,
  });

  if (!message) {
    expect(message).to.be.ok;
    throw new Error('message not found');
  }

  return message;
}

async function markAs(
  apiKey: string,
  messageIds: string | string[] | undefined,
  mark: MessagesStatusEnum,
  subscriberId: string
) {
  return await axiosInstance.post(
    `http://127.0.0.1:${process.env.PORT}/v1/subscribers/${subscriberId}/messages/mark-as`,
    {
      messageId: messageIds,
      markAs: mark,
    },
    {
      headers: {
        authorization: `ApiKey ${apiKey}`,
      },
    }
  );
}

async function getSubscriber(
  session: UserSession,
  subscriberRepository: SubscriberRepository,
  subscriberId: string
): Promise<SubscriberEntity> {
  const subscriberRes = await subscriberRepository.findOne({
    _environmentId: session.environment._id,
    subscriberId,
  });

  if (!subscriberRes) {
    expect(subscriberRes).to.be.ok;
    throw new Error('subscriber not found');
  }

  return subscriberRes;
}

async function pruneMessages(messageRepository) {
  await messageRepository.delete({});
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getMessage(session: UserSession,
  messageRepository: MessageRepository,
  subscriber: SubscriberEntity)
 - markAs(apiKey: string,
  messageIds: string | string[] | undefined,
  mark: MessagesStatusEnum,
  subscriberId: string)
 - getSubscriber(session: UserSession,
  subscriberRepository: SubscriberRepository,
  subscriberId: string)
 - pruneMessages(messageRepository)
Asignaciones con arrow functions encontradas (posibles funciones):
 - axiosInstance(axios.create();

describe('Mark as Seen - /widgets/messages/mark-as (POST) #novu-v2', async ())
 - subscriberRepository(new SubscriberRepository();
  let session: UserSession;
  let template: NotificationTemplateEntity;
...)
 - novuClient(initNovuClassSdk(session);
  });

  beforeEach(async ())
 - message(await getMessage(session, messageRepository, subscriber);

    expect(message.seen).to.equal(false);...)
 - updatedMessage(await getMessage(session, messageRepository, subscriber);

    expect(updatedMessage.seen).to.equal(...)
 - updatedMessage(await getMessage(session, messageRepository, subscriber);

    expect(updatedMessage.seen).to.equal(...)
 - updatedMessage(await getMessage(session, messageRepository, subscriber);
    expect(updatedMessage.seen).to.equal(f...)
 - updateMessage(await getMessage(session, messageRepository, subscriber);
    expect(updateMessage.seen).to.equal(tr...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/e2e/remove-subscriber.e2e.ts
Tamaño: 3432 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { TopicResponseDto } from '@novu/api/models/components';
import { SubscriberEntity, SubscriberRepository, TopicSubscribersRepository } from '@novu/dal';
import { ExternalSubscriberId, TopicKey, TopicName } from '@novu/shared';
import { SubscribersService, UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

const subscriberId = '123';
describe('Delete Subscriber - /subscribers/:subscriberId (DELETE) #novu-v2', () => {
  let session: UserSession;
  let subscriberService: SubscribersService;
  const subscriberRepository = new SubscriberRepository();
  const topicSubscribersRepository = new TopicSubscribersRepository();
  let novuClient: Novu;
  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    subscriberService = new SubscribersService(session.organization._id, session.environment._id);
    novuClient = initNovuClassSdk(session);
  });

  it('should delete an existing subscriber', async () => {
    await novuClient.subscribers.create({
      subscriberId,
      firstName: 'John',
      lastName: 'Doe',
      email: 'john@doe.com',
      phone: '+972523333333',
    });

    const createdSubscriber = await subscriberRepository.findBySubscriberId(session.environment._id, subscriberId);
    expect(createdSubscriber?.subscriberId).to.equal(subscriberId);
    await novuClient.subscribers.delete(subscriberId);
    const subscriber = await subscriberRepository.findBySubscriberId(session.environment._id, subscriberId);
    expect(subscriber).to.be.null;
  });

  it('should dispose subscriber relations to topic once he was removed', async () => {
    const subscriber = await subscriberService.createSubscriber({ subscriberId });
    for (let i = 0; i < 50; i += 1) {
      const firstTopicKey = `topic-key-${i}-trigger-event`;
      const firstTopicName = `topic-name-${i}-trigger-event`;
      const newTopic = await createTopic(firstTopicKey, firstTopicName);
      await addSubscribersToTopic(newTopic, [subscriber]);
    }

    const createdRelations = await topicSubscribersRepository.find({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      externalSubscriberId: subscriberId,
    });

    expect(createdRelations.length).to.equal(50);
    await novuClient.subscribers.delete(subscriberId);
    const deletedRelations = await topicSubscribersRepository.find({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      externalSubscriberId: subscriberId,
    });

    expect(deletedRelations.length).to.equal(0);
  });
  const createTopic = async (key: TopicKey, name: TopicName) => {
    const response = await novuClient.topics.create({
      key,
      name,
    });

    const body = response.result;
    expect(body.id).to.exist;
    expect(body.key).to.eql(key);

    return body;
  };
  const addSubscribersToTopic = async (createdTopicDto: TopicResponseDto, subscribers: SubscriberEntity[]) => {
    const subscriberIds: ExternalSubscriberId[] = subscribers.map(
      (subscriber: SubscriberEntity) => subscriber.subscriberId
    );

    const response = await novuClient.topics.subscriptions.create(
      {
        subscriberIds,
      },
      createdTopicDto.key
    );

    expect(response.result.data).to.be.ok;
  };
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - subscriberId('123';
describe('Delete Subscriber - /subscribers/:subscriberId (DELETE) #novu-v2', ())
 - topicSubscribersRepository(new TopicSubscribersRepository();
  let novuClient: Novu;
  beforeEach(async ())
 - novuClient(initNovuClassSdk(session);
  });

  it('should delete an existing subscriber', async ())
 - subscriber(await subscriberRepository.findBySubscriberId(session.environment._id, subscriberId);
    expect(sub...)
 - createTopic(async (key: TopicKey, name: TopicName))
 - addSubscribersToTopic(async (createdTopicDto: TopicResponseDto, subscribers: SubscriberEntity[]))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/e2e/update-online-flag.e2e.ts
Tamaño: 1687 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SubscriberEntity } from '@novu/dal';
import { SubscribersService, UserSession } from '@novu/testing';
import { expect } from 'chai';
import { sub } from 'date-fns';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Update Subscriber online flag - /subscribers/:subscriberId/online-status (PATCH) #novu-v2', () => {
  let session: UserSession;
  let onlineSubscriber: SubscriberEntity;
  let offlineSubscriber: SubscriberEntity;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    const subscribersService = new SubscribersService(session.organization._id, session.environment._id);
    onlineSubscriber = await subscribersService.createSubscriber({
      subscriberId: '123',
      isOnline: true,
    });
    offlineSubscriber = await subscribersService.createSubscriber({
      subscriberId: '456',
      isOnline: false,
      lastOnlineAt: sub(new Date(), { minutes: 1 }).toISOString(),
    });
  });

  it('should set the online status to false', async () => {
    const body = {
      isOnline: false,
    };

    const { result: data } = await initNovuClassSdk(session).subscribers.properties.updateOnlineFlag(
      body,
      onlineSubscriber.subscriberId
    );

    expect(data.isOnline).to.equal(false);
    expect(data.lastOnlineAt).to.be.a('string');
  });

  it('should set the online status to true', async () => {
    const body = {
      isOnline: true,
    };

    const { result: data } = await initNovuClassSdk(session).subscribers.properties.updateOnlineFlag(
      body,
      offlineSubscriber.subscriberId
    );

    expect(data.isOnline).to.equal(true);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - offlineSubscriber(await subscribersService.createSubscriber({
      subscriberId: '456',
      isOnline: false,
      ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/e2e/helpers/index.ts
Tamaño: 709 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IUpdateNotificationTemplateDto } from '@novu/shared';
import { UserSession } from '@novu/testing';
import axios from 'axios';

const axiosInstance = axios.create();

export async function getNotificationTemplate(session: UserSession, id: string) {
  return await axiosInstance.get(`${session.serverUrl}/v1/workflows/${id}`, {
    headers: {
      authorization: `ApiKey ${session.apiKey}`,
    },
  });
}

export async function updateNotificationTemplate(
  session: UserSession,
  id: string,
  data: IUpdateNotificationTemplateDto
) {
  return await axiosInstance.put(`${session.serverUrl}/v1/workflows/${id}`, data, {
    headers: {
      authorization: `ApiKey ${session.apiKey}`,
    },
  });
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getNotificationTemplate(session: UserSession, id: string)
 - updateNotificationTemplate(session: UserSession,
  id: string,
  data: IUpdateNotificationTemplateDto)
Declaraciones 'export' encontradas:
- export  async
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/params/get-subscriber-preferences-by-level.params.ts
Tamaño: 264 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { PreferenceLevelEnum } from '@novu/shared';
import { IsEnum, IsString } from 'class-validator';

export class GetSubscriberPreferencesByLevelParams {
  @IsEnum(PreferenceLevelEnum)
  parameter: PreferenceLevelEnum;

  @IsString()
  subscriberId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetSubscriberPreferencesByLevelParams

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/params/index.ts
Tamaño: 62 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './get-subscriber-preferences-by-level.params';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/query-objects/unseen-count.query.ts
Tamaño: 781 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { Transform } from 'class-transformer';

export class UnseenCountQueryDto {
  @ApiProperty({
    description: 'Identifier for the feed. Can be a single string or an array of strings.',
    oneOf: [{ type: 'string' }, { type: 'array', items: { type: 'string' } }],
    required: false,
  })
  feedId?: string | string[];

  @ApiProperty({
    description: 'Indicates whether to count seen notifications.',
    required: false,
    default: false,
    type: Boolean,
  })
  seen?: boolean;

  @ApiProperty({
    description: 'The maximum number of notifications to return.',
    required: false,
    default: 100,
    type: Number,
  })
  @Transform(({ value }) => Number(value)) // Convert string to integer
  limit?: number;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UnseenCountQueryDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/unit/update-subscriber-channel.spec.ts
Tamaño: 17734 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { faker } from '@faker-js/faker';
import { Test } from '@nestjs/testing';
import { OAuthHandlerEnum, UpdateSubscriberChannel, UpdateSubscriberChannelCommand } from '@novu/application-generic';

import { IntegrationRepository, SubscriberRepository } from '@novu/dal';
import { ChannelTypeEnum, ChatProviderIdEnum, PushProviderIdEnum } from '@novu/shared';
import { SubscribersService, UserSession } from '@novu/testing';
import { expect } from 'chai';

import { SharedModule } from '../../shared/shared.module';

describe('Update Subscriber channel credentials', () => {
  let updateSubscriberChannelUsecase: UpdateSubscriberChannel;
  let session: UserSession;
  const subscriberRepository = new SubscriberRepository();
  const integrationRepository = new IntegrationRepository();

  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [SharedModule],
      providers: [UpdateSubscriberChannel],
    }).compile();

    session = new UserSession();
    await session.initialize();

    updateSubscriberChannelUsecase = moduleRef.get<UpdateSubscriberChannel>(UpdateSubscriberChannel);
  });

  it('should add subscriber new discord channel credentials', async () => {
    const subscriberService = new SubscribersService(session.organization._id, session.environment._id);
    const subscriber = await subscriberService.createSubscriber();

    const subscriberChannel = {
      providerId: ChatProviderIdEnum.Discord,
      credentials: { webhookUrl: 'newWebhookUrl' },
    };
    await updateSubscriberChannelUsecase.execute(
      UpdateSubscriberChannelCommand.create({
        organizationId: subscriber._organizationId,
        subscriberId: subscriber.subscriberId,
        environmentId: session.environment._id,
        providerId: subscriberChannel.providerId,
        credentials: subscriberChannel.credentials,
        oauthHandler: OAuthHandlerEnum.NOVU,
        isIdempotentOperation: true,
      })
    );

    const updatedSubscriber = await subscriberRepository.findOne({
      _id: subscriber._id,
      _environmentId: subscriber._environmentId,
    });

    const newChannel = updatedSubscriber?.channels?.find(
      (channel) => channel.providerId === subscriberChannel.providerId
    );

    expect(newChannel?.credentials.webhookUrl).to.equal(subscriberChannel.credentials.webhookUrl);
  });

  it('should update subscriber existing slack channel credentials', async () => {
    const subscriberService = new SubscribersService(session.organization._id, session.environment._id);
    const subscriber = await subscriberService.createSubscriber();

    await updateSubscriberChannelUsecase.execute(
      UpdateSubscriberChannelCommand.create({
        organizationId: subscriber._organizationId,
        subscriberId: subscriber.subscriberId,
        environmentId: session.environment._id,
        providerId: ChatProviderIdEnum.Discord,
        credentials: { webhookUrl: 'webhookUrl' },
        oauthHandler: OAuthHandlerEnum.NOVU,
        isIdempotentOperation: true,
      })
    );

    const newSlackSubscribersChannel = {
      providerId: ChatProviderIdEnum.Slack,
      credentials: { webhookUrl: 'webhookUrlNew' },
    };
    await updateSubscriberChannelUsecase.execute(
      UpdateSubscriberChannelCommand.create({
        organizationId: subscriber._organizationId,
        subscriberId: subscriber.subscriberId,
        environmentId: session.environment._id,
        providerId: newSlackSubscribersChannel.providerId,
        credentials: newSlackSubscribersChannel.credentials,
        oauthHandler: OAuthHandlerEnum.NOVU,
        isIdempotentOperation: true,
      })
    );

    const updatedSubscriber = await subscriberRepository.findOne({
      _id: subscriber._id,
      _environmentId: subscriber._environmentId,
    });

    const updatedChannel = updatedSubscriber?.channels?.find(
      (channel) => channel.providerId === newSlackSubscribersChannel.providerId
    );

    expect(updatedChannel?.credentials.webhookUrl).to.equal(newSlackSubscribersChannel.credentials.webhookUrl);
  });

  it('should update only webhookUrl on existing slack channel credentials', async () => {
    const subscriberService = new SubscribersService(session.organization._id, session.environment._id);
    const subscriber = await subscriberService.createSubscriber();
    const slackIntegration = await integrationRepository.findOne({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      providerId: ChatProviderIdEnum.Slack,
    });

    const newSlackCredentials = {
      providerId: ChatProviderIdEnum.Slack,
      credentials: { webhookUrl: 'new-secret-webhookUrl' },
    };

    await updateSubscriberChannelUsecase.execute(
      UpdateSubscriberChannelCommand.create({
        organizationId: subscriber._organizationId,
        subscriberId: subscriber.subscriberId,
        environmentId: session.environment._id,
        providerId: newSlackCredentials.providerId,
        credentials: newSlackCredentials.credentials,
        oauthHandler: OAuthHandlerEnum.NOVU,
        isIdempotentOperation: true,
      })
    );

    const updatedSubscriber = await subscriberRepository.findOne({
      _id: subscriber._id,
      _environmentId: subscriber._environmentId,
    });

    const newChannel = updatedSubscriber?.channels?.find(
      (channel) => channel.providerId === newSlackCredentials.providerId
    );

    expect(newChannel?._integrationId).to.equal(slackIntegration?._id);
    expect(newChannel?.providerId).to.equal('slack');
    expect(newChannel?.credentials.webhookUrl).to.equal('new-secret-webhookUrl');
  });

  it('should update slack channel credentials for a specific integration', async () => {
    const identifier = 'identifier_slack';
    const webhookUrl = 'webhookUrl';
    const integration = await integrationRepository.create({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      identifier,
      providerId: ChatProviderIdEnum.Slack,
      channel: ChannelTypeEnum.CHAT,
      credentials: {},
      active: true,
    });
    const subscriberService = new SubscribersService(session.organization._id, session.environment._id);
    const subscriber = await subscriberService.createSubscriber();

    await updateSubscriberChannelUsecase.execute(
      UpdateSubscriberChannelCommand.create({
        organizationId: subscriber._organizationId,
        subscriberId: subscriber.subscriberId,
        environmentId: session.environment._id,
        integrationIdentifier: identifier,
        providerId: ChatProviderIdEnum.Slack,
        credentials: { webhookUrl },
        oauthHandler: OAuthHandlerEnum.NOVU,
        isIdempotentOperation: true,
      })
    );

    const updatedSubscriber = await subscriberRepository.findOne({
      _id: subscriber._id,
      _environmentId: subscriber._environmentId,
    });

    const updatedChannel = updatedSubscriber?.channels?.find(
      (channel) => channel.providerId === ChatProviderIdEnum.Slack && channel._integrationId === integration._id
    );

    expect(updatedChannel?.credentials.webhookUrl).to.equal(webhookUrl);
  });

  it('should not add duplicated token when the operation IS idempotent', async () => {
    const subscriberService = new SubscribersService(session.organization._id, session.environment._id);
    const subscriber = await subscriberService.createSubscriber();

    const fcmCredentials = {
      providerId: PushProviderIdEnum.FCM,
      credentials: { deviceTokens: ['token_1', 'token_1'] },
    };

    await updateSubscriberChannelUsecase.execute(
      UpdateSubscriberChannelCommand.create({
        organizationId: subscriber._organizationId,
        subscriberId: subscriber.subscriberId,
        environmentId: session.environment._id,
        providerId: fcmCredentials.providerId,
        credentials: fcmCredentials.credentials,
        oauthHandler: OAuthHandlerEnum.NOVU,
        isIdempotentOperation: true,
      })
    );

    const updatedSubscriber = await subscriberRepository.findOne({
      _id: subscriber._id,
      _environmentId: subscriber._environmentId,
    });

    const addedFcmToken = updatedSubscriber?.channels?.find(
      (channel) => channel.providerId === fcmCredentials.providerId
    );

    expect(addedFcmToken?.providerId).to.equal(PushProviderIdEnum.FCM);
    expect(addedFcmToken?.credentials?.deviceTokens?.length).to.equal(1);
    expect(addedFcmToken?.credentials?.deviceTokens).to.deep.equal(['token_1']);
  });

  it('should not add duplicated token when the operation IS NOT idempotent', async () => {
    const subscriberService = new SubscribersService(session.organization._id, session.environment._id);
    const subscriber = await subscriberService.createSubscriber();

    const fcmCredentials = {
      providerId: PushProviderIdEnum.FCM,
      credentials: { deviceTokens: ['token_1', 'token_1'] },
    };

    await updateSubscriberChannelUsecase.execute(
      UpdateSubscriberChannelCommand.create({
        organizationId: subscriber._organizationId,
        subscriberId: subscriber.subscriberId,
        environmentId: session.environment._id,
        providerId: fcmCredentials.providerId,
        credentials: fcmCredentials.credentials,
        oauthHandler: OAuthHandlerEnum.NOVU,
        isIdempotentOperation: false,
      })
    );

    const updatedSubscriber = await subscriberRepository.findOne({
      _id: subscriber._id,
      _environmentId: subscriber._environmentId,
    });

    const addedFcmToken = updatedSubscriber?.channels?.find(
      (channel) => channel.providerId === fcmCredentials.providerId
    );

    expect(addedFcmToken?.providerId).to.equal(PushProviderIdEnum.FCM);
    expect(addedFcmToken?.credentials?.deviceTokens?.length).to.equal(2);
    expect(addedFcmToken?.credentials?.deviceTokens).to.deep.equal(['identifier', 'token_1']);
  });

  it('should append to existing device token array when the operation IS NOT idempotent', async () => {
    const subscriberService = new SubscribersService(session.organization._id, session.environment._id);
    const subscriber = await subscriberService.createSubscriber();

    const fcmCredentials = {
      providerId: PushProviderIdEnum.FCM,
      credentials: { deviceTokens: ['token_1'] },
    };

    await updateSubscriberChannelUsecase.execute(
      UpdateSubscriberChannelCommand.create({
        organizationId: subscriber._organizationId,
        subscriberId: subscriber.subscriberId,
        environmentId: session.environment._id,
        providerId: fcmCredentials.providerId,
        credentials: fcmCredentials.credentials,
        oauthHandler: OAuthHandlerEnum.NOVU,
        isIdempotentOperation: false,
      })
    );

    const updatedSubscriber = await subscriberRepository.findOne({
      _id: subscriber._id,
      _environmentId: subscriber._environmentId,
    });

    const addedFcmToken = updatedSubscriber?.channels?.find(
      (channel) => channel.providerId === fcmCredentials.providerId
    );

    expect(addedFcmToken?.providerId).to.equal(PushProviderIdEnum.FCM);
    expect(addedFcmToken?.credentials?.deviceTokens?.length).to.equal(2);
    expect(addedFcmToken?.credentials?.deviceTokens).to.deep.equal(['identifier', 'token_1']);
  });

  it('should update deviceTokens with empty array', async () => {
    const subscriberService = new SubscribersService(session.organization._id, session.environment._id);
    const subscriber = await subscriberService.createSubscriber();

    const fcmCredentials = {
      providerId: PushProviderIdEnum.FCM,
      credentials: { deviceTokens: ['token_1'] },
    };

    await updateSubscriberChannelUsecase.execute(
      UpdateSubscriberChannelCommand.create({
        organizationId: subscriber._organizationId,
        subscriberId: subscriber.subscriberId,
        environmentId: session.environment._id,
        providerId: fcmCredentials.providerId,
        credentials: fcmCredentials.credentials,
        oauthHandler: OAuthHandlerEnum.NOVU,
        isIdempotentOperation: true,
      })
    );

    let updatedSubscriber = await subscriberRepository.findOne({
      _id: subscriber._id,
      _environmentId: subscriber._environmentId,
    });

    const addedFcmToken = updatedSubscriber?.channels?.find(
      (channel) => channel.providerId === fcmCredentials.providerId
    );

    expect(addedFcmToken?.credentials?.deviceTokens?.length).to.equal(1);
    expect(addedFcmToken?.credentials?.deviceTokens).to.deep.equal(['token_1']);

    await updateSubscriberChannelUsecase.execute(
      UpdateSubscriberChannelCommand.create({
        organizationId: subscriber._organizationId,
        subscriberId: subscriber.subscriberId,
        environmentId: session.environment._id,
        providerId: fcmCredentials.providerId,
        credentials: { deviceTokens: [] },
        oauthHandler: OAuthHandlerEnum.NOVU,
        isIdempotentOperation: true,
      })
    );

    updatedSubscriber = await subscriberRepository.findOne({
      _id: subscriber._id,
      _environmentId: subscriber._environmentId,
    });

    const updatedProviderWithEmptyDeviceToken = updatedSubscriber?.channels?.find(
      (channel) => channel.providerId === fcmCredentials.providerId
    );

    expect(updatedProviderWithEmptyDeviceToken?.credentials?.deviceTokens?.length).to.equal(0);
    expect(updatedProviderWithEmptyDeviceToken?.credentials?.deviceTokens).to.deep.equal([]);
  });

  it('should update deviceTokens with new token after stress adding', async () => {
    const subscriberService = new SubscribersService(session.organization._id, session.environment._id);
    const subscriber = await subscriberService.createSubscriber();

    await updateSubscriberChannelUsecase.execute(
      UpdateSubscriberChannelCommand.create({
        organizationId: subscriber._organizationId,
        subscriberId: subscriber.subscriberId,
        environmentId: session.environment._id,
        providerId: PushProviderIdEnum.FCM,
        credentials: { deviceTokens: ['token_1'] },
        oauthHandler: OAuthHandlerEnum.NOVU,
        isIdempotentOperation: true,
      })
    );

    let updatedSubscriber = await subscriberRepository.findOne({
      _id: subscriber._id,
      _environmentId: subscriber._environmentId,
    });

    let updateToken = updatedSubscriber?.channels?.find((channel) => channel.providerId === PushProviderIdEnum.FCM);

    expect(updateToken?.credentials?.deviceTokens?.length).to.equal(1);
    expect(updateToken?.credentials?.deviceTokens).to.deep.equal(['token_1']);

    await updateSubscriberChannelUsecase.execute(
      UpdateSubscriberChannelCommand.create({
        organizationId: subscriber._organizationId,
        subscriberId: subscriber.subscriberId,
        environmentId: session.environment._id,
        providerId: PushProviderIdEnum.FCM,
        credentials: { deviceTokens: ['token_1', 'token_2', 'token_2', 'token_3'] },
        oauthHandler: OAuthHandlerEnum.NOVU,
        isIdempotentOperation: true,
      })
    );

    updatedSubscriber = await subscriberRepository.findOne({
      _id: subscriber._id,
      _environmentId: subscriber._environmentId,
    });

    updateToken = updatedSubscriber?.channels?.find((channel) => channel.providerId === PushProviderIdEnum.FCM);

    expect(updateToken?.credentials?.deviceTokens?.length).to.equal(3);
    expect(updateToken?.credentials?.deviceTokens).to.deep.equal(['token_1', 'token_2', 'token_3']);

    await updateSubscriberChannelUsecase.execute(
      UpdateSubscriberChannelCommand.create({
        organizationId: subscriber._organizationId,
        subscriberId: subscriber.subscriberId,
        environmentId: session.environment._id,
        providerId: PushProviderIdEnum.FCM,
        credentials: { deviceTokens: ['token_555'] },
        oauthHandler: OAuthHandlerEnum.NOVU,
        isIdempotentOperation: true,
      })
    );

    updatedSubscriber = await subscriberRepository.findOne({
      _id: subscriber._id,
      _environmentId: subscriber._environmentId,
    });

    updateToken = updatedSubscriber?.channels?.find((channel) => channel.providerId === PushProviderIdEnum.FCM);

    expect(updateToken?.credentials?.deviceTokens?.length).to.equal(1);
    expect(updateToken?.credentials?.deviceTokens).to.deep.equal(['token_555']);
  });

  it('should update deviceTokens without duplication on channel creation (addChannelToSubscriber)', async () => {
    const subscriberId = SubscriberRepository.createObjectId();
    const test = await subscriberRepository.create({
      firstName: faker.name.firstName(),
      lastName: faker.name.lastName(),
      email: faker.internet.email(),
      phone: faker.phone.phoneNumber(),
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      subscriberId,
    });

    await updateSubscriberChannelUsecase.execute(
      UpdateSubscriberChannelCommand.create({
        organizationId: session.organization._id,
        subscriberId,
        environmentId: session.environment._id,
        providerId: PushProviderIdEnum.FCM,
        credentials: { deviceTokens: ['token_1', 'token_1', 'token_1'] },
        oauthHandler: OAuthHandlerEnum.NOVU,
        isIdempotentOperation: true,
      })
    );

    const updatedSubscriber = await subscriberRepository.findBySubscriberId(session.environment._id, subscriberId);

    const addedFcmToken = updatedSubscriber?.channels?.find((channel) => channel.providerId === PushProviderIdEnum.FCM);

    expect(addedFcmToken?.credentials?.deviceTokens?.length).to.equal(1);
    expect(addedFcmToken?.credentials?.deviceTokens).to.deep.equal(['token_1']);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - integrationRepository(new IntegrationRepository();

  beforeEach(async ())
 - updateSubscriberChannelUsecase(moduleRef.get<UpdateSubscriberChannel>(UpdateSubscriberChannel);
  });

  it('should add subscriber ...)
 - newChannel(updatedSubscriber?.channels?.find(
      (channel))
 - updatedChannel(updatedSubscriber?.channels?.find(
      (channel))
 - newChannel(updatedSubscriber?.channels?.find(
      (channel))
 - updatedChannel(updatedSubscriber?.channels?.find(
      (channel))
 - addedFcmToken(updatedSubscriber?.channels?.find(
      (channel))
 - addedFcmToken(updatedSubscriber?.channels?.find(
      (channel))
 - addedFcmToken(updatedSubscriber?.channels?.find(
      (channel))
 - addedFcmToken(updatedSubscriber?.channels?.find(
      (channel))
 - updatedProviderWithEmptyDeviceToken(updatedSubscriber?.channels?.find(
      (channel))
 - updateToken(updatedSubscriber?.channels?.find((channel))
 - updateToken(updatedSubscriber?.channels?.find((channel))
 - updateToken(updatedSubscriber?.channels?.find((channel))
 - addedFcmToken(updatedSubscriber?.channels?.find((channel))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/index.ts
Tamaño: 2331 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  CreateOrUpdateSubscriberUseCase,
  GetSubscriberTemplatePreference,
  GetWorkflowByIdsUseCase,
  UpdateSubscriber,
  UpdateSubscriberChannel,
} from '@novu/application-generic';
import { UpdatePreferences } from '../../inbox/usecases/update-preferences/update-preferences.usecase';
import { CheckIntegration } from '../../integrations/usecases/check-integration/check-integration.usecase';
import { CheckIntegrationEMail } from '../../integrations/usecases/check-integration/check-integration-email.usecase';
import { CreateIntegration } from '../../integrations/usecases/create-integration/create-integration.usecase';
import { BulkCreateSubscribers } from './bulk-create-subscribers/bulk-create-subscribers.usecase';
import { ChatOauth } from './chat-oauth/chat-oauth.usecase';
import { ChatOauthCallback } from './chat-oauth-callback/chat-oauth-callback.usecase';
import { DeleteSubscriberCredentials } from './delete-subscriber-credentials/delete-subscriber-credentials.usecase';
import { GetPreferencesByLevel } from './get-preferences-by-level/get-preferences-by-level.usecase';
import { GetSubscriber } from './get-subscriber';
import { GetSubscriberGlobalPreference } from './get-subscriber-global-preference/get-subscriber-global-preference.usecase';
import { GetSubscriberPreference } from './get-subscriber-preference/get-subscriber-preference.usecase';
import { GetSubscribers } from './get-subscribers';
import { RemoveSubscriber } from './remove-subscriber';
import { SearchByExternalSubscriberIds } from './search-by-external-subscriber-ids';
import { UpdateSubscriberOnlineFlag } from './update-subscriber-online-flag';

export {
  SearchByExternalSubscriberIds,
  SearchByExternalSubscriberIdsCommand,
} from './search-by-external-subscriber-ids';

export const USE_CASES = [
  CreateOrUpdateSubscriberUseCase,
  GetSubscribers,
  GetSubscriber,
  GetSubscriberPreference,
  GetSubscriberTemplatePreference,
  GetPreferencesByLevel,
  RemoveSubscriber,
  SearchByExternalSubscriberIds,
  UpdateSubscriber,
  UpdateSubscriberChannel,
  UpdateSubscriberOnlineFlag,
  ChatOauthCallback,
  ChatOauth,
  DeleteSubscriberCredentials,
  BulkCreateSubscribers,
  GetSubscriberGlobalPreference,
  CreateIntegration,
  CheckIntegration,
  CheckIntegrationEMail,
  GetWorkflowByIdsUseCase,
  UpdatePreferences,
];


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/bulk-create-subscribers/bulk-create-subscribers.command.ts
Tamaño: 499 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentCommand } from '@novu/application-generic';
import { Type } from 'class-transformer';
import { ArrayMaxSize, ArrayNotEmpty, IsArray, ValidateNested } from 'class-validator';
import { CreateSubscriberRequestDto } from '../../dtos';

export class BulkCreateSubscribersCommand extends EnvironmentCommand {
  @IsArray()
  @ArrayNotEmpty()
  @ArrayMaxSize(500)
  @ValidateNested({ each: true })
  @Type(() => CreateSubscriberRequestDto)
  subscribers: CreateSubscriberRequestDto[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class BulkCreateSubscribersCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/bulk-create-subscribers/bulk-create-subscribers.usecase.ts
Tamaño: 773 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable } from '@nestjs/common';
import { SubscriberRepository } from '@novu/dal';
import { BulkCreateSubscriberResponseDto } from '../../dtos/bulk-create-subscriber-response.dto';
import { BulkCreateSubscribersCommand } from './bulk-create-subscribers.command';

@Injectable()
export class BulkCreateSubscribers {
  constructor(private subscriberRepository: SubscriberRepository) {}

  async execute(command: BulkCreateSubscribersCommand): Promise<BulkCreateSubscriberResponseDto> {
    try {
      return await this.subscriberRepository.bulkCreateSubscribers(
        command.subscribers,
        command.environmentId,
        command.organizationId
      );
    } catch (e) {
      throw new BadRequestException(e.message);
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class BulkCreateSubscribers

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/bulk-create-subscribers/index.ts
Tamaño: 157 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export { BulkCreateSubscribersCommand } from './bulk-create-subscribers.command';
export { BulkCreateSubscribers } from './bulk-create-subscribers.usecase';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/chat-oauth-callback/chat-oauth-callback.command.ts
Tamaño: 1366 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BaseCommand } from '@novu/application-generic';
import { ChatProviderIdEnum } from '@novu/shared';
import {
  IsEnum,
  IsMongoId,
  IsOptional,
  IsString,
  registerDecorator,
  ValidationArguments,
  ValidationOptions,
} from 'class-validator';

export function IsNotEmpty(validationOptions?: ValidationOptions) {
  return (object: object, propertyName: string) => {
    registerDecorator({
      name: 'isNotEmpty',
      target: object.constructor,
      propertyName,
      options: validationOptions,
      validator: {
        validate(value: any, args: ValidationArguments) {
          return ![null, undefined, 'null', 'undefined', ''].some((invalidValue) => invalidValue === value);
        },
        defaultMessage(data) {
          const value = data?.value === '' ? 'empty string' : data?.value;

          return `${data?.property} should not be ${value}`;
        },
      },
    });
  };
}

export class ChatOauthCallbackCommand extends BaseCommand {
  @IsMongoId()
  @IsString()
  readonly environmentId: string;

  @IsNotEmpty()
  @IsEnum(ChatProviderIdEnum)
  readonly providerId: ChatProviderIdEnum;

  @IsNotEmpty()
  @IsString()
  readonly subscriberId: string;

  @IsNotEmpty()
  @IsString()
  readonly providerCode: string;

  readonly hmacHash?: string;

  @IsOptional()
  @IsString()
  readonly integrationIdentifier?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - IsNotEmpty(validationOptions?: ValidationOptions)
Declaraciones 'export' encontradas:
- export function IsNotEmpty
- export class ChatOauthCallbackCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/chat-oauth-callback/chat-oauth-callback.result.ts
Tamaño: 168 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export enum ResponseTypeEnum {
  HTML = 'HTML',
  URL = 'URL',
}

export class ChatOauthCallbackResult {
  typeOfResponse: ResponseTypeEnum;

  resultString: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  enum
- export class ChatOauthCallbackResult

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/chat-oauth-callback/chat-oauth-callback.usecase.ts
Tamaño: 6210 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import {
  CreateOrUpdateSubscriberCommand,
  CreateOrUpdateSubscriberUseCase,
  decryptCredentials,
  IChannelCredentialsCommand,
  OAuthHandlerEnum,
  UpdateSubscriberChannel,
  UpdateSubscriberChannelCommand,
} from '@novu/application-generic';
import {
  ChannelTypeEnum,
  EnvironmentEntity,
  EnvironmentRepository,
  IntegrationEntity,
  IntegrationRepository,
} from '@novu/dal';
import { ICredentialsDto } from '@novu/shared';
import axios from 'axios';
import { validateEncryption } from '../chat-oauth/chat-oauth.usecase';
import { ChatOauthCallbackCommand } from './chat-oauth-callback.command';
import { ChatOauthCallbackResult, ResponseTypeEnum } from './chat-oauth-callback.result';

@Injectable()
export class ChatOauthCallback {
  readonly SLACK_ACCESS_URL = 'https://slack.com/api/oauth.v2.access';
  readonly SCRIPT_CLOSE_TAB = '<script>window.close();</script>';

  constructor(
    private updateSubscriberChannelUsecase: UpdateSubscriberChannel,
    private integrationRepository: IntegrationRepository,
    private environmentRepository: EnvironmentRepository,
    private createSubscriberUsecase: CreateOrUpdateSubscriberUseCase
  ) {}

  async execute(command: ChatOauthCallbackCommand): Promise<ChatOauthCallbackResult> {
    const integrationCredentials = await this.getIntegrationCredentials(command);

    const { _organizationId, apiKeys } = await this.getEnvironment(command.environmentId);

    await this.hmacValidation({
      credentialHmac: integrationCredentials.hmac,
      apiKey: apiKeys[0].key,
      subscriberId: command.subscriberId,
      externalHmacHash: command.hmacHash,
    });

    const webhookUrl = await this.getWebhook(command, integrationCredentials);

    await this.createSubscriber(_organizationId, command, webhookUrl);

    if (integrationCredentials && integrationCredentials.redirectUrl) {
      return { typeOfResponse: ResponseTypeEnum.URL, resultString: integrationCredentials.redirectUrl };
    }

    return { typeOfResponse: ResponseTypeEnum.HTML, resultString: this.SCRIPT_CLOSE_TAB };
  }

  private async createSubscriber(
    organizationId: string,
    command: ChatOauthCallbackCommand,
    webhookUrl: string
  ): Promise<void> {
    await this.createSubscriberUsecase.execute(
      CreateOrUpdateSubscriberCommand.create({
        organizationId,
        environmentId: command.environmentId,
        subscriberId: command?.subscriberId,
      })
    );

    const subscriberCredentials: IChannelCredentialsCommand = { webhookUrl, channel: command.providerId };

    await this.updateSubscriberChannelUsecase.execute(
      UpdateSubscriberChannelCommand.create({
        organizationId,
        environmentId: command.environmentId,
        subscriberId: command.subscriberId,
        providerId: command.providerId,
        integrationIdentifier: command.integrationIdentifier,
        credentials: subscriberCredentials,
        oauthHandler: OAuthHandlerEnum.NOVU,
        isIdempotentOperation: false,
      })
    );
  }

  private async getEnvironment(environmentId: string): Promise<EnvironmentEntity> {
    const environment = await this.environmentRepository.findOne({ _id: environmentId });

    if (environment == null) {
      throw new NotFoundException(`Environment ID: ${environmentId} not found`);
    }

    return environment;
  }

  private async getWebhook(
    command: ChatOauthCallbackCommand,
    integrationCredentials: ICredentialsDto
  ): Promise<string> {
    let redirectUri = `${
      process.env.API_ROOT_URL
    }/v1/subscribers/${command.subscriberId}/credentials/${command.providerId}/oauth/callback?environmentId=${command.environmentId}`;

    if (command.integrationIdentifier) {
      redirectUri = `${redirectUri}&integrationIdentifier=${command.integrationIdentifier}`;
    }

    const body = {
      redirect_uri: redirectUri,
      code: command.providerCode,
      client_id: integrationCredentials.clientId,
      client_secret: integrationCredentials.secretKey,
    };
    const config = {
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
    };

    const res = await axios.post(this.SLACK_ACCESS_URL, body, config);
    const webhook = res.data?.incoming_webhook?.url;

    if (res?.data?.ok === false) {
      const metaData = res?.data?.response_metadata?.messages?.join(', ');
      throw new BadRequestException(
        `Provider ${command.providerId} returned error ${res.data.error}${metaData ? `, metadata:${metaData}` : ''}`
      );
    }

    if (!webhook) {
      throw new BadRequestException(`Provider ${command.providerId} did not return a webhook url`);
    }

    return webhook;
  }

  private async getIntegrationCredentials(command: ChatOauthCallbackCommand) {
    const query: Partial<IntegrationEntity> & { _environmentId: string } = {
      _environmentId: command.environmentId,
      channel: ChannelTypeEnum.CHAT,
      providerId: command.providerId,
    };

    if (command.integrationIdentifier) {
      query.identifier = command.integrationIdentifier;
    }

    const integration = await this.integrationRepository.findOne(query, undefined, {
      query: { sort: { createdAt: -1 } },
    });

    if (integration == null) {
      throw new NotFoundException(
        `Integration in environment ${command.environmentId} was not found, channel: ${ChannelTypeEnum.CHAT}, ` +
          `providerId: ${command.providerId}`
      );
    }

    integration.credentials = decryptCredentials(integration.credentials);

    return integration.credentials;
  }

  private async hmacValidation({
    credentialHmac,
    apiKey,
    subscriberId,
    externalHmacHash,
  }: {
    credentialHmac: boolean | undefined;
    apiKey: string;
    subscriberId: string;
    externalHmacHash: string | undefined;
  }) {
    if (credentialHmac) {
      if (!externalHmacHash) {
        throw new BadRequestException(
          'Hmac is enabled on the integration, please provide a HMAC hash on the request params'
        );
      }

      validateEncryption({
        apiKey,
        subscriberId,
        externalHmacHash,
      });
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ChatOauthCallback

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/chat-oauth-callback/is-not-empty.spec.ts
Tamaño: 2454 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

// noinspection ExceptionCaughtLocallyJS

import { BaseCommand, CommandValidationException } from '@novu/application-generic';
import { expect } from 'chai';
import { IsNotEmpty } from './chat-oauth-callback.command';

function assertCommandValidationError(e: CommandValidationException, fieldName: string, fieldMsg: string) {
  if (!(e instanceof CommandValidationException)) {
    throw new Error(e);
  }
  if (!e.constraintsViolated) {
    throw e;
  }
  expect(e.constraintsViolated[fieldName].messages[0]).to.equal(fieldMsg);
}

describe('@IsNotEmpty() validator', () => {
  it('should create command with string name', async () => {
    const validateNameCommand = IsNotEmptyNameCommand.create({ name: 'mike' });

    expect(validateNameCommand.name).to.equal('mike');
  });

  it('should throw exception on string null', async () => {
    const noValidation = NameCommand.create({ name: 'null' } as any);

    try {
      IsNotEmptyNameCommand.create({ name: 'null' } as any);
      throw new Error('should not have passed validation');
    } catch (e) {
      assertCommandValidationError(e, 'name', 'name should not be null');
    }
  });

  it('should throw exception on undefined', async () => {
    const noValidation = NameCommand.create({ name: undefined } as any);

    try {
      const validateNameCommand = IsNotEmptyNameCommand.create({ name: undefined } as any);
      throw new Error('should not have passed validation');
    } catch (e) {
      assertCommandValidationError(e, 'name', 'name should not be undefined');
    }
  });

  it('should throw exception on undefined null', async () => {
    const noValidation = NameCommand.create({ name: 'undefined' } as any);

    try {
      IsNotEmptyNameCommand.create({ name: 'undefined' } as any);
      throw new Error('should not have passed validation');
    } catch (e) {
      assertCommandValidationError(e, 'name', 'name should not be undefined');
    }
  });

  it('should throw exception on empty string', async () => {
    const noValidation = NameCommand.create({ name: '' });

    try {
      IsNotEmptyNameCommand.create({ name: '' });
      throw new Error('should not have passed validation');
    } catch (e) {
      assertCommandValidationError(e, 'name', 'name should not be empty string');
    }
  });
});

export class IsNotEmptyNameCommand extends BaseCommand {
  @IsNotEmpty()
  name?: string;
}

export class NameCommand extends BaseCommand {
  name: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - assertCommandValidationError(e: CommandValidationException, fieldName: string, fieldMsg: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - validateNameCommand(IsNotEmptyNameCommand.create({ name: 'mike' });

    expect(validateNameCommand.name).to.equal('mike...)
 - noValidation(NameCommand.create({ name: 'null' } as any);

    try {
      IsNotEmptyNameCommand.create({ name: '...)
 - validateNameCommand(IsNotEmptyNameCommand.create({ name: undefined } as any);
      throw new Error('should not have pas...)
 - noValidation(NameCommand.create({ name: 'undefined' } as any);

    try {
      IsNotEmptyNameCommand.create({ na...)
Declaraciones 'export' encontradas:
- export class IsNotEmptyNameCommand
- export class NameCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/chat-oauth/chat-oauth.command.ts
Tamaño: 642 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BaseCommand } from '@novu/application-generic';
import { ChatProviderIdEnum } from '@novu/shared';
import { IsEnum, IsMongoId, IsOptional, IsString } from 'class-validator';

import { IsNotEmpty } from '../chat-oauth-callback/chat-oauth-callback.command';

export class ChatOauthCommand extends BaseCommand {
  @IsMongoId()
  @IsString()
  readonly environmentId: string;

  @IsNotEmpty()
  @IsEnum(ChatProviderIdEnum)
  readonly providerId: ChatProviderIdEnum;

  @IsNotEmpty()
  @IsString()
  readonly subscriberId: string;

  @IsOptional()
  @IsString()
  readonly integrationIdentifier?: string;

  readonly hmacHash?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ChatOauthCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/chat-oauth/chat-oauth.usecase.ts
Tamaño: 4307 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import { createHash } from '@novu/application-generic';
import { EnvironmentRepository, ICredentialsEntity, IntegrationEntity, IntegrationRepository } from '@novu/dal';
import { ChannelTypeEnum } from '@novu/stateless';

import { ChatOauthCommand } from './chat-oauth.command';

@Injectable()
export class ChatOauth {
  readonly SLACK_OAUTH_URL = 'https://slack.com/oauth/v2/authorize?';

  constructor(
    private integrationRepository: IntegrationRepository,
    private environmentRepository: EnvironmentRepository
  ) {}
  async execute(command: ChatOauthCommand): Promise<string> {
    const { clientId, hmac } = await this.getCredentials(command);

    await this.hmacValidation({
      credentialHmac: hmac,
      environmentId: command.environmentId,
      subscriberId: command.subscriberId,
      externalHmacHash: command.hmacHash,
    });

    return this.getOAuthUrl(command.subscriberId, command.environmentId, clientId!, command.integrationIdentifier);
  }

  private async hmacValidation({
    credentialHmac,
    environmentId,
    subscriberId,
    externalHmacHash,
  }: {
    credentialHmac: boolean | undefined;
    environmentId: string;
    subscriberId: string;
    externalHmacHash: string | undefined;
  }) {
    if (credentialHmac) {
      if (!externalHmacHash) {
        throw new BadRequestException(
          'Hmac is enabled on the integration, please provide a HMAC hash on the request params'
        );
      }

      const apiKey = await this.getEnvironmentApiKey(environmentId);

      validateEncryption({
        apiKey,
        subscriberId,
        externalHmacHash,
      });
    }
  }

  private getOAuthUrl(
    subscriberId: string,
    environmentId: string,
    clientId: string,
    integrationIdentifier?: string
  ): string {
    let redirectUri = `${
      process.env.API_ROOT_URL
    }/v1/subscribers/${subscriberId}/credentials/slack/oauth/callback?environmentId=${environmentId}`;

    if (integrationIdentifier) {
      redirectUri = `${redirectUri}&integrationIdentifier=${integrationIdentifier}`;
    }

    return `${
      this.SLACK_OAUTH_URL
    }client_id=${clientId}&scope=incoming-webhook&user_scope=&redirect_uri=${encodeURIComponent(redirectUri)}`;
  }

  private async getCredentials(command: ChatOauthCommand): Promise<ICredentialsEntity> {
    const query: Partial<IntegrationEntity> & { _environmentId: string } = {
      _environmentId: command.environmentId,
      channel: ChannelTypeEnum.CHAT,
      providerId: command.providerId,
    };

    if (command.integrationIdentifier) {
      query.identifier = command.integrationIdentifier;
    }

    const integration = await this.integrationRepository.findOne(query, undefined, {
      query: { sort: { createdAt: -1 } },
    });

    if (!integration) {
      throw new NotFoundException(
        `Integration in environment ${command.environmentId} was not found, channel: ${ChannelTypeEnum.CHAT}, ` +
          `providerId: ${command.providerId}`
      );
    }

    if (!integration.credentials) {
      throw new NotFoundException(
        `Integration in environment ${command.environmentId} missing credentials, channel: ${ChannelTypeEnum.CHAT}, ` +
          `providerId: ${command.providerId}`
      );
    }

    if (!integration.credentials.clientId) {
      throw new NotFoundException(
        `Integration in environment ${command.environmentId} missing clientId, channel: ${ChannelTypeEnum.CHAT}, ` +
          `providerId: ${command.providerId}`
      );
    }

    return integration.credentials;
  }

  private async getEnvironmentApiKey(environmentId: string): Promise<string> {
    const apiKeys = await this.environmentRepository.getApiKeys(environmentId);

    if (!apiKeys.length) {
      throw new NotFoundException(`Environment ID: ${environmentId} not found`);
    }

    return apiKeys[0].key;
  }
}

export function validateEncryption({
  apiKey,
  subscriberId,
  externalHmacHash,
}: {
  apiKey: string;
  subscriberId: string;
  externalHmacHash: string;
}) {
  const hmacHash = createHash(apiKey, subscriberId);
  if (hmacHash !== externalHmacHash) {
    throw new BadRequestException('Hmac is enabled on the integration, please provide a valid HMAC hash');
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - validateEncryption({
  apiKey,
  subscriberId,
  externalHmacHash,
}: {
  apiKey: string;
  subscriberId: string;
  externalHmacHash: string;
})
Declaraciones 'export' encontradas:
- export class ChatOauth
- export function validateEncryption

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/delete-subscriber-credentials/delete-subscriber-credentials.command.ts
Tamaño: 393 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChatProviderIdEnum, PushProviderIdEnum } from '@novu/shared';
import { IsNotEmpty, IsString } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';

export class DeleteSubscriberCredentialsCommand extends EnvironmentCommand {
  @IsString()
  @IsNotEmpty()
  subscriberId: string;

  @IsString()
  @IsNotEmpty()
  providerId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DeleteSubscriberCredentialsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/delete-subscriber-credentials/delete-subscriber-credentials.spec.ts
Tamaño: 6126 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Test } from '@nestjs/testing';
import { OAuthHandlerEnum, UpdateSubscriberChannel, UpdateSubscriberChannelCommand } from '@novu/application-generic';
import { SubscriberRepository } from '@novu/dal';
import { ChannelTypeEnum, ChatProviderIdEnum, PushProviderIdEnum } from '@novu/shared';
import { SubscribersService, UserSession } from '@novu/testing';
import { expect } from 'chai';
import { CheckIntegration } from '../../../integrations/usecases/check-integration/check-integration.usecase';
import { CheckIntegrationEMail } from '../../../integrations/usecases/check-integration/check-integration-email.usecase';
import { CreateIntegrationCommand } from '../../../integrations/usecases/create-integration/create-integration.command';
import { CreateIntegration } from '../../../integrations/usecases/create-integration/create-integration.usecase';
import { SharedModule } from '../../../shared/shared.module';
import { GetSubscriber } from '../get-subscriber/get-subscriber.usecase';
import { DeleteSubscriberCredentialsCommand } from './delete-subscriber-credentials.command';
import { DeleteSubscriberCredentials } from './delete-subscriber-credentials.usecase';

describe('Delete subscriber provider credentials', () => {
  let createIntegrationUseCase: CreateIntegration;
  let updateSubscriberChannelUsecase: UpdateSubscriberChannel;
  let deleteSubscriberCredentialsUsecase: DeleteSubscriberCredentials;
  let session: UserSession;
  const subscriberRepository = new SubscriberRepository();
  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [SharedModule],
      providers: [
        DeleteSubscriberCredentials,
        UpdateSubscriberChannel,
        GetSubscriber,
        CreateIntegration,
        CheckIntegration,
        CheckIntegrationEMail,
      ],
    }).compile();

    session = new UserSession();
    await session.initialize();

    updateSubscriberChannelUsecase = moduleRef.get<UpdateSubscriberChannel>(UpdateSubscriberChannel);
    deleteSubscriberCredentialsUsecase = moduleRef.get<DeleteSubscriberCredentials>(DeleteSubscriberCredentials);
    createIntegrationUseCase = moduleRef.get<CreateIntegration>(CreateIntegration);
  });

  it('should delete subscriber discord provider credentials', async () => {
    const subscriberService = new SubscribersService(session.organization._id, session.environment._id);
    const subscriber = await subscriberService.createSubscriber();
    const fcmTokens = ['token1', 'token2'];

    const firstDiscordIntegration = await createIntegrationUseCase.execute(
      CreateIntegrationCommand.create({
        organizationId: subscriber._organizationId,
        environmentId: session.environment._id,
        channel: ChannelTypeEnum.CHAT,
        credentials: {},
        providerId: ChatProviderIdEnum.Discord,
        active: true,
        check: false,
        userId: session.user._id,
      })
    );

    const secondDiscordIntegration = await createIntegrationUseCase.execute(
      CreateIntegrationCommand.create({
        organizationId: subscriber._organizationId,
        environmentId: session.environment._id,
        channel: ChannelTypeEnum.CHAT,
        credentials: {},
        providerId: ChatProviderIdEnum.Discord,
        active: true,
        check: false,
        userId: session.user._id,
      })
    );

    await updateSubscriberChannelUsecase.execute(
      UpdateSubscriberChannelCommand.create({
        organizationId: subscriber._organizationId,
        subscriberId: subscriber.subscriberId,
        environmentId: session.environment._id,
        providerId: ChatProviderIdEnum.Discord,
        credentials: { webhookUrl: 'newWebhookUrl' },
        integrationIdentifier: firstDiscordIntegration.identifier,
        oauthHandler: OAuthHandlerEnum.NOVU,
        isIdempotentOperation: false,
      })
    );

    await updateSubscriberChannelUsecase.execute(
      UpdateSubscriberChannelCommand.create({
        organizationId: subscriber._organizationId,
        subscriberId: subscriber.subscriberId,
        environmentId: session.environment._id,
        providerId: ChatProviderIdEnum.Discord,
        credentials: { webhookUrl: 'newWebhookUrl' },
        integrationIdentifier: secondDiscordIntegration.identifier,
        oauthHandler: OAuthHandlerEnum.NOVU,
        isIdempotentOperation: false,
      })
    );

    const fcmUpdate = await updateSubscriberChannelUsecase.execute(
      UpdateSubscriberChannelCommand.create({
        organizationId: subscriber._organizationId,
        subscriberId: subscriber.subscriberId,
        environmentId: session.environment._id,
        providerId: PushProviderIdEnum.FCM,
        credentials: { deviceTokens: fcmTokens },
        oauthHandler: OAuthHandlerEnum.NOVU,
        isIdempotentOperation: false,
      })
    );

    let updatedSubscriber = await subscriberRepository.findOne({
      _id: subscriber._id,
      _environmentId: subscriber._environmentId,
    });

    const newDiscordProviders = updatedSubscriber?.channels?.filter(
      (channel) => channel.providerId === ChatProviderIdEnum.Discord
    );

    expect(newDiscordProviders?.length).to.equal(2);

    await deleteSubscriberCredentialsUsecase.execute(
      DeleteSubscriberCredentialsCommand.create({
        organizationId: subscriber._organizationId,
        subscriberId: subscriber.subscriberId,
        environmentId: session.environment._id,
        providerId: ChatProviderIdEnum.Discord,
      })
    );

    updatedSubscriber = await subscriberRepository.findOne({
      _id: subscriber._id,
      _environmentId: subscriber._environmentId,
    });

    const areDiscordProviderIntegrationsDeleted = updatedSubscriber?.channels?.find(
      (channel) => channel.providerId === ChatProviderIdEnum.Discord
    );
    const fcmCredentials = updatedSubscriber?.channels?.find(
      (channel) => channel.providerId === PushProviderIdEnum.FCM
    );
    expect(areDiscordProviderIntegrationsDeleted).to.equal(undefined);
    expect(fcmCredentials?.credentials.deviceTokens).to.deep.equal(['identifier', ...fcmTokens]);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - subscriberRepository(new SubscriberRepository();
  beforeEach(async ())
 - createIntegrationUseCase(moduleRef.get<CreateIntegration>(CreateIntegration);
  });

  it('should delete subscriber discord p...)
 - newDiscordProviders(updatedSubscriber?.channels?.filter(
      (channel))
 - areDiscordProviderIntegrationsDeleted(updatedSubscriber?.channels?.find(
      (channel))
 - fcmCredentials(updatedSubscriber?.channels?.find(
      (channel))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/delete-subscriber-credentials/delete-subscriber-credentials.usecase.ts
Tamaño: 1814 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { AnalyticsService, buildSubscriberKey, InvalidateCacheService } from '@novu/application-generic';
import { SubscriberRepository } from '@novu/dal';
import { GetSubscriber, GetSubscriberCommand } from '../get-subscriber';
import { DeleteSubscriberCredentialsCommand } from './delete-subscriber-credentials.command';

@Injectable()
export class DeleteSubscriberCredentials {
  constructor(
    private invalidateCache: InvalidateCacheService,
    private subscriberRepository: SubscriberRepository,
    private analyticsService: AnalyticsService,
    private getSubscriberUseCase: GetSubscriber
  ) {}

  async execute(command: DeleteSubscriberCredentialsCommand): Promise<void> {
    const foundSubscriber = await this.getSubscriberUseCase.execute(
      GetSubscriberCommand.create({
        ...command,
      })
    );

    await this.deleteSubscriberCredentialsOfOneProvider(
      foundSubscriber.subscriberId,
      command.environmentId,
      command.providerId,
      foundSubscriber._id
    );

    this.analyticsService.mixpanelTrack('Delete Subscriber Credentials - [Subscribers]', '', {
      providerId: command.providerId,
      _organization: command.organizationId,
      _subscriberId: foundSubscriber._id,
    });
  }

  private async deleteSubscriberCredentialsOfOneProvider(
    subscriberId: string,
    environmentId: string,
    providerId: string,
    _subscriberId: string
  ) {
    await this.invalidateCache.invalidateByKey({
      key: buildSubscriberKey({
        subscriberId,
        _environmentId: environmentId,
      }),
    });

    return await this.subscriberRepository.updateOne(
      {
        _id: _subscriberId,
        _environmentId: environmentId,
      },
      { $pull: { channels: { providerId } } }
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DeleteSubscriberCredentials

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/delete-subscriber-credentials/index.ts
Tamaño: 114 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './delete-subscriber-credentials.command';
export * from './delete-subscriber-credentials.usecase';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/get-preferences-by-level/get-preferences-by-level.command.ts
Tamaño: 488 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { PreferenceLevelEnum } from '@novu/shared';
import { IsBoolean, IsDefined, IsEnum, IsOptional, IsString } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';

export class GetPreferencesByLevelCommand extends EnvironmentCommand {
  @IsString()
  @IsDefined()
  subscriberId: string;

  @IsEnum(PreferenceLevelEnum)
  @IsDefined()
  level: PreferenceLevelEnum;

  @IsBoolean()
  @IsDefined()
  includeInactiveChannels: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetPreferencesByLevelCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/get-preferences-by-level/get-preferences-by-level.usecase.ts
Tamaño: 2222 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, ServiceUnavailableException } from '@nestjs/common';
import { FeatureFlagsService } from '@novu/application-generic';
import { FeatureFlagsKeysEnum, PreferenceLevelEnum, WorkflowCriticalityEnum } from '@novu/shared';
import {
  GetSubscriberGlobalPreference,
  GetSubscriberGlobalPreferenceCommand,
} from '../get-subscriber-global-preference';
import { GetSubscriberPreference, GetSubscriberPreferenceCommand } from '../get-subscriber-preference';
import { GetPreferencesByLevelCommand } from './get-preferences-by-level.command';

@Injectable()
export class GetPreferencesByLevel {
  constructor(
    private getSubscriberPreferenceUsecase: GetSubscriberPreference,
    private getSubscriberGlobalPreference: GetSubscriberGlobalPreference,
    private featureFlagsService: FeatureFlagsService
  ) {}

  async execute(command: GetPreferencesByLevelCommand) {
    const isGetPreferencesDisabled = await this.featureFlagsService.getFlag({
      key: FeatureFlagsKeysEnum.IS_GET_PREFERENCES_DISABLED,
      defaultValue: false,
      organization: { _id: command.organizationId },
      environment: { _id: command.environmentId },
    });

    if (isGetPreferencesDisabled) {
      throw new ServiceUnavailableException('Get preferences service is currently unavailable');
    }

    if (command.level === PreferenceLevelEnum.GLOBAL) {
      const globalPreferenceCommand = GetSubscriberGlobalPreferenceCommand.create({
        organizationId: command.organizationId,
        environmentId: command.environmentId,
        subscriberId: command.subscriberId,
        includeInactiveChannels: command.includeInactiveChannels,
      });
      const globalPreferences = await this.getSubscriberGlobalPreference.execute(globalPreferenceCommand);

      return [globalPreferences];
    }

    const preferenceCommand = GetSubscriberPreferenceCommand.create({
      organizationId: command.organizationId,
      environmentId: command.environmentId,
      subscriberId: command.subscriberId,
      includeInactiveChannels: command.includeInactiveChannels,
      criticality: WorkflowCriticalityEnum.NON_CRITICAL,
    });

    return await this.getSubscriberPreferenceUsecase.execute(preferenceCommand);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetPreferencesByLevel

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/get-subscriber-global-preference/get-subscriber-global-preference.command.ts
Tamaño: 390 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentWithSubscriber } from '@novu/application-generic';
import { SubscriberEntity } from '@novu/dal';
import { IsBoolean, IsDefined, IsOptional } from 'class-validator';

export class GetSubscriberGlobalPreferenceCommand extends EnvironmentWithSubscriber {
  @IsBoolean()
  @IsDefined()
  includeInactiveChannels: boolean;

  @IsOptional()
  subscriber?: SubscriberEntity;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetSubscriberGlobalPreferenceCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/get-subscriber-global-preference/get-subscriber-global-preference.usecase.ts
Tamaño: 3917 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import {
  buildSubscriberKey,
  CachedResponse,
  filteredPreference,
  GetPreferences,
  Instrument,
  InstrumentUsecase,
} from '@novu/application-generic';
import {
  NotificationTemplateEntity,
  NotificationTemplateRepository,
  SubscriberEntity,
  SubscriberRepository,
} from '@novu/dal';
import { ChannelTypeEnum, IPreferenceChannels, Schedule } from '@novu/shared';
import { GetSubscriberGlobalPreferenceCommand } from './get-subscriber-global-preference.command';

@Injectable()
export class GetSubscriberGlobalPreference {
  constructor(
    private subscriberRepository: SubscriberRepository,
    private getPreferences: GetPreferences,
    private notificationTemplateRepository: NotificationTemplateRepository
  ) {}

  @InstrumentUsecase()
  async execute(
    command: GetSubscriberGlobalPreferenceCommand
  ): Promise<{ preference: { enabled: boolean; channels: IPreferenceChannels; schedule?: Schedule } }> {
    const subscriber = command.subscriber ?? (await this.getSubscriber(command));

    const activeChannels = await this.getActiveChannels(command);

    const subscriberGlobalPreference = await this.getPreferences.getSubscriberGlobalPreference({
      environmentId: command.environmentId,
      organizationId: command.organizationId,
      subscriberId: subscriber._id,
    });

    const channelsWithDefaults = this.buildDefaultPreferences(subscriberGlobalPreference.channels);

    let channels: IPreferenceChannels;
    if (command.includeInactiveChannels === true) {
      channels = channelsWithDefaults;
    } else {
      channels = filteredPreference(channelsWithDefaults, activeChannels);
    }

    return {
      preference: {
        enabled: subscriberGlobalPreference.enabled,
        channels,
        schedule: subscriberGlobalPreference.schedule,
      },
    };
  }

  @Instrument()
  private async getActiveChannels(command: GetSubscriberGlobalPreferenceCommand): Promise<ChannelTypeEnum[]> {
    const workflowList = await this.notificationTemplateRepository.filterActive({
      organizationId: command.organizationId,
      environmentId: command.environmentId,
    });

    const activeChannels = new Set<ChannelTypeEnum>();

    for (const workflow of workflowList) {
      const workflowChannels = this.getChannels(workflow, command.includeInactiveChannels);
      for (const channel of workflowChannels) {
        activeChannels.add(channel);
      }
    }

    return Array.from(activeChannels);
  }

  private getChannels(workflow: NotificationTemplateEntity, includeInactiveChannels: boolean): ChannelTypeEnum[] {
    if (includeInactiveChannels) {
      return Object.values(ChannelTypeEnum);
    }

    const channelSet = new Set<ChannelTypeEnum>();

    for (const step of workflow.steps) {
      if (step.active && step.template?.type) {
        channelSet.add(step.template.type as unknown as ChannelTypeEnum);
      }
    }

    return Array.from(channelSet);
  }

  @CachedResponse({
    builder: (command: { subscriberId: string; _environmentId: string }) =>
      buildSubscriberKey({
        _environmentId: command._environmentId,
        subscriberId: command.subscriberId,
      }),
  })
  private async getSubscriber(command: GetSubscriberGlobalPreferenceCommand): Promise<SubscriberEntity> {
    const subscriber = await this.subscriberRepository.findBySubscriberId(command.environmentId, command.subscriberId);

    if (!subscriber) {
      throw new NotFoundException(`Subscriber ${command.subscriberId} not found`);
    }

    return subscriber;
  }
  // adds default state for missing channels
  private buildDefaultPreferences(preference: IPreferenceChannels) {
    const defaultPreference: IPreferenceChannels = {
      email: true,
      sms: true,
      in_app: true,
      chat: true,
      push: true,
    };

    return { ...defaultPreference, ...preference };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - channelSet(new Set<ChannelTypeEnum>();

    for (const step of workflow.steps) {
      if (step.active && step....)
Declaraciones 'export' encontradas:
- export class GetSubscriberGlobalPreference

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/get-subscriber-global-preference/index.ts
Tamaño: 120 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './get-subscriber-global-preference.command';
export * from './get-subscriber-global-preference.usecase';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/get-subscriber-preference/get-subscriber-preference.command.ts
Tamaño: 764 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentWithSubscriber } from '@novu/application-generic';
import { SubscriberEntity } from '@novu/dal';
import { SeverityLevelEnum, WorkflowCriticalityEnum } from '@novu/shared';
import { IsArray, IsBoolean, IsDefined, IsEnum, IsOptional, IsString } from 'class-validator';

export class GetSubscriberPreferenceCommand extends EnvironmentWithSubscriber {
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  tags?: string[];

  @IsOptional()
  @IsArray()
  @IsEnum(SeverityLevelEnum, { each: true })
  severity?: SeverityLevelEnum[];

  @IsBoolean()
  @IsDefined()
  includeInactiveChannels: boolean;

  @IsEnum(WorkflowCriticalityEnum)
  @IsOptional()
  criticality: WorkflowCriticalityEnum;

  @IsOptional()
  subscriber?: SubscriberEntity;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetSubscriberPreferenceCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/get-subscriber-preference/get-subscriber-preference.usecase.ts
Tamaño: 9297 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import {
  filteredPreference,
  GetPreferences,
  GetPreferencesResponseDto,
  Instrument,
  InstrumentUsecase,
  MergePreferences,
  MergePreferencesCommand,
  mapTemplateConfiguration,
  overridePreferences,
  PreferenceSet,
} from '@novu/application-generic';
import {
  NotificationTemplateEntity,
  NotificationTemplateRepository,
  PreferencesEntity,
  PreferencesRepository,
  SubscriberRepository,
} from '@novu/dal';
import {
  ChannelTypeEnum,
  IPreferenceChannels,
  ISubscriberPreferenceResponse,
  PreferencesTypeEnum,
  WorkflowCriticalityEnum,
} from '@novu/shared';
import { chunk } from 'es-toolkit';
import { GetSubscriberPreferenceCommand } from './get-subscriber-preference.command';

@Injectable()
export class GetSubscriberPreference {
  constructor(
    private subscriberRepository: SubscriberRepository,
    private notificationTemplateRepository: NotificationTemplateRepository,
    private preferencesRepository: PreferencesRepository
  ) {}

  @InstrumentUsecase()
  async execute(command: GetSubscriberPreferenceCommand): Promise<ISubscriberPreferenceResponse[]> {
    const subscriber =
      command.subscriber ??
      (await this.subscriberRepository.findBySubscriberId(command.environmentId, command.subscriberId));
    if (!subscriber) {
      throw new NotFoundException(`Subscriber with id: ${command.subscriberId} not found`);
    }

    const workflowList = await this.notificationTemplateRepository.filterActive({
      organizationId: command.organizationId,
      environmentId: command.environmentId,
      tags: command.tags,
      severity: command.severity,
    });

    const workflowIds = workflowList.map((wf) => wf._id);

    const {
      workflowResourcePreferences,
      workflowUserPreferences,
      subscriberWorkflowPreferences,
      subscriberGlobalPreference,
    } = await this.findAllPreferences({
      environmentId: command.environmentId,
      organizationId: command.organizationId,
      subscriberId: subscriber._id,
      workflowIds,
    });

    const allWorkflowPreferences = [
      ...workflowResourcePreferences,
      ...workflowUserPreferences,
      ...subscriberWorkflowPreferences,
    ];

    const workflowPreferenceSets = allWorkflowPreferences.reduce<Record<string, PreferenceSet>>((acc, preference) => {
      const workflowId = preference._templateId;

      // Skip if the preference is not for a workflow
      if (workflowId === undefined) {
        return acc;
      }

      if (!acc[workflowId]) {
        acc[workflowId] = {
          workflowResourcePreference: undefined,
          workflowUserPreference: undefined,
          subscriberWorkflowPreference: undefined,
        };
      }
      switch (preference.type) {
        case PreferencesTypeEnum.WORKFLOW_RESOURCE:
          acc[workflowId].workflowResourcePreference = preference as PreferenceSet['workflowResourcePreference'];
          break;
        case PreferencesTypeEnum.USER_WORKFLOW:
          acc[workflowId].workflowUserPreference = preference as PreferenceSet['workflowUserPreference'];
          break;
        case PreferencesTypeEnum.SUBSCRIBER_WORKFLOW:
          acc[workflowId].subscriberWorkflowPreference = preference;
          break;
        default:
      }

      return acc;
    }, {});

    const workflowPreferences = await this.calculateWorkflowPreferences(
      workflowList,
      workflowPreferenceSets,
      subscriberGlobalPreference,
      command.includeInactiveChannels
    );

    const nonCriticalWorkflowPreferences = workflowPreferences.filter(
      (preference): preference is ISubscriberPreferenceResponse => {
        if (preference === undefined) {
          return false;
        }

        if (command.criticality === WorkflowCriticalityEnum.ALL) {
          return true;
        }

        if (command.criticality === WorkflowCriticalityEnum.CRITICAL) {
          return preference.template.critical === true;
        }

        return preference.template.critical === false;
      }
    );

    return nonCriticalWorkflowPreferences;
  }

  @Instrument()
  private async calculateWorkflowPreferences(
    workflowList: NotificationTemplateEntity[],
    workflowPreferenceSets: Record<string, PreferenceSet>,
    subscriberGlobalPreference: PreferencesEntity | null,
    includeInactiveChannels: boolean
  ): Promise<(ISubscriberPreferenceResponse | undefined)[]> {
    const chunkSize = 30;
    const results: (ISubscriberPreferenceResponse | undefined)[] = [];

    const chunks = chunk(workflowList, chunkSize);

    for (const chunk of chunks) {
      // Use setImmediate to yield to the event loop between chunks
      await new Promise<void>((resolve) => {
        setImmediate(() => resolve());
      });

      const chunkResults = chunk
        .map((workflow) => {
          const preferences = workflowPreferenceSets[workflow._id];

          if (!preferences) {
            return null;
          }

          const merged = this.mergePreferences(preferences, subscriberGlobalPreference);

          const includedChannels = this.getChannels(workflow, includeInactiveChannels);

          const initialChannels = filteredPreference(
            {
              email: true,
              sms: true,
              in_app: true,
              chat: true,
              push: true,
            },
            includedChannels
          );

          const { channels, overrides } = this.calculateChannelsAndOverrides(merged, initialChannels);

          return {
            preference: {
              channels,
              enabled: true,
              overrides,
            },
            template: mapTemplateConfiguration({
              ...workflow,
              critical: merged.preferences.all.readOnly,
            }),
            type: PreferencesTypeEnum.SUBSCRIBER_WORKFLOW,
          };
        })
        .filter((item): item is ISubscriberPreferenceResponse => item !== null);

      results.push(...chunkResults);
    }

    return results;
  }

  @Instrument()
  private calculateChannelsAndOverrides(merged: GetPreferencesResponseDto, initialChannels: IPreferenceChannels) {
    return overridePreferences(
      {
        template: GetPreferences.mapWorkflowPreferencesToChannelPreferences(merged.source.WORKFLOW_RESOURCE),
        subscriber: GetPreferences.mapWorkflowPreferencesToChannelPreferences(merged.preferences),
        workflowOverride: {},
      },
      initialChannels
    );
  }

  @Instrument()
  private mergePreferences(preferences: PreferenceSet, subscriberGlobalPreference: PreferencesEntity | null) {
    const mergeCommand = MergePreferencesCommand.create({
      workflowResourcePreference: preferences.workflowResourcePreference,
      workflowUserPreference: preferences.workflowUserPreference,
      subscriberWorkflowPreference: preferences.subscriberWorkflowPreference,
      ...(subscriberGlobalPreference ? { subscriberGlobalPreference } : {}),
    });

    return MergePreferences.execute(mergeCommand);
  }

  private getChannels(workflow: NotificationTemplateEntity, includeInactiveChannels: boolean): ChannelTypeEnum[] {
    if (includeInactiveChannels) {
      return Object.values(ChannelTypeEnum);
    }

    const channelSet = new Set<ChannelTypeEnum>();

    for (const step of workflow.steps) {
      if (step.active && step.template?.type) {
        channelSet.add(step.template.type as unknown as ChannelTypeEnum);
      }
    }

    return Array.from(channelSet);
  }

  @Instrument()
  private async findAllPreferences({
    environmentId,
    organizationId,
    subscriberId,
    workflowIds,
  }: {
    environmentId: string;
    organizationId: string;
    subscriberId: string;
    workflowIds: string[];
  }) {
    const baseQuery = {
      _environmentId: environmentId,
      _organizationId: organizationId,
    };

    const readOptions = { readPreference: 'secondaryPreferred' as const };

    const [
      workflowResourcePreferences,
      workflowUserPreferences,
      subscriberWorkflowPreferences,
      subscriberGlobalPreferences,
    ] = await Promise.all([
      this.preferencesRepository.find(
        {
          ...baseQuery,
          _templateId: { $in: workflowIds },
          type: PreferencesTypeEnum.WORKFLOW_RESOURCE,
        },
        undefined,
        readOptions
      ),
      this.preferencesRepository.find(
        {
          ...baseQuery,
          _templateId: { $in: workflowIds },
          type: PreferencesTypeEnum.USER_WORKFLOW,
        },
        undefined,
        readOptions
      ),
      this.preferencesRepository.find(
        {
          ...baseQuery,
          _subscriberId: subscriberId,
          _templateId: { $in: workflowIds },
          type: PreferencesTypeEnum.SUBSCRIBER_WORKFLOW,
        },
        undefined,
        readOptions
      ),
      this.preferencesRepository.find(
        {
          ...baseQuery,
          _subscriberId: subscriberId,
          type: PreferencesTypeEnum.SUBSCRIBER_GLOBAL,
        },
        undefined,
        readOptions
      ),
    ]);

    return {
      workflowResourcePreferences,
      workflowUserPreferences,
      subscriberWorkflowPreferences,
      subscriberGlobalPreference: subscriberGlobalPreferences[0] ?? null,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - workflowIds(workflowList.map((wf))
 - workflowPreferenceSets(allWorkflowPreferences.reduce<Record<string, PreferenceSet>>((acc, preference))
 - nonCriticalWorkflowPreferences(workflowPreferences.filter(
      (preference): preference is ISubscriberPreferenceResponse)
 - chunks(chunk(workflowList, chunkSize);

    for (const chunk of chunks) {
      // Use setImmediate to yiel...)
 - chunkResults(chunk
        .map((workflow))
Declaraciones 'export' encontradas:
- export class GetSubscriberPreference

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/get-subscriber-preference/index.ts
Tamaño: 106 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './get-subscriber-preference.command';
export * from './get-subscriber-preference.usecase';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/get-subscriber/get-subscriber.command.ts
Tamaño: 335 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsBoolean, IsDefined, IsOptional, IsString } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';

export class GetSubscriberCommand extends EnvironmentCommand {
  @IsString()
  @IsDefined()
  subscriberId: string;

  @IsBoolean()
  @IsOptional()
  includeTopics?: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetSubscriberCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/get-subscriber/get-subscriber.spec.ts
Tamaño: 2022 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { NotFoundException } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { SubscribersService, UserSession } from '@novu/testing';
import { expect } from 'chai';
import { SharedModule } from '../../../shared/shared.module';
import { SubscribersV1Module } from '../../subscribersV1.module';
import { GetSubscriberCommand } from './get-subscriber.command';
import { GetSubscriber } from './get-subscriber.usecase';

describe('Get Subscriber', () => {
  let useCase: GetSubscriber;
  let session: UserSession;

  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [SharedModule, SubscribersV1Module],
      providers: [],
    }).compile();

    session = new UserSession();
    await session.initialize();

    useCase = moduleRef.get<GetSubscriber>(GetSubscriber);
  });

  it('should get a subscriber', async () => {
    const subscriberService = new SubscribersService(session.organization._id, session.environment._id);
    const subscriber = await subscriberService.createSubscriber();
    const res = await useCase.execute(
      GetSubscriberCommand.create({
        subscriberId: subscriber.subscriberId,
        environmentId: session.environment._id,
        organizationId: session.organization._id,
      })
    );
    expect(res.subscriberId).to.equal(subscriber.subscriberId);
  });

  it('should get a not found exception if subscriber does not exist', async () => {
    const subscriberService = new SubscribersService(session.organization._id, session.environment._id);

    try {
      await useCase.execute(
        GetSubscriberCommand.create({
          subscriberId: 'invalid-subscriber-id',
          environmentId: session.environment._id,
          organizationId: session.organization._id,
        })
      );
      throw new Error('Should not reach here');
    } catch (e) {
      expect(e).to.be.instanceOf(NotFoundException);
      expect(e.message).to.eql("Subscriber 'invalid-subscriber-id' was not found");
    }
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - useCase(moduleRef.get<GetSubscriber>(GetSubscriber);
  });

  it('should get a subscriber', async ())
 - res(await useCase.execute(
      GetSubscriberCommand.create({
        subscriberId: subscriber.subscrib...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/get-subscriber/get-subscriber.usecase.ts
Tamaño: 2020 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { buildSubscriberKey, CachedResponse } from '@novu/application-generic';
import { SubscriberEntity, SubscriberRepository, TopicSubscribersRepository } from '@novu/dal';

import { GetSubscriberCommand } from './get-subscriber.command';

@Injectable()
export class GetSubscriber {
  constructor(
    private subscriberRepository: SubscriberRepository,
    private topicSubscriberRepository: TopicSubscribersRepository
  ) {}

  async execute(command: GetSubscriberCommand): Promise<SubscriberEntity> {
    const { environmentId, subscriberId, includeTopics } = command;
    const subscribePromise = this.fetchSubscriber({ _environmentId: environmentId, subscriberId });
    const subscriberTopicsPromise = includeTopics
      ? this.fetchSubscriberTopics({ _environmentId: environmentId, subscriberId })
      : null;

    const [subscriber, topics] = await Promise.all([subscribePromise, subscriberTopicsPromise]);

    if (!subscriber) {
      throw new NotFoundException(`Subscriber '${subscriberId}' was not found`);
    }

    if (includeTopics) {
      subscriber.topics = topics || [];
    }

    return subscriber;
  }

  @CachedResponse({
    builder: (command: { subscriberId: string; _environmentId: string }) =>
      buildSubscriberKey({
        _environmentId: command._environmentId,
        subscriberId: command.subscriberId,
      }),
  })
  private async fetchSubscriber({
    subscriberId,
    _environmentId,
  }: {
    subscriberId: string;
    _environmentId: string;
  }): Promise<SubscriberEntity | null> {
    return await this.subscriberRepository.findBySubscriberId(_environmentId, subscriberId);
  }

  private async fetchSubscriberTopics({
    subscriberId,
    _environmentId,
  }: {
    subscriberId: string;
    _environmentId: string;
  }): Promise<string[]> {
    return await this.topicSubscriberRepository._model.distinct('topicKey', {
      _environmentId,
      externalSubscriberId: subscriberId,
    });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - topics(topics || [];
    }

    return subscriber;
  }

  @CachedResponse({
    builder: (command: { subscr...)
Declaraciones 'export' encontradas:
- export class GetSubscriber

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/get-subscriber/index.ts
Tamaño: 84 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './get-subscriber.command';
export * from './get-subscriber.usecase';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/get-subscribers/get-subscribers.command.ts
Tamaño: 296 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsNumber, IsOptional } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';

export class GetSubscribersCommand extends EnvironmentCommand {
  @IsNumber()
  @IsOptional()
  page: number;

  @IsNumber()
  @IsOptional()
  limit: number;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetSubscribersCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/get-subscribers/get-subscribers.usecase.ts
Tamaño: 735 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { SubscriberRepository } from '@novu/dal';
import { GetSubscribersCommand } from './get-subscribers.command';

@Injectable()
export class GetSubscribers {
  constructor(private subscriberRepository: SubscriberRepository) {}

  async execute(command: GetSubscribersCommand) {
    const query = {
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
    };

    const data = await this.subscriberRepository.find(query, '', {
      limit: command.limit,
      skip: command.page * command.limit,
    });

    return {
      page: command.page,
      hasMore: data?.length === command.limit,
      pageSize: command.limit,
      data,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetSubscribers

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/get-subscribers/index.ts
Tamaño: 86 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './get-subscribers.command';
export * from './get-subscribers.usecase';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/remove-subscriber/index.ts
Tamaño: 90 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './remove-subscriber.command';
export * from './remove-subscriber.usecase';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/remove-subscriber/remove-subscriber.command.ts
Tamaño: 230 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsString } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';

export class RemoveSubscriberCommand extends EnvironmentCommand {
  @IsString()
  subscriberId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RemoveSubscriberCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/remove-subscriber/remove-subscriber.spec.ts
Tamaño: 1903 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { NotFoundException } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { SubscribersService, UserSession } from '@novu/testing';
import { expect } from 'chai';
import { SharedModule } from '../../../shared/shared.module';
import { SubscribersV1Module } from '../../subscribersV1.module';
import { RemoveSubscriberCommand } from './remove-subscriber.command';
import { RemoveSubscriber } from './remove-subscriber.usecase';

describe('Remove Subscriber', () => {
  let useCase: RemoveSubscriber;
  let session: UserSession;

  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [SharedModule, SubscribersV1Module],
      providers: [],
    }).compile();

    session = new UserSession();
    await session.initialize();

    useCase = moduleRef.get<RemoveSubscriber>(RemoveSubscriber);
  });

  it('should remove a subscriber', async () => {
    const subscriberService = new SubscribersService(session.organization._id, session.environment._id);
    const subscriber = await subscriberService.createSubscriber();

    const res = await useCase.execute(
      RemoveSubscriberCommand.create({
        subscriberId: subscriber.subscriberId,
        environmentId: session.environment._id,
        organizationId: session.organization._id,
      })
    );

    expect(res).to.eql({ acknowledged: true, status: 'deleted' });
  });

  it('should throw a not found exception if subscriber to remove does not exist', async () => {
    try {
      await useCase.execute(
        RemoveSubscriberCommand.create({
          subscriberId: 'invalid-subscriber-id',
          environmentId: session.environment._id,
          organizationId: session.organization._id,
        })
      );
      expect(true, 'Should never reach this statement').to.be.false;
    } catch (e) {
      expect(e).to.be.instanceOf(NotFoundException);
    }
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - useCase(moduleRef.get<RemoveSubscriber>(RemoveSubscriber);
  });

  it('should remove a subscriber', async (...)
 - res(await useCase.execute(
      RemoveSubscriberCommand.create({
        subscriberId: subscriber.subsc...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/remove-subscriber/remove-subscriber.usecase.ts
Tamaño: 2544 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import {
  buildFeedKey,
  buildMessageCountKey,
  buildSubscriberKey,
  InvalidateCacheService,
} from '@novu/application-generic';
import { PreferencesRepository, SubscriberRepository, TopicSubscribersRepository } from '@novu/dal';

import { RemoveSubscriberCommand } from './remove-subscriber.command';

@Injectable()
export class RemoveSubscriber {
  constructor(
    private invalidateCache: InvalidateCacheService,
    private subscriberRepository: SubscriberRepository,
    private topicSubscribersRepository: TopicSubscribersRepository,
    private preferenceRepository: PreferencesRepository
  ) {}

  async execute({ environmentId: _environmentId, subscriberId }: RemoveSubscriberCommand) {
    await Promise.all([
      this.invalidateCache.invalidateByKey({
        key: buildSubscriberKey({
          subscriberId,
          _environmentId,
        }),
      }),
      this.invalidateCache.invalidateQuery({
        key: buildFeedKey().invalidate({
          subscriberId,
          _environmentId,
        }),
      }),
      this.invalidateCache.invalidateQuery({
        key: buildMessageCountKey().invalidate({
          subscriberId,
          _environmentId,
        }),
      }),
    ]);

    const subscriberInternalIds = await this.subscriberRepository._model.distinct('_id', {
      subscriberId,
      _environmentId,
    });

    if (subscriberInternalIds.length === 0) {
      throw new NotFoundException({ message: 'Subscriber was not found', externalSubscriberId: subscriberId });
    }

    await this.subscriberRepository.withTransaction(async () => {
      /*
       * Note about parallelism in transactions
       *
       * Running operations in parallel is not supported during a transaction.
       * The use of Promise.all, Promise.allSettled, Promise.race, etc. to parallelize operations
       * inside a transaction is undefined behaviour and should be avoided.
       *
       * Refer to https://mongoosejs.com/docs/transactions.html#note-about-parallelism-in-transactions
       */
      await this.subscriberRepository.delete({
        subscriberId,
        _environmentId,
      });

      await this.topicSubscribersRepository.delete({
        _environmentId,
        externalSubscriberId: subscriberId,
      });
      await this.preferenceRepository.delete({
        _environmentId,
        _subscriberId: { $in: subscriberInternalIds },
      });
    });

    return {
      acknowledged: true,
      status: 'deleted',
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RemoveSubscriber

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/search-by-external-subscriber-ids/index.ts
Tamaño: 123 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './search-by-external-subscriber-ids.command';
export * from './search-by-external-subscriber-ids.use-case';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/search-by-external-subscriber-ids/search-by-external-subscriber-ids.command.ts
Tamaño: 346 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ExternalSubscriberId } from '@novu/shared';
import { IsArray, IsDefined } from 'class-validator';

import { EnvironmentCommand } from '../../../shared/commands/project.command';

export class SearchByExternalSubscriberIdsCommand extends EnvironmentCommand {
  @IsArray()
  @IsDefined()
  externalSubscriberIds: ExternalSubscriberId[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SearchByExternalSubscriberIdsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/search-by-external-subscriber-ids/search-by-external-subscriber-ids.spec.ts
Tamaño: 2584 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Test } from '@nestjs/testing';
import { SubscriberEntity } from '@novu/dal';
import { SubscribersService, UserSession } from '@novu/testing';
import { expect } from 'chai';
import { SharedModule } from '../../../shared/shared.module';

import { SubscribersV1Module } from '../../subscribersV1.module';
import { SearchByExternalSubscriberIds, SearchByExternalSubscriberIdsCommand } from './index';

describe('SearchByExternalSubscriberIdsUseCase', () => {
  let session: UserSession;
  let subscribersService: SubscribersService;
  let useCase: SearchByExternalSubscriberIds;
  let firstSubscriber: SubscriberEntity;
  let secondSubscriber: SubscriberEntity;

  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [SharedModule, SubscribersV1Module],
      providers: [],
    }).compile();

    session = new UserSession();
    await session.initialize();

    useCase = moduleRef.get<SearchByExternalSubscriberIds>(SearchByExternalSubscriberIds);
    subscribersService = new SubscribersService(session.organization._id, session.environment._id);
    firstSubscriber = await subscribersService.createSubscriber();
    secondSubscriber = await subscribersService.createSubscriber();
  });

  it('should search and find the subscribers by the external subscriber ids', async () => {
    const externalSubscriberIds = [firstSubscriber.subscriberId, secondSubscriber.subscriberId];
    const command = SearchByExternalSubscriberIdsCommand.create({
      environmentId: session.environment._id,
      organizationId: session.organization._id,
      externalSubscriberIds,
    });
    const res = await useCase.execute(command);

    expect(res.length).to.eql(2);
    expect(res[0]._id).to.eql(firstSubscriber._id);
    expect(res[0].subscriberId).to.eql(firstSubscriber.subscriberId);
    expect(res[1]._id).to.eql(secondSubscriber._id);
    expect(res[1].subscriberId).to.eql(secondSubscriber.subscriberId);
  });

  it('should search and find the subscribers existing by the external subscriber ids', async () => {
    const externalSubscriberIds = [secondSubscriber.subscriberId, 'non-existing-external-subscriber-id'];
    const command = SearchByExternalSubscriberIdsCommand.create({
      environmentId: session.environment._id,
      organizationId: session.organization._id,
      externalSubscriberIds,
    });
    const res = await useCase.execute(command);

    expect(res.length).to.eql(1);
    expect(res[0]._id).to.eql(secondSubscriber._id);
    expect(res[0].subscriberId).to.eql(secondSubscriber.subscriberId);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - secondSubscriber(await subscribersService.createSubscriber();
  });

  it('should search and find the subscribers by ...)
 - res(await useCase.execute(command);

    expect(res.length).to.eql(2);
    expect(res[0]._id).to.eql(fir...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/search-by-external-subscriber-ids/search-by-external-subscriber-ids.use-case.ts
Tamaño: 1132 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { IExternalSubscribersEntity, SubscriberEntity, SubscriberRepository } from '@novu/dal';
import { SubscriberDto } from '@novu/shared';

import { SearchByExternalSubscriberIdsCommand } from './search-by-external-subscriber-ids.command';

@Injectable()
export class SearchByExternalSubscriberIds {
  constructor(private subscriberRepository: SubscriberRepository) {}

  async execute(command: SearchByExternalSubscriberIdsCommand): Promise<SubscriberDto[]> {
    const entity = this.mapToEntity(command);

    const entities = await this.subscriberRepository.searchByExternalSubscriberIds(entity);

    return entities.map(this.mapFromEntity);
  }

  private mapToEntity(command: SearchByExternalSubscriberIdsCommand): IExternalSubscribersEntity {
    return {
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
      externalSubscriberIds: command.externalSubscriberIds,
    };
  }

  private mapFromEntity(entity: SubscriberEntity): SubscriberDto {
    const { _id, ...rest } = entity;

    return {
      ...rest,
      _id,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SearchByExternalSubscriberIds

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/update-subscriber-online-flag/index.ts
Tamaño: 114 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './update-subscriber-online-flag.command';
export * from './update-subscriber-online-flag.usecase';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/update-subscriber-online-flag/update-subscriber-online-flag.command.ts
Tamaño: 280 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsBoolean, IsDefined } from 'class-validator';

import { EnvironmentWithSubscriber } from '../../../shared/commands/project.command';

export class UpdateSubscriberOnlineFlagCommand extends EnvironmentWithSubscriber {
  @IsDefined()
  @IsBoolean()
  isOnline: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateSubscriberOnlineFlagCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/subscribers/usecases/update-subscriber-online-flag/update-subscriber-online-flag.usecase.ts
Tamaño: 1347 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Inject, Injectable, NotFoundException } from '@nestjs/common';
import { AnalyticsService } from '@novu/application-generic';
import { MemberRepository, SubscriberEntity, SubscriberRepository } from '@novu/dal';

import { UpdateSubscriberOnlineFlagCommand } from './update-subscriber-online-flag.command';

@Injectable()
export class UpdateSubscriberOnlineFlag {
  constructor(
    private subscriberRepository: SubscriberRepository,
    private analyticsService: AnalyticsService,
    private memberRepository: MemberRepository
  ) {}

  private getUpdatedFields(isOnline: boolean) {
    return {
      isOnline,
      ...(!isOnline && { lastOnlineAt: new Date().toISOString() }),
    };
  }

  async execute(command: UpdateSubscriberOnlineFlagCommand) {
    const subscriber = await this.subscriberRepository.findBySubscriberId(command.environmentId, command.subscriberId);
    if (!subscriber) throw new NotFoundException(`Subscriber not found`);

    await this.subscriberRepository.update(
      { _id: subscriber._id, _organizationId: command.organizationId, _environmentId: command.environmentId },
      {
        $set: this.getUpdatedFields(command.isOnline),
      }
    );

    return (await this.subscriberRepository.findBySubscriberId(
      command.environmentId,
      command.subscriberId
    )) as SubscriberEntity;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateSubscriberOnlineFlag

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/support/support.controller.ts
Tamaño: 2168 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Body, Controller, Post, UseGuards } from '@nestjs/common';
import { ApiExcludeController } from '@nestjs/swagger';
import { Novu } from '@novu/api';
import { UserSession } from '@novu/application-generic';
import { UserSessionData } from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { CreateSupportThreadDto } from './dtos/create-thread.dto';
import { PlainCardRequestDto } from './dtos/plain-card.dto';
import { PlainCardsGuard } from './guards/plain-cards.guard';
import { CreateSupportThreadUsecase, PlainCardsUsecase } from './usecases';
import { CreateSupportThreadCommand } from './usecases/create-thread.command';
import { PlainCardsCommand } from './usecases/plain-cards.command';

@Controller('/support')
@ApiExcludeController()
export class SupportController {
  constructor(
    private createSupportThreadUsecase: CreateSupportThreadUsecase,
    private plainCardsUsecase: PlainCardsUsecase
  ) {}

  @UseGuards(PlainCardsGuard)
  @Post('customer-details')
  async fetchUserOrganizations(@Body() body: PlainCardRequestDto) {
    return this.plainCardsUsecase.fetchCustomerDetails(PlainCardsCommand.create({ ...body }));
  }

  @RequireAuthentication()
  @Post('create-thread')
  async createThread(@Body() body: CreateSupportThreadDto, @UserSession() user: UserSessionData) {
    return this.createSupportThreadUsecase.execute(
      CreateSupportThreadCommand.create({
        text: body.text,
        email: user.email as string,
        firstName: user.firstName as string,
        lastName: user.lastName as string,
        userId: user._id as string,
      })
    );
  }

  @RequireAuthentication()
  @Post('mobile-setup')
  async mobileSetup(@UserSession() user: UserSessionData) {
    const novu = new Novu({
      security: {
        secretKey: process.env.NOVU_INTERNAL_SECRET_KEY,
      },
    });

    await novu.trigger({
      workflowId: 'mobile-setup-email',
      to: {
        subscriberId: user._id as string,
        firstName: user.firstName as string,
        lastName: user.lastName as string,
        email: user.email as string,
      },
      payload: {},
    });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SupportController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/support/support.module.ts
Tamaño: 692 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Module } from '@nestjs/common';
import { SupportService } from '@novu/application-generic';
import { OrganizationRepository, UserRepository } from '@novu/dal';
import { SharedModule } from '../shared/shared.module';
import { PlainCardsGuard } from './guards/plain-cards.guard';
import { SupportController } from './support.controller';
import { CreateSupportThreadUsecase, PlainCardsUsecase } from './usecases';

@Module({
  imports: [SharedModule],
  controllers: [SupportController],
  providers: [
    CreateSupportThreadUsecase,
    PlainCardsUsecase,
    SupportService,
    OrganizationRepository,
    UserRepository,
    PlainCardsGuard,
  ],
})
export class SupportModule {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SupportModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/support/dtos/create-thread.dto.ts
Tamaño: 179 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IsString } from 'class-validator';

export class CreateSupportThreadDto {
  @ApiProperty()
  @IsString()
  text: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateSupportThreadDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/support/dtos/plain-card.dto.ts
Tamaño: 661 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';

export class PlainCustomer {
  @ApiProperty()
  id: string;

  @ApiProperty()
  externalId?: string;

  @ApiProperty()
  email?: string;
}

export class PlainTenant {
  @ApiProperty()
  id?: string;

  @ApiProperty()
  externalId?: string;
}

export class PlainThread {
  @ApiProperty()
  id?: string;

  @ApiProperty()
  externalId?: string;
}

export class PlainCardRequestDto {
  @ApiProperty()
  cardKeys?: string[];

  @ApiProperty()
  customer?: PlainCustomer | null;

  @ApiProperty()
  tenant?: PlainTenant | null;

  @ApiProperty()
  thread?: PlainThread | null;

  @ApiProperty()
  timestamp: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class PlainCustomer
- export class PlainTenant
- export class PlainThread
- export class PlainCardRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/support/guards/plain-cards.guard.ts
Tamaño: 880 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import crypto from 'node:crypto';
import { CanActivate, ExecutionContext, Injectable, UnauthorizedException } from '@nestjs/common';
import { Observable } from 'rxjs';

@Injectable()
export class PlainCardsGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean | Promise<boolean> | Observable<boolean> {
    const request = context.switchToHttp().getRequest();

    const requestBody = JSON.stringify(request.body);
    const plainCardsHMACSecretKey = process.env.PLAIN_CARDS_HMAC_SECRET_KEY as string;
    const incomingSignature = request.headers['plain-request-signature'];
    if (!incomingSignature) throw new UnauthorizedException('Plain request signature is missing');
    const expectedSignature = crypto.createHmac('sha-256', plainCardsHMACSecretKey).update(requestBody).digest('hex');

    return incomingSignature === expectedSignature;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class PlainCardsGuard

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/support/usecases/create-thread.command.ts
Tamaño: 432 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BaseCommand } from '@novu/application-generic';
import { IsDefined, IsOptional, IsString } from 'class-validator';

export class CreateSupportThreadCommand extends BaseCommand {
  @IsDefined()
  @IsString()
  text: string;

  @IsDefined()
  @IsString()
  email: string;

  @IsDefined()
  @IsString()
  firstName: string;

  @IsOptional()
  @IsString()
  lastName?: string;

  @IsDefined()
  @IsString()
  userId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateSupportThreadCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/support/usecases/create-thread.usecase.ts
Tamaño: 1010 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { SupportService } from '@novu/application-generic';
import { capitalize } from '../../shared/services/helper/helper.service';
import { CreateSupportThreadCommand } from './create-thread.command';

@Injectable()
export class CreateSupportThreadUsecase {
  constructor(private supportService: SupportService) {}

  async execute(command: CreateSupportThreadCommand) {
    const firstName = capitalize(command.firstName ?? '');
    const lastName = capitalize(command.lastName ?? '');
    const plainCustomer = await this.supportService.upsertCustomer({
      emailAddress: command.email,
      fullName: `${firstName} ${lastName}`,
      novuUserId: command.userId,
    });

    const thread = await this.supportService.createThread({
      plainCustomerId: plainCustomer.data?.customer?.id,
      threadText: command.text,
    });

    return {
      success: true,
      message: 'Thread created successfully',
      threadId: thread.data?.id,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateSupportThreadUsecase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/support/usecases/index.ts
Tamaño: 80 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './create-thread.usecase';
export * from './plain-cards.usecase';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/support/usecases/plain-cards.command.ts
Tamaño: 522 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BaseCommand } from '@novu/application-generic';
import { IsArray, IsDefined, IsOptional, IsString } from 'class-validator';
import { PlainCustomer, PlainTenant, PlainThread } from '../dtos/plain-card.dto';

export class PlainCardsCommand extends BaseCommand {
  @IsOptional()
  @IsArray()
  cardKeys?: string[];

  @IsOptional()
  customer?: PlainCustomer | null;

  @IsOptional()
  tenant?: PlainTenant | null;

  @IsOptional()
  thread?: PlainThread | null;

  @IsDefined()
  @IsString()
  timestamp: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class PlainCardsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/support/usecases/plain-cards.usecase.ts
Tamaño: 7792 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { OrganizationRepository, UserRepository } from '@novu/dal';
import { uiComponent } from '@team-plain/typescript-sdk';
import { differenceInDays } from 'date-fns';
import { PlainCardsCommand } from './plain-cards.command';

@Injectable()
export class PlainCardsUsecase {
  constructor(
    private organizationRepository: OrganizationRepository,
    private userRepository: UserRepository
  ) {}
  async fetchCustomerDetails(command: PlainCardsCommand) {
    const key = `customer-details-${process.env.NOVU_REGION}`;
    if (!command?.customer?.externalId) {
      return {
        data: {},
        cards: [
          {
            key,
            components: [
              uiComponent.spacer({ size: 'S' }),
              uiComponent.text({
                text: 'This user is not yet registered in this region',
              }),
            ],
          },
        ],
      };
    }

    const organizations = await this.organizationRepository.findUserActiveOrganizations(command?.customer?.externalId);
    if (!organizations) {
      return {
        data: {},
        cards: [
          {
            key,
            components: [
              uiComponent.spacer({ size: 'S' }),
              uiComponent.text({
                text: 'This user is not yet registered in this region',
              }),
            ],
          },
        ],
      };
    }

    const sessions = await this.userRepository.findUserSessions(command?.customer?.externalId);

    return {
      data: {},
      cards: [
        {
          key,
          components: [
            uiComponent.text({
              text: "User's Organizations",
              size: 'L',
            }),
            uiComponent.divider({ spacingSize: 'M' }),
            ...this.organizationsComponent(organizations),
            uiComponent.divider({ spacingSize: 'M' }),
            uiComponent.text({
              text: "User's Sessions",
              size: 'L',
            }),
            uiComponent.divider({ spacingSize: 'M' }),
            ...this.sessionsComponent(sessions),
          ],
        },
      ],
    };
  }

  private organizationsComponent = (organizations) => {
    const activeOrganizations = organizations?.map((organization) => {
      const orgCreatedAt = new Date(organization?.createdAt);
      const isTrialRemaining = differenceInDays(new Date(), orgCreatedAt) < 14;

      const orgTier =
        organization?.apiServiceLevel === 'business' && isTrialRemaining
          ? 'business-trial'
          : (organization?.apiServiceLevel ?? 'NA');

      return uiComponent.container({
        content: [
          uiComponent.spacer({ size: 'XS' }),
          uiComponent.text({
            text: 'Novu Org Id',
            size: 'S',
            color: 'MUTED',
          }),
          uiComponent.spacer({ size: 'XS' }),
          uiComponent.row({
            mainContent: [
              uiComponent.text({
                text: organization?._id,
                size: 'S',
              }),
            ],
            asideContent: [
              uiComponent.copyButton({
                tooltip: 'Copy Novu Org Id',
                value: organization?._id,
              }),
            ],
          }),
          uiComponent.spacer({ size: 'M' }),
          uiComponent.text({
            text: 'Clerk Org Id',
            size: 'S',
            color: 'MUTED',
          }),
          uiComponent.spacer({ size: 'XS' }),
          uiComponent.row({
            mainContent: [
              uiComponent.text({
                text: organization?.externalId,
                size: 'S',
              }),
            ],
            asideContent: [
              uiComponent.copyButton({
                tooltip: 'Copy Clerk Org Id',
                value: organization?.externalId,
              }),
            ],
          }),
          uiComponent.spacer({ size: 'M' }),
          uiComponent.text({
            text: 'Org Name',
            size: 'S',
            color: 'MUTED',
          }),
          uiComponent.spacer({ size: 'XS' }),
          uiComponent.row({
            mainContent: [
              uiComponent.text({
                text: organization?.name,
                size: 'S',
              }),
            ],
            asideContent: [
              uiComponent.copyButton({
                tooltip: 'Copy Org Name',
                value: organization?.name,
              }),
            ],
          }),
          uiComponent.spacer({ size: 'M' }),
          uiComponent.spacer({ size: 'XS' }),
          uiComponent.row({
            mainContent: [
              uiComponent.text({
                text: 'Org Tier',
                size: 'S',
                color: 'MUTED',
              }),
            ],
            asideContent: [
              uiComponent.text({
                text: orgTier,
                size: 'S',
              }),
            ],
          }),
          uiComponent.spacer({ size: 'M' }),
          uiComponent.row({
            mainContent: [
              uiComponent.text({
                text: 'Org Created At',
                size: 'S',
              }),
            ],
            asideContent: [
              uiComponent.text({
                text: organization?.createdAt,
                size: 'S',
              }),
            ],
          }),
        ],
      });
    });

    return activeOrganizations;
  };

  private sessionsComponent = (sessions) => {
    const allSessions = sessions.map((session) => {
      return uiComponent.container({
        content: [
          uiComponent.row({
            mainContent: [
              uiComponent.text({
                text: 'Status',
                size: 'S',
              }),
            ],
            asideContent: [
              uiComponent.text({
                text: session?.status || 'NA',
              }),
            ],
          }),
          uiComponent.row({
            mainContent: [
              uiComponent.text({
                text: 'City',
                size: 'S',
              }),
            ],
            asideContent: [
              uiComponent.text({
                text: session?.latestActivity?.city || 'NA',
              }),
            ],
          }),
          uiComponent.row({
            mainContent: [
              uiComponent.text({
                text: 'Country',
                size: 'S',
              }),
            ],
            asideContent: [
              uiComponent.text({
                text: session?.latestActivity?.country || 'NA',
              }),
            ],
          }),
          uiComponent.row({
            mainContent: [
              uiComponent.text({
                text: 'Device Type',
                size: 'S',
              }),
            ],
            asideContent: [
              uiComponent.text({
                text: session?.latestActivity?.deviceType || 'NA',
              }),
            ],
          }),
          uiComponent.row({
            mainContent: [
              uiComponent.text({
                text: 'Browser Name',
                size: 'S',
              }),
            ],
            asideContent: [
              uiComponent.text({
                text: session?.latestActivity?.browserName || 'NA',
              }),
            ],
          }),
          uiComponent.row({
            mainContent: [
              uiComponent.text({
                text: 'Browser Version',
                size: 'S',
              }),
            ],
            asideContent: [
              uiComponent.text({
                text: session?.latestActivity?.browserVersion || 'NA',
              }),
            ],
          }),
        ],
      });
    });

    return allSessions;
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - organizationsComponent(organizations))
 - activeOrganizations(organizations?.map((organization))
 - sessionsComponent(sessions))
 - allSessions(sessions.map((session))
Declaraciones 'export' encontradas:
- export class PlainCardsUsecase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/tenant/tenant.controller.ts
Tamaño: 7297 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  Body,
  ClassSerializerInterceptor,
  Controller,
  Delete,
  Get,
  HttpCode,
  HttpStatus,
  MethodNotAllowedException,
  Param,
  Patch,
  Post,
  Query,
  UseInterceptors,
} from '@nestjs/common';
import { ApiOperation, ApiTags } from '@nestjs/swagger';
import { ApiExcludeController } from '@nestjs/swagger/dist/decorators/api-exclude-controller.decorator';
import {
  CreateTenant,
  CreateTenantCommand,
  FeatureFlagsService,
  GetTenant,
  GetTenantCommand,
  UpdateTenant,
  UpdateTenantCommand,
} from '@novu/application-generic';
import { EnvironmentEntity, OrganizationEntity, UserEntity } from '@novu/dal';
import { ApiRateLimitCategoryEnum, FeatureFlagsKeysEnum, UserSessionData } from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { ExternalApiAccessible } from '../auth/framework/external-api.decorator';
import { ThrottlerCategory } from '../rate-limiting/guards';
import { PaginatedResponseDto } from '../shared/dtos/pagination-response';
import { ApiOkPaginatedResponse } from '../shared/framework/paginated-ok-response.decorator';
import {
  ApiCommonResponses,
  ApiConflictResponse,
  ApiNoContentResponse,
  ApiNotFoundResponse,
  ApiResponse,
} from '../shared/framework/response.decorator';
import { SdkUsePagination } from '../shared/framework/swagger/sdk.decorators';
import { UserSession } from '../shared/framework/user.decorator';
import {
  CreateTenantRequestDto,
  CreateTenantResponseDto,
  GetTenantResponseDto,
  GetTenantsRequestDto,
  UpdateTenantRequestDto,
  UpdateTenantResponseDto,
} from './dtos';
import { DeleteTenantCommand } from './usecases/delete-tenant/delete-tenant.command';
import { DeleteTenant } from './usecases/delete-tenant/delete-tenant.usecase';
import { GetTenantsCommand } from './usecases/get-tenants/get-tenants.command';
import { GetTenants } from './usecases/get-tenants/get-tenants.usecase';

const v2TenantsApiDescription = ' Tenants is not supported in code first version of the API.';

@ThrottlerCategory(ApiRateLimitCategoryEnum.CONFIGURATION)
@ApiCommonResponses()
@Controller('/tenants')
@ApiTags('Tenants')
@UseInterceptors(ClassSerializerInterceptor)
@RequireAuthentication()
@ApiExcludeController()
export class TenantController {
  constructor(
    private createTenantUsecase: CreateTenant,
    private updateTenantUsecase: UpdateTenant,
    private getTenantUsecase: GetTenant,
    private deleteTenantUsecase: DeleteTenant,
    private getTenantsUsecase: GetTenants,
    private featureFlagService: FeatureFlagsService
  ) {}

  @Get('')
  @ExternalApiAccessible()
  @ApiOkPaginatedResponse(GetTenantResponseDto)
  @ApiOperation({
    summary: 'Get tenants',
    description: `Returns a list of tenants, could paginated using the \`page\` and \`limit\` query parameter.${
      v2TenantsApiDescription
    }`,
  })
  @SdkUsePagination()
  async listTenants(
    @UserSession() user: UserSessionData,
    @Query() query: GetTenantsRequestDto
  ): Promise<PaginatedResponseDto<GetTenantResponseDto>> {
    await this.verifyTenantsApiAvailability(user);

    return await this.getTenantsUsecase.execute(
      GetTenantsCommand.create({
        organizationId: user.organizationId,
        environmentId: user.environmentId,
        page: query.page,
        limit: query.limit,
      })
    );
  }

  @Get('/:identifier')
  @ApiResponse(GetTenantResponseDto)
  @ApiOperation({
    summary: 'Get tenant',
    description: `Get tenant by your internal id used to identify the tenant${v2TenantsApiDescription}`,
  })
  @ApiNotFoundResponse({
    description: 'The tenant with the identifier provided does not exist in the database.',
  })
  @ExternalApiAccessible()
  async getTenantById(
    @UserSession() user: UserSessionData,
    @Param('identifier') identifier: string
  ): Promise<GetTenantResponseDto> {
    await this.verifyTenantsApiAvailability(user);

    return await this.getTenantUsecase.execute(
      GetTenantCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        identifier,
      })
    );
  }

  @Post('/')
  @ExternalApiAccessible()
  @ApiResponse(CreateTenantResponseDto)
  @ApiOperation({
    summary: 'Create tenant',
    description: `Create tenant under the current environment${v2TenantsApiDescription}`,
  })
  @ApiConflictResponse({
    description: 'A tenant with the same identifier is already exist.',
  })
  async createTenant(
    @UserSession() user: UserSessionData,
    @Body() body: CreateTenantRequestDto
  ): Promise<CreateTenantResponseDto> {
    await this.verifyTenantsApiAvailability(user);

    return await this.createTenantUsecase.execute(
      CreateTenantCommand.create({
        userId: user._id,
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        identifier: body.identifier,
        name: body.name,
        data: body.data,
      })
    );
  }

  @Patch('/:identifier')
  @ExternalApiAccessible()
  @ApiResponse(UpdateTenantResponseDto)
  @ApiOperation({
    summary: 'Update tenant',
    description: `Update tenant by your internal id used to identify the tenant${v2TenantsApiDescription}`,
  })
  @ApiNotFoundResponse({
    description: 'The tenant with the identifier provided does not exist in the database.',
  })
  async updateTenant(
    @UserSession() user: UserSessionData,
    @Param('identifier') identifier: string,
    @Body() body: UpdateTenantRequestDto
  ): Promise<UpdateTenantResponseDto> {
    await this.verifyTenantsApiAvailability(user);

    return await this.updateTenantUsecase.execute(
      UpdateTenantCommand.create({
        userId: user._id,
        identifier,
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        name: body.name,
        data: body.data,
        newIdentifier: body.identifier,
      })
    );
  }

  @Delete('/:identifier')
  @ExternalApiAccessible()
  @ApiOperation({
    summary: 'Delete tenant',
    description: `Deletes a tenant entity from the Novu platform.${v2TenantsApiDescription}`,
  })
  @ApiNoContentResponse({
    description: 'The tenant has been deleted correctly',
  })
  @ApiNotFoundResponse({
    description: 'The tenant with the identifier provided does not exist in the database so it can not be deleted.',
  })
  @HttpCode(HttpStatus.NO_CONTENT)
  async removeTenant(@UserSession() user: UserSessionData, @Param('identifier') identifier: string): Promise<void> {
    await this.verifyTenantsApiAvailability(user);

    return await this.deleteTenantUsecase.execute(
      DeleteTenantCommand.create({
        userId: user._id,
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        identifier,
      })
    );
  }

  private async verifyTenantsApiAvailability(user: UserSessionData) {
    const isV2Enabled = await this.featureFlagService.getFlag({
      user: { _id: user._id } as UserEntity,
      environment: { _id: user.environmentId } as EnvironmentEntity,
      organization: { _id: user.organizationId } as OrganizationEntity,
      key: FeatureFlagsKeysEnum.IS_V2_ENABLED,
      defaultValue: false,
    });

    if (!isV2Enabled) {
      return;
    }

    throw new MethodNotAllowedException(v2TenantsApiDescription.trim());
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class TenantController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/tenant/tenant.module.ts
Tamaño: 416 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Module } from '@nestjs/common';
import { AuthModule } from '../auth/auth.module';
import { SharedModule } from '../shared/shared.module';
import { TenantController } from './tenant.controller';
import { USE_CASES } from './usecases';

@Module({
  imports: [SharedModule, AuthModule],
  controllers: [TenantController],
  providers: [...USE_CASES],
  exports: [...USE_CASES],
})
export class TenantModule {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class TenantModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/tenant/dtos/create-tenant-request.dto.ts
Tamaño: 297 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { CustomDataType, ICreateTenantDto } from '@novu/shared';

export class CreateTenantRequestDto implements ICreateTenantDto {
  @ApiProperty()
  identifier: string;

  @ApiProperty()
  name: string;

  @ApiProperty()
  data?: CustomDataType;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateTenantRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/tenant/dtos/create-tenant-response.dto.ts
Tamaño: 409 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';

import { CustomDataType } from '@novu/shared';

export class CreateTenantResponseDto {
  @ApiProperty()
  _id: string;

  @ApiProperty()
  identifier: string;

  @ApiProperty()
  name?: string;

  @ApiProperty()
  data?: CustomDataType;

  @ApiProperty()
  _environmentId: string;

  @ApiProperty()
  createdAt: string;

  @ApiProperty()
  updatedAt: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateTenantResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/tenant/dtos/get-tenant-response.dto.ts
Tamaño: 405 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { CustomDataType } from '@novu/shared';

export class GetTenantResponseDto {
  @ApiProperty()
  _id: string;

  @ApiProperty()
  identifier: string;

  @ApiProperty()
  name?: string;

  @ApiProperty()
  data?: CustomDataType;

  @ApiProperty()
  _environmentId: string;

  @ApiProperty()
  createdAt: string;

  @ApiProperty()
  updatedAt: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetTenantResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/tenant/dtos/get-tenants-request.dto.ts
Tamaño: 217 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { PaginationRequestDto } from '../../shared/dtos/pagination-request';

const LIMIT = {
  DEFAULT: 10,
  MAX: 100,
};

export class GetTenantsRequestDto extends PaginationRequestDto(LIMIT.DEFAULT, LIMIT.MAX) {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetTenantsRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/tenant/dtos/index.ts
Tamaño: 268 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './create-tenant-request.dto';
export * from './create-tenant-response.dto';
export * from './get-tenant-response.dto';
export * from './get-tenants-request.dto';
export * from './update-tenant-request.dto';
export * from './update-tenant-response.dto';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/tenant/dtos/update-tenant-request.dto.ts
Tamaño: 495 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional } from '@nestjs/swagger';
import { CustomDataType, IUpdateTenantDto } from '@novu/shared';
import { IsOptional, IsString } from 'class-validator';

export class UpdateTenantRequestDto implements IUpdateTenantDto {
  @IsOptional()
  @IsString()
  @ApiPropertyOptional({ type: String })
  identifier?: string;

  @IsOptional()
  @IsString()
  @ApiPropertyOptional({ type: String })
  name?: string;

  @IsOptional()
  @ApiPropertyOptional()
  data?: CustomDataType;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateTenantRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/tenant/dtos/update-tenant-response.dto.ts
Tamaño: 669 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { CustomDataType } from '@novu/shared';
import { IsString } from 'class-validator';

export class UpdateTenantResponseDto {
  @ApiProperty({ type: String })
  @IsString()
  _id: string;

  @ApiProperty({ type: String })
  @IsString()
  identifier: string;

  @ApiPropertyOptional({ type: String })
  @IsString()
  name?: string;

  @ApiPropertyOptional()
  data?: CustomDataType;

  @ApiProperty({ type: String })
  @IsString()
  _environmentId: string;

  @ApiProperty({ type: String })
  @IsString()
  createdAt: string;

  @ApiProperty({ type: String })
  @IsString()
  updatedAt: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateTenantResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/tenant/e2e/create-tenant.e2e.ts
Tamaño: 2912 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

// noinspection ExceptionCaughtLocallyJS

import { TenantRepository } from '@novu/dal';
import { UserSession } from '@novu/testing';
import axios, { AxiosError, AxiosResponse } from 'axios';
import { expect } from 'chai';

function assertValidationMessages(e: AxiosError<any, any>, field: string, msg1: string) {
  if (!(e instanceof AxiosError)) {
    throw new Error(e);
  }
  const messages = e.response?.data.errors[field].messages;

  expect(messages).to.be.an('array').that.includes(msg1);
}

describe('Create Tenant - /tenants (POST) #novu-v0', () => {
  let session: UserSession;
  const tenantRepository = new TenantRepository();

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should create a new tenant', async () => {
    const response = await createTenant({
      session,
      identifier: 'identifier_123',
      name: 'name_123',
      data: { test1: 'test value1', test2: 'test value2' },
    });

    expect(response.status).to.equal(201);
    expect(response.data).to.be.ok;

    const createdTenant = await tenantRepository.findOne({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      identifier: 'identifier_123',
    });

    expect(createdTenant?.name).to.equal('name_123');
    expect(createdTenant?.identifier).to.equal('identifier_123');
    expect(createdTenant?.data).to.deep.equal({ test1: 'test value1', test2: 'test value2' });
  });

  it('should throw error if a tenant is already exist in the environment', async () => {
    await createTenant({
      session,
      identifier: 'identifier_123',
      name: 'name_123',
    });

    try {
      await createTenant({
        session,
        identifier: 'identifier_123',
        name: 'name_123',
      });

      throw new Error('');
    } catch (e) {
      expect(e.response.status).to.equal(409);
      expect(e.response.data.message).to.contains(
        `Tenant with identifier: identifier_123 already exists under environment ${session.environment._id}`
      );
    }
  });

  it('should throw error if a missing tenant identifier', async () => {
    try {
      await createTenant({
        session,
      });

      throw new Error('Should Not Succeed In the call');
    } catch (e) {
      assertValidationMessages(e, 'identifier', 'identifier should not be empty');
      assertValidationMessages(e, 'identifier', 'identifier must be a string');
    }
  });
});

export async function createTenant({
  session,
  identifier,
  name,
  data,
}: {
  session;
  identifier?: string;
  name?: string;
  data?: any;
}): Promise<AxiosResponse> {
  const axiosInstance = axios.create();

  return await axiosInstance.post(
    `${session.serverUrl}/v1/tenants`,
    {
      identifier,
      name,
      data,
    },
    {
      headers: {
        authorization: `ApiKey ${session.apiKey}`,
      },
    }
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - assertValidationMessages(e: AxiosError<any, any>, field: string, msg1: string)
 - createTenant({
  session,
  identifier,
  name,
  data,
}: {
  session;
  identifier?: string;
  name?: string;
  data?: any;
})
Asignaciones con arrow functions encontradas (posibles funciones):
 - messages(e.response?.data.errors[field].messages;

  expect(messages).to.be.an('array').that.includes(msg1);
...)
 - tenantRepository(new TenantRepository();

  beforeEach(async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('should create a new tenant', async (...)
 - createdTenant(await tenantRepository.findOne({
      _organizationId: session.organization._id,
      _environment...)
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/tenant/e2e/delete-tenant.e2e.ts
Tamaño: 2027 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { TenantRepository } from '@novu/dal';
import { UserSession } from '@novu/testing';
import axios, { AxiosResponse } from 'axios';
import { expect } from 'chai';

describe('Delete Tenant - /tenants/:identifier (DELETE) #novu-v0', () => {
  let session: UserSession;
  const tenantRepository = new TenantRepository();

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should delete newly created tenant', async () => {
    await tenantRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      identifier: 'identifier_123',
      name: 'name_123',
      data: { test1: 'test value1', test2: 'test value2' },
    });

    const existingTenant = await tenantRepository.findOne({
      _environmentId: session.environment._id,
      identifier: 'identifier_123',
    });

    expect(existingTenant).to.be.ok;

    await deleteTenant({
      session,
      identifier: 'identifier_123',
    });

    const deletedTenant = await tenantRepository.findOne({
      _environmentId: session.environment._id,
      identifier: 'identifier_123',
    });

    expect(deletedTenant).to.equal(null);
  });

  it('should throw exception while trying to delete not existing tenant', async () => {
    const identifier = '4f3c4146-e471-4fe8-b23d-e3411689db00';

    try {
      await deleteTenant({
        session,
        identifier,
      });

      throw new Error('');
    } catch (e) {
      expect(e?.response?.data?.message || e?.message).to.contains(
        `Tenant with identifier: ${identifier} does not exist under environment ${session.environment._id}`
      );
    }
  });
});

export async function deleteTenant({ session, identifier }: { session; identifier?: string }): Promise<AxiosResponse> {
  const axiosInstance = axios.create();

  return await axiosInstance.delete(`${session.serverUrl}/v1/tenants/${identifier}`, {
    headers: {
      authorization: `ApiKey ${session.apiKey}`,
    },
  });
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - deleteTenant({ session, identifier }: { session; identifier?: string })
Asignaciones con arrow functions encontradas (posibles funciones):
 - tenantRepository(new TenantRepository();

  beforeEach(async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('should delete newly created tenant',...)
 - deletedTenant(await tenantRepository.findOne({
      _environmentId: session.environment._id,
      identifier: 'i...)
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/tenant/e2e/get-tenant.e2e.ts
Tamaño: 1834 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { TenantRepository } from '@novu/dal';
import { UserSession } from '@novu/testing';
import axios, { AxiosResponse } from 'axios';
import { expect } from 'chai';

describe('Get Tenant - /tenants/:identifier (GET) #novu-v0', () => {
  let session: UserSession;
  const tenantRepository = new TenantRepository();

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should get a newly created tenant', async () => {
    await tenantRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      identifier: 'identifier_123',
      name: 'name_123',
      data: { test1: 'test value1', test2: 'test value2' },
    });

    const getTenantResult = await getTenant({ session, identifier: 'identifier_123' });

    expect(getTenantResult.data.identifier).to.equal('identifier_123');
    expect(getTenantResult.data.name).to.equal('name_123');
    expect(getTenantResult.data.data).to.deep.equal({ test1: 'test value1', test2: 'test value2' });
  });

  it('should throw exception if tenant does not existing', async () => {
    const incorrectId = 'identifier_123';
    try {
      await getTenant({ session, identifier: incorrectId });

      throw new Error('');
    } catch (e) {
      expect(e?.response?.data?.message || e?.message).to.contains(
        `Tenant with identifier: ${incorrectId} does not exist under environment ${session.environment._id}`
      );
    }
  });
});

async function getTenant({ session, identifier }: { session; identifier: string }): Promise<AxiosResponse> {
  const axiosInstance = axios.create();

  return (
    await axiosInstance.get(`${session.serverUrl}/v1/tenants/${identifier}`, {
      headers: {
        authorization: `ApiKey ${session.apiKey}`,
      },
    })
  ).data;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getTenant({ session, identifier }: { session; identifier: string })
Asignaciones con arrow functions encontradas (posibles funciones):
 - tenantRepository(new TenantRepository();

  beforeEach(async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('should get a newly created tenant', ...)
 - getTenantResult(await getTenant({ session, identifier: 'identifier_123' });

    expect(getTenantResult.data.identif...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/tenant/e2e/get-tenants.e2e.ts
Tamaño: 3808 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { TenantRepository } from '@novu/dal';
import { UserSession } from '@novu/testing';
import axios, { AxiosResponse } from 'axios';
import { expect } from 'chai';

describe('Get Tenants List- /tenants (GET) #novu-v0', () => {
  let session: UserSession;
  const tenantRepository = new TenantRepository();

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should get the newly created tenants', async () => {
    for (let i = 0; i < 5; i += 1) {
      await tenantRepository.create({
        _organizationId: session.organization._id,
        _environmentId: session.environment._id,
        identifier: `identifier_${i}`,
        name: 'name_123',
        data: { test1: 'test value1', test2: 'test value2' },
      });

      await timeout(5);
    }

    const getTenantResult = await getTenants({ session });

    const { data } = getTenantResult;

    expect(data.page).to.equal(0);
    expect(data.pageSize).to.equal(10);
    expect(data.hasMore).to.equal(false);
    expect(data.data.length).to.equal(5);
    expect(data.data[0].identifier).to.equal('identifier_4');
    expect(data.data[4].identifier).to.equal('identifier_0');
  });

  it('should get second page of tenants', async () => {
    for (let i = 0; i < 9; i += 1) {
      await tenantRepository.create({
        _environmentId: session.environment._id,
        _organizationId: session.organization._id,
        identifier: `identifier_${i}`,
        name: 'name_123',
        data: { test1: 'test value1', test2: 'test value2' },
      });

      await timeout(10);
    }

    const getTenantResult = await getTenants({ session, page: 1, limit: 5 });

    const { data } = getTenantResult;

    expect(data.page).to.equal(1);
    expect(data.pageSize).to.equal(5);
    expect(data.hasMore).to.equal(false);
    expect(data.data.length).to.equal(4);
    expect(data.data[0].identifier).to.equal('identifier_3');
    expect(data.data[3].identifier).to.equal('identifier_0');
  });

  it('should get tenants by pagination', async () => {
    for (let i = 0; i < 14; i += 1) {
      await tenantRepository.create({
        _environmentId: session.environment._id,
        _organizationId: session.organization._id,
        identifier: `identifier_${i}`,
        name: 'name_123',
        data: { test1: 'test value1', test2: 'test value2' },
      });

      await timeout(5);
    }

    const page1 = (await getTenants({ session, page: 0, limit: 5 })).data;

    expect(page1.page).to.equal(0);
    expect(page1.pageSize).to.equal(5);
    expect(page1.hasMore).to.equal(true);
    expect(page1.data.length).to.equal(5);

    const page2 = (await getTenants({ session, page: 1, limit: 5 })).data;

    expect(page2.page).to.equal(1);
    expect(page2.pageSize).to.equal(5);
    expect(page2.hasMore).to.equal(true);
    expect(page2.data.length).to.equal(5);

    const page3 = (await getTenants({ session, page: 2, limit: 5 })).data;

    expect(page3.page).to.equal(2);
    expect(page3.pageSize).to.equal(5);
    expect(page3.hasMore).to.equal(false);
    expect(page3.data.length).to.equal(4);
  });
});

async function getTenants({
  session,
  page,
  limit,
}: {
  session;
  page?: number;
  limit?: number;
}): Promise<AxiosResponse> {
  const axiosInstance = axios.create();
  const pageQuery = page ? `page=${page}` : '';
  const limitQuery = limit ? `limit=${limit}` : '';
  const queryParams = [pageQuery, limitQuery].filter((queryStr) => queryStr).join('&');
  const query = queryParams ? `?${queryParams}` : '';

  return await axiosInstance.get(`${session.serverUrl}/v1/tenants${query}`, {
    headers: {
      authorization: `ApiKey ${session.apiKey}`,
    },
  });
}

function timeout(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getTenants({
  session,
  page,
  limit,
}: {
  session;
  page?: number;
  limit?: number;
})
 - timeout(ms)
Asignaciones con arrow functions encontradas (posibles funciones):
 - tenantRepository(new TenantRepository();

  beforeEach(async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('should get the newly created tenants...)
 - queryParams([pageQuery, limitQuery].filter((queryStr))
 - query(queryParams ? `?${queryParams}` : '';

  return await axiosInstance.get(`${session.serverUrl}/v1/ten...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/tenant/e2e/update-tenant.e2e.ts
Tamaño: 4610 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { TenantRepository } from '@novu/dal';
import { UserSession } from '@novu/testing';
import axios, { AxiosResponse } from 'axios';
import { expect } from 'chai';

describe('Update Tenant - /tenants/:tenantId (PUT) #novu-v0', () => {
  let session: UserSession;
  const tenantRepository = new TenantRepository();

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should update tenant', async () => {
    await tenantRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      identifier: 'identifier_123',
      name: 'name_123',
      data: { test1: 'test value1', test2: 'test value2' },
    });

    const response = await updateTenant({
      session,
      identifier: 'identifier_123',
      newIdentifier: 'newIdentifier',
      name: 'new_name',
      data: { test1: 'new value', test2: 'new value2' },
    });

    expect(response?.status).to.equal(200);

    const updatedTenant = await tenantRepository.findOne({
      _environmentId: session.environment._id,
      identifier: 'newIdentifier',
    });

    expect(updatedTenant?.name).to.equal('new_name');
    expect(updatedTenant?.identifier).to.equal('newIdentifier');
    expect(updatedTenant?.data).to.deep.equal({ test1: 'new value', test2: 'new value2' });
  });

  it('should not update identifier with null/undefined', async () => {
    await tenantRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      identifier: 'identifier_123',
      name: 'name_123',
      data: { test1: 'test value1', test2: 'test value2' },
    });

    await updateTenant({
      session,
      identifier: 'identifier_123',
      newIdentifier: null,
    });

    const tenantNotUpdatedWithNull = await tenantRepository.findOne({
      _environmentId: session.environment._id,
      identifier: 'identifier_123',
    });

    expect(tenantNotUpdatedWithNull?.identifier).to.equal('identifier_123');

    await updateTenant({
      session,
      identifier: 'identifier_123',
      newIdentifier: undefined,
    });

    const tenantNotUpdatedWithUndefined = await tenantRepository.findOne({
      _environmentId: session.environment._id,
      identifier: 'identifier_123',
    });

    expect(tenantNotUpdatedWithUndefined?.identifier).to.equal('identifier_123');
  });

  it('should not be able to update to already existing identifier (in the same environment)', async () => {
    await tenantRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      identifier: 'identifier_123',
    });

    await tenantRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      identifier: 'identifier_456',
    });

    try {
      await updateTenant({
        session,
        identifier: 'identifier_123',
        newIdentifier: 'identifier_456',
      });

      expectedException();
    } catch (e) {
      expect(e.response.status).to.equal(409);
      expect(e?.response?.data?.message || e?.message).to.contains(
        `Tenant with identifier: identifier_456 already exists under environment ${session.environment._id}`
      );
    }
  });

  it('should throw exception id tenant was not found under environment', async () => {
    await tenantRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      identifier: 'identifier_123',
    });

    try {
      await updateTenant({
        session,
        identifier: 'identifier_1234',
      });

      expectedException();
    } catch (e) {
      expect(e.response.status).to.equal(404);
      expect(e?.response?.data?.message || e?.message).to.contains(
        `Tenant with identifier: identifier_1234 does not exist under environment ${session.environment._id}`
      );
    }
  });
});

const expectedException = () => {
  throw new Error('missing exception in the try/catch block');
};

export async function updateTenant({
  session,
  identifier,
  newIdentifier,
  name,
  data,
}: {
  session;
  identifier?: string;
  newIdentifier?: string | null | undefined;
  name?: string;
  data?: any;
}): Promise<AxiosResponse> {
  const axiosInstance = axios.create();

  return await axiosInstance.patch(
    `${session.serverUrl}/v1/tenants/${identifier}`,
    {
      identifier: newIdentifier,
      name,
      data,
    },
    {
      headers: {
        authorization: `ApiKey ${session.apiKey}`,
      },
    }
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - updateTenant({
  session,
  identifier,
  newIdentifier,
  name,
  data,
}: {
  session;
  identifier?: string;
  newIdentifier?: string | null | undefined;
  name?: string;
  data?: any;
})
Asignaciones con arrow functions encontradas (posibles funciones):
 - tenantRepository(new TenantRepository();

  beforeEach(async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('should update tenant', async ())
 - updatedTenant(await tenantRepository.findOne({
      _environmentId: session.environment._id,
      identifier: 'n...)
 - tenantNotUpdatedWithUndefined(await tenantRepository.findOne({
      _environmentId: session.environment._id,
      identifier: 'i...)
 - expectedException())
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/tenant/usecases/index.ts
Tamaño: 310 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CreateTenant, GetTenant, UpdateTenant } from '@novu/application-generic';
import { DeleteTenant } from './delete-tenant/delete-tenant.usecase';
import { GetTenants } from './get-tenants/get-tenants.usecase';

export const USE_CASES = [CreateTenant, GetTenant, UpdateTenant, DeleteTenant, GetTenants];


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/tenant/usecases/delete-tenant/delete-tenant.command.ts
Tamaño: 253 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentWithUserCommand } from '@novu/application-generic';
import { IsNotEmpty, IsString } from 'class-validator';

export class DeleteTenantCommand extends EnvironmentWithUserCommand {
  @IsString()
  @IsNotEmpty()
  identifier: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DeleteTenantCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/tenant/usecases/delete-tenant/delete-tenant.usecase.ts
Tamaño: 1046 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable } from '@nestjs/common';

import { GetTenant, GetTenantCommand } from '@novu/application-generic';
import { DalException, TenantRepository } from '@novu/dal';

import { DeleteTenantCommand } from './delete-tenant.command';

@Injectable()
export class DeleteTenant {
  constructor(
    private tenantRepository: TenantRepository,
    private getTenantUsecase: GetTenant
  ) {}

  async execute(command: DeleteTenantCommand) {
    const tenant = await this.getTenantUsecase.execute(
      GetTenantCommand.create({
        environmentId: command.environmentId,
        organizationId: command.organizationId,
        identifier: command.identifier,
      })
    );

    try {
      await this.tenantRepository.delete({
        _environmentId: command.environmentId,
        _organizationId: command.organizationId,
        identifier: command.identifier,
      });
    } catch (e) {
      if (e instanceof DalException) {
        throw new BadRequestException(e.message);
      }
      throw e;
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DeleteTenant

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/tenant/usecases/get-tenants/get-tenants.command.ts
Tamaño: 292 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsNumber, IsOptional } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';

export class GetTenantsCommand extends EnvironmentCommand {
  @IsNumber()
  @IsOptional()
  page: number;

  @IsNumber()
  @IsOptional()
  limit: number;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetTenantsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/tenant/usecases/get-tenants/get-tenants.usecase.ts
Tamaño: 875 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { TenantRepository } from '@novu/dal';
import { GetTenantsCommand } from './get-tenants.command';

@Injectable()
export class GetTenants {
  constructor(private tenantRepository: TenantRepository) {}

  async execute(command: GetTenantsCommand) {
    const data = await this.getTenants(command);

    return {
      page: command.page,
      hasMore: data?.length === command.limit,
      pageSize: command.limit,
      data,
    };
  }

  private async getTenants(command: GetTenantsCommand) {
    const data = await this.tenantRepository.find(
      {
        _environmentId: command.environmentId,
        _organizationId: command.organizationId,
      },
      '',
      {
        limit: command.limit,
        skip: command.page * command.limit,
        sort: { createdAt: -1 },
      }
    );

    return data;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetTenants

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/testing/auth.controller.ts
Tamaño: 1058 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Controller, Get } from '@nestjs/common';
import { ApiExcludeController } from '@nestjs/swagger';
import { RequirePermissions, SkipPermissionsCheck } from '@novu/application-generic';
import { PermissionsEnum } from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { ExternalApiAccessible } from '../auth/framework/external-api.decorator';

@Controller('/test-auth')
@RequireAuthentication()
@ApiExcludeController()
export class TestApiAuthController {
  @ExternalApiAccessible()
  @Get('/user-route')
  userRoute() {
    return true;
  }

  @Get('/user-api-inaccessible-route')
  userInaccessibleRoute() {
    return true;
  }

  @RequirePermissions(PermissionsEnum.INTEGRATION_WRITE, PermissionsEnum.WORKFLOW_WRITE)
  @ExternalApiAccessible()
  @Get('/permission-route')
  permissionRoute() {
    return true;
  }

  @SkipPermissionsCheck()
  @Get('/no-permission-route')
  noPermissionRoute() {
    return true;
  }

  @Get('/all-permissions-route')
  allPermissionsRoute() {
    return true;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class TestApiAuthController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/testing/product-feature.e2e.ts
Tamaño: 1375 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CommunityOrganizationRepository } from '@novu/dal';
import { ApiServiceLevelEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Product feature Test #novu-v0-os', async () => {
  let session: UserSession;
  const path = '/v1/testing/product-feature';
  let organizationRepository: CommunityOrganizationRepository;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    organizationRepository = new CommunityOrganizationRepository();
  });

  it('should return a number as response when required api service level exists on organization for feature', async () => {
    await organizationRepository.update(
      { _id: session.organization._id },
      {
        apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
      }
    );
    const { body } = await session.testAgent.get(path).set('authorization', `ApiKey ${session.apiKey}`).expect(200);
    expect(typeof body.data.number === 'number').to.be.true;
  });

  it('should return a 402 response when required api service level does not exists on organization for feature', async () => {
    const { body } = await session.testAgent.get(path).set('authorization', `ApiKey ${session.apiKey}`).expect(402);
    expect(body.statusCode).to.equal(402);
    expect(body.message).to.equal('Payment Required');
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - path('/v1/testing/product-feature';
  let organizationRepository: CommunityOrganizationRepository;

  bef...)
 - organizationRepository(new CommunityOrganizationRepository();
  });

  it('should return a number as response when required...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/testing/rate-limiting.controller.ts
Tamaño: 2697 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Controller, Get } from '@nestjs/common';
import { ApiExcludeController } from '@nestjs/swagger';
import { ApiRateLimitCategoryEnum, ApiRateLimitCostEnum } from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { ExternalApiAccessible } from '../auth/framework/external-api.decorator';
import { ThrottlerCategory, ThrottlerCost } from '../rate-limiting/guards';

@Controller('/rate-limiting')
@RequireAuthentication()
@ApiExcludeController()
export class TestApiRateLimitController {
  @ExternalApiAccessible()
  @Get('/no-category-no-cost')
  noCategoryNoCost() {
    return true;
  }

  @ExternalApiAccessible()
  @ThrottlerCost(ApiRateLimitCostEnum.SINGLE)
  @Get('/no-category-single-cost')
  noCategorySingleCost() {
    return true;
  }

  @ExternalApiAccessible()
  @ThrottlerCategory(ApiRateLimitCategoryEnum.GLOBAL)
  @Get('/global-category-no-cost')
  globalCategoryNoCost() {
    return true;
  }

  @ExternalApiAccessible()
  @ThrottlerCategory(ApiRateLimitCategoryEnum.GLOBAL)
  @ThrottlerCost(ApiRateLimitCostEnum.SINGLE)
  @Get('/global-category-single-cost')
  globalCategorySingleCost() {
    return true;
  }

  @ExternalApiAccessible()
  @ThrottlerCategory(ApiRateLimitCategoryEnum.GLOBAL)
  @ThrottlerCost(ApiRateLimitCostEnum.BULK)
  @Get('/global-category-bulk-cost')
  global() {
    return true;
  }

  @ExternalApiAccessible()
  @ThrottlerCategory(ApiRateLimitCategoryEnum.TRIGGER)
  @Get('/trigger-category-no-cost')
  triggerCategoryNoCost() {
    return true;
  }

  @ExternalApiAccessible()
  @ThrottlerCategory(ApiRateLimitCategoryEnum.TRIGGER)
  @ThrottlerCost(ApiRateLimitCostEnum.SINGLE)
  @Get('/trigger-category-single-cost')
  triggerCategorySingleCost() {
    return true;
  }

  @ExternalApiAccessible()
  @ThrottlerCategory(ApiRateLimitCategoryEnum.TRIGGER)
  @ThrottlerCost(ApiRateLimitCostEnum.BULK)
  @Get('/trigger-category-bulk-cost')
  triggerCategoryBulkCost() {
    return true;
  }
}
@ApiExcludeController()
@Controller('/rate-limiting-trigger-bulk')
@RequireAuthentication()
@ThrottlerCategory(ApiRateLimitCategoryEnum.TRIGGER)
@ThrottlerCost(ApiRateLimitCostEnum.BULK)
export class TestApiRateLimitBulkController {
  @ExternalApiAccessible()
  @Get('/no-category-no-cost-override')
  noCategoryNoCostOverride() {
    return true;
  }

  @ExternalApiAccessible()
  @ThrottlerCost(ApiRateLimitCostEnum.SINGLE)
  @Get('/no-category-single-cost-override')
  noCategorySingleCostOverride() {
    return true;
  }

  @ExternalApiAccessible()
  @Get('/global-category-no-cost-override')
  @ThrottlerCategory(ApiRateLimitCategoryEnum.GLOBAL)
  globalCategoryNoCostOverride() {
    return true;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class TestApiRateLimitController
- export class TestApiRateLimitBulkController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/testing/testing.controller.ts
Tamaño: 1353 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Controller, Get, NotFoundException } from '@nestjs/common';
import { ApiExcludeController } from '@nestjs/swagger';
import { ProductFeature, ResourceCategory } from '@novu/application-generic';
import { ProductFeatureKeyEnum, ResourceEnum } from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { ExternalApiAccessible } from '../auth/framework/external-api.decorator';

@Controller('/testing')
@RequireAuthentication()
@ApiExcludeController()
export class TestingController {
  @ExternalApiAccessible()
  @Get('/product-feature')
  @ProductFeature(ProductFeatureKeyEnum.TRANSLATIONS)
  async productFeatureGet(): Promise<{ number: number }> {
    if (process.env.NODE_ENV !== 'test') throw new NotFoundException();

    return { number: Math.random() };
  }

  @ExternalApiAccessible()
  @Get('/resource-limiting-default')
  async resourceLimitingDefaultGet(): Promise<{ number: number }> {
    if (process.env.NODE_ENV !== 'test') throw new NotFoundException();

    return { number: Math.random() };
  }

  @ExternalApiAccessible()
  @Get('/resource-limiting-events')
  @ResourceCategory(ResourceEnum.EVENTS)
  async resourceLimitingEventsGet(): Promise<{ number: number }> {
    if (process.env.NODE_ENV !== 'test') throw new NotFoundException();

    return { number: Math.random() };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class TestingController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/testing/testing.module.ts
Tamaño: 667 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Module } from '@nestjs/common';
import { AuthModule } from '../auth/auth.module';
import { RateLimitingModule } from '../rate-limiting/rate-limiting.module';
import { SharedModule } from '../shared/shared.module';
import { TestApiAuthController } from './auth.controller';
import { TestApiRateLimitBulkController, TestApiRateLimitController } from './rate-limiting.controller';
import { TestingController } from './testing.controller';

@Module({
  imports: [SharedModule, AuthModule, RateLimitingModule],
  controllers: [TestingController, TestApiRateLimitController, TestApiRateLimitBulkController, TestApiAuthController],
})
export class TestingModule {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class TestingModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/testing/dtos/idempotency.dto.ts
Tamaño: 704 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';

export enum IdempotencyBehaviorEnum {
  IMMEDIATE_RESPONSE = 'IMMEDIATE_RESPONSE',
  IMMEDIATE_EXCEPTION = 'IMMEDIATE_EXCEPTION',
  DELAYED_RESPONSE = 'DELAYED_RESPONSE',
}

export class IdempotencyTestingDto {
  @ApiProperty({
    enum: Object.values(IdempotencyBehaviorEnum),
    description: 'The expected behavior of the idempotency request',
    enumName: 'IdempotencyBehaviorEnum',
  })
  expectedBehavior: IdempotencyBehaviorEnum;
}
export class IdempotenceTestingResponse {
  @ApiProperty({
    description: 'A unique number representing the idempotency response',
    example: 1, // Example value for better understanding
  })
  number: number;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  enum
- export class IdempotencyTestingDto
- export class IdempotenceTestingResponse

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/topics-v1.controller.ts
Tamaño: 8928 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Body, Controller, Delete, Get, HttpCode, HttpStatus, Param, Patch, Post, Query } from '@nestjs/common';
import { ApiExcludeEndpoint, ApiOperation, ApiParam, ApiTags } from '@nestjs/swagger';
import { ApiRateLimitCategoryEnum, ExternalSubscriberId, TopicKey, UserSessionData } from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { ExternalApiAccessible } from '../auth/framework/external-api.decorator';
import { ThrottlerCategory } from '../rate-limiting/guards';
import {
  ApiCommonResponses,
  ApiNoContentResponse,
  ApiOkResponse,
  ApiResponse,
} from '../shared/framework/response.decorator';
import { SdkGroupName, SdkMethodName } from '../shared/framework/swagger/sdk.decorators';
import { UserSession } from '../shared/framework/user.decorator';
import {
  AddSubscribersRequestDto,
  CreateTopicRequestDto,
  CreateTopicResponseDto,
  FilterTopicsRequestDto,
  FilterTopicsResponseDto,
  GetTopicResponseDto,
  RemoveSubscribersRequestDto,
  RenameTopicRequestDto,
  RenameTopicResponseDto,
  TopicSubscriberDto,
} from './dtos';
import { AssignSubscriberToTopicDto } from './dtos/assignSubscriberToTopicDto';
import {
  AddSubscribersCommand,
  AddSubscribersUseCase,
  CreateTopicCommand,
  CreateTopicUseCase,
  DeleteTopicCommand,
  DeleteTopicUseCase,
  FilterTopicsCommand,
  FilterTopicsUseCase,
  GetTopicCommand,
  GetTopicSubscriberCommand,
  GetTopicSubscriberUseCase,
  GetTopicUseCase,
  RemoveSubscribersCommand,
  RemoveSubscribersUseCase,
  RenameTopicCommand,
  RenameTopicUseCase,
} from './use-cases';

@ThrottlerCategory(ApiRateLimitCategoryEnum.CONFIGURATION)
@ApiCommonResponses()
@Controller('/topics')
@RequireAuthentication()
@ApiTags('Topics')
export class TopicsV1Controller {
  constructor(
    private addSubscribersUseCase: AddSubscribersUseCase,
    private createTopicUseCase: CreateTopicUseCase,
    private deleteTopicUseCase: DeleteTopicUseCase,
    private filterTopicsUseCase: FilterTopicsUseCase,
    private getTopicSubscriberUseCase: GetTopicSubscriberUseCase,
    private getTopicUseCase: GetTopicUseCase,
    private removeSubscribersUseCase: RemoveSubscribersUseCase,
    private renameTopicUseCase: RenameTopicUseCase
  ) {}

  @Post('')
  @ExternalApiAccessible()
  @ApiExcludeEndpoint()
  @ApiResponse(CreateTopicResponseDto, 201)
  @ApiOperation({ summary: 'Topic creation', description: 'Create a topic' })
  async createTopic(
    @UserSession() user: UserSessionData,
    @Body() body: CreateTopicRequestDto
  ): Promise<CreateTopicResponseDto> {
    const topic = await this.createTopicUseCase.execute(
      CreateTopicCommand.create({
        environmentId: user.environmentId,
        key: body.key,
        name: body.name,
        organizationId: user.organizationId,
        userId: user._id,
      })
    );

    return {
      _id: topic._id,
      key: topic.key,
    };
  }

  @Post('/:topicKey/subscribers')
  @ExternalApiAccessible()
  @ApiExcludeEndpoint()
  @HttpCode(HttpStatus.OK)
  @ApiOkResponse({ type: AssignSubscriberToTopicDto })
  @ApiOperation({ summary: 'Subscribers addition', description: 'Add subscribers to a topic by key' })
  @ApiParam({ name: 'topicKey', description: 'The topic key', type: String, required: true })
  @SdkGroupName('Topics.Subscribers')
  @SdkMethodName('assign')
  async assign(
    @UserSession() user: UserSessionData,
    @Param('topicKey') topicKey: TopicKey,
    @Body() body: AddSubscribersRequestDto
  ): Promise<AssignSubscriberToTopicDto> {
    const { existingExternalSubscribers, nonExistingExternalSubscribers } = await this.addSubscribersUseCase.execute(
      AddSubscribersCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        subscribers: body.subscribers,
        userId: user._id,
        topicKey,
      })
    );

    return {
      succeeded: existingExternalSubscribers,
      ...(nonExistingExternalSubscribers.length > 0 && {
        failed: {
          notFound: nonExistingExternalSubscribers,
        },
      }),
    };
  }

  @Get('/:topicKey/subscribers/:externalSubscriberId')
  @ExternalApiAccessible()
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Check topic subscriber', description: 'Check if a subscriber belongs to a certain topic' })
  @ApiParam({ name: 'topicKey', description: 'The topic key', type: String, required: true })
  @ApiParam({ name: 'externalSubscriberId', description: 'The external subscriber id', type: String, required: true })
  @SdkGroupName('Topics.Subscribers')
  @ApiOkResponse({ type: TopicSubscriberDto })
  async getTopicSubscriber(
    @UserSession() user: UserSessionData,
    @Param('topicKey') topicKey: TopicKey,
    @Param('externalSubscriberId') externalSubscriberId: ExternalSubscriberId
  ): Promise<TopicSubscriberDto> {
    return await this.getTopicSubscriberUseCase.execute(
      GetTopicSubscriberCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        externalSubscriberId,
        topicKey,
      })
    );
  }

  @Post('/:topicKey/subscribers/removal')
  @ExternalApiAccessible()
  @ApiExcludeEndpoint()
  @ApiNoContentResponse()
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({ summary: 'Subscribers removal', description: 'Remove subscribers from a topic' })
  @ApiParam({ name: 'topicKey', description: 'The topic key', type: String, required: true })
  @SdkGroupName('Topics.Subscribers')
  @SdkMethodName('remove')
  async removeSubscribers(
    @UserSession() user: UserSessionData,
    @Param('topicKey') topicKey: TopicKey,
    @Body() body: RemoveSubscribersRequestDto
  ): Promise<void> {
    await this.removeSubscribersUseCase.execute(
      RemoveSubscribersCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        topicKey,
        subscribers: body.subscribers,
      })
    );
  }

  @Get('')
  @ExternalApiAccessible()
  @ApiOkResponse({
    type: FilterTopicsResponseDto,
  })
  @ApiOperation({
    summary: 'Get topic list filtered ',
    description:
      'Returns a list of topics that can be paginated using the `page` query ' +
      'parameter and filtered by the topic key with the `key` query parameter or by the topic name with the `name` query parameter',
  })
  @ApiExcludeEndpoint()
  async listTopics(
    @UserSession() user: UserSessionData,
    @Query() query?: FilterTopicsRequestDto
  ): Promise<FilterTopicsResponseDto> {
    return await this.filterTopicsUseCase.execute(
      FilterTopicsCommand.create({
        environmentId: user.environmentId,
        key: query?.key,
        name: query?.name,
        organizationId: user.organizationId,
        page: query?.page,
        pageSize: query?.pageSize,
      })
    );
  }

  @Delete('/:topicKey')
  @ApiExcludeEndpoint()
  @ExternalApiAccessible()
  @ApiNoContentResponse({
    description: 'The topic has been deleted correctly',
  })
  @ApiParam({ name: 'topicKey', description: 'The topic key', type: String, required: true })
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({ summary: 'Delete topic', description: 'Delete a topic by its topic key if it has no subscribers' })
  async deleteTopic(@UserSession() user: UserSessionData, @Param('topicKey') topicKey: TopicKey): Promise<void> {
    await this.deleteTopicUseCase.execute(
      DeleteTopicCommand.create({
        environmentId: user.environmentId,
        topicKey,
        organizationId: user.organizationId,
      })
    );
  }

  @Get('/:topicKey')
  @ApiExcludeEndpoint()
  @ExternalApiAccessible()
  @ApiResponse(GetTopicResponseDto)
  @ApiOperation({ summary: 'Get topic', description: 'Get a topic by its topic key' })
  @ApiParam({ name: 'topicKey', description: 'The topic key', type: String, required: true })
  async getTopic(
    @UserSession() user: UserSessionData,
    @Param('topicKey') topicKey: TopicKey
  ): Promise<GetTopicResponseDto> {
    return await this.getTopicUseCase.execute(
      GetTopicCommand.create({
        environmentId: user.environmentId,
        topicKey,
        organizationId: user.organizationId,
      })
    );
  }

  @Patch('/:topicKey')
  @ApiExcludeEndpoint()
  @ExternalApiAccessible()
  @ApiResponse(RenameTopicResponseDto)
  @ApiOperation({ summary: 'Rename a topic', description: 'Rename a topic by providing a new name' })
  @ApiParam({ name: 'topicKey', description: 'The topic key', type: String, required: true })
  @SdkMethodName('rename')
  async renameTopic(
    @UserSession() user: UserSessionData,
    @Param('topicKey') topicKey: TopicKey,
    @Body() body: RenameTopicRequestDto
  ): Promise<RenameTopicResponseDto> {
    return await this.renameTopicUseCase.execute(
      RenameTopicCommand.create({
        environmentId: user.environmentId,
        topicKey,
        name: body.name,
        organizationId: user.organizationId,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class TopicsV1Controller

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/topics-v1.module.ts
Tamaño: 705 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Module } from '@nestjs/common';

import { StorageHelperService } from '@novu/application-generic';
import { CommunityOrganizationRepository } from '@novu/dal';
import { AuthModule } from '../auth/auth.module';
import { SharedModule } from '../shared/shared.module';
import { SubscribersV1Module } from '../subscribers/subscribersV1.module';
import { TopicsV1Controller } from './topics-v1.controller';
import { USE_CASES } from './use-cases';

@Module({
  imports: [SharedModule, AuthModule, SubscribersV1Module],
  providers: [...USE_CASES, StorageHelperService, CommunityOrganizationRepository],
  exports: [...USE_CASES],
  controllers: [TopicsV1Controller],
})
export class TopicsV1Module {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class TopicsV1Module

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/dtos/add-subscribers.dto.ts
Tamaño: 357 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IsArray, IsDefined } from 'class-validator';

import { ExternalSubscriberId } from '../types';

export class AddSubscribersRequestDto {
  @ApiProperty({
    description: 'List of subscriber identifiers that will be associated to the topic',
  })
  @IsArray()
  @IsDefined()
  subscribers: string[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class AddSubscribersRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/dtos/assignSubscriberToTopicDto.ts
Tamaño: 659 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { ExternalSubscriberId } from '@novu/shared';

export class FailedAssignmentsDto {
  @ApiProperty({
    description: 'List of subscriber IDs that were not found',
    type: [String],
    required: false,
  })
  notFound?: ExternalSubscriberId[];
}

export class AssignSubscriberToTopicDto {
  @ApiProperty({
    description: 'List of successfully assigned subscriber IDs',
    type: [String],
  })
  succeeded: ExternalSubscriberId[];

  @ApiProperty({
    description: 'Details about failed assignments',
    required: false,
    type: () => FailedAssignmentsDto,
  })
  failed?: FailedAssignmentsDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class FailedAssignmentsDto
- export class AssignSubscriberToTopicDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/dtos/create-topic.dto.ts
Tamaño: 854 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IsDefined, IsString } from 'class-validator';

export class CreateTopicResponseDto {
  @ApiPropertyOptional({
    description: 'The unique identifier for the Topic created.',
  })
  _id: string;

  @ApiProperty({
    description:
      'User defined custom key and provided by the user that will be an unique identifier for the Topic created.',
  })
  key: string;
}

export class CreateTopicRequestDto {
  @ApiProperty({
    description:
      'User defined custom key and provided by the user that will be an unique identifier for the Topic created.',
  })
  @IsString()
  @IsDefined()
  key: string;

  @ApiProperty({
    description: 'User defined custom name and provided by the user that will name the Topic created.',
  })
  @IsString()
  @IsDefined()
  name: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateTopicResponseDto
- export class CreateTopicRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/dtos/filter-topics.dto.ts
Tamaño: 1743 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { Transform } from 'class-transformer';
import { IsOptional, IsString } from 'class-validator';
import { TopicDto } from './topic.dto';

export class FilterTopicsRequestDto {
  @ApiProperty({
    example: 0,
    required: false,
    type: 'integer',
    format: 'int64',
    description: 'The page number to retrieve (starts from 0)',
  })
  @IsOptional()
  @Transform(({ value }) => Number(value)) // Convert string to integer
  public page?: number = 0;

  @ApiProperty({
    example: 10,
    required: false,
    type: 'integer',
    format: 'int64',
    description: 'The number of items to return per page (default: 10)',
  })
  @IsOptional()
  @Transform(({ value }) => Number(value)) // Convert string to integer
  public pageSize?: number = 10;

  @ApiPropertyOptional({
    example: 'exampleKey',
    type: 'string',
    description: 'A filter key to apply to the results',
  })
  @IsString()
  @IsOptional()
  public key?: string;

  @ApiPropertyOptional({
    example: 'Example Topic',
    type: 'string',
    description: 'A filter name to apply to the results',
  })
  @IsString()
  @IsOptional()
  public name?: string;
}

export class FilterTopicsResponseDto {
  @ApiProperty({
    example: [],
    type: [TopicDto],
    description: 'The list of topics',
  })
  data: TopicDto[];

  @ApiProperty({
    example: 1,
    type: Number,
    description: 'The current page number',
  })
  page: number;

  @ApiProperty({
    example: 10,
    type: Number,
    description: 'The number of items per page',
  })
  pageSize: number;

  @ApiProperty({
    example: 10,
    type: Number,
    description: 'The total number of items',
  })
  totalCount: number;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - number(0;

  @ApiProperty({
    example: 10,
    required: false,
    type: 'integer',
    format: 'int64',...)
Declaraciones 'export' encontradas:
- export class FilterTopicsRequestDto
- export class FilterTopicsResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/dtos/get-topic.dto.ts
Tamaño: 94 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { TopicDto } from './topic.dto';

export class GetTopicResponseDto extends TopicDto {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetTopicResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/dtos/index.ts
Tamaño: 292 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './add-subscribers.dto';
export * from './create-topic.dto';
export * from './filter-topics.dto';
export * from './get-topic.dto';
export * from './remove-subscribers.dto';
export * from './rename-topic.dto';
export * from './topic.dto';
export * from './topic-subscriber.dto';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/dtos/remove-subscribers.dto.ts
Tamaño: 357 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IsArray, IsDefined } from 'class-validator';

import { ExternalSubscriberId } from '../types';

export class RemoveSubscribersRequestDto {
  @ApiProperty({
    description: 'List of subscriber identifiers that will be removed to the topic',
  })
  @IsArray()
  @IsDefined()
  subscribers: string[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RemoveSubscribersRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/dtos/rename-topic.dto.ts
Tamaño: 398 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IsDefined, IsString } from 'class-validator';

import { TopicDto } from './topic.dto';

export class RenameTopicResponseDto extends TopicDto {}

export class RenameTopicRequestDto {
  @ApiProperty({
    description: 'User defined custom name and provided by the user to rename the topic.',
  })
  @IsString()
  @IsDefined()
  name: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RenameTopicResponseDto
- export class RenameTopicRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/dtos/topic-subscriber.dto.ts
Tamaño: 974 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { ITopicSubscriber } from '@novu/shared';

export class TopicSubscriberDto implements ITopicSubscriber {
  @ApiProperty({
    description: 'Unique identifier for the organization',
    example: 'org_123456789',
  })
  _organizationId: string;

  @ApiProperty({
    description: 'Unique identifier for the environment',
    example: 'env_123456789',
  })
  _environmentId: string;

  @ApiProperty({
    description: 'Unique identifier for the subscriber',
    example: 'sub_123456789',
  })
  _subscriberId: string;

  @ApiProperty({
    description: 'Unique identifier for the topic',
    example: 'topic_123456789',
  })
  _topicId: string;

  @ApiProperty({
    description: 'Key associated with the topic',
    example: 'my_topic_key',
  })
  topicKey: string;

  @ApiProperty({
    description: 'External identifier for the subscriber',
    example: 'external_subscriber_123',
  })
  externalSubscriberId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class TopicSubscriberDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/dtos/topic.dto.ts
Tamaño: 585 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IsOptional, IsString } from 'class-validator';

export class TopicDto {
  @ApiPropertyOptional()
  _id: string;

  @ApiProperty()
  _organizationId: string;

  @ApiProperty()
  _environmentId: string;

  @ApiProperty()
  key: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  name?: string;

  @ApiProperty()
  subscribers: string[];

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  createdAt?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  updatedAt?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class TopicDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/types/index.ts
Tamaño: 153 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export {
  EnvironmentId,
  ExternalSubscriberId,
  OrganizationId,
  SubscriberId,
  TopicId,
  TopicKey,
  TopicName,
  UserId,
} from '@novu/shared';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/use-cases/index.ts
Tamaño: 1070 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { GetTopicSubscribersUseCase } from '@novu/application-generic';
import { AddSubscribersUseCase } from './add-subscribers';
import { CreateTopicUseCase } from './create-topic';
import { DeleteTopicUseCase } from './delete-topic/delete-topic.use-case';
import { FilterTopicsUseCase } from './filter-topics';
import { GetTopicUseCase } from './get-topic';
import { GetTopicSubscriberUseCase } from './get-topic-subscriber';
import { RemoveSubscribersUseCase } from './remove-subscribers';
import { RenameTopicUseCase } from './rename-topic';

export * from './add-subscribers';
export * from './create-topic';
export * from './delete-topic';
export * from './filter-topics';
export * from './get-topic';
export * from './get-topic-subscriber';
export * from './remove-subscribers';
export * from './rename-topic';

export const USE_CASES = [
  AddSubscribersUseCase,
  CreateTopicUseCase,
  DeleteTopicUseCase,
  FilterTopicsUseCase,
  GetTopicUseCase,
  GetTopicSubscriberUseCase,
  GetTopicSubscribersUseCase,
  RemoveSubscribersUseCase,
  RenameTopicUseCase,
];


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export
- export
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/use-cases/add-subscribers/add-subscribers.command.ts
Tamaño: 407 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsArray, IsDefined, IsString } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';
import { ExternalSubscriberId, TopicKey } from '../../types';

export class AddSubscribersCommand extends EnvironmentWithUserCommand {
  @IsString()
  @IsDefined()
  topicKey: TopicKey;

  @IsArray()
  @IsDefined()
  subscribers: ExternalSubscriberId[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class AddSubscribersCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/use-cases/add-subscribers/add-subscribers.use-case.ts
Tamaño: 4078 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { CreateTopicSubscribersEntity, TopicEntity, TopicRepository, TopicSubscribersRepository } from '@novu/dal';
import { SubscriberDto } from '@novu/shared';
import { SearchByExternalSubscriberIds, SearchByExternalSubscriberIdsCommand } from '../../../subscribers/usecases';
import { ExternalSubscriberId } from '../../types';

import { CreateTopicCommand, CreateTopicUseCase } from '../create-topic';
import { AddSubscribersCommand } from './add-subscribers.command';

interface ISubscriberGroups {
  existingExternalSubscribers: ExternalSubscriberId[];
  nonExistingExternalSubscribers: ExternalSubscriberId[];
  subscribersAvailableToAdd: SubscriberDto[];
}

@Injectable()
export class AddSubscribersUseCase {
  constructor(
    private createTopic: CreateTopicUseCase,
    private searchByExternalSubscriberIds: SearchByExternalSubscriberIds,
    private topicSubscribersRepository: TopicSubscribersRepository,
    private topicRepository: TopicRepository
  ) {}

  async execute(command: AddSubscribersCommand): Promise<Omit<ISubscriberGroups, 'subscribersAvailableToAdd'>> {
    let topic = await this.topicRepository.findTopicByKey(
      command.topicKey,
      command.organizationId,
      command.environmentId
    );

    if (!topic) {
      const createTopicCommand = CreateTopicCommand.create({
        environmentId: command.environmentId,
        key: command.topicKey,
        // TODO: Maybe make more clear that is a provisional name
        name: `Autogenerated-${command.topicKey}`,
        organizationId: command.organizationId,
        userId: command.userId,
      });
      topic = await this.createTopic.execute(createTopicCommand);
    }

    const { existingExternalSubscribers, nonExistingExternalSubscribers, subscribersAvailableToAdd } =
      await this.filterExistingSubscribers(command);

    if (subscribersAvailableToAdd.length > 0) {
      const topicSubscribers = this.mapSubscribersToTopic(topic, subscribersAvailableToAdd);
      await this.topicSubscribersRepository.addSubscribers(topicSubscribers);
    }

    return {
      existingExternalSubscribers,
      nonExistingExternalSubscribers,
    };
  }

  private async filterExistingSubscribers(command: AddSubscribersCommand): Promise<ISubscriberGroups> {
    const searchByExternalSubscriberIdsCommand = SearchByExternalSubscriberIdsCommand.create({
      environmentId: command.environmentId,
      organizationId: command.organizationId,
      externalSubscriberIds: command.subscribers,
    });
    const foundSubscribers = await this.searchByExternalSubscriberIds.execute(searchByExternalSubscriberIdsCommand);

    return this.groupSubscribersIfBelonging(command.subscribers, foundSubscribers);
  }

  /**
   * Time complexity: 0(n)
   */
  private groupSubscribersIfBelonging(
    subscribers: ExternalSubscriberId[],
    foundSubscribers: SubscriberDto[]
  ): ISubscriberGroups {
    const subscribersList = new Set<ExternalSubscriberId>(subscribers);
    const subscribersAvailableToAdd = new Set<SubscriberDto>();
    const existingExternalSubscribersList = new Set<ExternalSubscriberId>();

    for (const foundSubscriber of foundSubscribers) {
      existingExternalSubscribersList.add(foundSubscriber.subscriberId);
      subscribersList.delete(foundSubscriber.subscriberId);
      subscribersAvailableToAdd.add(foundSubscriber);
    }

    return {
      existingExternalSubscribers: Array.from(existingExternalSubscribersList),
      nonExistingExternalSubscribers: Array.from(subscribersList),
      subscribersAvailableToAdd: Array.from(subscribersAvailableToAdd),
    };
  }

  private mapSubscribersToTopic(topic: TopicEntity, subscribers: SubscriberDto[]): CreateTopicSubscribersEntity[] {
    return subscribers.map((subscriber) => ({
      _environmentId: subscriber._environmentId,
      _organizationId: subscriber._organizationId,
      _subscriberId: subscriber._id,
      _topicId: topic._id,
      topicKey: topic.key,
      externalSubscriberId: subscriber.subscriberId,
    }));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - existingExternalSubscribersList(new Set<ExternalSubscriberId>();

    for (const foundSubscriber of foundSubscribers) {
      existi...)
Declaraciones 'export' encontradas:
- export class AddSubscribersUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/use-cases/add-subscribers/index.ts
Tamaño: 87 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './add-subscribers.command';
export * from './add-subscribers.use-case';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/use-cases/create-topic/create-topic.command.ts
Tamaño: 491 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Transform } from 'class-transformer';
import { IsDefined, IsString } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';
import { TopicKey, TopicName } from '../../types';

export class CreateTopicCommand extends EnvironmentWithUserCommand {
  @IsString()
  @IsDefined()
  @Transform(({ value }) => value.trim())
  key: TopicKey;

  @IsString()
  @IsDefined()
  @Transform(({ value }) => value.trim())
  name: TopicName;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateTopicCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/use-cases/create-topic/create-topic.use-case.ts
Tamaño: 3529 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, ConflictException, Injectable } from '@nestjs/common';
import { FeatureFlagsService, PinoLogger } from '@novu/application-generic';
import {
  CommunityOrganizationRepository,
  EnvironmentEntity,
  EnvironmentRepository,
  OrganizationEntity,
  TopicEntity,
  TopicRepository,
  UserEntity,
} from '@novu/dal';
import { FeatureFlagsKeysEnum, VALID_ID_REGEX } from '@novu/shared';
import { TopicDto } from '../../dtos/topic.dto';
import { CreateTopicCommand } from './create-topic.command';

@Injectable()
export class CreateTopicUseCase {
  constructor(
    private topicRepository: TopicRepository,
    private featureFlagService: FeatureFlagsService,
    private environmentRepository: EnvironmentRepository,
    private communityOrganizationRepository: CommunityOrganizationRepository,
    private logger: PinoLogger
  ) {
    this.logger.setContext(this.constructor.name);
  }

  async execute(command: CreateTopicCommand) {
    const entity = this.mapToEntity(command);

    const [environment, organization] = await Promise.all([
      this.environmentRepository.findOne({ _id: command.environmentId }),
      this.communityOrganizationRepository.findOne({ _id: command.organizationId }),
    ]);

    if (!organization) {
      throw new BadRequestException('Organization not found');
    }

    if (!environment) {
      throw new BadRequestException('Environment not found');
    }

    const topicExists = await this.topicRepository.findTopicByKey(
      entity.key,
      entity._organizationId,
      entity._environmentId
    );

    if (topicExists) {
      throw new ConflictException(
        `Topic exists with key ${entity.key} in the environment ${entity._environmentId} of the organization ${entity._organizationId}`
      );
    }

    await this.validateTopicKey({
      environment,
      organization,
      userId: command.userId,
      key: entity.key,
    });

    const topic = await this.topicRepository.createTopic(entity);

    return this.mapFromEntity(topic);
  }

  private mapToEntity(domainEntity: CreateTopicCommand): Omit<TopicEntity, '_id'> {
    return {
      _environmentId: domainEntity.environmentId,
      _organizationId: domainEntity.organizationId,
      key: domainEntity.key,
      name: domainEntity.name,
    };
  }

  private mapFromEntity(topic: TopicEntity): TopicDto {
    return {
      ...topic,
      _id: topic._id,
      _organizationId: topic._organizationId,
      _environmentId: topic._environmentId,
      subscribers: [],
    };
  }

  private isValidTopicKey(key: string): boolean {
    return key.length > 0 && key.match(VALID_ID_REGEX) !== null;
  }

  private async validateTopicKey({
    key,
    userId,
    environment,
    organization,
  }: {
    key: string;
    environment?: EnvironmentEntity;
    organization?: OrganizationEntity;
    userId: string;
  }): Promise<void> {
    const isDryRun = await this.featureFlagService.getFlag({
      environment,
      organization,
      user: { _id: userId } as UserEntity,
      key: FeatureFlagsKeysEnum.IS_TOPIC_KEYS_VALIDATION_DRY_RUN_ENABLED,
      defaultValue: true,
    });

    if (this.isValidTopicKey(key)) {
      return;
    }

    if (isDryRun) {
      this.logger.warn(`[Dry run] Invalid topic key: ${key}`);
    } else {
      throw new BadRequestException(
        `Invalid topic key: "${key}". Topic keys must contain only alphanumeric characters (a-z, A-Z, 0-9), hyphens (-), underscores (_), colons (:), or be a valid email address.`
      );
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateTopicUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/use-cases/create-topic/index.ts
Tamaño: 81 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './create-topic.command';
export * from './create-topic.use-case';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/use-cases/delete-topic/delete-topic.command.ts
Tamaño: 289 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsString } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';
import { TopicKey } from '../../types';

export class DeleteTopicCommand extends EnvironmentCommand {
  @IsString()
  @IsDefined()
  topicKey: TopicKey;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DeleteTopicCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/use-cases/delete-topic/delete-topic.use-case.ts
Tamaño: 889 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ConflictException, Injectable } from '@nestjs/common';
import { TopicRepository } from '@novu/dal';
import { GetTopicUseCase } from '../get-topic';
import { DeleteTopicCommand } from './delete-topic.command';

@Injectable()
export class DeleteTopicUseCase {
  constructor(
    private getTopicUseCase: GetTopicUseCase,
    private topicRepository: TopicRepository
  ) {}

  async execute(command: DeleteTopicCommand): Promise<void> {
    const topic = await this.getTopicUseCase.execute(command);

    const { subscribers } = topic;

    if (subscribers?.length !== 0) {
      throw new ConflictException(
        `Topic with key ${command.topicKey} in the environment ${command.environmentId} can't be deleted as it still has subscribers assigned`
      );
    }

    await this.topicRepository.deleteTopic(command.topicKey, command.environmentId, command.organizationId);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DeleteTopicUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/use-cases/delete-topic/index.ts
Tamaño: 81 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './delete-topic.command';
export * from './delete-topic.use-case';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/use-cases/filter-topics/filter-topics.command.ts
Tamaño: 487 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsInt, IsOptional, IsString, Max, Min } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';
import { TopicKey } from '../../types';

export class FilterTopicsCommand extends EnvironmentCommand {
  @IsString()
  @IsOptional()
  key?: TopicKey;

  @IsString()
  @IsOptional()
  name?: string;

  @IsOptional()
  @IsInt()
  @Min(0)
  page?: number = 0;

  @IsOptional()
  @IsInt()
  @Min(0)
  @Max(10)
  pageSize?: number = 10;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class FilterTopicsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/use-cases/filter-topics/filter-topics.use-case.ts
Tamaño: 1859 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable } from '@nestjs/common';
import { TopicEntity, TopicRepository } from '@novu/dal';
import { TopicDto } from '../../dtos/topic.dto';
import { ExternalSubscriberId } from '../../types';
import { FilterTopicsCommand } from './filter-topics.command';

const DEFAULT_TOPIC_LIMIT = 10;

@Injectable()
export class FilterTopicsUseCase {
  constructor(private topicRepository: TopicRepository) {}

  async execute(command: FilterTopicsCommand) {
    const { pageSize = DEFAULT_TOPIC_LIMIT, page = 0 } = command;

    if (pageSize > DEFAULT_TOPIC_LIMIT) {
      throw new BadRequestException(`Page size can not be larger then ${DEFAULT_TOPIC_LIMIT}`);
    }

    const query = this.mapFromCommandToEntity(command);

    const totalCount = await this.topicRepository.count(query);

    const skipTimes = page <= 0 ? 0 : page;
    const pagination = {
      limit: pageSize,
      skip: skipTimes * pageSize,
    };

    const filteredTopics = await this.topicRepository.filterTopics(query, pagination);

    return {
      page,
      totalCount,
      pageSize,
      data: filteredTopics.map(this.mapFromEntityToDto),
    };
  }

  private mapFromCommandToEntity(
    command: FilterTopicsCommand
  ): Pick<TopicEntity, '_environmentId' | 'key' | 'name' | '_organizationId'> {
    return {
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
      ...(command.key && { key: command.key }),
      ...(command.name && { name: command.name }),
    } as Pick<TopicEntity, '_environmentId' | 'key' | 'name' | '_organizationId'>;
  }

  private mapFromEntityToDto(topic: TopicEntity & { subscribers: ExternalSubscriberId[] }): TopicDto {
    return {
      ...topic,
      _id: topic._id,
      _organizationId: topic._organizationId,
      _environmentId: topic._environmentId,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class FilterTopicsUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/use-cases/filter-topics/index.ts
Tamaño: 83 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './filter-topics.command';
export * from './filter-topics.use-case';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/use-cases/get-topic-subscriber/get-topic-subscriber.command.ts
Tamaño: 394 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsString } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';
import { ExternalSubscriberId, TopicKey } from '../../types';

export class GetTopicSubscriberCommand extends EnvironmentCommand {
  @IsString()
  @IsDefined()
  externalSubscriberId: ExternalSubscriberId;

  @IsString()
  @IsDefined()
  topicKey: TopicKey;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetTopicSubscriberCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/use-cases/get-topic-subscriber/get-topic-subscriber.use-case.ts
Tamaño: 1418 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { TopicSubscribersEntity, TopicSubscribersRepository } from '@novu/dal';
import { TopicSubscriberDto } from '../../dtos';
import { GetTopicSubscriberCommand } from './get-topic-subscriber.command';

@Injectable()
export class GetTopicSubscriberUseCase {
  constructor(private topicSubscribersRepository: TopicSubscribersRepository) {}

  async execute(command: GetTopicSubscriberCommand): Promise<TopicSubscriberDto> {
    const topicSubscriber = await this.topicSubscribersRepository.findOneByTopicKeyAndExternalSubscriberId(
      command.environmentId,
      command.organizationId,
      command.topicKey,
      command.externalSubscriberId
    );

    if (!topicSubscriber) {
      throw new NotFoundException(
        `Subscriber ${command.externalSubscriberId} not found for topic ${command.topicKey} in the environment ${command.environmentId}`
      );
    }

    return this.mapFromEntity(topicSubscriber);
  }

  private mapFromEntity(topicSubscriber: TopicSubscribersEntity): TopicSubscriberDto {
    return {
      externalSubscriberId: topicSubscriber.externalSubscriberId,
      topicKey: topicSubscriber.topicKey,
      _topicId: topicSubscriber._topicId,
      _organizationId: topicSubscriber._organizationId,
      _environmentId: topicSubscriber._environmentId,
      _subscriberId: topicSubscriber._subscriberId,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetTopicSubscriberUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/use-cases/get-topic-subscriber/index.ts
Tamaño: 97 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './get-topic-subscriber.command';
export * from './get-topic-subscriber.use-case';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/use-cases/get-topic/get-topic.command.ts
Tamaño: 286 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsString } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';
import { TopicKey } from '../../types';

export class GetTopicCommand extends EnvironmentCommand {
  @IsString()
  @IsDefined()
  topicKey: TopicKey;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetTopicCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/use-cases/get-topic/get-topic.use-case.ts
Tamaño: 977 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { TopicEntity, TopicRepository } from '@novu/dal';
import { TopicDto } from '../../dtos';
import { ExternalSubscriberId } from '../../types';
import { GetTopicCommand } from './get-topic.command';

@Injectable()
export class GetTopicUseCase {
  constructor(private topicRepository: TopicRepository) {}

  async execute(command: GetTopicCommand) {
    const topic = await this.topicRepository.findTopic(command.topicKey, command.environmentId);

    if (!topic) {
      throw new NotFoundException(
        `Topic not found for id ${command.topicKey} in the environment ${command.environmentId}`
      );
    }

    return this.mapFromEntity(topic);
  }

  private mapFromEntity(topic: TopicEntity & { subscribers: ExternalSubscriberId[] }): TopicDto {
    return {
      ...topic,
      _id: topic._id,
      _organizationId: topic._organizationId,
      _environmentId: topic._environmentId,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetTopicUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/use-cases/get-topic/index.ts
Tamaño: 75 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './get-topic.command';
export * from './get-topic.use-case';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/use-cases/remove-subscribers/index.ts
Tamaño: 93 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './remove-subscribers.command';
export * from './remove-subscribers.use-case';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/use-cases/remove-subscribers/remove-subscribers.command.ts
Tamaño: 394 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsArray, IsDefined, IsString } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';
import { ExternalSubscriberId, TopicKey } from '../../types';

export class RemoveSubscribersCommand extends EnvironmentCommand {
  @IsString()
  @IsDefined()
  topicKey: TopicKey;

  @IsArray()
  @IsDefined()
  subscribers: ExternalSubscriberId[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RemoveSubscribersCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/use-cases/remove-subscribers/remove-subscribers.use-case.ts
Tamaño: 698 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ConflictException, Injectable } from '@nestjs/common';
import { TopicSubscribersEntity, TopicSubscribersRepository } from '@novu/dal';
import { EnvironmentId, OrganizationId, TopicId } from '../../types';
import { RemoveSubscribersCommand } from './remove-subscribers.command';

@Injectable()
export class RemoveSubscribersUseCase {
  constructor(private topicSubscribersRepository: TopicSubscribersRepository) {}

  async execute(command: RemoveSubscribersCommand): Promise<void> {
    await this.topicSubscribersRepository.removeSubscribers(
      command.environmentId,
      command.organizationId,
      command.topicKey,
      command.subscribers
    );

    return undefined;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RemoveSubscribersUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/use-cases/rename-topic/index.ts
Tamaño: 81 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './rename-topic.command';
export * from './rename-topic.use-case';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/use-cases/rename-topic/rename-topic.command.ts
Tamaño: 349 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsString } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';
import { TopicKey, TopicName } from '../../types';

export class RenameTopicCommand extends EnvironmentCommand {
  @IsString()
  @IsDefined()
  topicKey: TopicKey;

  @IsString()
  @IsDefined()
  name: TopicName;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RenameTopicCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v1/use-cases/rename-topic/rename-topic.use-case.ts
Tamaño: 1479 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import { TopicEntity, TopicRepository } from '@novu/dal';
import { TopicDto } from '../../dtos/topic.dto';
import { ExternalSubscriberId } from '../../types';
import { GetTopicUseCase } from '../get-topic';
import { RenameTopicCommand } from './rename-topic.command';

@Injectable()
export class RenameTopicUseCase {
  constructor(
    private getTopicUseCase: GetTopicUseCase,
    private topicRepository: TopicRepository
  ) {}

  async execute(command: RenameTopicCommand): Promise<TopicDto> {
    const topic = await this.getTopicUseCase.execute(command);
    if (!topic) throw new NotFoundException(`Topic ${command.topicKey} not found`);

    const query = this.mapToQuery(command);
    if (!query.name) throw new BadRequestException('Name is required');

    const renamedTopic = await this.topicRepository.renameTopic(topic._id, query._environmentId, query.name);

    return this.mapFromEntityToDto(renamedTopic);
  }

  private mapToQuery(domainEntity: RenameTopicCommand): Pick<TopicEntity, '_environmentId' | 'name'> {
    return {
      _environmentId: domainEntity.environmentId,
      name: domainEntity.name,
    };
  }

  private mapFromEntityToDto(topic: TopicEntity & { subscribers: ExternalSubscriberId[] }): TopicDto {
    return {
      ...topic,
      _id: topic._id,
      _organizationId: topic._organizationId,
      _environmentId: topic._environmentId,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RenameTopicUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/topics-v2.module.ts
Tamaño: 356 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Module } from '@nestjs/common';
import { SharedModule } from '../shared/shared.module';
import { TopicsController } from './topics.controller';
import { USE_CASES } from './usecases';

@Module({
  imports: [SharedModule],
  controllers: [TopicsController],
  providers: [...USE_CASES],
  exports: [...USE_CASES],
})
export class TopicsV2Module {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class TopicsV2Module

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/topics.controller.ts
Tamaño: 14001 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  Body,
  ClassSerializerInterceptor,
  Controller,
  Delete,
  Get,
  HttpCode,
  HttpException,
  HttpStatus,
  Param,
  Patch,
  Post,
  Query,
  Res,
  UseInterceptors,
} from '@nestjs/common';
import { ApiOperation, ApiParam, ApiQuery, ApiTags } from '@nestjs/swagger';
import { ExternalApiAccessible, RequirePermissions } from '@novu/application-generic';
import { ApiRateLimitCategoryEnum, PermissionsEnum, UserSessionData } from '@novu/shared';
import { Response } from 'express';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { ThrottlerCategory } from '../rate-limiting/guards/throttler.decorator';
import { DirectionEnum } from '../shared/dtos/base-responses';
import { ApiCommonResponses, ApiResponse } from '../shared/framework/response.decorator';
import { SdkGroupName, SdkMethodName } from '../shared/framework/swagger/sdk.decorators';
import { UserSession } from '../shared/framework/user.decorator';
import { CreateTopicSubscriptionsRequestDto } from './dtos/create-topic-subscriptions.dto';
import { CreateTopicSubscriptionsResponseDto } from './dtos/create-topic-subscriptions-response.dto';
import { CreateUpdateTopicRequestDto } from './dtos/create-update-topic.dto';
import { DeleteTopicResponseDto } from './dtos/delete-topic-response.dto';
import { DeleteTopicSubscriptionsRequestDto } from './dtos/delete-topic-subscriptions.dto';
import { DeleteTopicSubscriptionsResponseDto } from './dtos/delete-topic-subscriptions-response.dto';
import { ListTopicSubscriptionsQueryDto } from './dtos/list-topic-subscriptions-query.dto';
import { ListTopicSubscriptionsResponseDto } from './dtos/list-topic-subscriptions-response.dto';
import { ListTopicsQueryDto } from './dtos/list-topics-query.dto';
import { ListTopicsResponseDto } from './dtos/list-topics-response.dto';
import { TopicResponseDto } from './dtos/topic-response.dto';
import { UpdateTopicRequestDto } from './dtos/update-topic.dto';
import { CreateTopicSubscriptionsCommand } from './usecases/create-topic-subscriptions/create-topic-subscriptions.command';
import { CreateTopicSubscriptionsUsecase } from './usecases/create-topic-subscriptions/create-topic-subscriptions.usecase';
import { DeleteTopicCommand } from './usecases/delete-topic/delete-topic.command';
import { DeleteTopicUseCase } from './usecases/delete-topic/delete-topic.usecase';
import { DeleteTopicSubscriptionsCommand } from './usecases/delete-topic-subscriptions/delete-topic-subscriptions.command';
import { DeleteTopicSubscriptionsUsecase } from './usecases/delete-topic-subscriptions/delete-topic-subscriptions.usecase';
import { GetTopicCommand } from './usecases/get-topic/get-topic.command';
import { GetTopicUseCase } from './usecases/get-topic/get-topic.usecase';
import { ListTopicSubscriptionsCommand } from './usecases/list-topic-subscriptions/list-topic-subscriptions.command';
import { ListTopicSubscriptionsUseCase } from './usecases/list-topic-subscriptions/list-topic-subscriptions.usecase';
import { ListTopicsCommand } from './usecases/list-topics/list-topics.command';
import { ListTopicsUseCase } from './usecases/list-topics/list-topics.usecase';
import { UpdateTopicCommand } from './usecases/update-topic/update-topic.command';
import { UpdateTopicUseCase } from './usecases/update-topic/update-topic.usecase';
import { UpsertTopicCommand } from './usecases/upsert-topic/upsert-topic.command';
import { UpsertTopicUseCase } from './usecases/upsert-topic/upsert-topic.usecase';

@ThrottlerCategory(ApiRateLimitCategoryEnum.CONFIGURATION)
@Controller({ path: '/topics', version: '2' })
@UseInterceptors(ClassSerializerInterceptor)
@RequireAuthentication()
@ApiTags('Topics')
@SdkGroupName('Topics')
@ApiCommonResponses()
export class TopicsController {
  constructor(
    private listTopicsUsecase: ListTopicsUseCase,
    private upsertTopicUsecase: UpsertTopicUseCase,
    private getTopicUsecase: GetTopicUseCase,
    private updateTopicUsecase: UpdateTopicUseCase,
    private deleteTopicUsecase: DeleteTopicUseCase,
    private listTopicSubscriptionsUsecase: ListTopicSubscriptionsUseCase,
    private createTopicSubscriptionsUsecase: CreateTopicSubscriptionsUsecase,
    private deleteTopicSubscriptionsUsecase: DeleteTopicSubscriptionsUsecase
  ) {}

  @Get('')
  @ExternalApiAccessible()
  @SdkMethodName('list')
  @ApiOperation({
    summary: 'List all topics',
    description: `This api returns a paginated list of topics.
    Topics can be filtered by **key**, **name**, or **includeCursor** to paginate through the list. 
    Checkout all available filters in the query section.`,
  })
  @ApiResponse(ListTopicsResponseDto)
  @RequirePermissions(PermissionsEnum.TOPIC_READ)
  async listTopics(
    @UserSession() user: UserSessionData,
    @Query() query: ListTopicsQueryDto
  ): Promise<ListTopicsResponseDto> {
    return await this.listTopicsUsecase.execute(
      ListTopicsCommand.create({
        user,
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        limit: Number(query.limit || '10'),
        after: query.after,
        before: query.before,
        orderDirection: query.orderDirection || DirectionEnum.DESC,
        orderBy: query.orderBy || '_id',
        key: query.key,
        name: query.name,
        includeCursor: query.includeCursor,
      })
    );
  }

  @Post('')
  @ExternalApiAccessible()
  @ApiOperation({
    summary: 'Create a topic',
    description: `Creates a new topic if it does not exist, or updates an existing topic if it already exists. Use ?failIfExists=true to prevent updates.`,
  })
  @ApiResponse(TopicResponseDto, 201)
  @ApiResponse(TopicResponseDto, 200)
  @ApiResponse(TopicResponseDto, 409, false, false, {
    description: 'Topic already exists (when query param failIfExists=true)',
  })
  @ApiQuery({
    name: 'failIfExists',
    required: false,
    type: Boolean,
    description: 'If true, the request will fail if a topic with the same key already exists',
  })
  @SdkMethodName('create')
  @RequirePermissions(PermissionsEnum.TOPIC_WRITE)
  async upsertTopic(
    @UserSession() user: UserSessionData,
    @Body() body: CreateUpdateTopicRequestDto,
    @Res({ passthrough: true }) response: Response,
    @Query('failIfExists') failIfExists?: boolean
  ): Promise<TopicResponseDto> {
    const result = await this.upsertTopicUsecase.execute(
      UpsertTopicCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
        key: body.key,
        name: body.name,
        failIfExists,
      })
    );

    if (result.created) {
      response.status(HttpStatus.CREATED);
    }

    return result.topic;
  }

  @Get('/:topicKey')
  @ExternalApiAccessible()
  @SdkMethodName('get')
  @ApiOperation({
    summary: 'Retrieve a topic',
    description: `Retrieve a topic by its unique key identifier **topicKey**`,
  })
  @ApiParam({ name: 'topicKey', description: 'The key identifier of the topic', type: String })
  @ApiResponse(TopicResponseDto, 200)
  @RequirePermissions(PermissionsEnum.TOPIC_READ)
  async getTopic(@UserSession() user: UserSessionData, @Param('topicKey') topicKey: string): Promise<TopicResponseDto> {
    return await this.getTopicUsecase.execute(
      GetTopicCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        topicKey,
      })
    );
  }

  @Patch('/:topicKey')
  @ExternalApiAccessible()
  @SdkMethodName('update')
  @ApiOperation({
    summary: 'Update a topic',
    description: `Update a topic name by its unique key identifier **topicKey**`,
  })
  @ApiParam({ name: 'topicKey', description: 'The key identifier of the topic', type: String })
  @ApiResponse(TopicResponseDto, 200)
  @RequirePermissions(PermissionsEnum.TOPIC_WRITE)
  async updateTopic(
    @UserSession() user: UserSessionData,
    @Param('topicKey') topicKey: string,
    @Body() body: UpdateTopicRequestDto
  ): Promise<TopicResponseDto> {
    return await this.updateTopicUsecase.execute(
      UpdateTopicCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
        topicKey,
        name: body.name,
      })
    );
  }

  @Delete('/:topicKey')
  @ExternalApiAccessible()
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'Delete a topic',
    description: `Delete a topic by its unique key identifier **topicKey**. 
    This action is irreversible and will remove all subscriptions to the topic.`,
  })
  @ApiParam({ name: 'topicKey', description: 'The key identifier of the topic', type: String })
  @ApiResponse(DeleteTopicResponseDto, 200, false, true, {
    description: 'Topic deleted successfully',
  })
  @RequirePermissions(PermissionsEnum.TOPIC_WRITE)
  async deleteTopic(
    @UserSession() user: UserSessionData,
    @Param('topicKey') topicKey: string
  ): Promise<DeleteTopicResponseDto> {
    await this.deleteTopicUsecase.execute(
      DeleteTopicCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
        topicKey,
        force: true,
      })
    );

    return {
      acknowledged: true,
    };
  }

  @Get('/:topicKey/subscriptions')
  @ExternalApiAccessible()
  @SdkGroupName('Topics.Subscriptions')
  @ApiOperation({
    summary: `List topic subscriptions`,
    description: `List all subscriptions of subscribers for a topic.
    Checkout all available filters in the query section.`,
  })
  @ApiParam({ name: 'topicKey', description: 'The key identifier of the topic', type: String })
  @ApiResponse(ListTopicSubscriptionsResponseDto, 200)
  @RequirePermissions(PermissionsEnum.TOPIC_READ)
  async listTopicSubscriptions(
    @UserSession() user: UserSessionData,
    @Param('topicKey') topicKey: string,
    @Query() query: ListTopicSubscriptionsQueryDto
  ): Promise<ListTopicSubscriptionsResponseDto> {
    return await this.listTopicSubscriptionsUsecase.execute(
      ListTopicSubscriptionsCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        topicKey,
        subscriberId: query.subscriberId,
        limit: query.limit ? Number(query.limit) : 10,
        after: query.after,
        before: query.before,
        orderDirection: query.orderDirection === DirectionEnum.ASC ? 1 : -1,
        orderBy: query.orderBy || '_id',
        includeCursor: query.includeCursor,
      })
    );
  }

  @Post('/:topicKey/subscriptions')
  @ExternalApiAccessible()
  @SdkGroupName('Topics.Subscriptions')
  @SdkMethodName('create')
  @ApiOperation({
    summary: 'Create topic subscriptions',
    description: `This api will create subscription for subscriberIds for a topic. 
      Its like subscribing to a common interest group. if topic does not exist, it will be created.`,
  })
  @ApiParam({ name: 'topicKey', description: 'The key identifier of the topic', type: String })
  @ApiResponse(CreateTopicSubscriptionsResponseDto, 201, false, true, {
    description: 'Subscriptions created successfully',
  })
  @RequirePermissions(PermissionsEnum.TOPIC_WRITE)
  async createTopicSubscriptions(
    @UserSession() user: UserSessionData,
    @Param('topicKey') topicKey: string,
    @Body() body: CreateTopicSubscriptionsRequestDto
  ): Promise<CreateTopicSubscriptionsResponseDto> {
    const result = await this.createTopicSubscriptionsUsecase.execute(
      CreateTopicSubscriptionsCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
        topicKey,
        subscriberIds: body.subscriberIds,
      })
    );

    const typeSafeResult: CreateTopicSubscriptionsResponseDto = {
      data: result.data.map((item) => ({
        ...item,
        createdAt: item.createdAt || '',
        updatedAt: item.updatedAt || '',
      })),
      meta: result.meta,
      errors: result.errors,
    };

    if (typeSafeResult.meta.failed > 0 && typeSafeResult.meta.successful === 0) {
      // All subscriptions failed but with valid request format
      throw new HttpException(typeSafeResult, HttpStatus.BAD_REQUEST);
    }

    return typeSafeResult;
  }

  @Delete('/:topicKey/subscriptions')
  @ExternalApiAccessible()
  @SdkGroupName('Topics.Subscriptions')
  @SdkMethodName('delete')
  @ApiOperation({
    summary: 'Delete topic subscriptions',
    description: 'Delete subscriptions for subscriberIds for a topic.',
  })
  @ApiParam({ name: 'topicKey', description: 'The key identifier of the topic', type: String })
  @ApiResponse(DeleteTopicSubscriptionsResponseDto, 200, false, false, {
    description: 'Subscriptions deleted successfully',
  })
  @RequirePermissions(PermissionsEnum.TOPIC_WRITE)
  async deleteTopicSubscriptions(
    @UserSession() user: UserSessionData,
    @Param('topicKey') topicKey: string,
    @Body() body: DeleteTopicSubscriptionsRequestDto
  ): Promise<DeleteTopicSubscriptionsResponseDto> {
    const result = await this.deleteTopicSubscriptionsUsecase.execute(
      DeleteTopicSubscriptionsCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
        topicKey,
        subscriberIds: body.subscriberIds,
      })
    );

    // Ensure createdAt and updatedAt are always strings to match SubscriptionDto
    const typeSafeResult: DeleteTopicSubscriptionsResponseDto = {
      data: result.data.map((item) => ({
        ...item,
        createdAt: item.createdAt || '',
        updatedAt: item.updatedAt || '',
      })),
      meta: result.meta,
      errors: result.errors,
    };

    if (typeSafeResult.meta.failed > 0 && typeSafeResult.meta.successful === 0) {
      // All subscriptions failed but with valid request format
      throw new HttpException(typeSafeResult, HttpStatus.BAD_REQUEST);
    }

    // All subscriptions were successfully deleted
    return typeSafeResult;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - CreateTopicSubscriptionsResponseDto({
      data: result.data.map((item))
 - DeleteTopicSubscriptionsResponseDto({
      data: result.data.map((item))
Declaraciones 'export' encontradas:
- export class TopicsController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/dtos/create-topic-subscriptions-response.dto.ts
Tamaño: 4060 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IsOptional, IsString } from 'class-validator';

export class TopicDto {
  @ApiProperty({
    description: 'The internal unique identifier of the topic',
    example: '64f5e95d3d7946d80d0cb677',
  })
  @IsString()
  _id: string;

  @ApiProperty({
    description: 'The key identifier of the topic used in your application. Should be unique on the environment level.',
    example: 'product-updates',
  })
  @IsString()
  key: string;

  @ApiPropertyOptional({
    description: 'The name of the topic',
    example: 'Product Updates',
  })
  @IsString()
  @IsOptional()
  name?: string;
}

export class SubscriberDto {
  @ApiProperty({
    description: 'The unique identifier of the subscriber',
    example: '64f5e95d3d7946d80d0cb678',
  })
  @IsString()
  _id: string;

  @ApiProperty({
    description: 'The external identifier of the subscriber',
    example: 'external-subscriber-id',
  })
  @IsString()
  subscriberId: string;

  @ApiPropertyOptional({
    description: 'The avatar URL of the subscriber',
    example: 'https://example.com/avatar.png',
  })
  @IsString()
  @IsOptional()
  avatar?: string;

  @ApiPropertyOptional({
    description: 'The first name of the subscriber',
    example: 'John',
  })
  @IsString()
  @IsOptional()
  firstName?: string;

  @ApiPropertyOptional({
    description: 'The last name of the subscriber',
    example: 'Doe',
  })
  @IsString()
  @IsOptional()
  lastName?: string;

  @ApiPropertyOptional({
    description: 'The email of the subscriber',
    example: 'john.doe@example.com',
  })
  @IsString()
  @IsOptional()
  email?: string;

  @ApiPropertyOptional({
    description: 'The creation date of the subscriber',
    example: '2025-04-24T05:40:21Z',
  })
  @IsString()
  @IsOptional()
  createdAt?: string;

  @ApiPropertyOptional({
    description: 'The last update date of the subscriber',
    example: '2025-04-24T05:40:21Z',
  })
  @IsString()
  @IsOptional()
  updatedAt?: string;
}

export class SubscriptionDto {
  @ApiProperty({
    description: 'The unique identifier of the subscription',
    example: '64f5e95d3d7946d80d0cb679',
  })
  @IsString()
  _id: string;

  @ApiProperty({
    description: 'The topic information',
    type: TopicDto,
  })
  topic: TopicDto;

  @ApiProperty({
    description: 'The subscriber information',
    type: SubscriberDto,
    nullable: true,
  })
  subscriber: SubscriberDto | null;

  @ApiProperty({
    description: 'The creation date of the subscription',
    example: '2025-04-24T05:40:21Z',
  })
  createdAt: string;

  @ApiProperty({
    description: 'The last update date of the subscription',
    example: '2025-04-24T05:40:21Z',
  })
  updatedAt: string;
}

export class SubscriptionErrorDto {
  @ApiProperty({
    description: 'The subscriber ID that failed',
    example: 'invalid-subscriber-id',
  })
  subscriberId: string;

  @ApiProperty({
    description: 'The error code',
    example: 'SUBSCRIBER_NOT_FOUND',
  })
  code: string;

  @ApiProperty({
    description: 'The error message',
    example: 'Subscriber with ID invalid-subscriber-id could not be found',
  })
  message: string;
}

export class MetaDto {
  @ApiProperty({
    description: 'The total count of subscriber IDs provided',
    example: 3,
  })
  totalCount: number;

  @ApiProperty({
    description: 'The count of successfully created subscriptions',
    example: 2,
  })
  successful: number;

  @ApiProperty({
    description: 'The count of failed subscription attempts',
    example: 1,
  })
  failed: number;
}

export class CreateTopicSubscriptionsResponseDto {
  @ApiProperty({
    description: 'The list of successfully created subscriptions',
    type: [SubscriptionDto],
  })
  data: SubscriptionDto[];

  @ApiProperty({
    description: 'Metadata about the operation',
    type: MetaDto,
  })
  meta: MetaDto;

  @ApiPropertyOptional({
    description: 'The list of errors for failed subscription attempts',
    type: [SubscriptionErrorDto],
  })
  errors?: SubscriptionErrorDto[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class TopicDto
- export class SubscriberDto
- export class SubscriptionDto
- export class SubscriptionErrorDto
- export class MetaDto
- export class CreateTopicSubscriptionsResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/dtos/create-topic-subscriptions.dto.ts
Tamaño: 586 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { ArrayMaxSize, ArrayMinSize, IsArray, IsDefined } from 'class-validator';

export class CreateTopicSubscriptionsRequestDto {
  @ApiProperty({
    description: 'List of subscriber identifiers to subscribe to the topic (max: 100)',
    example: ['subscriberId1', 'subscriberId2'],
    type: [String],
  })
  @IsArray()
  @IsDefined()
  @ArrayMaxSize(100, { message: 'Cannot subscribe more than 100 subscribers at once' })
  @ArrayMinSize(1, { message: 'At least one subscriber identifier is required' })
  subscriberIds: string[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateTopicSubscriptionsRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/dtos/create-update-topic.dto.ts
Tamaño: 680 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IsNotEmpty, IsOptional, IsString, Length } from 'class-validator';

export class CreateUpdateTopicRequestDto {
  @ApiProperty({
    description:
      'The unique key identifier for the topic. The key must contain only alphanumeric characters (a-z, A-Z, 0-9), hyphens (-), underscores (_), colons (:), or be a valid email address.',
    example: 'task:12345',
  })
  @IsString()
  @IsNotEmpty()
  @Length(1, 100)
  key: string;

  @ApiPropertyOptional({
    description: 'The display name for the topic',
    example: 'Task Title',
  })
  @IsString()
  @IsOptional()
  @Length(0, 100)
  name: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateUpdateTopicRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/dtos/cursor-pagination-query.dto.ts
Tamaño: 1384 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { DirectionEnum } from '@novu/shared';
import { Transform } from 'class-transformer';
import { IsOptional, IsString, Max } from 'class-validator';

export class CursorPaginationQueryDto<T, K extends keyof T> {
  @ApiProperty({
    description: 'Cursor for pagination indicating the starting point after which to fetch results.',
    type: String,
    required: false,
  })
  @IsString()
  @IsOptional()
  after?: string;

  @ApiProperty({
    description: 'Cursor for pagination indicating the ending point before which to fetch results.',
    type: String,
    required: false,
  })
  @IsString()
  @IsOptional()
  before?: string;

  @ApiPropertyOptional({
    description: 'Limit the number of items to return (max 100)',
    type: Number,
  })
  @Transform(({ value }) => Number(value))
  @Max(100)
  @IsOptional()
  limit?: number;

  @ApiPropertyOptional({
    description: 'Direction of sorting',
    enum: DirectionEnum,
  })
  @IsOptional()
  orderDirection?: DirectionEnum;

  @ApiPropertyOptional({
    description: 'Field to order by',
    type: String,
  })
  @IsString()
  @IsOptional()
  orderBy?: K;

  @ApiPropertyOptional({
    description: 'Include cursor item in response',
    type: Boolean,
  })
  @Transform(({ value }) => value === 'true')
  @IsOptional()
  includeCursor?: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CursorPaginationQueryDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/dtos/delete-topic-response.dto.ts
Tamaño: 218 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';

export class DeleteTopicResponseDto {
  @ApiProperty({
    description: 'Indicates if the operation was acknowledged',
    example: true,
  })
  acknowledged: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DeleteTopicResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/dtos/delete-topic-subscriptions-response.dto.ts
Tamaño: 3742 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';

export class TopicDto {
  @ApiProperty({
    description: 'The unique identifier of the topic',
    example: '64f5e95d3d7946d80d0cb677',
  })
  _id: string;

  @ApiProperty({
    description: 'The key identifier of the topic',
    example: 'product-updates',
  })
  key: string;

  @ApiProperty({
    description: 'The name of the topic',
    example: 'Product Updates',
    required: false,
  })
  name?: string;
}

export class SubscriberDto {
  @ApiProperty({
    description: 'The unique identifier of the subscriber',
    example: '64f5e95d3d7946d80d0cb678',
  })
  _id: string;

  @ApiProperty({
    description: 'The external identifier of the subscriber',
    example: 'external-subscriber-id',
  })
  subscriberId: string;

  @ApiProperty({
    description: 'The avatar URL of the subscriber',
    example: 'https://example.com/avatar.png',
    required: false,
  })
  avatar?: string;

  @ApiProperty({
    description: 'The first name of the subscriber',
    example: 'John',
    required: false,
  })
  firstName?: string;

  @ApiProperty({
    description: 'The last name of the subscriber',
    example: 'Doe',
    required: false,
  })
  lastName?: string;

  @ApiProperty({
    description: 'The email of the subscriber',
    example: 'john.doe@example.com',
    required: false,
  })
  email?: string;

  @ApiProperty({
    description: 'The creation date of the subscriber',
    example: '2025-04-24T05:40:21Z',
    required: false,
  })
  createdAt?: string;

  @ApiProperty({
    description: 'The last update date of the subscriber',
    example: '2025-04-24T05:40:21Z',
    required: false,
  })
  updatedAt?: string;
}

export class SubscriptionDto {
  @ApiProperty({
    description: 'The unique identifier of the subscription',
    example: '64f5e95d3d7946d80d0cb679',
  })
  _id: string;

  @ApiProperty({
    description: 'The topic information',
    type: TopicDto,
  })
  topic: TopicDto;

  @ApiProperty({
    description: 'The subscriber information',
    type: SubscriberDto,
    nullable: true,
  })
  subscriber: SubscriberDto | null;

  @ApiProperty({
    description: 'The creation date of the subscription',
    example: '2025-04-24T05:40:21Z',
  })
  createdAt: string;

  @ApiProperty({
    description: 'The last update date of the subscription',
    example: '2025-04-24T05:40:21Z',
  })
  updatedAt: string;
}

export class SubscriptionsDeleteErrorDto {
  @ApiProperty({
    description: 'The subscriber ID that failed',
    example: 'invalid-subscriber-id',
  })
  subscriberId: string;

  @ApiProperty({
    description: 'The error code',
    example: 'SUBSCRIBER_NOT_FOUND',
  })
  code: string;

  @ApiProperty({
    description: 'The error message',
    example: 'Subscriber with ID invalid-subscriber-id could not be found',
  })
  message: string;
}

export class MetaDto {
  @ApiProperty({
    description: 'The total count of subscriber IDs provided',
    example: 3,
  })
  totalCount: number;

  @ApiProperty({
    description: 'The count of successfully deleted subscriptions',
    example: 2,
  })
  successful: number;

  @ApiProperty({
    description: 'The count of failed deletion attempts',
    example: 1,
  })
  failed: number;
}

export class DeleteTopicSubscriptionsResponseDto {
  @ApiProperty({
    description: 'The list of successfully deleted subscriptions',
    type: [SubscriptionDto],
  })
  data: SubscriptionDto[];

  @ApiProperty({
    description: 'Metadata about the operation',
    type: MetaDto,
  })
  meta: MetaDto;

  @ApiProperty({
    description: 'The list of errors for failed deletion attempts',
    type: [SubscriptionsDeleteErrorDto],
    required: false,
  })
  errors?: SubscriptionsDeleteErrorDto[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class TopicDto
- export class SubscriberDto
- export class SubscriptionDto
- export class SubscriptionsDeleteErrorDto
- export class MetaDto
- export class DeleteTopicSubscriptionsResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/dtos/delete-topic-subscriptions.dto.ts
Tamaño: 592 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { ArrayMaxSize, ArrayMinSize, IsArray, IsDefined } from 'class-validator';

export class DeleteTopicSubscriptionsRequestDto {
  @ApiProperty({
    description: 'List of subscriber identifiers to unsubscribe from the topic (max: 100)',
    example: ['subscriberId1', 'subscriberId2'],
    type: [String],
  })
  @IsArray()
  @IsDefined()
  @ArrayMaxSize(100, { message: 'Cannot unsubscribe more than 100 subscribers at once' })
  @ArrayMinSize(1, { message: 'At least one subscriber identifier is required' })
  subscriberIds: string[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DeleteTopicSubscriptionsRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/dtos/list-subscriber-subscriptions-query.dto.ts
Tamaño: 530 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IsOptional, IsString } from 'class-validator';
import { CursorPaginationQueryDto } from './cursor-pagination-query.dto';
import { TopicSubscriptionResponseDto } from './topic-subscription-response.dto';

export class ListSubscriberSubscriptionsQueryDto extends CursorPaginationQueryDto<TopicSubscriptionResponseDto, '_id'> {
  @ApiProperty({
    description: 'Filter by topic key',
    type: String,
    required: false,
  })
  @IsOptional()
  @IsString()
  key?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ListSubscriberSubscriptionsQueryDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/dtos/list-topic-subscriptions-query.dto.ts
Tamaño: 538 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IsOptional, IsString } from 'class-validator';
import { CursorPaginationQueryDto } from './cursor-pagination-query.dto';
import { TopicSubscriptionResponseDto } from './topic-subscription-response.dto';

export class ListTopicSubscriptionsQueryDto extends CursorPaginationQueryDto<TopicSubscriptionResponseDto, '_id'> {
  @ApiProperty({
    description: 'Filter by subscriber ID',
    type: String,
    required: false,
  })
  @IsOptional()
  @IsString()
  subscriberId?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ListTopicSubscriptionsQueryDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/dtos/list-topic-subscriptions-response.dto.ts
Tamaño: 336 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { withCursorPagination } from '../../shared/dtos/cursor-paginated-response';
import { TopicSubscriptionResponseDto } from './topic-subscription-response.dto';

export class ListTopicSubscriptionsResponseDto extends withCursorPagination(TopicSubscriptionResponseDto, {
  description: 'List of returned Topic Subscriptions',
}) {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ListTopicSubscriptionsResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/dtos/list-topics-query.dto.ts
Tamaño: 686 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IsOptional, IsString } from 'class-validator';
import { CursorPaginationQueryDto } from './cursor-pagination-query.dto';
import { TopicResponseDto } from './topic-response.dto';

export class ListTopicsQueryDto extends CursorPaginationQueryDto<TopicResponseDto, 'createdAt' | 'updatedAt' | '_id'> {
  @ApiProperty({
    description: 'Key of the topic to filter results.',
    type: String,
    required: false,
  })
  @IsOptional()
  @IsString()
  key?: string;

  @ApiProperty({
    description: 'Name of the topic to filter results.',
    type: String,
    required: false,
  })
  @IsOptional()
  @IsString()
  name?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ListTopicsQueryDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/dtos/list-topics-response.dto.ts
Tamaño: 274 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { withCursorPagination } from '../../shared/dtos/cursor-paginated-response';
import { TopicResponseDto } from './topic-response.dto';

export class ListTopicsResponseDto extends withCursorPagination(TopicResponseDto, {
  description: 'List of returned Topics',
}) {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ListTopicsResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/dtos/topic-response.dto.ts
Tamaño: 1028 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IsOptional, IsString } from 'class-validator';

export class TopicResponseDto {
  @ApiProperty({
    description: 'The identifier of the topic',
    type: String,
    example: '64da692e9a94fb2e6449ad06',
  })
  @IsString()
  _id: string;

  @ApiProperty({
    description: 'The unique key of the topic',
    type: String,
    example: 'product-updates',
  })
  @IsString()
  key: string;

  @ApiPropertyOptional({
    description: 'The name of the topic',
    type: String,
    example: 'Product Updates',
  })
  @IsString()
  @IsOptional()
  name?: string;

  @ApiPropertyOptional({
    description: 'The date the topic was created',
    type: String,
    example: '2023-08-15T00:00:00.000Z',
  })
  @IsString()
  @IsOptional()
  createdAt?: string;

  @ApiPropertyOptional({
    description: 'The date the topic was last updated',
    type: String,
    example: '2023-08-15T00:00:00.000Z',
  })
  @IsString()
  @IsOptional()
  updatedAt?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class TopicResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/dtos/topic-subscription-response.dto.ts
Tamaño: 1548 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { TopicResponseDto } from './topic-response.dto';

export class SubscriberDto {
  @ApiProperty({
    description: 'The identifier of the subscriber',
    example: '64da692e9a94fb2e6449ad07',
  })
  _id: string;

  @ApiProperty({
    description: 'The external identifier of the subscriber',
    example: 'user-123',
  })
  subscriberId: string;

  @ApiProperty({
    description: 'The avatar URL of the subscriber',
    example: 'https://example.com/avatar.png',
    nullable: true,
  })
  avatar?: string;

  @ApiProperty({
    description: 'The first name of the subscriber',
    example: 'John',
    nullable: true,
  })
  firstName?: string;

  @ApiProperty({
    description: 'The last name of the subscriber',
    example: 'Doe',
    nullable: true,
  })
  lastName?: string;

  @ApiProperty({
    description: 'The email of the subscriber',
    example: 'john@example.com',
    nullable: true,
  })
  email?: string;
}

export class TopicSubscriptionResponseDto {
  @ApiProperty({
    description: 'The identifier of the subscription',
    example: '64da692e9a94fb2e6449ad08',
  })
  _id: string;

  @ApiProperty({
    description: 'The date and time the subscription was created',
    example: '2021-01-01T00:00:00.000Z',
  })
  createdAt: string;

  @ApiProperty({
    description: 'Topic information',
    type: TopicResponseDto,
  })
  topic: TopicResponseDto;

  @ApiProperty({
    description: 'Subscriber information',
    type: SubscriberDto,
  })
  subscriber: SubscriberDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SubscriberDto
- export class TopicSubscriptionResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/dtos/update-topic.dto.ts
Tamaño: 297 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsString } from 'class-validator';

export class UpdateTopicRequestDto {
  @ApiProperty({
    description: 'The display name for the topic',
    example: 'Updated Topic Name',
  })
  @IsString()
  @IsNotEmpty()
  name: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateTopicRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/e2e/create-topic-subscriptions.e2e.ts
Tamaño: 7820 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { SubscriberEntity, TopicRepository, TopicSubscribersRepository } from '@novu/dal';
import { SubscribersService, UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Create topic subscriptions - /v2/topics/:topicKey/subscriptions (POST) #novu-v2', async () => {
  let session: UserSession;
  let novuClient: Novu;
  let subscriber1: SubscriberEntity;
  let subscriber2: SubscriberEntity;
  let subscriber3: SubscriberEntity;
  let topicSubscribersRepository: TopicSubscribersRepository;
  let topicRepository: TopicRepository;

  before(async () => {
    session = new UserSession();
    await session.initialize();
    novuClient = initNovuClassSdk(session);
    topicSubscribersRepository = new TopicSubscribersRepository();
    topicRepository = new TopicRepository();

    // Create subscribers
    const subscribersService = new SubscribersService(session.organization._id, session.environment._id);
    subscriber1 = await subscribersService.createSubscriber();
    subscriber2 = await subscribersService.createSubscriber();
    subscriber3 = await subscribersService.createSubscriber();
  });

  it('should create subscriptions for subscribers to an existing topic', async () => {
    const topicKey = `topic-key-${Date.now()}`;

    // Create a topic first
    const createResponse = await novuClient.topics.create({
      key: topicKey,
      name: 'Test Topic',
    });
    const topicId = createResponse.result.id;

    // Add subscribers to topic
    const response = await novuClient.topics.subscriptions.create(
      {
        subscriberIds: [subscriber1.subscriberId, subscriber2.subscriberId],
      },
      topicKey
    );

    expect(response).to.exist;
    expect(response.result.data.length).to.equal(2);
    expect(response.result.meta.successful).to.equal(2);
    expect(response.result.meta.failed).to.equal(0);

    // Verify subscribers were added to the topic
    const subscribers = await topicSubscribersRepository.findSubscribersByTopicId(
      session.environment._id,
      session.organization._id,
      topicId
    );
    expect(subscribers.length).to.equal(2);

    // Verify the structure of the response data
    response.result.data.forEach((subscription) => {
      expect(subscription).to.have.property('id');
      expect(subscription).to.have.property('topic');
      expect(subscription).to.have.property('subscriber');
      expect(subscription.topic.id).to.equal(topicId);
      expect(subscription.topic.key).to.equal(topicKey);
      expect([subscriber1.subscriberId, subscriber2.subscriberId]).to.include(
        subscription.subscriber?.subscriberId as string
      );
    });
  });

  it('should automatically create a topic when subscribing to a non-existing topic', async () => {
    const nonExistingTopicKey = `non-existing-topic-${Date.now()}`;

    // Try to get the topic - should not exist
    try {
      await novuClient.topics.get(nonExistingTopicKey);
      throw new Error('Topic should not exist');
    } catch (error) {
      expect(error.statusCode).to.equal(404);
    }

    // Add subscribers to non-existing topic
    const response = await novuClient.topics.subscriptions.create(
      {
        subscriberIds: [subscriber3.subscriberId],
      },
      nonExistingTopicKey
    );

    expect(response).to.exist;
    expect(response.result.data.length).to.equal(1);
    expect(response.result.meta.successful).to.equal(1);
    expect(response.result.meta.failed).to.equal(0);

    // Verify topic was created
    const topic = await novuClient.topics.get(nonExistingTopicKey);
    expect(topic).to.exist;
    expect(topic.result.key).to.equal(nonExistingTopicKey);

    // Verify subscriber was added to the topic
    const subscribers = await topicSubscribersRepository.findSubscribersByTopicId(
      session.environment._id,
      session.organization._id,
      topic.result.id
    );
    expect(subscribers.length).to.equal(1);
    expect(subscribers[0]?._subscriberId).to.equal(subscriber3._id);
  });

  it('should handle removal of subscribers from a topic', async () => {
    const topicKey = `topic-key-removal-${Date.now()}`;

    // Create a topic
    const createResponse = await novuClient.topics.create({
      key: topicKey,
      name: 'Test Topic for Removal',
    });
    const topicId = createResponse.result.id;

    // Add subscribers to topic
    await novuClient.topics.subscriptions.create(
      {
        subscriberIds: [subscriber1.subscriberId, subscriber2.subscriberId],
      },
      topicKey
    );

    // Verify subscribers were added
    let subscribers = await topicSubscribersRepository.findSubscribersByTopicId(
      session.environment._id,
      session.organization._id,
      topicId
    );
    expect(subscribers.length).to.equal(2);

    // Remove one subscriber
    const deleteResponse = await novuClient.topics.subscriptions.delete(
      {
        subscriberIds: [subscriber1.subscriberId],
      },
      topicKey
    );

    expect(deleteResponse).to.exist;
    expect(deleteResponse.result.data.length).to.equal(1);
    expect(deleteResponse.result.meta.successful).to.equal(1);
    expect(deleteResponse.result.meta.failed).to.equal(0);

    // Verify subscriber was removed
    subscribers = await topicSubscribersRepository.findSubscribersByTopicId(
      session.environment._id,
      session.organization._id,
      topicId
    );
    expect(subscribers.length).to.equal(1);
    expect(subscribers[0]?._subscriberId).to.equal(subscriber2._id);
  });

  it('should handle partial success when some subscribers do not exist', async () => {
    const topicKey = `topic-key-partial-${Date.now()}`;

    // Create a topic
    await novuClient.topics.create({
      key: topicKey,
      name: 'Test Topic for Partial Success',
    });

    // Add existing and non-existing subscribers
    const nonExistingSubscriberId = 'non-existing-subscriber-id';
    const response = await novuClient.topics.subscriptions.create(
      {
        subscriberIds: [subscriber1.subscriberId, nonExistingSubscriberId],
      },
      topicKey
    );

    // Verify partial success response
    expect(response).to.exist;
    expect(response.result.meta.successful).to.equal(1);
    expect(response.result.meta.failed).to.equal(1);
    expect(response.result.errors?.length).to.equal(1);
    expect(response.result.errors?.[0]?.subscriberId).to.equal(nonExistingSubscriberId);
  });

  it('should handle adding the same subscriber multiple times', async () => {
    const topicKey = `topic-key-duplicate-${Date.now()}`;

    // Create a topic
    const createResponse = await novuClient.topics.create({
      key: topicKey,
      name: 'Test Topic for Duplicates',
    });
    const topicId = createResponse.result.id;

    // Add a subscriber
    await novuClient.topics.subscriptions.create(
      {
        subscriberIds: [subscriber1.subscriberId],
      },
      topicKey
    );

    // Add the same subscriber again
    const response = await novuClient.topics.subscriptions.create(
      {
        subscriberIds: [subscriber1.subscriberId],
      },
      topicKey
    );

    // Should still be successful (idempotent operation)
    expect(response).to.exist;
    expect(response.result.data.length).to.equal(1);
    expect(response.result.meta.successful).to.equal(1);
    expect(response.result.meta.failed).to.equal(0);

    // Verify only one subscription exists
    const subscribers = await topicSubscribersRepository.findSubscribersByTopicId(
      session.environment._id,
      session.organization._id,
      topicId
    );
    expect(subscribers.length).to.equal(1);
    expect(subscribers[0]?._subscriberId).to.equal(subscriber1._id);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - subscriber3(await subscribersService.createSubscriber();
  });

  it('should create subscriptions for subscriber...)
 - subscribers(await topicSubscribersRepository.findSubscribersByTopicId(
      session.environment._id,
      sess...)
 - subscribers(await topicSubscribersRepository.findSubscribersByTopicId(
      session.environment._id,
      sess...)
 - subscribers(await topicSubscribersRepository.findSubscribersByTopicId(
      session.environment._id,
      sess...)
 - response(await novuClient.topics.subscriptions.create(
      {
        subscriberIds: [subscriber1.subscriber...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/e2e/delete-topic-subscriptions.e2e.ts
Tamaño: 6312 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { SubscriberEntity, TopicSubscribersRepository } from '@novu/dal';
import { SubscribersService, UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Delete topic subscriptions - /v2/topics/:topicKey/subscriptions (DELETE) #novu-v2', async () => {
  let session: UserSession;
  let novuClient: Novu;
  let subscriber1: SubscriberEntity;
  let subscriber2: SubscriberEntity;
  let subscriber3: SubscriberEntity;
  let topicSubscribersRepository: TopicSubscribersRepository;

  before(async () => {
    session = new UserSession();
    await session.initialize();
    novuClient = initNovuClassSdk(session);
    topicSubscribersRepository = new TopicSubscribersRepository();

    // Create subscribers
    const subscribersService = new SubscribersService(session.organization._id, session.environment._id);
    subscriber1 = await subscribersService.createSubscriber();
    subscriber2 = await subscribersService.createSubscriber();
    subscriber3 = await subscribersService.createSubscriber();
  });

  it('should delete a single subscription from a topic', async () => {
    const topicKey = `topic-key-${Date.now()}`;

    // Create a topic
    const createResponse = await novuClient.topics.create({
      key: topicKey,
      name: 'Test Topic for Single Deletion',
    });
    const topicId = createResponse.result.id;

    // Add multiple subscribers to topic
    await novuClient.topics.subscriptions.create(
      {
        subscriberIds: [subscriber1.subscriberId, subscriber2.subscriberId],
      },
      topicKey
    );

    // Verify subscribers were added
    let subscribers = await topicSubscribersRepository.findSubscribersByTopicId(
      session.environment._id,
      session.organization._id,
      topicId
    );
    expect(subscribers.length).to.equal(2);

    // Delete one subscriber
    const deleteResponse = await novuClient.topics.subscriptions.delete(
      {
        subscriberIds: [subscriber1.subscriberId],
      },
      topicKey
    );

    expect(deleteResponse).to.exist;
    expect(deleteResponse.result.data.length).to.equal(1);
    expect(deleteResponse.result.meta.successful).to.equal(1);
    expect(deleteResponse.result.meta.failed).to.equal(0);

    // Verify the subscription was removed
    subscribers = await topicSubscribersRepository.findSubscribersByTopicId(
      session.environment._id,
      session.organization._id,
      topicId
    );
    expect(subscribers.length).to.equal(1);
    expect(subscribers[0]?._subscriberId).to.equal(subscriber2._id);
  });

  it('should delete multiple subscriptions from a topic', async () => {
    const topicKey = `topic-key-multiple-${Date.now()}`;

    // Create a topic
    const createResponse = await novuClient.topics.create({
      key: topicKey,
      name: 'Test Topic for Multiple Deletion',
    });
    const topicId = createResponse.result.id;

    // Add multiple subscribers to topic
    await novuClient.topics.subscriptions.create(
      {
        subscriberIds: [subscriber1.subscriberId, subscriber2.subscriberId, subscriber3.subscriberId],
      },
      topicKey
    );

    // Verify subscribers were added
    let subscribers = await topicSubscribersRepository.findSubscribersByTopicId(
      session.environment._id,
      session.organization._id,
      topicId
    );
    expect(subscribers.length).to.equal(3);

    // Delete multiple subscribers
    const deleteResponse = await novuClient.topics.subscriptions.delete(
      {
        subscriberIds: [subscriber1.subscriberId, subscriber2.subscriberId],
      },
      topicKey
    );

    expect(deleteResponse).to.exist;
    expect(deleteResponse.result.data.length).to.equal(2);
    expect(deleteResponse.result.meta.successful).to.equal(2);
    expect(deleteResponse.result.meta.failed).to.equal(0);

    // Verify the subscriptions were removed
    subscribers = await topicSubscribersRepository.findSubscribersByTopicId(
      session.environment._id,
      session.organization._id,
      topicId
    );
    expect(subscribers.length).to.equal(1);
    expect(subscribers[0]?._subscriberId).to.equal(subscriber3._id);
  });

  it('should handle partial success when deleting subscriptions', async () => {
    const topicKey = `topic-key-partial-${Date.now()}`;

    // Create a topic
    const createResponse = await novuClient.topics.create({
      key: topicKey,
      name: 'Test Topic for Partial Success',
    });
    const topicId = createResponse.result.id;

    // Add one subscriber to topic
    await novuClient.topics.subscriptions.create(
      {
        subscriberIds: [subscriber1.subscriberId],
      },
      topicKey
    );

    // Try to delete one existing and one non-existing subscriber
    const nonExistingSubscriberId = 'non-existing-subscriber-id';
    const deleteResponse = await novuClient.topics.subscriptions.delete(
      {
        subscriberIds: [subscriber1.subscriberId, nonExistingSubscriberId],
      },
      topicKey
    );

    // Should return partial success
    expect(deleteResponse).to.exist;
    expect(deleteResponse.result.data.length).to.equal(1);
    expect(deleteResponse.result.meta.successful).to.equal(1);
    expect(deleteResponse.result.meta.failed).to.equal(1);
    expect(deleteResponse.result.errors?.length).to.equal(1);
    expect(deleteResponse.result.errors?.[0]?.subscriberId).to.equal(nonExistingSubscriberId);

    // Verify the subscription was removed
    const subscribers = await topicSubscribersRepository.findSubscribersByTopicId(
      session.environment._id,
      session.organization._id,
      topicId
    );
    expect(subscribers.length).to.equal(0);
  });

  it('should handle deleting from a non-existent topic', async () => {
    const nonExistentTopicKey = `non-existent-topic-${Date.now()}`;

    try {
      await novuClient.topics.subscriptions.delete(
        {
          subscriberIds: [subscriber1.subscriberId],
        },
        nonExistentTopicKey
      );
      throw new Error('Should have failed to delete subscriptions from non-existent topic');
    } catch (error) {
      expect(error.statusCode).to.equal(404);
      expect(error.message).to.include(nonExistentTopicKey);
    }
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - subscriber3(await subscribersService.createSubscriber();
  });

  it('should delete a single subscription from a...)
 - subscribers(await topicSubscribersRepository.findSubscribersByTopicId(
      session.environment._id,
      sess...)
 - subscribers(await topicSubscribersRepository.findSubscribersByTopicId(
      session.environment._id,
      sess...)
 - subscribers(await topicSubscribersRepository.findSubscribersByTopicId(
      session.environment._id,
      sess...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/e2e/delete-topic.e2e.ts
Tamaño: 3356 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { SubscriberEntity, TopicSubscribersRepository } from '@novu/dal';
import { SubscribersService, UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Delete topic by key - /v2/topics/:topicKey (DELETE) #novu-v2', async () => {
  let session: UserSession;
  let novuClient: Novu;
  let subscriber: SubscriberEntity;
  let topicSubscribersRepository: TopicSubscribersRepository;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    novuClient = initNovuClassSdk(session);
    topicSubscribersRepository = new TopicSubscribersRepository();
  });

  it('should delete a topic with no subscribers', async () => {
    const topicKey = `topic-key-${Date.now()}`;

    await novuClient.topics.create({
      key: topicKey,
      name: 'Test Topic',
    });

    // Verify topic exists
    const getTopic = await novuClient.topics.get(topicKey);

    expect(getTopic).to.exist;

    // Delete the topic
    const response = await novuClient.topics.delete(topicKey);
    expect(response).to.exist;
    expect(response.result.acknowledged).to.equal(true);

    // Verify topic no longer exists
    try {
      await novuClient.topics.get(topicKey);
      throw new Error('Topic should not exist');
    } catch (error) {
      expect(error.statusCode).to.equal(404);
    }
  });

  it('should delete a topic with subscribers', async () => {
    // Create a subscriber
    const subscribersService = new SubscribersService(session.organization._id, session.environment._id);
    subscriber = await subscribersService.createSubscriber();

    // Create a topic
    const topicKey = `topic-key-${Date.now()}`;
    const createResponse = await novuClient.topics.create({
      key: topicKey,
      name: 'Test Topic with Subscribers',
    });
    const topicId = createResponse.result.id;

    // Add subscriber to topic
    await novuClient.topics.subscriptions.create(
      {
        subscriberIds: [subscriber.subscriberId],
      },
      topicKey
    );

    // Verify subscriber is added to topic
    const subscribers = await topicSubscribersRepository.findSubscribersByTopicId(
      session.environment._id,
      session.organization._id,
      topicId
    );
    expect(subscribers.length).to.be.greaterThan(0);

    await novuClient.topics.delete(topicKey);

    // Verify topic no longer exists
    try {
      await novuClient.topics.get(topicKey);
      throw new Error('Topic should not exist');
    } catch (error) {
      expect(error.statusCode).to.equal(404);
    }

    // Verify subscriptions have been removed
    const subscribersAfterDelete = await topicSubscribersRepository.findSubscribersByTopicId(
      session.environment._id,
      session.organization._id,
      topicId
    );
    expect(subscribersAfterDelete.length).to.equal(0);
  });

  it('should return 404 for deleting a non-existent topic key', async () => {
    const nonExistentKey = 'non-existent-topic-key';
    try {
      await novuClient.topics.delete(nonExistentKey);
      throw new Error('Should have failed to delete non-existent topic');
    } catch (error) {
      expect(error.statusCode).to.equal(404);
      expect(error.message).to.include(nonExistentKey);
    }
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - topicSubscribersRepository(new TopicSubscribersRepository();
  });

  it('should delete a topic with no subscribers', async ())
 - response(await novuClient.topics.delete(topicKey);
    expect(response).to.exist;
    expect(response.result....)
 - subscribersAfterDelete(await topicSubscribersRepository.findSubscribersByTopicId(
      session.environment._id,
      sess...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/e2e/get-topic.e2e.ts
Tamaño: 1505 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Get topic by key - /v2/topics/:topicKey (GET) #novu-v2', async () => {
  let session: UserSession;
  let novuClient: Novu;
  const topicKey = `topic-key-${Date.now()}`;
  const topicName = 'Test Topic Name';

  before(async () => {
    session = new UserSession();
    await session.initialize();
    novuClient = initNovuClassSdk(session);

    // Create a topic to retrieve later
    await novuClient.topics.create({
      key: topicKey,
      name: topicName,
    });
  });

  it('should retrieve a topic by its key', async () => {
    const response = await novuClient.topics.get(topicKey);

    expect(response).to.exist;
    expect(response.result).to.have.property('id');
    expect(response.result.key).to.equal(topicKey);
    expect(response.result.name).to.equal(topicName);
    expect(response.result).to.have.property('createdAt');
    expect(response.result).to.have.property('updatedAt');
  });

  it('should return 404 for a non-existent topic key', async () => {
    const nonExistentKey = 'non-existent-topic-key';
    try {
      await novuClient.topics.get(nonExistentKey);
      throw new Error('Should have failed to get non-existent topic');
    } catch (error) {
      expect(error.statusCode).to.equal(404);
      expect(error.message).to.include(nonExistentKey);
    }
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - topicName('Test Topic Name';

  before(async ())
 - novuClient(initNovuClassSdk(session);

    // Create a topic to retrieve later
    await novuClient.topics.crea...)
 - response(await novuClient.topics.get(topicKey);

    expect(response).to.exist;
    expect(response.result).t...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/e2e/list-topic-subscriptions.e2e.ts
Tamaño: 4184 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { SubscriberEntity } from '@novu/dal';
import { SubscribersService, UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('List topic subscriptions - /v2/topics/:topicKey/subscriptions (GET) #novu-v2', async () => {
  let session: UserSession;
  let novuClient: Novu;
  let subscriber1: SubscriberEntity;
  let subscriber2: SubscriberEntity;
  let subscriber3: SubscriberEntity;
  const topicKey = `topic-key-${Date.now()}`;
  let topicId: string;

  before(async () => {
    session = new UserSession();
    await session.initialize();
    novuClient = initNovuClassSdk(session);

    // Create subscribers
    const subscribersService = new SubscribersService(session.organization._id, session.environment._id);
    subscriber1 = await subscribersService.createSubscriber();
    subscriber2 = await subscribersService.createSubscriber();
    subscriber3 = await subscribersService.createSubscriber();

    // Create a topic
    const createResponse = await novuClient.topics.create({
      key: topicKey,
      name: 'Test Topic',
    });
    topicId = createResponse.result.id;

    // Add subscribers to topic
    await novuClient.topics.subscriptions.create(
      {
        subscriberIds: [subscriber1.subscriberId, subscriber2.subscriberId, subscriber3.subscriberId],
      },
      topicKey
    );
  });

  it('should list topic subscriptions with pagination', async () => {
    const response = await novuClient.topics.subscriptions.list({
      topicKey,
      limit: 2,
    });

    expect(response).to.exist;
    expect(response.result.data.length).to.equal(2);
    expect(response.result.next).to.be.a('string');
    expect(response.result.previous).to.be.null;

    // Check response structure for each subscription
    response.result.data.forEach((subscription) => {
      expect(subscription).to.have.property('id');
      expect(subscription).to.have.property('topic');
      expect(subscription).to.have.property('subscriber');
      expect(subscription.topic.id).to.equal(topicId);
      expect(subscription.topic.key).to.equal(topicKey);
    });

    // Get next page
    const nextResponse = await novuClient.topics.subscriptions.list({
      topicKey,
      limit: 2,
      after: response.result.next as string,
    });

    expect(nextResponse).to.exist;
    // We have 3 subscribers total, with 2 per page, so the second page has 1 subscriber
    const expectedSubscribersInSecondPage = 1;
    expect(nextResponse.result.data.length).to.equal(expectedSubscribersInSecondPage);
    expect(nextResponse.result.next).to.be.null;
    expect(nextResponse.result.previous).to.be.a('string');
  });

  it('should filter subscriptions by subscriberId', async () => {
    const response = await novuClient.topics.subscriptions.list({
      topicKey,
      subscriberId: subscriber1.subscriberId,
    });

    expect(response).to.exist;
    expect(response.result.data.length).to.equal(1);
    expect(response.result.data[0].subscriber.subscriberId).to.equal(subscriber1.subscriberId);
  });

  it('should return 404 for non-existent topic', async () => {
    const nonExistentKey = 'non-existent-topic-key';
    try {
      await novuClient.topics.subscriptions.list({
        topicKey: nonExistentKey,
      });
      throw new Error('Should have failed to list subscriptions for non-existent topic');
    } catch (error) {
      expect(error.statusCode).to.equal(404);
      expect(error.message).to.include(nonExistentKey);
    }
  });

  it('should return empty array for topic with no subscriptions', async () => {
    // Create a topic with no subscribers
    const emptyTopicKey = `empty-topic-${Date.now()}`;
    await novuClient.topics.create({
      key: emptyTopicKey,
      name: 'Empty Topic',
    });

    const response = await novuClient.topics.subscriptions.list({
      topicKey: emptyTopicKey,
    });

    expect(response).to.exist;
    expect(response.result.data).to.be.an('array').that.is.empty;
    expect(response.result.next).to.be.null;
    expect(response.result.previous).to.be.null;
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - topicKey(`topic-key-${Date.now()}`;
  let topicId: string;

  before(async ())
 - topicId(createResponse.result.id;

    // Add subscribers to topic
    await novuClient.topics.subscriptions...)
 - response(await novuClient.topics.subscriptions.list({
      topicKey,
      limit: 2,
    });

    expect(res...)
 - expectedSubscribersInSecondPage(1;
    expect(nextResponse.result.data.length).to.equal(expectedSubscribersInSecondPage);
    expect...)
 - response(await novuClient.topics.subscriptions.list({
      topicKey,
      subscriberId: subscriber1.subscri...)
 - nonExistentKey('non-existent-topic-key';
    try {
      await novuClient.topics.subscriptions.list({
        topic...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/e2e/list-topics.e2e.ts
Tamaño: 4431 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { SubscriberEntity } from '@novu/dal';
import { ExternalSubscriberId, TopicKey } from '@novu/shared';
import { SubscribersService, UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('List topics - /v2/topics (GET) #novu-v2', async () => {
  let session: UserSession;
  let novuClient: Novu;
  let firstSubscriber: SubscriberEntity;
  let secondSubscriber: SubscriberEntity;

  before(async () => {
    session = new UserSession();
    await session.initialize();

    // Create multiple topics for testing pagination
    await createNewTopic(session, 'topic-key-1');
    await createNewTopic(session, 'topic-key-2');
    await createNewTopic(session, 'topic-key-3');
    await createNewTopic(session, 'topic-key-4');
    await createNewTopic(session, 'topic-key-5');

    // Add subscribers to one of the topics
    const subscribersService = new SubscribersService(session.organization._id, session.environment._id);
    firstSubscriber = await subscribersService.createSubscriber();
    secondSubscriber = await subscribersService.createSubscriber();

    const topicKey = 'topic-key-2';
    const subscribers = [firstSubscriber.subscriberId, secondSubscriber.subscriberId];
    await addSubscribersToTopic(session, topicKey, subscribers);

    novuClient = initNovuClassSdk(session);
  });

  it('should retrieve all topics with cursor pagination', async () => {
    const response = await novuClient.topics.list({
      limit: 3,
    });

    expect(response).to.exist;
    expect(response.result.data.length).to.equal(3);
    expect(response.result.next).to.be.a('string');
    expect(response.result.previous).to.be.null;

    // Get the next page using the cursor
    const nextResponse = await novuClient.topics.list({
      limit: 3,
      after: response.result.next as string,
    });

    expect(nextResponse).to.exist;
    expect(nextResponse.result.data.length).to.equal(2);
    expect(nextResponse.result.next).to.be.null;
    expect(nextResponse.result.previous).to.be.a('string');

    // Ensure we have 5 unique topics between the two pages
    const allTopics = [...response.result.data, ...nextResponse.result.data];
    const uniqueTopicIds = new Set(allTopics.map((topic) => topic.id));
    expect(uniqueTopicIds.size).to.equal(5);
  });

  it('should filter topics by key', async () => {
    const response = await novuClient.topics.list({
      key: 'topic-key-2',
    });

    expect(response).to.exist;
    expect(response.result.data.length).to.equal(1);
    expect(response.result.data[0].key).to.equal('topic-key-2');
  });

  it('should filter topics by name', async () => {
    const response = await novuClient.topics.list({
      name: 'topic-key-3-name',
    });

    expect(response).to.exist;
    expect(response.result.data.length).to.equal(1);
    expect(response.result.data[0].name).to.equal('topic-key-3-name');
  });

  it('should order topics by specified field', async () => {
    const response = await novuClient.topics.list({
      orderBy: 'key',
      orderDirection: 'ASC',
    });

    expect(response).to.exist;

    const keys = response.result.data.map((topic) => topic.key);
    const sortedKeys = [...keys].sort();

    expect(keys).to.deep.equal(sortedKeys);
  });

  it('should include topic fields: id, name, key, createdAt, updatedAt', async () => {
    const response = await novuClient.topics.list({
      limit: 1,
    });

    expect(response).to.exist;
    expect(response.result.data.length).to.equal(1);

    const topic = response.result.data[0];
    expect(topic).to.have.property('id');
    expect(topic).to.have.property('name');
    expect(topic).to.have.property('key');
    expect(topic).to.have.property('createdAt');
    expect(topic).to.have.property('updatedAt');
  });
});

const createNewTopic = async (session: UserSession, topicKey: string) => {
  const result = await initNovuClassSdk(session).topics.create({
    key: topicKey,
    name: `${topicKey}-name`,
  });

  return result.result;
};

const addSubscribersToTopic = async (session: UserSession, topicKey: TopicKey, subscribers: ExternalSubscriberId[]) => {
  const result = await initNovuClassSdk(session).topics.subscriptions.create(
    {
      subscriberIds: subscribers,
    },
    topicKey
  );

  expect(result.result.data).to.be.ok;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - novuClient(initNovuClassSdk(session);
  });

  it('should retrieve all topics with cursor pagination', async ())
 - uniqueTopicIds(new Set(allTopics.map((topic))
 - response(await novuClient.topics.list({
      key: 'topic-key-2',
    });

    expect(response).to.exist;
   ...)
 - response(await novuClient.topics.list({
      name: 'topic-key-3-name',
    });

    expect(response).to.exis...)
 - keys(response.result.data.map((topic))
 - sortedKeys([...keys].sort();

    expect(keys).to.deep.equal(sortedKeys);
  });

  it('should include topic fie...)
 - createNewTopic(async (session: UserSession, topicKey: string))
 - addSubscribersToTopic(async (session: UserSession, topicKey: TopicKey, subscribers: ExternalSubscriberId[]))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/e2e/update-topic.e2e.ts
Tamaño: 2146 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Update topic by key - /v2/topics/:topicKey (PATCH) #novu-v2', async () => {
  let session: UserSession;
  let novuClient: Novu;
  const topicKey = `topic-key-${Date.now()}`;
  const initialName = 'Initial Topic Name';
  let topicId: string;

  before(async () => {
    session = new UserSession();
    await session.initialize();
    novuClient = initNovuClassSdk(session);

    // Create a topic to update later
    const createResponse = await novuClient.topics.create({
      key: topicKey,
      name: initialName,
    });
    topicId = createResponse.result.id;
  });

  it('should update a topic by its key', async () => {
    const updatedName = 'Updated Topic Name';
    const response = await novuClient.topics.update(
      {
        name: updatedName,
      },
      topicKey
    );

    expect(response.result).to.exist;
    expect(response.result.id).to.equal(topicId);
    expect(response.result.key).to.equal(topicKey);
    expect(response.result.name).to.equal(updatedName);
    expect(response.result).to.have.property('createdAt');
    expect(response.result).to.have.property('updatedAt');

    // Verify the update persisted by fetching the topic
    const getResponse = await novuClient.topics.get(topicKey);
    expect(getResponse.result).to.exist;
    expect(getResponse.result.name).to.equal(updatedName);
  });

  it('should return 404 for updating a non-existent topic key', async () => {
    const nonExistentKey = 'non-existent-topic-key';
    try {
      await novuClient.topics.update(
        {
          name: 'New Name',
        },
        nonExistentKey
      );

      /* If we reach here, the test failed */
      expect.fail('Should have thrown an error for non-existent topic');
    } catch (error) {
      expect(error.statusCode).to.equal(404);

      const message = error.response?.data?.message || error.message || error.data?.message;
      expect(message).to.include(nonExistentKey);
    }
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - initialName('Initial Topic Name';
  let topicId: string;

  before(async ())
 - topicId(createResponse.result.id;
  });

  it('should update a topic by its key', async ())
 - getResponse(await novuClient.topics.get(topicKey);
    expect(getResponse.result).to.exist;
    expect(getRespon...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/e2e/upsert-topic.e2e.ts
Tamaño: 2021 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Upsert topic - /v2/topics (POST) #novu-v2', async () => {
  let session: UserSession;
  let novuClient: Novu;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();

    novuClient = initNovuClassSdk(session);
  });

  it('should create a new topic when it does not exist', async () => {
    const key = `topic-key-${Date.now()}`;
    const name = 'Test Topic Name';

    const response = await novuClient.topics.create({
      key,
      name,
    });

    expect(response.result).to.exist;
    expect(response.result).to.have.property('id');
    expect(response.result.key).to.equal(key);
    expect(response.result.name).to.equal(name);
    expect(response.result).to.have.property('createdAt');
    expect(response.result).to.have.property('updatedAt');
  });

  it('should update an existing topic when it already exists', async () => {
    // First create a topic
    const key = `topic-key-${Date.now()}`;
    const originalName = 'Original Name';

    const createResponse = await novuClient.topics.create({
      key,
      name: originalName,
    });

    expect(createResponse.result).to.exist;
    const originalId = createResponse.result.id;

    // Now update the same topic by creating with the same key
    const updatedName = 'Updated Name';
    const updateResponse = await novuClient.topics.update(
      {
        name: updatedName,
      },
      key
    );

    expect(updateResponse.result).to.exist;
    expect(updateResponse.result.id).to.equal(originalId);
    expect(updateResponse.result.key).to.equal(key);
    expect(updateResponse.result.name).to.equal(updatedName);
    // Verify the update persisted by fetching the topic
    const getResponse = await novuClient.topics.get(key);
    expect(getResponse.result.name).to.equal(updatedName);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - novuClient(initNovuClassSdk(session);
  });

  it('should create a new topic when it does not exist', async ())
 - response(await novuClient.topics.create({
      key,
      name,
    });

    expect(response.result).to.exis...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/usecases/index.ts
Tamaño: 1099 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CreateTopicSubscriptionsUsecase } from './create-topic-subscriptions/create-topic-subscriptions.usecase';
import { DeleteTopicUseCase } from './delete-topic/delete-topic.usecase';
import { DeleteTopicSubscriptionsUsecase } from './delete-topic-subscriptions/delete-topic-subscriptions.usecase';
import { GetTopicUseCase } from './get-topic/get-topic.usecase';
import { ListSubscriberSubscriptionsUseCase } from './list-subscriber-subscriptions/list-subscriber-subscriptions.usecase';
import { ListTopicSubscriptionsUseCase } from './list-topic-subscriptions/list-topic-subscriptions.usecase';
import { ListTopicsUseCase } from './list-topics/list-topics.usecase';
import { UpdateTopicUseCase } from './update-topic/update-topic.usecase';
import { UpsertTopicUseCase } from './upsert-topic/upsert-topic.usecase';

export const USE_CASES = [
  CreateTopicSubscriptionsUsecase,
  DeleteTopicSubscriptionsUsecase,
  DeleteTopicUseCase,
  GetTopicUseCase,
  ListSubscriberSubscriptionsUseCase,
  ListTopicSubscriptionsUseCase,
  ListTopicsUseCase,
  UpdateTopicUseCase,
  UpsertTopicUseCase,
];


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/usecases/create-topic-subscriptions/create-topic-subscriptions.command.ts
Tamaño: 341 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsArray, IsDefined, IsString } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class CreateTopicSubscriptionsCommand extends EnvironmentWithUserCommand {
  @IsString()
  @IsDefined()
  topicKey: string;

  @IsArray()
  @IsDefined()
  subscriberIds: string[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateTopicSubscriptionsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/usecases/create-topic-subscriptions/create-topic-subscriptions.usecase.ts
Tamaño: 5398 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { InstrumentUsecase } from '@novu/application-generic';
import {
  CreateTopicSubscribersEntity,
  SubscriberEntity,
  SubscriberRepository,
  TopicEntity,
  TopicRepository,
  TopicSubscribersEntity,
  TopicSubscribersRepository,
} from '@novu/dal';
import {
  CreateTopicSubscriptionsResponseDto,
  SubscriptionDto,
  SubscriptionErrorDto,
} from '../../dtos/create-topic-subscriptions-response.dto';
import { UpsertTopicUseCase } from '../upsert-topic/upsert-topic.usecase';
import { CreateTopicSubscriptionsCommand } from './create-topic-subscriptions.command';

@Injectable()
export class CreateTopicSubscriptionsUsecase {
  constructor(
    private topicRepository: TopicRepository,
    private topicSubscribersRepository: TopicSubscribersRepository,
    private subscriberRepository: SubscriberRepository,
    private upsertTopicUseCase: UpsertTopicUseCase
  ) {}

  @InstrumentUsecase()
  async execute(command: CreateTopicSubscriptionsCommand): Promise<CreateTopicSubscriptionsResponseDto> {
    // Use upsert topic usecase to create the topic if it doesn't exist
    await this.upsertTopicUseCase.execute({
      environmentId: command.environmentId,
      organizationId: command.organizationId,
      userId: command.userId,
      key: command.topicKey,
    });

    // Get the topic entity from the repository after upsert
    const topic = await this.topicRepository.findTopicByKey(
      command.topicKey,
      command.organizationId,
      command.environmentId
    );

    if (!topic) {
      throw new Error(`Topic with key ${command.topicKey} not found after upsert`);
    }

    const errors: SubscriptionErrorDto[] = [];
    const subscriptionData: SubscriptionDto[] = [];

    const foundSubscribers = await this.subscriberRepository.searchByExternalSubscriberIds({
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
      externalSubscriberIds: command.subscriberIds,
    });

    const foundSubscriberIds = foundSubscribers.map((sub) => sub.subscriberId);
    const notFoundSubscriberIds = command.subscriberIds.filter((id) => !foundSubscriberIds.includes(id));

    for (const subscriberId of notFoundSubscriberIds) {
      errors.push({
        subscriberId,
        code: 'SUBSCRIBER_NOT_FOUND',
        message: `Subscriber with ID '${subscriberId}' could not be found.`,
      });
    }

    if (foundSubscribers.length === 0) {
      return {
        data: [],
        meta: {
          totalCount: command.subscriberIds.length,
          successful: 0,
          failed: command.subscriberIds.length,
        },
        errors,
      };
    }

    // Check for existing subscriptions to make the operation idempotent
    const existingSubscriptions = await this.topicSubscribersRepository.find({
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
      _topicId: topic._id,
      _subscriberId: { $in: foundSubscribers.map((sub) => sub._id) },
    });

    // Create topic subscriptions for subscribers that don't already have a subscription
    const existingSubscriberIds = existingSubscriptions.map((sub) => sub._subscriberId.toString());
    const subscribersToCreate = foundSubscribers.filter((sub) => !existingSubscriberIds.includes(sub._id.toString()));

    let newSubscriptions: TopicSubscribersEntity[] = [];
    if (subscribersToCreate.length > 0) {
      const topicSubscribersToCreate = this.mapSubscribersToTopic(topic, subscribersToCreate);
      newSubscriptions = await this.topicSubscribersRepository.addSubscribers(topicSubscribersToCreate);
    }

    // Combine existing and new subscriptions for the response
    const allSubscriptions = [...existingSubscriptions, ...newSubscriptions];
    // Map subscriptions to response format
    for (const subscription of allSubscriptions) {
      const subscriber = foundSubscribers.find((sub) => sub._id.toString() === subscription._subscriberId.toString());

      subscriptionData.push({
        _id: subscription._id.toString(),
        topic: {
          _id: topic._id,
          key: topic.key,
          name: topic.name,
        },
        subscriber: subscriber
          ? {
              _id: subscriber._id,
              subscriberId: subscriber.subscriberId,
              avatar: subscriber.avatar,
              firstName: subscriber.firstName,
              lastName: subscriber.lastName,
              email: subscriber.email,
              createdAt: subscriber.createdAt,
              updatedAt: subscriber.updatedAt,
            }
          : null,
        createdAt: subscription.createdAt ?? '',
        updatedAt: subscription.updatedAt ?? '',
      });
    }

    return {
      data: subscriptionData,
      meta: {
        totalCount: command.subscriberIds.length,
        successful: subscriptionData.length,
        failed: errors.length,
      },
      errors: errors.length > 0 ? errors : undefined,
    };
  }

  private mapSubscribersToTopic(topic: TopicEntity, subscribers: SubscriberEntity[]): CreateTopicSubscribersEntity[] {
    return subscribers.map((subscriber) => ({
      _environmentId: subscriber._environmentId,
      _organizationId: subscriber._organizationId,
      _subscriberId: subscriber._id,
      _topicId: topic._id,
      topicKey: topic.key,
      externalSubscriberId: subscriber.subscriberId,
    }));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - foundSubscriberIds(foundSubscribers.map((sub))
 - notFoundSubscriberIds(command.subscriberIds.filter((id))
 - existingSubscriptions(await this.topicSubscribersRepository.find({
      _environmentId: command.environmentId,
      _org...)
 - existingSubscriberIds(existingSubscriptions.map((sub))
 - subscribersToCreate(foundSubscribers.filter((sub))
 - subscriber(foundSubscribers.find((sub))
Declaraciones 'export' encontradas:
- export class CreateTopicSubscriptionsUsecase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/usecases/create-topic-subscriptions/index.ts
Tamaño: 108 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './create-topic-subscriptions.command';
export * from './create-topic-subscriptions.usecase';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/usecases/delete-topic-subscriptions/delete-topic-subscriptions.command.ts
Tamaño: 341 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsArray, IsDefined, IsString } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class DeleteTopicSubscriptionsCommand extends EnvironmentWithUserCommand {
  @IsString()
  @IsDefined()
  topicKey: string;

  @IsArray()
  @IsDefined()
  subscriberIds: string[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DeleteTopicSubscriptionsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/usecases/delete-topic-subscriptions/delete-topic-subscriptions.usecase.ts
Tamaño: 5295 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { InstrumentUsecase } from '@novu/application-generic';
import { SubscriberRepository, TopicRepository, TopicSubscribersRepository } from '@novu/dal';
import {
  DeleteTopicSubscriptionsResponseDto,
  SubscriptionDto,
  SubscriptionsDeleteErrorDto,
} from '../../dtos/delete-topic-subscriptions-response.dto';
import { DeleteTopicSubscriptionsCommand } from './delete-topic-subscriptions.command';

@Injectable()
export class DeleteTopicSubscriptionsUsecase {
  constructor(
    private topicRepository: TopicRepository,
    private topicSubscribersRepository: TopicSubscribersRepository,
    private subscriberRepository: SubscriberRepository
  ) {}

  @InstrumentUsecase()
  async execute(command: DeleteTopicSubscriptionsCommand): Promise<DeleteTopicSubscriptionsResponseDto> {
    const topic = await this.topicRepository.findTopicByKey(
      command.topicKey,
      command.organizationId,
      command.environmentId
    );

    if (!topic) {
      throw new NotFoundException(`Topic with key ${command.topicKey} not found`);
    }

    const errors: SubscriptionsDeleteErrorDto[] = [];
    const subscriptionData: SubscriptionDto[] = [];

    if (command.subscriberIds.length === 0) {
      return {
        data: [],
        meta: {
          totalCount: 0,
          successful: 0,
          failed: 0,
        },
      };
    }

    // Find existing subscribers directly using the subscriberRepository
    const foundSubscribers = await this.subscriberRepository.searchByExternalSubscriberIds({
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
      externalSubscriberIds: command.subscriberIds,
    });

    // Identify which subscribers were not found
    const foundSubscriberIds = foundSubscribers.map((sub) => sub.subscriberId);
    const notFoundSubscriberIds = command.subscriberIds.filter((id) => !foundSubscriberIds.includes(id));

    // Add errors for subscribers not found
    for (const subscriberId of notFoundSubscriberIds) {
      errors.push({
        subscriberId,
        code: 'SUBSCRIBER_NOT_FOUND',
        message: `Subscriber with ID '${subscriberId}' could not be found.`,
      });
    }

    if (foundSubscribers.length === 0) {
      return {
        data: [],
        meta: {
          totalCount: command.subscriberIds.length,
          successful: 0,
          failed: command.subscriberIds.length,
        },
        errors,
      };
    }

    // Find existing subscriptions for these subscribers
    const existingSubscriptions = await this.topicSubscribersRepository.find({
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
      _topicId: topic._id,
      _subscriberId: { $in: foundSubscribers.map((sub) => sub._id) },
    });

    // Identify which subscribers don't have a subscription to delete
    const existingSubscriberIds = existingSubscriptions.map((sub) => sub._subscriberId.toString());
    const subscribersWithoutSubscription = foundSubscribers.filter(
      (sub) => !existingSubscriberIds.includes(sub._id.toString())
    );

    // Add errors for subscribers without subscriptions
    for (const subscriber of subscribersWithoutSubscription) {
      errors.push({
        subscriberId: subscriber.subscriberId,
        code: 'SUBSCRIPTION_NOT_FOUND',
        message: `Subscription for subscriber '${subscriber.subscriberId}' not found.`,
      });
    }

    // Map existing subscriptions to response format before deleting them
    for (const subscription of existingSubscriptions) {
      const subscriber = foundSubscribers.find((sub) => sub._id.toString() === subscription._subscriberId.toString());

      subscriptionData.push({
        _id: subscription._id,
        topic: {
          _id: topic._id,
          key: topic.key,
          name: topic.name,
        },
        subscriber: subscriber
          ? {
              _id: subscriber._id,
              subscriberId: subscriber.subscriberId,
              avatar: subscriber.avatar,
              firstName: subscriber.firstName,
              lastName: subscriber.lastName,
              email: subscriber.email,
              createdAt: subscriber.createdAt,
              updatedAt: subscriber.updatedAt,
            }
          : null,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      });
    }

    // Only delete subscriptions if there are any to delete
    if (existingSubscriptions.length > 0) {
      // Get the list of external subscriber IDs that have subscriptions
      const subscribersToRemove = foundSubscribers
        .filter((sub) => existingSubscriberIds.includes(sub._id.toString()))
        .map((sub) => sub.subscriberId);

      // Remove subscriptions for the specified subscribers
      await this.topicSubscribersRepository.removeSubscribers(
        command.environmentId,
        command.organizationId,
        command.topicKey,
        subscribersToRemove
      );
    }

    return {
      data: subscriptionData,
      meta: {
        totalCount: command.subscriberIds.length,
        successful: subscriptionData.length,
        failed: errors.length,
      },
      errors: errors.length > 0 ? errors : undefined,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - foundSubscriberIds(foundSubscribers.map((sub))
 - notFoundSubscriberIds(command.subscriberIds.filter((id))
 - existingSubscriptions(await this.topicSubscribersRepository.find({
      _environmentId: command.environmentId,
      _org...)
 - existingSubscriberIds(existingSubscriptions.map((sub))
 - subscribersWithoutSubscription(foundSubscribers.filter(
      (sub))
 - subscriber(foundSubscribers.find((sub))
 - subscribersToRemove(foundSubscribers
        .filter((sub))
Declaraciones 'export' encontradas:
- export class DeleteTopicSubscriptionsUsecase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/usecases/delete-topic-subscriptions/index.ts
Tamaño: 108 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './delete-topic-subscriptions.command';
export * from './delete-topic-subscriptions.usecase';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/usecases/delete-topic/delete-topic.command.ts
Tamaño: 339 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsBoolean, IsNotEmpty, IsOptional, IsString } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class DeleteTopicCommand extends EnvironmentWithUserCommand {
  @IsString()
  @IsNotEmpty()
  topicKey: string;

  @IsBoolean()
  @IsOptional()
  force?: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DeleteTopicCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/usecases/delete-topic/delete-topic.usecase.ts
Tamaño: 1688 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import { InstrumentUsecase } from '@novu/application-generic';
import { TopicRepository, TopicSubscribersRepository } from '@novu/dal';
import { DeleteTopicCommand } from './delete-topic.command';

@Injectable()
export class DeleteTopicUseCase {
  constructor(
    private topicRepository: TopicRepository,
    private topicSubscribersRepository: TopicSubscribersRepository
  ) {}

  @InstrumentUsecase()
  async execute(command: DeleteTopicCommand): Promise<void> {
    const topic = await this.topicRepository.findTopicByKey(
      command.topicKey,
      command.organizationId,
      command.environmentId
    );

    if (!topic) {
      throw new NotFoundException(`Topic with key ${command.topicKey} not found`);
    }

    const hasSubscribers = await this.topicSubscribersRepository.find(
      {
        _topicId: topic._id,
        _environmentId: command.environmentId,
        _organizationId: command.organizationId,
      },
      '_id',
      {
        limit: 1,
      }
    );

    if (hasSubscribers.length > 0 && !command.force) {
      throw new BadRequestException(
        `Topic has subscribers. Use force=true parameter to delete the topic and its subscriptions.`
      );
    }

    if (hasSubscribers.length > 0) {
      await this.topicSubscribersRepository.delete({
        _topicId: topic._id,
        _environmentId: command.environmentId,
        _organizationId: command.organizationId,
      });
    }

    await this.topicRepository.delete({
      _id: topic._id,
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
    });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DeleteTopicUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/usecases/get-topic/get-topic.command.ts
Tamaño: 246 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsNotEmpty, IsString } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';

export class GetTopicCommand extends EnvironmentCommand {
  @IsString()
  @IsNotEmpty()
  topicKey: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetTopicCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/usecases/get-topic/get-topic.usecase.ts
Tamaño: 875 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { InstrumentUsecase } from '@novu/application-generic';
import { TopicRepository } from '@novu/dal';
import { TopicResponseDto } from '../../dtos/topic-response.dto';
import { mapTopicEntityToDto } from '../list-topics/map-topic-entity-to.dto';
import { GetTopicCommand } from './get-topic.command';

@Injectable()
export class GetTopicUseCase {
  constructor(private topicRepository: TopicRepository) {}

  @InstrumentUsecase()
  async execute(command: GetTopicCommand): Promise<TopicResponseDto> {
    const topic = await this.topicRepository.findTopicByKey(
      command.topicKey,
      command.organizationId,
      command.environmentId
    );

    if (!topic) {
      throw new NotFoundException(`Topic with key ${command.topicKey} not found`);
    }

    return mapTopicEntityToDto(topic);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetTopicUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/usecases/list-subscriber-subscriptions/index.ts
Tamaño: 114 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './list-subscriber-subscriptions.command';
export * from './list-subscriber-subscriptions.usecase';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/usecases/list-subscriber-subscriptions/list-subscriber-subscriptions.command.ts
Tamaño: 564 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsNotEmpty, IsOptional, IsString } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';

export class ListSubscriberSubscriptionsCommand extends EnvironmentCommand {
  @IsString()
  @IsNotEmpty()
  subscriberId: string;

  @IsString()
  @IsOptional()
  topicKey?: string;

  @IsOptional()
  limit?: number;

  @IsOptional()
  after?: string;

  @IsOptional()
  before?: string;

  @IsOptional()
  orderBy?: string;

  @IsOptional()
  orderDirection?: number;

  @IsOptional()
  includeCursor?: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ListSubscriberSubscriptionsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/usecases/list-subscriber-subscriptions/list-subscriber-subscriptions.usecase.ts
Tamaño: 3867 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { InstrumentUsecase } from '@novu/application-generic';
import { SubscriberRepository, TopicSubscribersEntity, TopicSubscribersRepository } from '@novu/dal';
import { DirectionEnum, EnvironmentId } from '@novu/shared';
import { ListTopicSubscriptionsResponseDto } from '../../dtos/list-topic-subscriptions-response.dto';
import { TopicSubscriptionResponseDto } from '../../dtos/topic-subscription-response.dto';
import { mapTopicSubscriptionsToDto } from '../list-topics/map-topic-entity-to.dto';
import { ListSubscriberSubscriptionsCommand } from './list-subscriber-subscriptions.command';

@Injectable()
export class ListSubscriberSubscriptionsUseCase {
  constructor(
    private topicSubscribersRepository: TopicSubscribersRepository,
    private subscriberRepository: SubscriberRepository
  ) {}

  @InstrumentUsecase()
  async execute(command: ListSubscriberSubscriptionsCommand): Promise<ListTopicSubscriptionsResponseDto> {
    // Find the subscriber to validate it exists
    const subscriber = await this.subscriberRepository.findBySubscriberId(command.environmentId, command.subscriberId);

    if (!subscriber) {
      throw new NotFoundException('Subscriber not found');
    }

    if (command.before && command.after) {
      throw new Error('Cannot specify both "before" and "after" cursors at the same time.');
    }

    // Use the repository method for pagination
    const subscriptionsPagination = await this.topicSubscribersRepository.findTopicSubscriptionsWithPagination({
      environmentId: command.environmentId,
      organizationId: command.organizationId,
      topicKey: command.topicKey,
      subscriberId: command.subscriberId,
      limit: command.limit || 10,
      before: command.before,
      after: command.after,
      orderDirection: command.orderDirection === 1 ? DirectionEnum.ASC : DirectionEnum.DESC,
      includeCursor: command.includeCursor,
    });

    // Build detailed response with topic and subscriber info
    const subscriptionsWithDetails = await this.populateSubscriptionsData(
      subscriptionsPagination.data,
      command.environmentId
    );

    return {
      data: subscriptionsWithDetails,
      next: subscriptionsPagination.next,
      previous: subscriptionsPagination.previous,
      totalCount: subscriptionsPagination.totalCount,
      totalCountCapped: subscriptionsPagination.totalCountCapped,
    };
  }

  private async populateSubscriptionsData(
    subscriptions: TopicSubscribersEntity[],
    environmentId: EnvironmentId
  ): Promise<TopicSubscriptionResponseDto[]> {
    if (subscriptions.length === 0) {
      return [];
    }

    // Get the subscriber from the first subscription since it's always the same subscriber
    const subscriberId = subscriptions[0]._subscriberId;
    const subscriber = await this.subscriberRepository.findOne({
      _environmentId: environmentId,
      _id: subscriberId,
    });

    if (!subscriber) {
      return [];
    }

    // Need unique topic IDs
    const topicKeys = subscriptions.map((subscription) => subscription.topicKey);

    if (topicKeys.length === 0) {
      return [];
    }

    // Find all topic information using the topic keys
    const topics = await this.topicSubscribersRepository.findTopicsByTopicKeys(environmentId, topicKeys);

    // Create a map for quick lookup
    const topicsMap = new Map(topics.map((result) => [result._id, result.topic]));

    // Map subscriptions to response DTOs with topic and subscriber details
    return subscriptions
      .map((subscription) => {
        const topic = topicsMap.get(subscription.topicKey);

        if (!topic) {
          return null;
        }

        return mapTopicSubscriptionsToDto(subscription, subscriber, topic);
      })
      .filter(Boolean) as TopicSubscriptionResponseDto[];
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - topicKeys(subscriptions.map((subscription))
 - topicsMap(new Map(topics.map((result))
Declaraciones 'export' encontradas:
- export class ListSubscriberSubscriptionsUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/usecases/list-topic-subscriptions/list-topic-subscriptions.command.ts
Tamaño: 559 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsNotEmpty, IsOptional, IsString } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';

export class ListTopicSubscriptionsCommand extends EnvironmentCommand {
  @IsString()
  @IsNotEmpty()
  topicKey: string;

  @IsString()
  @IsOptional()
  subscriberId?: string;

  @IsOptional()
  limit?: number;

  @IsOptional()
  after?: string;

  @IsOptional()
  before?: string;

  @IsOptional()
  orderBy?: string;

  @IsOptional()
  orderDirection?: number;

  @IsOptional()
  includeCursor?: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ListTopicSubscriptionsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/usecases/list-topic-subscriptions/list-topic-subscriptions.usecase.ts
Tamaño: 3482 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { InstrumentUsecase } from '@novu/application-generic';
import {
  SubscriberRepository,
  TopicEntity,
  TopicRepository,
  TopicSubscribersEntity,
  TopicSubscribersRepository,
} from '@novu/dal';
import { DirectionEnum, EnvironmentId } from '@novu/shared';
import { ListTopicSubscriptionsResponseDto } from '../../dtos/list-topic-subscriptions-response.dto';
import { TopicSubscriptionResponseDto } from '../../dtos/topic-subscription-response.dto';
import { mapTopicSubscriptionsToDto } from '../list-topics/map-topic-entity-to.dto';
import { ListTopicSubscriptionsCommand } from './list-topic-subscriptions.command';

@Injectable()
export class ListTopicSubscriptionsUseCase {
  constructor(
    private topicRepository: TopicRepository,
    private topicSubscribersRepository: TopicSubscribersRepository,
    private subscriberRepository: SubscriberRepository
  ) {}

  @InstrumentUsecase()
  async execute(command: ListTopicSubscriptionsCommand): Promise<ListTopicSubscriptionsResponseDto> {
    const topic = await this.topicRepository.findTopicByKey(
      command.topicKey,
      command.organizationId,
      command.environmentId
    );

    if (!topic) {
      throw new NotFoundException(`Topic with key ${command.topicKey} not found`);
    }

    const subscriptionsPagination = await this.topicSubscribersRepository.findTopicSubscriptionsWithPagination({
      environmentId: command.environmentId,
      organizationId: command.organizationId,
      topicKey: command.topicKey,
      subscriberId: command.subscriberId,
      limit: command.limit || 10,
      before: command.before,
      after: command.after,
      orderDirection: command.orderDirection === 1 ? DirectionEnum.ASC : DirectionEnum.DESC,
      includeCursor: command.includeCursor,
    });

    // Build detailed response with topic and subscriber info
    const subscriptionsWithDetails = await this.populateSubscriptionsData(
      topic,
      subscriptionsPagination.data,
      command.environmentId
    );

    return {
      data: subscriptionsWithDetails,
      next: subscriptionsPagination.next,
      previous: subscriptionsPagination.previous,
      totalCount: subscriptionsPagination.totalCount,
      totalCountCapped: subscriptionsPagination.totalCountCapped,
    };
  }

  private async populateSubscriptionsData(
    topic: TopicEntity,
    subscriptions: TopicSubscribersEntity[],
    environmentId: EnvironmentId
  ): Promise<TopicSubscriptionResponseDto[]> {
    if (subscriptions.length === 0) {
      return [];
    }

    // Get all subscriber IDs from subscriptions
    const subscriberIds = subscriptions.map((subscription) => subscription._subscriberId);

    // Fetch all subscribers in a single query
    const subscribers = await this.subscriberRepository.find({
      _environmentId: environmentId,
      _id: { $in: subscriberIds },
    });

    // Create a map for quick lookup
    const subscriberMap = new Map(subscribers.map((subscriber) => [subscriber._id, subscriber]));

    // Map subscriptions to response DTOs with topic and subscriber details
    return subscriptions
      .map((subscription) => {
        const subscriber = subscriberMap.get(subscription._subscriberId);

        if (!subscriber) {
          return null;
        }

        return mapTopicSubscriptionsToDto(subscription, subscriber, topic);
      })
      .filter(Boolean) as TopicSubscriptionResponseDto[];
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - subscriberIds(subscriptions.map((subscription))
 - subscriberMap(new Map(subscribers.map((subscriber))
Declaraciones 'export' encontradas:
- export class ListTopicSubscriptionsUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/usecases/list-topics/list-topics.command.ts
Tamaño: 550 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CursorBasedPaginatedCommand } from '@novu/application-generic';
import { TopicEntity } from '@novu/dal';
import { IsMongoId, IsNotEmpty, IsOptional, IsString } from 'class-validator';

export class ListTopicsCommand extends CursorBasedPaginatedCommand<TopicEntity, 'createdAt' | 'updatedAt' | '_id'> {
  @IsString()
  @IsOptional()
  key?: string;

  @IsString()
  @IsOptional()
  name?: string;

  @IsString()
  @IsNotEmpty()
  @IsMongoId()
  environmentId: string;

  @IsString()
  @IsMongoId()
  @IsNotEmpty()
  organizationId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ListTopicsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/usecases/list-topics/list-topics.usecase.ts
Tamaño: 1341 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { InstrumentUsecase } from '@novu/application-generic';
import { TopicRepository } from '@novu/dal';
import { DirectionEnum } from '../../../shared/dtos/base-responses';
import { ListTopicsResponseDto } from '../../dtos/list-topics-response.dto';
import { ListTopicsCommand } from './list-topics.command';
import { mapTopicEntityToDto } from './map-topic-entity-to.dto';

@Injectable()
export class ListTopicsUseCase {
  constructor(private topicRepository: TopicRepository) {}

  @InstrumentUsecase()
  async execute(command: ListTopicsCommand): Promise<ListTopicsResponseDto> {
    const pagination = await this.topicRepository.listTopics({
      after: command.after,
      before: command.before,
      limit: command.limit,
      sortDirection: command.orderDirection === DirectionEnum.ASC ? 1 : -1,
      sortBy: command.orderBy,
      key: command.key,
      name: command.name,
      environmentId: command.environmentId,
      organizationId: command.organizationId,
      includeCursor: command.includeCursor,
    });

    return {
      data: pagination.topics.map((topic) => mapTopicEntityToDto(topic)),
      next: pagination.next,
      previous: pagination.previous,
      totalCount: pagination.totalCount,
      totalCountCapped: pagination.totalCountCapped,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ListTopicsUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/usecases/list-topics/map-topic-entity-to.dto.ts
Tamaño: 1054 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SubscriberEntity, TopicEntity, TopicSubscribersEntity } from '@novu/dal';
import { TopicResponseDto } from '../../dtos/topic-response.dto';
import { TopicSubscriptionResponseDto } from '../../dtos/topic-subscription-response.dto';

export function mapTopicEntityToDto(topicEntity: TopicEntity): TopicResponseDto {
  return {
    _id: String(topicEntity._id),
    name: topicEntity.name,
    key: topicEntity.key,
    createdAt: topicEntity.createdAt,
    updatedAt: topicEntity.updatedAt,
  };
}

export function mapTopicSubscriptionsToDto(
  subscription: TopicSubscribersEntity,
  subscriber: SubscriberEntity,
  topic: TopicEntity
): TopicSubscriptionResponseDto {
  return {
    _id: String(subscription._id),
    topic: mapTopicEntityToDto(topic),
    createdAt: subscription.createdAt!,
    subscriber: {
      _id: String(subscriber._id),
      subscriberId: subscriber.subscriberId,
      firstName: subscriber.firstName,
      lastName: subscriber.lastName,
      email: subscriber.email,
      avatar: subscriber.avatar,
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - mapTopicEntityToDto(topicEntity: TopicEntity)
 - mapTopicSubscriptionsToDto(subscription: TopicSubscribersEntity,
  subscriber: SubscriberEntity,
  topic: TopicEntity)
Declaraciones 'export' encontradas:
- export function mapTopicEntityToDto
- export function mapTopicSubscriptionsToDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/usecases/update-topic/update-topic.command.ts
Tamaño: 312 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsNotEmpty, IsString } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class UpdateTopicCommand extends EnvironmentWithUserCommand {
  @IsString()
  @IsNotEmpty()
  topicKey: string;

  @IsString()
  @IsNotEmpty()
  name: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateTopicCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/usecases/update-topic/update-topic.usecase.ts
Tamaño: 1228 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { InstrumentUsecase } from '@novu/application-generic';
import { TopicRepository } from '@novu/dal';
import { TopicResponseDto } from '../../dtos/topic-response.dto';
import { mapTopicEntityToDto } from '../list-topics/map-topic-entity-to.dto';
import { UpdateTopicCommand } from './update-topic.command';

@Injectable()
export class UpdateTopicUseCase {
  constructor(private topicRepository: TopicRepository) {}

  @InstrumentUsecase()
  async execute(command: UpdateTopicCommand): Promise<TopicResponseDto> {
    const existingTopic = await this.topicRepository.findTopicByKey(
      command.topicKey,
      command.organizationId,
      command.environmentId
    );

    if (!existingTopic) {
      throw new NotFoundException(`Topic with key ${command.topicKey} not found`);
    }

    const updatedTopic = await this.topicRepository.findOneAndUpdate(
      {
        _id: existingTopic._id,
        _environmentId: command.environmentId,
        _organizationId: command.organizationId,
      },
      {
        $set: {
          name: command.name,
        },
      },
      { new: true }
    );

    return mapTopicEntityToDto(updatedTopic!);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateTopicUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/usecases/upsert-topic/upsert-topic.command.ts
Tamaño: 433 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsBoolean, IsNotEmpty, IsOptional, IsString, Length } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class UpsertTopicCommand extends EnvironmentWithUserCommand {
  @IsString()
  @IsNotEmpty()
  @Length(1, 100)
  key: string;

  @IsString()
  @IsOptional()
  @Length(0, 100)
  name?: string;

  @IsBoolean()
  @IsOptional()
  failIfExists?: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpsertTopicCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/topics-v2/usecases/upsert-topic/upsert-topic.usecase.ts
Tamaño: 2040 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, ConflictException, Injectable } from '@nestjs/common';
import { InstrumentUsecase } from '@novu/application-generic';
import { TopicRepository } from '@novu/dal';
import { VALID_ID_REGEX } from '@novu/shared';
import { TopicResponseDto } from '../../dtos/topic-response.dto';
import { mapTopicEntityToDto } from '../list-topics/map-topic-entity-to.dto';
import { UpsertTopicCommand } from './upsert-topic.command';

@Injectable()
export class UpsertTopicUseCase {
  constructor(private topicRepository: TopicRepository) {}

  @InstrumentUsecase()
  async execute(command: UpsertTopicCommand): Promise<{ topic: TopicResponseDto; created: boolean }> {
    let topic = await this.topicRepository.findTopicByKey(command.key, command.organizationId, command.environmentId);
    if (command.failIfExists && topic) {
      throw new ConflictException(`Topic with key "${command.key}" already exists`);
    }

    if (!topic) {
      this.isValidTopicKey(command.key);

      topic = await this.topicRepository.createTopic({
        _environmentId: command.environmentId,
        _organizationId: command.organizationId,
        key: command.key,
        name: command.name,
      });
    } else {
      const updateBody: Record<string, unknown> = {};

      if (command.name) {
        updateBody.name = command.name;
      }

      topic = await this.topicRepository.findOneAndUpdate(
        {
          _id: topic._id,
          _environmentId: command.environmentId,
          _organizationId: command.organizationId,
        },
        {
          $set: updateBody,
        }
      );
    }

    return {
      topic: mapTopicEntityToDto(topic!),
      created: !topic,
    };
  }

  private isValidTopicKey(key: string): void {
    if (VALID_ID_REGEX.test(key)) {
      return;
    }

    throw new BadRequestException(
      `Invalid topic key: "${key}". Topic keys must contain only alphanumeric characters (a-z, A-Z, 0-9), hyphens (-), underscores (_), colons (:), or be a valid email address.`
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpsertTopicUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/translations/e2e/v1/create-translation.e2e-ee.ts
Tamaño: 3633 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('[V1 Translations] Create translation group - /translations/groups (POST) #novu-v2', async () => {
  let session: UserSession;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    await session.testAgent.put(`/v1/organizations/language`).send({
      locale: 'en_US',
    });
  });

  it('should create translation group', async () => {
    const result = await session.testAgent.post(`/v1/translations/groups`).send({
      name: 'test',
      identifier: 'test',
      locales: ['en_US'],
    });

    let group = result.body.data;
    const { id } = group;

    expect(group.name).to.eq('test');
    expect(group.identifier).to.eq('test');

    let data = await session.testAgent.get(`/v1/translations/groups/test`).send();
    group = data.body.data;
    let locales = group.translations.map((t) => t.isoLanguage);

    expect(group.name).to.eq('test');
    expect(group.identifier).to.eq('test');
    expect(locales).to.deep.eq(['en_US']);
    expect(id).to.equal(group.id);
    await session.applyChanges({
      enabled: false,
    });
    await session.switchToProdEnvironment();

    data = await session.testAgent.get(`/v1/translations/groups/test`).send();
    group = data.body.data;
    locales = group.translations.map((t) => t.isoLanguage);
    expect(group.name).to.eq('test');
    expect(group.identifier).to.eq('test');
    expect(locales).to.deep.eq(['en_US']);
  });
  it('should promote creation of default locale translation after translation group promotion', async () => {
    const result = await session.testAgent.post(`/v1/translations/groups`).send({
      name: 'test',
      identifier: 'test',
      locales: ['en_US', 'sv_SE'],
    });

    let group = result.body.data;
    const { id } = group;

    expect(group.name).to.eq('test');
    expect(group.identifier).to.eq('test');

    let data = await session.testAgent.get(`/v1/translations/groups/test`).send();
    group = data.body.data;
    let locales = group.translations.map((t) => t.isoLanguage);

    expect(group.name).to.eq('test');
    expect(group.identifier).to.eq('test');
    expect(locales).to.deep.eq(['en_US', 'sv_SE']);
    expect(id).to.equal(group.id);

    await session.applyChanges({
      enabled: false,
      _entityId: group.id,
    });
    await session.switchToProdEnvironment();

    data = await session.testAgent.get(`/v1/translations/groups/test`).send();
    group = data.body.data;
    locales = group.translations.map((t) => t.isoLanguage);
    expect(group.name).to.eq('test');
    expect(group.identifier).to.eq('test');
    expect(locales).to.deep.eq(['en_US']);
  });

  it('should check that default locale is included in group else add it', async () => {
    const result = await session.testAgent.post(`/v1/translations/groups`).send({
      name: 'test',
      identifier: 'test1',
      locales: ['en_GB'],
    });
    const data = await session.testAgent.get(`/v1/translations/groups/test1`).send();
    const group = data.body.data;
    const locales = group.translations.map((t) => t.isoLanguage);
    expect(locales).to.deep.eq(['en_US', 'en_GB']);
  });

  it('should check that locale is allowed', async () => {
    const result = await session.testAgent.post(`/v1/translations/groups`).send({
      name: 'test',
      identifier: 'test',
      locales: ['en_US', 'test'],
    });

    expect(result.body.message).to.be.eq('Locale could not be found');
    expect(result.body.statusCode).to.be.eq(404);
    expect(result.body.error).to.be.eq('Not Found');
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
    await session.initialize();
    await session.testAgent.put(`/v1/organization...)
 - locales(group.translations.map((t))
 - locales(group.translations.map((t))
 - locales(group.translations.map((t))
 - locales(group.translations.map((t))
 - locales(group.translations.map((t))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/translations/e2e/v1/delete-translation-group.e2e-ee.ts
Tamaño: 3561 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('[V1 Translations] Delete a Translation group - /translations/group/:id (Delete) #novu-v2', async () => {
  let session: UserSession;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();

    await session.testAgent.put(`/v1/organizations/language`).send({
      locale: 'hi_IN',
    });
  });

  it('should delete the translation group', async () => {
    const createTranslationGroup = {
      name: 'test',
      identifier: 'test',
      locales: ['hi_IN'],
    };

    const { body } = await session.testAgent.post('/v1/translations/groups').send(createTranslationGroup);
    const newTranslationGroupId = body.data._id;
    const { body: translationGroupList } = await session.testAgent.get('/v1/translations/groups').send();
    expect(translationGroupList.data.length).to.equal(1);
    expect(translationGroupList.data[0].name).to.equal(createTranslationGroup.name);
    expect(translationGroupList.data[0].identifier).to.equal(createTranslationGroup.identifier);
    expect(translationGroupList.data[0].uiConfig.locales).to.eql(createTranslationGroup.locales);
    expect(translationGroupList.data[0]._id).to.equal(newTranslationGroupId);

    await session.testAgent.delete(`/v1/translations/groups/${createTranslationGroup.identifier}`).send();

    const { body: translationGroupListAfterDelete } = await session.testAgent.get('/v1/translations/groups').send();
    expect(translationGroupListAfterDelete.data.length).to.equal(0);
  });

  it('should also delete the translations of the group', async () => {
    const createTranslationGroup = {
      name: 'test',
      identifier: 'test',
      locales: ['hi_IN'],
    };

    const { body } = await session.testAgent.post('/v1/translations/groups').send(createTranslationGroup);
    const newTranslationGroupId = body.data._id;
    const { body: translationGroupList } = await session.testAgent.get('/v1/translations/groups').send();
    expect(translationGroupList.data.length).to.equal(1);
    expect(translationGroupList.data[0].name).to.equal(createTranslationGroup.name);
    expect(translationGroupList.data[0].identifier).to.equal(createTranslationGroup.identifier);
    expect(translationGroupList.data[0].uiConfig.locales).to.eql(createTranslationGroup.locales);
    expect(translationGroupList.data[0]._id).to.equal(newTranslationGroupId);

    const { body: translationGroup } = await session.testAgent
      .get(`/v1/translations/groups/${createTranslationGroup.identifier}`)
      .send();
    expect(translationGroup.data.name).to.equal(createTranslationGroup.name);
    expect(translationGroup.data.identifier).to.equal(createTranslationGroup.identifier);
    expect(translationGroup.data.translations.length).to.equal(1);
    expect(translationGroup.data.translations[0].isoLanguage).to.equal(createTranslationGroup.locales[0]);

    await session.testAgent.delete(`/v1/translations/groups/${createTranslationGroup.identifier}`).send();

    const { body: translationGroupListAfterDelete } = await session.testAgent.get('/v1/translations/groups').send();
    expect(translationGroupListAfterDelete.data.length).to.equal(0);

    const { body: translationGroupAfterDelete } = await session.testAgent
      .get(`/v1/translations/groups/${createTranslationGroup.identifier}`)
      .send();

    expect(translationGroupAfterDelete.statusCode).to.equal(404);
    expect(translationGroupAfterDelete.message).to.equal('Group could not be found');
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
    await session.initialize();

    await session.testAgent.put(`/v1/organizatio...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/translations/e2e/v1/delete-translation.e2e-ee.ts
Tamaño: 4341 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('[V1 Translations] Delete a Translation - /translations/group/:id/locale/:locale (Delete) #novu-v2', async () => {
  let session: UserSession;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();

    await session.testAgent.put(`/v1/organizations/language`).send({
      locale: 'hi_IN',
    });
  });

  it('should delete the translation file', async () => {
    const createTranslationGroup = {
      name: 'test',
      identifier: 'test',
      locales: ['hi_IN'],
    };

    const { body } = await session.testAgent.post('/v1/translations/groups').send(createTranslationGroup);
    const newTranslationGroupId = body.data._id;
    const { body: translationGroupList } = await session.testAgent.get('/v1/translations/groups').send();
    expect(translationGroupList.data.length).to.equal(1);
    expect(translationGroupList.data[0].name).to.equal(createTranslationGroup.name);
    expect(translationGroupList.data[0].identifier).to.equal(createTranslationGroup.identifier);
    expect(translationGroupList.data[0].uiConfig.locales).to.eql(createTranslationGroup.locales);
    expect(translationGroupList.data[0]._id).to.equal(newTranslationGroupId);

    const jsonContent = {
      key1: 'value1',
      key2: 'value2',
    };

    const buffer = Buffer.from(JSON.stringify(jsonContent));

    const file = {
      fieldname: 'test.json',
      originalname: 'test.json',
      encoding: 'utf-8',
      mimetype: 'application/json',
      size: 123,
      buffer,
    };

    const fileBuffer = Buffer.from(JSON.stringify(file), 'utf-8');

    await session.testAgent
      .post(`/v1/translations/groups/${createTranslationGroup.identifier}`)
      .attach('files', fileBuffer, 'test.json')
      .field('locales', JSON.stringify(createTranslationGroup.locales))
      .field('identifier', createTranslationGroup.identifier);

    const { body: translation } = await session.testAgent
      .get(`/v1/translations/groups/${createTranslationGroup.identifier}/locales/${createTranslationGroup.locales[0]}`)
      .send();

    const translationData = translation.data;
    expect(translationData.isoLanguage).to.equal(createTranslationGroup.locales[0]);
    expect(translationData._groupId).to.equal(newTranslationGroupId);
    expect(translationData.translations).to.equal(JSON.stringify(file));

    await session.applyChanges({
      enabled: false,
    });
    await session.switchToProdEnvironment();

    const { body: translationProd } = await session.testAgent
      .get(`/v1/translations/groups/${createTranslationGroup.identifier}/locales/${createTranslationGroup.locales[0]}`)
      .send();

    const translationProdData = translationProd.data;
    expect(translationProdData.isoLanguage).to.equal(createTranslationGroup.locales[0]);
    expect(translationProdData.translations).to.equal(JSON.stringify(file));

    await session.switchToDevEnvironment();

    await session.testAgent
      .delete(
        `/v1/translations/groups/${createTranslationGroup.identifier}/locales/${createTranslationGroup.locales[0]}`
      )
      .send();

    const { body: translationAfterDelete } = await session.testAgent
      .get(`/v1/translations/groups/${createTranslationGroup.identifier}/locales/${createTranslationGroup.locales[0]}`)
      .send();

    const translationDataAfterDelete = translationAfterDelete.data;

    expect(translationDataAfterDelete.isoLanguage).to.equal(createTranslationGroup.locales[0]);
    expect(translationDataAfterDelete._groupId).to.equal(newTranslationGroupId);
    expect(translationDataAfterDelete.translations).to.not.exist;
    expect(translationDataAfterDelete.fileName).to.not.exist;

    await session.applyChanges({
      enabled: false,
    });

    await session.switchToProdEnvironment();

    const { body: translationProdAfterDelete } = await session.testAgent
      .get(`/v1/translations/groups/${createTranslationGroup.identifier}/locales/${createTranslationGroup.locales[0]}`)
      .send();

    const translationProdDataAfterDelete = translationProdAfterDelete.data;
    expect(translationProdDataAfterDelete.isoLanguage).to.equal(createTranslationGroup.locales[0]);
    expect(translationProdDataAfterDelete.translations).to.not.exist;
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
    await session.initialize();

    await session.testAgent.put(`/v1/organizatio...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/translations/e2e/v1/edit-translation.e2e-ee.ts
Tamaño: 4448 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';

const createTranslationGroup = {
  name: 'test',
  identifier: 'test',
  locales: ['hi_IN'],
};

describe('[V1 Translations] Edit translation - /translations/groups/:identifier/locales/:locale (PATCH) #novu-v2', async () => {
  let session: UserSession;

  before(async () => {
    session = new UserSession();
    await session.initialize();
    await session.testAgent.put(`/v1/organizations/language`).send({
      locale: createTranslationGroup.locales[0],
    });
  });

  it('should edit translation', async () => {
    const { body } = await session.testAgent.post('/v1/translations/groups').send(createTranslationGroup);
    const newTranslationGroupId = body.data._id;
    const { body: translationGroupList } = await session.testAgent.get('/v1/translations/groups').send();
    expect(translationGroupList.data.length).to.equal(1);
    expect(translationGroupList.data[0].name).to.equal(createTranslationGroup.name);
    expect(translationGroupList.data[0].identifier).to.equal(createTranslationGroup.identifier);
    expect(translationGroupList.data[0].uiConfig.locales).to.eql(createTranslationGroup.locales);
    expect(translationGroupList.data[0]._id).to.equal(newTranslationGroupId);

    const jsonContent = {
      key1: 'value1',
      key2: 'value2',
    };

    const buffer = Buffer.from(JSON.stringify(jsonContent));

    const file = {
      fieldname: 'test.json',
      originalname: 'test.json',
      encoding: 'utf-8',
      mimetype: 'application/json',
      size: 123,
      buffer,
    };

    const fileBuffer = Buffer.from(JSON.stringify(file), 'utf-8');

    await session.testAgent
      .post(`/v1/translations/groups/${createTranslationGroup.identifier}`)
      .attach('files', fileBuffer, 'test.json')
      .field('locales', JSON.stringify(createTranslationGroup.locales))
      .field('identifier', createTranslationGroup.identifier);

    const { body: translation } = await session.testAgent
      .get(`/v1/translations/groups/${createTranslationGroup.identifier}/locales/${createTranslationGroup.locales[0]}`)
      .send();

    const translationData = translation.data;
    expect(translationData.isoLanguage).to.equal(createTranslationGroup.locales[0]);
    expect(translationData._groupId).to.equal(newTranslationGroupId);
    expect(translationData.translations).to.equal(JSON.stringify(file));

    await session.applyChanges({
      enabled: false,
    });
    await session.switchToProdEnvironment();

    const { body: translationProd } = await session.testAgent
      .get(`/v1/translations/groups/${createTranslationGroup.identifier}/locales/${createTranslationGroup.locales[0]}`)
      .send();

    const translationProdData = translationProd.data;
    expect(translationProdData.isoLanguage).to.equal(createTranslationGroup.locales[0]);
    expect(translationProdData.translations).to.equal(JSON.stringify(file));

    await session.switchToDevEnvironment();

    const editedFileName = 'edited.json';
    const editedFileText = {
      key1: 'value1',
      key2: 'value2',
      key3: 'value3',
    };

    const { body: editTranslationBody } = await session.testAgent
      .patch(
        `/v1/translations/groups/${createTranslationGroup.identifier}/locales/${createTranslationGroup.locales[0]}`
      )
      .send({
        translation: JSON.stringify(editedFileText),
        fileName: editedFileName,
      });

    const editTranslation = editTranslationBody.data;

    expect(editTranslation.isoLanguage).to.equal(createTranslationGroup.locales[0]);
    expect(editTranslation._groupId).to.equal(newTranslationGroupId);
    expect(editTranslation.translations).to.equal(JSON.stringify(editedFileText));
    expect(editTranslation.fileName).to.equal(editedFileName);

    await session.applyChanges({
      enabled: false,
    });
    await session.switchToProdEnvironment();

    const { body: editTranslationProdBody } = await session.testAgent
      .get(`/v1/translations/groups/${createTranslationGroup.identifier}/locales/${createTranslationGroup.locales[0]}`)
      .send();

    const editTranslationProd = editTranslationProdBody.data;

    expect(editTranslationProd.isoLanguage).to.equal(createTranslationGroup.locales[0]);

    expect(editTranslationProd.fileName).to.equal(editedFileName);
    expect(editTranslationProd.translations).to.equal(JSON.stringify(editedFileText));
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - createTranslationGroup({
  name: 'test',
  identifier: 'test',
  locales: ['hi_IN'],
};

describe('[V1 Translations] Edit t...)
 - session(new UserSession();
    await session.initialize();
    await session.testAgent.put(`/v1/organization...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/translations/e2e/v1/get-locales-from-content.e2e-ee.ts
Tamaño: 1168 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';

const createTranslationGroup = {
  name: 'test',
  identifier: 'test',
  locales: ['hi_IN', 'en_US'],
};

const content = 'Hello {{i18n "test.key1"}}, {{i18n "test.key2"}}, {{i18n "test.key3"}}';

describe('[V1 Translations] Get locales from content - /translations/groups/:identifier/locales/:locale (PATCH) #novu-v2', async () => {
  let session: UserSession;

  before(async () => {
    session = new UserSession();
    await session.initialize();
    await session.testAgent.put(`/v1/organizations/language`).send({
      locale: createTranslationGroup.locales[0],
    });

    await session.testAgent.post('/v1/translations/groups').send(createTranslationGroup);
  });

  it('should get locales from the content', async () => {
    const { body } = await session.testAgent.post('/v1/translations/groups/preview/locales').send({
      content,
    });

    const locales = body.data;

    expect(locales.length).to.equal(2);
    expect(locales[0].langIso).to.equal(createTranslationGroup.locales[0]);
    expect(locales[1].langIso).to.equal(createTranslationGroup.locales[1]);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - content('Hello {{i18n "test.key1"}}, {{i18n "test.key2"}}, {{i18n "test.key3"}}';

describe('[V1 Translation...)
 - session(new UserSession();
    await session.initialize();
    await session.testAgent.put(`/v1/organization...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/translations/e2e/v1/get-locales.e2e-ee.ts
Tamaño: 748 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('[V1 Translations] get locales - /translations/locales (GET) #novu-v2', async () => {
  let session: UserSession;

  before(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should get locales', async () => {
    const data = await session.testAgent.get(`/v1/translations/locales`).send();
    const locales: any[] = data.body.data;

    expect(locales.length).to.equal(482);
    expect(Object.keys(locales[0])).to.deep.equal([
      'name',
      'officialName',
      'numeric',
      'alpha2',
      'alpha3',
      'currencyName',
      'currencyAlphabeticCode',
      'langName',
      'langIso',
    ]);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
    await session.initialize();
  });

  it('should get locales', async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/translations/e2e/v1/get-translation-group.e2e-ee.ts
Tamaño: 1314 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('[V1 Translations] get translation group - /translations/groups/:identifier (GET) #novu-v2', async () => {
  let session: UserSession;

  before(async () => {
    session = new UserSession();
    await session.initialize();
    await session.testAgent.put(`/v1/organizations/language`).send({
      locale: 'en_US',
    });
    await session.testAgent.post(`/v1/translations/groups`).send({
      name: 'test',
      identifier: 'test',
      locales: ['en_US'],
    });
  });

  it('should get translation group', async () => {
    const data = await session.testAgent.get(`/v1/translations/groups/test`).send();
    const group = data.body.data;
    const locales = group.translations.map((t) => t.isoLanguage);

    expect(group.name).to.eq('test');
    expect(group.identifier).to.eq('test');
    expect(locales).to.deep.eq(['en_US']);
  });

  it('should return 404 on trying getting a translation group that does not exist', async () => {
    const data = await session.testAgent.get(`/v1/translations/groups/hej`).send();
    const result = data.body;

    expect(result.message).to.equal('Group could not be found');
    expect(result.statusCode).to.be.eq(404);
    expect(result.error).to.be.eq('Not Found');
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
    await session.initialize();
    await session.testAgent.put(`/v1/organization...)
 - locales(group.translations.map((t))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/translations/e2e/v1/get-translation-groups.e2e-ee.ts
Tamaño: 1933 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('[V1 Translations] get translation groups - /translations/groups (GET) #novu-v2', async () => {
  let session: UserSession;

  before(async () => {
    session = new UserSession();
    await session.initialize();
    await session.testAgent.put(`/v1/organizations/language`).send({
      locale: 'en_US',
    });
    await session.testAgent.post(`/v1/translations/groups`).send({
      name: 'test',
      identifier: 'test',
      locales: ['en_US'],
    });
    await session.testAgent.post(`/v1/translations/groups`).send({
      name: 'test1',
      identifier: 'test1',
      locales: ['en_US', 'en_GB'],
    });
    await session.testAgent.post(`/v1/translations/groups`).send({
      name: 'test2',
      identifier: 'test2',
      locales: ['en_US', 'sv_SE'],
    });
  });

  it('should get translation groups', async () => {
    const data = await session.testAgent.get(`/v1/translations/groups`).send();
    const groups = data.body.data;

    const testGroup = groups[0];
    expect(testGroup.identifier).to.equal('test');
    expect(testGroup.name).to.equal('test');
    expect(testGroup.uiConfig.locales).to.deep.equal(['en_US']);
    expect(testGroup.uiConfig.localesMissingTranslations).to.deep.equal(['en_US']);

    const test1Group = groups[1];
    expect(test1Group.identifier).to.equal('test1');
    expect(test1Group.name).to.equal('test1');
    expect(test1Group.uiConfig.locales).to.deep.equal(['en_US', 'en_GB']);
    expect(test1Group.uiConfig.localesMissingTranslations).to.deep.equal(['en_US', 'en_GB']);

    const test2Group = groups[2];
    expect(test2Group.identifier).to.equal('test2');
    expect(test2Group.name).to.equal('test2');
    expect(test2Group.uiConfig.locales).to.deep.equal(['en_US', 'sv_SE']);
    expect(test2Group.uiConfig.localesMissingTranslations).to.deep.equal(['en_US', 'sv_SE']);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
    await session.initialize();
    await session.testAgent.put(`/v1/organization...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/translations/e2e/v1/get-translation.e2e-ee.ts
Tamaño: 936 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('[V1 Translations] GET translation - /translations/groups/:identifier/locales/:locale (GET) #novu-v2', async () => {
  let session: UserSession;

  before(async () => {
    session = new UserSession();
    await session.initialize();
    await session.testAgent.put(`/v1/organizations/language`).send({
      locale: 'en_US',
    });
  });

  it('should get translation', async () => {
    let result = await session.testAgent.post(`/v1/translations/groups`).send({
      name: 'test',
      identifier: 'test',
      locales: ['en_US', 'sv_SE'],
    });

    const group = result.body.data;

    result = await session.testAgent.get(`/v1/translations/groups/test/locales/sv_SE`).send();

    const translation = result.body.data;

    expect(translation.isoLanguage).to.equal('sv_SE');
    expect(translation._groupId).to.equal(group.id);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
    await session.initialize();
    await session.testAgent.put(`/v1/organization...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/translations/e2e/v1/update-default-locale.e2e-ee.ts
Tamaño: 1750 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { OrganizationRepository } from '@novu/dal';
import { getEERepository, UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('[V1 Translations] Update default locale and add new translations - /translations/language (PATCH) #novu-v2', async () => {
  let session: UserSession;
  const organizationRepository = getEERepository<OrganizationRepository>('OrganizationRepository');

  before(async () => {
    session = new UserSession();
    await session.initialize();
    await session.testAgent.put(`/v1/organizations/language`).send({
      locale: 'en_US',
    });
  });

  it('should update default locale and add that locale to groups', async () => {
    await session.testAgent.post(`/v1/translations/groups`).send({
      name: 'test',
      identifier: 'test',
      locales: ['en_US', 'sv_SE'],
    });

    await session.applyChanges({
      enabled: false,
    });

    await session.testAgent.patch(`/v1/translations/language`).send({
      locale: 'en_GB',
    });

    const org = await organizationRepository.findById(session.organization._id);
    expect(org?.defaultLocale).to.be.equal('en_GB');

    const result = await session.testAgent.get(`/v1/translations/groups/test`).send();
    let group = result.body.data;

    let locales = group.translations.map((t) => t.isoLanguage);

    expect(locales).to.deep.equal(['en_US', 'sv_SE', 'en_GB']);

    await session.applyChanges({
      enabled: false,
    });
    await session.switchToProdEnvironment();

    const data = await session.testAgent.get(`/v1/translations/groups/test`).send();
    group = data.body.data;
    locales = group.translations.map((t) => t.isoLanguage);
    expect(locales).to.deep.equal(['en_US', 'sv_SE', 'en_GB']);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - organizationRepository(getEERepository<OrganizationRepository>('OrganizationRepository');

  before(async ())
 - session(new UserSession();
    await session.initialize();
    await session.testAgent.put(`/v1/organization...)
 - locales(group.translations.map((t))
 - locales(group.translations.map((t))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/translations/e2e/v1/update-translation.e2e-ee.ts
Tamaño: 1812 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('[V1 Translations] Update translation - /translations/groups (PATCH) #novu-v2', async () => {
  let session: UserSession;

  before(async () => {
    session = new UserSession();
    await session.initialize();
    await session.testAgent.put(`/v1/organizations/language`).send({
      locale: 'en_US',
    });
  });

  it('should update translation', async () => {
    await session.testAgent.post(`/v1/translations/groups`).send({
      name: 'test',
      identifier: 'test',
      locales: ['en_US', 'sv_SE'],
    });

    await session.applyChanges({
      enabled: false,
    });

    let result = await session.testAgent.patch(`/v1/translations/groups/test`).send({
      name: 'test1',
      identifier: 'test1',
      locales: ['en_US', 'en_GB'],
    });

    let group = result.body.data;

    let locales = group.translations.map((t) => t.isoLanguage);

    expect(group.identifier).to.equal('test1');
    expect(group.name).to.equal('test1');
    expect(locales).to.deep.equal(['en_US', 'en_GB']);

    result = await session.testAgent.get(`/v1/translations/groups/test1/locales/sv_SE`).send();

    expect(result.body.message).to.equal('Translation could not be found');
    expect(result.body.error).to.equal('Not Found');
    expect(result.body.statusCode).to.equal(404);

    await session.applyChanges({
      enabled: false,
    });
    await session.switchToProdEnvironment();

    const data = await session.testAgent.get(`/v1/translations/groups/test1`).send();
    group = data.body.data;
    locales = group.translations.map((t) => t.isoLanguage);
    expect(group.identifier).to.equal('test1');
    expect(group.name).to.equal('test1');
    expect(locales).to.deep.equal(['en_US', 'en_GB']);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
    await session.initialize();
    await session.testAgent.put(`/v1/organization...)
 - locales(group.translations.map((t))
 - locales(group.translations.map((t))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/translations/e2e/v2/create-translation.e2e-ee.ts
Tamaño: 3380 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { LocalizationResourceEnum } from '@novu/dal';
import { ApiServiceLevelEnum, StepTypeEnum, WorkflowCreationSourceEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdkInternalAuth } from '../../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Create/update translation - /v2/translations (POST) #novu-v2', async () => {
  let session: UserSession;
  let novuClient: Novu;
  let workflowId: string;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();

    // Set organization service level to business to avoid payment required errors
    await session.updateOrganizationServiceLevel(ApiServiceLevelEnum.BUSINESS);

    novuClient = initNovuClassSdkInternalAuth(session);

    const { result: workflow } = await novuClient.workflows.create({
      name: 'Test Workflow for Translations',
      workflowId: `test-workflow-${Date.now()}`,
      source: WorkflowCreationSourceEnum.EDITOR,
      active: true,
      isTranslationEnabled: true,
      steps: [
        {
          name: 'In-App Step',
          type: StepTypeEnum.IN_APP,
          controlValues: {
            body: 'Test content',
          },
        },
      ],
    });
    workflowId = workflow.workflowId;
  });

  it('should create new translation successfully', async () => {
    const requestBody = {
      resourceId: workflowId,
      resourceType: LocalizationResourceEnum.WORKFLOW,
      locale: 'en_US',
      content: {
        'welcome.title': 'Welcome',
        'welcome.message': 'Hello there!',
        'button.submit': 'Submit',
      },
    };

    const { body } = await session.testAgent.post('/v2/translations').send(requestBody).expect(200);

    console.log(body);

    expect(body.data.locale).to.equal('en_US');
    expect(body.data.resourceId).to.equal(workflowId);
    expect(body.data.resourceType).to.equal(LocalizationResourceEnum.WORKFLOW);
    expect(body.data.content).to.deep.equal(requestBody.content);
    expect(body.data.createdAt).to.be.a('string');
    expect(body.data.updatedAt).to.be.a('string');
  });

  it('should update existing translation', async () => {
    const originalContent = {
      key1: 'original value',
      key2: 'another value',
    };
    const updatedContent = {
      key1: 'updated value',
      key3: 'new value',
    };

    // Create initial translation
    await session.testAgent
      .post('/v2/translations')
      .send({
        resourceId: workflowId,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: 'en_US',
        content: originalContent,
      })
      .expect(200);

    // Update the translation
    const { body } = await session.testAgent
      .post('/v2/translations')
      .send({
        resourceId: workflowId,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: 'en_US',
        content: updatedContent,
      })
      .expect(200);

    expect(body.data.content).to.deep.equal(updatedContent);
  });

  it('should validate locale format', async () => {
    await session.testAgent
      .post('/v2/translations')
      .send({
        resourceId: workflowId,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: '123',
        content: { key: 'value' },
      })
      .expect(422);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - workflowId(workflow.workflowId;
  });

  it('should create new translation successfully', async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/translations/e2e/v2/delete-translation-group.e2e-ee.ts
Tamaño: 3971 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { LocalizationResourceEnum } from '@novu/dal';
import { ApiServiceLevelEnum, StepTypeEnum, WorkflowCreationSourceEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { initNovuClassSdkInternalAuth } from '../../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Delete translation group - /v2/translations/:resourceType/:resourceId (DELETE) #novu-v2', async () => {
  let session: UserSession;
  let novuClient: Novu;
  let workflowId: string;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();

    // Set organization service level to business to avoid payment required errors
    await session.updateOrganizationServiceLevel(ApiServiceLevelEnum.BUSINESS);

    novuClient = initNovuClassSdkInternalAuth(session);

    const { result: workflow } = await novuClient.workflows.create({
      name: 'Test Workflow for Translation Group Deletion',
      workflowId: `test-workflow-${Date.now()}`,
      source: WorkflowCreationSourceEnum.EDITOR,
      active: true,
      isTranslationEnabled: true,
      steps: [
        {
          name: 'In-App Step',
          type: StepTypeEnum.IN_APP,
          controlValues: {
            body: 'Test content',
          },
        },
      ],
    });
    workflowId = workflow.workflowId;
  });

  it('should delete entire translation group with all translations successfully', async () => {
    const translations = [
      {
        resourceId: workflowId,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: 'en_US',
        content: { 'welcome.title': 'Welcome', 'welcome.message': 'Hello there!' },
      },
      {
        resourceId: workflowId,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: 'es_ES',
        content: { 'welcome.title': 'Bienvenido', 'welcome.message': '¡Hola!' },
      },
      {
        resourceId: workflowId,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: 'fr_FR',
        content: { 'welcome.title': 'Bienvenue', 'welcome.message': 'Bonjour!' },
      },
    ];

    // Create multiple translations
    for (const translation of translations) {
      await session.testAgent.post('/v2/translations').send(translation).expect(200);
    }

    // Delete the entire translation group
    await session.testAgent.delete(`/v2/translations/${LocalizationResourceEnum.WORKFLOW}/${workflowId}`).expect(204);

    // Verify all translations are deleted
    for (const translation of translations) {
      await session.testAgent
        .get(`/v2/translations/${translation.resourceType}/${translation.resourceId}/${translation.locale}`)
        .expect(404);
    }
  });

  it('should return 404 when trying to delete non-existent translation group', async () => {
    const fakeWorkflowId = '507f1f77bcf86cd799439011';

    await session.testAgent
      .delete(`/v2/translations/${LocalizationResourceEnum.WORKFLOW}/${fakeWorkflowId}`)
      .expect(404);
  });

  it('should return 404 when trying to delete non-existent translation group for workflow without translations enabled', async () => {
    // Create a workflow with translations disabled (no translation group created)
    const { result: workflowWithoutTranslations } = await novuClient.workflows.create({
      name: 'Workflow Without Translations',
      workflowId: `workflow-no-translations-${Date.now()}`,
      source: WorkflowCreationSourceEnum.EDITOR,
      active: true,
      isTranslationEnabled: false, // This prevents automatic translation group creation
      steps: [
        {
          name: 'No Translation Step',
          type: StepTypeEnum.IN_APP,
          controlValues: {
            body: 'No translation content',
          },
        },
      ],
    });

    await session.testAgent
      .delete(`/v2/translations/${LocalizationResourceEnum.WORKFLOW}/${workflowWithoutTranslations.workflowId}`)
      .expect(404);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - workflowId(workflow.workflowId;
  });

  it('should delete entire translation group with all translations succe...)
 - translations([
      {
        resourceId: workflowId,
        resourceType: LocalizationResourceEnum.WORKFLOW,
 ...)
 - fakeWorkflowId('507f1f77bcf86cd799439011';

    await session.testAgent
      .delete(`/v2/translations/${Localizat...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/translations/e2e/v2/delete-translation.e2e-ee.ts
Tamaño: 6308 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { LocalizationResourceEnum } from '@novu/dal';
import { ApiServiceLevelEnum, StepTypeEnum, WorkflowCreationSourceEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdkInternalAuth } from '../../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Delete translation - /v2/translations/:resourceType/:resourceId/:locale (DELETE) #novu-v2', async () => {
  let session: UserSession;
  let novuClient: Novu;
  let workflowId: string;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();

    // Set organization service level to business to avoid payment required errors
    await session.updateOrganizationServiceLevel(ApiServiceLevelEnum.BUSINESS);

    novuClient = initNovuClassSdkInternalAuth(session);

    const { result: workflow } = await novuClient.workflows.create({
      name: 'Test Workflow for Translations',
      workflowId: `test-workflow-${Date.now()}`,
      source: WorkflowCreationSourceEnum.EDITOR,
      active: true,
      isTranslationEnabled: true,
      steps: [
        {
          name: 'In-App Step',
          type: StepTypeEnum.IN_APP,
          controlValues: {
            body: 'Test content',
          },
        },
      ],
    });
    workflowId = workflow.workflowId;
  });

  it('should delete existing translation successfully', async () => {
    const translationContent = {
      'welcome.title': 'Welcome',
      'welcome.message': 'Hello there!',
      'button.submit': 'Submit',
    };

    // Create translation first
    await session.testAgent
      .post('/v2/translations')
      .send({
        resourceId: workflowId,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: 'en_US',
        content: translationContent,
      })
      .expect(200);

    // Verify translation exists
    await session.testAgent
      .get(`/v2/translations/${LocalizationResourceEnum.WORKFLOW}/${workflowId}/en_US`)
      .expect(200);

    // Delete the translation
    await session.testAgent
      .delete(`/v2/translations/${LocalizationResourceEnum.WORKFLOW}/${workflowId}/en_US`)
      .expect(204);

    // Verify translation no longer exists
    await session.testAgent
      .get(`/v2/translations/${LocalizationResourceEnum.WORKFLOW}/${workflowId}/en_US`)
      .expect(404);
  });

  it('should return 404 when trying to delete non-existent translation', async () => {
    await session.testAgent
      .delete(`/v2/translations/${LocalizationResourceEnum.WORKFLOW}/${workflowId}/fr_FR`)
      .expect(404);
  });

  it('should return 404 when trying to delete translation for non-existent workflow', async () => {
    const fakeWorkflowId = '507f1f77bcf86cd799439011';

    await session.testAgent
      .delete(`/v2/translations/${LocalizationResourceEnum.WORKFLOW}/${fakeWorkflowId}/en_US`)
      .expect(404);
  });

  it('should validate locale format in URL parameter', async () => {
    await session.testAgent
      .delete(`/v2/translations/${LocalizationResourceEnum.WORKFLOW}/${workflowId}/invalid-locale-123`)
      .expect(400);
  });

  it('should handle underscores in locale and normalize them', async () => {
    const translationContent = {
      'test.key': 'Test value',
    };

    // Create translation with underscore format
    await session.testAgent
      .post('/v2/translations')
      .send({
        resourceId: workflowId,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: 'en_US',
        content: translationContent,
      })
      .expect(200);

    // Delete with dash format (should be normalized to underscore)
    await session.testAgent
      .delete(`/v2/translations/${LocalizationResourceEnum.WORKFLOW}/${workflowId}/en-US`)
      .expect(204);

    // Verify translation no longer exists
    await session.testAgent
      .get(`/v2/translations/${LocalizationResourceEnum.WORKFLOW}/${workflowId}/en_US`)
      .expect(404);
  });

  it('should delete only the specified locale, leaving others intact', async () => {
    const englishContent = {
      'welcome.title': 'Welcome',
      'welcome.message': 'Hello there!',
    };

    const frenchContent = {
      'welcome.title': 'Bienvenue',
      'welcome.message': 'Bonjour!',
    };

    // Create translations in multiple locales
    await session.testAgent
      .post('/v2/translations')
      .send({
        resourceId: workflowId,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: 'en_US',
        content: englishContent,
      })
      .expect(200);

    await session.testAgent
      .post('/v2/translations')
      .send({
        resourceId: workflowId,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: 'fr_FR',
        content: frenchContent,
      })
      .expect(200);

    // Delete only the English translation
    await session.testAgent
      .delete(`/v2/translations/${LocalizationResourceEnum.WORKFLOW}/${workflowId}/en_US`)
      .expect(204);

    // Verify English translation is gone
    await session.testAgent
      .get(`/v2/translations/${LocalizationResourceEnum.WORKFLOW}/${workflowId}/en_US`)
      .expect(404);

    // Verify French translation still exists
    const { body } = await session.testAgent
      .get(`/v2/translations/${LocalizationResourceEnum.WORKFLOW}/${workflowId}/fr_FR`)
      .expect(200);
    expect(body.data.content).to.deep.equal(frenchContent);
  });

  it('should work with complex locale codes', async () => {
    const translationContent = {
      'test.key': 'Chinese Simplified content',
    };

    // Create translation with complex locale
    await session.testAgent
      .post('/v2/translations')
      .send({
        resourceId: workflowId,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: 'zh_CN',
        content: translationContent,
      })
      .expect(200);

    // Delete the translation
    await session.testAgent
      .delete(`/v2/translations/${LocalizationResourceEnum.WORKFLOW}/${workflowId}/zh_CN`)
      .expect(204);

    // Verify translation no longer exists
    await session.testAgent
      .get(`/v2/translations/${LocalizationResourceEnum.WORKFLOW}/${workflowId}/zh_CN`)
      .expect(404);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - workflowId(workflow.workflowId;
  });

  it('should delete existing translation successfully', async ())
 - translationContent({
      'welcome.title': 'Welcome',
      'welcome.message': 'Hello there!',
      'button.submit': ...)
 - fakeWorkflowId('507f1f77bcf86cd799439011';

    await session.testAgent
      .delete(`/v2/translations/${Localizat...)
 - translationContent({
      'test.key': 'Test value',
    };

    // Create translation with underscore format
    await...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/translations/e2e/v2/export-master-json.e2e-ee.ts
Tamaño: 4970 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { LocalizationResourceEnum } from '@novu/dal';
import { ApiServiceLevelEnum, StepTypeEnum, WorkflowCreationSourceEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdkInternalAuth } from '../../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Export master JSON - /v2/translations/master-json (GET) #novu-v2', async () => {
  let session: UserSession;
  let novuClient: Novu;
  let workflowId1: string;
  let workflowId2: string;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();

    // Set organization service level to business to avoid payment required errors
    await session.updateOrganizationServiceLevel(ApiServiceLevelEnum.BUSINESS);

    novuClient = initNovuClassSdkInternalAuth(session);

    // Create first workflow with translations
    const { result: workflow1 } = await novuClient.workflows.create({
      name: 'User Onboarding Workflow',
      workflowId: `user-onboarding-workflow-${Date.now()}`,
      source: WorkflowCreationSourceEnum.EDITOR,
      active: true,
      isTranslationEnabled: true,
      steps: [
        {
          name: 'Welcome Email',
          type: StepTypeEnum.EMAIL,
          controlValues: {
            subject: 'Welcome to our platform',
            body: 'Welcome {{payload.name}}!',
          },
        },
      ],
    });
    workflowId1 = workflow1.workflowId;

    // Create second workflow without translations (for testing filtering)
    const { result: workflow2 } = await novuClient.workflows.create({
      name: 'No Translation Workflow',
      workflowId: `no-translation-workflow-${Date.now()}`,
      source: WorkflowCreationSourceEnum.EDITOR,
      active: true,
      isTranslationEnabled: false,
      steps: [
        {
          name: 'Simple Email',
          type: StepTypeEnum.EMAIL,
          controlValues: {
            subject: 'Simple notification',
            body: 'This workflow has no translations',
          },
        },
      ],
    });
    workflowId2 = workflow2.workflowId;

    // Create translations for first workflow in multiple locales
    await session.testAgent
      .post('/v2/translations')
      .send({
        resourceId: workflowId1,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: 'en_US',
        content: {
          'welcome.title': 'Welcome to our platform',
          'welcome.message': 'Hello {{payload.name}}, welcome aboard!',
        },
      })
      .expect(200);

    await session.testAgent
      .post('/v2/translations')
      .send({
        resourceId: workflowId1,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: 'es_ES',
        content: {
          'welcome.title': 'Bienvenido a nuestra plataforma',
          'welcome.message': 'Hola {{payload.name}}, ¡bienvenido!',
        },
      })
      .expect(200);
  });

  it('should export master JSON with correct structure and content filtering', async () => {
    const { body } = await session.testAgent.get('/v2/translations/master-json?locale=en_US').expect(200);

    // Verify response structure
    expect(body.data).to.have.property('workflows');
    expect(body.data.workflows).to.be.an('object');

    // Should include workflow with translations
    expect(body.data.workflows).to.have.property(workflowId1);

    // Should not include workflow without translations
    expect(body.data.workflows).to.not.have.property(workflowId2);

    // Verify content structure and liquid variables
    expect(body.data.workflows[workflowId1]).to.deep.equal({
      'welcome.title': 'Welcome to our platform',
      'welcome.message': 'Hello {{payload.name}}, welcome aboard!',
    });
  });

  it('should filter by locale correctly', async () => {
    // Test Spanish locale
    const { body: spanishBody } = await session.testAgent.get('/v2/translations/master-json?locale=es_ES').expect(200);

    expect(spanishBody.data.workflows).to.have.property(workflowId1);
    expect(spanishBody.data.workflows[workflowId1]).to.deep.equal({
      'welcome.title': 'Bienvenido a nuestra plataforma',
      'welcome.message': 'Hola {{payload.name}}, ¡bienvenido!',
    });

    // Test non-existent locale
    const { body: emptyBody } = await session.testAgent.get('/v2/translations/master-json?locale=de_DE').expect(200);

    expect(emptyBody.data.workflows).to.be.an('object');
    expect(Object.keys(emptyBody.data.workflows)).to.have.lengthOf(0);
  });

  it('should work without locale parameter', async () => {
    const { body } = await session.testAgent.get('/v2/translations/master-json').expect(200);

    expect(body.data).to.have.property('workflows');
    expect(body.data.workflows).to.be.an('object');
  });

  it('should validate locale format', async () => {
    await session.testAgent.get('/v2/translations/master-json?locale=invalid-locale').expect(422);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - workflowId2(workflow2.workflowId;

    // Create translations for first workflow in multiple locales
    await s...)
 - locale(en_US').expect(200);

    // Verify response structure
    expect(body.data).to.have.property('workf...)
 - locale(de_DE').expect(200);

    expect(emptyBody.data.workflows).to.be.an('object');
    expect(Object.key...)
Declaraciones 'export' encontradas:
- export  master

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/translations/e2e/v2/get-translation-group.e2e-ee.ts
Tamaño: 10036 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { LocalizationResourceEnum } from '@novu/dal';
import { ApiServiceLevelEnum, StepTypeEnum, WorkflowCreationSourceEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdkInternalAuth } from '../../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Get single translation group - /v2/translations/group/:resourceType/:resourceId (GET) #novu-v2', async () => {
  let session: UserSession;
  let novuClient: Novu;
  let workflowId: string;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();

    // Set organization service level to business to avoid payment required errors
    await session.updateOrganizationServiceLevel(ApiServiceLevelEnum.BUSINESS);

    novuClient = initNovuClassSdkInternalAuth(session);

    const { result: workflow } = await novuClient.workflows.create({
      name: 'Test Workflow for Translation Group',
      workflowId: `test-workflow-${Date.now()}`,
      source: WorkflowCreationSourceEnum.EDITOR,
      active: true,
      isTranslationEnabled: true,
      steps: [
        {
          name: 'In-App Step',
          type: StepTypeEnum.IN_APP,
          controlValues: {
            body: 'Test content',
          },
        },
      ],
    });
    workflowId = workflow.workflowId;
  });

  it('should get translation group with multiple locales', async () => {
    const translations = [
      {
        resourceId: workflowId,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: 'en_US',
        content: {
          'welcome.title': 'Welcome',
          'welcome.message': 'Hello there!',
          'button.submit': 'Submit',
        },
      },
      {
        resourceId: workflowId,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: 'es_ES',
        content: {
          'welcome.title': 'Bienvenido',
          'welcome.message': '¡Hola!',
          'button.submit': 'Enviar',
        },
      },
      {
        resourceId: workflowId,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: 'fr_FR',
        content: {
          'welcome.title': 'Bienvenue',
          'welcome.message': 'Bonjour!',
          'button.submit': 'Soumettre',
        },
      },
    ];

    // Create translations
    for (const translation of translations) {
      await session.testAgent.post('/v2/translations').send(translation).expect(200);
    }

    // Get the translation group
    const { body } = await session.testAgent
      .get(`/v2/translations/group/${LocalizationResourceEnum.WORKFLOW}/${workflowId}`)
      .expect(200);

    expect(body.data.resourceId).to.equal(workflowId);
    expect(body.data.resourceType).to.equal(LocalizationResourceEnum.WORKFLOW);
    expect(body.data.resourceName).to.equal('Test Workflow for Translation Group');
    expect(body.data.locales).to.be.an('array');
    expect(body.data.locales).to.have.lengthOf(3);
    expect(body.data.locales).to.include.members(['en_US', 'es_ES', 'fr_FR']);
    expect(body.data.createdAt).to.be.a('string');
    expect(body.data.updatedAt).to.be.a('string');
  });

  it('should include outdatedLocales when present', async () => {
    // First, set organization default locale and target locales
    await session.testAgent
      .patch('/v1/organizations/settings')
      .send({
        defaultLocale: 'en_US',
        targetLocales: ['es_ES', 'fr_FR', 'de_DE'], // Configure target locales
      })
      .expect(200);

    const translations = [
      {
        resourceId: workflowId,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: 'en_US',
        content: {
          'welcome.title': 'Welcome',
          'welcome.message': 'Hello there!',
        },
      },
      {
        resourceId: workflowId,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: 'es_ES',
        content: {
          'welcome.title': 'Bienvenido',
          'welcome.message': '¡Hola!',
        },
      },
    ];

    /*
     * Create translations for en_US (default) and es_ES only
     * fr_FR and de_DE are configured as targets but missing = outdated
     */
    for (const translation of translations) {
      await session.testAgent.post('/v2/translations').send(translation).expect(200);
    }

    // Update the default locale (en_US) to add new keys, making es_ES out of sync
    await session.testAgent
      .post('/v2/translations')
      .send({
        resourceId: workflowId,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: 'en_US',
        content: {
          'welcome.title': 'Welcome Updated',
          'welcome.message': 'Hello there, updated!',
          'new.key': 'New content', // This key is missing in es_ES
        },
      })
      .expect(200);

    // Get the translation group
    const { body } = await session.testAgent
      .get(`/v2/translations/group/${LocalizationResourceEnum.WORKFLOW}/${workflowId}`)
      .expect(200);

    expect(body.data.resourceId).to.equal(workflowId);
    expect(body.data.locales).to.include.members(['en_US', 'es_ES']);

    // Should include outdatedLocales: es_ES (out of sync), fr_FR (missing), de_DE (missing)
    expect(body.data.outdatedLocales).to.be.an('array');
    expect(body.data.outdatedLocales).to.have.lengthOf(3);
    expect(body.data.outdatedLocales).to.include.members(['es_ES', 'fr_FR', 'de_DE']);
  });

  it('should not include outdatedLocales when no target locales are configured', async () => {
    // Ensure no target locales are configured (only default locale)
    await session.testAgent
      .patch('/v1/organizations/settings')
      .send({
        defaultLocale: 'en_US',
        // No targetLocales specified
      })
      .expect(200);

    // Create some translations
    await session.testAgent
      .post('/v2/translations')
      .send({
        resourceId: workflowId,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: 'en_US',
        content: {
          'welcome.title': 'Welcome',
          'welcome.message': 'Hello there!',
        },
      })
      .expect(200);

    // Even if we have other locales not in target list
    await session.testAgent
      .post('/v2/translations')
      .send({
        resourceId: workflowId,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: 'es_ES',
        content: {
          'welcome.title': 'Bienvenido',
        },
      })
      .expect(200);

    // Get the translation group
    const { body } = await session.testAgent
      .get(`/v2/translations/group/${LocalizationResourceEnum.WORKFLOW}/${workflowId}`)
      .expect(200);

    expect(body.data.resourceId).to.equal(workflowId);
    expect(body.data.locales).to.include.members(['en_US', 'es_ES']);

    // Should not include outdatedLocales since no target locales are configured
    expect(body.data).to.not.have.property('outdatedLocales');
  });

  it('should return 404 for non-existent translation group', async () => {
    const fakeWorkflowId = '507f1f77bcf86cd799439011';

    await session.testAgent
      .get(`/v2/translations/group/${LocalizationResourceEnum.WORKFLOW}/${fakeWorkflowId}`)
      .expect(404);
  });

  it('should return 404 for workflow without translations', async () => {
    // Create a workflow without any translations
    const { result: workflowWithoutTranslations } = await novuClient.workflows.create({
      name: 'Workflow Without Translations',
      workflowId: `workflow-no-translations-${Date.now()}`,
      source: WorkflowCreationSourceEnum.EDITOR,
      active: true,
      isTranslationEnabled: false, // This prevents automatic translation group creation
      steps: [
        {
          name: 'No Translation Step',
          type: StepTypeEnum.IN_APP,
          controlValues: {
            body: 'No translation content',
          },
        },
      ],
    });

    await session.testAgent
      .get(`/v2/translations/group/${LocalizationResourceEnum.WORKFLOW}/${workflowWithoutTranslations.workflowId}`)
      .expect(404);
  });

  it('should return consistent structure with list endpoint', async () => {
    // Create translation
    await session.testAgent
      .post('/v2/translations')
      .send({
        resourceId: workflowId,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: 'en_US',
        content: { 'test.key': 'Test value' },
      })
      .expect(200);

    // Get single group
    const { body: singleGroup } = await session.testAgent
      .get(`/v2/translations/group/${LocalizationResourceEnum.WORKFLOW}/${workflowId}`)
      .expect(200);

    // Get list and find the same group
    const { body: listResponse } = await session.testAgent.get('/v2/translations/list').expect(200);

    const groupFromList = listResponse.data.find((group: any) => group.resourceId === workflowId);

    // Both should have the same structure
    expect(singleGroup.data).to.have.property('resourceId');
    expect(singleGroup.data).to.have.property('resourceType');
    expect(singleGroup.data).to.have.property('resourceName');
    expect(singleGroup.data).to.have.property('locales');
    expect(singleGroup.data).to.have.property('createdAt');
    expect(singleGroup.data).to.have.property('updatedAt');

    expect(groupFromList).to.have.property('resourceId');
    expect(groupFromList).to.have.property('resourceType');
    expect(groupFromList).to.have.property('resourceName');
    expect(groupFromList).to.have.property('locales');
    expect(groupFromList).to.have.property('createdAt');
    expect(groupFromList).to.have.property('updatedAt');

    // Values should match
    expect(singleGroup.data.resourceId).to.equal(groupFromList.resourceId);
    expect(singleGroup.data.resourceType).to.equal(groupFromList.resourceType);
    expect(singleGroup.data.resourceName).to.equal(groupFromList.resourceName);
    expect(singleGroup.data.locales).to.deep.equal(groupFromList.locales);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - workflowId(workflow.workflowId;
  });

  it('should get translation group with multiple locales', async ())
 - fakeWorkflowId('507f1f77bcf86cd799439011';

    await session.testAgent
      .get(`/v2/translations/group/${Locali...)
 - groupFromList(listResponse.data.find((group: any))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/translations/e2e/v2/get-translation.e2e-ee.ts
Tamaño: 3075 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { LocalizationResourceEnum } from '@novu/dal';
import { ApiServiceLevelEnum, StepTypeEnum, WorkflowCreationSourceEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdkInternalAuth } from '../../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Get single translation - /v2/translations/:resourceType/:resourceId/:locale (GET) #novu-v2', async () => {
  let session: UserSession;
  let novuClient: Novu;
  let workflowId: string;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();

    // Set organization service level to business to avoid payment required errors
    await session.updateOrganizationServiceLevel(ApiServiceLevelEnum.BUSINESS);

    novuClient = initNovuClassSdkInternalAuth(session);

    const { result: workflow } = await novuClient.workflows.create({
      name: 'Test Workflow for Translations',
      workflowId: `test-workflow-${Date.now()}`,
      source: WorkflowCreationSourceEnum.EDITOR,
      active: true,
      isTranslationEnabled: true,
      steps: [
        {
          name: 'In-App Step',
          type: StepTypeEnum.IN_APP,
          controlValues: {
            body: 'Test content',
          },
        },
      ],
    });
    workflowId = workflow.workflowId;
  });

  it('should get existing translation', async () => {
    const translationContent = {
      'welcome.title': 'Welcome',
      'welcome.message': 'Hello there!',
    };

    // Create translation first
    await session.testAgent
      .post('/v2/translations')
      .send({
        resourceId: workflowId,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: 'en_US',
        content: translationContent,
      })
      .expect(200);

    // Get the translation
    const { body } = await session.testAgent
      .get(`/v2/translations/${LocalizationResourceEnum.WORKFLOW}/${workflowId}/en_US`)
      .expect(200);

    expect(body.data.resourceId).to.equal(workflowId);
    expect(body.data.resourceType).to.equal(LocalizationResourceEnum.WORKFLOW);
    expect(body.data.locale).to.equal('en_US');
    expect(body.data.content).to.deep.equal(translationContent);
    expect(body.data.createdAt).to.be.a('string');
    expect(body.data.updatedAt).to.be.a('string');
  });

  it('should return 404 for non-existent translation', async () => {
    await session.testAgent
      .get(`/v2/translations/${LocalizationResourceEnum.WORKFLOW}/${workflowId}/fr_FR`)
      .expect(404);
  });

  it('should return 404 for non-existent workflow', async () => {
    const fakeWorkflowId = '507f1f77bcf86cd799439011';

    await session.testAgent
      .get(`/v2/translations/${LocalizationResourceEnum.WORKFLOW}/${fakeWorkflowId}/en_US`)
      .expect(404);
  });

  it('should validate locale format in URL parameter', async () => {
    await session.testAgent
      .get(`/v2/translations/${LocalizationResourceEnum.WORKFLOW}/${workflowId}/invalid-locale-123`)
      .expect(400);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - workflowId(workflow.workflowId;
  });

  it('should get existing translation', async ())
 - fakeWorkflowId('507f1f77bcf86cd799439011';

    await session.testAgent
      .get(`/v2/translations/${Localization...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/translations/e2e/v2/get-translations-list.e2e-ee.ts
Tamaño: 13991 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { LocalizationResourceEnum } from '@novu/dal';
import { ApiServiceLevelEnum, StepTypeEnum, WorkflowCreationSourceEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdkInternalAuth } from '../../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Get translations list - /v2/translations/list (GET) #novu-v2', async () => {
  let session: UserSession;
  let novuClient: Novu;
  let workflowId1: string;
  let workflowId2: string;
  let workflowId3: string;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();

    // Set organization service level to business to avoid payment required errors
    await session.updateOrganizationServiceLevel(ApiServiceLevelEnum.BUSINESS);

    novuClient = initNovuClassSdkInternalAuth(session);

    // Create first workflow
    const { result: workflow1 } = await novuClient.workflows.create({
      name: 'User Onboarding Workflow',
      workflowId: `user-onboarding-workflow-${Date.now()}`,
      source: WorkflowCreationSourceEnum.EDITOR,
      active: true,
      isTranslationEnabled: true,
      steps: [
        {
          name: 'Welcome Email',
          type: StepTypeEnum.EMAIL,
          controlValues: {
            subject: 'Welcome to our platform',
            body: 'Welcome {{payload.name}}!',
          },
        },
      ],
    });
    workflowId1 = workflow1.workflowId;

    // Create second workflow
    const { result: workflow2 } = await novuClient.workflows.create({
      name: 'Order Confirmation Workflow',
      workflowId: `order-confirmation-workflow-${Date.now()}`,
      source: WorkflowCreationSourceEnum.EDITOR,
      active: true,
      isTranslationEnabled: true,
      steps: [
        {
          name: 'Order Email',
          type: StepTypeEnum.EMAIL,
          controlValues: {
            subject: 'Order confirmed',
            body: 'Your order #{{payload.orderId}} is confirmed',
          },
        },
      ],
    });
    workflowId2 = workflow2.workflowId;

    // Create third workflow
    const { result: workflow3 } = await novuClient.workflows.create({
      name: 'Password Reset Workflow',
      workflowId: `password-reset-workflow-${Date.now()}`,
      source: WorkflowCreationSourceEnum.EDITOR,
      active: true,
      isTranslationEnabled: true,
      steps: [
        {
          name: 'Reset Email',
          type: StepTypeEnum.EMAIL,
          controlValues: {
            subject: 'Reset your password',
            body: 'Click here to reset: {{payload.resetLink}}',
          },
        },
      ],
    });
    workflowId3 = workflow3.workflowId;

    // Create translations for different workflows and locales
    const translations = [
      // User Onboarding - Multiple locales
      {
        resourceId: workflowId1,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: 'en_US',
        content: {
          'welcome.title': 'Welcome to our platform',
          'welcome.message': 'Hello {{payload.name}}, welcome aboard!',
          'button.getStarted': 'Get Started',
        },
      },
      {
        resourceId: workflowId1,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: 'es_ES',
        content: {
          'welcome.title': 'Bienvenido a nuestra plataforma',
          'welcome.message': 'Hola {{payload.name}}, ¡bienvenido!',
          'button.getStarted': 'Empezar',
        },
      },
      {
        resourceId: workflowId1,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: 'fr_FR',
        content: {
          'welcome.title': 'Bienvenue sur notre plateforme',
          'welcome.message': 'Bonjour {{payload.name}}, bienvenue!',
          'button.getStarted': 'Commencer',
        },
      },
      // Order Confirmation - Two locales
      {
        resourceId: workflowId2,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: 'en_US',
        content: {
          'order.title': 'Order Confirmation',
          'order.message': 'Your order #{{payload.orderId}} has been confirmed',
          'order.total': 'Total: {{payload.total}}',
        },
      },
      {
        resourceId: workflowId2,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: 'de_DE',
        content: {
          'order.title': 'Bestellbestätigung',
          'order.message': 'Ihre Bestellung #{{payload.orderId}} wurde bestätigt',
          'order.total': 'Gesamt: {{payload.total}} EUR',
        },
      },
      // Password Reset - One locale
      {
        resourceId: workflowId3,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: 'en_US',
        content: {
          'reset.title': 'Password Reset',
          'reset.message': 'Click the link below to reset your password',
          'reset.button': 'Reset Password',
        },
      },
    ];

    // Create all translations
    for (const translation of translations) {
      await session.testAgent.post('/v2/translations').send(translation).expect(200);
    }
  });

  it('should get paginated list of translation groups without query', async () => {
    const { body } = await session.testAgent.get('/v2/translations/list').expect(200);

    expect(body.data).to.be.an('array');
    expect(body.total).to.be.a('number');
    expect(body.limit).to.equal(50); // Default limit
    expect(body.offset).to.equal(0); // Default offset

    // Should have 3 groups (one per workflow)
    expect(body.total).to.equal(3);
    expect(body.data).to.have.lengthOf(3);

    // Verify structure of translation groups
    body.data.forEach((group: any) => {
      expect(group).to.have.property('resourceId');
      expect(group).to.have.property('resourceType');
      expect(group).to.have.property('resourceName');
      expect(group).to.have.property('locales');
      expect(group).to.have.property('createdAt');
      expect(group).to.have.property('updatedAt');
      expect(group.locales).to.be.an('array');
      expect(group.resourceType).to.equal(LocalizationResourceEnum.WORKFLOW);
    });

    // Verify specific locale counts
    const onboardingGroup = body.data.find((group: any) => group.resourceId === workflowId1);
    const orderGroup = body.data.find((group: any) => group.resourceId === workflowId2);
    const resetGroup = body.data.find((group: any) => group.resourceId === workflowId3);

    expect(onboardingGroup.locales).to.have.lengthOf(3);
    expect(onboardingGroup.locales).to.include.members(['en_US', 'es_ES', 'fr_FR']);

    expect(orderGroup.locales).to.have.lengthOf(2);
    expect(orderGroup.locales).to.include.members(['en_US', 'de_DE']);

    expect(resetGroup.locales).to.have.lengthOf(1);
    expect(resetGroup.locales).to.include('en_US');
  });

  it('should handle pagination with custom limit and offset', async () => {
    // Get first page with limit 2
    const { body: page1 } = await session.testAgent.get('/v2/translations/list?limit=2&offset=0').expect(200);

    expect(page1.data).to.have.lengthOf(2);
    expect(page1.total).to.equal(3);
    expect(page1.limit).to.equal(2);
    expect(page1.offset).to.equal(0);

    // Get second page
    const { body: page2 } = await session.testAgent.get('/v2/translations/list?limit=2&offset=2').expect(200);

    expect(page2.data).to.have.lengthOf(1);
    expect(page2.total).to.equal(3);
    expect(page2.limit).to.equal(2);
    expect(page2.offset).to.equal(2);

    // Verify no overlap between pages
    const page1Ids = page1.data.map((group: any) => group.resourceId);
    const page2Ids = page2.data.map((group: any) => group.resourceId);
    const intersection = page1Ids.filter((id: string) => page2Ids.includes(id));
    expect(intersection).to.have.lengthOf(0);

    // Verify locales are populated correctly in paginated results
    page1.data.forEach((group: any) => {
      expect(group.locales).to.be.an('array');
      expect(group.locales.length).to.be.greaterThan(0);
    });

    page2.data.forEach((group: any) => {
      expect(group.locales).to.be.an('array');
      expect(group.locales.length).to.be.greaterThan(0);
    });
  });

  it('should filter translation groups by search query matching workflow name', async () => {
    const { body } = await session.testAgent.get('/v2/translations/list?query=onboarding').expect(200);

    expect(body.data).to.have.lengthOf(1);
    expect(body.total).to.equal(1);

    const group = body.data[0];
    expect(group.resourceId).to.equal(workflowId1);
    expect(group.locales).to.be.an('array');
    expect(group.locales).to.have.lengthOf(3);
    expect(group.locales).to.include.members(['en_US', 'es_ES', 'fr_FR']);
  });

  it('should filter translation groups by search query matching workflow ID', async () => {
    // Search by partial workflow ID
    const searchTerm = workflowId2.split('-')[0]; // Get the prefix part
    const { body } = await session.testAgent.get(`/v2/translations/list?query=${searchTerm}`).expect(200);

    expect(body.data).to.have.lengthOf(1);
    expect(body.total).to.equal(1);
    expect(body.data[0].resourceId).to.equal(workflowId2);
    expect(body.data[0].locales).to.have.lengthOf(2);
    expect(body.data[0].locales).to.include.members(['en_US', 'de_DE']);
  });

  it('should return empty results for non-matching search query', async () => {
    const { body } = await session.testAgent.get('/v2/translations/list?query=nonexistent').expect(200);

    expect(body.data).to.have.lengthOf(0);
    expect(body.total).to.equal(0);
  });

  it('should handle case-insensitive search', async () => {
    const { body } = await session.testAgent.get('/v2/translations/list?query=ORDER').expect(200);

    expect(body.data).to.have.lengthOf(1);
    expect(body.total).to.equal(1);
    expect(body.data[0].resourceId).to.equal(workflowId2);
    expect(body.data[0].locales).to.have.lengthOf(2);
    expect(body.data[0].locales).to.include.members(['en_US', 'de_DE']);
  });

  it('should combine search query with pagination', async () => {
    // Create additional workflows to test pagination with search
    const { result: workflow4 } = await novuClient.workflows.create({
      name: 'User Onboarding Advanced Workflow',
      workflowId: `user-onboarding-advanced-${Date.now()}`,
      source: WorkflowCreationSourceEnum.EDITOR,
      active: true,
      isTranslationEnabled: true,
      steps: [
        {
          name: 'Advanced Welcome',
          type: StepTypeEnum.EMAIL,
          controlValues: {
            subject: 'Advanced welcome',
            body: 'Advanced onboarding process',
          },
        },
      ],
    });

    // Add translation for the new workflow
    await session.testAgent
      .post('/v2/translations')
      .send({
        resourceId: workflow4.workflowId,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: 'en_US',
        content: { 'advanced.welcome': 'Advanced Welcome' },
      })
      .expect(200);

    // Search for "onboarding" should now return 2 results
    const { body } = await session.testAgent.get('/v2/translations/list?query=onboarding&limit=1&offset=0').expect(200);

    expect(body.data).to.have.lengthOf(1);
    expect(body.total).to.equal(2);
    expect(body.limit).to.equal(1);
    expect(body.offset).to.equal(0);

    // Verify the returned group has locales
    expect(body.data[0].locales).to.be.an('array');
    expect(body.data[0].locales.length).to.be.greaterThan(0);
  });

  it('should return correct locale counts for each translation group', async () => {
    const { body } = await session.testAgent.get('/v2/translations/list').expect(200);

    // Find the user onboarding workflow
    const onboardingGroup = body.data.find((group: any) => group.resourceId === workflowId1);
    expect(onboardingGroup).to.exist;
    expect(onboardingGroup.locales).to.be.an('array');
    expect(onboardingGroup.locales).to.have.lengthOf(3);
    expect(onboardingGroup.locales).to.include.members(['en_US', 'es_ES', 'fr_FR']);

    // Find the order confirmation workflow
    const orderGroup = body.data.find((group: any) => group.resourceId === workflowId2);
    expect(orderGroup).to.exist;
    expect(orderGroup.locales).to.be.an('array');
    expect(orderGroup.locales).to.have.lengthOf(2);
    expect(orderGroup.locales).to.include.members(['en_US', 'de_DE']);

    // Find the password reset workflow
    const resetGroup = body.data.find((group: any) => group.resourceId === workflowId3);
    expect(resetGroup).to.exist;
    expect(resetGroup.locales).to.be.an('array');
    expect(resetGroup.locales).to.have.lengthOf(1);
    expect(resetGroup.locales).to.include('en_US');
  });

  it('should handle large offset gracefully', async () => {
    const { body } = await session.testAgent.get('/v2/translations/list?offset=1000').expect(200);

    expect(body.data).to.have.lengthOf(0);
    expect(body.total).to.equal(3);
    expect(body.offset).to.equal(1000);
  });

  it('should validate limit parameter bounds', async () => {
    // Test with limit = 10 (should work)
    const { body: smallLimit } = await session.testAgent.get('/v2/translations/list?limit=10').expect(200);

    expect(smallLimit.data).to.have.lengthOf(3); // Only 3 items available
    expect(smallLimit.limit).to.equal(10);

    // Verify locales are populated
    smallLimit.data.forEach((group: any) => {
      expect(group.locales).to.be.an('array');
      expect(group.locales.length).to.be.greaterThan(0);
    });

    const { body: largeLimit } = await session.testAgent.get('/v2/translations/list?limit=100').expect(200);

    expect(largeLimit.data).to.have.lengthOf(3); // Should return all available
    expect(largeLimit.limit).to.equal(100);

    // Verify locales are populated
    largeLimit.data.forEach((group: any) => {
      expect(group.locales).to.be.an('array');
      expect(group.locales.length).to.be.greaterThan(0);
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - translations([
      // User Onboarding - Multiple locales
      {
        resourceId: workflowId1,
        resou...)
 - onboardingGroup(body.data.find((group: any))
 - orderGroup(body.data.find((group: any))
 - resetGroup(body.data.find((group: any))
 - page1Ids(page1.data.map((group: any))
 - page2Ids(page2.data.map((group: any))
 - intersection(page1Ids.filter((id: string))
 - group(body.data[0];
    expect(group.resourceId).to.equal(workflowId1);
    expect(group.locales).to.be.an...)
 - query(${searchTerm}`).expect(200);

    expect(body.data).to.have.lengthOf(1);
    expect(body.total).to.e...)
 - query(nonexistent').expect(200);

    expect(body.data).to.have.lengthOf(0);
    expect(body.total).to.equ...)
 - query(ORDER').expect(200);

    expect(body.data).to.have.lengthOf(1);
    expect(body.total).to.equal(1);...)
 - offset(0').expect(200);

    expect(body.data).to.have.lengthOf(1);
    expect(body.total).to.equal(2);
   ...)
 - onboardingGroup(body.data.find((group: any))
 - orderGroup(body.data.find((group: any))
 - resetGroup(body.data.find((group: any))
 - offset(1000').expect(200);

    expect(body.data).to.have.lengthOf(0);
    expect(body.total).to.equal(3);
...)
 - limit(10').expect(200);

    expect(smallLimit.data).to.have.lengthOf(3); // Only 3 items available
    ex...)
 - limit(100').expect(200);

    expect(largeLimit.data).to.have.lengthOf(3); // Should return all available
...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/translations/e2e/v2/import-master-json.e2e-ee.ts
Tamaño: 8250 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { LocalizationResourceEnum } from '@novu/dal';
import { ApiServiceLevelEnum, StepTypeEnum, WorkflowCreationSourceEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdkInternalAuth } from '../../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Import master JSON - /v2/translations/master-json (POST) #novu-v2', async () => {
  let session: UserSession;
  let novuClient: Novu;
  let workflowId1: string;
  let workflowId2: string;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();

    // Set organization service level to business to avoid payment required errors
    await session.updateOrganizationServiceLevel(ApiServiceLevelEnum.BUSINESS);

    novuClient = initNovuClassSdkInternalAuth(session);

    // Create first workflow with translations enabled
    const { result: workflow1 } = await novuClient.workflows.create({
      name: 'User Onboarding Workflow',
      workflowId: `user-onboarding-workflow-${Date.now()}`,
      source: WorkflowCreationSourceEnum.EDITOR,
      active: true,
      isTranslationEnabled: true,
      steps: [
        {
          name: 'Welcome Email',
          type: StepTypeEnum.EMAIL,
          controlValues: {
            subject: 'Welcome to our platform',
            body: 'Welcome {{payload.name}}!',
          },
        },
      ],
    });
    workflowId1 = workflow1.workflowId;

    // Create second workflow without translations for testing graceful skipping
    const { result: workflow2 } = await novuClient.workflows.create({
      name: 'No Translation Workflow',
      workflowId: `no-translation-workflow-${Date.now()}`,
      source: WorkflowCreationSourceEnum.EDITOR,
      active: true,
      isTranslationEnabled: false,
      steps: [
        {
          name: 'Simple Email',
          type: StepTypeEnum.EMAIL,
          controlValues: {
            subject: 'Simple notification',
            body: 'This workflow has no translations',
          },
        },
      ],
    });
    workflowId2 = workflow2.workflowId;
  });

  it('should import master JSON with valid workflows only', async () => {
    const masterJson = {
      workflows: {
        [workflowId1]: {
          'welcome.title': 'Welcome to our platform',
          'welcome.message': 'Hello {{payload.name | upcase}}, welcome aboard!',
          'button.getStarted': 'Get Started',
        },
        [workflowId2]: {
          'disabled.key': 'Content for workflow with translations disabled',
        },
      },
    };

    const { body } = await session.testAgent
      .post('/v2/translations/master-json')
      .send({
        locale: 'en_US',
        masterJson,
      })
      .expect(200);

    expect(body.data.success).to.be.true;
    expect(body.data.message).to.include('2 resource'); // Both valid workflows

    // Test new response structure
    expect(body.data.successful).to.be.an('array');
    expect(body.data.successful).to.have.lengthOf(2);
    expect(body.data.successful).to.include(workflowId1);
    expect(body.data.successful).to.include(workflowId2);
    expect(body.data.failed).to.be.undefined; // No failures

    // Verify translation was created for workflow1
    const { body: translation1 } = await session.testAgent
      .get(`/v2/translations/${LocalizationResourceEnum.WORKFLOW}/${workflowId1}/en_US`)
      .expect(200);

    expect(translation1.data.content).to.deep.equal(masterJson.workflows[workflowId1]);

    // Verify translation was created for workflow2 (even though translations disabled)
    const { body: translation2 } = await session.testAgent
      .get(`/v2/translations/${LocalizationResourceEnum.WORKFLOW}/${workflowId2}/en_US`)
      .expect(200);

    expect(translation2.data.content).to.deep.equal(masterJson.workflows[workflowId2]);
  });

  it('should gracefully skip missing workflows but import valid ones', async () => {
    const nonExistentWorkflowId = '507f1f77bcf86cd799439011';
    const masterJson = {
      workflows: {
        [workflowId1]: {
          'valid.key': 'Valid content',
        },
        [nonExistentWorkflowId]: {
          'invalid.key': 'Content for non-existent workflow',
        },
      },
    };

    const { body } = await session.testAgent
      .post('/v2/translations/master-json')
      .send({
        locale: 'en_US',
        masterJson,
      })
      .expect(200);

    expect(body.data.success).to.be.true;
    expect(body.data.message).to.include('Partial import completed');

    // Test enhanced response structure for partial success
    expect(body.data.successful).to.be.an('array');
    expect(body.data.successful).to.have.lengthOf(1);
    expect(body.data.successful).to.include(workflowId1);

    expect(body.data.failed).to.be.an('array');
    expect(body.data.failed).to.have.lengthOf(1);
    expect(body.data.failed).to.include(nonExistentWorkflowId);

    // Verify valid translation was created
    const { body: translation1 } = await session.testAgent
      .get(`/v2/translations/${LocalizationResourceEnum.WORKFLOW}/${workflowId1}/en_US`)
      .expect(200);

    expect(translation1.data.content).to.deep.equal(masterJson.workflows[workflowId1]);
  });

  it('should handle complete failure gracefully', async () => {
    const nonExistentWorkflowId1 = '507f1f77bcf86cd799439011';
    const nonExistentWorkflowId2 = '507f1f77bcf86cd799439012';
    const masterJson = {
      workflows: {
        [nonExistentWorkflowId1]: {
          'invalid.key1': 'Content for non-existent workflow 1',
        },
        [nonExistentWorkflowId2]: {
          'invalid.key2': 'Content for non-existent workflow 2',
        },
      },
    };

    const { body } = await session.testAgent
      .post('/v2/translations/master-json')
      .send({
        locale: 'en_US',
        masterJson,
      })
      .expect(200);

    expect(body.data.success).to.be.false;
    expect(body.data.message).to.include('Failed to import any resources');

    // Test response structure for complete failure
    expect(body.data.successful).to.be.undefined; // No successes
    expect(body.data.failed).to.be.an('array');
    expect(body.data.failed).to.have.lengthOf(2);
    expect(body.data.failed).to.include(nonExistentWorkflowId1);
    expect(body.data.failed).to.include(nonExistentWorkflowId2);
  });

  it('should update existing translations correctly', async () => {
    // Create initial translation
    await session.testAgent
      .post('/v2/translations')
      .send({
        resourceId: workflowId1,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        locale: 'en_US',
        content: {
          'old.key': 'Old value',
          'existing.key': 'Will be updated',
        },
      })
      .expect(200);

    const masterJson = {
      workflows: {
        [workflowId1]: {
          'existing.key': 'Updated value',
          'new.key': 'New value',
        },
      },
    };

    const { body } = await session.testAgent
      .post('/v2/translations/master-json')
      .send({
        locale: 'en_US',
        masterJson,
      })
      .expect(200);

    expect(body.data.success).to.be.true;
    expect(body.data.successful).to.include(workflowId1);
    expect(body.data.failed).to.be.undefined;

    // Verify translation was updated (replaces entire content)
    const { body: translation } = await session.testAgent
      .get(`/v2/translations/${LocalizationResourceEnum.WORKFLOW}/${workflowId1}/en_US`)
      .expect(200);

    expect(translation.data.content).to.deep.equal(masterJson.workflows[workflowId1]);
    expect(translation.data.content).to.not.have.property('old.key');
  });

  it('should handle empty master JSON gracefully', async () => {
    const masterJson = {
      workflows: {},
    };

    const { body } = await session.testAgent
      .post('/v2/translations/master-json')
      .send({
        locale: 'en_US',
        masterJson,
      })
      .expect(200);

    expect(body.data.success).to.be.false;
    expect(body.data.message).to.include('No supported resources found');
    expect(body.data.successful).to.be.undefined;
    expect(body.data.failed).to.be.undefined;
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - workflowId2(workflow2.workflowId;
  });

  it('should import master JSON with valid workflows only', async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/translations/e2e/v2/upload-master-json.e2e-ee.ts
Tamaño: 8415 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { LocalizationResourceEnum } from '@novu/dal';
import { ApiServiceLevelEnum, StepTypeEnum, WorkflowCreationSourceEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdkInternalAuth } from '../../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Upload master JSON file - /v2/translations/master-json/upload (POST) #novu-v2', async () => {
  let session: UserSession;
  let novuClient: Novu;
  let workflowId: string;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();

    // Set organization service level to business to avoid payment required errors
    await session.updateOrganizationServiceLevel(ApiServiceLevelEnum.BUSINESS);

    novuClient = initNovuClassSdkInternalAuth(session);

    // Create workflow for basic integration test
    const { result: workflow } = await novuClient.workflows.create({
      name: 'Test Workflow',
      workflowId: `test-workflow-${Date.now()}`,
      source: WorkflowCreationSourceEnum.EDITOR,
      active: true,
      isTranslationEnabled: true,
      steps: [
        {
          name: 'Test Email',
          type: StepTypeEnum.EMAIL,
          controlValues: {
            subject: 'Test subject',
            body: 'Test body',
          },
        },
      ],
    });
    workflowId = workflow.workflowId;
  });

  it('should upload master JSON file successfully', async () => {
    const masterJson = {
      workflows: {
        [workflowId]: {
          'test.key': 'Test value',
          'another.key': 'Another value',
        },
      },
    };

    const { body } = await session.testAgent
      .post('/v2/translations/master-json/upload')
      .attach('file', Buffer.from(JSON.stringify(masterJson)), 'en_US.json')
      .expect(200);

    expect(body.data.success).to.be.true;
    expect(body.data.message).to.include('1 resource');

    // Test new response structure
    expect(body.data.successful).to.be.an('array');
    expect(body.data.successful).to.have.lengthOf(1);
    expect(body.data.successful).to.include(workflowId);
    expect(body.data.failed).to.be.undefined; // No failures

    // Verify translation was created (basic integration test)
    const { body: translation } = await session.testAgent
      .get(`/v2/translations/${LocalizationResourceEnum.WORKFLOW}/${workflowId}/en_US`)
      .expect(200);

    expect(translation.data.content).to.deep.equal(masterJson.workflows[workflowId]);
  });

  it('should handle mixed success and failure in uploaded file', async () => {
    const nonExistentWorkflowId = '507f1f77bcf86cd799439011';
    const masterJson = {
      workflows: {
        [workflowId]: {
          'valid.key': 'Valid content',
        },
        [nonExistentWorkflowId]: {
          'invalid.key': 'Content for non-existent workflow',
        },
      },
    };

    const { body } = await session.testAgent
      .post('/v2/translations/master-json/upload')
      .field('locale', 'en_US')
      .attach('file', Buffer.from(JSON.stringify(masterJson)), 'en_US.json')
      .expect(200);

    expect(body.data.success).to.be.true;
    expect(body.data.message).to.include('Partial import completed');

    // Test enhanced response structure for mixed results
    expect(body.data.successful).to.be.an('array');
    expect(body.data.successful).to.have.lengthOf(1);
    expect(body.data.successful).to.include(workflowId);

    expect(body.data.failed).to.be.an('array');
    expect(body.data.failed).to.have.lengthOf(1);
    expect(body.data.failed).to.include(nonExistentWorkflowId);
  });

  it('should validate file requirements', async () => {
    const masterJson = {
      workflows: {
        [workflowId]: {
          'test.key': 'Test value',
        },
      },
    };

    // Test missing file
    await session.testAgent.post('/v2/translations/master-json/upload').expect(400);

    // Test multiple files (should only allow one)
    await session.testAgent
      .post('/v2/translations/master-json/upload')
      .attach('file', Buffer.from(JSON.stringify(masterJson)), 'en_US.json')
      .attach('file', Buffer.from(JSON.stringify(masterJson)), 'fr_FR.json')
      .expect(400);
  });

  it('should validate filename format', async () => {
    const masterJson = {
      workflows: {
        [workflowId]: {
          'test.key': 'Test value',
        },
      },
    };

    // Test invalid filename patterns
    const invalidFilenames = ['invalid-filename.json', 'en_US-master.json', 'en_US.txt', 'notlocale.json', 'en.json'];

    for (const filename of invalidFilenames) {
      await session.testAgent
        .post('/v2/translations/master-json/upload')
        .field('locale', 'en_US')
        .attach('file', Buffer.from(JSON.stringify(masterJson)), filename)
        .expect(400);
    }

    // Test valid filename patterns
    const validFilenames = ['en_US.json', 'fr_FR.json', 'zh_CN.json'];

    for (const filename of validFilenames) {
      const { body } = await session.testAgent
        .post('/v2/translations/master-json/upload')
        .field('locale', 'en_US')
        .attach('file', Buffer.from(JSON.stringify(masterJson)), filename)
        .expect(200);

      // Verify response structure for valid uploads
      expect(body.data.success).to.be.true;
      expect(body.data.successful).to.be.an('array');
      expect(body.data.successful).to.include(workflowId);
    }
  });

  it('should handle file processing correctly', async () => {
    const masterJson = {
      workflows: {
        [workflowId]: {
          'unicode.test': 'Hello 👋 世界 🌍',
          'liquid.test': 'Hello {{payload.name | upcase}}',
        },
      },
    };

    // Test formatted JSON (with indentation)
    const formattedJson = JSON.stringify(masterJson, null, 2);
    const { body: formattedResponse } = await session.testAgent
      .post('/v2/translations/master-json/upload')
      .field('locale', 'en_US')
      .attach('file', Buffer.from(formattedJson, 'utf8'), 'en_US.json')
      .expect(200);

    expect(formattedResponse.data.success).to.be.true;
    expect(formattedResponse.data.successful).to.include(workflowId);

    // Test compressed JSON
    const compressedJson = JSON.stringify(masterJson);
    const { body: compressedResponse } = await session.testAgent
      .post('/v2/translations/master-json/upload')
      .field('locale', 'fr_FR')
      .attach('file', Buffer.from(compressedJson, 'utf8'), 'fr_FR.json')
      .expect(200);

    expect(compressedResponse.data.success).to.be.true;
    expect(compressedResponse.data.successful).to.include(workflowId);

    // Verify Unicode and liquid variables are preserved
    const { body: translation } = await session.testAgent
      .get(`/v2/translations/${LocalizationResourceEnum.WORKFLOW}/${workflowId}/en_US`)
      .expect(200);

    expect(translation.data.content['unicode.test']).to.equal('Hello 👋 世界 🌍');
    expect(translation.data.content['liquid.test']).to.equal('Hello {{payload.name | upcase}}');
  });

  it('should reject invalid JSON files', async () => {
    // Test invalid JSON content
    await session.testAgent
      .post('/v2/translations/master-json/upload')
      .field('locale', 'en_US')
      .attach('file', Buffer.from('invalid json content'), 'en_US.json')
      .expect(400);

    // Test empty file
    await session.testAgent
      .post('/v2/translations/master-json/upload')
      .field('locale', 'en_US')
      .attach('file', Buffer.from(''), 'en_US.json')
      .expect(400);

    // Test non-JSON file
    await session.testAgent
      .post('/v2/translations/master-json/upload')
      .field('locale', 'en_US')
      .attach('file', Buffer.from('<xml>not json</xml>'), 'en_US.json')
      .expect(400);
  });

  it('should handle empty workflows object in uploaded file', async () => {
    const masterJson = {
      workflows: {},
    };

    const { body } = await session.testAgent
      .post('/v2/translations/master-json/upload')
      .field('locale', 'en_US')
      .attach('file', Buffer.from(JSON.stringify(masterJson)), 'en_US.json')
      .expect(200);

    expect(body.data.success).to.be.false;
    expect(body.data.message).to.include('No supported resources found');
    expect(body.data.successful).to.be.undefined;
    expect(body.data.failed).to.be.undefined;
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - workflowId(workflow.workflowId;
  });

  it('should upload master JSON file successfully', async ())
 - masterJson({
      workflows: {
        [workflowId]: {
          'test.key': 'Test value',
        },
      },...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/translations/e2e/v2/upload-translations.e2e-ee.ts
Tamaño: 10302 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { LocalizationResourceEnum } from '@novu/dal';
import { ApiServiceLevelEnum, StepTypeEnum, WorkflowCreationSourceEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdkInternalAuth } from '../../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Upload translation files - /v2/translations/upload (POST) #novu-v2', async () => {
  let session: UserSession;
  let novuClient: Novu;
  let workflowId: string;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();

    // Set organization service level to business to avoid payment required errors
    await session.updateOrganizationServiceLevel(ApiServiceLevelEnum.BUSINESS);

    /*
     * Configure organization locales with a more minimal set
     * Only configure locales that are commonly used across tests
     */
    await session.testAgent
      .patch('/v1/organizations/settings')
      .send({
        defaultLocale: 'en_US',
        targetLocales: ['es_ES', 'fr_FR', 'de_DE', 'it_IT'], // Include all locales that might be used in tests
      })
      .expect(200);

    novuClient = initNovuClassSdkInternalAuth(session);

    const { result: workflow } = await novuClient.workflows.create({
      name: 'Test Workflow for Translations',
      workflowId: `test-workflow-${Date.now()}`,
      source: WorkflowCreationSourceEnum.EDITOR,
      active: true,
      isTranslationEnabled: true,
      steps: [
        {
          name: 'In-App Step',
          type: StepTypeEnum.IN_APP,
          controlValues: {
            body: 'Test content',
          },
        },
      ],
    });
    workflowId = workflow.workflowId;
  });

  it('should upload single translation file', async () => {
    const translationContent = {
      'welcome.title': 'Welcome',
      'welcome.message': 'Hello there!',
      'button.submit': 'Submit',
    };

    const { body } = await session.testAgent
      .post('/v2/translations/upload')
      .field('resourceId', workflowId)
      .field('resourceType', LocalizationResourceEnum.WORKFLOW)
      .attach('files', Buffer.from(JSON.stringify(translationContent)), 'en_US.json')
      .expect(200);

    expect(body.data.totalFiles).to.equal(1);
    expect(body.data.successfulUploads).to.equal(1);
    expect(body.data.failedUploads).to.equal(0);
    expect(body.data.errors).to.be.an('array').that.is.empty;

    // Verify the translation was created
    const { body: translation } = await session.testAgent
      .get(`/v2/translations/${LocalizationResourceEnum.WORKFLOW}/${workflowId}/en_US`)
      .expect(200);

    expect(translation.data.content).to.deep.equal(translationContent);
  });

  it('should upload multiple translation files', async () => {
    const enContent = {
      'welcome.title': 'Welcome',
      'welcome.message': 'Hello there!',
    };

    const esContent = {
      'welcome.title': 'Bienvenido',
      'welcome.message': '¡Hola!',
    };

    const { body } = await session.testAgent
      .post('/v2/translations/upload')
      .field('resourceId', workflowId)
      .field('resourceType', LocalizationResourceEnum.WORKFLOW)
      .attach('files', Buffer.from(JSON.stringify(enContent)), 'en_US.json')
      .attach('files', Buffer.from(JSON.stringify(esContent)), 'es_ES.json')
      .expect(200);

    expect(body.data.totalFiles).to.equal(2);
    expect(body.data.successfulUploads).to.equal(2);
    expect(body.data.failedUploads).to.equal(0);
    expect(body.data.errors).to.be.an('array').that.is.empty;

    // Verify both translations were created
    const { body: translationGroup } = await session.testAgent
      .get(`/v2/translations/group/${LocalizationResourceEnum.WORKFLOW}/${workflowId}`)
      .expect(200);

    /*
     * The locales should include configured locales plus any uploaded locales
     * Configured: en_US (default), es_ES, fr_FR, de_DE, it_IT (targets)
     */
    expect(translationGroup.data.locales).to.have.lengthOf(5);
    expect(translationGroup.data.locales).to.include('en_US');
    expect(translationGroup.data.locales).to.include('es_ES');
    expect(translationGroup.data.locales).to.include('fr_FR');
    expect(translationGroup.data.locales).to.include('de_DE');
    expect(translationGroup.data.locales).to.include('it_IT');
  });

  it('should update existing translation when uploading same locale', async () => {
    const originalContent = { key1: 'original value' };
    const updatedContent = { key1: 'updated value', key2: 'new value' };

    // Upload initial translation
    await session.testAgent
      .post('/v2/translations/upload')
      .field('resourceId', workflowId)
      .field('resourceType', LocalizationResourceEnum.WORKFLOW)
      .attach('files', Buffer.from(JSON.stringify(originalContent)), 'en_US.json')
      .expect(200);

    // Upload updated translation
    const { body } = await session.testAgent
      .post('/v2/translations/upload')
      .field('resourceId', workflowId)
      .field('resourceType', LocalizationResourceEnum.WORKFLOW)
      .attach('files', Buffer.from(JSON.stringify(updatedContent)), 'en_US.json')
      .expect(200);

    expect(body.data.successfulUploads).to.equal(1);

    // Verify the content was updated
    const { body: translation } = await session.testAgent
      .get(`/v2/translations/${LocalizationResourceEnum.WORKFLOW}/${workflowId}/en_US`)
      .expect(200);

    expect(translation.data.content).to.deep.equal(updatedContent);
  });

  it('should handle different filename patterns', async () => {
    const content = { key: 'value' };

    const testCases = [
      { filename: 'en_US.json', expectedLocale: 'en_US' },
      { filename: 'fr_FR.json', expectedLocale: 'fr_FR' },
      { filename: 'de_DE.json', expectedLocale: 'de_DE' },
      { filename: 'it_IT.json', expectedLocale: 'it_IT' },
    ];

    for (const testCase of testCases) {
      const { body } = await session.testAgent
        .post('/v2/translations/upload')
        .field('resourceId', workflowId)
        .field('resourceType', LocalizationResourceEnum.WORKFLOW)
        .attach('files', Buffer.from(JSON.stringify(content)), testCase.filename)
        .expect(200);

      expect(body.data.successfulUploads).to.equal(1);

      // Verify the locale was extracted correctly
      const { body: translation } = await session.testAgent
        .get(`/v2/translations/${LocalizationResourceEnum.WORKFLOW}/${workflowId}/${testCase.expectedLocale}`)
        .expect(200);

      expect(translation.data.locale).to.equal(testCase.expectedLocale);
    }
  });

  it('should reject invalid JSON files', async () => {
    const { body } = await session.testAgent
      .post('/v2/translations/upload')
      .field('resourceId', workflowId)
      .field('resourceType', LocalizationResourceEnum.WORKFLOW)
      .attach('files', Buffer.from('invalid json content'), 'en_US.json')
      .expect(400);

    expect(body.message).to.include('No valid translation files were found');
  });

  it('should reject files with invalid locale patterns', async () => {
    const content = { key: 'value' };

    const { body } = await session.testAgent
      .post('/v2/translations/upload')
      .field('resourceId', workflowId)
      .field('resourceType', LocalizationResourceEnum.WORKFLOW)
      .attach('files', Buffer.from(JSON.stringify(content)), 'invalid-filename.json')
      .expect(400);

    expect(body.message).to.include('invalid names or formats');
    expect(body.errors).to.be.an('array').that.is.not.empty;
    expect(body.errors[0]).to.include('invalid-filename.json');
  });

  it('should reject uploads with invalid filename patterns', async () => {
    const validContent = { key: 'value' };

    // This test should fail at validation level because invalid-name.json has invalid locale pattern
    const { body } = await session.testAgent
      .post('/v2/translations/upload')
      .field('resourceId', workflowId)
      .field('resourceType', LocalizationResourceEnum.WORKFLOW)
      .attach('files', Buffer.from(JSON.stringify(validContent)), 'en_US.json')
      .attach('files', Buffer.from('invalid json'), 'es_ES.json')
      .attach('files', Buffer.from(JSON.stringify(validContent)), 'invalid-name.json')
      .expect(400);

    expect(body.message).to.include('invalid names or formats');
    expect(body.errors).to.be.an('array').that.is.not.empty;
    expect(body.errors[0]).to.include('invalid-name.json');
  });

  it('should handle mixed success and failure uploads with valid filenames', async () => {
    const validContent = { key: 'value' };

    const { body } = await session.testAgent
      .post('/v2/translations/upload')
      .field('resourceId', workflowId)
      .field('resourceType', LocalizationResourceEnum.WORKFLOW)
      .attach('files', Buffer.from(JSON.stringify(validContent)), 'en_US.json')
      .attach('files', Buffer.from('invalid json'), 'es_ES.json')
      .attach('files', Buffer.from(JSON.stringify(validContent)), 'fr_FR.json')
      .expect(200);

    expect(body.data.totalFiles).to.equal(3);
    expect(body.data.successfulUploads).to.equal(2);
    expect(body.data.failedUploads).to.equal(1);
    expect(body.data.errors).to.have.lengthOf(1);
    expect(body.data.errors[0]).to.include("Failed to process file 'es_ES.json'");
  });

  it('should reject uploads for locales not configured in organization settings', async () => {
    const validContent = { key: 'value' };

    /*
     * Try to upload a locale that is not in the configured locales
     * Configured locales are: en_US (default), es_ES, fr_FR, de_DE, it_IT
     */
    const { body } = await session.testAgent
      .post('/v2/translations/upload')
      .field('resourceId', workflowId)
      .field('resourceType', LocalizationResourceEnum.WORKFLOW)
      .attach('files', Buffer.from(JSON.stringify(validContent)), 'ja_JP.json') // Japanese not configured
      .expect(400);

    expect(body.message).to.include('The following locales are not configured for your organization: ja_JP');
    expect(body.message).to.include('Please add these locales in your translation settings');
    expect(body.message).to.include('configured locales: en_US, es_ES, fr_FR, de_DE, it_IT');
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - workflowId(workflow.workflowId;
  });

  it('should upload single translation file', async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/user/user.controller.ts
Tamaño: 5020 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Body, ClassSerializerInterceptor, Controller, Get, Put, UseInterceptors } from '@nestjs/common';
import { ApiExcludeController, ApiOperation, ApiTags } from '@nestjs/swagger';
import { PinoLogger } from '@novu/application-generic';
import { UserSessionData } from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { ExternalApiAccessible } from '../auth/framework/external-api.decorator';
import { ApiCommonResponses, ApiResponse } from '../shared/framework/response.decorator';
import { UserSession } from '../shared/framework/user.decorator';
import { ChangeProfileEmailDto } from './dtos/change-profile-email.dto';
import { UpdateProfileRequestDto } from './dtos/update-profile-request.dto';
import { UserOnboardingRequestDto } from './dtos/user-onboarding-request.dto';
import { UserOnboardingTourRequestDto } from './dtos/user-onboarding-tour-request.dto';
import { UserResponseDto } from './dtos/user-response.dto';
import { GetMyProfileCommand } from './usecases/get-my-profile/get-my-profile.dto';
import { GetMyProfileUsecase } from './usecases/get-my-profile/get-my-profile.usecase';
import { UpdateNameAndProfilePictureCommand } from './usecases/update-name-and-profile-picture/update-name-and-profile-picture.command';
import { UpdateNameAndProfilePicture } from './usecases/update-name-and-profile-picture/update-name-and-profile-picture.usecase';
import { UpdateOnBoardingCommand } from './usecases/update-on-boarding/update-on-boarding.command';
import { UpdateOnBoardingUsecase } from './usecases/update-on-boarding/update-on-boarding.usecase';
import { UpdateOnBoardingTourCommand } from './usecases/update-on-boarding-tour/update-on-boarding-tour.command';
import { UpdateOnBoardingTourUsecase } from './usecases/update-on-boarding-tour/update-on-boarding-tour.usecase';
import { UpdateProfileEmailCommand } from './usecases/update-profile-email/update-profile-email.command';
import { UpdateProfileEmail } from './usecases/update-profile-email/update-profile-email.usecase';

@ApiCommonResponses()
@Controller('/users')
@ApiTags('Users')
@UseInterceptors(ClassSerializerInterceptor)
@RequireAuthentication()
@ApiExcludeController()
export class UsersController {
  constructor(
    private getMyProfileUsecase: GetMyProfileUsecase,
    private updateOnBoardingUsecase: UpdateOnBoardingUsecase,
    private updateOnBoardingTourUsecase: UpdateOnBoardingTourUsecase,
    private updateProfileEmailUsecase: UpdateProfileEmail,
    private updateNameAndProfilePictureUsecase: UpdateNameAndProfilePicture,
    private logger: PinoLogger
  ) {
    this.logger.setContext(this.constructor.name);
  }

  @Get('/me')
  @ApiResponse(UserResponseDto)
  @ApiOperation({
    summary: 'Get User',
  })
  @ExternalApiAccessible()
  async getMyProfile(@UserSession() user: UserSessionData): Promise<UserResponseDto> {
    this.logger.trace('Getting User');
    this.logger.debug(`User id: ${user._id}`);
    this.logger.trace('Creating GetMyProfileCommand');

    const command = GetMyProfileCommand.create({
      userId: user._id,
    });

    return await this.getMyProfileUsecase.execute(command);
  }

  @Put('/profile/email')
  async updateProfileEmail(
    @UserSession() user: UserSessionData,
    @Body() body: ChangeProfileEmailDto
  ): Promise<UserResponseDto> {
    return await this.updateProfileEmailUsecase.execute(
      UpdateProfileEmailCommand.create({
        userId: user._id,
        email: body.email,
        environmentId: user.environmentId,
      })
    );
  }

  @Put('/onboarding')
  @ApiResponse(UserResponseDto)
  @ApiOperation({
    summary: 'Update onboarding',
  })
  @ExternalApiAccessible()
  async updateOnBoarding(
    @UserSession() user: UserSessionData,
    @Body() body: UserOnboardingRequestDto
  ): Promise<UserResponseDto> {
    return await this.updateOnBoardingUsecase.execute(
      UpdateOnBoardingCommand.create({
        userId: user._id,
        showOnBoarding: body.showOnBoarding,
      })
    );
  }

  @Put('/onboarding-tour')
  async updateOnBoardingTour(
    @UserSession() user: UserSessionData,
    @Body() body: UserOnboardingTourRequestDto
  ): Promise<UserResponseDto> {
    return await this.updateOnBoardingTourUsecase.execute(
      UpdateOnBoardingTourCommand.create({
        userId: user._id,
        showOnBoardingTour: body.showOnBoardingTour,
      })
    );
  }

  @Put('/profile')
  @ApiOperation({
    summary: 'Update user name and profile picture',
  })
  @ExternalApiAccessible()
  async updateProfile(
    @UserSession() user: UserSessionData,
    @Body() body: UpdateProfileRequestDto
  ): Promise<UserResponseDto> {
    return await this.updateNameAndProfilePictureUsecase.execute(
      UpdateNameAndProfilePictureCommand.create({
        userId: user._id,
        environmentId: user.environmentId,
        firstName: body.firstName,
        lastName: body.lastName,
        profilePicture: body.profilePicture,
        organizationId: user.organizationId,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UsersController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/user/user.module.ts
Tamaño: 348 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Module } from '@nestjs/common';
import { SharedModule } from '../shared/shared.module';
import { USE_CASES } from './usecases';
import { UsersController } from './user.controller';

@Module({
  imports: [SharedModule],
  controllers: [UsersController],
  providers: [...USE_CASES],
  exports: [...USE_CASES],
})
export class UserModule {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UserModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/user/dtos/change-profile-email.dto.ts
Tamaño: 139 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsEmail } from 'class-validator';

export class ChangeProfileEmailDto {
  @IsDefined()
  @IsEmail()
  email: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ChangeProfileEmailDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/user/dtos/update-profile-request.dto.ts
Tamaño: 740 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import type { IUpdateUserProfile } from '@novu/shared';
import { IsOptional, IsUrl } from 'class-validator';

import { IsImageUrl } from '../../shared/validators/image.validator';

const protocols = process.env.NODE_ENV === 'production' ? ['https'] : ['http', 'https'];

export class UpdateProfileRequestDto implements IUpdateUserProfile {
  @ApiProperty()
  firstName: string;

  @ApiProperty()
  lastName: string;

  @ApiProperty()
  @IsUrl({
    require_protocol: true,
    protocols,
    require_tld: false,
  })
  @IsImageUrl({
    message: 'Logo must be a valid image URL with one of the following extensions: jpg, jpeg, png, gif, svg',
  })
  @IsOptional()
  profilePicture?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateProfileRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/user/dtos/user-onboarding-request.dto.ts
Tamaño: 134 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';

export class UserOnboardingRequestDto {
  @ApiProperty()
  showOnBoarding: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UserOnboardingRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/user/dtos/user-onboarding-tour-request.dto.ts
Tamaño: 141 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';

export class UserOnboardingTourRequestDto {
  @ApiProperty()
  showOnBoardingTour: number;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UserOnboardingTourRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/user/dtos/user-response.dto.ts
Tamaño: 888 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IUserEntity, JobTitleEnum } from '@novu/shared';

export class ServicesHashesDto {
  @ApiProperty()
  intercom?: string;

  @ApiProperty()
  plain?: string;
}

export class UserResponseDto implements IUserEntity {
  @ApiProperty()
  _id: string;

  @ApiPropertyOptional()
  resetToken?: string;

  @ApiPropertyOptional()
  resetTokenDate?: string;

  @ApiProperty()
  firstName?: string | null;

  @ApiProperty()
  lastName?: string | null;

  @ApiProperty()
  email?: string | null;

  @ApiProperty()
  profilePicture?: string | null;

  @ApiProperty()
  createdAt: string;

  @ApiPropertyOptional()
  showOnBoarding?: boolean;

  @ApiProperty()
  servicesHashes?: ServicesHashesDto;

  @ApiPropertyOptional({
    enum: JobTitleEnum,
  })
  jobTitle?: JobTitleEnum;

  @ApiProperty()
  hasPassword: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ServicesHashesDto
- export class UserResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/user/e2e/email-change.e2e.ts
Tamaño: 1265 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Change Profile Email - /users/profile/email (PUT) #novu-v0-os', async () => {
  let session: UserSession;
  let existingSession: UserSession;

  before(async () => {
    session = new UserSession();
    await session.initialize();

    existingSession = new UserSession();
    await existingSession.initialize();
  });

  it('should throw when existing email provided', async () => {
    const { body } = await session.testAgent.put('/v1/users/profile/email').send({
      email: existingSession.user.email,
    });

    expect(body.statusCode).to.equal(400);
    expect(body.message).to.equal('E-mail is invalid or taken');
  });

  it('should update the e-mail address', async () => {
    const { body } = await session.testAgent.put('/v1/users/profile/email').send({
      email: 'another-email@gmail.com',
    });

    expect(body.data.email).to.equal('another-email@gmail.com');
  });

  it('should normalize the updated the e-mail address', async () => {
    const { body } = await session.testAgent.put('/v1/users/profile/email').send({
      email: 'another-email-12+123@gmail.com',
    });

    expect(body.data.email).to.equal('another-email-12@gmail.com');
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - existingSession(new UserSession();
    await existingSession.initialize();
  });

  it('should throw when existing e...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/user/e2e/get-me.e2e.ts
Tamaño: 641 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('User Profile #novu-v0-os', async () => {
  let session: UserSession;

  before(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should return a correct user profile', async () => {
    const { body } = await session.testAgent.get('/v1/users/me').expect(200);

    const me = body.data;

    expect(me._id).to.equal(session.user._id);
    expect(me.firstName).to.equal(session.user.firstName);
    expect(me.lastName).to.equal(session.user.lastName);
    expect(me.email).to.equal(session.user.email);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
    await session.initialize();
  });

  it('should return a correct user profile...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/user/e2e/update-name-and-profile-picture.e2e.ts
Tamaño: 1838 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { processTestAgentExpectedStatusCode, UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Update user name and profile picture - /users/profile (PUT) #novu-v0-os', async () => {
  let session: UserSession;

  before(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should update the user name and profile picture', async () => {
    const profilePicture = 'https://example.com/profile-picture.jpg';
    const {
      body: { data },
    } = await session.testAgent
      .put('/v1/users/profile')
      .send({
        firstName: 'John',
        lastName: 'Doe',
        profilePicture,
      })
      .expect(processTestAgentExpectedStatusCode(200));

    expect(data.firstName).to.equal('John');
    expect(data.lastName).to.equal('Doe');
    expect(data.profilePicture).to.equal(profilePicture);
  });

  it('should update the user name', async () => {
    const {
      body: { data },
      statusCode,
    } = await session.testAgent.put('/v1/users/profile').send({
      firstName: 'John',
      lastName: 'Doe',
    });

    expect(statusCode).to.equal(200);
    expect(data.firstName).to.equal('John');
    expect(data.lastName).to.equal('Doe');
  });

  it('should throw when invalid first name or last name provided', async () => {
    const { body } = await session.testAgent.put('/v1/users/profile').send({
      firstName: '',
      lastName: 'Doe',
    });

    expect(body.statusCode).to.equal(400);
    expect(body.message).to.equal('First name and last name are required');

    const { body: body2 } = await session.testAgent.put('/v1/users/profile').send({
      firstName: 'John',
      lastName: '',
    });

    expect(body2.statusCode).to.equal(400);
    expect(body2.message).to.equal('First name and last name are required');
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
    await session.initialize();
  });

  it('should update the user name and prof...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/user/usecases/base-user-profile.usecase.ts
Tamaño: 695 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { UserEntity } from '@novu/dal';
import { UserResponseDto } from '../dtos/user-response.dto';

export class BaseUserProfileUsecase {
  protected mapToDto(user: UserEntity): UserResponseDto {
    const {
      _id,
      resetToken,
      resetTokenDate,
      firstName,
      lastName,
      email,
      profilePicture,
      createdAt,
      showOnBoarding,
      servicesHashes,
      jobTitle,
      password,
    } = user;

    return {
      _id,
      resetToken,
      resetTokenDate,
      firstName,
      lastName,
      email,
      profilePicture,
      createdAt,
      showOnBoarding,
      servicesHashes,
      jobTitle,
      hasPassword: !!password,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class BaseUserProfileUsecase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/user/usecases/index.ts
Tamaño: 729 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CreateUser } from './create-user/create-user.usecase';
import { GetMyProfileUsecase } from './get-my-profile/get-my-profile.usecase';
import { UpdateNameAndProfilePicture } from './update-name-and-profile-picture/update-name-and-profile-picture.usecase';
import { UpdateOnBoardingUsecase } from './update-on-boarding/update-on-boarding.usecase';
import { UpdateOnBoardingTourUsecase } from './update-on-boarding-tour/update-on-boarding-tour.usecase';
import { UpdateProfileEmail } from './update-profile-email/update-profile-email.usecase';

export const USE_CASES = [
  CreateUser,
  GetMyProfileUsecase,
  UpdateOnBoardingUsecase,
  UpdateProfileEmail,
  UpdateOnBoardingTourUsecase,
  UpdateNameAndProfilePicture,
];


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/user/usecases/create-user/create-user.command.ts
Tamaño: 404 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BaseCommand } from '@novu/application-generic';
import { AuthProviderEnum } from '@novu/shared';

export class CreateUserCommand extends BaseCommand {
  email: string;

  firstName?: string | null;

  lastName?: string | null;

  picture?: string;

  auth: {
    username?: string;
    profileId: string;
    provider: AuthProviderEnum;
    accessToken: string;
    refreshToken: string;
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateUserCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/user/usecases/create-user/create-user.usecase.ts
Tamaño: 985 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { UserEntity, UserRepository } from '@novu/dal';
import { CreateUserCommand } from './create-user.command';

@Injectable()
export class CreateUser {
  constructor(private readonly userRepository: UserRepository) {}

  async execute(data: CreateUserCommand): Promise<UserEntity> {
    const user = new UserEntity();

    user.email = data.email ? data.email.toLowerCase() : '';
    user.firstName = data.firstName ? data.firstName.toLowerCase() : '';
    user.lastName = data.lastName ? data.lastName.toLowerCase() : data.lastName;
    user.profilePicture = data.picture;
    user.showOnBoarding = true;
    user.tokens = [
      {
        username: data.auth.username,
        providerId: data.auth.profileId,
        provider: data.auth.provider,
        accessToken: data.auth.accessToken,
        refreshToken: data.auth.refreshToken,
        valid: true,
      },
    ];

    return await this.userRepository.create(user);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateUser

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/user/usecases/create-user/index.ts
Tamaño: 78 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './create-user.command';
export * from './create-user.usecase';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/user/usecases/get-my-profile/get-my-profile.dto.ts
Tamaño: 153 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { AuthenticatedCommand } from '../../../shared/commands/authenticated.command';

export class GetMyProfileCommand extends AuthenticatedCommand {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetMyProfileCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/user/usecases/get-my-profile/get-my-profile.usecase.ts
Tamaño: 1896 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { createHash, PinoLogger } from '@novu/application-generic';
import { UserRepository } from '@novu/dal';
import type { UserResponseDto } from '../../dtos/user-response.dto';
import { BaseUserProfileUsecase } from '../base-user-profile.usecase';
import { GetMyProfileCommand } from './get-my-profile.dto';

@Injectable()
export class GetMyProfileUsecase extends BaseUserProfileUsecase {
  constructor(
    private readonly userRepository: UserRepository,
    private readonly logger: PinoLogger
  ) {
    super();
    this.logger.setContext(this.constructor.name);
  }

  async execute(command: GetMyProfileCommand): Promise<UserResponseDto> {
    this.logger.trace('Getting User from user repository in Command');
    this.logger.debug(`Getting user data for ${command.userId}`);
    const profile = await this.userRepository.findById(command.userId);

    if (!profile) {
      throw new NotFoundException('User not found');
    }

    /*
     * This code is added for intercom identity verification, so that we have hash value saved for all users.
     * This code can be deleted after 30 Sept, 2023.
     * Read more about Intercom Identity Verification here
     * https://www.intercom.com/help/en/articles/183-enable-identity-verification-for-web-and-mobile
     */
    if (process.env.INTERCOM_IDENTITY_VERIFICATION_SECRET_KEY && !profile.servicesHashes?.intercom) {
      const intercomSecretKey = process.env.INTERCOM_IDENTITY_VERIFICATION_SECRET_KEY as string;
      const userHashForIntercom = createHash(intercomSecretKey, profile._id);

      await this.userRepository.update(
        { _id: profile._id },
        {
          $set: {
            'servicesHashes.intercom': userHashForIntercom,
          },
        }
      );
    }

    this.logger.trace('Found User');

    return this.mapToDto(profile);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetMyProfileUsecase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/user/usecases/update-name-and-profile-picture/update-name-and-profile-picture.command.ts
Tamaño: 426 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsOptional, IsString, IsUrl } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class UpdateNameAndProfilePictureCommand extends EnvironmentWithUserCommand {
  @IsUrl({ require_tld: false })
  @IsOptional()
  profilePicture?: string;

  @IsDefined()
  @IsString()
  firstName: string;

  @IsString()
  @IsDefined()
  lastName: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateNameAndProfilePictureCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/user/usecases/update-name-and-profile-picture/update-name-and-profile-picture.usecase.ts
Tamaño: 1695 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import { buildUserKey, InvalidateCacheService } from '@novu/application-generic';
import { UserEntity, UserRepository } from '@novu/dal';

import { BaseUserProfileUsecase } from '../base-user-profile.usecase';
import { UpdateNameAndProfilePictureCommand } from './update-name-and-profile-picture.command';

@Injectable()
export class UpdateNameAndProfilePicture extends BaseUserProfileUsecase {
  constructor(
    private invalidateCache: InvalidateCacheService,
    private readonly userRepository: UserRepository
  ) {
    super();
  }

  async execute(command: UpdateNameAndProfilePictureCommand) {
    if (!command.firstName || !command.lastName) throw new BadRequestException('First name and last name are required');

    let user = await this.userRepository.findById(command.userId);
    if (!user) throw new NotFoundException('User not found');

    const updatePayload: Partial<UserEntity> = {
      firstName: command.firstName,
      lastName: command.lastName,
    };

    const unsetPayload: Partial<Record<keyof UserEntity, string>> = {};

    if (command.profilePicture) {
      updatePayload.profilePicture = command.profilePicture;
    }

    await this.userRepository.update(
      {
        _id: command.userId,
      },
      {
        $set: updatePayload,
        $unset: unsetPayload,
      }
    );

    await this.invalidateCache.invalidateByKey({
      key: buildUserKey({
        _id: command.userId,
      }),
    });

    user = await this.userRepository.findById(command.userId);
    if (!user) throw new NotFoundException('User not found');

    return this.mapToDto(user);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateNameAndProfilePicture

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/user/usecases/update-on-boarding-tour/update-on-boarding-tour.command.ts
Tamaño: 278 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsNumber, IsOptional } from 'class-validator';
import { AuthenticatedCommand } from '../../../shared/commands/authenticated.command';

export class UpdateOnBoardingTourCommand extends AuthenticatedCommand {
  @IsNumber()
  @IsOptional()
  showOnBoardingTour: number;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateOnBoardingTourCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/user/usecases/update-on-boarding-tour/update-on-boarding-tour.usecase.ts
Tamaño: 1365 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { buildUserKey, InvalidateCacheService } from '@novu/application-generic';
import { UserRepository } from '@novu/dal';
import type { UserResponseDto } from '../../dtos/user-response.dto';
import { BaseUserProfileUsecase } from '../base-user-profile.usecase';
import { UpdateOnBoardingTourCommand } from './update-on-boarding-tour.command';

@Injectable()
export class UpdateOnBoardingTourUsecase extends BaseUserProfileUsecase {
  constructor(
    private invalidateCache: InvalidateCacheService,
    private readonly userRepository: UserRepository
  ) {
    super();
  }

  async execute(command: UpdateOnBoardingTourCommand): Promise<UserResponseDto> {
    const user = await this.userRepository.findById(command.userId);
    if (!user) throw new NotFoundException('User not found');

    await this.userRepository.update(
      {
        _id: command.userId,
      },
      {
        $set: {
          showOnBoardingTour: command.showOnBoardingTour,
        },
      }
    );

    await this.invalidateCache.invalidateByKey({
      key: buildUserKey({
        _id: command.userId,
      }),
    });

    const updatedUser = await this.userRepository.findById(command.userId);
    if (!updatedUser) throw new NotFoundException('User not found');

    return this.mapToDto(updatedUser);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateOnBoardingTourUsecase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/user/usecases/update-on-boarding/update-on-boarding.command.ts
Tamaño: 274 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsBoolean, IsOptional } from 'class-validator';
import { AuthenticatedCommand } from '../../../shared/commands/authenticated.command';

export class UpdateOnBoardingCommand extends AuthenticatedCommand {
  @IsBoolean()
  @IsOptional()
  showOnBoarding?: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateOnBoardingCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/user/usecases/update-on-boarding/update-on-boarding.usecase.ts
Tamaño: 1187 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { buildUserKey, InvalidateCacheService } from '@novu/application-generic';
import { UserRepository } from '@novu/dal';
import type { UserResponseDto } from '../../dtos/user-response.dto';
import { BaseUserProfileUsecase } from '../base-user-profile.usecase';
import { UpdateOnBoardingCommand } from './update-on-boarding.command';

@Injectable()
export class UpdateOnBoardingUsecase extends BaseUserProfileUsecase {
  constructor(
    private invalidateCache: InvalidateCacheService,
    private readonly userRepository: UserRepository
  ) {
    super();
  }

  async execute(command: UpdateOnBoardingCommand): Promise<UserResponseDto> {
    await this.invalidateCache.invalidateByKey({
      key: buildUserKey({
        _id: command.userId,
      }),
    });

    await this.userRepository.update(
      {
        _id: command.userId,
      },
      {
        $set: {
          showOnBoarding: command.showOnBoarding,
        },
      }
    );

    const user = await this.userRepository.findById(command.userId);
    if (!user) throw new NotFoundException('User not found');

    return this.mapToDto(user);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateOnBoardingUsecase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/user/usecases/update-profile-email/update-profile-email.command.ts
Tamaño: 392 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentId } from '@novu/shared';
import { IsDefined, IsEmail, IsMongoId, IsNotEmpty } from 'class-validator';
import { AuthenticatedCommand } from '../../../shared/commands/authenticated.command';

export class UpdateProfileEmailCommand extends AuthenticatedCommand {
  @IsEmail()
  @IsDefined()
  email: string;

  @IsMongoId()
  @IsNotEmpty()
  environmentId: EnvironmentId;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateProfileEmailCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/user/usecases/update-profile-email/update-profile-email.usecase.ts
Tamaño: 2057 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, forwardRef, Inject, Injectable, NotFoundException } from '@nestjs/common';
import {
  AnalyticsService,
  buildAuthServiceKey,
  buildUserKey,
  decryptApiKey,
  InvalidateCacheService,
} from '@novu/application-generic';
import { EnvironmentRepository, UserRepository } from '@novu/dal';

import { normalizeEmail } from '@novu/shared';
import type { UserResponseDto } from '../../dtos/user-response.dto';
import { BaseUserProfileUsecase } from '../base-user-profile.usecase';
import { UpdateProfileEmailCommand } from './update-profile-email.command';

@Injectable()
export class UpdateProfileEmail extends BaseUserProfileUsecase {
  constructor(
    private invalidateCache: InvalidateCacheService,
    private readonly userRepository: UserRepository,
    private readonly environmentRepository: EnvironmentRepository,
    @Inject(forwardRef(() => AnalyticsService))
    private analyticsService: AnalyticsService
  ) {
    super();
  }

  async execute(command: UpdateProfileEmailCommand): Promise<UserResponseDto> {
    const email = normalizeEmail(command.email);
    const user = await this.userRepository.findByEmail(email);
    if (user) throw new BadRequestException('E-mail is invalid or taken');

    await this.userRepository.update(
      {
        _id: command.userId,
      },
      {
        $set: {
          email,
        },
      }
    );

    await this.invalidateCache.invalidateByKey({
      key: buildUserKey({
        _id: command.userId,
      }),
    });

    const apiKeys = await this.environmentRepository.getApiKeys(command.environmentId);

    const decryptedApiKey = decryptApiKey(apiKeys[0].key);

    await this.invalidateCache.invalidateByKey({
      key: buildAuthServiceKey({
        apiKey: decryptedApiKey,
      }),
    });

    const updatedUser = await this.userRepository.findById(command.userId);
    if (!updatedUser) throw new NotFoundException('User not found');

    this.analyticsService.setValue(updatedUser._id, 'email', email);

    return this.mapToDto(updatedUser);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateProfileEmail

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/widgets.controller.ts
Tamaño: 20568 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  BadRequestException,
  Body,
  Controller,
  DefaultValuePipe,
  Delete,
  Get,
  HttpCode,
  HttpStatus,
  NotFoundException,
  Param,
  Patch,
  Post,
  Query,
  UseGuards,
} from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { ApiExcludeController, ApiOperation, ApiQuery } from '@nestjs/swagger';
import { AnalyticsService } from '@novu/application-generic';
import { MessageEntity } from '@novu/dal';
import {
  ButtonTypeEnum,
  IPreferenceChannels,
  MessageActionStatusEnum,
  MessagesStatusEnum,
  PreferenceLevelEnum,
  TriggerTypeEnum,
  WorkflowCriticalityEnum,
} from '@novu/shared';
import { UpdatePreferencesCommand } from '../inbox/usecases/update-preferences/update-preferences.command';
import { UpdatePreferences } from '../inbox/usecases/update-preferences/update-preferences.usecase';
import { ApiCommonResponses, ApiNoContentResponse } from '../shared/framework/response.decorator';
import { SubscriberSession } from '../shared/framework/user.decorator';
import { UpdateSubscriberGlobalPreferencesRequestDto } from '../subscribers/dtos/update-subscriber-global-preferences-request.dto';
import { GetPreferencesByLevelCommand } from '../subscribers/usecases/get-preferences-by-level/get-preferences-by-level.command';
import { GetPreferencesByLevel } from '../subscribers/usecases/get-preferences-by-level/get-preferences-by-level.usecase';
import {
  GetSubscriberPreference,
  GetSubscriberPreferenceCommand,
} from '../subscribers/usecases/get-subscriber-preference';
import { GetNotificationsFeedDto } from './dtos/get-notifications-feed-request.dto';
import { LogUsageRequestDto } from './dtos/log-usage-request.dto';
import { LogUsageResponseDto } from './dtos/log-usage-response.dto';
import { MessageMarkAsRequestDto } from './dtos/mark-as-request.dto';
import { MessageResponseDto } from './dtos/message-response.dto';
import { OrganizationResponseDto } from './dtos/organization-response.dto';
import { RemoveAllMessagesDto } from './dtos/remove-all-messages.dto';
import { RemoveMessagesBulkRequestDto } from './dtos/remove-messages-bulk-request.dto';
import { SessionInitializeRequestDto } from './dtos/session-initialize-request.dto';
import { SessionInitializeResponseDto } from './dtos/session-initialize-response.dto';
import { UnseenCountResponse } from './dtos/unseen-count-response.dto';
import { UpdateSubscriberPreferenceRequestDto } from './dtos/update-subscriber-preference-request.dto';
import { UpdateSubscriberPreferenceResponseDto } from './dtos/update-subscriber-preference-response.dto';
import { LimitPipe } from './pipes/limit-pipe/limit-pipe';
import { GetCountQuery } from './queries/get-count.query';
import { GetFeedCountCommand } from './usecases/get-feed-count/get-feed-count.command';
import { GetFeedCount } from './usecases/get-feed-count/get-feed-count.usecase';
import { GetNotificationsFeedCommand } from './usecases/get-notifications-feed/get-notifications-feed.command';
import { GetNotificationsFeed } from './usecases/get-notifications-feed/get-notifications-feed.usecase';
import { GetOrganizationDataCommand } from './usecases/get-organization-data/get-organization-data.command';
import { GetOrganizationData } from './usecases/get-organization-data/get-organization-data.usecase';
import { InitializeSessionCommand } from './usecases/initialize-session/initialize-session.command';
import { InitializeSession } from './usecases/initialize-session/initialize-session.usecase';
import { UpdateMessageActionsCommand } from './usecases/mark-action-as-done/update-message-actions.command';
import { UpdateMessageActions } from './usecases/mark-action-as-done/update-message-actions.usecase';
import { MarkAllMessagesAsCommand } from './usecases/mark-all-messages-as/mark-all-messages-as.command';
import { MarkAllMessagesAs } from './usecases/mark-all-messages-as/mark-all-messages-as.usecase';
import { MarkMessageAsCommand } from './usecases/mark-message-as/mark-message-as.command';
import { MarkMessageAs } from './usecases/mark-message-as/mark-message-as.usecase';
import { MarkMessageAsByMarkCommand } from './usecases/mark-message-as-by-mark/mark-message-as-by-mark.command';
import { MarkMessageAsByMark } from './usecases/mark-message-as-by-mark/mark-message-as-by-mark.usecase';
import { RemoveMessageCommand } from './usecases/remove-message/remove-message.command';
import { RemoveMessage } from './usecases/remove-message/remove-message.usecase';
import { RemoveAllMessagesCommand } from './usecases/remove-messages/remove-all-messages.command';
import { RemoveAllMessages } from './usecases/remove-messages/remove-all-messages.usecase';
import { RemoveMessagesBulkCommand } from './usecases/remove-messages-bulk/remove-messages-bulk.command';
import { RemoveMessagesBulk } from './usecases/remove-messages-bulk/remove-messages-bulk.usecase';

@ApiCommonResponses()
@Controller('/widgets')
@ApiExcludeController()
export class WidgetsController {
  constructor(
    private initializeSessionUsecase: InitializeSession,
    private getNotificationsFeedUsecase: GetNotificationsFeed,
    private getFeedCountUsecase: GetFeedCount,
    private markMessageAsUsecase: MarkMessageAs,
    private markMessageAsByMarkUsecase: MarkMessageAsByMark,
    private removeMessageUsecase: RemoveMessage,
    private removeAllMessagesUsecase: RemoveAllMessages,
    private removeMessagesBulkUsecase: RemoveMessagesBulk,
    private updateMessageActionsUsecase: UpdateMessageActions,
    private getOrganizationUsecase: GetOrganizationData,
    private getSubscriberPreferenceUsecase: GetSubscriberPreference,
    private getSubscriberPreferenceByLevelUsecase: GetPreferencesByLevel,
    private updatePreferencesUsecase: UpdatePreferences,
    private markAllMessagesAsUsecase: MarkAllMessagesAs,
    private analyticsService: AnalyticsService
  ) {}

  @Post('/session/initialize')
  async sessionInitialize(@Body() body: SessionInitializeRequestDto): Promise<SessionInitializeResponseDto> {
    return await this.initializeSessionUsecase.execute(
      InitializeSessionCommand.create({
        subscriberId: body.subscriberId,
        applicationIdentifier: body.applicationIdentifier,
        email: body.email,
        firstName: body.firstName,
        lastName: body.lastName,
        phone: body.phone,
        hmacHash: body.hmacHash,
      })
    );
  }

  @UseGuards(AuthGuard('subscriberJwt'))
  @Get('/notifications/feed')
  @ApiQuery({
    name: 'seen',
    type: Boolean,
    required: false,
  })
  async getNotificationsFeed(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Query() query: GetNotificationsFeedDto
  ) {
    let feedsQuery: string[] | undefined;
    if (query.feedIdentifier) {
      feedsQuery = Array.isArray(query.feedIdentifier) ? query.feedIdentifier : [query.feedIdentifier];
    }

    const command = GetNotificationsFeedCommand.create({
      organizationId: subscriberSession._organizationId,
      subscriberId: subscriberSession.subscriberId,
      environmentId: subscriberSession._environmentId,
      page: query.page,
      feedId: feedsQuery,
      query: { seen: query.seen, read: query.read },
      limit: query.limit,
      payload: query.payload,
    });

    return await this.getNotificationsFeedUsecase.execute(command);
  }

  @UseGuards(AuthGuard('subscriberJwt'))
  @Get('/notifications/unseen')
  async getUnseenCount(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Query('feedIdentifier') feedId: string[] | string,
    @Query('seen') seen: boolean,
    @Query('limit', new DefaultValuePipe(100), new LimitPipe(1, 100, true)) limit: number
  ): Promise<UnseenCountResponse> {
    const feedsQuery = this.toArray(feedId);

    if (seen === undefined) {
      seen = false;
    }

    return await this.getFeedCountUsecase.execute(
      GetFeedCountCommand.create({
        organizationId: subscriberSession._organizationId,
        subscriberId: subscriberSession.subscriberId,
        environmentId: subscriberSession._environmentId,
        feedId: feedsQuery,
        seen,
        limit,
      })
    );
  }

  @UseGuards(AuthGuard('subscriberJwt'))
  @Get('/notifications/unread')
  async getUnreadCount(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Query('feedIdentifier') feedId: string[] | string,
    @Query('read') read: boolean,
    @Query('limit', new DefaultValuePipe(100), new LimitPipe(1, 100, true)) limit: number
  ): Promise<UnseenCountResponse> {
    const feedsQuery = this.toArray(feedId);

    if (read === undefined) {
      read = false;
    }

    return await this.getFeedCountUsecase.execute(
      GetFeedCountCommand.create({
        organizationId: subscriberSession._organizationId,
        subscriberId: subscriberSession.subscriberId,
        environmentId: subscriberSession._environmentId,
        feedId: feedsQuery,
        read,
        limit,
      })
    );
  }

  @UseGuards(AuthGuard('subscriberJwt'))
  @Get('/notifications/count')
  async getCount(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Query() query: GetCountQuery,
    @Query('limit', new DefaultValuePipe(100), new LimitPipe(1, 100, true)) limit: number
  ): Promise<UnseenCountResponse> {
    const feedsQuery = this.toArray(query.feedIdentifier);

    if (query.seen === undefined && query.read === undefined) {
      query.seen = false;
    }

    const command = GetFeedCountCommand.create({
      organizationId: subscriberSession._organizationId,
      subscriberId: subscriberSession.subscriberId,
      environmentId: subscriberSession._environmentId,
      feedId: feedsQuery,
      seen: query.seen,
      read: query.read,
      limit,
    });

    return await this.getFeedCountUsecase.execute(command);
  }

  @ApiOperation({
    summary: 'Mark a subscriber feed messages as seen or as read',
    description: `Introducing '/messages/mark-as endpoint for consistent read and seen message handling,
     deprecating old legacy endpoint.`,
    deprecated: true,
  })
  @UseGuards(AuthGuard('subscriberJwt'))
  @Post('/messages/markAs')
  async markMessageAs(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Body() body: { messageId: string | string[]; mark: { seen?: boolean; read?: boolean } }
  ): Promise<MessageEntity[]> {
    const messageIds = this.toArray(body.messageId);
    if (!messageIds) throw new BadRequestException('messageId is required');

    return await this.markMessageAsUsecase.execute(
      MarkMessageAsCommand.create({
        organizationId: subscriberSession._organizationId,
        subscriberId: subscriberSession.subscriberId,
        environmentId: subscriberSession._environmentId,
        messageIds,
        mark: body.mark,
      })
    );
  }

  @ApiOperation({
    summary: 'Mark a subscriber messages as seen, read, unseen or unread',
  })
  @UseGuards(AuthGuard('subscriberJwt'))
  @Post('/messages/mark-as')
  async markMessagesAs(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Body() body: MessageMarkAsRequestDto
  ): Promise<MessageResponseDto[]> {
    const messageIds = this.toArray(body.messageId);
    if (!messageIds || messageIds.length === 0) throw new BadRequestException('messageId is required');

    return await this.markMessageAsByMarkUsecase.execute(
      MarkMessageAsByMarkCommand.create({
        organizationId: subscriberSession._organizationId,
        subscriberId: subscriberSession.subscriberId,
        environmentId: subscriberSession._environmentId,
        messageIds,
        markAs: body.markAs,
        __source: 'notification_center',
      })
    );
  }

  @ApiOperation({
    summary: 'Remove a subscriber feed message',
  })
  @UseGuards(AuthGuard('subscriberJwt'))
  @Delete('/messages/:messageId')
  async removeMessage(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Param('messageId') messageId: string
  ): Promise<void> {
    if (!messageId) throw new BadRequestException('messageId is required');

    const command = RemoveMessageCommand.create({
      organizationId: subscriberSession._organizationId,
      subscriberId: subscriberSession.subscriberId,
      environmentId: subscriberSession._environmentId,
      messageId,
    });

    return await this.removeMessageUsecase.execute(command);
  }

  @ApiOperation({
    summary: `Remove a subscriber's feed messages`,
  })
  @UseGuards(AuthGuard('subscriberJwt'))
  @Delete('/messages')
  @ApiNoContentResponse({ description: 'Messages removed' })
  @HttpCode(HttpStatus.NO_CONTENT)
  async removeAllMessages(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Query() query: RemoveAllMessagesDto
  ): Promise<void> {
    const command = RemoveAllMessagesCommand.create({
      organizationId: subscriberSession._organizationId,
      subscriberId: subscriberSession.subscriberId,
      environmentId: subscriberSession._environmentId,
      feedId: query.feedId,
    });

    await this.removeAllMessagesUsecase.execute(command);
  }

  @ApiOperation({
    summary: 'Remove subscriber messages in bulk',
  })
  @UseGuards(AuthGuard('subscriberJwt'))
  @Post('/messages/bulk/delete')
  @HttpCode(HttpStatus.OK)
  async removeMessagesBulk(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Body() body: RemoveMessagesBulkRequestDto
  ) {
    return await this.removeMessagesBulkUsecase.execute(
      RemoveMessagesBulkCommand.create({
        organizationId: subscriberSession._organizationId,
        subscriberId: subscriberSession.subscriberId,
        environmentId: subscriberSession._environmentId,
        messageIds: body.messageIds,
      })
    );
  }

  @ApiOperation({
    summary: "Mark subscriber's all unread messages as read",
  })
  @UseGuards(AuthGuard('subscriberJwt'))
  @Post('/messages/read')
  async markAllUnreadAsRead(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Body() body: { feedId?: string | string[] }
  ) {
    const feedIds = this.toArray(body.feedId);

    return await this.markAllMessagesAsUsecase.execute(
      MarkAllMessagesAsCommand.create({
        organizationId: subscriberSession._organizationId,
        subscriberId: subscriberSession.subscriberId,
        environmentId: subscriberSession._environmentId,
        markAs: MessagesStatusEnum.READ,
        feedIdentifiers: feedIds,
      })
    );
  }

  @ApiOperation({
    summary: "Mark subscriber's all unseen messages as seen",
  })
  @UseGuards(AuthGuard('subscriberJwt'))
  @Post('/messages/seen')
  async markAllUnseenAsSeen(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Body() body: { feedId?: string | string[] }
  ): Promise<number> {
    const feedIds = this.toArray(body.feedId);

    return await this.markAllMessagesAsUsecase.execute(
      MarkAllMessagesAsCommand.create({
        organizationId: subscriberSession._organizationId,
        subscriberId: subscriberSession.subscriberId,
        environmentId: subscriberSession._environmentId,
        markAs: MessagesStatusEnum.SEEN,
        feedIdentifiers: feedIds,
      })
    );
  }

  @UseGuards(AuthGuard('subscriberJwt'))
  @Post('/messages/:messageId/actions/:type')
  async markActionAsSeen(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Param('messageId') messageId: string,
    @Param('type') type: ButtonTypeEnum,
    @Body() body: { payload: any; status: MessageActionStatusEnum }
  ): Promise<MessageEntity> {
    return await this.updateMessageActionsUsecase.execute(
      UpdateMessageActionsCommand.create({
        organizationId: subscriberSession._organizationId,
        subscriberId: subscriberSession.subscriberId,
        environmentId: subscriberSession._environmentId,
        messageId,
        type,
        payload: body.payload,
        status: body.status,
      })
    );
  }

  @UseGuards(AuthGuard('subscriberJwt'))
  @Get('/organization')
  async getOrganizationData(
    @SubscriberSession() subscriberSession: SubscriberSession
  ): Promise<OrganizationResponseDto> {
    const command = GetOrganizationDataCommand.create({
      organizationId: subscriberSession._organizationId,
      subscriberId: subscriberSession._id,
      environmentId: subscriberSession._environmentId,
    });

    return await this.getOrganizationUsecase.execute(command);
  }

  @UseGuards(AuthGuard('subscriberJwt'))
  @Get('/preferences')
  async getSubscriberPreference(@SubscriberSession() subscriberSession: SubscriberSession) {
    const command = GetSubscriberPreferenceCommand.create({
      organizationId: subscriberSession._organizationId,
      subscriberId: subscriberSession.subscriberId,
      environmentId: subscriberSession._environmentId,
      includeInactiveChannels: false,
      criticality: WorkflowCriticalityEnum.NON_CRITICAL,
    });

    return await this.getSubscriberPreferenceUsecase.execute(command);
  }

  @UseGuards(AuthGuard('subscriberJwt'))
  @Get('/preferences/:level')
  async getSubscriberPreferenceByLevel(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Param('level') level: PreferenceLevelEnum
  ) {
    const command = GetPreferencesByLevelCommand.create({
      organizationId: subscriberSession._organizationId,
      subscriberId: subscriberSession.subscriberId,
      environmentId: subscriberSession._environmentId,
      includeInactiveChannels: false,
      level,
    });

    return await this.getSubscriberPreferenceByLevelUsecase.execute(command);
  }

  @UseGuards(AuthGuard('subscriberJwt'))
  @Patch('/preferences/:templateId')
  async updateSubscriberPreference(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Param('templateId') templateId: string,
    @Body() body: UpdateSubscriberPreferenceRequestDto
  ): Promise<UpdateSubscriberPreferenceResponseDto> {
    const result = await this.updatePreferencesUsecase.execute(
      UpdatePreferencesCommand.create({
        environmentId: subscriberSession._environmentId,
        organizationId: subscriberSession._organizationId,
        subscriberId: subscriberSession.subscriberId,
        workflowIdOrIdentifier: templateId,
        level: PreferenceLevelEnum.TEMPLATE,
        includeInactiveChannels: false,
        ...(body.channel && { [body.channel.type]: body.channel.enabled }),
      })
    );

    if (!result.workflow) throw new NotFoundException('Workflow not found');

    return {
      preference: {
        channels: result.channels,
        enabled: result.enabled,
      },
      template: {
        _id: result.workflow.id,
        name: result.workflow.name,
        critical: result.workflow.critical,
        tags: result.workflow.tags,
        data: result.workflow.data,
        triggers: [
          {
            identifier: result.workflow.identifier,
            type: TriggerTypeEnum.EVENT,
            variables: [],
          },
        ],
      },
    };
  }

  @UseGuards(AuthGuard('subscriberJwt'))
  @Patch('/preferences')
  async updateSubscriberGlobalPreference(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Body() body: UpdateSubscriberGlobalPreferencesRequestDto
  ) {
    const channels = body.preferences?.reduce((acc, curr) => {
      acc[curr.type] = curr.enabled;

      return acc;
    }, {} as IPreferenceChannels);

    const result = await this.updatePreferencesUsecase.execute(
      UpdatePreferencesCommand.create({
        environmentId: subscriberSession._environmentId,
        organizationId: subscriberSession._organizationId,
        subscriberId: subscriberSession.subscriberId,
        level: PreferenceLevelEnum.GLOBAL,
        includeInactiveChannels: false,
        ...channels,
      })
    );

    return {
      preference: {
        channels: result.channels,
        enabled: result.enabled,
      },
    };
  }

  @UseGuards(AuthGuard('subscriberJwt'))
  @Post('/usage/log')
  async logUsage(
    @SubscriberSession() subscriberSession: SubscriberSession,
    @Body() body: LogUsageRequestDto
  ): Promise<LogUsageResponseDto> {
    this.analyticsService.track(body.name, subscriberSession._organizationId, {
      environmentId: subscriberSession._environmentId,
      _organization: subscriberSession._organizationId,
      ...(body.payload || {}),
    });

    return {
      success: true,
    };
  }

  private toArray(param: string[] | string | undefined): string[] | undefined {
    let paramArray: string[] | undefined;

    if (param) {
      paramArray = Array.isArray(param) ? param : String(param).split(',');
    }

    return paramArray as string[];
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - channels(body.preferences?.reduce((acc, curr))
Declaraciones 'export' encontradas:
- export class WidgetsController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/widgets.module.ts
Tamaño: 880 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { forwardRef, Module } from '@nestjs/common';

import { CommunityOrganizationRepository } from '@novu/dal';
import { AuthModule } from '../auth/auth.module';
import { IntegrationModule } from '../integrations/integrations.module';
import { OutboundWebhooksModule } from '../outbound-webhooks/outbound-webhooks.module';
import { SharedModule } from '../shared/shared.module';
import { SubscribersV1Module } from '../subscribers/subscribersV1.module';
import { USE_CASES } from './usecases';
import { WidgetsController } from './widgets.controller';

@Module({
  imports: [
    SharedModule,
    forwardRef(() => SubscribersV1Module),
    AuthModule,
    IntegrationModule,
    OutboundWebhooksModule.forRoot(),
  ],
  providers: [...USE_CASES, CommunityOrganizationRepository],
  exports: [...USE_CASES],
  controllers: [WidgetsController],
})
export class WidgetsModule {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class WidgetsModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/dtos/feeds-response.dto.ts
Tamaño: 7161 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiExtraModels, ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { ActorTypeEnum, ChannelTypeEnum, IActor, INotificationDto } from '@novu/shared';

import { SubscriberFeedResponseDto } from '../../subscribers/dtos';
import { EmailBlock, MessageCTA } from './message-response.dto';

class ActorFeedItemDto implements IActor {
  @ApiProperty({
    description: 'The data associated with the actor, can be null if not applicable.',
    nullable: true,
    example: null,
    type: String,
  })
  data: string | null;

  @ApiProperty({
    description: 'The type of the actor, indicating the role in the notification process.',
    enum: [...Object.values(ActorTypeEnum)],
    enumName: 'ActorTypeEnum',
    type: ActorTypeEnum,
  })
  type: ActorTypeEnum;
}

@ApiExtraModels(EmailBlock, MessageCTA)
export class NotificationFeedItemDto implements INotificationDto {
  @ApiProperty({
    description: 'Unique identifier for the notification.',
    example: '615c1f2f9b0c5b001f8e4e3b',
    type: String,
  })
  _id: string;

  @ApiProperty({
    description: 'Identifier for the template used to generate the notification.',
    example: 'template_12345',
    type: String,
  })
  _templateId: string;

  @ApiProperty({
    description: 'Identifier for the environment where the notification is sent.',
    example: 'env_67890',
    type: String,
  })
  _environmentId: string;

  @ApiPropertyOptional({
    description: 'Identifier for the message template used.',
    example: 'message_template_54321',
    type: String,
  })
  _messageTemplateId: string;

  @ApiProperty({
    description: 'Identifier for the organization sending the notification.',
    example: 'org_98765',
    type: String,
  })
  _organizationId: string;

  @ApiProperty({
    description: 'Unique identifier for the notification instance.',
    example: 'notification_123456',
    type: String,
  })
  _notificationId: string;

  @ApiProperty({
    description: 'Unique identifier for the subscriber receiving the notification.',
    example: 'subscriber_112233',
    type: String,
  })
  _subscriberId: string;

  @ApiPropertyOptional({
    description: 'Identifier for the feed associated with the notification.',
    example: 'feed_445566',
    type: String,
    nullable: true,
  })
  _feedId?: string | null;

  @ApiProperty({
    description: 'Identifier for the job that triggered the notification.',
    example: 'job_778899',
    type: String,
  })
  _jobId: string;

  @ApiPropertyOptional({
    description: 'Timestamp indicating when the notification was created.',
    type: String,
    format: 'date-time',
    nullable: true,
    example: '2024-12-10T10:10:59.639Z',
  })
  createdAt: string;

  @ApiPropertyOptional({
    description: 'Timestamp indicating when the notification was last updated.',
    type: String,
    format: 'date-time',
    nullable: true,
    example: '2024-12-10T10:10:59.639Z',
  })
  updatedAt?: string | null;

  @ApiPropertyOptional({
    description: 'Actor details related to the notification, if applicable.',
    type: ActorFeedItemDto,
  })
  actor?: ActorFeedItemDto;

  @ApiPropertyOptional({
    description: 'Subscriber details associated with this notification.',
    type: SubscriberFeedResponseDto,
  })
  subscriber?: SubscriberFeedResponseDto;

  @ApiProperty({
    description: 'Unique identifier for the transaction associated with the notification.',
    example: 'transaction_123456',
    type: String,
  })
  transactionId: string;

  @ApiPropertyOptional({
    description: 'Identifier for the template used, if applicable.',
    nullable: true,
    example: 'template_abcdef',
    type: String,
  })
  templateIdentifier?: string | null;

  @ApiPropertyOptional({
    description: 'Identifier for the provider that sends the notification.',
    nullable: true,
    example: 'provider_xyz',
    type: String,
  })
  providerId?: string | null;

  @ApiProperty({
    description: 'The main content of the notification.',
    example: 'This is a test notification content.',
    type: String,
  })
  content: string;

  @ApiPropertyOptional({
    description: 'The subject line for email notifications, if applicable.',
    nullable: true,
    example: 'Test Notification Subject',
    type: String,
  })
  subject?: string | null;

  @ApiProperty({
    description: 'The channel through which the notification is sent.',
    enum: [...Object.values(ChannelTypeEnum)],
    enumName: 'ChannelTypeEnum',
    type: ChannelTypeEnum,
  })
  channel: ChannelTypeEnum;

  @ApiProperty({
    description: 'Indicates whether the notification has been read by the subscriber.',
    example: false,
    type: Boolean,
  })
  read: boolean;

  @ApiProperty({
    description: 'Indicates whether the notification has been seen by the subscriber.',
    example: true,
    type: Boolean,
  })
  seen: boolean;

  @ApiPropertyOptional({
    description: 'Device tokens for push notifications, if applicable.',
    type: [String],
    nullable: true,
    example: ['token1', 'token2'],
  })
  deviceTokens?: string[] | null;

  @ApiProperty({
    description: 'Call-to-action information associated with the notification.',
    type: MessageCTA,
  })
  cta: MessageCTA;

  @ApiProperty({
    description: 'Current status of the notification.',
    enum: ['sent', 'error', 'warning'],
    example: 'sent',
    type: String,
  })
  status: 'sent' | 'error' | 'warning';

  @ApiProperty({
    description: 'The payload that was used to send the notification trigger.',
    type: 'object',
    additionalProperties: true,
    required: false,
    example: { key: 'value' },
  })
  payload?: Record<string, unknown>;

  @ApiPropertyOptional({
    description: 'The data sent with the notification.',
    type: 'object',
    nullable: true,
    example: { key: 'value' },
    additionalProperties: true,
  })
  data?: Record<string, unknown> | null;

  @ApiProperty({
    description: 'Provider-specific overrides used when triggering the notification.',
    type: 'object',
    additionalProperties: true,
    required: false,
    example: { overrideKey: 'overrideValue' },
  })
  overrides?: Record<string, unknown>;

  @ApiPropertyOptional({
    description: 'Tags associated with the workflow that triggered the notification.',
    type: [String],
    nullable: true,
    example: ['tag1', 'tag2'],
  })
  tags?: string[] | null;
}

export class FeedResponseDto {
  @ApiPropertyOptional({
    description: 'Total number of notifications available.',
    example: 5,
    type: Number,
  })
  totalCount?: number;

  @ApiProperty({
    description: 'Indicates if there are more notifications to load.',
    example: true,
    type: Boolean,
  })
  hasMore: boolean;

  @ApiProperty({
    description: 'Array of notifications returned in the response.',
    type: [NotificationFeedItemDto],
  })
  data: NotificationFeedItemDto[];

  @ApiProperty({
    description: 'The number of notifications returned in this response.',
    example: 2,
    type: Number,
  })
  pageSize: number;

  @ApiProperty({
    description: 'The current page number of the notifications.',
    example: 1,
    type: Number,
  })
  page: number;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class NotificationFeedItemDto
- export class FeedResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/dtos/get-notifications-feed-request.dto.ts
Tamaño: 223 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { GetInAppNotificationsFeedForSubscriberDto } from '../../subscribers/dtos/get-in-app-notification-feed-for-subscriber.dto';

export class GetNotificationsFeedDto extends GetInAppNotificationsFeedForSubscriberDto {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetNotificationsFeedDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/dtos/log-usage-request.dto.ts
Tamaño: 298 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';

export class LogUsageRequestDto {
  @ApiProperty({
    example: '[Widget] - Notification Click',
  })
  name: string;
  @ApiProperty({
    example: {
      notificationId: '507f191e810c19729de860ea',
      hasCta: true,
    },
  })
  payload: any;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class LogUsageRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/dtos/log-usage-response.dto.ts
Tamaño: 122 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';

export class LogUsageResponseDto {
  @ApiProperty()
  success: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class LogUsageResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/dtos/mark-as-request.dto.ts
Tamaño: 515 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { MessagesStatusEnum } from '@novu/shared';
import { IsDefined, IsEnum } from 'class-validator';

export class MessageMarkAsRequestDto {
  @ApiProperty({
    oneOf: [
      { type: 'string' },
      {
        type: 'array',
        items: {
          type: 'string',
        },
      },
    ],
  })
  messageId: string | string[];

  @ApiProperty({
    enum: MessagesStatusEnum,
  })
  @IsDefined()
  @IsEnum(MessagesStatusEnum)
  markAs: MessagesStatusEnum;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class MessageMarkAsRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/dtos/mark-message-action-as-seen.dto.ts
Tamaño: 525 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { MessageActionStatusEnum } from '@novu/shared';
import { IsDefined, IsOptional, IsString } from 'class-validator';

export class MarkMessageActionAsSeenDto {
  @ApiProperty({
    enum: MessageActionStatusEnum,
    description: 'Message action status',
  })
  @IsString()
  @IsDefined()
  status: MessageActionStatusEnum;

  @ApiPropertyOptional({
    description: 'Message action payload',
  })
  @IsOptional()
  payload: Record<string, unknown>;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class MarkMessageActionAsSeenDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/dtos/mark-message-as-request.dto.ts
Tamaño: 547 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';

class MarkMessageFields {
  @ApiPropertyOptional({
    type: Boolean,
  })
  seen?: boolean;

  @ApiPropertyOptional({
    type: Boolean,
  })
  read?: boolean;
}

export class MarkMessageAsRequestDto {
  @ApiProperty({
    oneOf: [
      { type: 'string' },
      {
        type: 'array',
        items: {
          type: 'string',
        },
      },
    ],
  })
  messageId: string | string[];

  @ApiProperty({
    type: MarkMessageFields,
  })
  mark: MarkMessageFields;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class MarkMessageAsRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/dtos/message-response.dto.ts
Tamaño: 9313 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiExtraModels, ApiProperty, ApiPropertyOptional, getSchemaPath } from '@nestjs/swagger';
import {
  ButtonTypeEnum,
  ChannelCTATypeEnum,
  ChannelTypeEnum,
  EmailBlockTypeEnum,
  IMessage,
  IMessageAction,
  IMessageCTA,
  MessageActionStatusEnum,
  TextAlignEnum,
} from '@novu/shared';
import { SubscriberResponseDto } from '../../subscribers/dtos';
import { WorkflowResponse } from '../../workflows-v1/dtos/workflow-response.dto';

class EmailBlockStyles {
  @ApiProperty({
    enum: [...Object.values(TextAlignEnum)],
    enumName: 'TextAlignEnum',
    description: 'Text alignment for the email block',
  })
  textAlign?: TextAlignEnum;
}

export class EmailBlock {
  @ApiProperty({
    enum: [...Object.values(EmailBlockTypeEnum)],
    enumName: 'EmailBlockTypeEnum',
    description: 'Type of the email block',
  })
  type: EmailBlockTypeEnum;

  @ApiProperty({
    type: String,
    description: 'Content of the email block',
  })
  content: string;

  @ApiPropertyOptional({
    type: String,
    description: 'URL associated with the email block, if any',
  })
  url?: string;

  @ApiPropertyOptional({
    type: EmailBlockStyles,
    description: 'Styles applied to the email block',
  })
  styles?: EmailBlockStyles;
}

class MessageActionResult {
  @ApiPropertyOptional({
    description: 'Payload of the action result',
    type: Object,
  })
  payload?: Record<string, unknown>;

  @ApiPropertyOptional({
    enum: [...Object.values(ButtonTypeEnum)],
    enumName: 'ButtonTypeEnum',
    description: 'Type of button for the action result',
  })
  type?: ButtonTypeEnum;
}

class MessageButton {
  @ApiProperty({
    enum: [...Object.values(ButtonTypeEnum)],
    enumName: 'ButtonTypeEnum',
    description: 'Type of the button',
  })
  type: ButtonTypeEnum;

  @ApiProperty({
    type: String,
    description: 'Content of the button',
  })
  content: string;

  @ApiPropertyOptional({
    type: String,
    description: 'Content of the result when the button is clicked',
  })
  resultContent?: string;
}

class MessageAction implements IMessageAction {
  @ApiPropertyOptional({
    enum: [...Object.values(MessageActionStatusEnum)],
    enumName: 'MessageActionStatusEnum',
    description: 'Status of the message action',
  })
  status?: MessageActionStatusEnum;

  @ApiPropertyOptional({
    type: MessageButton,
    isArray: true,
    description: 'List of buttons associated with the message action',
  })
  buttons?: MessageButton[];

  @ApiPropertyOptional({
    type: MessageActionResult,
    description: 'Result of the message action',
  })
  result: MessageActionResult;
}

class MessageCTAData {
  @ApiPropertyOptional({
    type: String,
    description: 'URL for the call to action',
  })
  url?: string;
}

export class MessageCTA implements IMessageCTA {
  @ApiPropertyOptional({
    enum: [...Object.values(ChannelCTATypeEnum)],
    enumName: 'ChannelCTATypeEnum',
    description: 'Type of call to action',
  })
  type: ChannelCTATypeEnum;

  @ApiPropertyOptional({
    description: 'Data associated with the call to action',
    type: MessageCTAData,
  })
  data: MessageCTAData;

  @ApiPropertyOptional({
    description: 'Action associated with the call to action',
    type: MessageAction,
  })
  action?: MessageAction;
}

@ApiExtraModels(EmailBlock, MessageCTA)
export class MessageResponseDto implements IMessage {
  @ApiPropertyOptional({
    type: String,
    description: 'Unique identifier for the message',
  })
  _id: string;

  @ApiPropertyOptional({
    nullable: true,
    type: String,
    description: 'Template ID associated with the message',
  })
  _templateId: string;

  @ApiProperty({
    type: String,
    description: 'Environment ID where the message is sent',
  })
  _environmentId: string;

  @ApiPropertyOptional({
    nullable: true,
    type: String,
    description: 'Message template ID',
  })
  _messageTemplateId: string;

  @ApiProperty({
    type: String,
    description: 'Organization ID associated with the message',
  })
  _organizationId: string;

  @ApiProperty({
    type: String,
    description: 'Notification ID associated with the message',
  })
  _notificationId: string;

  @ApiProperty({
    type: String,
    description: 'Subscriber ID associated with the message',
  })
  _subscriberId: string;

  @ApiPropertyOptional({
    type: SubscriberResponseDto,
    description: 'Subscriber details, if available',
  })
  subscriber?: SubscriberResponseDto;

  @ApiPropertyOptional({
    type: WorkflowResponse,
    description: 'Workflow template associated with the message',
  })
  template?: WorkflowResponse;

  @ApiPropertyOptional({
    type: String,
    description: 'Identifier for the message template',
  })
  templateIdentifier?: string;

  @ApiProperty({
    type: String,
    description: 'Creation date of the message',
  })
  createdAt: string;

  @ApiPropertyOptional({
    type: [String],
    description:
      'Array of delivery dates for the message, if the message has multiple delivery dates, for example after being snoozed',
  })
  deliveredAt?: string[];

  @ApiPropertyOptional({
    type: String,
    description: 'Last seen date of the message, if available',
  })
  lastSeenDate?: string;

  @ApiPropertyOptional({
    type: String,
    description: 'Last read date of the message, if available',
  })
  lastReadDate?: string;

  @ApiPropertyOptional({
    nullable: true,
    oneOf: [
      {
        type: 'array',
        items: {
          $ref: getSchemaPath(EmailBlock),
        },
      },
      {
        type: 'string',
        description: 'String representation of the content',
      },
    ],
    description: 'Content of the message, can be an email block or a string',
  })
  content: string | EmailBlock[];

  @ApiProperty({
    type: String,
    description: 'Transaction ID associated with the message',
  })
  transactionId: string;

  @ApiPropertyOptional({
    type: String,
    description: 'Subject of the message, if applicable',
  })
  subject?: string;

  @ApiProperty({
    enum: [...Object.values(ChannelTypeEnum)],
    enumName: 'ChannelTypeEnum',
    description: 'Channel type through which the message is sent',
  })
  channel: ChannelTypeEnum;

  @ApiProperty({
    type: Boolean,
    description: 'Indicates if the message has been read',
  })
  read: boolean;

  @ApiProperty({
    type: Boolean,
    description: 'Indicates if the message has been seen',
  })
  seen: boolean;

  @ApiPropertyOptional({
    type: String,
    description: 'Date when the message will be unsnoozed',
  })
  snoozedUntil?: string;

  @ApiPropertyOptional({
    type: String,
    description: 'Email address associated with the message, if applicable',
  })
  email?: string;

  @ApiPropertyOptional({
    type: String,
    description: 'Phone number associated with the message, if applicable',
  })
  phone?: string;

  @ApiPropertyOptional({
    type: String,
    description: 'Direct webhook URL for the message, if applicable',
  })
  directWebhookUrl?: string;

  @ApiPropertyOptional({
    type: String,
    description: 'Provider ID associated with the message, if applicable',
  })
  providerId?: string;

  @ApiPropertyOptional({
    type: [String],
    description: 'Device tokens associated with the message, if applicable',
  })
  deviceTokens?: string[];

  @ApiPropertyOptional({
    type: String,
    description: 'Title of the message, if applicable',
  })
  title?: string;

  @ApiProperty({
    type: MessageCTA,
    description: 'Call to action associated with the message',
  })
  cta: MessageCTA;

  @ApiPropertyOptional({
    type: String,
    description: 'Feed ID associated with the message, if applicable',
  })
  _feedId?: string | null;

  @ApiProperty({
    enum: ['sent', 'error', 'warning'],
    enumName: 'MessageStatusEnum',
    description: 'Status of the message',
  })
  status: 'sent' | 'error' | 'warning';

  @ApiPropertyOptional({
    type: String,
    description: 'Error ID if the message has an error',
  })
  errorId?: string;

  @ApiPropertyOptional({
    type: String,
    description: 'Error text if the message has an error',
  })
  errorText?: string;

  @ApiPropertyOptional({
    description: 'The payload that was used to send the notification trigger',
    type: Object,
  })
  payload: Record<string, unknown>;

  @ApiPropertyOptional({
    description: 'Provider specific overrides used when triggering the notification',
    type: Object,
  })
  overrides?: Record<string, unknown>;

  @ApiPropertyOptional({
    type: [String],
    description: 'Context keys associated with the message (format: "type:id")',
    example: ['tenant:org-123', 'region:us-east-1'],
  })
  contextKeys?: string[];
}

export class MessagesResponseDto {
  @ApiPropertyOptional({
    type: Number,
    description: 'Total number of messages available',
  })
  totalCount?: number;

  @ApiProperty({
    type: Boolean,
    description: 'Indicates if there are more messages available',
  })
  hasMore: boolean;

  @ApiProperty({
    type: [MessageResponseDto],
    description: 'List of messages',
  })
  data: MessageResponseDto[];

  @ApiProperty({
    type: Number,
    description: 'Number of messages per page',
  })
  pageSize: number;

  @ApiProperty({
    type: Number,
    description: 'Current page number',
  })
  page: number;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class EmailBlock
- export class MessageCTA
- export class MessageResponseDto
- export class MessagesResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/dtos/organization-response.dto.ts
Tamaño: 545 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';

class Branding {
  @ApiPropertyOptional()
  fontFamily?: string;
  @ApiPropertyOptional()
  fontColor?: string;
  @ApiPropertyOptional()
  contentBackground?: string;
  @ApiProperty()
  logo: string;
  @ApiProperty()
  color: string;
  @ApiPropertyOptional({
    enum: ['ltr', 'rtl'],
  })
  direction?: 'ltr' | 'rtl';
}

export class OrganizationResponseDto {
  @ApiProperty()
  _id: string;
  @ApiProperty()
  name: string;
  @ApiPropertyOptional()
  branding?: Branding;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class OrganizationResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/dtos/remove-all-messages.dto.ts
Tamaño: 335 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional } from '@nestjs/swagger';
import { IsMongoId, IsOptional } from 'class-validator';

export class RemoveAllMessagesDto {
  @ApiPropertyOptional({
    description: 'FeedId to remove messages from',
  })
  @IsMongoId({ message: 'FeedId must be a valid MongoDB ObjectId' })
  @IsOptional()
  feedId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RemoveAllMessagesDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/dtos/remove-messages-bulk-request.dto.ts
Tamaño: 324 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { ArrayMaxSize, ArrayNotEmpty, IsArray, IsMongoId } from 'class-validator';

export class RemoveMessagesBulkRequestDto {
  @ApiProperty({
    isArray: true,
  })
  @IsArray()
  @ArrayNotEmpty()
  @IsMongoId({ each: true })
  @ArrayMaxSize(100)
  messageIds: string[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RemoveMessagesBulkRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/dtos/session-initialize-request.dto.ts
Tamaño: 875 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IsDefined, IsEmail, IsOptional, IsString } from 'class-validator';

export class SessionInitializeRequestDto {
  @ApiProperty({
    description: 'Your internal identifier for subscriber',
  })
  @IsString()
  @IsDefined()
  subscriberId: string;

  @ApiProperty({
    description: 'Identifier for your application can be found in settings for Novu',
  })
  @IsString()
  @IsDefined()
  applicationIdentifier: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  firstName?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  lastName?: string;

  @ApiPropertyOptional()
  @IsEmail()
  @IsOptional()
  email?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  phone?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  hmacHash?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SessionInitializeRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/dtos/session-initialize-response.dto.ts
Tamaño: 373 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';

class Profile {
  @ApiProperty()
  _id: string;
  @ApiPropertyOptional()
  firstName?: string;
  @ApiPropertyOptional()
  lastName?: string;
  @ApiPropertyOptional()
  phone?: string;
}

export class SessionInitializeResponseDto {
  @ApiProperty()
  token: string;
  @ApiProperty()
  profile: Profile;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SessionInitializeResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/dtos/unseen-count-response.dto.ts
Tamaño: 119 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';

export class UnseenCountResponse {
  @ApiProperty()
  count: number;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UnseenCountResponse

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/dtos/update-subscriber-preference-request.dto.ts
Tamaño: 805 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiExtraModels, ApiPropertyOptional } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { IsBoolean, IsOptional, ValidateNested } from 'class-validator';
import { ChannelPreference } from '../../shared/dtos/channel-preference';

@ApiExtraModels(ChannelPreference)
export class UpdateSubscriberPreferenceRequestDto {
  @ApiPropertyOptional({
    type: ChannelPreference,
    description: 'Optional preferences for each channel type in the assigned workflow.',
  })
  @ValidateNested()
  @Type(() => ChannelPreference)
  @IsOptional()
  channel?: ChannelPreference;

  @ApiPropertyOptional({
    description: 'Indicates whether the workflow is fully enabled for all channels for the subscriber.',
    type: Boolean,
  })
  @IsBoolean()
  @IsOptional()
  enabled?: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateSubscriberPreferenceRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/dtos/update-subscriber-preference-response.dto.ts
Tamaño: 4278 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import {
  CustomDataType,
  INotificationTrigger,
  INotificationTriggerVariable,
  ITemplateConfiguration,
  ITriggerReservedVariable,
  TemplateVariableTypeEnum,
  TriggerContextTypeEnum,
  TriggerTypeEnum,
} from '@novu/shared';
import { SubscriberPreferenceChannels } from '../../shared/dtos/preference-channels';

class Preference {
  @ApiProperty({
    description: 'Sets if the workflow is fully enabled for all channels or not for the subscriber.',
    type: Boolean,
  })
  enabled: boolean;

  @ApiProperty({
    type: SubscriberPreferenceChannels,
    description: 'Subscriber preferences for the different channels regarding this workflow',
  })
  channels: SubscriberPreferenceChannels;
}

export class NotificationTriggerVariableResponse implements INotificationTriggerVariable {
  @ApiProperty({
    type: String,
    description: 'The name of the variable',
  })
  name: string;

  @ApiPropertyOptional()
  @ApiProperty({
    description: 'The value of the variable',
  })
  value?: any;

  @ApiPropertyOptional()
  @ApiProperty({
    enum: TemplateVariableTypeEnum,
    description: 'The type of the variable',
  })
  type?: TemplateVariableTypeEnum;
}

export class TriggerReservedVariableResponse implements ITriggerReservedVariable {
  @ApiProperty({
    enum: TriggerContextTypeEnum,
    description: 'The type of the reserved variable',
  })
  type: TriggerContextTypeEnum;

  @ApiProperty({
    type: Array<NotificationTriggerVariableResponse>,
    description: 'The reserved variables of the trigger',
  })
  variables: NotificationTriggerVariableResponse[];
}

export class NotificationTriggerResponse implements INotificationTrigger {
  @ApiProperty({
    enum: [...Object.values(TriggerTypeEnum)],
    enumName: 'TriggerTypeEnum',
    description: 'The type of the trigger',
  })
  type: TriggerTypeEnum;

  @ApiProperty({
    type: String,
    description: 'The identifier of the trigger',
  })
  identifier: string;

  @ApiProperty({
    type: [NotificationTriggerVariableResponse],
    description: 'The variables of the trigger',
  })
  variables: NotificationTriggerVariableResponse[];

  @ApiPropertyOptional()
  @ApiProperty({
    type: [NotificationTriggerVariableResponse],
    description: 'The subscriber variables of the trigger',
  })
  subscriberVariables?: NotificationTriggerVariableResponse[];

  @ApiPropertyOptional()
  @ApiProperty({
    type: [TriggerReservedVariableResponse],
    description: 'The reserved variables of the trigger',
  })
  reservedVariables?: TriggerReservedVariableResponse[];
}

class TemplateResponse implements ITemplateConfiguration {
  @ApiProperty({
    description: 'Unique identifier of the workflow',
    type: String,
  })
  _id: string;

  @ApiProperty({
    description: 'Name of the workflow',
    type: String,
  })
  name: string;

  @ApiProperty({
    description:
      'Critical templates will always be delivered to the end user and should be hidden from the subscriber preferences screen',
    type: Boolean,
  })
  critical: boolean;

  @ApiProperty({
    description: 'Triggers are the events that will trigger the workflow.',
    type: [NotificationTriggerResponse], // Use an array syntax
  })
  triggers: NotificationTriggerResponse[];

  @ApiProperty({
    description: 'Tags applied to the workflow.',
    type: [String],
  })
  tags?: string[];

  @ApiProperty({
    description: 'The custom data of the workflow.',
    type: Object,
  })
  data?: CustomDataType;

  @ApiPropertyOptional({
    description: "The date and time the workflow was last updated. It's in ISO 8601 format.",
    type: String,
  })
  updatedAt?: string;
}
export class UpdateSubscriberPreferenceResponseDto {
  @ApiProperty({
    type: TemplateResponse,
    description: 'The workflow information and if it is critical or not',
  })
  template: TemplateResponse;

  @ApiProperty({
    type: Preference,
    description: 'The preferences of the subscriber regarding the related workflow',
  })
  preference: Preference;
}
export class UpdateSubscriberPreferenceGlobalResponseDto {
  @ApiProperty({
    type: Preference,
    description: 'The preferences of the subscriber regarding the related workflow',
  })
  preference: Preference;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class NotificationTriggerVariableResponse
- export class TriggerReservedVariableResponse
- export class NotificationTriggerResponse
- export class UpdateSubscriberPreferenceResponseDto
- export class UpdateSubscriberPreferenceGlobalResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/e2e/get-count.e2e.ts
Tamaño: 13663 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import {
  buildFeedKey,
  buildMessageCountKey,
  CacheInMemoryProviderService,
  CacheService,
  InvalidateCacheService,
} from '@novu/application-generic';
import { MessageRepository, NotificationTemplateEntity, SubscriberRepository } from '@novu/dal';
import { ChannelTypeEnum, InAppProviderIdEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import axios from 'axios';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Count - GET /widget/notifications/count #novu-v0', () => {
  const messageRepository = new MessageRepository();
  let session: UserSession;
  let template: NotificationTemplateEntity;
  let subscriberId: string;
  let subscriberToken: string;
  let subscriberProfile: {
    _id: string;
  } | null = null;

  let invalidateCache: InvalidateCacheService;
  let cacheInMemoryProviderService: CacheInMemoryProviderService;
  let novuClient: Novu;
  before(async () => {
    cacheInMemoryProviderService = new CacheInMemoryProviderService();
    const cacheService = new CacheService(cacheInMemoryProviderService);
    await cacheService.initialize();
    invalidateCache = new InvalidateCacheService(cacheService);
  });

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    novuClient = initNovuClassSdk(session);

    subscriberId = SubscriberRepository.createObjectId();

    template = await session.createTemplate({
      noFeedId: true,
    });

    const { body } = await session.testAgent
      .post('/v1/widgets/session/initialize')
      .send({
        applicationIdentifier: session.environment.identifier,
        subscriberId,
        firstName: 'Test',
        lastName: 'User',
        email: 'test@example.com',
      })
      .expect(201);

    const { token, profile } = body.data;

    subscriberToken = token;
    subscriberProfile = profile;
  });

  it('should return unseen count', async () => {
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    const messages = await messageRepository.findBySubscriberChannel(
      session.environment._id,
      String(subscriberProfile?._id),
      ChannelTypeEnum.IN_APP
    );
    const seenCount = (await getFeedCount()).data.count;
    expect(seenCount).to.equal(3);
  });

  it('should return unseen count after on message was seen', async () => {
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    const messages = await messageRepository.findBySubscriberChannel(
      session.environment._id,
      String(subscriberProfile?._id),
      ChannelTypeEnum.IN_APP
    );

    const messageId = messages[0]._id;

    await messageRepository.update(
      { _environmentId: session.environment._id, _id: messageId },
      {
        $set: {
          seen: true,
        },
      }
    );

    await invalidateSeenFeed(invalidateCache, subscriberId, session);

    const seenCount = (await getFeedCount()).data.count;
    expect(seenCount).to.equal(2);
  });

  it('should return unseen count after on message was read', async () => {
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    const messages = await messageRepository.findBySubscriberChannel(
      session.environment._id,
      String(subscriberProfile?._id),
      ChannelTypeEnum.IN_APP
    );

    const messageId = messages[0]._id;

    await messageRepository.update(
      { _environmentId: session.environment._id, _id: messageId },
      {
        $set: {
          read: true,
        },
      }
    );

    await invalidateSeenFeed(invalidateCache, subscriberId, session);

    const seenCount = (await getFeedCount()).data.count;
    expect(seenCount).to.equal(3);

    const unReadCount = (await getFeedCount({ read: false })).data.count;
    expect(unReadCount).to.equal(2);
  });

  it('should return unseen count by limit', async () => {
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    try {
      await getFeedCount({ seen: false, limit: 0 });
      throw new Error('Exception should have been thrown');
    } catch (e) {
      const message = Array.isArray(e.response.data.message) ? e.response.data.message[0] : e.response.data.message;
      expect(message).to.equal('limit must not be less than 1');
    }

    let unseenCount = (await getFeedCount({ seen: false, limit: 1 })).data.count;
    expect(unseenCount).to.equal(1);

    unseenCount = (await getFeedCount({ seen: false, limit: 2 })).data.count;
    expect(unseenCount).to.equal(2);

    unseenCount = (await getFeedCount({ seen: false, limit: 4 })).data.count;
    expect(unseenCount).to.equal(3);

    unseenCount = (await getFeedCount({ seen: false, limit: 99 })).data.count;
    expect(unseenCount).to.equal(3);

    unseenCount = (await getFeedCount({ seen: false, limit: 100 })).data.count;
    expect(unseenCount).to.equal(3);

    try {
      await getFeedCount({ seen: false, limit: 101 });
      throw new Error('Exception should have been thrown');
    } catch (e) {
      const message = Array.isArray(e.response.data.message) ? e.response.data.message[0] : e.response.data.message;
      expect(message).to.equal('limit must not be greater than 100');
    }
  });

  it('should return unseen count by default limit 100', async () => {
    for (let i = 0; i < 102; i += 1) {
      await messageRepository.create({
        _notificationId: MessageRepository.createObjectId(),
        _environmentId: session.environment._id,
        _organizationId: session.organization._id,
        _subscriberId: subscriberProfile?._id,
        _templateId: template._id,
        _messageTemplateId: template.steps[0]._templateId,
        channel: ChannelTypeEnum.IN_APP,
        cta: {},
        transactionId: MessageRepository.createObjectId(),
        content: template.steps,
        payload: {},
        providerId: InAppProviderIdEnum.Novu,
        templateIdentifier: template.triggers[0].identifier,
        seen: false,
      });
    }

    const unseenCount = (await getFeedCount({ seen: false })).data.count;
    expect(unseenCount).to.equal(100);
  });

  it('should return default on string non numeric(NaN) value', async () => {
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    const unseenCount = (await getFeedCount({ seen: false, limit: 'what what' })).data.count;
    expect(unseenCount).to.equal(2);
  });

  it('should return parse numeric string to number', async () => {
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    try {
      await getFeedCount({ seen: false, limit: '0' });
      throw new Error('Exception should have been thrown');
    } catch (e) {
      const message = Array.isArray(e.response.data.message) ? e.response.data.message[0] : e.response.data.message;
      expect(message).to.equal('limit must not be less than 1');
    }

    let unseenCount = (await getFeedCount({ seen: false, limit: '1' })).data.count;
    expect(unseenCount).to.equal(1);

    unseenCount = (await getFeedCount({ seen: false, limit: '2' })).data.count;
    expect(unseenCount).to.equal(2);

    unseenCount = (await getFeedCount({ seen: false, limit: '99' })).data.count;
    expect(unseenCount).to.equal(2);

    unseenCount = (await getFeedCount({ seen: false, limit: '100' })).data.count;
    expect(unseenCount).to.equal(2);

    try {
      await getFeedCount({ seen: false, limit: '101' });
      throw new Error('Exception should have been thrown');
    } catch (e) {
      const message = Array.isArray(e.response.data.message) ? e.response.data.message[0] : e.response.data.message;
      expect(message).to.equal('limit must not be greater than 100');
    }
  });

  it('should return unseen count with a seen filter', async () => {
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    const messages = await messageRepository.findBySubscriberChannel(
      session.environment._id,
      String(subscriberProfile?._id),
      ChannelTypeEnum.IN_APP
    );
    const messageId = messages[0]._id;
    expect(messages[0].seen).to.equal(false);

    await axios.post(
      `http://127.0.0.1:${process.env.PORT}/v1/widgets/messages/markAs`,
      { messageId, mark: { seen: true } },
      {
        headers: {
          Authorization: `Bearer ${subscriberToken}`,
        },
      }
    );

    const unseenFeed = await getFeedCount({ seen: false });
    expect(unseenFeed.data.count).to.equal(2);
  });

  it('should return unread count with a read filter', async () => {
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);
    if (!subscriberProfile) throw new Error('Subscriber profile is null');

    const messages = await messageRepository.findBySubscriberChannel(
      session.environment._id,
      subscriberProfile._id,
      ChannelTypeEnum.IN_APP
    );

    const messageId = messages[0]._id;
    expect(messages[0].read).to.equal(false);

    await axios.post(
      `http://127.0.0.1:${process.env.PORT}/v1/widgets/messages/markAs`,
      { messageId, mark: { seen: true, read: true } },
      {
        headers: {
          Authorization: `Bearer ${subscriberToken}`,
        },
      }
    );

    const readFeed = await getFeedCount({ read: true });
    expect(readFeed.data.count).to.equal(1);

    const unreadFeed = await getFeedCount({ read: false });
    expect(unreadFeed.data.count).to.equal(2);
  });

  it('should return unseen count after mark as request', async () => {
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    const messages = await messageRepository.findBySubscriberChannel(
      session.environment._id,
      String(subscriberProfile?._id),
      ChannelTypeEnum.IN_APP
    );
    const messageId = messages[0]._id;

    let seenCount = (await getFeedCount({ seen: false })).data.count;
    expect(seenCount).to.equal(3);

    await invalidateCache.invalidateQuery({
      key: buildFeedKey().invalidate({
        subscriberId,
        _environmentId: session.environment._id,
      }),
    });

    await invalidateCache.invalidateQuery({
      key: buildMessageCountKey().invalidate({
        subscriberId,
        _environmentId: session.environment._id,
      }),
    });

    await axios.post(
      `http://127.0.0.1:${process.env.PORT}/v1/widgets/messages/markAs`,
      { messageId, mark: { seen: true } },
      {
        headers: {
          Authorization: `Bearer ${subscriberToken}`,
        },
      }
    );

    seenCount = (await getFeedCount({ seen: false })).data.count;
    expect(seenCount).to.equal(2);
  });

  async function getFeedCount(query = {}) {
    const response = await axios.get(`http://127.0.0.1:${process.env.PORT}/v1/widgets/notifications/count`, {
      params: {
        ...query,
      },
      headers: {
        Authorization: `Bearer ${subscriberToken}`,
      },
    });

    return response.data;
  }
});

async function invalidateSeenFeed(invalidateCache: InvalidateCacheService, subscriberId: string, session) {
  await invalidateCache.invalidateQuery({
    key: buildFeedKey().invalidate({
      subscriberId,
      _environmentId: session.environment._id,
    }),
  });

  await invalidateCache.invalidateQuery({
    key: buildMessageCountKey().invalidate({
      subscriberId,
      _environmentId: session.environment._id,
    }),
  });
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getFeedCount(query = {})
 - invalidateSeenFeed(invalidateCache: InvalidateCacheService, subscriberId: string, session)
Asignaciones con arrow functions encontradas (posibles funciones):
 - null(null;

  let invalidateCache: InvalidateCacheService;
  let cacheInMemoryProviderService: CacheInMem...)
 - invalidateCache(new InvalidateCacheService(cacheService);
  });

  beforeEach(async ())
 - subscriberProfile(profile;
  });

  it('should return unseen count', async ())
 - seenCount(await getFeedCount()).data.count;
    expect(seenCount).to.equal(3);
  });

  it('should return unse...)
 - seenCount(await getFeedCount()).data.count;
    expect(seenCount).to.equal(2);
  });

  it('should return unse...)
 - unReadCount(await getFeedCount({ read: false })).data.count;
    expect(unReadCount).to.equal(2);
  });

  it('s...)
 - message(Array.isArray(e.response.data.message) ? e.response.data.message[0] : e.response.data.message;
     ...)
 - unseenCount(await getFeedCount({ seen: false })).data.count;
    expect(unseenCount).to.equal(100);
  });

  it(...)
 - unseenCount(await getFeedCount({ seen: false, limit: 'what what' })).data.count;
    expect(unseenCount).to.equa...)
 - message(Array.isArray(e.response.data.message) ? e.response.data.message[0] : e.response.data.message;
     ...)
 - unseenFeed(await getFeedCount({ seen: false });
    expect(unseenFeed.data.count).to.equal(2);
  });

  it('sho...)
 - unreadFeed(await getFeedCount({ read: false });
    expect(unreadFeed.data.count).to.equal(2);
  });

  it('sho...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/e2e/get-notification-feed.e2e.ts
Tamaño: 8488 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { MessageRepository, NotificationTemplateEntity, SubscriberRepository } from '@novu/dal';
import { ChannelTypeEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import axios from 'axios';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('GET /widget/notifications/feed #novu-v0', () => {
  const messageRepository = new MessageRepository();
  let session: UserSession;
  let template: NotificationTemplateEntity;
  let subscriberId: string;
  let subscriberToken: string;
  let subscriberProfile: {
    _id: string;
  } | null = null;
  let novuClient: Novu;
  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    subscriberId = SubscriberRepository.createObjectId();

    template = await session.createTemplate({
      noFeedId: true,
    });

    const { body } = await session.testAgent.post('/v1/widgets/session/initialize').send({
      applicationIdentifier: session.environment.identifier,
      subscriberId,
      firstName: 'Test',
      lastName: 'User',
      email: 'test@example.com',
    });

    expect(body).to.be.ok;
    expect(body.data).to.be.ok;

    const { token, profile } = body.data;

    subscriberToken = token;
    subscriberProfile = profile;
    novuClient = initNovuClassSdk(session);
  });

  it('should fetch a feed without filters and with feed id', async () => {
    /**
     * This test help preventing accidental passing `null` as a feed id which causes
     * the feed to be fetched with explicit null as a property of feedId.
     *
     * This test will fail if the feedId is not passed as a query parameter,
     * but the null query still was applied mistakenly
     */
    template = await session.createTemplate();

    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    const response = await getSubscriberFeed();
    expect(response.data.length).to.equal(2);
  });

  it('should fetch a feed without filters', async () => {
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    const response = await getSubscriberFeed();
    expect(response.data.length).to.equal(2);
  });

  it('should filter only unseen messages', async () => {
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    const messages = await messageRepository.findBySubscriberChannel(
      session.environment._id,
      subscriberProfile?._id as string,
      ChannelTypeEnum.IN_APP
    );
    const messageId = messages[0]._id;
    expect(messages[0].seen).to.equal(false);

    await markMessageAsSeen(messageId);

    const seenFeed = await getSubscriberFeed({ seen: true });
    expect(seenFeed.data.length).to.equal(1);
    expect(seenFeed.data[0]._id).to.equal(messageId);

    const unseenFeed = await getSubscriberFeed({ seen: false });
    expect(unseenFeed.data.length).to.equal(1);
    expect(unseenFeed.data[0]._id).to.not.equal(messageId);
  });

  it('should return seen and unseen', async () => {
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    const messages = await messageRepository.findBySubscriberChannel(
      session.environment._id,
      subscriberProfile?._id as string,
      ChannelTypeEnum.IN_APP
    );
    const messageId = messages[0]._id;
    expect(messages[0].seen).to.equal(false);

    await markMessageAsSeen(messageId);

    const seenFeed = await getSubscriberFeed({ seen: true });
    expect(seenFeed.data.length).to.equal(1);
    expect(seenFeed.data[0]._id).to.equal(messageId);

    const unseenFeed = await getSubscriberFeed({ seen: false });
    expect(unseenFeed.data.length).to.equal(1);
    expect(unseenFeed.data[0]._id).to.not.equal(messageId);

    const seenUnseenFeed = await getSubscriberFeed();
    expect(seenUnseenFeed.data.length).to.equal(2);
  });

  it('should include subscriber object', async () => {
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    const feed = await getSubscriberFeed();

    expect(feed.data[0]).to.be.an('object').that.has.any.keys('subscriber');
  });

  it('should include hasMore when there is more notification', async () => {
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    let feed = await getSubscriberFeed();

    expect(feed.data.length).to.be.equal(1);
    expect(feed.totalCount).to.be.equal(1);
    expect(feed.hasMore).to.be.equal(false);

    for (let i = 0; i < 10; i += 1) {
      await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    }

    await session.waitForJobCompletion(template._id);

    feed = await getSubscriberFeed();

    expect(feed.data.length).to.be.equal(10);
    expect(feed.totalCount).to.be.equal(10);
    expect(feed.hasMore).to.be.equal(true);
  });

  it('should throw exception when invalid payload query param is passed', async () => {
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    try {
      await getSubscriberFeed({ payload: 'invalid' });
    } catch (err) {
      expect(err.response.status).to.equals(400);
      expect(err.response.data.message).to.eq(`Invalid payload, the JSON object should be encoded to base64 string.`);

      return;
    }

    expect.fail('Should have thrown an bad request exception');
  });

  it('should allow filtering by custom data from the payload', async () => {
    const partialPayload = { foo: 123 };
    const payload = { ...partialPayload, bar: 'bar' };

    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId, payload });
    await session.waitForJobCompletion(template._id);

    const payloadQueryValue = Buffer.from(JSON.stringify(partialPayload)).toString('base64');
    const { data } = await getSubscriberFeed({ payload: payloadQueryValue });

    expect(data.length).to.equal(1);
    expect(data[0].payload).to.deep.equal(payload);
  });

  it('should allow filtering by custom nested data from the payload', async () => {
    const partialPayload = { foo: { bar: 123 } };
    const payload = { ...partialPayload, baz: 'baz' };

    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId, payload });
    await session.waitForJobCompletion(template._id);

    const payloadQueryValue = Buffer.from(JSON.stringify(partialPayload)).toString('base64');
    const { data } = await getSubscriberFeed({ payload: payloadQueryValue });

    expect(data.length).to.equal(1);
    expect(data[0].payload).to.deep.equal(payload);
  });

  async function getSubscriberFeed(query = {}) {
    const response = await axios.get(`http://127.0.0.1:${process.env.PORT}/v1/widgets/notifications/feed`, {
      params: {
        page: 0,
        ...query,
      },
      headers: {
        Authorization: `Bearer ${subscriberToken}`,
      },
    });

    return response.data;
  }

  async function markMessageAsSeen(messageId: string) {
    return await axios.post(
      `http://127.0.0.1:${process.env.PORT}/v1/widgets/messages/markAs`,
      { messageId, mark: { seen: true } },
      {
        headers: {
          Authorization: `Bearer ${subscriberToken}`,
        },
      }
    );
  }
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getSubscriberFeed(query = {})
 - markMessageAsSeen(messageId: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - null(null;
  let novuClient: Novu;
  beforeEach(async ())
 - novuClient(initNovuClassSdk(session);
  });

  it('should fetch a feed without filters and with feed id', async...)
 - response(await getSubscriberFeed();
    expect(response.data.length).to.equal(2);
  });

  it('should fetch a...)
 - response(await getSubscriberFeed();
    expect(response.data.length).to.equal(2);
  });

  it('should filter ...)
 - unseenFeed(await getSubscriberFeed({ seen: false });
    expect(unseenFeed.data.length).to.equal(1);
    expect...)
 - seenUnseenFeed(await getSubscriberFeed();
    expect(seenUnseenFeed.data.length).to.equal(2);
  });

  it('should i...)
 - feed(await getSubscriberFeed();

    expect(feed.data[0]).to.be.an('object').that.has.any.keys('subscribe...)
 - feed(await getSubscriberFeed();

    expect(feed.data.length).to.be.equal(10);
    expect(feed.totalCount...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/e2e/get-subscriber-preference.e2e.ts
Tamaño: 3729 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { NotificationTemplateEntity } from '@novu/dal';
import { ChannelTypeEnum } from '@novu/stateless';
import { UserSession } from '@novu/testing';
import axios from 'axios';
import { expect } from 'chai';
import { updateSubscriberPreference } from './update-subscriber-preference.e2e';

describe('GET /widget/preferences #novu-v0', () => {
  let template: NotificationTemplateEntity;
  let session: UserSession;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();

    template = await session.createTemplate({
      noFeedId: true,
    });
  });

  it('should fetch a default user preference', async () => {
    const response = await getSubscriberPreference(session.subscriberToken);

    const data = response.data.data[0];

    expect(data.template.name).to.exist;
    expect(data.template.tags[0]).to.equal('test-tag');
    expect(data.template.critical).to.equal(false);
    expect(data.template.triggers[0].identifier).to.contains('test-event-');

    expect(data.preference.channels.email).to.equal(true);
    expect(data.preference.channels.in_app).to.equal(true);

    expect(data.preference.overrides.find((sources) => sources.channel === 'email').source).to.equal('subscriber');
  });

  it('should fetch according to template preferences defaults ', async () => {
    const templateDefaultSettings = await session.createTemplate({
      preferenceSettingsOverride: { email: true, chat: true, push: true, sms: true, in_app: false },
      noFeedId: true,
    });
    const response = await getSubscriberPreference(session.subscriberToken);

    const data = response.data.data.find((pref) => pref.template._id === templateDefaultSettings._id);

    expect(data.preference.channels.email).to.equal(true);
    expect(data.preference.channels.in_app).to.equal(false);

    expect(data.preference.overrides.find((sources) => sources.channel === 'email').source).to.equal('subscriber');
  });

  // `enabled` flag is not used anymore. The presence of a preference object means that the subscriber has enabled notifications.
  it.skip('should fetch according to merged subscriber and template preferences ', async () => {
    const templateDefaultSettings = await session.createTemplate({
      preferenceSettingsOverride: { email: true, chat: true, push: true, sms: true, in_app: false },
      noFeedId: true,
    });

    const updateDataEmailFalse = {
      channel: {
        type: ChannelTypeEnum.EMAIL,
        enabled: false,
      },
    };

    await updateSubscriberPreference(updateDataEmailFalse, session.subscriberToken, templateDefaultSettings._id);

    const response = await getSubscriberPreference(session.subscriberToken);

    const data = response.data.data.find((pref) => pref.template._id === templateDefaultSettings._id);

    expect(data.preference.channels.email).to.equal(false);
    expect(data.preference.channels.in_app).to.equal(false);

    expect(data.preference.overrides.find((sources) => sources.channel === 'email').source).to.equal('subscriber');
    expect(data.preference.overrides.find((sources) => sources.channel === 'in_app').source).to.equal('template');
  });

  it('should filter not active channels and sources', async () => {
    const response = await getSubscriberPreference(session.subscriberToken);

    const data = response.data.data[0];

    expect(Object.keys(data.preference.channels).length).to.equal(2);
    expect(data.preference.overrides.length).to.equal(2);
  });
});

export async function getSubscriberPreference(subscriberToken: string) {
  return await axios.get(`http://127.0.0.1:${process.env.PORT}/v1/widgets/preferences`, {
    headers: {
      Authorization: `Bearer ${subscriberToken}`,
    },
  });
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getSubscriberPreference(subscriberToken: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - template(await session.createTemplate({
      noFeedId: true,
    });
  });

  it('should fetch a default use...)
 - data(response.data.data[0];

    expect(data.template.name).to.exist;
    expect(data.template.tags[0]).t...)
 - data(response.data.data.find((pref))
 - data(response.data.data.find((pref))
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/e2e/get-unread-count.e2e.ts
Tamaño: 4794 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { MessageRepository, NotificationTemplateEntity, SubscriberRepository } from '@novu/dal';
import { ChannelTypeEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import axios from 'axios';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Unread Count - GET /widget/notifications/unread #novu-v0', () => {
  const messageRepository = new MessageRepository();
  let session: UserSession;
  let template: NotificationTemplateEntity;
  let subscriberId: string;
  let subscriberToken: string;
  let subscriberProfile: {
    _id: string;
  } | null = null;
  let novuClient: Novu;
  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    subscriberId = SubscriberRepository.createObjectId();
    novuClient = initNovuClassSdk(session);

    template = await session.createTemplate({
      noFeedId: true,
    });

    const { body } = await session.testAgent
      .post('/v1/widgets/session/initialize')
      .send({
        applicationIdentifier: session.environment.identifier,
        subscriberId,
        firstName: 'Test',
        lastName: 'User',
        email: 'test@example.com',
      })
      .expect(201);

    const { token, profile } = body.data;

    subscriberToken = token;
    subscriberProfile = profile;
  });

  it('should return unread count with no query', async () => {
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    const messages = await messageRepository.findBySubscriberChannel(
      session.environment._id,
      subscriberProfile!._id,
      ChannelTypeEnum.IN_APP
    );
    const messageId = messages[0]._id;
    expect(messages[0].read).to.equal(false);

    await axios.post(
      `http://127.0.0.1:${process.env.PORT}/v1/widgets/messages/markAs`,
      { messageId, mark: { read: true } },
      {
        headers: {
          Authorization: `Bearer ${subscriberToken}`,
        },
      }
    );

    const unreadFeed = await getUnreadCount();
    expect(unreadFeed.data.count).to.equal(2);
  });

  it('should return unread count with query read false', async () => {
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    const messages = await messageRepository.findBySubscriberChannel(
      session.environment._id,
      subscriberProfile!._id,
      ChannelTypeEnum.IN_APP
    );
    const messageId = messages[0]._id;
    expect(messages[0].read).to.equal(false);

    await axios.post(
      `http://127.0.0.1:${process.env.PORT}/v1/widgets/messages/markAs`,
      { messageId, mark: { read: true } },
      {
        headers: {
          Authorization: `Bearer ${subscriberToken}`,
        },
      }
    );

    const unreadFeed = await getUnreadCount({ read: false });
    expect(unreadFeed.data.count).to.equal(2);
  });

  it('should return unread count with query read true', async () => {
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    const messages = await messageRepository.findBySubscriberChannel(
      session.environment._id,
      subscriberProfile!._id,
      ChannelTypeEnum.IN_APP
    );
    const messageId = messages[0]._id;
    expect(messages[0].read).to.equal(false);

    await axios.post(
      `http://127.0.0.1:${process.env.PORT}/v1/widgets/messages/markAs`,
      { messageId, mark: { read: true } },
      {
        headers: {
          Authorization: `Bearer ${subscriberToken}`,
        },
      }
    );

    const readFeed = await getUnreadCount({ read: true });
    expect(readFeed.data.count).to.equal(1);
  });

  async function getUnreadCount(query = {}) {
    const response = await axios.get(`http://127.0.0.1:${process.env.PORT}/v1/widgets/notifications/unread`, {
      params: {
        ...query,
      },
      headers: {
        Authorization: `Bearer ${subscriberToken}`,
      },
    });

    return response.data;
  }
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getUnreadCount(query = {})
Asignaciones con arrow functions encontradas (posibles funciones):
 - null(null;
  let novuClient: Novu;
  beforeEach(async ())
 - subscriberProfile(profile;
  });

  it('should return unread count with no query', async ())
 - unreadFeed(await getUnreadCount();
    expect(unreadFeed.data.count).to.equal(2);
  });

  it('should return un...)
 - unreadFeed(await getUnreadCount({ read: false });
    expect(unreadFeed.data.count).to.equal(2);
  });

  it('s...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/e2e/get-unseen-count.e2e.ts
Tamaño: 6818 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import {
  buildFeedKey,
  buildMessageCountKey,
  CacheInMemoryProviderService,
  CacheService,
  InvalidateCacheService,
} from '@novu/application-generic';
import { MessageRepository, NotificationTemplateEntity, SubscriberRepository } from '@novu/dal';
import { ChannelTypeEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import axios from 'axios';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Unseen Count - GET /widget/notifications/unseen #novu-v0', () => {
  const messageRepository = new MessageRepository();
  let session: UserSession;
  let template: NotificationTemplateEntity;
  let subscriberId: string;
  let subscriberToken: string;
  let subscriberProfile: {
    _id: string;
  } | null = null;

  let cacheInMemoryProviderService: CacheInMemoryProviderService;
  let invalidateCache: InvalidateCacheService;
  let novuClient: Novu;
  before(async () => {
    cacheInMemoryProviderService = new CacheInMemoryProviderService();
    const cacheService = new CacheService(cacheInMemoryProviderService);
    await cacheService.initialize();
    invalidateCache = new InvalidateCacheService(cacheService);
  });

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    novuClient = initNovuClassSdk(session);

    subscriberId = SubscriberRepository.createObjectId();

    template = await session.createTemplate({
      noFeedId: true,
    });

    const { body } = await session.testAgent
      .post('/v1/widgets/session/initialize')
      .send({
        applicationIdentifier: session.environment.identifier,
        subscriberId,
        firstName: 'Test',
        lastName: 'User',
        email: 'test@example.com',
      })
      .expect(201);

    const { token, profile } = body.data;

    subscriberToken = token;
    subscriberProfile = profile;
  });

  it('should return unseen count with no query', async () => {
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    const messages = await messageRepository.findBySubscriberChannel(
      session.environment._id,
      String(subscriberProfile?._id),
      ChannelTypeEnum.IN_APP
    );
    const messageId = messages[0]._id;
    expect(messages[0].seen).to.equal(false);

    await axios.post(
      `http://127.0.0.1:${process.env.PORT}/v1/widgets/messages/markAs`,
      { messageId, mark: { seen: true } },
      {
        headers: {
          Authorization: `Bearer ${subscriberToken}`,
        },
      }
    );

    const unseenFeed = await getUnseenCount();
    expect(unseenFeed.data.count).to.equal(2);
  });

  it('should return unseen count with query seen false', async () => {
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    const messages = await messageRepository.findBySubscriberChannel(
      session.environment._id,
      String(subscriberProfile?._id),
      ChannelTypeEnum.IN_APP
    );
    const messageId = messages[0]._id;
    expect(messages[0].seen).to.equal(false);

    await axios.post(
      `http://127.0.0.1:${process.env.PORT}/v1/widgets/messages/markAs`,
      { messageId, mark: { seen: true } },
      {
        headers: {
          Authorization: `Bearer ${subscriberToken}`,
        },
      }
    );

    const unseenFeed = await getUnseenCount({ seen: false });
    expect(unseenFeed.data.count).to.equal(2);
  });

  it('should return unseen count with query seen true', async () => {
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    const messages = await messageRepository.findBySubscriberChannel(
      session.environment._id,
      String(subscriberProfile?._id),
      ChannelTypeEnum.IN_APP
    );
    const messageId = messages[0]._id;
    expect(messages[0].seen).to.equal(false);

    await axios.post(
      `http://127.0.0.1:${process.env.PORT}/v1/widgets/messages/markAs`,
      { messageId, mark: { seen: true } },
      {
        headers: {
          Authorization: `Bearer ${subscriberToken}`,
        },
      }
    );

    const seenFeed = await getUnseenCount({ seen: true });
    expect(seenFeed.data.count).to.equal(1);
  });

  it('should return unseen count after mark as request', async () => {
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    const messages = await messageRepository.findBySubscriberChannel(
      session.environment._id,
      String(subscriberProfile?._id),
      ChannelTypeEnum.IN_APP
    );
    const messageId = messages[0]._id;

    let seenCount = (await getUnseenCount({ seen: false })).data.count;
    expect(seenCount).to.equal(3);

    await invalidateCache.invalidateQuery({
      key: buildFeedKey().invalidate({
        subscriberId,
        _environmentId: session.environment._id,
      }),
    });

    await invalidateCache.invalidateQuery({
      key: buildMessageCountKey().invalidate({
        subscriberId,
        _environmentId: session.environment._id,
      }),
    });

    await axios.post(
      `http://127.0.0.1:${process.env.PORT}/v1/widgets/messages/markAs`,
      { messageId, mark: { seen: true } },
      {
        headers: {
          Authorization: `Bearer ${subscriberToken}`,
        },
      }
    );

    seenCount = (await getUnseenCount({ seen: false })).data.count;
    expect(seenCount).to.equal(2);
  });

  async function getUnseenCount(query = {}) {
    const response = await axios.get(`http://127.0.0.1:${process.env.PORT}/v1/widgets/notifications/unseen`, {
      params: {
        ...query,
      },
      headers: {
        Authorization: `Bearer ${subscriberToken}`,
      },
    });

    return response.data;
  }
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getUnseenCount(query = {})
Asignaciones con arrow functions encontradas (posibles funciones):
 - null(null;

  let cacheInMemoryProviderService: CacheInMemoryProviderService;
  let invalidateCache: Inva...)
 - invalidateCache(new InvalidateCacheService(cacheService);
  });

  beforeEach(async ())
 - subscriberProfile(profile;
  });

  it('should return unseen count with no query', async ())
 - unseenFeed(await getUnseenCount();
    expect(unseenFeed.data.count).to.equal(2);
  });

  it('should return un...)
 - unseenFeed(await getUnseenCount({ seen: false });
    expect(unseenFeed.data.count).to.equal(2);
  });

  it('s...)
 - seenFeed(await getUnseenCount({ seen: true });
    expect(seenFeed.data.count).to.equal(1);
  });

  it('shou...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/e2e/initialize-widget-session.e2e.ts
Tamaño: 5756 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  buildIntegrationKey,
  CacheInMemoryProviderService,
  CacheService,
  createHash,
  InvalidateCacheService,
} from '@novu/application-generic';
import { IntegrationRepository } from '@novu/dal';
import { ChannelTypeEnum, InAppProviderIdEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

// import { encryptApiKeysMigration } from '../../../../migrations/encrypt-api-keys/encrypt-api-keys-migration';

const integrationRepository = new IntegrationRepository();
const subscriberId = '12345';

describe('Initialize Session - /widgets/session/initialize (POST) #novu-v0', async () => {
  let session: UserSession;
  let invalidateCache: InvalidateCacheService;

  before(async () => {
    const cacheInMemoryProviderService = new CacheInMemoryProviderService();
    const cacheService = new CacheService(cacheInMemoryProviderService);
    await cacheService.initialize();
    invalidateCache = new InvalidateCacheService(cacheService);
  });

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();

    await setHmacConfig(subscriberId, session, invalidateCache);
  });

  it('should create a valid app session for current widget user', async () => {
    const secretKey = session.environment.apiKeys[0].key;
    const hmacHash = createHash(secretKey, subscriberId);

    const firstName = 'Test';
    const lastName = 'User';
    const phone = '054777777';

    const result = await session.testAgent.post('/v1/widgets/session/initialize').send({
      applicationIdentifier: session.environment.identifier,
      subscriberId,
      firstName,
      lastName,
      email: 'test@example.com',
      phone,
      hmacHash,
    });

    const { body } = result;

    expect(body.data.token).to.be.ok;
    expect(body.data.profile._id).to.be.ok;
    expect(body.data.profile.firstName).to.equal(firstName);
    expect(body.data.profile.lastName).to.equal(lastName);
    expect(body.data.profile.phone).to.equal(phone);
  });

  it('should throw an error when an invalid environment Id passed', async () => {
    const { body } = await session.testAgent.post('/v1/widgets/session/initialize').send({
      applicationIdentifier: 'some-not-existing-id',
      subscriberId,
      firstName: 'Test',
      lastName: 'User',
      email: 'test@example.com',
      phone: '054777777',
    });

    expect(body.message).to.contain('Please provide a valid app identifier');
  });

  it('should pass the test with valid HMAC hash', async () => {
    const secretKey = session.environment.apiKeys[0].key;

    const hmacHash = createHash(secretKey, subscriberId);
    const response = await initWidgetSession(subscriberId, session, hmacHash);

    expect(response.status).to.equal(201);
  });

  it('should fail the test with invalid subscriber id', async () => {
    const validSecretKey = session.environment.apiKeys[0].key;

    const invalidSubscriberId = `invalid-suscriberId`;
    const validSubscriberHmacHash = createHash(validSecretKey, subscriberId);
    const responseInvalidSubscriberId = await initWidgetSession(invalidSubscriberId, session, validSubscriberHmacHash);

    expect(responseInvalidSubscriberId.body?.data?.profile).to.not.exist;
    expect(responseInvalidSubscriberId.body.message).to.contain('Please provide a valid HMAC hash');
  });

  it('should fail the test with invalid secret key', async () => {
    const validSecretKey = session.environment.apiKeys[0].key;

    const invalidSecretKey = 'invalid-secret-key';
    const invalidSubscriberHmacHash = createHash(invalidSecretKey, subscriberId);

    const responseInvalidSecretKey = await initWidgetSession(subscriberId, session, invalidSubscriberHmacHash);

    expect(responseInvalidSecretKey.body?.data?.profile).to.not.exist;
    expect(responseInvalidSecretKey.body.message).to.contain('Please provide a valid HMAC hash');
  });

  /*
   * it('should pass api key migration regression tests', async function () {
   *   const validSecretKey = session.environment.apiKeys[0].key;
   */

  //   const invalidSubscriberHmacHash = createHash(validSecretKey, subscriberId);

  //   await encryptApiKeysMigration();

  //   const response = await initWidgetSession(subscriberId, session, invalidSubscriberHmacHash);

  /*
   *   expect(response.status).to.equal(201);
   * });
   */
});

async function initWidgetSession(subscriberIdentifier: string, session, hmacHash?: string) {
  return await session.testAgent.post('/v1/widgets/session/initialize').send({
    applicationIdentifier: session.environment.identifier,
    subscriberId: subscriberIdentifier,
    firstName: 'Test',
    lastName: 'User',
    email: 'test@example.com',
    phone: '054777777',
    hmacHash,
  });
}

async function setHmacConfig(userId: string, session: UserSession, invalidateCache: InvalidateCacheService) {
  await invalidateCache.invalidateQuery({
    key: buildIntegrationKey().invalidate({
      _organizationId: session.organization._id,
    }),
  });

  const command = {
    environmentId: session.environment._id,
    userId,
    providerId: InAppProviderIdEnum.Novu,
    channel: ChannelTypeEnum.IN_APP,
  };

  await invalidateCache.invalidateByKey({
    key: buildIntegrationKey().cache({
      _organizationId: session.organization._id,
      ...command,
    }),
  });

  const result = await integrationRepository.update(
    {
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      providerId: InAppProviderIdEnum.Novu,
      channel: ChannelTypeEnum.IN_APP,
      active: true,
    },
    {
      $set: {
        'credentials.hmac': true,
      },
    }
  );

  expect(result.matched).to.equal(1);
  expect(result.modified).to.equal(1);
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - initWidgetSession(subscriberIdentifier: string, session, hmacHash?: string)
 - setHmacConfig(userId: string, session: UserSession, invalidateCache: InvalidateCacheService)
Asignaciones con arrow functions encontradas (posibles funciones):
 - subscriberId('12345';

describe('Initialize Session - /widgets/session/initialize (POST) #novu-v0', async ())
 - invalidateCache(new InvalidateCacheService(cacheService);
  });

  beforeEach(async ())
 - session(new UserSession();
    await session.initialize();

    await setHmacConfig(subscriberId, session, i...)
 - response(await initWidgetSession(subscriberId, session, hmacHash);

    expect(response.status).to.equal(201)...)
 - responseInvalidSubscriberId(await initWidgetSession(invalidSubscriberId, session, validSubscriberHmacHash);

    expect(response...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/e2e/mark-all-as-read.e2e.ts
Tamaño: 3707 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { MessageRepository, NotificationTemplateEntity, SubscriberRepository } from '@novu/dal';
import { UserSession } from '@novu/testing';
import axios from 'axios';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Mark all as read - /widgets/messages/seen (POST) #novu-v0', () => {
  const messageRepository = new MessageRepository();
  let session: UserSession;
  let template: NotificationTemplateEntity;
  let subscriberId: string;
  let subscriberToken: string;
  let subscriberProfile: {
    _id: string;
  } | null = null;
  let novuClient: Novu;
  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    subscriberId = SubscriberRepository.createObjectId();
    novuClient = initNovuClassSdk(session);

    template = await session.createTemplate({
      noFeedId: true,
    });

    const { body } = await session.testAgent
      .post('/v1/widgets/session/initialize')
      .send({
        applicationIdentifier: session.environment.identifier,
        subscriberId,
        firstName: 'Test',
        lastName: 'User',
        email: 'test@example.com',
      })
      .expect(201);

    const { token, profile } = body.data;

    subscriberToken = token;
    subscriberProfile = profile;
  });

  it('should mark all as seen', async () => {
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    const unseenMessagesBefore = await getFeedCount({ seen: false });
    expect(unseenMessagesBefore.data.count).to.equal(3);

    await axios.post(
      `http://127.0.0.1:${process.env.PORT}/v1/widgets/messages/seen`,
      {},
      {
        headers: {
          Authorization: `Bearer ${subscriberToken}`,
        },
      }
    );

    const unseenMessagesAfter = await getFeedCount({ seen: false });
    expect(unseenMessagesAfter.data.count).to.equal(0);
  });

  it('should mark all as read', async () => {
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    const unseenMessagesBefore = await getNotificationCount('read=false');

    expect(unseenMessagesBefore.data.count).to.equal(3);

    await axios.post(
      `http://127.0.0.1:${process.env.PORT}/v1/widgets/messages/read`,
      {},
      {
        headers: {
          Authorization: `Bearer ${subscriberToken}`,
        },
      }
    );

    const unseenMessagesAfter = await getNotificationCount('read=false');

    expect(unseenMessagesAfter.data.count).to.equal(0);
  });

  async function getFeedCount(query = {}) {
    const response = await axios.get(`http://127.0.0.1:${process.env.PORT}/v1/widgets/notifications/unseen`, {
      params: {
        ...query,
      },
      headers: {
        Authorization: `Bearer ${subscriberToken}`,
      },
    });

    return response.data;
  }

  async function getNotificationCount(query: string) {
    const response = await axios.get(`http://127.0.0.1:${process.env.PORT}/v1/widgets/notifications/count?${query}`, {
      headers: {
        Authorization: `Bearer ${subscriberToken}`,
      },
    });

    return response.data;
  }
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getFeedCount(query = {})
 - getNotificationCount(query: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - null(null;
  let novuClient: Novu;
  beforeEach(async ())
 - subscriberProfile(profile;
  });

  it('should mark all as seen', async ())
 - unseenMessagesAfter(await getFeedCount({ seen: false });
    expect(unseenMessagesAfter.data.count).to.equal(0);
  });

...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/e2e/mark-as-by-mark.e2e.ts
Tamaño: 6641 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import {
  MessageEntity,
  MessageRepository,
  NotificationTemplateEntity,
  SubscriberEntity,
  SubscriberRepository,
} from '@novu/dal';
import { ChannelTypeEnum, MessagesStatusEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import axios from 'axios';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Mark as Seen - /widgets/messages/mark-as (POST) #novu-v0', async () => {
  const messageRepository = new MessageRepository();
  const subscriberRepository = new SubscriberRepository();
  let session: UserSession;
  let template: NotificationTemplateEntity;
  let subscriberId;
  let subscriberToken: string;
  let subscriber: SubscriberEntity;
  let message: MessageEntity;
  let novuClient: Novu;
  before(async () => {
    session = new UserSession();
    await session.initialize();
    subscriberId = SubscriberRepository.createObjectId();
    template = await session.createTemplate();
    novuClient = initNovuClassSdk(session);

    const { body } = await session.testAgent
      .post('/v1/widgets/session/initialize')
      .send({
        applicationIdentifier: session.environment.identifier,
        subscriberId,
        firstName: 'Test',
        lastName: 'User',
        email: 'test@example.com',
      })
      .expect(201);
    subscriberToken = body.data.token;
    subscriber = await getSubscriber(session, subscriberRepository, subscriberId);
  });

  beforeEach(async () => {
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await session.waitForJobCompletion(template._id);

    message = await getMessage(session, messageRepository, subscriber);

    expect(message.seen).to.equal(false);
    expect(message.read).to.equal(false);
    expect(message.lastSeenDate).to.be.not.ok;
    expect(message.lastReadDate).to.be.not.ok;
  });

  afterEach(async () => {
    await pruneMessages(messageRepository);
  });

  it('should change the seen status', async () => {
    await markAs(subscriberToken, message._id, MessagesStatusEnum.SEEN);

    const updatedMessage = await getMessage(session, messageRepository, subscriber);

    expect(updatedMessage.seen).to.equal(true);
    expect(updatedMessage.read).to.equal(false);
    expect(updatedMessage.lastSeenDate).to.be.ok;
    expect(updatedMessage.lastReadDate).to.be.not.ok;
  });

  it('should change the read status', async () => {
    await markAs(subscriberToken, message._id, MessagesStatusEnum.READ);

    const updatedMessage = await getMessage(session, messageRepository, subscriber);

    expect(updatedMessage.seen).to.equal(true);
    expect(updatedMessage.read).to.equal(true);
    expect(updatedMessage.lastSeenDate).to.be.ok;
    expect(updatedMessage.lastReadDate).to.be.ok;
  });

  it('should change the seen status to unseen', async () => {
    // simulate user seen
    await markAs(subscriberToken, message._id, MessagesStatusEnum.SEEN);

    const seenMessage = await getMessage(session, messageRepository, subscriber);
    expect(seenMessage.seen).to.equal(true);
    expect(seenMessage.read).to.equal(false);
    expect(seenMessage.lastSeenDate).to.be.ok;
    expect(seenMessage.lastReadDate).to.be.not.ok;

    await markAs(subscriberToken, message._id, MessagesStatusEnum.UNSEEN);

    const updatedMessage = await getMessage(session, messageRepository, subscriber);
    expect(updatedMessage.seen).to.equal(false);
    expect(updatedMessage.read).to.equal(false);
    expect(updatedMessage.lastSeenDate).to.be.ok;
    expect(updatedMessage.lastReadDate).to.be.not.ok;
  });

  it('should change the read status to unread', async () => {
    // simulate user read
    await markAs(subscriberToken, message._id, MessagesStatusEnum.READ);

    const readMessage = await getMessage(session, messageRepository, subscriber);
    expect(readMessage.seen).to.equal(true);
    expect(readMessage.read).to.equal(true);
    expect(readMessage.lastSeenDate).to.be.ok;
    expect(readMessage.lastReadDate).to.be.ok;

    await markAs(subscriberToken, message._id, MessagesStatusEnum.UNREAD);
    const updateMessage = await getMessage(session, messageRepository, subscriber);
    expect(updateMessage.seen).to.equal(true);
    expect(updateMessage.read).to.equal(false);
    expect(updateMessage.lastSeenDate).to.be.ok;
    expect(updateMessage.lastReadDate).to.be.ok;
  });

  it('should throw exception if messages were not provided', async () => {
    const failureMessage = 'should not reach here, should throw error';

    try {
      await markAs(subscriberToken, undefined, MessagesStatusEnum.SEEN);

      expect.fail(failureMessage);
    } catch (e) {
      if (e.message === failureMessage) {
        expect(e.message).to.be.empty;
      }

      expect(e.response.data.message).to.equal('messageId is required');
      expect(e.response.data.statusCode).to.equal(400);
    }

    try {
      await markAs(subscriberToken, [], MessagesStatusEnum.SEEN);

      expect.fail(failureMessage);
    } catch (e) {
      if (e.message === failureMessage) {
        expect(e.message).to.be.empty;
      }

      expect(e.response.data.message).to.equal('messageId is required');
      expect(e.response.data.statusCode).to.equal(400);
    }
  });
});

async function getMessage(
  session: UserSession,
  messageRepository: MessageRepository,
  subscriber: SubscriberEntity
): Promise<MessageEntity> {
  const message = await messageRepository.findOne({
    _environmentId: session.environment._id,
    _subscriberId: subscriber._id,
    channel: ChannelTypeEnum.IN_APP,
  });

  if (!message) {
    expect(message).to.be.ok;
    throw new Error('message not found');
  }

  return message;
}

async function markAs(subscriberToken: string, messageIds: string | string[] | undefined, mark: MessagesStatusEnum) {
  return await axios.post(
    `http://127.0.0.1:${process.env.PORT}/v1/widgets/messages/mark-as`,
    { messageId: messageIds, markAs: mark },
    {
      headers: {
        Authorization: `Bearer ${subscriberToken}`,
      },
    }
  );
}

async function getSubscriber(
  session: UserSession,
  subscriberRepository: SubscriberRepository,
  subscriberId: string
): Promise<SubscriberEntity> {
  const subscriberRes = await subscriberRepository.findOne({
    _environmentId: session.environment._id,
    subscriberId,
  });

  if (!subscriberRes) {
    expect(subscriberRes).to.be.ok;
    throw new Error('subscriber not found');
  }

  return subscriberRes;
}

async function pruneMessages(messageRepository) {
  await messageRepository.delete({});
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getMessage(session: UserSession,
  messageRepository: MessageRepository,
  subscriber: SubscriberEntity)
 - markAs(subscriberToken: string, messageIds: string | string[] | undefined, mark: MessagesStatusEnum)
 - getSubscriber(session: UserSession,
  subscriberRepository: SubscriberRepository,
  subscriberId: string)
 - pruneMessages(messageRepository)
Asignaciones con arrow functions encontradas (posibles funciones):
 - subscriberRepository(new SubscriberRepository();
  let session: UserSession;
  let template: NotificationTemplateEntity;
...)
 - subscriber(await getSubscriber(session, subscriberRepository, subscriberId);
  });

  beforeEach(async ())
 - message(await getMessage(session, messageRepository, subscriber);

    expect(message.seen).to.equal(false);...)
 - updatedMessage(await getMessage(session, messageRepository, subscriber);

    expect(updatedMessage.seen).to.equal(...)
 - updatedMessage(await getMessage(session, messageRepository, subscriber);

    expect(updatedMessage.seen).to.equal(...)
 - updatedMessage(await getMessage(session, messageRepository, subscriber);
    expect(updatedMessage.seen).to.equal(f...)
 - updateMessage(await getMessage(session, messageRepository, subscriber);
    expect(updateMessage.seen).to.equal(tr...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/e2e/mark-as.e2e.ts
Tamaño: 2174 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { MessageEntity, MessageRepository, NotificationTemplateEntity, SubscriberRepository } from '@novu/dal';
import { ChannelTypeEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import axios from 'axios';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Mark as Seen - /widgets/messages/markAs (POST) #novu-v0', async () => {
  const messageRepository = new MessageRepository();
  let session: UserSession;
  let template: NotificationTemplateEntity;
  let subscriberId;
  let novuClient: Novu;
  before(async () => {
    session = new UserSession();
    await session.initialize();
    subscriberId = SubscriberRepository.createObjectId();
    template = await session.createTemplate();
    novuClient = initNovuClassSdk(session);
  });

  it('should change the seen status', async () => {
    const { body } = await session.testAgent
      .post('/v1/widgets/session/initialize')
      .send({
        applicationIdentifier: session.environment.identifier,
        subscriberId,
        firstName: 'Test',
        lastName: 'User',
        email: 'test@example.com',
      })
      .expect(201);

    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await session.waitForJobCompletion(template._id);
    const { token } = body.data;
    const messages = await messageRepository.findBySubscriberChannel(
      session.environment._id,
      body.data.profile._id,
      ChannelTypeEnum.IN_APP
    );
    const messageId = messages[0]._id;

    expect(messages[0].seen).to.equal(false);
    await axios.post(
      `http://127.0.0.1:${process.env.PORT}/v1/widgets/messages/markAs`,
      { messageId, mark: { seen: true } },
      {
        headers: {
          Authorization: `Bearer ${token}`,
        },
      }
    );

    const modifiedMessage = (await messageRepository.findOne({
      _id: messageId,
      _environmentId: session.environment._id,
    })) as MessageEntity;

    expect(modifiedMessage.seen).to.equal(true);
    expect(modifiedMessage.lastSeenDate).to.be.ok;
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - messageRepository(new MessageRepository();
  let session: UserSession;
  let template: NotificationTemplateEntity;
  l...)
 - novuClient(initNovuClassSdk(session);
  });

  it('should change the seen status', async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/e2e/remove-all-messages.e2e.ts
Tamaño: 3992 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { MessageRepository, NotificationTemplateEntity, SubscriberRepository } from '@novu/dal';
import { ChannelTypeEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import axios from 'axios';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Remove all messages - /widgets/messages (DELETE) #novu-v0', () => {
  const messageRepository = new MessageRepository();
  let session: UserSession;
  let template: NotificationTemplateEntity;
  let subscriberId: string;
  let subscriberToken: string;
  let subscriberProfile: {
    _id: string;
  } | null = null;
  let novuClient: Novu;
  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    subscriberId = SubscriberRepository.createObjectId();
    novuClient = initNovuClassSdk(session);

    template = await session.createTemplate({
      noFeedId: true,
    });

    const { body } = await session.testAgent
      .post('/v1/widgets/session/initialize')
      .send({
        applicationIdentifier: session.environment.identifier,
        subscriberId,
        firstName: 'Test',
        lastName: 'User',
        email: 'test@example.com',
      })
      .expect(201);

    const { token, profile } = body.data;

    subscriberToken = token;
    subscriberProfile = profile;
  });

  it('should remove all messages', async () => {
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    const messagesBefore = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriberProfile?._id,
      channel: ChannelTypeEnum.IN_APP,
    });

    expect(messagesBefore.length).to.equal(3);
    await axios.delete(`http://127.0.0.1:${process.env.PORT}/v1/widgets/messages`, {
      headers: {
        Authorization: `Bearer ${subscriberToken}`,
      },
    });

    const messagesAfter = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriberProfile?._id,
      channel: ChannelTypeEnum.IN_APP,
    });

    expect(messagesAfter.length).to.equal(0);
  });

  it('should remove all messages of a specific feed', async () => {
    const templateWithFeed = await session.createTemplate({ noFeedId: false });

    const _feedId = templateWithFeed?.steps[0]?.template?._feedId;

    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: templateWithFeed.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: templateWithFeed.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(templateWithFeed._id);
    await session.waitForJobCompletion(template._id);

    const messagesBefore = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriberProfile?._id,
      channel: ChannelTypeEnum.IN_APP,
    });

    expect(messagesBefore.length).to.equal(5);

    await axios.delete(`http://127.0.0.1:${process.env.PORT}/v1/widgets/messages?feedId=${_feedId}`, {
      headers: {
        Authorization: `Bearer ${subscriberToken}`,
      },
    });

    const messagesAfter = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriberProfile?._id,
      channel: ChannelTypeEnum.IN_APP,
    });

    expect(messagesAfter.length).to.equal(3);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - null(null;
  let novuClient: Novu;
  beforeEach(async ())
 - subscriberProfile(profile;
  });

  it('should remove all messages', async ())
 - messagesAfter(await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: s...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/e2e/remove-messages-bulk.e2e.ts
Tamaño: 4621 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { MessageRepository, NotificationTemplateEntity, SubscriberRepository } from '@novu/dal';
import { ChannelTypeEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import axios from 'axios';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Remove messages by bulk - /widgets/messages/bulk/delete (POST) #novu-v0', () => {
  const messageRepository = new MessageRepository();
  let session: UserSession;
  let template: NotificationTemplateEntity;
  let subscriberId: string;
  let subscriberToken: string;
  let subscriberProfile: {
    _id: string;
  } | null = null;
  let novuClient: Novu;
  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    subscriberId = SubscriberRepository.createObjectId();
    novuClient = initNovuClassSdk(session);

    template = await session.createTemplate({
      noFeedId: true,
    });

    const { body } = await session.testAgent
      .post('/v1/widgets/session/initialize')
      .send({
        applicationIdentifier: session.environment.identifier,
        subscriberId,
        firstName: 'Test',
        lastName: 'User',
        email: 'test@example.com',
      })
      .expect(201);

    const { token, profile } = body.data;

    subscriberToken = token;
    subscriberProfile = profile;
  });

  it('should remove messages by bulk', async () => {
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    const messagesBefore = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriberProfile?._id,
      channel: ChannelTypeEnum.IN_APP,
    });

    expect(messagesBefore.length).to.equal(3);

    const [firstMessage, ...messagesToDelete] = messagesBefore;

    await axios.post(
      `http://127.0.0.1:${process.env.PORT}/v1/widgets/messages/bulk/delete`,
      { messageIds: messagesToDelete.map((msg) => msg._id) },
      {
        headers: {
          Authorization: `Bearer ${subscriberToken}`,
        },
      }
    );

    const messagesAfter = await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: subscriberProfile?._id,
      channel: ChannelTypeEnum.IN_APP,
    });

    expect(messagesAfter.length).to.equal(1);
    expect(messagesAfter[0]._id).to.equal(firstMessage._id);
  });

  it('should throw an exception when message ids were not provided', async () => {
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });
    await novuClient.trigger({ workflowId: template.triggers[0].identifier, to: subscriberId });

    await session.waitForJobCompletion(template._id);

    try {
      const res = await axios.post(
        `http://127.0.0.1:${process.env.PORT}/v1/widgets/messages/bulk/delete`,
        {},
        {
          headers: {
            Authorization: `Bearer ${subscriberToken}`,
          },
        }
      );

      expect(true).to.equal(false);
    } catch (e) {
      expect(e.response.data.message).to.contain('messageIds should not be empty');
    }
  });

  it('should throw an exception message amount exceeds the api limit', async () => {
    const randomMongoId = session.organization._id;

    let messageIds = duplicateStr(randomMongoId, 100);

    const res = await axios.post(
      `http://127.0.0.1:${process.env.PORT}/v1/widgets/messages/bulk/delete`,
      { messageIds },
      {
        headers: {
          Authorization: `Bearer ${subscriberToken}`,
        },
      }
    );

    expect(res.status).to.equal(200);

    try {
      messageIds = duplicateStr(randomMongoId, 101);

      await axios.post(
        `http://127.0.0.1:${process.env.PORT}/v1/widgets/messages/bulk/delete`,
        { messageIds },
        {
          headers: {
            Authorization: `Bearer ${subscriberToken}`,
          },
        }
      );

      expect(true).to.equal(false);
    } catch (e) {
      expect(e.response.data.message).to.contain('messageIds must contain no more than 100 elements');
    }
  });
});

function duplicateStr(str: string, count: number): string[] {
  return [...Array(count)].map((_, i) => str);
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - duplicateStr(str: string, count: number)
Asignaciones con arrow functions encontradas (posibles funciones):
 - null(null;
  let novuClient: Novu;
  beforeEach(async ())
 - subscriberProfile(profile;
  });

  it('should remove messages by bulk', async ())
 - messagesAfter(await messageRepository.find({
      _environmentId: session.environment._id,
      _subscriberId: s...)
 - res(await axios.post(
        `http://127.0.0.1:${process.env.PORT}/v1/widgets/messages/bulk/delete`,
  ...)
 - messageIds(duplicateStr(randomMongoId, 101);

      await axios.post(
        `http://127.0.0.1:${process.env.P...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/e2e/update-subscriber-preference.e2e.ts
Tamaño: 4164 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { NotificationTemplateEntity, SubscriberRepository } from '@novu/dal';
import { ChannelTypeEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import axios from 'axios';
import { expect } from 'chai';
import { UpdateSubscriberPreferenceRequestDto } from '../dtos/update-subscriber-preference-request.dto';
import { getSubscriberPreference } from './get-subscriber-preference.e2e';

describe('PATCH /widgets/preferences/:templateId #novu-v0', () => {
  let template: NotificationTemplateEntity;
  let session: UserSession;
  let subscriberId: string;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    subscriberId = SubscriberRepository.createObjectId();

    template = await session.createTemplate({
      noFeedId: true,
    });
  });

  // `enabled` flag is not used anymore. The presence of a preference object means that the subscriber has enabled notifications.
  it.skip('should create user preference', async () => {
    const updateData = {
      enabled: false,
    };

    await updateSubscriberPreference(updateData, session.subscriberToken, template._id);

    const response = await getSubscriberPreference(session.subscriberToken);

    const data = response.data.data[0];

    expect(data.preference.enabled).to.equal(false);
    expect(data.preference.channels.email).to.equal(true);
    expect(data.preference.channels.in_app).to.equal(true);
  });

  it('should update user preference', async () => {
    const createData = {
      enabled: true,
    };

    await updateSubscriberPreference(createData, session.subscriberToken, template._id);

    const updateDataEmailFalse = {
      channel: {
        type: ChannelTypeEnum.EMAIL,
        enabled: false,
      },
    };

    const response = (await updateSubscriberPreference(updateDataEmailFalse, session.subscriberToken, template._id))
      .data.data;

    expect(response.preference.enabled).to.equal(true);
    expect(response.preference.channels.email).to.equal(false);
    expect(response.preference.channels.in_app).to.equal(true);
    expect(response.preference.channels.sms).to.be.not.ok;
    expect(response.preference.channels.chat).to.be.not.ok;
  });

  it(
    'should not update empty object should throw exception if ' +
      'no channel and not template enable param - user preference',
    async () => {
      const createData = {
        templateId: template._id,
        enabled: true,
      };

      await updateSubscriberPreference(createData, session.subscriberToken, template._id);

      const updateDataEmailFalse = {
        channel: {},
      } as UpdateSubscriberPreferenceRequestDto;

      let responseMessage = '';
      try {
        await updateSubscriberPreference(updateDataEmailFalse, session.subscriberToken, template._id);
      } catch (e) {
        responseMessage = 'In order to make an update you need to provider channel or enabled';
      }

      expect(responseMessage).to.equal('In order to make an update you need to provider channel or enabled');
    }
  );

  it('should override template preference defaults after subscriber update', async () => {
    const templateDefaultSettings = await session.createTemplate({
      preferenceSettingsOverride: { email: false, chat: true, push: true, sms: true, in_app: true },
      noFeedId: true,
    });

    const updateEmailEnable = {
      channel: {
        type: ChannelTypeEnum.EMAIL,
        enabled: true,
      },
    };

    const response = (
      await updateSubscriberPreference(updateEmailEnable, session.subscriberToken, templateDefaultSettings._id)
    ).data.data;

    expect(response.preference.enabled).to.equal(true);
    expect(response.preference.channels.email).to.equal(true);
    expect(response.preference.channels.in_app).to.equal(true);
  });
});

export async function updateSubscriberPreference(
  data: UpdateSubscriberPreferenceRequestDto,
  subscriberToken: string,
  templateId: string
) {
  return await axios.patch(`http://127.0.0.1:${process.env.PORT}/v1/widgets/preferences/${templateId}`, data, {
    headers: {
      Authorization: `Bearer ${subscriberToken}`,
    },
  });
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - updateSubscriberPreference(data: UpdateSubscriberPreferenceRequestDto,
  subscriberToken: string,
  templateId: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - template(await session.createTemplate({
      noFeedId: true,
    });
  });

  // `enabled` flag is not used ...)
 - data(response.data.data[0];

    expect(data.preference.enabled).to.equal(false);
    expect(data.prefere...)
 - response(await updateSubscriberPreference(updateDataEmailFalse, session.subscriberToken, template._id))
     ...)
 - responseMessage('In order to make an update you need to provider channel or enabled';
      }

      expect(response...)
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/pipes/limit-pipe/limit-pipe.spec.ts
Tamaño: 2734 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Paramtype } from '@nestjs/common/interfaces/features/paramtype.interface';
import { expect } from 'chai';
import { LimitPipe } from './limit-pipe';

enum MetadataEnum {
  DATA = 'limit',
  TYPE = 'query',
}

describe('LimitPipe', () => {
  let pipe: LimitPipe;
  const metadata = { data: MetadataEnum.DATA, type: MetadataEnum.TYPE as Paramtype, metatype: String };

  beforeEach(() => {
    pipe = new LimitPipe(1, 1000);
  });

  it('should return the input value if it is within the limits', () => {
    let limit = 1;
    let res = pipe.transform(limit, metadata);
    expect(res).to.equal(limit);

    limit = 500;
    res = pipe.transform(limit, metadata);
    expect(res).to.equal(limit);

    limit = 999;
    res = pipe.transform(limit, metadata);
    expect(res).to.equal(limit);

    limit = 1000;
    res = pipe.transform(limit, metadata);
    expect(res).to.equal(limit);
  });

  it('should throw exception when the limit is lower then the min threshold', () => {
    let limit = -1;
    expect(() => pipe.transform(limit, metadata)).to.throw(`${MetadataEnum.DATA} must not be less than 1`);

    limit = 0;
    expect(() => pipe.transform(limit, metadata)).to.throw(`${MetadataEnum.DATA} must not be less than 1`);
  });

  it('should throw exception when the limit is higher then the limit ', () => {
    const limit = 1001;
    expect(() => pipe.transform(limit, metadata)).to.throw(`${MetadataEnum.DATA} must not be greater than 1000`);
  });

  it('should return undefined input value if optional', () => {
    pipe = new LimitPipe(1, 1000, true);
    let limit: undefined | null;
    let res = pipe.transform(limit, metadata);
    expect(res).to.equal(limit);

    limit = null;
    res = pipe.transform(limit, metadata);
    expect(res).to.equal(limit);
  });

  it('should throw exception if the input value is not optional', () => {
    pipe = new LimitPipe(1, 1000, false);
    let limit: undefined | null;
    expect(() => pipe.transform(limit, metadata)).to.throw(
      `${MetadataEnum.DATA} must be a number conforming to the specified constraints`
    );

    expect(() => pipe.transform(limit, metadata)).to.throw(
      `${MetadataEnum.DATA} must be a number conforming to the specified constraints`
    );

    limit = null;
    expect(() => pipe.transform(limit, metadata)).to.throw(
      `${MetadataEnum.DATA} must be a number conforming to the specified constraints`
    );
  });

  it('should set isOptional as false by default on LimitPipe initialize', () => {
    pipe = new LimitPipe(1, 1000);
    const limit = undefined;
    expect(() => pipe.transform(limit, metadata)).to.throw(
      `${MetadataEnum.DATA} must be a number conforming to the specified constraints`
    );
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - TYPE('query',
}

describe('LimitPipe', ())
 - metadata({ data: MetadataEnum.DATA, type: MetadataEnum.TYPE as Paramtype, metatype: String };

  beforeEach((...)
 - pipe(new LimitPipe(1, 1000);
  });

  it('should return the input value if it is within the limits', ())
 - res(pipe.transform(limit, metadata);
    expect(res).to.equal(limit);
  });

  it('should throw exceptio...)
 - limit(-1;
    expect(())
 - limit(0;
    expect(())
 - limit(1001;
    expect(())
 - res(pipe.transform(limit, metadata);
    expect(res).to.equal(limit);
  });

  it('should throw exceptio...)
 - pipe(new LimitPipe(1, 1000, false);
    let limit: undefined | null;
    expect(())
 - limit(null;
    expect(())
 - limit(undefined;
    expect(())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/pipes/limit-pipe/limit-pipe.ts
Tamaño: 1066 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ArgumentMetadata, BadRequestException, PipeTransform } from '@nestjs/common';

export class LimitPipe implements PipeTransform {
  private readonly minInt: number;
  private readonly maxInt: number;
  private readonly isOptional: boolean;

  constructor(minInt: number, maxInt: number, isOptional = false) {
    this.minInt = minInt;
    this.maxInt = maxInt;
    this.isOptional = isOptional;
  }

  transform(value: number | undefined | null, metadata: ArgumentMetadata) {
    if (this.isOptional && (value === null || value === undefined)) {
      return value;
    }

    if (!this.isOptional && (value === null || value === undefined)) {
      throw new BadRequestException(`${metadata.data} must be a number conforming to the specified constraints`);
    }

    if (value! < this.minInt) {
      throw new BadRequestException(`${metadata.data} must not be less than ${this.minInt}`);
    }

    if (value! > this.maxInt) {
      throw new BadRequestException(`${metadata.data} must not be greater than ${this.maxInt}`);
    }

    return value;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class LimitPipe

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/queries/get-count.query.ts
Tamaño: 105 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export class GetCountQuery {
  feedIdentifier?: string[] | string;
  seen?: boolean;
  read?: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetCountQuery

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/queries/store.query.ts
Tamaño: 64 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export class StoreQuery {
  seen?: boolean;
  read?: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class StoreQuery

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/usecases/index.ts
Tamaño: 1348 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { GetFeedCount } from './get-feed-count/get-feed-count.usecase';
import { GetNotificationsFeed } from './get-notifications-feed/get-notifications-feed.usecase';
import { GetOrganizationData } from './get-organization-data/get-organization-data.usecase';
import { InitializeSession } from './initialize-session/initialize-session.usecase';
import { UpdateMessageActions } from './mark-action-as-done/update-message-actions.usecase';
import { MarkAllMessagesAs } from './mark-all-messages-as/mark-all-messages-as.usecase';
import { MarkMessageAs } from './mark-message-as/mark-message-as.usecase';
import { MarkMessageAsByMark } from './mark-message-as-by-mark/mark-message-as-by-mark.usecase';
import { RemoveMessage } from './remove-message/remove-message.usecase';
import { RemoveAllMessages } from './remove-messages/remove-all-messages.usecase';
import { RemoveMessagesBulk } from './remove-messages-bulk/remove-messages-bulk.usecase';
import { MessageInteractionService, WorkflowRunService } from '@novu/application-generic';

export const USE_CASES = [
  GetOrganizationData,
  UpdateMessageActions,
  MarkMessageAs,
  GetFeedCount,
  GetNotificationsFeed,
  InitializeSession,
  RemoveMessage,
  RemoveAllMessages,
  MarkAllMessagesAs,
  RemoveMessagesBulk,
  MarkMessageAsByMark,
  MessageInteractionService,
  WorkflowRunService,
];


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/usecases/get-feed-count/get-feed-count.command.ts
Tamaño: 573 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Transform } from 'class-transformer';
import { IsArray, IsOptional, Max, Min } from 'class-validator';
import { EnvironmentWithSubscriber } from '../../../shared/commands/project.command';

export class GetFeedCountCommand extends EnvironmentWithSubscriber {
  @IsOptional()
  @IsArray()
  feedId?: string[];

  @IsOptional()
  seen?: boolean;

  @IsOptional()
  read?: boolean;

  @IsOptional()
  @Transform(({ value }) => {
    if (Number.isNaN(value) || value == null) {
      return 100;
    }

    return value;
  })
  @Min(1)
  @Max(1000)
  limit: number;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetFeedCountCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/usecases/get-feed-count/get-feed-count.usecase.ts
Tamaño: 1529 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable } from '@nestjs/common';
import { buildMessageCountKey, CachedQuery, InstrumentUsecase } from '@novu/application-generic';
import { MessageRepository, SubscriberRepository } from '@novu/dal';
import { ChannelTypeEnum } from '@novu/shared';

import { GetFeedCountCommand } from './get-feed-count.command';

@Injectable()
export class GetFeedCount {
  constructor(
    private messageRepository: MessageRepository,
    private subscriberRepository: SubscriberRepository
  ) {}

  @InstrumentUsecase()
  @CachedQuery({
    builder: ({ environmentId, subscriberId, ...command }: GetFeedCountCommand) =>
      buildMessageCountKey().cache({
        environmentId,
        subscriberId,
        ...command,
      }),
  })
  async execute(command: GetFeedCountCommand): Promise<{ count: number }> {
    const subscriber = await this.subscriberRepository.findBySubscriberId(
      command.environmentId,
      command.subscriberId,
      true
    );

    if (!subscriber) {
      throw new BadRequestException(
        `Subscriber ${command.subscriberId} is not exist in environment ${command.environmentId}, ` +
          `please provide a valid subscriber identifier`
      );
    }

    const count = await this.messageRepository.getCount(
      command.environmentId,
      subscriber._id,
      ChannelTypeEnum.IN_APP,
      {
        feedId: command.feedId,
        seen: command.seen,
        read: command.read,
      },
      { limit: command.limit }
    );

    return { count };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetFeedCount

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/usecases/get-notifications-feed/get-notifications-feed.command.ts
Tamaño: 525 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsArray, IsNumber, IsOptional, IsString } from 'class-validator';

import { EnvironmentWithSubscriber } from '../../../shared/commands/project.command';
import { StoreQuery } from '../../queries/store.query';

export class GetNotificationsFeedCommand extends EnvironmentWithSubscriber {
  @IsNumber()
  @IsOptional()
  page = 0;

  @IsNumber()
  @IsOptional()
  limit = 10;

  @IsOptional()
  @IsArray()
  feedId?: string[];

  @IsOptional()
  query: StoreQuery;

  @IsOptional()
  @IsString()
  payload?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetNotificationsFeedCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/usecases/get-notifications-feed/get-notifications-feed.usecase.ts
Tamaño: 3890 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable } from '@nestjs/common';
import {
  AnalyticsService,
  buildFeedKey,
  buildSubscriberKey,
  CachedQuery,
  CachedResponse,
  InstrumentUsecase,
} from '@novu/application-generic';
import { MessageRepository, SubscriberEntity, SubscriberRepository } from '@novu/dal';
import { ActorTypeEnum, ChannelTypeEnum } from '@novu/shared';
import { FeedResponseDto } from '../../dtos/feeds-response.dto';
import { GetNotificationsFeedCommand } from './get-notifications-feed.command';

@Injectable()
export class GetNotificationsFeed {
  constructor(
    private messageRepository: MessageRepository,
    private analyticsService: AnalyticsService,
    private subscriberRepository: SubscriberRepository
  ) {}

  private getPayloadObject(payload?: string): object | undefined {
    if (!payload) {
      return;
    }

    try {
      return JSON.parse(Buffer.from(payload, 'base64').toString());
    } catch (e) {
      throw new BadRequestException('Invalid payload, the JSON object should be encoded to base64 string.');
    }
  }

  @InstrumentUsecase()
  @CachedQuery({
    builder: ({ environmentId, subscriberId, ...command }: GetNotificationsFeedCommand) =>
      buildFeedKey().cache({
        environmentId,
        subscriberId,
        ...command,
      }),
  })
  async execute(command: GetNotificationsFeedCommand): Promise<FeedResponseDto> {
    const payload = this.getPayloadObject(command.payload);

    const subscriber = await this.fetchSubscriber({
      _environmentId: command.environmentId,
      subscriberId: command.subscriberId,
    });

    if (!subscriber) {
      throw new BadRequestException(
        `Subscriber not found for this environment with the id: ${
          command.subscriberId
        }. Make sure to create a subscriber before fetching the feed.`
      );
    }

    const feed = await this.messageRepository.findBySubscriberChannel(
      command.environmentId,
      subscriber._id,
      ChannelTypeEnum.IN_APP,
      { feedId: command.feedId, seen: command.query.seen, read: command.query.read, payload },
      {
        limit: command.limit,
        skip: command.page * command.limit,
      }
    );

    if (feed.length) {
      this.analyticsService.mixpanelTrack('Fetch Feed - [Notification Center]', '', {
        _subscriber: feed[0]?._subscriberId,
        _organization: command.organizationId,
        feedSize: feed.length,
      });
    }

    for (const message of feed) {
      if (message._actorId && message.actor?.type === ActorTypeEnum.USER) {
        message.actor.data = message.actorSubscriber?.avatar || null;
      }
    }

    const skip = command.page * command.limit;
    let totalCount = 0;

    if (feed.length) {
      totalCount = await this.messageRepository.getCount(
        command.environmentId,
        subscriber._id,
        ChannelTypeEnum.IN_APP,
        {
          feedId: command.feedId,
          seen: command.query.seen,
          read: command.query.read,
          payload,
        },
        { limit: command.limit + 1, skip }
      );
    }

    const hasMore = feed.length < totalCount;
    totalCount = Math.min(totalCount, command.limit);

    const data = feed.map((el) => ({ ...el, content: el.content as string }));

    return {
      data,
      totalCount,
      hasMore,
      pageSize: command.limit,
      page: command.page,
    };
  }

  @CachedResponse({
    builder: (command: { subscriberId: string; _environmentId: string }) =>
      buildSubscriberKey({
        _environmentId: command._environmentId,
        subscriberId: command.subscriberId,
      }),
  })
  private async fetchSubscriber({
    subscriberId,
    _environmentId,
  }: {
    subscriberId: string;
    _environmentId: string;
  }): Promise<SubscriberEntity | null> {
    return await this.subscriberRepository.findBySubscriberId(_environmentId, subscriberId);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - data(feed.map((el))
Declaraciones 'export' encontradas:
- export class GetNotificationsFeed

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/usecases/get-organization-data/get-organization-data.command.ts
Tamaño: 164 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentWithSubscriber } from '../../../shared/commands/project.command';

export class GetOrganizationDataCommand extends EnvironmentWithSubscriber {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetOrganizationDataCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/usecases/get-organization-data/get-organization-data.usecase.ts
Tamaño: 868 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { CommunityOrganizationRepository } from '@novu/dal';
import { OrganizationResponseDto } from '../../dtos/organization-response.dto';
import { GetOrganizationDataCommand } from './get-organization-data.command';

@Injectable()
export class GetOrganizationData {
  constructor(private communityOrganizationRepository: CommunityOrganizationRepository) {}

  async execute(command: GetOrganizationDataCommand): Promise<OrganizationResponseDto> {
    const organization = await this.communityOrganizationRepository.findById(command.organizationId);
    if (!organization) {
      throw new NotFoundException(`Organization with id ${command.organizationId} not found`);
    }

    return {
      _id: organization._id,
      name: organization.name,
      branding: organization.branding,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetOrganizationData

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/usecases/initialize-session/initialize-session.command.ts
Tamaño: 506 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BaseCommand } from '@novu/application-generic';
import { IsDefined, IsEmail, IsOptional, IsString } from 'class-validator';

export class InitializeSessionCommand extends BaseCommand {
  @IsDefined()
  @IsString()
  subscriberId: string;

  @IsDefined()
  @IsString()
  applicationIdentifier: string;

  firstName?: string;

  lastName?: string;

  @IsEmail()
  @IsOptional()
  email?: string;

  @IsString()
  @IsOptional()
  phone?: string;

  @IsString()
  @IsOptional()
  hmacHash?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class InitializeSessionCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/usecases/initialize-session/initialize-session.usecase.ts
Tamaño: 3300 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import {
  AnalyticsService,
  CreateOrUpdateSubscriberCommand,
  CreateOrUpdateSubscriberUseCase,
  createHash,
  decryptApiKey,
  InstrumentUsecase,
  LogDecorator,
  SelectIntegration,
  SelectIntegrationCommand,
} from '@novu/application-generic';
import { EnvironmentRepository } from '@novu/dal';
import { ChannelTypeEnum, InAppProviderIdEnum } from '@novu/shared';
import { AuthService } from '../../../auth/services/auth.service';
import { isHmacValid } from '../../../shared/helpers/is-valid-hmac';

import { SessionInitializeResponseDto } from '../../dtos/session-initialize-response.dto';
import { InitializeSessionCommand } from './initialize-session.command';

@Injectable()
export class InitializeSession {
  constructor(
    private environmentRepository: EnvironmentRepository,
    private createOrUpdateSubscriberUsecase: CreateOrUpdateSubscriberUseCase,
    private authService: AuthService,
    private selectIntegration: SelectIntegration,
    private analyticsService: AnalyticsService
  ) {}

  @LogDecorator()
  @InstrumentUsecase()
  async execute(command: InitializeSessionCommand): Promise<SessionInitializeResponseDto> {
    const environment = await this.environmentRepository.findEnvironmentByIdentifier(command.applicationIdentifier);

    if (!environment) {
      throw new BadRequestException('Please provide a valid app identifier');
    }

    const inAppIntegration = await this.selectIntegration.execute(
      SelectIntegrationCommand.create({
        environmentId: environment._id,
        organizationId: environment._organizationId,
        channelType: ChannelTypeEnum.IN_APP,
        providerId: InAppProviderIdEnum.Novu,
        filterData: {},
      })
    );

    if (!inAppIntegration) {
      throw new NotFoundException('In app integration could not be found');
    }

    if (inAppIntegration.credentials.hmac) {
      validateNotificationCenterEncryption(environment, command);
    }

    const subscriber = await this.createOrUpdateSubscriberUsecase.execute(
      CreateOrUpdateSubscriberCommand.create({
        environmentId: environment._id,
        organizationId: environment._organizationId,
        subscriberId: command.subscriberId,
        firstName: command.firstName,
        lastName: command.lastName,
        email: command.email,
        phone: command.phone,
        allowUpdate: isHmacValid(environment.apiKeys[0].key, command.subscriberId, command.hmacHash),
      })
    );

    this.analyticsService.mixpanelTrack('Initialize Widget Session - [Notification Center]', '', {
      _organization: environment._organizationId,
      environmentName: environment.name,
      _subscriber: subscriber._id,
    });

    return {
      token: await this.authService.getSubscriberWidgetToken(subscriber),
      profile: {
        _id: subscriber._id,
        firstName: subscriber.firstName,
        lastName: subscriber.lastName,
        phone: subscriber.phone,
      },
    };
  }
}

function validateNotificationCenterEncryption(environment, command: InitializeSessionCommand) {
  if (!isHmacValid(environment.apiKeys[0].key, command.subscriberId, command.hmacHash)) {
    throw new BadRequestException('Please provide a valid HMAC hash');
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - validateNotificationCenterEncryption(environment, command: InitializeSessionCommand)
Declaraciones 'export' encontradas:
- export class InitializeSession

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/usecases/mark-action-as-done/update-message-actions.command.ts
Tamaño: 467 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ButtonTypeEnum, MessageActionStatusEnum } from '@novu/shared';
import { IsDefined, IsMongoId, IsOptional } from 'class-validator';
import { EnvironmentWithSubscriber } from '../../../shared/commands/project.command';

export class UpdateMessageActionsCommand extends EnvironmentWithSubscriber {
  @IsMongoId()
  messageId: string;

  @IsDefined()
  type: ButtonTypeEnum;

  @IsDefined()
  status: MessageActionStatusEnum;

  @IsOptional()
  payload?: any;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateMessageActionsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/usecases/mark-action-as-done/update-message-actions.usecase.ts
Tamaño: 2547 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Inject, Injectable, NotFoundException } from '@nestjs/common';
import { AnalyticsService } from '@novu/application-generic';
import { MessageEntity, MessageRepository, MessageTemplateEntity, SubscriberRepository } from '@novu/dal';

import { UpdateMessageActionsCommand } from './update-message-actions.command';

@Injectable()
export class UpdateMessageActions {
  constructor(
    private messageRepository: MessageRepository,
    private subscriberRepository: SubscriberRepository,
    private analyticsService: AnalyticsService
  ) {}

  async execute(command: UpdateMessageActionsCommand): Promise<MessageEntity> {
    const foundMessage = await this.messageRepository.findOne({
      _environmentId: command.environmentId,
      _id: command.messageId,
    });
    if (!foundMessage) {
      throw new NotFoundException(`Message ${command.messageId} not found`);
    }

    const updatePayload: Partial<MessageTemplateEntity> = {};

    if (command.type) {
      updatePayload['cta.action.result.type'] = command.type;
    }

    if (command.status) {
      updatePayload['cta.action.status'] = command.status;
    }

    if (command.payload) {
      updatePayload['cta.action.result.payload'] = command.payload;
    }

    const subscriber = await this.subscriberRepository.findBySubscriberId(command.environmentId, command.subscriberId);

    if (!subscriber) {
      throw new BadRequestException(
        `Subscriber with the id: ${command.subscriberId} was not found for this environment. ` +
          `Make sure to create a subscriber before trying to modify it.`
      );
    }

    const modificationResponse = await this.messageRepository.update(
      {
        _environmentId: command.environmentId,
        _subscriberId: subscriber._id,
        _id: command.messageId,
      },
      {
        $set: updatePayload,
      }
    );

    if (!modificationResponse.modified) {
      throw new BadRequestException(
        `Message with the id: ${command.messageId} was not found for this environment. ` +
          `Make sure to address correct message before trying to modify it.`
      );
    }

    this.analyticsService.track('Notification Action Clicked - [Notification Center]', command.organizationId, {
      _subscriber: subscriber._id,
      _organization: command.organizationId,
      _environment: command.environmentId,
    });

    return (await this.messageRepository.findOne({
      _environmentId: command.environmentId,
      _id: command.messageId,
    })) as MessageEntity;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateMessageActions

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/usecases/mark-all-message-as-seen/mark-all-message-as-seen.usecase.ts
Tamaño: 0 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###



### ANALISIS AUTOMATICO (ESPAÑOL) ###

No se detectaron funciones/exportaciones con heurística JS/TS.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/usecases/mark-all-messages-as/mark-all-messages-as.command.ts
Tamaño: 364 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { MessagesStatusEnum } from '@novu/shared';
import { IsDefined, IsOptional } from 'class-validator';

import { EnvironmentWithSubscriber } from '../../../shared/commands/project.command';

export class MarkAllMessagesAsCommand extends EnvironmentWithSubscriber {
  @IsOptional()
  feedIdentifiers?: string[];

  @IsDefined()
  markAs: MessagesStatusEnum;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class MarkAllMessagesAsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/usecases/mark-all-messages-as/mark-all-messages-as.usecase.ts
Tamaño: 4072 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Inject, Injectable, NotFoundException, Optional } from '@nestjs/common';
import {
  AnalyticsService,
  buildFeedKey,
  buildMessageCountKey,
  InvalidateCacheService,
  messageWebhookMapper,
  SendWebhookMessage,
  WebSocketsQueueService,
} from '@novu/application-generic';
import { EnvironmentRepository, MessageRepository, SubscriberRepository } from '@novu/dal';
import { ChannelTypeEnum, MessagesStatusEnum, WebhookEventEnum, WebhookObjectTypeEnum } from '@novu/shared';
import { mapMarkMessageToWebSocketEvent } from '../../../shared/helpers';
import { MarkAllMessagesAsCommand } from './mark-all-messages-as.command';

@Injectable()
export class MarkAllMessagesAs {
  constructor(
    @Inject(InvalidateCacheService)
    private invalidateCache: InvalidateCacheService,
    private messageRepository: MessageRepository,
    private webSocketsQueueService: WebSocketsQueueService,
    private subscriberRepository: SubscriberRepository,
    private analyticsService: AnalyticsService,
    private sendWebhookMessage: SendWebhookMessage,
    private environmentRepository: EnvironmentRepository
  ) {}

  async execute(command: MarkAllMessagesAsCommand): Promise<number> {
    const subscriber = await this.subscriberRepository.findBySubscriberId(command.environmentId, command.subscriberId);
    if (!subscriber) {
      throw new NotFoundException(
        `Subscriber ${command.subscriberId} does not exist in environment ${command.environmentId}, ` +
          `please provide a valid subscriber identifier`
      );
    }
    const environment = await this.environmentRepository.findOne(
      {
        _id: command.environmentId,
      },
      'webhookAppId identifier'
    );
    if (!environment) {
      throw new Error(`Environment not found for id ${command.environmentId}`);
    }

    await this.invalidateCache.invalidateQuery({
      key: buildFeedKey().invalidate({
        subscriberId: command.subscriberId,
        _environmentId: command.environmentId,
      }),
    });

    await this.invalidateCache.invalidateQuery({
      key: buildMessageCountKey().invalidate({
        subscriberId: command.subscriberId,
        _environmentId: command.environmentId,
      }),
    });

    const updatedMessages = await this.messageRepository.markAllMessagesAs({
      subscriberId: subscriber._id,
      environmentId: command.environmentId,
      markAs: command.markAs,
      feedIdentifiers: command.feedIdentifiers,
      channel: ChannelTypeEnum.IN_APP,
    });

    if (command.markAs !== MessagesStatusEnum.UNSEEN) {
      let eventType = WebhookEventEnum.MESSAGE_SEEN;
      if (command.markAs === MessagesStatusEnum.READ) {
        eventType = WebhookEventEnum.MESSAGE_READ;
      } else if (command.markAs === MessagesStatusEnum.UNREAD) {
        eventType = WebhookEventEnum.MESSAGE_UNREAD;
      }

      const webhookPromises = updatedMessages.map((message) =>
        this.sendWebhookMessage.execute({
          eventType: eventType,
          objectType: WebhookObjectTypeEnum.MESSAGE,
          payload: {
            object: messageWebhookMapper(message, command.subscriberId),
          },
          organizationId: command.organizationId,
          environmentId: command.environmentId,
          environment,
        })
      );

      await Promise.all(webhookPromises);
    }

    const eventMessage = mapMarkMessageToWebSocketEvent(command.markAs);

    if (eventMessage !== undefined) {
      this.webSocketsQueueService.add({
        name: 'sendMessage',
        data: {
          event: eventMessage,
          userId: subscriber._id,
          _environmentId: command.environmentId,
        },
        groupId: subscriber._organizationId,
      });
    }

    this.analyticsService.track(
      `Mark all messages as ${command.markAs}- [Notification Center]`,
      command.organizationId,
      {
        _organization: command.organizationId,
        _subscriberId: subscriber._id,
        feedIds: command.feedIdentifiers,
        markAs: command.markAs,
      }
    );

    return updatedMessages.length;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - webhookPromises(updatedMessages.map((message))
Declaraciones 'export' encontradas:
- export class MarkAllMessagesAs

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/usecases/mark-message-as-by-mark/mark-message-as-by-mark.command.ts
Tamaño: 487 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { MessagesStatusEnum } from '@novu/shared';
import { IsArray, IsDefined, IsEnum, IsNotEmpty, IsString } from 'class-validator';
import { EnvironmentWithSubscriber } from '../../../shared/commands/project.command';

export class MarkMessageAsByMarkCommand extends EnvironmentWithSubscriber {
  @IsArray()
  messageIds: string[];

  @IsDefined()
  @IsEnum(MessagesStatusEnum)
  markAs: MessagesStatusEnum;

  @IsNotEmpty()
  @IsString()
  __source: 'notification_center' | 'api';
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class MarkMessageAsByMarkCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/usecases/mark-message-as-by-mark/mark-message-as-by-mark.usecase.ts
Tamaño: 6799 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException, Optional } from '@nestjs/common';
import {
  AnalyticsService,
  buildFeedKey,
  buildMessageCountKey,
  buildSubscriberKey,
  CachedResponse,
  InvalidateCacheService,
  messageWebhookMapper,
  SendWebhookMessage,
  WebSocketsQueueService,
} from '@novu/application-generic';
import {
  EnvironmentRepository,
  MessageEntity,
  MessageRepository,
  SubscriberEntity,
  SubscriberRepository,
} from '@novu/dal';
import { MessagesStatusEnum, WebhookEventEnum, WebhookObjectTypeEnum } from '@novu/shared';
import { mapMarkMessageToWebSocketEvent } from '../../../shared/helpers';
import { MessageResponseDto } from '../../dtos/message-response.dto';
import { MarkMessageAsByMarkCommand } from './mark-message-as-by-mark.command';

@Injectable()
export class MarkMessageAsByMark {
  constructor(
    private invalidateCache: InvalidateCacheService,
    private messageRepository: MessageRepository,
    private webSocketsQueueService: WebSocketsQueueService,
    private analyticsService: AnalyticsService,
    private subscriberRepository: SubscriberRepository,
    private sendWebhookMessage: SendWebhookMessage,
    private environmentRepository: EnvironmentRepository
  ) {}

  async execute(command: MarkMessageAsByMarkCommand): Promise<MessageResponseDto[]> {
    const subscriber = await this.fetchSubscriber({
      _environmentId: command.environmentId,
      subscriberId: command.subscriberId,
    });

    if (!subscriber) throw new NotFoundException(`Subscriber ${command.subscriberId} not found`);

    const environment = await this.environmentRepository.findOne(
      {
        _id: command.environmentId,
      },
      'webhookAppId identifier'
    );
    if (!environment) {
      throw new Error(`Environment not found for id ${command.environmentId}`);
    }
    await this.invalidateCache.invalidateQuery({
      key: buildFeedKey().invalidate({
        subscriberId: command.subscriberId,
        _environmentId: command.environmentId,
      }),
    });

    await this.invalidateCache.invalidateQuery({
      key: buildMessageCountKey().invalidate({
        subscriberId: command.subscriberId,
        _environmentId: command.environmentId,
      }),
    });

    const updatedMessages = await this.messageRepository.changeMessagesStatus({
      environmentId: command.environmentId,
      subscriberId: subscriber._id,
      messageIds: command.messageIds,
      markAs: command.markAs,
    });

    await this.updateServices(command, subscriber, updatedMessages, command.markAs);

    if (command.markAs !== MessagesStatusEnum.UNSEEN) {
      let eventType = WebhookEventEnum.MESSAGE_SEEN;
      if (command.markAs === MessagesStatusEnum.READ) {
        eventType = WebhookEventEnum.MESSAGE_READ;
      } else if (command.markAs === MessagesStatusEnum.UNREAD) {
        eventType = WebhookEventEnum.MESSAGE_UNREAD;
      }

      const webhookPromises = updatedMessages.map((message) =>
        this.sendWebhookMessage.execute({
          eventType: eventType,
          objectType: WebhookObjectTypeEnum.MESSAGE,
          payload: {
            object: messageWebhookMapper(message, command.subscriberId),
          },
          organizationId: command.organizationId,
          environmentId: command.environmentId,
          environment,
        })
      );

      await Promise.all(webhookPromises);
    }

    return updatedMessages.map(mapMessageEntityToResponseDto);
  }

  private async updateServices(command: MarkMessageAsByMarkCommand, subscriber, messages, markAs: MessagesStatusEnum) {
    this.updateSocketCount(subscriber, markAs);
    const analyticMessage =
      command.__source === 'notification_center'
        ? `Mark as ${markAs} - [Notification Center]`
        : `Mark as ${markAs} - [API]`;

    for (const message of messages) {
      this.analyticsService.mixpanelTrack(analyticMessage, '', {
        _subscriber: message._subscriberId,
        _organization: command.organizationId,
        _template: message._templateId,
      });
    }
  }

  private updateSocketCount(subscriber: SubscriberEntity, markAs: MessagesStatusEnum) {
    const eventMessage = mapMarkMessageToWebSocketEvent(markAs);

    if (eventMessage === undefined) {
      return;
    }

    this.webSocketsQueueService.add({
      name: 'sendMessage',
      data: {
        event: eventMessage,
        userId: subscriber._id,
        _environmentId: subscriber._environmentId,
      },
      groupId: subscriber._organizationId,
    });
  }

  @CachedResponse({
    builder: (command: { subscriberId: string; _environmentId: string }) =>
      buildSubscriberKey({
        _environmentId: command._environmentId,
        subscriberId: command.subscriberId,
      }),
  })
  private async fetchSubscriber({
    subscriberId,
    _environmentId,
  }: {
    subscriberId: string;
    _environmentId: string;
  }): Promise<SubscriberEntity | null> {
    return await this.subscriberRepository.findBySubscriberId(_environmentId, subscriberId);
  }
}
export function mapMessageEntityToResponseDto(entity: MessageEntity): MessageResponseDto {
  const responseDto = new MessageResponseDto();

  responseDto._id = entity._id;
  responseDto._templateId = entity._templateId;
  responseDto._environmentId = entity._environmentId;
  responseDto._messageTemplateId = entity._messageTemplateId;
  responseDto._organizationId = entity._organizationId;
  responseDto._notificationId = entity._notificationId;
  responseDto._subscriberId = entity._subscriberId;
  responseDto.templateIdentifier = entity.templateIdentifier;
  responseDto.createdAt = entity.createdAt;
  responseDto.lastSeenDate = entity.lastSeenDate;
  responseDto.lastReadDate = entity.lastReadDate;
  responseDto.content = entity.content; // Assuming content can be directly assigned
  responseDto.transactionId = entity.transactionId;
  responseDto.subject = entity.subject;
  responseDto.channel = entity.channel;
  responseDto.read = entity.read;
  responseDto.seen = entity.seen;
  responseDto.snoozedUntil = entity.snoozedUntil;
  responseDto.deliveredAt = entity.deliveredAt; // snoozed notifications can have multiple delivery dates
  responseDto.email = entity.email;
  responseDto.phone = entity.phone;
  responseDto.directWebhookUrl = entity.directWebhookUrl;
  responseDto.providerId = entity.providerId;
  responseDto.deviceTokens = entity.deviceTokens;
  responseDto.title = entity.title;
  responseDto.cta = entity.cta; // Assuming cta can be directly assigned
  responseDto._feedId = entity._feedId ?? null; // Handle optional _feedId
  responseDto.status = entity.status;
  responseDto.errorId = entity.errorId;
  responseDto.errorText = entity.errorText;
  responseDto.payload = entity.payload;
  responseDto.overrides = entity.overrides;

  return responseDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - mapMessageEntityToResponseDto(entity: MessageEntity)
Asignaciones con arrow functions encontradas (posibles funciones):
 - webhookPromises(updatedMessages.map((message))
Declaraciones 'export' encontradas:
- export class MarkMessageAsByMark
- export function mapMessageEntityToResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/usecases/mark-message-as/mark-message-as.command.ts
Tamaño: 370 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsArray, IsDefined } from 'class-validator';
import { EnvironmentWithSubscriber } from '../../../shared/commands/project.command';

export class MarkMessageAsCommand extends EnvironmentWithSubscriber {
  @IsArray()
  messageIds: string[];

  @IsDefined()
  mark: { seen?: boolean; read?: boolean };
}

export enum MarkEnum {
  SEEN = 'seen',
  READ = 'read',
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class MarkMessageAsCommand
- export  enum

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/usecases/mark-message-as/mark-message-as.usecase.ts
Tamaño: 7008 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import {
  AnalyticsService,
  buildFeedKey,
  buildMessageCountKey,
  buildSubscriberKey,
  CachedResponse,
  EventType,
  InvalidateCacheService,
  LogRepository,
  MessageInteractionService,
  MessageInteractionTrace,
  mapEventTypeToTitle,
  messageWebhookMapper,
  PinoLogger,
  SendWebhookMessage,
  StepType,
  Trace,
  WebSocketsQueueService,
} from '@novu/application-generic';
import { MessageEntity, MessageRepository, SubscriberEntity, SubscriberRepository } from '@novu/dal';
import { DeliveryLifecycleStatusEnum, WebhookEventEnum, WebhookObjectTypeEnum, WebSocketEventEnum } from '@novu/shared';

import { MarkEnum, MarkMessageAsCommand } from './mark-message-as.command';

@Injectable()
export class MarkMessageAs {
  constructor(
    private invalidateCache: InvalidateCacheService,
    private messageRepository: MessageRepository,
    private webSocketsQueueService: WebSocketsQueueService,
    private analyticsService: AnalyticsService,
    private subscriberRepository: SubscriberRepository,
    private messageInteractionService: MessageInteractionService,
    private logger: PinoLogger,
    private sendWebhookMessage: SendWebhookMessage
  ) {
    this.logger.setContext(this.constructor.name);
  }

  async execute(command: MarkMessageAsCommand): Promise<MessageEntity[]> {
    await this.invalidateCache.invalidateQuery({
      key: buildFeedKey().invalidate({
        subscriberId: command.subscriberId,
        _environmentId: command.environmentId,
      }),
    });

    await this.invalidateCache.invalidateQuery({
      key: buildMessageCountKey().invalidate({
        subscriberId: command.subscriberId,
        _environmentId: command.environmentId,
      }),
    });

    const subscriber = await this.fetchSubscriber({
      _environmentId: command.environmentId,
      subscriberId: command.subscriberId,
    });

    if (!subscriber) throw new NotFoundException(`Subscriber ${command.subscriberId} not found`);

    await this.messageRepository.changeStatus(command.environmentId, subscriber._id, command.messageIds, command.mark);

    const updatedMessages = await this.messageRepository.find({
      _environmentId: command.environmentId,
      _id: {
        $in: command.messageIds,
      },
    });

    const allTraceData: MessageInteractionTrace[] = [];

    if (command.mark.seen != null) {
      await this.updateServices(command, subscriber, updatedMessages, MarkEnum.SEEN);

      allTraceData.push(
        ...this.prepareTrace(
          updatedMessages,
          command.mark.seen ? 'message_seen' : 'message_unseen',
          command.subscriberId
        )
      );

      if (command.mark.seen === true) {
        await this.sendWebhookForMessages(
          updatedMessages,
          WebhookEventEnum.MESSAGE_SEEN,
          command.organizationId,
          command.environmentId,
          command.subscriberId
        );
      }
    }

    if (command.mark.read !== undefined || command.mark.read !== null) {
      await this.updateServices(command, subscriber, updatedMessages, MarkEnum.READ);

      allTraceData.push(
        ...this.prepareTrace(
          updatedMessages,
          command.mark.read ? 'message_read' : 'message_unread',
          command.subscriberId
        )
      );

      await this.sendWebhookForMessages(
        updatedMessages,
        command.mark.read ? WebhookEventEnum.MESSAGE_READ : WebhookEventEnum.MESSAGE_UNREAD,
        command.organizationId,
        command.environmentId,
        command.subscriberId
      );
    }

    if (allTraceData.length > 0) {
      try {
        await this.messageInteractionService.trace(allTraceData, DeliveryLifecycleStatusEnum.INTERACTED);
      } catch (error) {
        this.logger.warn({ err: error }, `Failed to create engagement traces for ${allTraceData.length} traces`);
      }
    }

    return updatedMessages;
  }

  private prepareTrace(messages: MessageEntity[], eventType: EventType, userId: string): MessageInteractionTrace[] {
    const traceDataArray: MessageInteractionTrace[] = [];

    for (const message of messages) {
      if (message._jobId) {
        traceDataArray.push({
          created_at: LogRepository.formatDateTime64(new Date()),
          organization_id: message._organizationId,
          environment_id: message._environmentId,
          user_id: userId,
          subscriber_id: message._subscriberId,
          event_type: eventType,
          title: mapEventTypeToTitle(eventType),
          message: `Message ${eventType.replace('message_', '')} for subscriber ${message._subscriberId}`,
          raw_data: null,
          status: 'success',
          entity_type: 'step_run',
          entity_id: message._jobId,
          external_subscriber_id: message._subscriberId,
          step_run_type: message.channel as StepType,
          workflow_run_identifier: '',
          _notificationId: message._notificationId,
        });
      }
    }

    return traceDataArray;
  }

  private async updateServices(command: MarkMessageAsCommand, subscriber, messages, marked: MarkEnum) {
    this.updateSocketCount(subscriber, marked);

    for (const message of messages) {
      this.analyticsService.mixpanelTrack(`Mark as ${marked} - [Notification Center]`, '', {
        _subscriber: message._subscriberId,
        _organization: command.organizationId,
        _template: message._templateId,
      });
    }
  }

  private updateSocketCount(subscriber: SubscriberEntity, mark: MarkEnum) {
    const eventMessage = mark === MarkEnum.READ ? WebSocketEventEnum.UNREAD : WebSocketEventEnum.UNSEEN;

    this.webSocketsQueueService.add({
      name: 'sendMessage',
      data: {
        event: eventMessage,
        userId: subscriber._id,
        _environmentId: subscriber._environmentId,
      },
      groupId: subscriber._organizationId,
    });
  }

  private async sendWebhookForMessages(
    messages: MessageEntity[],
    eventType: WebhookEventEnum,
    organizationId: string,
    environmentId: string,
    subscriberId: string
  ): Promise<void> {
    const webhookPromises = messages.map((message) =>
      this.sendWebhookMessage.execute({
        eventType: eventType,
        objectType: WebhookObjectTypeEnum.MESSAGE,
        payload: {
          object: messageWebhookMapper(message, subscriberId),
        },
        organizationId: organizationId,
        environmentId: environmentId,
      })
    );

    await Promise.all(webhookPromises);
  }

  @CachedResponse({
    builder: (command: { subscriberId: string; _environmentId: string }) =>
      buildSubscriberKey({
        _environmentId: command._environmentId,
        subscriberId: command.subscriberId,
      }),
  })
  private async fetchSubscriber({
    subscriberId,
    _environmentId,
  }: {
    subscriberId: string;
    _environmentId: string;
  }): Promise<SubscriberEntity | null> {
    return await this.subscriberRepository.findBySubscriberId(_environmentId, subscriberId);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - webhookPromises(messages.map((message))
Declaraciones 'export' encontradas:
- export class MarkMessageAs

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/usecases/remove-message/remove-message.command.ts
Tamaño: 238 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsString } from 'class-validator';
import { EnvironmentWithSubscriber } from '../../../shared/commands/project.command';

export class RemoveMessageCommand extends EnvironmentWithSubscriber {
  @IsString()
  messageId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RemoveMessageCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/usecases/remove-message/remove-message.usecase.ts
Tamaño: 3056 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import {
  AnalyticsService,
  buildFeedKey,
  buildMessageCountKey,
  InvalidateCacheService,
  WebSocketsQueueService,
} from '@novu/application-generic';
import { DalException, MessageRepository, SubscriberEntity, SubscriberRepository } from '@novu/dal';
import { WebSocketEventEnum } from '@novu/shared';

import { MarkEnum } from '../mark-message-as/mark-message-as.command';
import { RemoveMessageCommand } from './remove-message.command';

@Injectable()
export class RemoveMessage {
  constructor(
    private invalidateCache: InvalidateCacheService,
    private messageRepository: MessageRepository,
    private webSocketsQueueService: WebSocketsQueueService,
    private analyticsService: AnalyticsService,
    private subscriberRepository: SubscriberRepository
  ) {}

  async execute(command: RemoveMessageCommand): Promise<void> {
    await this.invalidateCache.invalidateQuery({
      key: buildFeedKey().invalidate({
        subscriberId: command.subscriberId,
        _environmentId: command.environmentId,
      }),
    });

    await this.invalidateCache.invalidateQuery({
      key: buildMessageCountKey().invalidate({
        subscriberId: command.subscriberId,
        _environmentId: command.environmentId,
      }),
    });

    const subscriber = await this.subscriberRepository.findBySubscriberId(command.environmentId, command.subscriberId);
    if (!subscriber) throw new NotFoundException(`Subscriber ${command.subscriberId} not found`);

    try {
      const deletedMessage = await this.messageRepository.delete({
        _environmentId: command.environmentId,
        _organizationId: command.organizationId,
        _id: command.messageId,
        _subscriberId: subscriber._id,
      });

      if (deletedMessage.deletedCount) {
        await Promise.all([
          this.updateServices(command, subscriber, command.messageId, MarkEnum.READ),
          this.updateServices(command, subscriber, command.messageId, MarkEnum.SEEN),
        ]);
      }
    } catch (e) {
      if (e instanceof DalException) {
        throw new BadRequestException(e.message);
      }
      throw e;
    }
  }

  private async updateServices(command: RemoveMessageCommand, subscriber, message, marked: MarkEnum) {
    await this.updateSocketCount(subscriber, marked);

    this.analyticsService.track(`Removed Message - [Notification Center]`, command.organizationId, {
      _subscriber: message._subscriberId,
      _organization: command.organizationId,
      _template: message._templateId,
    });
  }

  private async updateSocketCount(subscriber: SubscriberEntity, mark: MarkEnum) {
    const eventMessage = mark === MarkEnum.READ ? WebSocketEventEnum.UNREAD : WebSocketEventEnum.UNSEEN;

    await this.webSocketsQueueService.add({
      name: 'sendMessage',
      data: {
        event: eventMessage,
        userId: subscriber._id,
        _environmentId: subscriber._environmentId,
      },
      groupId: subscriber._organizationId,
    });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RemoveMessage

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/usecases/remove-messages-bulk/remove-messages-bulk.command.ts
Tamaño: 353 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ArrayMaxSize, ArrayNotEmpty, IsArray, IsMongoId } from 'class-validator';
import { EnvironmentWithSubscriber } from '../../../shared/commands/project.command';

export class RemoveMessagesBulkCommand extends EnvironmentWithSubscriber {
  @IsArray()
  @ArrayNotEmpty()
  @IsMongoId({ each: true })
  @ArrayMaxSize(100)
  messageIds: string[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RemoveMessagesBulkCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/usecases/remove-messages-bulk/remove-messages-bulk.usecase.ts
Tamaño: 2734 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import {
  AnalyticsService,
  buildFeedKey,
  buildMessageCountKey,
  InvalidateCacheService,
  WebSocketsQueueService,
} from '@novu/application-generic';
import { DalException, MessageRepository, SubscriberRepository } from '@novu/dal';
import { ChannelTypeEnum, WebSocketEventEnum } from '@novu/shared';

import { MarkEnum } from '../mark-message-as/mark-message-as.command';
import { RemoveMessagesBulkCommand } from './remove-messages-bulk.command';

@Injectable()
export class RemoveMessagesBulk {
  constructor(
    private invalidateCache: InvalidateCacheService,
    private messageRepository: MessageRepository,
    private webSocketsQueueService: WebSocketsQueueService,
    private analyticsService: AnalyticsService,
    private subscriberRepository: SubscriberRepository
  ) {}

  async execute(command: RemoveMessagesBulkCommand): Promise<void> {
    const subscriber = await this.subscriberRepository.findBySubscriberId(command.environmentId, command.subscriberId);
    if (!subscriber) throw new NotFoundException(`Subscriber ${command.subscriberId} not found`);

    try {
      const deletedMessages = await this.messageRepository.delete({
        _environmentId: command.environmentId,
        _organizationId: command.organizationId,
        _subscriberId: subscriber._id,
        channel: ChannelTypeEnum.IN_APP,
        _id: { $in: command.messageIds },
      });

      if (deletedMessages.deletedCount > 0) {
        await Promise.all([
          this.updateServices(subscriber, MarkEnum.SEEN),
          this.updateServices(subscriber, MarkEnum.READ),
          this.invalidateCache.invalidateQuery({
            key: buildFeedKey().invalidate({
              subscriberId: command.subscriberId,
              _environmentId: command.environmentId,
            }),
          }),
          this.invalidateCache.invalidateQuery({
            key: buildMessageCountKey().invalidate({
              subscriberId: command.subscriberId,
              _environmentId: command.environmentId,
            }),
          }),
        ]);
      }
    } catch (e) {
      if (e instanceof DalException) {
        throw new BadRequestException(e.message);
      }
      throw e;
    }
  }

  private async updateServices(subscriber, marked: string): Promise<void> {
    const eventMessage = marked === MarkEnum.READ ? WebSocketEventEnum.UNREAD : WebSocketEventEnum.UNSEEN;

    await this.webSocketsQueueService.add({
      name: 'sendMessage',
      data: {
        event: eventMessage,
        userId: subscriber._id,
        _environmentId: subscriber._environmentId,
      },
      groupId: subscriber._organizationId,
    });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RemoveMessagesBulk

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/usecases/remove-messages/remove-all-messages.command.ts
Tamaño: 268 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsOptional, IsString } from 'class-validator';
import { EnvironmentWithSubscriber } from '../../../shared/commands/project.command';

export class RemoveAllMessagesCommand extends EnvironmentWithSubscriber {
  @IsString()
  @IsOptional()
  feedId?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RemoveAllMessagesCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/widgets/usecases/remove-messages/remove-all-messages.usecase.ts
Tamaño: 3746 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import {
  AnalyticsService,
  buildFeedKey,
  buildMessageCountKey,
  InvalidateCacheService,
  WebSocketsQueueService,
} from '@novu/application-generic';
import {
  DalException,
  EnforceEnvId,
  FeedRepository,
  MessageEntity,
  MessageRepository,
  SubscriberEntity,
  SubscriberRepository,
} from '@novu/dal';
import { ChannelTypeEnum, WebSocketEventEnum } from '@novu/shared';
import { MarkEnum } from '../mark-message-as/mark-message-as.command';
import { RemoveAllMessagesCommand } from './remove-all-messages.command';

@Injectable()
export class RemoveAllMessages {
  constructor(
    private invalidateCache: InvalidateCacheService,
    private messageRepository: MessageRepository,
    private webSocketsQueueService: WebSocketsQueueService,
    private analyticsService: AnalyticsService,
    private subscriberRepository: SubscriberRepository,
    private feedRepository: FeedRepository
  ) {}

  async execute(command: RemoveAllMessagesCommand): Promise<void> {
    const subscriber = await this.subscriberRepository.findBySubscriberId(command.environmentId, command.subscriberId);
    if (!subscriber) throw new NotFoundException(`Subscriber ${command.subscriberId} not found`);

    try {
      let feed;
      if (command.feedId) {
        feed = await this.feedRepository.findOne({ _id: command.feedId, _organizationId: command.organizationId });
        if (!feed) {
          throw new NotFoundException(`Feed with ${command.feedId} not found`);
        }
      }

      const deleteMessageQuery: Partial<MessageEntity> & EnforceEnvId = {
        _environmentId: command.environmentId,
        _organizationId: command.organizationId,
        _subscriberId: subscriber._id,
        channel: ChannelTypeEnum.IN_APP,
      };

      if (feed) {
        deleteMessageQuery._feedId = feed._id;
      }
      const deletedMessages = await this.messageRepository.delete(deleteMessageQuery);

      if (deletedMessages.deletedCount > 0) {
        await Promise.all([
          this.updateServices(command, subscriber, MarkEnum.SEEN),
          this.updateServices(command, subscriber, MarkEnum.READ),
          this.invalidateCache.invalidateQuery({
            key: buildFeedKey().invalidate({
              subscriberId: command.subscriberId,
              _environmentId: command.environmentId,
            }),
          }),
          this.invalidateCache.invalidateQuery({
            key: buildMessageCountKey().invalidate({
              subscriberId: command.subscriberId,
              _environmentId: command.environmentId,
            }),
          }),
        ]);
      }

      this.analyticsService.track(`Removed All Feed Messages - [Notification Center]`, command.organizationId, {
        _subscriber: subscriber._id,
        _organization: command.organizationId,
        _environment: command.environmentId,
        _feedId: command.feedId,
      });
    } catch (e) {
      if (e instanceof DalException) {
        throw new BadRequestException(e.message);
      }
      throw e;
    }
  }

  private async updateServices(command: RemoveAllMessagesCommand, subscriber, marked: string): Promise<void> {
    await this.updateSocketCount(subscriber, marked);
  }

  private async updateSocketCount(subscriber: SubscriberEntity, mark: string): Promise<void> {
    const eventMessage = mark === MarkEnum.READ ? WebSocketEventEnum.UNREAD : WebSocketEventEnum.UNSEEN;

    await this.webSocketsQueueService.add({
      name: 'sendMessage',
      data: {
        event: eventMessage,
        userId: subscriber._id,
        _environmentId: subscriber._environmentId,
      },
      groupId: subscriber._organizationId,
    });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RemoveAllMessages

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/workflow-overrides.controller.ts
Tamaño: 8307 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  Body,
  ClassSerializerInterceptor,
  Controller,
  Delete,
  Get,
  Param,
  Post,
  Put,
  Query,
  UseGuards,
  UseInterceptors,
} from '@nestjs/common';
import { ApiExcludeController, ApiOperation, ApiTags } from '@nestjs/swagger';
import { UserSessionData } from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { ExternalApiAccessible } from '../auth/framework/external-api.decorator';
import { RootEnvironmentGuard } from '../auth/framework/root-environment-guard.service';
import { DataBooleanDto } from '../shared/dtos/data-wrapper-dto';
import { ApiCommonResponses, ApiOkResponse, ApiResponse } from '../shared/framework/response.decorator';
import { UserSession } from '../shared/framework/user.decorator';
import {
  CreateWorkflowOverrideRequestDto,
  CreateWorkflowOverrideResponseDto,
  GetWorkflowOverrideResponseDto,
  GetWorkflowOverridesRequestDto,
  GetWorkflowOverridesResponseDto,
  UpdateWorkflowOverrideRequestDto,
  UpdateWorkflowOverrideResponseDto,
} from './dtos';
import { CreateWorkflowOverrideCommand } from './usecases/create-workflow-override/create-workflow-override.command';
import { CreateWorkflowOverride } from './usecases/create-workflow-override/create-workflow-override.usecase';
import { DeleteWorkflowOverrideCommand } from './usecases/delete-workflow-override/delete-workflow-override.command';
import { DeleteWorkflowOverride } from './usecases/delete-workflow-override/delete-workflow-override.usecase';
import { GetWorkflowOverrideCommand } from './usecases/get-workflow-override/get-workflow-override.command';
import { GetWorkflowOverride } from './usecases/get-workflow-override/get-workflow-override.usecase';
import { GetWorkflowOverrideByIdCommand } from './usecases/get-workflow-override-by-id/get-workflow-override-by-id.command';
import { GetWorkflowOverrideById } from './usecases/get-workflow-override-by-id/get-workflow-override-by-id.usecase';
import { GetWorkflowOverridesCommand } from './usecases/get-workflow-overrides/get-workflow-overrides.command';
import { GetWorkflowOverrides } from './usecases/get-workflow-overrides/get-workflow-overrides.usecase';
import { UpdateWorkflowOverrideCommand } from './usecases/update-workflow-override/update-workflow-override.command';
import { UpdateWorkflowOverride } from './usecases/update-workflow-override/update-workflow-override.usecase';
import { UpdateWorkflowOverrideByIdCommand } from './usecases/update-workflow-override-by-id/update-workflow-override-by-id.command';
import { UpdateWorkflowOverrideById } from './usecases/update-workflow-override-by-id/update-workflow-override-by-id.usecase';

@ApiCommonResponses()
@Controller('/workflow-overrides')
@UseInterceptors(ClassSerializerInterceptor)
@RequireAuthentication()
@ApiTags('Workflows-Overrides')
@ApiExcludeController()
export class WorkflowOverridesController {
  constructor(
    private createWorkflowOverrideUsecase: CreateWorkflowOverride,
    private updateWorkflowOverrideUsecase: UpdateWorkflowOverride,
    private updateWorkflowOverrideByIdUsecase: UpdateWorkflowOverrideById,
    private getWorkflowOverrideUsecase: GetWorkflowOverride,
    private getWorkflowOverrideByIdUsecase: GetWorkflowOverrideById,
    private deleteWorkflowOverrideUsecase: DeleteWorkflowOverride,
    private getWorkflowOverridesUsecase: GetWorkflowOverrides
  ) {}

  @Post('/')
  @UseGuards(RootEnvironmentGuard)
  @ApiResponse(CreateWorkflowOverrideResponseDto)
  @ApiOperation({
    summary: 'Create workflow override',
  })
  @ExternalApiAccessible()
  create(
    @UserSession() user: UserSessionData,
    @Body() body: CreateWorkflowOverrideRequestDto
  ): Promise<CreateWorkflowOverrideResponseDto> {
    return this.createWorkflowOverrideUsecase.execute(
      CreateWorkflowOverrideCommand.create({
        organizationId: user.organizationId,
        environmentId: user.environmentId,
        userId: user._id,
        active: body.active,
        preferenceSettings: body.preferenceSettings,
        _tenantId: body.tenantId,
        _workflowId: body.workflowId,
      })
    );
  }

  @Put('/:overrideId')
  @UseGuards(RootEnvironmentGuard)
  @ApiResponse(UpdateWorkflowOverrideResponseDto)
  @ApiOperation({
    summary: 'Update workflow override by id',
  })
  @ExternalApiAccessible()
  updateWorkflowOverrideById(
    @UserSession() user: UserSessionData,
    @Body() body: UpdateWorkflowOverrideRequestDto,
    @Param('overrideId') overrideId: string
  ): Promise<UpdateWorkflowOverrideResponseDto> {
    return this.updateWorkflowOverrideByIdUsecase.execute(
      UpdateWorkflowOverrideByIdCommand.create({
        organizationId: user.organizationId,
        environmentId: user.environmentId,
        userId: user._id,
        active: body.active,
        preferenceSettings: body.preferenceSettings,
        overrideId,
      })
    );
  }

  @Put('/workflows/:workflowId/tenants/:tenantId')
  @UseGuards(RootEnvironmentGuard)
  @ApiResponse(UpdateWorkflowOverrideResponseDto)
  @ApiOperation({
    summary: 'Update workflow override',
  })
  @ExternalApiAccessible()
  updateWorkflowOverride(
    @UserSession() user: UserSessionData,
    @Body() body: UpdateWorkflowOverrideRequestDto,
    @Param('workflowId') workflowId: string,
    @Param('tenantId') tenantId: string
  ): Promise<UpdateWorkflowOverrideResponseDto> {
    return this.updateWorkflowOverrideUsecase.execute(
      UpdateWorkflowOverrideCommand.create({
        organizationId: user.organizationId,
        environmentId: user.environmentId,
        userId: user._id,
        active: body.active,
        preferenceSettings: body.preferenceSettings,
        _tenantId: tenantId,
        _workflowId: workflowId,
      })
    );
  }

  @Get('/:overrideId')
  @UseGuards(RootEnvironmentGuard)
  @ApiResponse(GetWorkflowOverrideResponseDto)
  @ApiOperation({
    summary: 'Get workflow override by id',
  })
  @ExternalApiAccessible()
  getWorkflowOverrideById(
    @UserSession() user: UserSessionData,
    @Param('overrideId') overrideId: string
  ): Promise<GetWorkflowOverrideResponseDto> {
    return this.getWorkflowOverrideByIdUsecase.execute(
      GetWorkflowOverrideByIdCommand.create({
        organizationId: user.organizationId,
        environmentId: user.environmentId,
        userId: user._id,
        overrideId,
      })
    );
  }

  @Get('/workflows/:workflowId/tenants/:tenantId')
  @UseGuards(RootEnvironmentGuard)
  @ApiResponse(GetWorkflowOverrideResponseDto)
  @ApiOperation({
    summary: 'Get workflow override',
  })
  @ExternalApiAccessible()
  getWorkflowOverride(
    @UserSession() user: UserSessionData,
    @Param('workflowId') workflowId: string,
    @Param('tenantId') tenantId: string
  ): Promise<GetWorkflowOverrideResponseDto> {
    return this.getWorkflowOverrideUsecase.execute(
      GetWorkflowOverrideCommand.create({
        organizationId: user.organizationId,
        environmentId: user.environmentId,
        userId: user._id,
        _tenantId: tenantId,
        _workflowId: workflowId,
      })
    );
  }

  @Delete('/:overrideId')
  @UseGuards(RootEnvironmentGuard)
  @ApiOkResponse({
    type: DataBooleanDto,
  })
  @ApiOperation({
    summary: 'Delete workflow override',
  })
  @ExternalApiAccessible()
  deleteWorkflowOverride(
    @UserSession() user: UserSessionData,
    @Param('overrideId') overrideId: string
  ): Promise<boolean> {
    return this.deleteWorkflowOverrideUsecase.execute(
      DeleteWorkflowOverrideCommand.create({
        organizationId: user.organizationId,
        environmentId: user.environmentId,
        userId: user._id,
        _id: overrideId,
      })
    );
  }

  @Get('/')
  @UseGuards(RootEnvironmentGuard)
  @ApiResponse(GetWorkflowOverridesResponseDto)
  @ApiOperation({
    summary: 'Get workflow overrides',
  })
  @ExternalApiAccessible()
  getWorkflowOverrides(
    @UserSession() user: UserSessionData,
    @Query() query: GetWorkflowOverridesRequestDto
  ): Promise<GetWorkflowOverridesResponseDto> {
    return this.getWorkflowOverridesUsecase.execute(
      GetWorkflowOverridesCommand.create({
        organizationId: user.organizationId,
        environmentId: user.environmentId,
        userId: user._id,
        page: query.page,
        limit: query.limit,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class WorkflowOverridesController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/workflow-overrides.module.ts
Tamaño: 588 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { MiddlewareConsumer, Module, NestModule } from '@nestjs/common';
import { AuthModule } from '../auth/auth.module';
import { SharedModule } from '../shared/shared.module';
import { USE_CASES } from './usecases';
import { WorkflowOverridesController } from './workflow-overrides.controller';

@Module({
  imports: [SharedModule, AuthModule],
  controllers: [WorkflowOverridesController],
  providers: [...USE_CASES],
  exports: [...USE_CASES],
})
export class WorkflowOverridesModule implements NestModule {
  configure(consumer: MiddlewareConsumer): MiddlewareConsumer | void {}
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class WorkflowOverridesModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/dtos/create-workflow-override-request.dto.ts
Tamaño: 869 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { ICreateWorkflowOverrideRequestDto } from '@novu/shared';
import { Type } from 'class-transformer';
import { IsBoolean, IsDefined, IsOptional, IsString, ValidateNested } from 'class-validator';

import { SubscriberPreferenceChannels } from '../../shared/dtos/preference-channels';

export class CreateWorkflowOverrideRequestDto implements ICreateWorkflowOverrideRequestDto {
  @ApiProperty()
  @IsString()
  @IsDefined()
  workflowId: string;

  @ApiProperty()
  @IsString()
  @IsDefined()
  tenantId: string;

  @ApiPropertyOptional()
  @IsBoolean()
  @IsOptional()
  active?: boolean;

  @ApiPropertyOptional({
    type: SubscriberPreferenceChannels,
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => SubscriberPreferenceChannels)
  preferenceSettings?: SubscriberPreferenceChannels;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateWorkflowOverrideRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/dtos/create-workflow-override-response.dto.ts
Tamaño: 244 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ICreateWorkflowOverrideResponseDto } from '@novu/shared';
import { OverrideResponseDto } from './shared';

export class CreateWorkflowOverrideResponseDto
  extends OverrideResponseDto
  implements ICreateWorkflowOverrideResponseDto {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateWorkflowOverrideResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/dtos/get-workflow-override-response.dto.ts
Tamaño: 225 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IWorkflowOverrideResponseDto } from '@novu/shared';
import { OverrideResponseDto } from './shared';

export class GetWorkflowOverrideResponseDto extends OverrideResponseDto implements IWorkflowOverrideResponseDto {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetWorkflowOverrideResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/dtos/get-workflow-overrides-request.dto.ts
Tamaño: 163 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { PaginationRequestDto } from '../../shared/dtos/pagination-request';

export class GetWorkflowOverridesRequestDto extends PaginationRequestDto(10, 100) {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetWorkflowOverridesRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/dtos/get-workflow-overrides-response.dto.ts
Tamaño: 406 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IWorkflowOverridesResponseDto } from '@novu/shared';
import { OverrideResponseDto } from './shared';

export class GetWorkflowOverridesResponseDto implements IWorkflowOverridesResponseDto {
  @ApiProperty()
  hasMore: boolean;

  @ApiProperty()
  data: OverrideResponseDto[];

  @ApiProperty()
  pageSize: number;

  @ApiProperty()
  page: number;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetWorkflowOverridesResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/dtos/index.ts
Tamaño: 389 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './create-workflow-override-request.dto';
export * from './create-workflow-override-response.dto';
export * from './get-workflow-override-response.dto';
export * from './get-workflow-overrides-request.dto';
export * from './get-workflow-overrides-response.dto';
export * from './update-workflow-override-request.dto';
export * from './update-workflow-override-response.dto';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/dtos/shared.ts
Tamaño: 938 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import {
  EnvironmentId,
  IPreferenceChannels,
  IWorkflowOverride,
  OrganizationId,
  WorkflowOverrideId,
} from '@novu/shared';
import { SubscriberPreferenceChannels } from '../../shared/dtos/preference-channels';

export class OverrideResponseDto implements IWorkflowOverride {
  @ApiProperty()
  _id: WorkflowOverrideId;

  @ApiProperty()
  _organizationId: OrganizationId;

  @ApiProperty()
  _environmentId: EnvironmentId;

  @ApiProperty()
  _workflowId: string;

  @ApiProperty()
  _tenantId: string;

  @ApiProperty()
  active: boolean;

  @ApiProperty({
    type: SubscriberPreferenceChannels,
  })
  preferenceSettings: IPreferenceChannels;

  @ApiProperty()
  deleted: boolean;

  @ApiPropertyOptional()
  deletedAt?: string;

  @ApiPropertyOptional()
  deletedBy?: string;

  @ApiProperty()
  createdAt: string;

  @ApiProperty()
  updatedAt?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class OverrideResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/dtos/update-workflow-override-request.dto.ts
Tamaño: 699 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional } from '@nestjs/swagger';
import { IUpdateWorkflowOverrideRequestDto } from '@novu/shared';
import { Type } from 'class-transformer';
import { IsBoolean, IsOptional, ValidateNested } from 'class-validator';

import { SubscriberPreferenceChannels } from '../../shared/dtos/preference-channels';

export class UpdateWorkflowOverrideRequestDto implements IUpdateWorkflowOverrideRequestDto {
  @ApiPropertyOptional()
  @IsBoolean()
  @IsOptional()
  active?: boolean;

  @ApiPropertyOptional({
    type: SubscriberPreferenceChannels,
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => SubscriberPreferenceChannels)
  preferenceSettings?: SubscriberPreferenceChannels;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateWorkflowOverrideRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/dtos/update-workflow-override-response.dto.ts
Tamaño: 244 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IUpdateWorkflowOverrideResponseDto } from '@novu/shared';
import { OverrideResponseDto } from './shared';

export class UpdateWorkflowOverrideResponseDto
  extends OverrideResponseDto
  implements IUpdateWorkflowOverrideResponseDto {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateWorkflowOverrideResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/e2e/create-workflow-override.e2e.ts
Tamaño: 4000 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { NotificationTemplateRepository, TenantRepository } from '@novu/dal';
import { ICreateWorkflowOverrideRequestDto } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Create Integration - /workflow-overrides (POST) #novu-v0', () => {
  let session: UserSession;
  const tenantRepository = new TenantRepository();
  const notificationTemplateRepository = new NotificationTemplateRepository();

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should successfully create new workflow override', async () => {
    const tenant = await tenantRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      identifier: 'identifier_123',
      name: 'name_123',
      data: { test1: 'test value1', test2: 'test value2' },
    });

    const workflow = await notificationTemplateRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      name: 'test api template',
      description: 'This is a test description',
      tags: ['test-tag-api'],
      notificationGroupId: session.notificationGroups[0]._id,
      steps: [],
      triggers: [{ identifier: 'test-trigger-api' }],
    });

    const payload: ICreateWorkflowOverrideRequestDto = {
      preferenceSettings: { email: false },
      active: false,
      workflowId: workflow._id,
      tenantId: tenant._id,
    };

    const res = await session.testAgent.post('/v1/workflow-overrides').send(payload);

    expect(res.status).to.equal(201);

    expect(res.body.data.active).to.equal(false);
    expect(res.body.data._workflowId).to.equal(workflow._id);
    expect(res.body.data._tenantId).to.equal(tenant._id);
    expect(res.body.data.preferenceSettings).to.deep.equal({
      email: false,
      sms: true,
      in_app: true,
      chat: true,
      push: true,
    });
    expect(res.body.data.deleted).to.equal(false);
    expect(res.body.data._environmentId).to.equal(session.environment._id);
    expect(res.body.data._organizationId).to.equal(session.organization._id);
  });

  it('should fail on creation of new workflow override with missing workflow id', async () => {
    const tenant = await tenantRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      identifier: 'identifier_123',
      name: 'name_123',
      data: { test1: 'test value1', test2: 'test value2' },
    });

    const payload: ICreateWorkflowOverrideRequestDto = {
      preferenceSettings: { email: false },
      active: false,
      tenantId: tenant._id,
      workflowId: undefined as any,
    };

    const res = await session.testAgent.post('/v1/workflow-overrides').send(payload);

    expect(res.body.statusCode).to.equal(400);
    expect(res.body.message[0]).to.equal('workflowId should not be null or undefined');
    expect(res.body.message[1]).to.equal('workflowId must be a string');
  });

  it('should fail on creation of new workflow override with missing tenant id', async () => {
    const workflow = await notificationTemplateRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      name: 'test api template',
      description: 'This is a test description',
      tags: ['test-tag-api'],
      notificationGroupId: session.notificationGroups[0]._id,
      steps: [],
      triggers: [{ identifier: 'test-trigger-api' }],
    });

    const payload: ICreateWorkflowOverrideRequestDto = {
      preferenceSettings: { email: false },
      active: false,
      workflowId: workflow._id,
      tenantId: 'fake-tenant-identifier',
    };

    const res = await session.testAgent.post('/v1/workflow-overrides').send(payload);
    expect(res.body.statusCode).to.equal(422);
    expect(res.body.errors._tenantId.messages[0]).to.equal(`_tenantId must be a mongodb id`);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - notificationTemplateRepository(new NotificationTemplateRepository();

  beforeEach(async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('should successfully create new workf...)
 - res(await session.testAgent.post('/v1/workflow-overrides').send(payload);

    expect(res.status).to.equ...)
 - res(await session.testAgent.post('/v1/workflow-overrides').send(payload);

    expect(res.body.statusCod...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/e2e/delete-workflow-override.e2e.ts
Tamaño: 2146 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { TenantRepository, WorkflowOverrideRepository } from '@novu/dal';
import { UserSession, WorkflowOverrideService } from '@novu/testing';
import { expect } from 'chai';

describe('Delete workflow override - /workflow-overrides/:overrideId (Delete) #novu-v0', async () => {
  let session: UserSession;
  const tenantRepository = new TenantRepository();
  const workflowOverrideRepository = new WorkflowOverrideRepository();

  before(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should delete the workflow override', async () => {
    const workflowOverrideService = new WorkflowOverrideService({
      organizationId: session.organization._id,
      environmentId: session.environment._id,
    });

    const { tenant, workflowOverride } = await workflowOverrideService.createWorkflowOverride();

    if (!tenant) throw new Error('Tenant not found');

    const validatedCreationWorkflowOverride = await workflowOverrideRepository.findOne({
      _environmentId: session.environment._id,
      _id: workflowOverride._id,
    });

    if (!validatedCreationWorkflowOverride) throw new Error('WorkflowOverride not found');

    expect(validatedCreationWorkflowOverride._id).to.be.ok;

    const deleteRes = await session.testAgent.delete(`/v1/workflow-overrides/${validatedCreationWorkflowOverride._id}`);

    const foundWorkflowOverride: boolean = deleteRes.body.data;

    expect(foundWorkflowOverride).to.equal(true);

    const findDeleted = await workflowOverrideRepository.findOne({
      _environmentId: session.environment._id,
      _id: workflowOverride._id,
    });

    expect(findDeleted).to.be.null;
  });

  it('should fail to delete non-existing workflow override', async () => {
    const fakeWorkflowOverrideId = session.user._id;
    const deleteRes = await session.testAgent.delete(`/v1/workflow-overrides/${fakeWorkflowOverrideId}`);

    const foundWorkflowOverride = deleteRes.body;

    expect(foundWorkflowOverride.statusCode).to.equal(404);
    expect(foundWorkflowOverride.message).to.equal(`Workflow Override with id ${fakeWorkflowOverrideId} not found`);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - workflowOverrideRepository(new WorkflowOverrideRepository();

  before(async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('should delete the workflow override'...)
 - findDeleted(await workflowOverrideRepository.findOne({
      _environmentId: session.environment._id,
      _id:...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/e2e/get-workflow-override-by-id.e2e.ts
Tamaño: 1973 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { TenantRepository } from '@novu/dal';
import { IWorkflowOverride } from '@novu/shared';
import { UserSession, WorkflowOverrideService } from '@novu/testing';
import { expect } from 'chai';

describe('Get workflow override by ID - /workflow-overrides/:overrideId (GET) #novu-v0', async () => {
  let session: UserSession;
  const tenantRepository = new TenantRepository();

  before(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should return the workflow override by ID', async () => {
    const workflowOverrideService = new WorkflowOverrideService({
      organizationId: session.organization._id,
      environmentId: session.environment._id,
    });
    const { workflowOverride } = await workflowOverrideService.createWorkflowOverride();

    const tenant = await tenantRepository.findOne({
      _environmentId: session.environment._id,
      _id: workflowOverride._tenantId,
    });

    if (!tenant) throw new Error('Tenant not found');

    const res = await session.testAgent.get(`/v1/workflow-overrides/${workflowOverride._id}`);

    const foundWorkflowOverride: IWorkflowOverride = res.body.data;

    expect(foundWorkflowOverride._workflowId).to.equal(workflowOverride._workflowId);
    expect(foundWorkflowOverride._tenantId).to.equal(workflowOverride._tenantId);
    expect(foundWorkflowOverride.active).to.equal(workflowOverride.active);
    expect(foundWorkflowOverride.preferenceSettings.chat).to.equal(workflowOverride.preferenceSettings.chat);
    expect(foundWorkflowOverride.preferenceSettings.sms).to.equal(workflowOverride.preferenceSettings.sms);
    expect(foundWorkflowOverride.preferenceSettings.in_app).to.equal(workflowOverride.preferenceSettings.in_app);
    expect(foundWorkflowOverride.preferenceSettings.email).to.equal(workflowOverride.preferenceSettings.email);
    expect(foundWorkflowOverride.preferenceSettings.push).to.equal(workflowOverride.preferenceSettings.push);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - tenantRepository(new TenantRepository();

  before(async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('should return the workflow override ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/e2e/get-workflow-override.e2e.ts
Tamaño: 2049 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { TenantRepository } from '@novu/dal';
import { IWorkflowOverride } from '@novu/shared';
import { UserSession, WorkflowOverrideService } from '@novu/testing';
import { expect } from 'chai';

describe('Get workflow override - /workflow-overrides/workflows/:workflowId/tenants/:tenantIdentifier (GET) #novu-v0', async () => {
  let session: UserSession;
  const tenantRepository = new TenantRepository();

  before(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should return the workflow override', async () => {
    const workflowOverrideService = new WorkflowOverrideService({
      organizationId: session.organization._id,
      environmentId: session.environment._id,
    });
    const { workflowOverride } = await workflowOverrideService.createWorkflowOverride();

    const tenant = await tenantRepository.findOne({
      _environmentId: session.environment._id,
      _id: workflowOverride._tenantId,
    });

    if (!tenant) throw new Error('Tenant not found');

    const res = await session.testAgent.get(
      `/v1/workflow-overrides/workflows/${workflowOverride._workflowId}/tenants/${tenant._id}`
    );

    const foundWorkflowOverride: IWorkflowOverride = res.body.data;

    expect(foundWorkflowOverride._workflowId).to.equal(workflowOverride._workflowId);
    expect(foundWorkflowOverride._tenantId).to.equal(workflowOverride._tenantId);
    expect(foundWorkflowOverride.active).to.equal(workflowOverride.active);
    expect(foundWorkflowOverride.preferenceSettings.chat).to.equal(workflowOverride.preferenceSettings.chat);
    expect(foundWorkflowOverride.preferenceSettings.sms).to.equal(workflowOverride.preferenceSettings.sms);
    expect(foundWorkflowOverride.preferenceSettings.in_app).to.equal(workflowOverride.preferenceSettings.in_app);
    expect(foundWorkflowOverride.preferenceSettings.email).to.equal(workflowOverride.preferenceSettings.email);
    expect(foundWorkflowOverride.preferenceSettings.push).to.equal(workflowOverride.preferenceSettings.push);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - tenantRepository(new TenantRepository();

  before(async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('should return the workflow override'...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/e2e/get-workflow-overrides.e2e.ts
Tamaño: 5122 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { NotificationGroupRepository, NotificationTemplateRepository, WorkflowOverrideRepository } from '@novu/dal';
import { UserSession, WorkflowOverrideService } from '@novu/testing';
import { expect } from 'chai';

describe('Get workflows overrides - /workflow-overrides (GET) #novu-v0', async () => {
  let session: UserSession;
  const notificationTemplateRepository = new NotificationTemplateRepository();
  const notificationGroupRepository = new NotificationGroupRepository();
  const workflowOverrideRepository = new WorkflowOverrideRepository();

  before(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should return all workflows override by workflow id', async () => {
    const workflowOverrideService = new WorkflowOverrideService({
      organizationId: session.organization._id,
      environmentId: session.environment._id,
    });

    const groups = await notificationGroupRepository.find({
      _environmentId: session.environment._id,
    });

    const noOverrides = (await session.testAgent.get(`/v1/workflow-overrides`)).body.data;

    expect(noOverrides.length).to.equal(0);

    let workflow = await notificationTemplateRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      name: 'test api template',
      description: 'This is a test description',
      tags: ['test-tag-api'],
      notificationGroupId: groups[0]._id,
      steps: [],
      triggers: [{ identifier: 'test-trigger-api_1' }],
    });
    await workflowOverrideService.createWorkflowOverride({ workflowId: workflow._id });
    workflow = await notificationTemplateRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      name: 'test api template',
      description: 'This is a test description',
      tags: ['test-tag-api'],
      notificationGroupId: groups[0]._id,
      steps: [],
      triggers: [{ identifier: 'test-trigger-api_2' }],
    });
    await workflowOverrideService.createWorkflowOverride({ workflowId: workflow._id });
    workflow = await notificationTemplateRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      name: 'test api template',
      description: 'This is a test description',
      tags: ['test-tag-api'],
      notificationGroupId: groups[0]._id,
      steps: [],
      triggers: [{ identifier: 'test-trigger-api_3' }],
    });
    await workflowOverrideService.createWorkflowOverride({ workflowId: workflow._id });

    const { data } = (await session.testAgent.get(`/v1/workflow-overrides`)).body;

    expect(data.length).to.equal(3);

    const paginatedData = (await session.testAgent.get(`/v1/workflow-overrides?page=1&limit=2`)).body.data;

    expect(paginatedData.length).to.equal(1);
  });

  it('should return all workflows override by workflow id with pagination', async () => {
    await workflowOverrideRepository.delete({} as any);

    const workflowOverrideService = new WorkflowOverrideService({
      organizationId: session.organization._id,
      environmentId: session.environment._id,
    });

    const groups = await notificationGroupRepository.find({
      _environmentId: session.environment._id,
    });

    let workflow = await notificationTemplateRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      name: 'test api template',
      description: 'This is a test description',
      tags: ['test-tag-api'],
      notificationGroupId: groups[0]._id,
      steps: [],
      triggers: [{ identifier: 'test-trigger-api_1' }],
    });
    await workflowOverrideService.createWorkflowOverride({ workflowId: workflow._id });
    workflow = await notificationTemplateRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      name: 'test api template',
      description: 'This is a test description',
      tags: ['test-tag-api'],
      notificationGroupId: groups[0]._id,
      steps: [],
      triggers: [{ identifier: 'test-trigger-api_2' }],
    });
    await workflowOverrideService.createWorkflowOverride({ workflowId: workflow._id });
    workflow = await notificationTemplateRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      name: 'test api template',
      description: 'This is a test description',
      tags: ['test-tag-api'],
      notificationGroupId: groups[0]._id,
      steps: [],
      triggers: [{ identifier: 'test-trigger-api_2' }],
    });
    await workflowOverrideService.createWorkflowOverride({ workflowId: workflow._id });

    const page1 = (await session.testAgent.get(`/v1/workflow-overrides?limit=2`)).body;

    expect(page1.data.length).to.equal(2);
    expect(page1.hasMore).to.equal(true);

    const page2 = (await session.testAgent.get(`/v1/workflow-overrides?page=1&limit=2`)).body;

    expect(page2.data.length).to.equal(1);
    expect(page2.hasMore).to.equal(false);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - workflowOverrideRepository(new WorkflowOverrideRepository();

  before(async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('should return all workflows override...)
 - limit(2`)).body.data;

    expect(paginatedData.length).to.equal(1);
  });

  it('should return all workfl...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/e2e/update-workflow-override-by-id.e2e.ts
Tamaño: 1621 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IUpdateWorkflowOverrideRequestDto } from '@novu/shared';

import { UserSession, WorkflowOverrideService } from '@novu/testing';
import { expect } from 'chai';

describe('Update Workflow Override By ID - /workflow-overrides/:overrideId (PUT) #novu-v0', () => {
  let session: UserSession;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should successfully update workflow override by ID', async () => {
    const workflowOverrideService = new WorkflowOverrideService({
      organizationId: session.organization._id,
      environmentId: session.environment._id,
    });

    const { workflowOverride } = await workflowOverrideService.createWorkflowOverride({
      preferenceSettings: {
        email: false,
        sms: true,
        in_app: true,
        chat: true,
        push: true,
      },
    });

    expect(workflowOverride.preferenceSettings).to.deep.equal({
      email: false,
      sms: true,
      in_app: true,
      chat: true,
      push: true,
    });
    expect(workflowOverride.active).to.equal(false);

    const updatePayload: IUpdateWorkflowOverrideRequestDto = {
      preferenceSettings: { email: true, sms: false },
      active: true,
    };

    const updatedOverrides = (
      await session.testAgent.put(`/v1/workflow-overrides/${workflowOverride._id}`).send(updatePayload)
    ).body.data;

    expect(updatedOverrides.preferenceSettings).to.deep.equal({
      email: true,
      sms: false,
      in_app: true,
      chat: true,
      push: true,
    });
    expect(updatedOverrides.active).to.equal(true);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
    await session.initialize();
  });

  it('should successfully update workflow ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/e2e/update-workflow-override.e2e.ts
Tamaño: 5792 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { NotificationTemplateRepository, TenantRepository } from '@novu/dal';
import { ICreateWorkflowOverrideRequestDto, IUpdateWorkflowOverrideRequestDto } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Update Workflow Override - /workflow-overrides/workflows/:workflowId/tenants/:tenantIdentifier (PUT) #novu-v0', () => {
  let session: UserSession;
  const tenantRepository = new TenantRepository();
  const notificationTemplateRepository = new NotificationTemplateRepository();

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should successfully update workflow override', async () => {
    const { tenant, workflow, overrides } = await initializeOverrides();

    expect(overrides.preferenceSettings).to.deep.equal({
      email: false,
      sms: true,
      in_app: true,
      chat: true,
      push: true,
    });
    expect(overrides.active).to.equal(false);

    const updatePayload: IUpdateWorkflowOverrideRequestDto = {
      preferenceSettings: { email: true, sms: false },
      active: true,
    };

    const updatedOverrides = (
      await session.testAgent
        .put(`/v1/workflow-overrides/workflows/${workflow._id}/tenants/${tenant._id}`)
        .send(updatePayload)
    ).body.data;

    expect(updatedOverrides.preferenceSettings).to.deep.equal({
      email: true,
      sms: false,
      in_app: true,
      chat: true,
      push: true,
    });
    expect(updatedOverrides.active).to.equal(true);
  });

  it('should fail update workflow override with invalid tenant identifier', async () => {
    const { tenant, workflow, overrides } = await initializeOverrides();

    expect(overrides.preferenceSettings).to.deep.equal({
      email: false,
      sms: true,
      in_app: true,
      chat: true,
      push: true,
    });
    expect(overrides.active).to.equal(false);

    const updatePayload: IUpdateWorkflowOverrideRequestDto = {
      preferenceSettings: { email: true, sms: false },
      active: true,
    };

    const invalidTenantIdentifier = 'invalid-tenant-identifier';
    const updatedOverrides = (
      await session.testAgent
        .put(`/v1/workflow-overrides/workflows/${workflow._id}/tenants/${invalidTenantIdentifier}`)
        .send(updatePayload)
    ).body;
    expect(updatedOverrides.statusCode).to.equal(422);
    expect(updatedOverrides.errors._tenantId.messages[0]).to.equal('_tenantId must be a mongodb id');
  });

  it('should fail update workflow override with invalid workflow id', async () => {
    const { tenant, workflow, overrides } = await initializeOverrides();

    expect(overrides.preferenceSettings).to.deep.equal({
      email: false,
      sms: true,
      in_app: true,
      chat: true,
      push: true,
    });
    expect(overrides.active).to.equal(false);

    const updatePayload: IUpdateWorkflowOverrideRequestDto = {
      preferenceSettings: { email: true, sms: false },
      active: true,
    };

    const invalidWorkflowId = tenant._id;
    const updatedOverrides = (
      await session.testAgent
        .put(`/v1/workflow-overrides/workflows/${invalidWorkflowId}/tenants/${tenant.identifier}`)
        .send(updatePayload)
    ).body;
    expect(updatedOverrides.statusCode).to.equal(422);
    expect(updatedOverrides.errors._tenantId.messages[0]).to.equal(`_tenantId must be a mongodb id`);
  });

  it('should fail update workflow override with now existing workflow override', async () => {
    const tenant = await tenantRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      identifier: 'identifier_123',
      name: 'name_123',
      data: { test1: 'test value1', test2: 'test value2' },
    });

    const workflow = await notificationTemplateRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      name: 'test api template',
      description: 'This is a test description',
      tags: ['test-tag-api'],
      notificationGroupId: session.notificationGroups[0]._id,
      steps: [],
      triggers: [{ identifier: 'test-trigger-api' }],
    });

    const updatePayload: IUpdateWorkflowOverrideRequestDto = {
      preferenceSettings: { email: true, sms: false },
      active: true,
    };

    const updatedOverrides = (
      await session.testAgent
        .put(`/v1/workflow-overrides/workflows/${workflow._id}/tenants/${tenant.identifier}`)
        .send(updatePayload)
    ).body;
    expect(updatedOverrides.statusCode).to.equal(422);
    expect(updatedOverrides.errors._tenantId.messages[0]).to.equal(`_tenantId must be a mongodb id`);
  });

  async function initializeOverrides() {
    const tenant = await tenantRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      identifier: 'identifier_123',
      name: 'name_123',
      data: { test1: 'test value1', test2: 'test value2' },
    });

    const workflow = await notificationTemplateRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      name: 'test api template',
      description: 'This is a test description',
      tags: ['test-tag-api'],
      notificationGroupId: session.notificationGroups[0]._id,
      steps: [],
      triggers: [{ identifier: 'test-trigger-api' }],
    });

    const payload: ICreateWorkflowOverrideRequestDto = {
      preferenceSettings: { email: false },
      active: false,
      workflowId: workflow._id,
      tenantId: tenant._id,
    };

    const overrides = (await session.testAgent.post('/v1/workflow-overrides').send(payload)).body.data;

    return { tenant, workflow, overrides };
  }
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - initializeOverrides()
Asignaciones con arrow functions encontradas (posibles funciones):
 - notificationTemplateRepository(new NotificationTemplateRepository();

  beforeEach(async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('should successfully update workflow ...)
 - updatedOverrides(await session.testAgent
        .put(`/v1/workflow-overrides/workflows/${workflow._id}/tenants/${ten...)
 - updatedOverrides(await session.testAgent
        .put(`/v1/workflow-overrides/workflows/${workflow._id}/tenants/${inv...)
 - updatedOverrides(await session.testAgent
        .put(`/v1/workflow-overrides/workflows/${invalidWorkflowId}/tenants/...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/usecases/index.ts
Tamaño: 935 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CreateWorkflowOverride } from './create-workflow-override/create-workflow-override.usecase';
import { DeleteWorkflowOverride } from './delete-workflow-override/delete-workflow-override.usecase';
import { GetWorkflowOverride } from './get-workflow-override/get-workflow-override.usecase';
import { GetWorkflowOverrideById } from './get-workflow-override-by-id/get-workflow-override-by-id.usecase';
import { GetWorkflowOverrides } from './get-workflow-overrides/get-workflow-overrides.usecase';
import { UpdateWorkflowOverride } from './update-workflow-override/update-workflow-override.usecase';
import { UpdateWorkflowOverrideById } from './update-workflow-override-by-id/update-workflow-override-by-id.usecase';

export const USE_CASES = [
  CreateWorkflowOverride,
  UpdateWorkflowOverride,
  GetWorkflowOverride,
  DeleteWorkflowOverride,
  GetWorkflowOverrides,
  GetWorkflowOverrideById,
  UpdateWorkflowOverrideById,
];


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/usecases/create-workflow-override/create-workflow-override.command.ts
Tamaño: 687 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Type } from 'class-transformer';
import { IsBoolean, IsDefined, IsMongoId, IsOptional, ValidateNested } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';
import { SubscriberPreferenceChannels } from '../../../shared/dtos/preference-channels';

export class CreateWorkflowOverrideCommand extends EnvironmentWithUserCommand {
  @IsMongoId()
  @IsDefined()
  _workflowId: string;

  @IsMongoId()
  @IsDefined()
  _tenantId: string;

  @IsBoolean()
  @IsOptional()
  active?: boolean;

  @IsOptional()
  @ValidateNested()
  @Type(() => SubscriberPreferenceChannels)
  preferenceSettings?: SubscriberPreferenceChannels;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateWorkflowOverrideCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/usecases/create-workflow-override/create-workflow-override.usecase.ts
Tamaño: 1868 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';

import {
  NotificationTemplateEntity,
  NotificationTemplateRepository,
  TenantEntity,
  TenantRepository,
  WorkflowOverrideRepository,
} from '@novu/dal';
import { CreateWorkflowOverrideResponseDto } from '../../dtos';
import { CreateWorkflowOverrideCommand } from './create-workflow-override.command';

@Injectable()
export class CreateWorkflowOverride {
  constructor(
    private tenantRepository: TenantRepository,
    private notificationTemplateRepository: NotificationTemplateRepository,
    private workflowOverrideRepository: WorkflowOverrideRepository
  ) {}

  async execute(command: CreateWorkflowOverrideCommand): Promise<CreateWorkflowOverrideResponseDto> {
    const { tenant, workflow } = await this.extractEntities(command);

    return await this.workflowOverrideRepository.create({
      _organizationId: command.organizationId,
      _environmentId: command.environmentId,
      _tenantId: tenant._id,
      _workflowId: workflow._id,
      active: command.active,
      preferenceSettings: command.preferenceSettings,
    });
  }

  private async extractEntities(
    command: CreateWorkflowOverrideCommand
  ): Promise<{ tenant: TenantEntity; workflow: NotificationTemplateEntity }> {
    const tenant = await this.tenantRepository.findOne({
      _environmentId: command.environmentId,
      _id: command._tenantId,
    });

    if (!tenant) {
      throw new NotFoundException(`Tenant with id ${command._tenantId} is not found`);
    }

    const workflow = await this.notificationTemplateRepository.findOne({
      _environmentId: command.environmentId,
      _id: command._workflowId,
    });

    if (!workflow) {
      throw new NotFoundException(`Workflow with id ${command._workflowId} is not found`);
    }

    return { tenant, workflow };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateWorkflowOverride

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/usecases/delete-workflow-override/delete-workflow-override.command.ts
Tamaño: 272 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsMongoId } from 'class-validator';

import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class DeleteWorkflowOverrideCommand extends EnvironmentWithUserCommand {
  @IsMongoId()
  @IsDefined()
  _id: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DeleteWorkflowOverrideCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/usecases/delete-workflow-override/delete-workflow-override.usecase.ts
Tamaño: 1038 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { WorkflowOverrideRepository } from '@novu/dal';
import { DeleteWorkflowOverrideCommand } from './delete-workflow-override.command';

@Injectable()
export class DeleteWorkflowOverride {
  constructor(private workflowOverrideRepository: WorkflowOverrideRepository) {}

  async execute(command: DeleteWorkflowOverrideCommand): Promise<boolean> {
    const workflowOverride = await this.workflowOverrideRepository.findOne({
      _environmentId: command.environmentId,
      _id: command._id,
    });

    if (!workflowOverride) {
      throw new NotFoundException(`Workflow Override with id ${command._id} not found`);
    }

    const deletedWorkflowOverride = await this.workflowOverrideRepository.delete({
      _environmentId: command.environmentId,
      _id: command._id,
    });

    if (!deletedWorkflowOverride?.acknowledged) {
      throw new Error(`Unexpected error: failed to delete workflow override with id ${command._id}`);
    }

    return true;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DeleteWorkflowOverride

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/usecases/get-workflow-override-by-id/get-workflow-override-by-id.command.ts
Tamaño: 280 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsMongoId } from 'class-validator';

import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class GetWorkflowOverrideByIdCommand extends EnvironmentWithUserCommand {
  @IsMongoId()
  @IsDefined()
  overrideId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetWorkflowOverrideByIdCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/usecases/get-workflow-override-by-id/get-workflow-override-by-id.usecase.ts
Tamaño: 836 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';

import { WorkflowOverrideRepository } from '@novu/dal';

import { GetWorkflowOverrideResponseDto } from '../../dtos';
import { GetWorkflowOverrideByIdCommand } from './get-workflow-override-by-id.command';

@Injectable()
export class GetWorkflowOverrideById {
  constructor(private workflowOverrideRepository: WorkflowOverrideRepository) {}

  async execute(command: GetWorkflowOverrideByIdCommand): Promise<GetWorkflowOverrideResponseDto> {
    const workflowOverride = await this.workflowOverrideRepository.findOne({
      _environmentId: command.environmentId,
      _id: command.overrideId,
    });

    if (!workflowOverride) {
      throw new NotFoundException(`Workflow Override with id ${command.overrideId} not found`);
    }

    return workflowOverride;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetWorkflowOverrideById

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/usecases/get-workflow-override/get-workflow-override.command.ts
Tamaño: 339 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsMongoId, IsString } from 'class-validator';

import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class GetWorkflowOverrideCommand extends EnvironmentWithUserCommand {
  @IsMongoId()
  @IsDefined()
  _workflowId: string;

  @IsMongoId()
  @IsDefined()
  _tenantId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetWorkflowOverrideCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/usecases/get-workflow-override/get-workflow-override.usecase.ts
Tamaño: 1029 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';

import { TenantRepository, WorkflowOverrideRepository } from '@novu/dal';
import { GetWorkflowOverrideResponseDto } from '../../dtos/get-workflow-override-response.dto';
import { GetWorkflowOverrideCommand } from './get-workflow-override.command';

@Injectable()
export class GetWorkflowOverride {
  constructor(
    private tenantRepository: TenantRepository,
    private workflowOverrideRepository: WorkflowOverrideRepository
  ) {}

  async execute(command: GetWorkflowOverrideCommand): Promise<GetWorkflowOverrideResponseDto> {
    const workflowOverride = await this.workflowOverrideRepository.findOne({
      _environmentId: command.environmentId,
      _workflowId: command._workflowId,
      _tenantId: command._tenantId,
    });

    if (!workflowOverride) {
      throw new NotFoundException(
        `Workflow Override with workflow id ${command._workflowId}, tenant id ${command._tenantId} not found`
      );
    }

    return workflowOverride;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetWorkflowOverride

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/usecases/get-workflow-overrides/get-workflow-overrides.command.ts
Tamaño: 326 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsMongoId, IsNumber } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class GetWorkflowOverridesCommand extends EnvironmentWithUserCommand {
  @IsNumber()
  @IsDefined()
  page: number;

  @IsNumber()
  @IsDefined()
  limit: number;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetWorkflowOverridesCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/usecases/get-workflow-overrides/get-workflow-overrides.usecase.ts
Tamaño: 882 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';

import { WorkflowOverrideRepository } from '@novu/dal';
import { GetWorkflowOverridesResponseDto } from '../../dtos/get-workflow-overrides-response.dto';
import { GetWorkflowOverridesCommand } from './get-workflow-overrides.command';

@Injectable()
export class GetWorkflowOverrides {
  constructor(private workflowOverrideRepository: WorkflowOverrideRepository) {}

  async execute(command: GetWorkflowOverridesCommand): Promise<GetWorkflowOverridesResponseDto> {
    const { data } = await this.workflowOverrideRepository.getList(
      {
        skip: command.page * command.limit,
        limit: command.limit,
      },
      {
        environmentId: command.environmentId,
      }
    );

    return {
      data,
      page: command.page,
      pageSize: command.limit,
      hasMore: data?.length === command.limit,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetWorkflowOverrides

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/usecases/update-workflow-override-by-id/update-workflow-override-by-id.command.ts
Tamaño: 638 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Type } from 'class-transformer';
import { IsBoolean, IsDefined, IsMongoId, IsOptional, ValidateNested } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';
import { SubscriberPreferenceChannels } from '../../../shared/dtos/preference-channels';

export class UpdateWorkflowOverrideByIdCommand extends EnvironmentWithUserCommand {
  @IsMongoId()
  @IsDefined()
  overrideId: string;

  @IsBoolean()
  @IsOptional()
  active?: boolean;

  @IsOptional()
  @ValidateNested()
  @Type(() => SubscriberPreferenceChannels)
  preferenceSettings?: SubscriberPreferenceChannels;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateWorkflowOverrideByIdCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/usecases/update-workflow-override-by-id/update-workflow-override-by-id.usecase.ts
Tamaño: 1662 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';

import {
  NotificationTemplateRepository,
  TenantRepository,
  WorkflowOverrideEntity,
  WorkflowOverrideRepository,
} from '@novu/dal';
import { UpdateWorkflowOverrideResponseDto } from '../../dtos';
import { UpdateWorkflowOverrideByIdCommand } from './update-workflow-override-by-id.command';

@Injectable()
export class UpdateWorkflowOverrideById {
  constructor(
    private tenantRepository: TenantRepository,
    private notificationTemplateRepository: NotificationTemplateRepository,
    private workflowOverrideRepository: WorkflowOverrideRepository
  ) {}

  async execute(command: UpdateWorkflowOverrideByIdCommand): Promise<UpdateWorkflowOverrideResponseDto> {
    const currentOverrideEntity = await this.workflowOverrideRepository.findOne({
      _environmentId: command.environmentId,
      _id: command.overrideId,
    });

    if (!currentOverrideEntity) {
      throw new NotFoundException(`Workflow override with id ${command.overrideId} not found`);
    }

    const updatePayload: Partial<WorkflowOverrideEntity> = {};

    if (command.active != null) {
      updatePayload.active = command.active;
    }

    if (command.preferenceSettings != null) {
      updatePayload.preferenceSettings = {
        ...currentOverrideEntity.preferenceSettings,
        ...command.preferenceSettings,
      };
    }

    await this.workflowOverrideRepository.update(
      {
        _environmentId: command.environmentId,
        _id: currentOverrideEntity._id,
      },
      {
        $set: updatePayload,
      }
    );

    return { ...currentOverrideEntity, ...updatePayload };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateWorkflowOverrideById

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/usecases/update-workflow-override/update-workflow-override.command.ts
Tamaño: 687 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Type } from 'class-transformer';
import { IsBoolean, IsDefined, IsMongoId, IsOptional, ValidateNested } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';
import { SubscriberPreferenceChannels } from '../../../shared/dtos/preference-channels';

export class UpdateWorkflowOverrideCommand extends EnvironmentWithUserCommand {
  @IsMongoId()
  @IsDefined()
  _workflowId: string;

  @IsMongoId()
  @IsDefined()
  _tenantId: string;

  @IsBoolean()
  @IsOptional()
  active?: boolean;

  @IsOptional()
  @ValidateNested()
  @Type(() => SubscriberPreferenceChannels)
  preferenceSettings?: SubscriberPreferenceChannels;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateWorkflowOverrideCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflow-overrides/usecases/update-workflow-override/update-workflow-override.usecase.ts
Tamaño: 2620 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';

import {
  NotificationTemplateEntity,
  NotificationTemplateRepository,
  TenantEntity,
  TenantRepository,
  WorkflowOverrideEntity,
  WorkflowOverrideRepository,
} from '@novu/dal';
import { UpdateWorkflowOverrideResponseDto } from '../../dtos/update-workflow-override-response.dto';
import { UpdateWorkflowOverrideCommand } from './update-workflow-override.command';

@Injectable()
export class UpdateWorkflowOverride {
  constructor(
    private tenantRepository: TenantRepository,
    private notificationTemplateRepository: NotificationTemplateRepository,
    private workflowOverrideRepository: WorkflowOverrideRepository
  ) {}

  async execute(command: UpdateWorkflowOverrideCommand): Promise<UpdateWorkflowOverrideResponseDto> {
    const { tenant, workflow } = await this.extractEntities(command);

    const currentOverrideEntity = await this.workflowOverrideRepository.findOne({
      _environmentId: command.environmentId,
      _workflowId: workflow._id,
      _tenantId: tenant._id,
    });

    if (!currentOverrideEntity) {
      throw new NotFoundException(
        `Workflow override with workflow id ${command._workflowId} and tenant id ${command._tenantId} was not found`
      );
    }

    const updatePayload: Partial<WorkflowOverrideEntity> = {};

    if (command.active != null) {
      updatePayload.active = command.active;
    }

    if (command.preferenceSettings != null) {
      updatePayload.preferenceSettings = {
        ...currentOverrideEntity.preferenceSettings,
        ...command.preferenceSettings,
      };
    }

    await this.workflowOverrideRepository.update(
      {
        _environmentId: command.environmentId,
        _id: currentOverrideEntity._id,
      },
      {
        $set: updatePayload,
      }
    );

    return { ...currentOverrideEntity, ...updatePayload };
  }

  private async extractEntities(
    command: UpdateWorkflowOverrideCommand
  ): Promise<{ tenant: TenantEntity; workflow: NotificationTemplateEntity }> {
    const tenant = await this.tenantRepository.findOne({
      _environmentId: command.environmentId,
      _id: command._tenantId,
    });

    if (!tenant) {
      throw new NotFoundException(`Tenant with id ${command._tenantId} is not found`);
    }

    const workflow = await this.notificationTemplateRepository.findOne({
      _environmentId: command.environmentId,
      _id: command._workflowId,
    });

    if (!workflow) {
      throw new NotFoundException(`Workflow with id ${command._workflowId} is not found`);
    }

    return { tenant, workflow };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateWorkflowOverride

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/notification-template.controller.ts
Tamaño: 9088 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  Body,
  ClassSerializerInterceptor,
  Controller,
  Delete,
  Get,
  Param,
  Post,
  Put,
  Query,
  UseGuards,
  UseInterceptors,
} from '@nestjs/common';
import { ApiExcludeController, ApiOperation, ApiTags } from '@nestjs/swagger';
import {
  buildWorkflowPreferencesFromPreferenceChannels,
  DEFAULT_WORKFLOW_PREFERENCES,
  ResourceOriginEnum,
  ResourceTypeEnum,
  UserSessionData,
} from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { ExternalApiAccessible } from '../auth/framework/external-api.decorator';
import { RootEnvironmentGuard } from '../auth/framework/root-environment-guard.service';
import { DataBooleanDto } from '../shared/dtos/data-wrapper-dto';
import { ApiCommonResponses, ApiOkResponse, ApiResponse } from '../shared/framework/response.decorator';
import { UserSession } from '../shared/framework/user.decorator';
import { ChangeWorkflowStatusRequestDto, CreateWorkflowRequestDto, UpdateWorkflowRequestDto } from './dtos';
import { WorkflowResponse } from './dtos/workflow-response.dto';
import { WorkflowsResponseDto } from './dtos/workflows.response.dto';
import { WorkflowsRequestDto } from './dtos/workflows-request.dto';
import { CreateWorkflowQuery } from './queries';
import { ChangeTemplateActiveStatusCommand } from './usecases/change-template-active-status/change-template-active-status.command';
import { ChangeTemplateActiveStatus } from './usecases/change-template-active-status/change-template-active-status.usecase';
import { CreateWorkflowCommand } from './usecases/create-workflow/create-workflow.command';
import { CreateWorkflow } from './usecases/create-workflow/create-workflow.usecase';
import { DeleteNotificationTemplateCommand } from './usecases/delete-notification-template/delete-notification-template.command';
import { DeleteNotificationTemplate } from './usecases/delete-notification-template/delete-notification-template.usecase';
import { GetNotificationTemplateCommand } from './usecases/get-notification-template/get-notification-template.command';
import { GetNotificationTemplate } from './usecases/get-notification-template/get-notification-template.usecase';
import { GetNotificationTemplatesCommand } from './usecases/get-notification-templates/get-notification-templates.command';
import { GetNotificationTemplates } from './usecases/get-notification-templates/get-notification-templates.usecase';
import { UpdateWorkflowCommand } from './usecases/update-workflow/update-workflow.command';
import { UpdateWorkflow } from './usecases/update-workflow/update-workflow.usecase';

/**
 * @deprecated use controller in /workflows directory
 */

@ApiCommonResponses()
@ApiExcludeController()
@Controller('/notification-templates')
@UseInterceptors(ClassSerializerInterceptor)
@RequireAuthentication()
@ApiTags('Notification Templates')
export class NotificationTemplateController {
  constructor(
    private createWorkflowUsecase: CreateWorkflow,
    private updateWorkflowUsecase: UpdateWorkflow,
    private getNotificationTemplateUsecase: GetNotificationTemplate,
    private getNotificationTemplatesUsecase: GetNotificationTemplates,
    private deleteTemplateByIdUsecase: DeleteNotificationTemplate,
    private changeTemplateActiveStatusUsecase: ChangeTemplateActiveStatus
  ) {}

  @Get('')
  @ApiResponse(WorkflowResponse)
  @ApiOperation({
    summary: 'Get Notification templates',
    description: `Notification templates have been renamed to Workflows, Please use the new workflows controller`,
    deprecated: true,
  })
  @ExternalApiAccessible()
  getNotificationTemplates(
    @UserSession() user: UserSessionData,
    @Query() queryParams: WorkflowsRequestDto
  ): Promise<WorkflowsResponseDto> {
    return this.getNotificationTemplatesUsecase.execute(
      GetNotificationTemplatesCommand.create({
        organizationId: user.organizationId,
        userId: user._id,
        environmentId: user.environmentId,
        page: queryParams.page,
        limit: queryParams.limit,
        query: queryParams.query,
      })
    );
  }

  @Put('/:templateId')
  @ApiResponse(WorkflowResponse)
  @ApiOperation({
    summary: 'Update Notification template',
    description: `Notification templates have been renamed to Workflows, Please use the new workflows controller`,
    deprecated: true,
  })
  @ExternalApiAccessible()
  async updateTemplateById(
    @UserSession() user: UserSessionData,
    @Param('templateId') templateId: string,
    @Body() body: UpdateWorkflowRequestDto
  ): Promise<WorkflowResponse> {
    return await this.updateWorkflowUsecase.execute(
      UpdateWorkflowCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
        id: templateId,
        name: body.name,
        tags: body.tags,
        description: body.description,
        workflowId: body.identifier,
        critical: body.critical,
        defaultPreferences: DEFAULT_WORKFLOW_PREFERENCES,
        userPreferences:
          body.preferenceSettings &&
          buildWorkflowPreferencesFromPreferenceChannels(body.critical, body.preferenceSettings),
        steps: body.steps,
        notificationGroupId: body.notificationGroupId,
        data: body.data,
        type: ResourceTypeEnum.REGULAR,
      })
    );
  }

  @Delete('/:templateId')
  @UseGuards(RootEnvironmentGuard)
  @ApiOkResponse({
    type: DataBooleanDto,
  })
  @ApiOperation({
    summary: 'Delete Notification template',
    description: `Notification templates have been renamed to Workflows, Please use the new workflows controller`,
    deprecated: true,
  })
  @ExternalApiAccessible()
  deleteTemplateById(@UserSession() user: UserSessionData, @Param('templateId') templateId: string): Promise<boolean> {
    return this.deleteTemplateByIdUsecase.execute(
      DeleteNotificationTemplateCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
        templateId,
        type: ResourceTypeEnum.REGULAR,
      })
    );
  }

  @Get('/:workflowIdOrIdentifier')
  @ApiResponse(WorkflowResponse)
  @ApiOperation({
    summary: 'Get Notification template',
    description: `Notification templates have been renamed to Workflows, Please use the new workflows controller`,
    deprecated: true,
  })
  @ExternalApiAccessible()
  getNotificationTemplateById(
    @UserSession() user: UserSessionData,
    @Param('workflowIdOrIdentifier') workflowIdOrIdentifier: string
  ): Promise<WorkflowResponse> {
    return this.getNotificationTemplateUsecase.execute(
      GetNotificationTemplateCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
        workflowIdOrIdentifier,
      })
    );
  }

  @Post('')
  @ExternalApiAccessible()
  @UseGuards(RootEnvironmentGuard)
  @ApiResponse(WorkflowResponse, 201)
  @ApiOperation({
    summary: 'Create Notification template',
    description: `Notification templates have been renamed to Workflows, Please use the new workflows controller`,
    deprecated: true,
  })
  create(
    @UserSession() user: UserSessionData,
    @Query() query: CreateWorkflowQuery,
    @Body() body: CreateWorkflowRequestDto
  ): Promise<WorkflowResponse> {
    return this.createWorkflowUsecase.execute(
      CreateWorkflowCommand.create({
        organizationId: user.organizationId,
        userId: user._id,
        environmentId: user.environmentId,
        name: body.name,
        tags: body.tags,
        description: body.description,
        steps: body.steps,
        notificationGroupId: body.notificationGroupId,
        notificationGroup: body.notificationGroup,
        active: body.active ?? false,
        draft: !body.active,
        critical: body.critical ?? false,
        defaultPreferences: DEFAULT_WORKFLOW_PREFERENCES,
        userPreferences:
          body.preferenceSettings &&
          buildWorkflowPreferencesFromPreferenceChannels(body.critical, body.preferenceSettings),
        blueprintId: body.blueprintId,
        data: body.data,
        __source: query?.__source,
        type: ResourceTypeEnum.REGULAR,
        origin: ResourceOriginEnum.NOVU_CLOUD,
      })
    );
  }

  @Put('/:templateId/status')
  @UseGuards(RootEnvironmentGuard)
  @ApiResponse(WorkflowResponse)
  @ApiOperation({
    summary: 'Update Notification template status',
    description: `Notification templates have been renamed to Workflows, Please use the new workflows controller`,
    deprecated: true,
  })
  @ExternalApiAccessible()
  changeActiveStatus(
    @UserSession() user: UserSessionData,
    @Body() body: ChangeWorkflowStatusRequestDto,
    @Param('templateId') templateId: string
  ): Promise<WorkflowResponse> {
    return this.changeTemplateActiveStatusUsecase.execute(
      ChangeTemplateActiveStatusCommand.create({
        organizationId: user.organizationId,
        userId: user._id,
        environmentId: user.environmentId,
        active: body.active,
        templateId,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class NotificationTemplateController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/workflow-v1.controller.ts
Tamaño: 9577 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  Body,
  ClassSerializerInterceptor,
  Controller,
  Delete,
  Get,
  Param,
  Post,
  Put,
  Query,
  UseGuards,
  UseInterceptors,
} from '@nestjs/common';
import { ApiOperation, ApiTags } from '@nestjs/swagger';
import { ApiExcludeController } from '@nestjs/swagger/dist/decorators/api-exclude-controller.decorator';
import {
  buildWorkflowPreferencesFromPreferenceChannels,
  DEFAULT_WORKFLOW_PREFERENCES,
  ResourceOriginEnum,
  ResourceTypeEnum,
  UserSessionData,
} from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { ExternalApiAccessible } from '../auth/framework/external-api.decorator';
import { RootEnvironmentGuard } from '../auth/framework/root-environment-guard.service';
import { DataBooleanDto } from '../shared/dtos/data-wrapper-dto';
import { ApiOkResponse, ApiResponse } from '../shared/framework/response.decorator';
import { SdkGroupName } from '../shared/framework/swagger/sdk.decorators';
import { UserSession } from '../shared/framework/user.decorator';
import {
  ChangeWorkflowStatusRequestDto,
  CreateWorkflowRequestDto,
  UpdateWorkflowRequestDto,
  VariablesResponseDto,
} from './dtos';
import { WorkflowResponse } from './dtos/workflow-response.dto';
import { WorkflowsResponseDto } from './dtos/workflows.response.dto';
import { WorkflowsRequestDto } from './dtos/workflows-request.dto';
import { CreateWorkflowQuery } from './queries';
import { ChangeTemplateActiveStatusCommand } from './usecases/change-template-active-status/change-template-active-status.command';
import { ChangeTemplateActiveStatus } from './usecases/change-template-active-status/change-template-active-status.usecase';
import { CreateWorkflowCommand } from './usecases/create-workflow/create-workflow.command';
import { CreateWorkflow } from './usecases/create-workflow/create-workflow.usecase';
import { DeleteNotificationTemplateCommand } from './usecases/delete-notification-template/delete-notification-template.command';
import { DeleteNotificationTemplate } from './usecases/delete-notification-template/delete-notification-template.usecase';
import { GetNotificationTemplateCommand } from './usecases/get-notification-template/get-notification-template.command';
import { GetNotificationTemplate } from './usecases/get-notification-template/get-notification-template.usecase';
import { GetNotificationTemplatesCommand } from './usecases/get-notification-templates/get-notification-templates.command';
import { GetNotificationTemplates } from './usecases/get-notification-templates/get-notification-templates.usecase';
import { GetWorkflowVariablesCommand } from './usecases/get-workflow-variables/get-workflow-variables.command';
import { GetWorkflowVariables } from './usecases/get-workflow-variables/get-workflow-variables.usecase';
import { UpdateWorkflowCommand } from './usecases/update-workflow/update-workflow.command';
import { UpdateWorkflow } from './usecases/update-workflow/update-workflow.usecase';

/**
 * @deprecated use controllers in /workflows directory
 */
@ApiExcludeController()
@Controller('/workflows')
@UseInterceptors(ClassSerializerInterceptor)
@RequireAuthentication()
@ApiTags('Workflows')
export class WorkflowControllerV1 {
  constructor(
    private createWorkflowUsecase: CreateWorkflow,
    private updateWorkflowByIdUsecase: UpdateWorkflow,
    private getWorkflowsUsecase: GetNotificationTemplates,
    private getWorkflowUsecase: GetNotificationTemplate,
    private getWorkflowVariablesUsecase: GetWorkflowVariables,
    private deleteWorkflowByIdUsecase: DeleteNotificationTemplate,
    private changeWorkflowActiveStatusUsecase: ChangeTemplateActiveStatus
  ) {}

  @Get('')
  @ApiResponse(WorkflowsResponseDto)
  @ApiOperation({
    summary: 'Get workflows',
    description: `Workflows were previously named notification templates`,
  })
  @ExternalApiAccessible()
  listWorkflows(
    @UserSession() user: UserSessionData,
    @Query() queryParams: WorkflowsRequestDto
  ): Promise<WorkflowsResponseDto> {
    return this.getWorkflowsUsecase.execute(
      GetNotificationTemplatesCommand.create({
        organizationId: user.organizationId,
        userId: user._id,
        environmentId: user.environmentId,
        page: queryParams.page,
        limit: queryParams.limit,
        query: queryParams.query,
      })
    );
  }

  @Put('/:workflowId')
  @ApiResponse(WorkflowResponse)
  @ApiOperation({
    summary: 'Update workflow',
    description: `Workflow was previously named notification template`,
  })
  @ExternalApiAccessible()
  async updateWorkflowById(
    @UserSession() user: UserSessionData,
    @Param('workflowId') workflowId: string,
    @Body() body: UpdateWorkflowRequestDto
  ): Promise<WorkflowResponse> {
    return await this.updateWorkflowByIdUsecase.execute(
      UpdateWorkflowCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
        id: workflowId,
        name: body.name,
        tags: body.tags,
        description: body.description,
        workflowId: body.identifier,
        critical: body.critical,
        defaultPreferences: DEFAULT_WORKFLOW_PREFERENCES,
        userPreferences:
          body.preferenceSettings &&
          buildWorkflowPreferencesFromPreferenceChannels(body.critical, body.preferenceSettings),
        steps: body.steps,
        notificationGroupId: body.notificationGroupId,
        data: body.data,
        type: ResourceTypeEnum.REGULAR,
      })
    );
  }

  @Delete('/:workflowId')
  @UseGuards(RootEnvironmentGuard)
  @ApiOkResponse({
    type: DataBooleanDto,
  })
  @ApiOperation({
    summary: 'Delete workflow',
    description: `Workflow was previously named notification template`,
  })
  @ExternalApiAccessible()
  deleteWorkflowById(@UserSession() user: UserSessionData, @Param('workflowId') workflowId: string): Promise<boolean> {
    return this.deleteWorkflowByIdUsecase.execute(
      DeleteNotificationTemplateCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
        templateId: workflowId,
        type: ResourceTypeEnum.REGULAR,
      })
    );
  }

  @Get('/variables')
  @ApiResponse(VariablesResponseDto)
  @ApiOperation({
    summary: 'Get available variables',
    description: 'Get the variables that can be used in the workflow',
  })
  @ExternalApiAccessible()
  @SdkGroupName('Workflows.Variables')
  getWorkflowVariables(@UserSession() user: UserSessionData): Promise<VariablesResponseDto> {
    return this.getWorkflowVariablesUsecase.execute(
      GetWorkflowVariablesCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
      })
    );
  }

  @Get('/:workflowId')
  @ApiResponse(WorkflowResponse)
  @ApiOperation({
    summary: 'Get workflow',
    description: `Workflow was previously named notification template`,
  })
  @ExternalApiAccessible()
  getWorkflowById(
    @UserSession() user: UserSessionData,
    @Param('workflowId') workflowId: string
  ): Promise<WorkflowResponse> {
    return this.getWorkflowUsecase.execute(
      GetNotificationTemplateCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
        workflowIdOrIdentifier: workflowId,
      })
    );
  }

  @Post('')
  @ExternalApiAccessible()
  @UseGuards(RootEnvironmentGuard)
  @ApiResponse(WorkflowResponse, 201)
  @ApiOperation({
    summary: 'Create workflow',
    description: `Workflow was previously named notification template`,
  })
  create(
    @UserSession() user: UserSessionData,
    @Query() query: CreateWorkflowQuery,
    @Body() body: CreateWorkflowRequestDto
  ): Promise<WorkflowResponse> {
    return this.createWorkflowUsecase.execute(
      CreateWorkflowCommand.create({
        organizationId: user.organizationId,
        userId: user._id,
        environmentId: user.environmentId,
        name: body.name,
        tags: body.tags,
        description: body.description,
        steps: body.steps,
        notificationGroupId: body.notificationGroupId,
        notificationGroup: body.notificationGroup,
        active: body.active ?? false,
        draft: !body.active,
        critical: body.critical ?? false,
        defaultPreferences: DEFAULT_WORKFLOW_PREFERENCES,
        userPreferences:
          body.preferenceSettings &&
          buildWorkflowPreferencesFromPreferenceChannels(body.critical, body.preferenceSettings),
        blueprintId: body.blueprintId,
        data: body.data,
        __source: query?.__source,
        type: ResourceTypeEnum.REGULAR,
        origin: ResourceOriginEnum.NOVU_CLOUD_V1,
      })
    );
  }

  @Put('/:workflowId/status')
  @UseGuards(RootEnvironmentGuard)
  @ApiResponse(WorkflowResponse)
  @ApiOperation({
    summary: 'Update workflow status',
    description: `Workflow was previously named notification template`,
  })
  @ExternalApiAccessible()
  @SdkGroupName('Workflows.Status')
  updateActiveStatus(
    @UserSession() user: UserSessionData,
    @Body() body: ChangeWorkflowStatusRequestDto,
    @Param('workflowId') workflowId: string
  ): Promise<WorkflowResponse> {
    return this.changeWorkflowActiveStatusUsecase.execute(
      ChangeTemplateActiveStatusCommand.create({
        organizationId: user.organizationId,
        userId: user._id,
        environmentId: user.environmentId,
        active: body.active,
        templateId: workflowId,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class WorkflowControllerV1

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/workflow-v1.module.ts
Tamaño: 1183 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { MiddlewareConsumer, Module, NestModule } from '@nestjs/common';
import { AuthModule } from '../auth/auth.module';
import { ChangeModule } from '../change/change.module';
import { IntegrationModule } from '../integrations/integrations.module';
import { MessageTemplateModule } from '../message-template/message-template.module';
import { OutboundWebhooksModule } from '../outbound-webhooks/outbound-webhooks.module';
import { PreferencesModule } from '../preferences';
import { SharedModule } from '../shared/shared.module';
import { NotificationTemplateController } from './notification-template.controller';
import { USE_CASES } from './usecases';
import { WorkflowControllerV1 } from './workflow-v1.controller';

const MODULES = [
  SharedModule,
  MessageTemplateModule,
  ChangeModule,
  AuthModule,
  IntegrationModule,
  PreferencesModule,
  OutboundWebhooksModule.forRoot(),
];

@Module({
  imports: MODULES,
  controllers: [NotificationTemplateController, WorkflowControllerV1],
  providers: [...USE_CASES],
  exports: [...USE_CASES],
})
export class WorkflowModuleV1 implements NestModule {
  configure(consumer: MiddlewareConsumer): MiddlewareConsumer | void {}
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class WorkflowModuleV1

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/dtos/change-workflow-status-request.dto.ts
Tamaño: 275 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IsBoolean, IsDefined } from 'class-validator';

/**
 * @deprecated use dto's in /workflows directory
 */
export class ChangeWorkflowStatusRequestDto {
  @ApiProperty()
  @IsDefined()
  @IsBoolean()
  active: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ChangeWorkflowStatusRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/dtos/create-workflow.request.dto.ts
Tamaño: 1697 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { CustomDataType, ICreateWorkflowDto, INotificationGroup, IPreferenceChannels } from '@novu/shared';
import { IsArray, IsBoolean, IsDefined, IsOptional, IsString, MaxLength, ValidateNested } from 'class-validator';
import { NotificationStepDto } from '../../shared/dtos/notification-step-dto';
import { SubscriberPreferenceChannels } from '../../shared/dtos/preference-channels';

/**
 * @deprecated use dto's in /workflows directory
 */

export class CreateWorkflowRequestDto implements ICreateWorkflowDto {
  @ApiProperty()
  @IsString()
  @IsDefined()
  name: string;

  @ApiProperty()
  @IsString()
  @IsDefined({
    message: 'Notification group must be provided ',
  })
  notificationGroupId: string;

  @ApiProperty()
  @IsOptional()
  notificationGroup?: INotificationGroup;

  @ApiPropertyOptional()
  @IsOptional()
  @IsArray()
  tags: string[];

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  @MaxLength(1000)
  description: string;

  @ApiProperty({
    type: [NotificationStepDto],
  })
  @IsDefined()
  @IsArray()
  @ValidateNested()
  steps: NotificationStepDto[];

  @ApiPropertyOptional()
  @IsBoolean()
  @IsOptional()
  active?: boolean;

  @ApiPropertyOptional({ deprecated: true })
  @IsBoolean()
  @IsOptional()
  draft?: boolean;

  @ApiPropertyOptional()
  @IsBoolean()
  @IsOptional()
  critical?: boolean;

  @ApiPropertyOptional({
    type: SubscriberPreferenceChannels,
  })
  @IsOptional()
  preferenceSettings?: IPreferenceChannels;

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  blueprintId?: string;

  @ApiPropertyOptional()
  @IsOptional()
  data?: CustomDataType;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateWorkflowRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/dtos/get-workflow-with-preferences.dto.ts
Tamaño: 287 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { NotificationTemplateEntity } from '@novu/dal';
import { WorkflowPreferences } from '@novu/shared';

export class WorkflowWithPreferencesResponseDto extends NotificationTemplateEntity {
  userPreferences: WorkflowPreferences | null;

  defaultPreferences: WorkflowPreferences;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class WorkflowWithPreferencesResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/dtos/index.ts
Tamaño: 190 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './change-workflow-status-request.dto';
export * from './create-workflow.request.dto';
export * from './update-workflow-request.dto';
export * from './variables.response.dto';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/dtos/update-workflow-request.dto.ts
Tamaño: 1284 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { CustomDataType, IPreferenceChannels, IUpdateWorkflowDto } from '@novu/shared';
import { IsArray, IsMongoId, IsOptional, IsString, MaxLength, ValidateNested } from 'class-validator';
import { NotificationStepDto } from '../../shared/dtos/notification-step-dto';
import { SubscriberPreferenceChannels } from '../../shared/dtos/preference-channels';

/**
 * @deprecated use dto's in /workflows directory
 */

export class UpdateWorkflowRequestDto implements IUpdateWorkflowDto {
  @ApiProperty()
  @IsString()
  @IsOptional()
  name: string;

  @ApiPropertyOptional()
  @IsArray()
  @IsOptional()
  tags: string[];

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  @MaxLength(300)
  description: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  identifier?: string;

  @ApiPropertyOptional()
  @IsArray()
  @IsOptional()
  @ValidateNested()
  steps: NotificationStepDto[];

  @ApiProperty()
  @IsOptional()
  @IsMongoId()
  notificationGroupId: string;

  @ApiPropertyOptional()
  critical?: boolean;

  @ApiPropertyOptional({
    type: SubscriberPreferenceChannels,
  })
  preferenceSettings?: IPreferenceChannels;

  @ApiPropertyOptional()
  @IsOptional()
  data?: CustomDataType;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateWorkflowRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/dtos/variables.response.dto.ts
Tamaño: 247 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';

/**
 * @deprecated use dto's in /workflows directory
 */

export class VariablesResponseDto {
  @ApiProperty()
  translations: Record<string, any>;

  @ApiProperty()
  system: Record<string, any>;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class VariablesResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/dtos/workflow-response.dto.ts
Tamaño: 2396 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiExtraModels, ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { CustomDataType, INotificationTemplate, TriggerTypeEnum, WorkflowIntegrationStatus } from '@novu/shared';
import { IsOptional } from 'class-validator';

import { NotificationStepDto } from '../../shared/dtos/notification-step-dto';
import { SubscriberPreferenceChannels } from '../../shared/dtos/preference-channels';

/**
 * @deprecated use dto's in /workflows directory
 */

export class NotificationGroup {
  @ApiPropertyOptional()
  _id?: string;

  @ApiProperty()
  name: string;

  @ApiProperty()
  _environmentId: string;

  @ApiProperty()
  _organizationId: string;

  @ApiPropertyOptional()
  _parentId?: string;
}

export class NotificationTriggerVariable {
  name: string;
}

export class NotificationTrigger {
  @ApiProperty({
    enum: TriggerTypeEnum,
  })
  type: TriggerTypeEnum;

  @ApiProperty()
  identifier: string;

  @ApiProperty({
    type: [NotificationTriggerVariable],
  })
  variables: NotificationTriggerVariable[];

  @ApiProperty({
    type: [NotificationTriggerVariable],
  })
  subscriberVariables?: NotificationTriggerVariable[];
}

@ApiExtraModels(NotificationGroup)
export class WorkflowResponse implements INotificationTemplate {
  @ApiPropertyOptional()
  _id?: string;

  @ApiProperty()
  name: string;

  @ApiProperty()
  description: string;

  @ApiProperty()
  active: boolean;

  @ApiProperty()
  draft: boolean;

  @ApiProperty({
    type: SubscriberPreferenceChannels,
  })
  preferenceSettings: SubscriberPreferenceChannels;

  @ApiProperty()
  critical: boolean;

  @ApiProperty()
  tags: string[];

  @ApiProperty({
    type: [NotificationStepDto],
  })
  steps: NotificationStepDto[];

  @ApiProperty()
  _organizationId: string;

  @ApiProperty()
  _creatorId: string;

  @ApiProperty()
  _environmentId: string;

  @ApiProperty({
    type: [NotificationTrigger],
  })
  triggers: NotificationTrigger[];

  @ApiProperty()
  _notificationGroupId: string;

  @ApiPropertyOptional()
  _parentId?: string;

  @ApiProperty()
  deleted: boolean;

  @ApiProperty()
  deletedAt: string;

  @ApiProperty()
  deletedBy: string;

  @ApiPropertyOptional({
    type: NotificationGroup,
  })
  readonly notificationGroup?: NotificationGroup;

  @ApiPropertyOptional()
  @IsOptional()
  data?: CustomDataType;

  workflowIntegrationStatus?: WorkflowIntegrationStatus;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class NotificationGroup
- export class NotificationTriggerVariable
- export class NotificationTrigger
- export class WorkflowResponse

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/dtos/workflows-request.dto.ts
Tamaño: 391 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { PaginationWithFiltersRequestDto } from '../../shared/dtos/pagination-with-filters-request';

/**
 * @deprecated use dto's in /workflows directory
 */

export class WorkflowsRequestDto extends PaginationWithFiltersRequestDto({
  defaultLimit: 10,
  maxLimit: 100,
  queryDescription: 'It allows filtering based on either the name or trigger identifier of the workflow items.',
}) {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class WorkflowsRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/dtos/workflows.response.dto.ts
Tamaño: 361 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { WorkflowResponse } from './workflow-response.dto';

/**
 * @deprecated use dto's in /workflows directory
 */

export class WorkflowsResponseDto {
  @ApiProperty()
  totalCount: number;

  @ApiProperty()
  data: WorkflowResponse[];

  @ApiProperty()
  pageSize: number;

  @ApiProperty()
  page: number;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class WorkflowsResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/e2e/change-template-status.e2e.ts
Tamaño: 1370 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { NotificationTemplateRepository } from '@novu/dal';
import { NotificationTemplateService, UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Change workflow status by id - /workflows/:workflowId/status (PUT) #novu-v0', async () => {
  let session: UserSession;
  const notificationTemplateRepository = new NotificationTemplateRepository();

  before(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should change the status from active false to active true', async () => {
    const notificationTemplateService = new NotificationTemplateService(
      session.user._id,
      session.organization._id,
      session.environment._id
    );
    const template = await notificationTemplateService.createTemplate({
      active: false,
      draft: true,
    });
    const beforeChange = await notificationTemplateRepository.findById(template._id, template._environmentId);

    expect(beforeChange?.active).to.equal(false);
    expect(beforeChange?.draft).to.equal(true);
    const { body } = await session.testAgent.put(`/v1/workflows/${template._id}/status`).send({
      active: true,
    });
    const found = await notificationTemplateRepository.findById(template._id, template._environmentId);

    expect(found?.active).to.equal(true);
    expect(found?.draft).to.equal(false);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - notificationTemplateRepository(new NotificationTemplateRepository();

  before(async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('should change the status from active...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/e2e/create-notification-templates.e2e.ts
Tamaño: 33200 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  ChangeRepository,
  CommunityOrganizationRepository,
  EnvironmentRepository,
  MessageTemplateRepository,
  NotificationTemplateEntity,
  NotificationTemplateRepository,
  OrganizationRepository,
  SubscriberEntity,
} from '@novu/dal';
import {
  ChangeEntityTypeEnum,
  ChannelCTATypeEnum,
  ChannelTypeEnum,
  EmailBlockTypeEnum,
  EmailProviderIdEnum,
  FieldLogicalOperatorEnum,
  FieldOperatorEnum,
  FilterPartTypeEnum,
  IFieldFilterPart,
  INotificationTemplate,
  INotificationTemplateStep,
  isClerkEnabled,
  ResourceTypeEnum,
  StepTypeEnum,
  TriggerTypeEnum,
} from '@novu/shared';
import { SubscribersService, testServer, UserSession } from '@novu/testing';
import axios from 'axios';
import { expect } from 'chai';
import { isSameDay } from 'date-fns';
import { CreateWorkflowRequestDto } from '../dtos';

describe('Create Workflow - /workflows (POST) #novu-v0', async () => {
  let session: UserSession;
  const changeRepository: ChangeRepository = new ChangeRepository();
  const notificationTemplateRepository: NotificationTemplateRepository = new NotificationTemplateRepository();
  const messageTemplateRepository: MessageTemplateRepository = new MessageTemplateRepository();
  const environmentRepository: EnvironmentRepository = new EnvironmentRepository();
  const axiosInstance = axios.create();

  let subscriber: SubscriberEntity;
  let subscriberService: SubscribersService;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    subscriberService = new SubscribersService(session.organization._id, session.environment._id);
    subscriber = await subscriberService.createSubscriber();
  });

  it('should be able to create a notification with the API Key', async () => {
    const templateBody: Partial<CreateWorkflowRequestDto> = {
      name: 'test api template',
      description: 'This is a test description',
      tags: ['test-tag-api'],
      notificationGroupId: session.notificationGroups[0]._id,
      steps: [],
    };

    const response = await axiosInstance.post(`${session.serverUrl}/v1/workflows`, templateBody, {
      headers: {
        authorization: `ApiKey ${session.apiKey}`,
      },
    });

    expect(response.data.data.name).to.equal(templateBody.name);
  });

  it('should create email template', async () => {
    const defaultMessageIsActive = true;

    const templateRequestPayload: Partial<CreateWorkflowRequestDto> = {
      name: 'test email template',
      description: 'This is a test description',
      tags: ['test-tag'],
      notificationGroupId: session.notificationGroups[0]._id,
      steps: [
        {
          template: {
            name: 'Message Name',
            subject: 'Test email subject',
            preheader: 'Test email preheader',
            senderName: 'Test email sender name',
            content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a sample text block' }],
            type: StepTypeEnum.EMAIL,
          },
          filters: [
            {
              isNegated: false,
              type: 'GROUP',
              value: FieldLogicalOperatorEnum.AND,
              children: [
                {
                  on: FilterPartTypeEnum.SUBSCRIBER,
                  field: 'firstName',
                  value: 'test value',
                  operator: FieldOperatorEnum.EQUAL,
                },
              ],
            },
          ],
          variants: [
            {
              template: {
                name: 'Better Message Template',
                subject: 'Better subject',
                preheader: 'Better pre header',
                senderName: 'Better pre sender name',
                content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a sample of Better text block' }],
                type: StepTypeEnum.EMAIL,
              },
              active: defaultMessageIsActive,
              filters: [
                {
                  isNegated: false,
                  type: 'GROUP',
                  value: FieldLogicalOperatorEnum.AND,
                  children: [
                    {
                      on: FilterPartTypeEnum.TENANT,
                      field: 'name',
                      value: 'Titans',
                      operator: FieldOperatorEnum.EQUAL,
                    },
                  ],
                },
              ],
            },
          ],
        },
      ],
    };

    const { body } = await session.testAgent.post(`/v1/workflows`).send(templateRequestPayload);

    expect(body.data).to.be.ok;
    const templateRequestResult: INotificationTemplate = body.data;

    expect(templateRequestResult._notificationGroupId).to.equal(templateRequestPayload.notificationGroupId);
    const message = templateRequestResult.steps[0] as INotificationTemplateStep;

    const messageRequest = templateRequestPayload?.steps ? templateRequestPayload?.steps[0] : null;
    const filtersTest = messageRequest?.filters ? messageRequest.filters[0] : null;

    const children: IFieldFilterPart = filtersTest?.children[0] as IFieldFilterPart;
    const template = message?.template;

    expect(message?.template?.name).to.equal(`${messageRequest?.template?.name}`);
    expect(message?.template?.active).to.equal(defaultMessageIsActive);
    expect(message?.template?.subject).to.equal(`${messageRequest?.template?.subject}`);
    expect(message?.template?.preheader).to.equal(`${messageRequest?.template?.preheader}`);
    expect(message?.template?.senderName).to.equal(`${messageRequest?.template?.senderName}`);

    const filters = message?.filters ? message?.filters[0] : null;
    expect(filters?.type).to.equal(filtersTest?.type);
    expect(filters?.children.length).to.equal(filtersTest?.children?.length);

    expect(children.value).to.equal(children.value);
    expect(children.operator).to.equal(children.operator);
    expect(templateRequestResult.tags[0]).to.equal('test-tag');

    const variantRequest = messageRequest?.variants ? messageRequest?.variants[0] : null;
    const variantResult = (templateRequestResult.steps[0] as INotificationTemplateStep)?.variants
      ? (templateRequestResult.steps as INotificationTemplateStep)[0]?.variants[0]
      : null;
    expect(variantResult?.template?.name).to.equal(variantRequest?.template?.name);
    expect(variantResult?.template?.active).to.equal(variantRequest?.active);
    expect(variantResult?.template?.subject).to.equal(variantRequest?.template?.subject);
    expect(variantResult?.template?.preheader).to.equal(variantRequest?.template?.preheader);
    expect(variantResult?.template?.senderName).to.equal(variantRequest?.template?.senderName);

    if (Array.isArray(message?.template?.content) && Array.isArray(messageRequest?.template?.content)) {
      expect(message?.template?.content[0].type).to.equal(messageRequest?.template?.content[0].type);
    } else {
      throw new Error('content must be an array');
    }

    let change = await changeRepository.findOne({
      _environmentId: session.environment._id,
      _entityId: message._templateId,
    });
    await session.testAgent.post(`/v1/changes/${change?._id}/apply`);

    change = await changeRepository.findOne({
      _environmentId: session.environment._id,
      _entityId: templateRequestResult._id,
    });
    await session.testAgent.post(`/v1/changes/${change?._id}/apply`);

    const prodEnv = await getProductionEnvironment();

    if (!prodEnv) throw new Error('prodEnv was not found');

    const prodVersionNotification = await notificationTemplateRepository.findOne({
      _environmentId: prodEnv._id,
      _parentId: templateRequestResult._id,
    });

    expect(prodVersionNotification?.tags[0]).to.equal(templateRequestResult.tags[0]);
    expect(prodVersionNotification?.steps.length).to.equal(templateRequestResult.steps.length);
    expect(prodVersionNotification?.triggers[0].type).to.equal(templateRequestResult.triggers[0].type);
    expect(prodVersionNotification?.triggers[0].identifier).to.equal(templateRequestResult.triggers[0].identifier);
    expect(prodVersionNotification?.active).to.equal(templateRequestResult.active);
    expect(prodVersionNotification?.draft).to.equal(templateRequestResult.draft);
    expect(prodVersionNotification?.name).to.equal(templateRequestResult.name);
    expect(prodVersionNotification?.description).to.equal(templateRequestResult.description);

    const prodVersionMessage = await messageTemplateRepository.findOne({
      _environmentId: prodEnv._id,
      _parentId: message._templateId,
    });

    expect(message?.template?.name).to.equal(prodVersionMessage?.name);
    expect(message?.template?.subject).to.equal(prodVersionMessage?.subject);
    expect(message?.template?.type).to.equal(prodVersionMessage?.type);
    expect(message?.template?.content).to.deep.equal(prodVersionMessage?.content);
    expect(message?.template?.active).to.equal(prodVersionMessage?.active);
    expect(message?.template?.preheader).to.equal(prodVersionMessage?.preheader);
    expect(message?.template?.senderName).to.equal(prodVersionMessage?.senderName);

    const prodVersionVariant = await messageTemplateRepository.findOne({
      _environmentId: prodEnv._id,
      _parentId: variantResult._templateId,
    });

    expect(variantResult?.template?.name).to.equal(prodVersionVariant?.name);
    expect(variantResult?.template?.subject).to.equal(prodVersionVariant?.subject);
    expect(variantResult?.template?.type).to.equal(prodVersionVariant?.type);
    expect(variantResult?.template?.content).to.deep.equal(prodVersionVariant?.content);
    expect(variantResult?.template?.active).to.equal(prodVersionVariant?.active);
    expect(variantResult?.template?.preheader).to.equal(prodVersionVariant?.preheader);
    expect(variantResult?.template?.senderName).to.equal(prodVersionVariant?.senderName);
  });

  it('should create a valid notification', async () => {
    const testTemplate: Partial<CreateWorkflowRequestDto> = {
      name: 'test template',
      description: 'This is a test description',
      notificationGroupId: session.notificationGroups[0]._id,
      steps: [
        {
          template: {
            name: 'Message Name',
            content: 'Test Template',
            type: StepTypeEnum.IN_APP,
            cta: {
              type: ChannelCTATypeEnum.REDIRECT,
              data: {
                url: 'https://example.org/profile',
              },
            },
          },
        },
      ],
    };
    const { body } = await session.testAgent.post(`/v1/workflows`).send(testTemplate);

    expect(body.data).to.be.ok;

    const template: INotificationTemplate = body.data;

    expect(template._id).to.be.ok;
    expect(template.description).to.equal(testTemplate.description);
    expect(template.name).to.equal(testTemplate.name);
    expect(template.draft).to.equal(true);
    expect(template.active).to.equal(false);
    expect(isSameDay(new Date(template?.createdAt ? template?.createdAt : '1970'), new Date()));

    const step = template?.steps[0] as INotificationTemplateStep;
    expect(template.steps.length).to.equal(1);
    expect(step?.template?.type).to.equal(ChannelTypeEnum.IN_APP);
    expect(step?.template?.content).to.equal(testTemplate?.steps?.[0]?.template?.content);
    expect(step?.template?.cta?.data.url).to.equal(testTemplate?.steps?.[0]?.template?.cta?.data.url);
  });

  it('should create event trigger', async () => {
    const testTemplate: Partial<CreateWorkflowRequestDto> = {
      name: 'test template',
      notificationGroupId: session.notificationGroups[0]._id,
      description: 'This is a test description',
      steps: [
        {
          active: false,
          template: {
            name: 'Message Name',
            content: 'Test Template {{name}} {{lastName}}',
            type: StepTypeEnum.IN_APP,
            cta: {
              type: ChannelCTATypeEnum.REDIRECT,
              data: {
                url: 'https://example.org/profile',
              },
            },
          },
        },
      ],
    };

    const { body } = await session.testAgent.post(`/v1/workflows`).send(testTemplate);

    expect(body.data).to.be.ok;

    const template: INotificationTemplate = body.data;

    expect(template.active).to.equal(false);
    expect(template.triggers.length).to.equal(1);
    expect(template.triggers[0].identifier).to.include('test');
    expect(template.triggers[0].type).to.equal(TriggerTypeEnum.EVENT);
  });

  it('should only add shortid to trigger identifier if same identifier exists', async () => {
    const testTemplate: Partial<CreateWorkflowRequestDto> = {
      name: 'test',
      notificationGroupId: session.notificationGroups[0]._id,
      description: 'This is a test description',
      steps: [],
    };

    const { body } = await session.testAgent.post(`/v1/workflows`).send(testTemplate);

    expect(body.data).to.be.ok;
    const template: INotificationTemplate = body.data;

    expect(template.triggers[0].identifier).to.equal('test');

    const sameNameTemplate: Partial<CreateWorkflowRequestDto> = {
      name: 'test',
      notificationGroupId: session.notificationGroups[0]._id,
      description: 'This is a test description',
      steps: [],
    };
    const { body: newBody } = await session.testAgent.post(`/v1/workflows`).send(sameNameTemplate);

    expect(newBody.data).to.be.ok;
    const newTemplate: INotificationTemplate = newBody.data;

    expect(newTemplate.triggers[0].identifier).to.include('test-');
  });

  it('should add parentId to step', async () => {
    const testTemplate: Partial<CreateWorkflowRequestDto> = {
      name: 'test template',
      description: 'This is a test description',
      notificationGroupId: session.notificationGroups[0]._id,
      steps: [
        {
          template: {
            type: StepTypeEnum.IN_APP,
            content: 'Test Template',
            cta: {
              type: ChannelCTATypeEnum.REDIRECT,
              data: {
                url: 'https://example.org/profile',
              },
            },
          },
        },
        {
          template: {
            type: StepTypeEnum.IN_APP,
            content: 'Test Template',
            cta: {
              type: ChannelCTATypeEnum.REDIRECT,
              data: {
                url: 'https://example.org/profile',
              },
            },
          },
        },
      ],
    };
    const { body } = await session.testAgent.post(`/v1/workflows`).send(testTemplate);

    expect(body.data).to.be.ok;

    const template: INotificationTemplate = body.data;
    const steps = template.steps as INotificationTemplateStep[];
    expect(steps[0]._parentId).to.equal(null);
    expect(steps[0]._id).to.equal(steps[1]._parentId);
  });

  it('should use sender name in email template', async () => {
    const testTemplate: Partial<CreateWorkflowRequestDto> = {
      name: 'test email template',
      description: 'This is a test description',
      tags: ['test-tag'],
      notificationGroupId: session.notificationGroups[0]._id,
      steps: [
        {
          template: {
            name: 'Message Name',
            subject: 'Test email subject',
            preheader: 'Test email preheader',
            senderName: 'test',
            content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a sample text block' }],
            type: StepTypeEnum.EMAIL,
          },
          filters: [],
        },
      ],
    };

    const { body } = await session.testAgent.post(`/v1/workflows`).send(testTemplate);

    expect(body.data).to.be.ok;
    const template: INotificationTemplate = body.data;

    expect(template._notificationGroupId).to.equal(testTemplate.notificationGroupId);
    const message = template.steps[0] as INotificationTemplateStep;
    expect(message.template?.senderName).to.equal('test');
  });

  xit('should build factory integration', () => {
    // const instance = testServer.getService(SendMessageEmail);
    const instance: any = {};

    let result = instance.buildFactoryIntegration({
      _environmentId: '',
      _organizationId: '',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      credentials: {
        senderName: 'credentials',
      },
      active: false,
      deleted: false,
      deletedAt: '',
      deletedBy: '',
    });

    expect(result.credentials.senderName).to.equal('credentials');

    result = instance.buildFactoryIntegration(
      {
        _environmentId: '',
        _organizationId: '',
        providerId: EmailProviderIdEnum.SendGrid,
        channel: ChannelTypeEnum.EMAIL,
        credentials: {
          senderName: 'credentials',
        },
        active: false,
        deleted: false,
        deletedAt: '',
        deletedBy: '',
      },
      ''
    );
    expect(result.credentials.senderName).to.equal('credentials');

    result = instance.buildFactoryIntegration(
      {
        _environmentId: '',
        _organizationId: '',
        providerId: EmailProviderIdEnum.SendGrid,
        channel: ChannelTypeEnum.EMAIL,
        credentials: {
          senderName: 'credentials',
        },
        active: false,
        deleted: false,
        deletedAt: '',
        deletedBy: '',
      },
      'senderName'
    );

    expect(result.credentials.senderName).to.equal('senderName');
  });

  it('should not promote deleted template that is not existing in prod', async () => {
    const testTemplate: Partial<CreateWorkflowRequestDto> = {
      name: 'test email template',
      description: 'This is a test description',
      tags: ['test-tag'],
      notificationGroupId: session.notificationGroups[0]._id,
      steps: [],
    };

    const { body } = await session.testAgent.post(`/v1/workflows`).send(testTemplate);

    expect(body.data).to.be.ok;
    const template: INotificationTemplate = body.data;

    await session.testAgent.delete(`/v1/workflows/${template._id}`).send();

    const change = await changeRepository.findOne({ _environmentId: session.environment._id, _entityId: template._id });
    await session.testAgent.post(`/v1/changes/${change?._id}/apply`);

    const prodEnv = await getProductionEnvironment();

    if (!prodEnv) throw new Error('prodEnv was not found');

    const prodVersionNotification = await notificationTemplateRepository.findOne({
      _environmentId: prodEnv._id,
      _parentId: template._id,
    });

    expect(prodVersionNotification).to.equal(null);
  });

  async function getProductionEnvironment() {
    return await environmentRepository.findOne({
      _parentId: session.environment._id,
    });
  }
});

describe('Create Notification template from blueprint - /notification-templates (POST)', async () => {
  let session: UserSession;
  const notificationTemplateRepository: NotificationTemplateRepository = new NotificationTemplateRepository();
  const environmentRepository: EnvironmentRepository = new EnvironmentRepository();
  const organizationRepository: OrganizationRepository = new OrganizationRepository(
    new CommunityOrganizationRepository()
  );

  before(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should create template from blueprint', async () => {
    const prodEnv = await getProductionEnvironment();

    const { testTemplateRequestDto, testTemplate, blueprintId, createdTemplate } = await createTemplateFromBlueprint({
      session,
      notificationTemplateRepository,
      prodEnv,
    });

    expect(createdTemplate.blueprintId).to.equal(blueprintId);
    expect(testTemplateRequestDto.name).to.equal(createdTemplate.name);

    const fetchedTemplate = (await session.testAgent.get(`/v1/blueprints/${blueprintId}`).send()).body.data;

    expect(fetchedTemplate.isBlueprint).to.equal(true);
    expect(testTemplateRequestDto.name).to.equal(fetchedTemplate.name);
    expect(createdTemplate.blueprintId).to.equal(fetchedTemplate._id);

    const response = await session.testAgent.get(`/v1/blueprints/${testTemplate._id}`).send();

    expect(response.body.statusCode).to.equal(404);
  });

  it('should create notification group change from blueprint creation', async () => {
    const prodEnv = await getProductionEnvironment();

    const { blueprintId } = await buildBlueprint(session, prodEnv, notificationTemplateRepository);

    const blueprint = (await session.testAgent.get(`/v1/blueprints/${blueprintId}`).send()).body.data;

    if (isClerkEnabled()) {
      process.env.BLUEPRINT_CREATOR = session.organization._id;
    } else {
      const blueprintOrg = await organizationRepository.create({ name: 'Blueprint Org' });
      process.env.BLUEPRINT_CREATOR = blueprintOrg._id;
    }

    blueprint.notificationGroupId = blueprint._notificationGroupId;
    blueprint.notificationGroup.name = 'New Group Name';
    blueprint.blueprintId = blueprint._id;

    const noChanges = (await session.testAgent.get(`/v1/changes?promoted=false`)).body.data;
    expect(noChanges.length).to.equal(0);
    await session.testAgent.post(`/v1/workflows`).send({ ...blueprint });
    const newWorkflowChanges = (await session.testAgent.get(`/v1/changes?promoted=false`)).body.data;
    expect(newWorkflowChanges.length).to.equal(2);
    expect(newWorkflowChanges[0].type).to.equal(ChangeEntityTypeEnum.NOTIFICATION_TEMPLATE);
    expect(newWorkflowChanges[1].type).to.equal(ChangeEntityTypeEnum.NOTIFICATION_GROUP);
  });

  it('should create workflow from blueprint (full blueprint mock)', async () => {
    const createdTemplate: NotificationTemplateEntity = (
      await session.testAgent.post(`/v1/workflows`).send(blueprintTemplateMock)
    ).body.data;

    expect(createdTemplate.blueprintId).to.equal(blueprintTemplateMock.blueprintId);
    expect(createdTemplate.isBlueprint).to.equal(false);
    expect(createdTemplate.name).to.equal(blueprintTemplateMock.name);
    expect(createdTemplate.steps.length).to.equal(blueprintTemplateMock.steps.length);
    expect(createdTemplate._notificationGroupId).to.not.equal(blueprintTemplateMock.notificationGroupId);

    const inAppStep = createdTemplate.steps.find((step) => step.template?.type === StepTypeEnum.IN_APP);

    expect(inAppStep?.template?._feedId).to.be.equal(null);
  });

  async function getProductionEnvironment() {
    return await environmentRepository.findOne({
      _parentId: session.environment._id,
    });
  }
});

async function buildBlueprint(session, prodEnv, notificationTemplateRepository) {
  const testTemplateRequestDto: Partial<CreateWorkflowRequestDto> = {
    name: 'test email template',
    description: 'This is a test description',
    tags: ['test-tag'],
    notificationGroupId: session.notificationGroups[0]._id,
    steps: [
      {
        template: {
          name: 'Message Name',
          subject: 'Test email subject',
          preheader: 'Test email preheader',
          content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a sample text block' }],
          type: StepTypeEnum.EMAIL,
        },
        filters: [
          {
            isNegated: false,
            type: 'GROUP',
            value: FieldLogicalOperatorEnum.AND,
            children: [
              {
                on: FilterPartTypeEnum.SUBSCRIBER,
                field: 'firstName',
                value: 'test value',
                operator: FieldOperatorEnum.EQUAL,
              },
            ],
          },
        ],
      },
    ],
  };

  const testTemplate = (await session.testAgent.post(`/v1/workflows`).send(testTemplateRequestDto)).body.data;

  process.env.BLUEPRINT_CREATOR = session.organization._id;

  const testEnvBlueprintTemplate = (await session.testAgent.post(`/v1/workflows`).send(testTemplateRequestDto)).body
    .data;

  expect(testEnvBlueprintTemplate).to.be.ok;

  await session.applyChanges({
    enabled: false,
  });

  if (!prodEnv) throw new Error('production environment was not found');

  const blueprintId = (
    await notificationTemplateRepository.findOne({
      _environmentId: prodEnv._id,
      _parentId: testEnvBlueprintTemplate._id,
    })
  )?._id;

  if (!blueprintId) throw new Error('blueprintId was not found');

  return { testTemplateRequestDto, testTemplate, blueprintId };
}

export async function createTemplateFromBlueprint({
  session,
  notificationTemplateRepository,
  prodEnv,
  overrides = {},
}: {
  session: UserSession;
  notificationTemplateRepository: NotificationTemplateRepository;
  prodEnv;
  overrides?: Partial<CreateWorkflowRequestDto>;
}) {
  const { testTemplateRequestDto, testTemplate, blueprintId } = await buildBlueprint(
    session,
    prodEnv,
    notificationTemplateRepository
  );

  const blueprint = (await session.testAgent.get(`/v1/blueprints/${blueprintId}`).send()).body.data;

  blueprint.notificationGroupId = blueprint._notificationGroupId;
  blueprint.blueprintId = blueprint._id;

  const createdTemplate = (await session.testAgent.post(`/v1/workflows`).send({ ...blueprint })).body.data;

  return {
    testTemplateRequestDto,
    testTemplate,
    blueprintId,
    createdTemplate,
  };
}

const blueprintTemplateMock = {
  // _id: '64731d4e1084f5a48293ceab',
  blueprintId: '64731d4e1084f5a48293ceab',
  name: 'Mention in a comment',
  active: true,
  draft: false,
  critical: false,
  isBlueprint: true,
  notificationGroupId: '64731d4e1084f5a48293ce85',
  tags: [],
  triggers: [
    {
      type: 'event',
      identifier: 'fa-solid-fa-comment-mention-in-a-comment',
      variables: [
        {
          name: 'commenterName',
          type: 'String',
          _id: '65ee069a319fc6a92cf436d5',
        },
        {
          name: 'commentSnippet',
          type: 'String',
          _id: '65ee069a319fc6a92cf436d6',
        },
        {
          name: 'commentLink',
          type: 'String',
          _id: '65ee069a319fc6a92cf436d7',
        },
      ],
      reservedVariables: [],
      subscriberVariables: [
        {
          name: 'email',
          _id: '65ee069a319fc6a92cf436d4',
        },
      ],
      _id: '64731d1c1084f5a48293cd4a',
    },
  ],
  steps: [
    {
      active: true,
      shouldStopOnFail: false,
      uuid: 'b6944995-a283-46bd-b55a-18625fd1d4fd',
      name: 'In-App',
      type: ResourceTypeEnum.REGULAR,
      filters: [
        {
          children: [],
          _id: '6485b9052a50bb49867584a0',
        },
      ],
      _templateId: '6485b92e2a50bb4986758656',
      _parentId: null,
      metadata: {
        timed: {
          weekDays: [],
          monthDays: [],
        },
      },
      variants: [],
      _id: '6485b9052a50bb498675846d',
      template: {
        _id: '6485b92e2a50bb4986758656',
        type: 'in_app',
        active: true,
        subject: '',
        variables: [
          {
            name: 'commenterName',
            type: 'String',
            required: false,
            _id: '6485b9052a50bb498675846e',
          },
          {
            name: 'commentSnippet',
            type: 'String',
            required: false,
            _id: '6485b9052a50bb498675846f',
          },
        ],
        content: '{{commenterName}} has mentioned you in <b> "{{commentSnippet}}" </b>',
        contentType: 'editor',
        cta: {
          data: {
            url: '',
          },
          type: 'redirect',
        },
        _environmentId: '64731b391084f5a48293cb87',
        _organizationId: '64731b391084f5a48293cb5b',
        _creatorId: '64731b331084f5a48293cb52',
        _parentId: '6485b9052a50bb498675846d',
        _layoutId: null,
        _feedId: '64731b331084f5a48293cb52',
        feedId: '64731b331084f5a48293cb52',
        deleted: false,
        createdAt: '2023-06-11T12:08:14.446Z',
        updatedAt: '2024-03-10T19:14:45.347Z',
        __v: 0,
        actor: {
          type: 'none',
          data: null,
        },
      },
    },
    {
      active: true,
      shouldStopOnFail: false,
      uuid: '642e42b5-51e6-4d3b-8a91-067c29e902d4',
      name: 'Digest',
      type: ResourceTypeEnum.REGULAR,
      filters: [],
      _templateId: '6485b92e2a50bb4986758662',
      _parentId: '6485b9052a50bb498675846d',
      metadata: {
        amount: 30,
        unit: 'minutes',
        type: 'regular',
        backoffUnit: 'minutes',
        backoffAmount: 5,
        backoff: true,
        timed: {
          weekDays: [],
          monthDays: [],
        },
      },
      variants: [],
      _id: '6485b9052a50bb4986758479',
      template: {
        _id: '6485b92e2a50bb4986758662',
        type: 'digest',
        active: true,
        subject: '',
        variables: [],
        content: '',
        contentType: 'editor',
        _environmentId: '64731b391084f5a48293cb87',
        _organizationId: '64731b391084f5a48293cb5b',
        _creatorId: '64731b331084f5a48293cb52',
        _parentId: '6485b9052a50bb4986758479',
        _layoutId: null,
        deleted: false,
        createdAt: '2023-06-11T12:08:14.520Z',
        updatedAt: '2024-03-10T19:14:45.377Z',
        __v: 0,
      },
    },
    {
      active: true,
      replyCallback: {
        active: true,
        url: 'https://webhook.com/reply-callback',
      },
      shouldStopOnFail: false,
      uuid: '671d86ec-dc27-413c-a666-ec4aeb191691',
      name: 'Email',
      type: ResourceTypeEnum.REGULAR,
      filters: [
        {
          value: 'AND',
          children: [
            {
              operator: 'EQUAL',
              on: 'previousStep',
              step: 'b6944995-a283-46bd-b55a-18625fd1d4fd',
              stepType: 'unseen',
              _id: '6485b9052a50bb49867584a4',
            },
          ],
          _id: '6485b9052a50bb49867584a3',
        },
      ],
      _templateId: '6485b92e2a50bb4986758671',
      _parentId: '6485b9052a50bb4986758479',
      metadata: {
        timed: {
          weekDays: [],
          monthDays: [],
        },
      },
      variants: [],
      _id: '6485b9052a50bb4986758481',
      template: {
        _id: '6485b92e2a50bb4986758671',
        type: 'email',
        active: true,
        subject: '{{mentionedUser}} mention you in {{resourceName}}',
        variables: [
          {
            name: 'mentionedUser',
            type: 'String',
            required: false,
            _id: '6485b9052a50bb4986758482',
          },
          {
            name: 'resourceName',
            type: 'String',
            required: false,
            _id: '6485b9052a50bb4986758483',
          },
          {
            name: 'commentLink',
            type: 'String',
            required: false,
            _id: '6485b9052a50bb4986758484',
          },
          {
            name: 'step.digest',
            type: 'Boolean',
            required: false,
            defaultValue: true,
            _id: '6485b9052a50bb4986758485',
          },
          {
            name: 'step.events.0.mentionedUser',
            type: 'String',
            required: false,
            _id: '6485b9052a50bb4986758486',
          },
          {
            name: 'step.total_count',
            type: 'String',
            required: false,
            _id: '6485b9052a50bb4986758487',
          },
        ],
        content:
          '{{#if step.digest}}\n    {{step.events.0.mentionedUser}} and {{step.total_count}} others mentioned you in a comment. \n{{else}}\n   {{mentionedUser}} mentioned you in a comment. \n{{/if}}\n \n<br/><br/>\n\n<div style="font-family:inherit;text-align:center">\n <a href="{{commentLink}}" style="line-height:30px;display:inline-block;font-weight:400;white-space:nowrap;text-align:center;border:1px solid transparent;height:32px;padding:4px 15px;font-size:14px;border-radius:4px;color:white;background:#f47373;border-color:#f47373;text-decoration:none">\n  Reply to comment\n </a>\n</div>\n\n<br/>\n\n{{#unless step.digest}}\n  You can reply to this email, and the email contents will be posted as a comment reply to this post.\n{{/unless}}\n',
        contentType: 'customHtml',
        _environmentId: '64731b391084f5a48293cb87',
        _organizationId: '64731b391084f5a48293cb5b',
        _creatorId: '64731b331084f5a48293cb52',
        _parentId: '6485b9052a50bb4986758481',
        _layoutId: '64731d4e1084f5a48293ce8f',
        deleted: false,
        createdAt: '2023-06-11T12:08:14.551Z',
        updatedAt: '2024-03-10T19:14:45.409Z',
        __v: 0,
        preheader: '',
        senderName: '',
      },
    },
  ],
  preferenceSettings: {
    email: true,
    sms: true,
    in_app: true,
    chat: true,
    push: true,
  },
  _environmentId: '64731b391084f5a48293cb87',
  _organizationId: '64731b391084f5a48293cb5b',
  _creatorId: '64731b331084f5a48293cb52',
  _parentId: '64731d1c1084f5a48293cd49',
  deleted: false,
  createdAt: '2023-05-28T09:22:22.586Z',
  updatedAt: '2024-03-10T19:14:45.442Z',
  __v: 0,
  deletedAt: '2023-05-30T12:55:34.842Z',
  notificationGroup: {
    _id: '64731d4e1084f5a48293ce85',
    name: 'General',
    _organizationId: '64731b391084f5a48293cb5b',
    _environmentId: '64731b391084f5a48293cb87',
    _parentId: '64731b391084f5a48293cb65',
    createdAt: '2023-05-28T09:22:22.381Z',
    updatedAt: '2023-05-28T09:22:22.381Z',
    __v: 0,
  },
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getProductionEnvironment()
 - getProductionEnvironment()
 - buildBlueprint(session, prodEnv, notificationTemplateRepository)
 - createTemplateFromBlueprint({
  session,
  notificationTemplateRepository,
  prodEnv,
  overrides = {},
}: {
  session: UserSession;
  notificationTemplateRepository: NotificationTemplateRepository;
  prodEnv;
  overrides?: Partial<CreateWorkflowRequestDto>;
})
Asignaciones con arrow functions encontradas (posibles funciones):
 - axiosInstance(axios.create();

  let subscriber: SubscriberEntity;
  let subscriberService: SubscribersService;

 ...)
 - subscriber(await subscriberService.createSubscriber();
  });

  it('should be able to create a notification wit...)
 - response(await axiosInstance.post(`${session.serverUrl}/v1/workflows`, templateBody, {
      headers: {
     ...)
 - prodVersionVariant(await messageTemplateRepository.findOne({
      _environmentId: prodEnv._id,
      _parentId: varian...)
 - step(template?.steps[0] as INotificationTemplateStep;
    expect(template.steps.length).to.equal(1);
    ...)
 - INotificationTemplate(body.data;

    expect(template.active).to.equal(false);
    expect(template.triggers.length).to.equ...)
 - INotificationTemplate(newBody.data;

    expect(newTemplate.triggers[0].identifier).to.include('test-');
  });

  it('shou...)
 - steps(template.steps as INotificationTemplateStep[];
    expect(steps[0]._parentId).to.equal(null);
    ex...)
 - message(template.steps[0] as INotificationTemplateStep;
    expect(message.template?.senderName).to.equal('t...)
 - result(instance.buildFactoryIntegration(
      {
        _environmentId: '',
        _organizationId: '',
 ...)
 - prodVersionNotification(await notificationTemplateRepository.findOne({
      _environmentId: prodEnv._id,
      _parentId: t...)
 - OrganizationRepository(new OrganizationRepository(
    new CommunityOrganizationRepository()
  );

  before(async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('should create template from blueprin...)
 - response(await session.testAgent.get(`/v1/blueprints/${testTemplate._id}`).send();

    expect(response.body....)
 - promoted(false`)).body.data;
    expect(newWorkflowChanges.length).to.equal(2);
    expect(newWorkflowChanges...)
 - inAppStep(createdTemplate.steps.find((step))
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/e2e/delete-notification-template.e2e.ts
Tamaño: 9050 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  ChannelTypeEnum,
  EnvironmentRepository,
  MessageTemplateRepository,
  NotificationGroupRepository,
  NotificationTemplateRepository,
} from '@novu/dal';
import { ChannelCTATypeEnum } from '@novu/shared';
import { NotificationTemplateService, UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Delete workflow by id - /workflows/:workflowId (DELETE) #novu-v0', async () => {
  let session: UserSession;
  const notificationTemplateRepository = new NotificationTemplateRepository();
  const notificationGroupRepository: NotificationGroupRepository = new NotificationGroupRepository();
  const environmentRepository: EnvironmentRepository = new EnvironmentRepository();
  const messageTemplateRepository: MessageTemplateRepository = new MessageTemplateRepository();

  before(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should delete the workflow', async () => {
    const notificationTemplateService = new NotificationTemplateService(
      session.user._id,
      session.organization._id,
      session.environment._id
    );
    const template = await notificationTemplateService.createTemplate();

    await session.testAgent.delete(`/v1/workflows/${template._id}`).send();

    const isDeleted = !(await notificationTemplateRepository.findOne({
      _environmentId: session.environment._id,
      _id: template._id,
    }));

    expect(isDeleted).to.equal(true);

    const deletedIntegration = (
      await notificationTemplateRepository.findDeleted({ _environmentId: session.environment._id, _id: template._id })
    )[0];

    expect(deletedIntegration.deleted).to.equal(true);
  });

  it('should delete the production workflow', async () => {
    const groups = await notificationGroupRepository.find({
      _environmentId: session.environment._id,
    });

    const testTemplate = {
      name: 'test email template',
      description: 'This is a test description',
      tags: ['test-tag'],
      notificationGroupId: groups[0]._id,
      steps: [],
    };

    const { body } = await session.testAgent.post(`/v1/workflows`).send(testTemplate);
    const notificationTemplateId = body.data._id;

    await session.applyChanges({
      enabled: false,
    });

    const prodEnv = await getProductionEnvironment(session.environment._id);
    if (!prodEnv) {
      throw new Error('No env found');
    }

    const isCreated = await notificationTemplateRepository.findOne({
      _environmentId: prodEnv._id,
      _parentId: notificationTemplateId,
    });

    expect(isCreated).to.exist;

    await session.testAgent.delete(`/v1/workflows/${notificationTemplateId}`).send();

    const {
      body: { data },
    } = await session.testAgent.get(`/v1/changes?promoted=false`);

    expect(data[0].templateName).to.eq(body.data.name);

    await session.applyChanges({
      enabled: false,
    });

    const isDeleted = await notificationTemplateRepository.findOne({
      _environmentId: prodEnv._id,
      _parentId: notificationTemplateId,
    });

    expect(!isDeleted).to.equal(true);
  });

  it('should only make one change on delete', async () => {
    const groups = await notificationGroupRepository.find({
      _environmentId: session.environment._id,
    });

    const testTemplate = {
      name: 'test email template',
      description: 'This is a test description',
      tags: ['test-tag'],
      notificationGroupId: groups[0]._id,
      steps: [],
    };

    const { body } = await session.testAgent.post(`/v1/workflows`).send(testTemplate);
    const notificationTemplateId = body.data._id;

    await session.testAgent.delete(`/v1/workflows/${notificationTemplateId}`).send();

    const {
      body: { data },
    } = await session.testAgent.get(`/v1/changes?promoted=false`);

    expect(data[0].templateName).to.eq(body.data.name);
    expect(data.length).to.eq(1);
  });

  it('should not display on listing workflows', async () => {
    const notificationTemplateService = new NotificationTemplateService(
      session.user._id,
      session.organization._id,
      session.environment._id
    );

    const template1 = await notificationTemplateService.createTemplate();
    await notificationTemplateService.createTemplate();
    await notificationTemplateService.createTemplate();

    const { body: templates } = await session.testAgent.get(`/v1/workflows`);
    expect(templates.data.length).to.equal(3);

    await session.testAgent.delete(`/v1/workflows/${template1._id}`).send();

    const { body: templatesAfterDelete } = await session.testAgent.get(`/v1/workflows`);

    expect(templatesAfterDelete.data.length).to.equal(2);
  });

  it('should fail for non-existing workflow', async () => {
    const dummyId = '5f6651112efc19f33b34fc39';
    const response = await session.testAgent.delete(`/v1/workflows/${dummyId}`).send();

    expect(response.body.message).to.contains('Workflow cannot be found');
  });

  it('should delete the workflow along with the message templates', async () => {
    const notificationTemplateService = new NotificationTemplateService(
      session.user._id,
      session.organization._id,
      session.environment._id
    );
    const template = await notificationTemplateService.createTemplate();

    const messageTemplateIds = template.steps.map((step) => step._templateId);

    const messageTemplates = await messageTemplateRepository.find({
      _environmentId: session.environment._id,
      _id: { $in: messageTemplateIds },
    });

    expect(messageTemplates.length).to.equal(2);

    await session.testAgent.delete(`/v1/workflows/${template._id}`).send();

    const deletedNotificationTemplate = await notificationTemplateRepository.findOne({
      _environmentId: session.environment._id,
      _id: template._id,
    });

    expect(deletedNotificationTemplate).to.equal(null);

    const deletedIntegration = (
      await notificationTemplateRepository.findDeleted({ _environmentId: session.environment._id, _id: template._id })
    )[0];

    expect(deletedIntegration.deleted).to.equal(true);

    const deletedMessageTemplates = await messageTemplateRepository.find({
      _environmentId: session.environment._id,
      _id: { $in: messageTemplateIds },
    });

    expect(deletedMessageTemplates.length).to.equal(0);
  });

  it('should delete the production message templates', async () => {
    const groups = await notificationGroupRepository.find({
      _environmentId: session.environment._id,
    });

    const testTemplate = {
      name: 'test email template',
      description: 'This is a test description',
      tags: ['test-tag'],
      notificationGroupId: groups[0]._id,
      steps: [
        {
          template: {
            type: ChannelTypeEnum.IN_APP,
            content: 'Test content for <b>{{firstName}}</b>',
            cta: {
              type: ChannelCTATypeEnum.REDIRECT,
              data: {
                url: '/cypress/test-shell/example/test?test-param=true',
              },
            },
            variables: [
              {
                defaultValue: '',
                name: 'firstName',
                required: false,
                type: 'String',
              },
            ],
          },
        },
      ],
    };

    const { body } = await session.testAgent.post(`/v1/workflows`).send(testTemplate);
    const notificationTemplate = body.data;

    const notificationTemplateId = body.data._id;

    const messageTemplateId = notificationTemplate.steps[0]._templateId;

    await session.applyChanges({
      enabled: false,
    });

    const prodEvn = await getProductionEnvironment(session.environment._id);

    const isNotificationTemplatePromoted = await notificationTemplateRepository.findOne({
      _environmentId: prodEvn._id,
      _parentId: notificationTemplateId,
    });

    expect(isNotificationTemplatePromoted).to.exist;

    const isMessageTemplatePromoted = await messageTemplateRepository.findOne({
      _environmentId: prodEvn._id,
      _parentId: messageTemplateId,
    });

    expect(isMessageTemplatePromoted).to.exist;

    await session.testAgent.delete(`/v1/workflows/${notificationTemplateId}`).send();

    const {
      body: { data },
    } = await session.testAgent.get(`/v1/changes?promoted=false`);

    expect(data[0].templateName).to.eq(body.data.name);

    await session.applyChanges({
      enabled: false,
    });

    const isNotificationTemplateExists = await notificationTemplateRepository.findOne({
      _environmentId: prodEvn._id,
      _parentId: notificationTemplateId,
    });

    expect(isNotificationTemplateExists).to.not.exist;

    const isMessageTemplateExists = await notificationTemplateRepository.findOne({
      _environmentId: prodEvn._id,
      _parentId: messageTemplateId,
    });

    expect(isMessageTemplateExists).to.not.exist;
  });

  async function getProductionEnvironment(currentEnvId: string) {
    return await environmentRepository.findOne({
      _parentId: currentEnvId,
    });
  }
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getProductionEnvironment(currentEnvId: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - MessageTemplateRepository(new MessageTemplateRepository();

  before(async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('should delete the workflow', async (...)
 - deletedIntegration(await notificationTemplateRepository.findDeleted({ _environmentId: session.environment._id, _id: tem...)
 - isDeleted(await notificationTemplateRepository.findOne({
      _environmentId: prodEnv._id,
      _parentId: n...)
 - promoted(false`);

    expect(data[0].templateName).to.eq(body.data.name);
    expect(data.length).to.eq(1);
...)
 - response(await session.testAgent.delete(`/v1/workflows/${dummyId}`).send();

    expect(response.body.message...)
 - messageTemplateIds(template.steps.map((step))
 - deletedMessageTemplates(await messageTemplateRepository.find({
      _environmentId: session.environment._id,
      _id: { $...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/e2e/get-notification-template.e2e.ts
Tamaño: 2964 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { PreferencesRepository } from '@novu/dal';
import { ChannelCTATypeEnum, INotificationTemplate, INotificationTemplateStep, StepTypeEnum } from '@novu/shared';
import { NotificationTemplateService, UserSession } from '@novu/testing';
import { expect } from 'chai';
import { CreateWorkflowRequestDto } from '../dtos';

describe('Get workflow by id - /workflows/:workflowId (GET) #novu-v0', async () => {
  let session: UserSession;

  before(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should return the workflow by its id', async () => {
    const notificationTemplateService = new NotificationTemplateService(
      session.user._id,
      session.organization._id,
      session.environment._id
    );
    const template = await notificationTemplateService.createTemplate();
    const { body } = await session.testAgent.get(`/v1/workflows/${template._id}`);

    const foundTemplate: INotificationTemplate = body.data;

    expect(foundTemplate._id).to.equal(template._id);
    expect(foundTemplate.name).to.equal(template.name);
    expect(foundTemplate.steps.length).to.equal(template.steps.length);
    const step = foundTemplate.steps[0] as INotificationTemplateStep;
    expect(step.template).to.be.ok;
    expect(step.template?.content).to.equal(template.steps[0].template?.content);
    expect(step._templateId).to.be.ok;
    expect(foundTemplate.triggers.length).to.equal(template.triggers.length);
  });

  it('should return the workflow preference settings when the V2 Preferences do not exist', async () => {
    const testTemplate = {
      name: 'test template',
      description: 'This is a test description',
      notificationGroupId: session.notificationGroups[0]._id,
      steps: [
        {
          template: {
            name: 'Message Name',
            content: 'Test Template',
            type: StepTypeEnum.IN_APP,
            cta: {
              type: ChannelCTATypeEnum.REDIRECT,
              data: {
                url: 'https://example.org/profile',
              },
            },
          },
        },
      ],
      preferenceSettings: {
        in_app: true,
        sms: true,
        push: true,
        chat: true,
        email: false,
      },
      tags: [],
    } satisfies CreateWorkflowRequestDto;
    const { body: postWorkflowResponse } = await session.testAgent.post(`/v1/workflows`).send(testTemplate);

    const preferenceRepository = new PreferencesRepository();

    await preferenceRepository.delete({
      _environmentId: session.environment._id,
      _templateId: postWorkflowResponse.data._id,
    });

    const { body: getWorkflowResponse } = await session.testAgent.get(`/v1/workflows/${postWorkflowResponse.data._id}`);

    expect(getWorkflowResponse.data).to.be.ok;

    const template: INotificationTemplate = getWorkflowResponse.data;

    expect(template.preferenceSettings).to.deep.equal(testTemplate.preferenceSettings);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
    await session.initialize();
  });

  it('should return the workflow by its id...)
 - step(foundTemplate.steps[0] as INotificationTemplateStep;
    expect(step.template).to.be.ok;
    expect(...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/e2e/get-notification-templates.e2e.ts
Tamaño: 7945 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { NotificationTemplateEntity } from '@novu/dal';
import {
  ChannelCTATypeEnum,
  FieldLogicalOperatorEnum,
  FieldOperatorEnum,
  FilterPartTypeEnum,
  StepTypeEnum,
  TemplateVariableTypeEnum,
  TriggerTypeEnum,
} from '@novu/shared';
import { NotificationTemplateService, UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Get workflows - /workflows (GET) #novu-v0', async () => {
  let session: UserSession;
  const templates: NotificationTemplateEntity[] = [];
  let notificationTemplateService: NotificationTemplateService;

  before(async () => {
    session = new UserSession();
    await session.initialize();

    notificationTemplateService = new NotificationTemplateService(
      session.user._id,
      session.organization._id,
      session.environment._id
    );

    templates.push(
      await notificationTemplateService.createTemplate({
        steps: [
          {
            type: StepTypeEnum.IN_APP,
            content: 'Test content for <b>{{firstName}}</b>',
            cta: {
              type: ChannelCTATypeEnum.REDIRECT,
              data: {
                url: '/cypress/test-shell/example/test?test-param=true',
              },
            },
            variables: [
              {
                defaultValue: '',
                name: 'firstName',
                required: false,
                type: TemplateVariableTypeEnum.STRING,
              },
            ],
            variants: [
              {
                name: 'In-App',
                subject: 'test',
                type: StepTypeEnum.IN_APP,
                content: '',
                contentType: 'editor',
                variables: [],
                active: true,
                filters: [
                  {
                    value: FieldLogicalOperatorEnum.OR,
                    children: [
                      {
                        operator: FieldOperatorEnum.EQUAL,
                        on: FilterPartTypeEnum.PAYLOAD,
                        field: 'ef',
                        value: 'dsf',
                      },
                    ],
                  },
                ],
              },
            ],
          },
        ],
      })
    );
    templates.push(await notificationTemplateService.createTemplate());
    templates.push(await notificationTemplateService.createTemplate());
  });

  it('should return all workflows for organization', async () => {
    const { body } = await session.testAgent.get(`/v1/workflows`);

    expect(body.data.length).to.equal(3);

    const found = body.data.find((i) => templates[0]._id === i._id);

    expect(found).to.be.ok;
    expect(found.name).to.equal(templates[0].name);
    expect(found.notificationGroup.name).to.equal('General');
  });

  it('should not include variants data in the response', async () => {
    const { body } = await session.testAgent.get(`/v1/workflows`);

    expect(body.data.length).to.equal(3);

    const found = body.data.find((i) => templates[0]._id === i._id);

    expect(found).to.be.ok;
    expect(found.name).to.equal(templates[0].name);
    expect(found.notificationGroup.name).to.equal('General');
    expect(found.steps[0].variants).to.be.undefined;
  });

  it('should return all workflows as per pagination', async () => {
    templates.push(await notificationTemplateService.createTemplate());
    templates.push(await notificationTemplateService.createTemplate());
    templates.push(await notificationTemplateService.createTemplate());

    const { body: page0Limit2Results } = await session.testAgent.get(`/v1/workflows?page=0&limit=2`);

    expect(page0Limit2Results.data.length).to.equal(2);
    expect(page0Limit2Results.totalCount).to.equal(6);
    expect(page0Limit2Results.page).to.equal(0);
    expect(page0Limit2Results.pageSize).to.equal(2);
    expect(page0Limit2Results.data[0]._id).to.equal(templates[5]._id);

    const { body: page1Limit3Results } = await session.testAgent.get(`/v1/workflows?page=1&limit=3`);

    expect(page1Limit3Results.data.length).to.equal(3);
    expect(page1Limit3Results.totalCount).to.equal(6);
    expect(page1Limit3Results.page).to.equal(1);
    expect(page1Limit3Results.pageSize).to.equal(3);
    expect(page1Limit3Results.data[2]._id).to.equal(templates[0]._id);
  });

  it('should paginate and filter workflows based on the name', async () => {
    const promises: Promise<NotificationTemplateEntity>[] = [];
    const count = 10;
    for (let i = 0; i < count; i += 1) {
      promises.push(
        notificationTemplateService.createTemplate({
          name: `Pagination Test ${i}`,
        })
      );
    }
    await Promise.all(promises);

    const { body } = await session.testAgent.get(`/v1/workflows?page=0&limit=2&query=Pagination+Test`);

    expect(body.data.length).to.equal(2);
    expect(body.totalCount).to.equal(count);
    expect(body.page).to.equal(0);
    expect(body.pageSize).to.equal(2);
    for (let i = 0; i < 2; i += 1) {
      expect(body.data[i].name).to.contain('Pagination Test');
    }
  });

  it('should filter workflows based on the name', async () => {
    const promises: Promise<NotificationTemplateEntity>[] = [];
    const count = 10;
    for (let i = 0; i < count; i += 1) {
      promises.push(
        notificationTemplateService.createTemplate({
          name: `Test Template ${i}`,
        })
      );
    }
    await Promise.all(promises);

    const { body } = await session.testAgent.get(`/v1/workflows?page=0&limit=100&query=Test+Template`);

    expect(body.data.length).to.equal(count);
    expect(body.totalCount).to.equal(count);
    expect(body.page).to.equal(0);
    expect(body.pageSize).to.equal(100);
    for (let i = 0; i < count; i += 1) {
      expect(body.data[i].name).to.contain('Test Template');
    }
  });

  it('should filter workflows based on the trigger identifier', async () => {
    const promises: Promise<NotificationTemplateEntity>[] = [];
    const count = 10;
    const triggerIdentifier = 'test-trigger-identifier';
    for (let i = 0; i < count; i += 1) {
      promises.push(
        notificationTemplateService.createTemplate({
          triggers: [{ identifier: `${triggerIdentifier}-${i}`, type: TriggerTypeEnum.EVENT, variables: [] }],
        })
      );
    }
    await Promise.all(promises);

    const { body } = await session.testAgent.get(`/v1/workflows?page=0&limit=100&query=${triggerIdentifier}`);

    expect(body.data.length).to.equal(count);
    expect(body.totalCount).to.equal(count);
    expect(body.page).to.equal(0);
    expect(body.pageSize).to.equal(100);
    for (let i = 0; i < count; i += 1) {
      expect(body.data[i].triggers[0].identifier).to.contain(`${triggerIdentifier}`);
    }
  });

  it('should filter workflows based on both the name and trigger identifier', async () => {
    const promises: Promise<NotificationTemplateEntity>[] = [];
    const count = 10;
    for (let i = 0; i < count; i += 1) {
      if (i % 2 === 0) {
        promises.push(
          notificationTemplateService.createTemplate({
            name: Math.random() > 0.5 ? `SMS ${i}` : `sms ${i}`,
          })
        );
        continue;
      }

      promises.push(
        notificationTemplateService.createTemplate({
          triggers: [{ identifier: `sms-trigger-${i}`, type: TriggerTypeEnum.EVENT, variables: [] }],
        })
      );
    }
    await Promise.all(promises);

    const { body } = await session.testAgent.get(`/v1/workflows?page=0&limit=100&query=sms`);
    const nameCount = body.data.filter((i) => i.name.toUpperCase().includes('SMS')).length;
    const triggerCount = body.data.filter((i) => i.triggers[0].identifier.includes('sms')).length;

    expect(body.data.length).to.equal(count);
    expect(body.totalCount).to.equal(count);
    expect(body.page).to.equal(0);
    expect(body.pageSize).to.equal(100);
    expect(nameCount).to.equal(5);
    expect(triggerCount).to.equal(5);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - param(true',
              },
            },
            variables: [
              {
                defa...)
 - found(body.data.find((i))
 - found(body.data.find((i))
 - limit(3`);

    expect(page1Limit3Results.data.length).to.equal(3);
    expect(page1Limit3Results.totalCou...)
 - nameCount(body.data.filter((i))
 - triggerCount(body.data.filter((i))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/e2e/update-notification-template.e2e.ts
Tamaño: 14536 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChangeRepository } from '@novu/dal';
import {
  EmailBlockTypeEnum,
  FieldLogicalOperatorEnum,
  FieldOperatorEnum,
  FilterPartTypeEnum,
  INotificationTemplate,
  INotificationTemplateStep,
  IUpdateNotificationTemplateDto,
  StepTypeEnum,
} from '@novu/shared';
import { NotificationTemplateService, UserSession } from '@novu/testing';
import { expect } from 'chai';
import { CreateWorkflowRequestDto, UpdateWorkflowRequestDto } from '../dtos';
import { WorkflowResponse } from '../dtos/workflow-response.dto';

describe('Update workflow by id - /workflows/:workflowId (PUT) #novu-v0', async () => {
  let session: UserSession;
  const changeRepository: ChangeRepository = new ChangeRepository();

  before(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should update the workflow', async () => {
    const notificationTemplateService = new NotificationTemplateService(
      session.user._id,
      session.organization._id,
      session.environment._id
    );
    const template = await notificationTemplateService.createTemplate();
    const update: IUpdateNotificationTemplateDto = {
      name: 'new name for notification',
      steps: [
        {
          template: {
            type: StepTypeEnum.IN_APP,
            content: 'This is new content for notification',
          },
          variants: [
            {
              filters: [
                {
                  isNegated: false,
                  type: 'GROUP',
                  value: FieldLogicalOperatorEnum.AND,
                  children: [
                    {
                      on: FilterPartTypeEnum.TENANT,
                      field: 'name',
                      value: 'Titans',
                      operator: FieldOperatorEnum.EQUAL,
                    },
                  ],
                },
              ],
              template: {
                type: StepTypeEnum.IN_APP,
                content: 'first content',
              },
            },
            {
              filters: [
                {
                  isNegated: false,
                  type: 'GROUP',
                  value: FieldLogicalOperatorEnum.AND,
                  children: [
                    {
                      on: FilterPartTypeEnum.TENANT,
                      field: 'name',
                      value: 'Titans',
                      operator: FieldOperatorEnum.EQUAL,
                    },
                  ],
                },
              ],
              template: {
                type: StepTypeEnum.IN_APP,
                content: 'second content',
              },
            },
          ],
        },
      ],
    };
    const { body } = await session.testAgent.put(`/v1/workflows/${template._id}`).send(update);
    const foundTemplate: INotificationTemplate = body.data;

    expect(foundTemplate._id).to.equal(template._id);
    expect(foundTemplate.name).to.equal('new name for notification');
    expect(foundTemplate.description).to.equal(template.description);
    expect(foundTemplate.steps.length).to.equal(1);

    const updateRequestStep = update.steps ? update.steps[0] : undefined;
    const step = foundTemplate.steps[0] as INotificationTemplateStep;
    expect(step.template?.content).to.equal(updateRequestStep?.template?.content);

    const fountVariant = step.variants ? step.variants[0] : undefined;
    const updateRequestStepVariant = updateRequestStep?.variants ? updateRequestStep?.variants[0] : undefined;
    expect(fountVariant?.template?.content).to.equal(updateRequestStepVariant?.template?.content);

    // test variant parent id
    const firstVariant = step.variants ? step.variants[0] : undefined;
    expect(firstVariant?._parentId).to.equal(null);
    const secondVariant = step.variants ? step.variants[1] : undefined;
    expect(secondVariant?._parentId).to.equal(firstVariant?._id);

    const change = await changeRepository.findOne({
      _environmentId: session.environment._id,
      _entityId: foundTemplate._id,
    });
    if (!change) {
      throw new Error('Change not found');
    }
    expect(change._entityId).to.eq(foundTemplate._id);
  });

  it('should throw error if trigger identifier already exists', async () => {
    const notificationTemplateService = new NotificationTemplateService(
      session.user._id,
      session.organization._id,
      session.environment._id
    );
    const template1 = await notificationTemplateService.createTemplate();
    const template2 = await notificationTemplateService.createTemplate();
    const update: IUpdateNotificationTemplateDto = {
      identifier: template1.triggers[0].identifier,
    };

    const { body } = await session.testAgent.put(`/v1/workflows/${template2._id}`).send(update);

    expect(body.statusCode).to.equal(400);
    expect(body.message).to.equal(`Workflow with identifier ${template1.triggers[0].identifier} already exists`);
    expect(body.error).to.equal('Bad Request');
  });

  it('should update the trigger identifier', async () => {
    const notificationTemplateService = new NotificationTemplateService(
      session.user._id,
      session.organization._id,
      session.environment._id
    );
    const template = await notificationTemplateService.createTemplate();
    const newIdentifier = `${template.triggers[0].identifier}-new`;
    const update: IUpdateNotificationTemplateDto = {
      identifier: newIdentifier,
    };

    const { body } = await session.testAgent.put(`/v1/workflows/${template._id}`).send(update);

    const foundTemplate: INotificationTemplate = body.data;

    expect(foundTemplate._id).to.equal(template._id);
    expect(foundTemplate.description).to.equal(template.description);
    expect(foundTemplate.name).to.equal(template.name);
    expect(foundTemplate.triggers[0].identifier).to.equal(newIdentifier);

    const change = await changeRepository.findOne({
      _environmentId: session.environment._id,
      _entityId: foundTemplate._id,
    });
    if (!change) {
      throw new Error('Change not found');
    }

    expect(change._entityId).to.eq(foundTemplate._id);
  });

  it('should generate new variables on update', async () => {
    const notificationTemplateService = new NotificationTemplateService(
      session.user._id,
      session.organization._id,
      session.environment._id
    );

    const template = await notificationTemplateService.createTemplate({
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'This is new content for notification {{otherVariable}}',
        },
      ],
    });

    const update: IUpdateNotificationTemplateDto = {
      steps: [
        {
          template: {
            type: StepTypeEnum.IN_APP,
            content: 'This is new content for notification {{newVariableFromUpdate}}',
          },
        },
      ],
    };
    const { body } = await session.testAgent.put(`/v1/workflows/${template._id}`).send(update);
    const foundTemplate: INotificationTemplate = body.data;

    expect(foundTemplate._id).to.equal(template._id);
    expect(foundTemplate.triggers[0].variables[0].name).to.equal('newVariableFromUpdate');
  });

  it('should update the contentType and active of a message', async () => {
    const notificationTemplateService = new NotificationTemplateService(
      session.user._id,
      session.organization._id,
      session.environment._id
    );

    const template = await notificationTemplateService.createTemplate({
      steps: [
        {
          type: StepTypeEnum.EMAIL,
          contentType: 'editor',
          content: 'Content',
        },
      ],
    });

    const update: IUpdateNotificationTemplateDto = {
      steps: [
        {
          active: false,
          template: {
            type: StepTypeEnum.EMAIL,
            contentType: 'customHtml',
            content: 'Content',
          },
        },
      ],
    };
    const { body } = await session.testAgent.put(`/v1/workflows/${template._id}`).send(update);
    const foundTemplate: INotificationTemplate = body.data;

    expect(foundTemplate._id).to.equal(template._id);
    const step = foundTemplate.steps[0] as INotificationTemplateStep;
    expect(step.active).to.equal(false);
    expect(step.template?.contentType).to.equal('customHtml');
  });

  it('should be able to update empty message content', async () => {
    const notificationTemplateService = new NotificationTemplateService(
      session.user._id,
      session.organization._id,
      session.environment._id
    );

    const template = await notificationTemplateService.createTemplate({
      steps: [
        {
          type: StepTypeEnum.EMAIL,
          contentType: 'editor',
          content: [{ type: EmailBlockTypeEnum.TEXT, content: 'This is a sample text block' }],
        },
        {
          type: StepTypeEnum.EMAIL,
          contentType: 'customHtml',
          content: 'This is a sample text block',
        },
      ],
    });

    const update: IUpdateNotificationTemplateDto = {
      steps: [
        ...template.steps.map((step) => {
          return {
            _templateId: step._templateId,
            template: {
              type: StepTypeEnum.EMAIL,
              contentType: 'customHtml',
              content: '',
            },
          } as INotificationTemplateStep;
        }),
      ],
    };
    const { body } = await session.testAgent.put(`/v1/workflows/${template._id}`).send(update);
    const { steps } = body.data;

    expect(steps[0].template?.contentType).to.equal('customHtml');
    expect(steps[0].template?.content).to.equal('');
    expect(steps[1].template?.content).to.equal('');
  });

  it('should update the steps', async () => {
    const testTemplate: CreateWorkflowRequestDto = {
      name: 'test email template',
      description: 'This is a test description',
      tags: ['test-tag'],
      notificationGroupId: session.notificationGroups[0]._id,
      steps: [
        {
          template: {
            name: 'Message Name',
            subject: 'Test email subject',
            preheader: 'Test email preheader',
            senderName: 'Test email sender name',
            type: StepTypeEnum.EMAIL,
            content: [],
          },
        },
        {
          template: {
            name: 'Message Name',
            subject: 'Test email subject',
            type: StepTypeEnum.EMAIL,
            content: [],
          },
        },
      ],
    };

    const { body } = await session.testAgent.post(`/v1/workflows`).send(testTemplate);

    const template: INotificationTemplate = body.data;

    const updateData: UpdateWorkflowRequestDto = {
      name: testTemplate.name,
      tags: testTemplate.tags,
      description: testTemplate.description,
      steps: [
        ...template.steps.map((step) => {
          return {
            _id: step._id,
            template: {
              name: 'Message Name',
              subject: 'Test email subject',
              preheader: 'updated preheader',
              senderName: 'updated sender name',
              type: StepTypeEnum.EMAIL,
              content: [],
            },
            _parentId: step._parentId,
          } as INotificationTemplateStep;
        }),
        {
          template: {
            name: 'Message Name',
            subject: 'Test email subject',
            type: StepTypeEnum.EMAIL,
            content: [],
          },
        },
      ],
      notificationGroupId: session.notificationGroups[0]._id,
    };

    const { body: updated } = await session.testAgent.put(`/v1/workflows/${template._id}`).send(updateData);

    const { steps } = updated.data;

    expect(steps[0]._parentId).to.equal(null);
    expect(steps[0].template.preheader).to.equal('updated preheader');
    expect(steps[0].template.senderName).to.equal('updated sender name');
    expect(steps[0]._id).to.equal(steps[1]._parentId);
    expect(steps[1]._id).to.equal(steps[2]._parentId);
  });

  it('should update reply callbacks', async () => {
    const testTemplate: Partial<CreateWorkflowRequestDto> = {
      name: 'test email template',
      description: 'This is a test description',
      tags: ['test-tag'],
      notificationGroupId: session.notificationGroups[0]._id,
      steps: [
        {
          template: {
            name: 'Message Name',
            type: StepTypeEnum.EMAIL,
            content: [],
          },
        },
      ],
    };

    const { body } = await session.testAgent.post(`/v1/workflows`).send(testTemplate);

    const createdTemplate: WorkflowResponse = body.data;

    expect(createdTemplate.name).to.equal(testTemplate.name);
    expect(createdTemplate.steps[0].replyCallback).to.deep.equal({});

    const template: INotificationTemplate = body.data;

    const updateData: UpdateWorkflowRequestDto = {
      name: 'test email template',
      tags: ['test-tag'],
      description: 'This is a test description',
      steps: [
        {
          template: {
            name: 'Message Name',
            type: StepTypeEnum.EMAIL,
            content: [],
          },
          replyCallback: { active: true, url: 'acme-corp.com/webhook' },
        },
      ],
      notificationGroupId: session.notificationGroups[0]._id,
    };

    const { body: updated } = await session.testAgent.put(`/v1/workflows/${template._id}`).send(updateData);

    const updatedTemplate: WorkflowResponse = updated.data;

    expect(updatedTemplate.name).to.equal(testTemplate.name);
    expect(updatedTemplate.steps[0].replyCallback?.active).to.equal(true);
    expect(updatedTemplate.steps[0].replyCallback?.url).to.equal('acme-corp.com/webhook');
  });

  it('should not able to update step with invalid action', async () => {
    const notificationTemplateService = new NotificationTemplateService(
      session.user._id,
      session.organization._id,
      session.environment._id
    );
    const workflow = await notificationTemplateService.createTemplate();
    const invalidAction = '';
    const update: IUpdateNotificationTemplateDto = {
      steps: [
        {
          template: {
            type: StepTypeEnum.IN_APP,
            cta: { action: invalidAction } as any,
            content: 'This is new content for notification',
          },
        },
      ],
    };

    const { body } = await session.testAgent.put(`/v1/workflows/${workflow._id}`).send(update);

    expect(body.message).to.equal('Please provide a valid CTA action');
    expect(body.statusCode).to.equal(400);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - ChangeRepository(new ChangeRepository();

  before(async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('should update the workflow', async (...)
 - change(await changeRepository.findOne({
      _environmentId: session.environment._id,
      _entityId: fou...)
 - change(await changeRepository.findOne({
      _environmentId: session.environment._id,
      _entityId: fou...)
 - INotificationTemplate(body.data;

    expect(foundTemplate._id).to.equal(template._id);
    expect(foundTemplate.triggers[...)
 - step(foundTemplate.steps[0] as INotificationTemplateStep;
    expect(step.active).to.equal(false);
    ex...)
 - IUpdateNotificationTemplateDto({
      steps: [
        ...template.steps.map((step))
 - UpdateWorkflowRequestDto({
      name: testTemplate.name,
      tags: testTemplate.tags,
      description: testTemplate.desc...)
 - WorkflowResponse(updated.data;

    expect(updatedTemplate.name).to.equal(testTemplate.name);
    expect(updatedTempl...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/queries/CreateWorkflowQuery.ts
Tamaño: 115 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/**
 * @deprecated use dto's in /workflows directory
 */
export class CreateWorkflowQuery {
  __source?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateWorkflowQuery

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/queries/index.ts
Tamaño: 39 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './CreateWorkflowQuery';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/usecases/index.ts
Tamaño: 1562 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { GetWorkflowByIdsUseCase, ResourceValidatorService } from '@novu/application-generic';

import { CommunityOrganizationRepository } from '@novu/dal';
import { ChangeTemplateActiveStatus } from './change-template-active-status/change-template-active-status.usecase';
import { CreateWorkflow } from './create-workflow/create-workflow.usecase';
import { DeleteNotificationTemplate } from './delete-notification-template/delete-notification-template.usecase';
import { DeleteWorkflowUseCase } from './delete-workflow/delete-workflow.usecase';
import { GetActiveIntegrationsStatus } from './get-active-integrations-status/get-active-integrations-status.usecase';
import { GetNotificationTemplate } from './get-notification-template/get-notification-template.usecase';
import { GetNotificationTemplates } from './get-notification-templates/get-notification-templates.usecase';
import { GetWorkflowVariables } from './get-workflow-variables/get-workflow-variables.usecase';
import { GetWorkflowWithPreferencesUseCase } from './get-workflow-with-preferences/get-workflow-with-preferences.usecase';
import { UpdateWorkflow } from './update-workflow/update-workflow.usecase';

export const USE_CASES = [
  GetActiveIntegrationsStatus,
  ChangeTemplateActiveStatus,
  GetWorkflowByIdsUseCase,
  GetWorkflowWithPreferencesUseCase,
  CreateWorkflow,
  UpdateWorkflow,
  ResourceValidatorService,
  DeleteWorkflowUseCase,
  GetNotificationTemplates,
  GetNotificationTemplate,
  DeleteNotificationTemplate,
  GetWorkflowVariables,
  CommunityOrganizationRepository,
];


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/usecases/change-template-active-status/change-template-active-status.command.ts
Tamaño: 550 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsBoolean, IsDefined, IsMongoId } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

/**
 * @deprecated use dto's in /workflows directory
 */

/**
 * @deprecated
 * This command is deprecated and will be removed in the future.
 * Please use the ChangeWorkflowActiveStatusCommand instead.
 */
export class ChangeTemplateActiveStatusCommand extends EnvironmentWithUserCommand {
  @IsBoolean()
  @IsDefined()
  active: boolean;

  @IsMongoId()
  @IsDefined()
  templateId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ChangeTemplateActiveStatusCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/usecases/change-template-active-status/change-template-active-status.usecase.ts
Tamaño: 2446 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import { CreateChange, CreateChangeCommand, InvalidateCacheService } from '@novu/application-generic';
import { ChangeRepository, NotificationTemplateEntity, NotificationTemplateRepository } from '@novu/dal';
import { ChangeEntityTypeEnum } from '@novu/shared';

import { ChangeTemplateActiveStatusCommand } from './change-template-active-status.command';

/**
 * @deprecated
 * This usecase is deprecated and will be removed in the future.
 * Please use the ChangeWorkflowActiveStatus usecase instead.
 */
@Injectable()
export class ChangeTemplateActiveStatus {
  constructor(
    private invalidateCache: InvalidateCacheService,
    private notificationTemplateRepository: NotificationTemplateRepository,
    private createChange: CreateChange,
    private changeRepository: ChangeRepository
  ) {}

  async execute(command: ChangeTemplateActiveStatusCommand): Promise<NotificationTemplateEntity> {
    const foundTemplate = await this.notificationTemplateRepository.findOne({
      _environmentId: command.environmentId,
      _id: command.templateId,
    });

    if (!foundTemplate) {
      throw new NotFoundException(`Template with id ${command.templateId} not found`);
    }

    if (foundTemplate.active === command.active) {
      throw new BadRequestException('You must provide a different status from the current status');
    }

    await this.notificationTemplateRepository.update(
      {
        _id: command.templateId,
        _environmentId: command.environmentId,
      },
      {
        $set: {
          active: command.active,
          draft: !command.active,
        },
      }
    );

    const item = await this.notificationTemplateRepository.findById(command.templateId, command.environmentId);
    if (!item) throw new NotFoundException(`Notification template ${command.templateId} is not found`);

    const parentChangeId: string = await this.changeRepository.getChangeId(
      command.environmentId,
      ChangeEntityTypeEnum.NOTIFICATION_TEMPLATE,
      command.templateId
    );

    await this.createChange.execute(
      CreateChangeCommand.create({
        organizationId: command.organizationId,
        environmentId: command.environmentId,
        userId: command.userId,
        type: ChangeEntityTypeEnum.NOTIFICATION_TEMPLATE,
        item,
        changeId: parentChangeId,
      })
    );

    return item;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ChangeTemplateActiveStatus

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/usecases/create-workflow/create-workflow.command.ts
Tamaño: 3201 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  ContentIssue,
  EnvironmentWithUserCommand,
  JSONSchema,
  NotificationStep,
  PreferencesRequired,
} from '@novu/application-generic';
import { ClientSession } from '@novu/dal';
import {
  CustomDataType,
  INotificationGroup,
  MAX_DESCRIPTION_LENGTH,
  MAX_NAME_LENGTH,
  MAX_TAG_LENGTH,
  ResourceOriginEnum,
  ResourceTypeEnum,
  RuntimeIssue,
  SeverityLevelEnum,
  WorkflowStatusEnum,
} from '@novu/shared';
import { Exclude, Type } from 'class-transformer';
import {
  ArrayUnique,
  IsArray,
  IsBoolean,
  IsDefined,
  IsEnum,
  IsMongoId,
  IsObject,
  IsOptional,
  IsString,
  Length,
  ValidateIf,
  ValidateNested,
} from 'class-validator';

export class CreateWorkflowCommand extends EnvironmentWithUserCommand {
  @IsDefined()
  @IsString()
  @Length(1, MAX_NAME_LENGTH)
  name: string;

  @IsString()
  @IsOptional()
  @Length(0, MAX_DESCRIPTION_LENGTH)
  description?: string;

  @IsOptional()
  @IsArray()
  @ArrayUnique()
  @Length(1, MAX_TAG_LENGTH, { each: true })
  tags?: string[];

  @IsBoolean()
  active: boolean;

  @IsDefined()
  @IsArray()
  @ValidateNested()
  steps: NotificationStep[];

  @IsBoolean()
  @IsOptional()
  draft?: boolean;

  @IsMongoId()
  @IsDefined()
  notificationGroupId?: string;

  @IsOptional()
  notificationGroup?: INotificationGroup;

  @IsObject()
  @ValidateNested()
  @Type(() => PreferencesRequired)
  @ValidateIf((object, value) => value !== null)
  @IsOptional()
  userPreferences?: PreferencesRequired | null;

  @IsBoolean()
  @IsOptional()
  critical?: boolean;

  @IsObject()
  @IsOptional()
  @ValidateNested()
  @Type(() => PreferencesRequired)
  defaultPreferences: PreferencesRequired;

  @IsOptional()
  blueprintId?: string;

  @IsOptional()
  @IsString()
  __source?: string;

  @IsOptional()
  data?: CustomDataType;

  @IsOptional()
  inputs?: {
    schema: JSONSchema;
  };
  @IsOptional()
  controls?: {
    schema: JSONSchema;
  };

  @IsOptional()
  rawData?: Record<string, unknown>;

  @IsOptional()
  payloadSchema?: JSONSchema | null;

  @IsOptional()
  @IsBoolean()
  validatePayload?: boolean;

  @IsOptional()
  @IsBoolean()
  isTranslationEnabled?: boolean;

  @IsEnum(ResourceTypeEnum)
  @IsDefined()
  type: ResourceTypeEnum;

  @IsEnum(ResourceOriginEnum)
  @IsDefined()
  origin: ResourceOriginEnum;

  /**
   * Optional identifier for the workflow trigger.
   * This allows overriding the default trigger identifier generation strategy in the use case.
   * If provided, the use case will use this value instead of generating one.
   * If not provided, the use case will generate a trigger identifier based on its internal logic.
   */
  @IsOptional()
  @IsString()
  triggerIdentifier?: string;
  @IsObject()
  @IsOptional()
  @ValidateNested({ each: true })
  @Type(() => ContentIssue)
  issues?: Record<string, RuntimeIssue>;

  @IsEnum(WorkflowStatusEnum)
  @IsOptional()
  status?: WorkflowStatusEnum;

  @IsOptional()
  @IsString()
  updatedBy?: string;

  /**
   * Exclude session from the command to avoid serializing it in the response
   */
  @IsOptional()
  @Exclude()
  session?: ClientSession | null;

  @IsOptional()
  @IsEnum(SeverityLevelEnum)
  severity?: SeverityLevelEnum;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateWorkflowCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/usecases/create-workflow/create-workflow.usecase.ts
Tamaño: 21260 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import {
  AnalyticsService,
  ContentService,
  CreateChange,
  CreateChangeCommand,
  CreateMessageTemplate,
  CreateMessageTemplateCommand,
  GetPreferences,
  Instrument,
  InstrumentUsecase,
  isVariantEmpty,
  NotificationStep,
  NotificationStepVariantCommand,
  PinoLogger,
  PlatformException,
  ResourceValidatorService,
  shortId,
  UpsertPreferences,
  UpsertUserWorkflowPreferencesCommand,
  UpsertWorkflowPreferencesCommand,
} from '@novu/application-generic';
import {
  ClientSession,
  JsonSchemaTypeEnum,
  LocalizationResourceEnum,
  NotificationGroupEntity,
  NotificationGroupRepository,
  NotificationTemplateRepository,
} from '@novu/dal';
import {
  ChangeEntityTypeEnum,
  DEFAULT_WORKFLOW_PREFERENCES,
  INotificationTemplateStep,
  INotificationTrigger,
  IStepVariant,
  isBridgeWorkflow,
  ResourceOriginEnum,
  ResourceTypeEnum,
  slugify,
  TriggerTypeEnum,
} from '@novu/shared';
import { WorkflowWithPreferencesResponseDto } from '../../dtos/get-workflow-with-preferences.dto';
import { GetWorkflowWithPreferencesUseCase } from '../get-workflow-with-preferences/get-workflow-with-preferences.usecase';
import { CreateWorkflowCommand } from './create-workflow.command';

/**
 * @deprecated - use `UpsertWorkflow` instead
 */
@Injectable()
export class CreateWorkflow {
  constructor(
    private notificationTemplateRepository: NotificationTemplateRepository,
    private notificationGroupRepository: NotificationGroupRepository,
    private createMessageTemplate: CreateMessageTemplate,
    private createChange: CreateChange,
    private analyticsService: AnalyticsService,
    private logger: PinoLogger,
    protected moduleRef: ModuleRef,
    private upsertPreferences: UpsertPreferences,
    private getWorkflowWithPreferencesUseCase: GetWorkflowWithPreferencesUseCase,
    private resourceValidatorService: ResourceValidatorService
  ) {}

  @InstrumentUsecase()
  async execute(usecaseCommand: CreateWorkflowCommand): Promise<WorkflowWithPreferencesResponseDto> {
    const blueprintCommand = await this.processBlueprint(usecaseCommand);
    const command = blueprintCommand ?? usecaseCommand;
    await this.validatePayload(command);
    await this.resourceValidatorService.validateWorkflowLimit(command.environmentId);

    let storedWorkflow!: WorkflowWithPreferencesResponseDto;

    const workflowCreation = async (session?: ClientSession | null) => {
      const triggerIdentifier = this.generateTriggerIdentifier(command);

      const parentChangeId: string = NotificationTemplateRepository.createObjectId();

      const templateSteps = await this.storeTemplateSteps(command, parentChangeId, session);
      const trigger = await this.createNotificationTrigger(command, triggerIdentifier);
      if (!command.payloadSchema) {
        command.payloadSchema = {
          type: JsonSchemaTypeEnum.OBJECT,
          additionalProperties: true,
          properties: {},
        };

        command.validatePayload = command.validatePayload ?? true;
      }

      storedWorkflow = await this.storeWorkflow(command, templateSteps, trigger, triggerIdentifier, session);

      if (command.isTranslationEnabled !== undefined) {
        await this.toggleV2TranslationsForWorkflow(triggerIdentifier, command, storedWorkflow, session);
      }

      await this.createWorkflowChange(command, storedWorkflow, parentChangeId);
    };

    if (command.session) {
      // If session is provided, use it (we're already in a transaction)
      await workflowCreation(command.session);
    } else {
      // If no session, create our own transaction
      await this.notificationTemplateRepository.withTransaction(async (session) => {
        await workflowCreation(session);
      });
    }

    try {
      if (
        (process.env.NOVU_ENTERPRISE === 'true' || process.env.CI_EE_TEST === 'true') &&
        storedWorkflow.origin === ResourceOriginEnum.NOVU_CLOUD_V1
      ) {
        if (!require('@novu/ee-shared-services')?.TranslationsService) {
          throw new PlatformException('Translation module is not loaded');
        }
        const service = this.moduleRef.get(require('@novu/ee-shared-services')?.TranslationsService, { strict: false });

        const locales = await service.createTranslationAnalytics(storedWorkflow);

        this.analyticsService.track('Locale used in workflow - [Translations]', command.userId, {
          _organization: command.organizationId,
          _environment: command.environmentId,
          workflowId: storedWorkflow._id,
          locales,
        });
      }
    } catch (e) {
      this.logger.error(e, `Unexpected error while importing enterprise modules`, 'TranslationsService');
    }

    this.analyticsService.track('Workflow created', command.userId, {
      _organization: command.organizationId,
      _environment: command.environmentId,
      workflowId: storedWorkflow._id,
      name: storedWorkflow.name,
      description: storedWorkflow.description,
      tags: storedWorkflow.tags,
    });

    return storedWorkflow;
  }

  private async toggleV2TranslationsForWorkflow(
    workflowIdentifier: string,
    command: CreateWorkflowCommand,
    workflowEntity: WorkflowWithPreferencesResponseDto,
    session?: ClientSession | null
  ) {
    const isEnterprise = process.env.NOVU_ENTERPRISE === 'true' || process.env.CI_EE_TEST === 'true';
    const isSelfHosted = process.env.IS_SELF_HOSTED === 'true';

    if (!isEnterprise || isSelfHosted) {
      return;
    }

    try {
      const manageTranslations = this.moduleRef.get(require('@novu/ee-translation')?.ManageTranslations, {
        strict: false,
      });

      await manageTranslations.execute({
        enabled: command.isTranslationEnabled,
        resourceId: workflowIdentifier,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        organizationId: command.organizationId,
        environmentId: command.environmentId,
        userId: command.userId,
        session,
        resourceEntity: workflowEntity,
      });
    } catch (error) {
      this.logger.error(
        `Failed to ${command.isTranslationEnabled ? 'enable' : 'disable'} V2 translations for workflow`,
        {
          workflowIdentifier,
          enabled: command.isTranslationEnabled,
          organizationId: command.organizationId,
          error: error instanceof Error ? error.message : String(error),
        }
      );

      throw error;
    }
  }

  private generateTriggerIdentifier(command: CreateWorkflowCommand) {
    if (command.triggerIdentifier) {
      return command.triggerIdentifier;
    }

    let triggerIdentifier: string;
    if (command.type === ResourceTypeEnum.BRIDGE && command.origin === ResourceOriginEnum.EXTERNAL)
      /*
       * Bridge workflows need to have the identifier preserved to ensure that
       * the Framework-defined identifier is the source of truth.
       */
      triggerIdentifier = command.name;
    else {
      /**
       * For non-bridge workflows, we use a slugified version of the workflow name
       * as the trigger identifier to provide a better trigger DX.
       */
      triggerIdentifier = slugify(command.name);
    }

    return triggerIdentifier;
  }

  private async validatePayload(command: CreateWorkflowCommand) {
    if (command.steps) {
      await this.resourceValidatorService.validateStepsLimit(
        command.environmentId,
        command.organizationId,
        command.steps
      );
    }

    const variants = command.steps ? command.steps?.flatMap((step) => step.variants || []) : [];

    for (const variant of variants) {
      if (isVariantEmpty(variant)) {
        throw new BadRequestException(
          `Variant conditions are required, variant name ${variant.name} id ${variant._id}`
        );
      }
    }
  }

  @Instrument()
  private async createNotificationTrigger(
    command: CreateWorkflowCommand,
    triggerIdentifier: string
  ): Promise<INotificationTrigger> {
    const contentService = new ContentService();
    const { variables, reservedVariables } = contentService.extractMessageVariables(command.steps);
    const subscriberVariables = contentService.extractSubscriberMessageVariables(command.steps);
    const identifier = await this.generateUniqueIdentifier(command, triggerIdentifier);

    return {
      type: TriggerTypeEnum.EVENT,
      identifier,
      variables: variables.map((i) => {
        return {
          name: i.name,
          type: i.type,
        };
      }),
      reservedVariables: reservedVariables.map((i) => {
        return {
          type: i.type,
          variables: i.variables.map((variable) => {
            return {
              name: variable.name,
              type: variable.type,
            };
          }),
        };
      }),
      subscriberVariables: subscriberVariables.map((i) => {
        return {
          name: i,
        };
      }),
    };
  }

  private async generateUniqueIdentifier(command: CreateWorkflowCommand, triggerIdentifier: string) {
    const maxAttempts = 3;
    let identifier = '';

    for (let attempt = 0; attempt < maxAttempts; attempt += 1) {
      const candidateIdentifier = attempt === 0 ? triggerIdentifier : `${triggerIdentifier}-${shortId()}`;

      const isIdentifierExist = await this.notificationTemplateRepository.findByTriggerIdentifier(
        command.environmentId,
        candidateIdentifier
      );

      if (!isIdentifierExist) {
        identifier = candidateIdentifier;
        break;
      }
    }

    if (!identifier) {
      throw new BadRequestException(
        `Unable to generate a unique identifier. Please provide a different workflow name.${command.name}`
      );
    }

    return identifier;
  }

  private sendTemplateCreationEvent(command: CreateWorkflowCommand, triggerIdentifier: string) {
    if (command.name !== 'On-boarding notification' && !command.__source?.startsWith('onboarding_')) {
      this.analyticsService.track('Create Notification Template - [Platform]', command.userId, {
        _organization: command.organizationId,
        steps: command.steps?.length,
        channels: command.steps?.map((i) => i.template?.type),
        __source: command.__source,
        triggerIdentifier,
      });
    }
  }

  private async createWorkflowChange(command: CreateWorkflowCommand, item, parentChangeId: string) {
    if (!isBridgeWorkflow(command.type)) {
      await this.createChange.execute(
        CreateChangeCommand.create({
          organizationId: command.organizationId,
          environmentId: command.environmentId,
          userId: command.userId,
          type: ChangeEntityTypeEnum.NOTIFICATION_TEMPLATE,
          item,
          changeId: parentChangeId,
        })
      );
    }
  }

  @Instrument()
  private async storeWorkflow(
    command: CreateWorkflowCommand,
    templateSteps: INotificationTemplateStep[],
    trigger: INotificationTrigger,
    triggerIdentifier: string,
    session?: ClientSession | null
  ): Promise<WorkflowWithPreferencesResponseDto> {
    this.logger.info(`Creating workflow ${JSON.stringify(command)}`);

    const workflowData = {
      _organizationId: command.organizationId,
      _creatorId: command.userId,
      _environmentId: command.environmentId,
      name: command.name,
      active: command.active,
      draft: command.draft,
      critical: command.critical ?? false,
      /** @deprecated - use `userPreferences` instead */
      preferenceSettings: GetPreferences.mapWorkflowPreferencesToChannelPreferences(
        command.userPreferences ?? DEFAULT_WORKFLOW_PREFERENCES
      ),
      tags: command.tags,
      description: command.description,
      steps: templateSteps,
      triggers: [trigger],
      _notificationGroupId: command.notificationGroupId,
      blueprintId: command.blueprintId,
      type: command.type,
      origin: command.origin,
      status: command.status,
      issues: command.issues,
      severity: command.severity,
      ...(command.updatedBy ? { _updatedBy: command.updatedBy } : {}),
      ...(command.rawData ? { rawData: command.rawData } : {}),
      ...(command.payloadSchema ? { payloadSchema: command.payloadSchema } : {}),
      ...(command.validatePayload !== undefined ? { validatePayload: command.validatePayload } : {}),
      ...(command.data ? { data: command.data } : {}),
    };

    const savedWorkflow = await this.notificationTemplateRepository.create(workflowData, { session });

    // defaultPreferences is required, so we always call the upsert
    await this.upsertPreferences.upsertWorkflowPreferences(
      UpsertWorkflowPreferencesCommand.create({
        templateId: savedWorkflow._id,
        preferences: command.defaultPreferences,
        environmentId: command.environmentId,
        organizationId: command.organizationId,
      })
    );

    if (command.userPreferences !== undefined && command.userPreferences !== null) {
      // userPreferences is optional, so we need to check if it's defined before calling the upsert
      await this.upsertPreferences.upsertUserWorkflowPreferences(
        UpsertUserWorkflowPreferencesCommand.create({
          templateId: savedWorkflow._id,
          preferences: command.userPreferences,
          environmentId: command.environmentId,
          organizationId: command.organizationId,
          userId: command.userId,
        })
      );
    }

    const item = await this.notificationTemplateRepository.findById(savedWorkflow._id, command.environmentId, session);
    if (!item) throw new NotFoundException(`Workflow ${savedWorkflow._id} is not found`);

    this.sendTemplateCreationEvent(command, triggerIdentifier);

    return this.getWorkflowWithPreferencesUseCase.execute({
      environmentId: command.environmentId,
      organizationId: command.organizationId,
      workflowIdOrInternalId: savedWorkflow._id,
      session,
    });
  }

  @Instrument()
  private async storeTemplateSteps(
    command: CreateWorkflowCommand,
    parentChangeId: string,
    session?: ClientSession | null
  ): Promise<INotificationTemplateStep[]> {
    let parentStepId: string | null = null;
    const templateSteps: INotificationTemplateStep[] = [];

    for (const step of command.steps) {
      if (!step.template) throw new BadRequestException(`Unexpected error: message template is missing`);

      const messageTemplateCommand = {
        organizationId: command.organizationId,
        environmentId: command.environmentId,
        userId: command.userId,
        type: step.template.type,
        name: step.template.name,
        content: step.template.content,
        variables: step.template.variables,
        contentType: step.template.contentType,
        cta: step.template.cta,
        subject: step.template.subject,
        title: step.template.title,
        feedId: step.template.feedId,
        layoutId: step.template.layoutId,
        preheader: step.template.preheader,
        senderName: step.template.senderName,
        actor: step.template.actor,
        controls: step.template.controls,
        output: step.template.output,
        stepId: step.template.stepId,
        parentChangeId,
        workflowType: command.type,
        ...(session ? { session } : {}),
      };

      const createdMessageTemplate = await this.createMessageTemplate.execute(
        CreateMessageTemplateCommand.create(messageTemplateCommand)
      );

      const storedVariants = await this.storeVariantSteps(
        {
          variants: step.variants,
          parentChangeId,
          organizationId: command.organizationId,
          environmentId: command.environmentId,
          userId: command.userId,
          workflowType: command.type,
        },
        session
      );

      const stepId = createdMessageTemplate._id;
      const templateStep: Partial<INotificationTemplateStep> = {
        _id: stepId,
        _templateId: createdMessageTemplate._id,
        filters: step.filters,
        _parentId: parentStepId,
        active: step.active,
        shouldStopOnFail: step.shouldStopOnFail,
        replyCallback: step.replyCallback,
        uuid: step.uuid,
        name: step.name,
        metadata: step.metadata,
        stepId: step.stepId,
        issues: step.issues,
      };

      if (storedVariants.length) {
        templateStep.variants = storedVariants;
      }

      templateSteps.push(templateStep);

      if (stepId) {
        parentStepId = stepId;
      }
    }

    return templateSteps;
  }

  private async storeVariantSteps(
    {
      variants,
      parentChangeId,
      organizationId,
      environmentId,
      userId,
      workflowType,
    }: {
      variants: NotificationStepVariantCommand[] | undefined;
      parentChangeId: string;
      organizationId: string;
      environmentId: string;
      userId: string;
      workflowType: ResourceTypeEnum;
    },
    session?: ClientSession | null
  ): Promise<IStepVariant[]> {
    if (!variants?.length) return [];

    const variantsList: IStepVariant[] = [];
    let parentVariantId: string | null = null;

    for (const variant of variants) {
      if (!variant.template) throw new BadRequestException(`Unexpected error: variants message template is missing`);

      const variantTemplateCommand = {
        organizationId,
        environmentId,
        userId,
        type: variant.template.type,
        name: variant.template.name,
        content: variant.template.content,
        variables: variant.template.variables,
        contentType: variant.template.contentType,
        cta: variant.template.cta,
        subject: variant.template.subject,
        title: variant.template.title,
        feedId: variant.template.feedId,
        layoutId: variant.template.layoutId,
        preheader: variant.template.preheader,
        senderName: variant.template.senderName,
        actor: variant.template.actor,
        parentChangeId,
        workflowType,
        ...(session ? { session } : {}),
      };

      const variantTemplate = await this.createMessageTemplate.execute(
        CreateMessageTemplateCommand.create(variantTemplateCommand)
      );

      variantsList.push({
        _id: variantTemplate._id,
        _templateId: variantTemplate._id,
        filters: variant.filters,
        _parentId: parentVariantId,
        active: variant.active,
        shouldStopOnFail: variant.shouldStopOnFail,
        replyCallback: variant.replyCallback,
        uuid: variant.uuid,
        name: variant.name,
        metadata: variant.metadata,
      });

      if (variantTemplate._id) {
        parentVariantId = variantTemplate._id;
      }
    }

    return variantsList;
  }

  private async processBlueprint(command: CreateWorkflowCommand) {
    if (!command.blueprintId) return null;

    const group: NotificationGroupEntity = await this.handleGroup(command);
    const steps: NotificationStep[] = this.normalizeSteps(command.steps);

    return CreateWorkflowCommand.create({
      organizationId: command.organizationId,
      userId: command.userId,
      environmentId: command.environmentId,
      name: command.name,
      tags: command.tags,
      description: command.description,
      steps,
      notificationGroupId: group._id,
      active: command.active ?? false,
      draft: command.draft ?? true,
      userPreferences: command.userPreferences,
      defaultPreferences: command.defaultPreferences,
      blueprintId: command.blueprintId,
      __source: command.__source,
      type: ResourceTypeEnum.REGULAR,
      origin: command.origin ?? ResourceOriginEnum.NOVU_CLOUD,
    });
  }

  private normalizeSteps(commandSteps: NotificationStep[]): NotificationStep[] {
    const steps = JSON.parse(JSON.stringify(commandSteps)) as NotificationStep[];

    return steps.map((step) => {
      const { template } = step;
      if (template) {
        template.feedId = undefined;
      }

      return {
        ...step,
        ...(template ? { template } : {}),
      };
    });
  }

  private async handleGroup(command: CreateWorkflowCommand): Promise<NotificationGroupEntity> {
    if (!command.notificationGroup?.name) throw new NotFoundException(`Notification group was not provided`);

    let notificationGroup = await this.notificationGroupRepository.findOne({
      name: command.notificationGroup.name,
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
    });

    if (!notificationGroup) {
      notificationGroup = await this.notificationGroupRepository.create({
        _environmentId: command.environmentId,
        _organizationId: command.organizationId,
        name: command.notificationGroup.name,
      });

      if (!isBridgeWorkflow(command.type)) {
        await this.createChange.execute(
          CreateChangeCommand.create({
            item: notificationGroup,
            environmentId: command.environmentId,
            organizationId: command.organizationId,
            userId: command.userId,
            type: ChangeEntityTypeEnum.NOTIFICATION_GROUP,
            changeId: NotificationGroupRepository.createObjectId(),
          })
        );
      }
    }

    return notificationGroup;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - workflowCreation(async (session?: ClientSession | null))
 - variants(command.steps ? command.steps?.flatMap((step))
 - identifier(await this.generateUniqueIdentifier(command, triggerIdentifier);

    return {
      type: TriggerTy...)
 - steps(JSON.parse(JSON.stringify(commandSteps)) as NotificationStep[];

    return steps.map((step))
Declaraciones 'export' encontradas:
- export class CreateWorkflow

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/usecases/delete-notification-template/delete-notification-template.command.ts
Tamaño: 543 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ResourceTypeEnum } from '@novu/shared';
import { IsDefined, IsEnum, IsMongoId } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

/**
 * @deprecated
 * This command is deprecated and will be removed in the future.
 * Please use the GetWorkflowCommand instead.
 */
export class DeleteNotificationTemplateCommand extends EnvironmentWithUserCommand {
  @IsDefined()
  @IsMongoId()
  templateId: string;

  @IsEnum(ResourceTypeEnum)
  @IsDefined()
  type: ResourceTypeEnum;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DeleteNotificationTemplateCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/usecases/delete-notification-template/delete-notification-template.usecase.ts
Tamaño: 2690 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable } from '@nestjs/common';
import { AnalyticsService, CreateChange, CreateChangeCommand } from '@novu/application-generic';
import { ChangeRepository, DalException, NotificationTemplateEntity, NotificationTemplateRepository } from '@novu/dal';
import { ChangeEntityTypeEnum } from '@novu/shared';
import { DeleteWorkflowCommand } from '../delete-workflow/delete-workflow.command';
import { DeleteWorkflowUseCase } from '../delete-workflow/delete-workflow.usecase';
import { DeleteNotificationTemplateCommand } from './delete-notification-template.command';

/**
 * @deprecated
 * This usecase is deprecated and will be removed in the future.
 * Please use the DeleteWorkflow usecase instead.
 */
@Injectable()
export class DeleteNotificationTemplate {
  constructor(
    private createChange: CreateChange,
    private changeRepository: ChangeRepository,
    private analyticsService: AnalyticsService,
    private deleteWorkflowUseCase: DeleteWorkflowUseCase,
    private notificationTemplateRepository: NotificationTemplateRepository
  ) {}

  async execute(command: DeleteNotificationTemplateCommand) {
    try {
      await this.deleteWorkflowUseCase.execute(
        DeleteWorkflowCommand.create({
          workflowIdOrInternalId: command.templateId,
          environmentId: command.environmentId,
          organizationId: command.organizationId,
          userId: command.userId,
        })
      );

      const parentChangeId: string = await this.changeRepository.getChangeId(
        command.environmentId,
        ChangeEntityTypeEnum.NOTIFICATION_TEMPLATE,
        command.templateId
      );

      const item: NotificationTemplateEntity = (
        await this.notificationTemplateRepository.findDeleted({
          _environmentId: command.environmentId,
          _id: command.templateId,
        })
      )?.[0];

      await this.createChange.execute(
        CreateChangeCommand.create({
          organizationId: command.organizationId,
          environmentId: command.environmentId,
          userId: command.userId,
          item,
          type: ChangeEntityTypeEnum.NOTIFICATION_TEMPLATE,
          changeId: parentChangeId,
        })
      );

      this.analyticsService.track(`Removed Notification Template`, command.userId, {
        _organization: command.organizationId,
        _environment: command.environmentId,
        _templateId: command.templateId,
        data: {
          draft: item.draft,
          critical: item.critical,
        },
      });
    } catch (e) {
      if (e instanceof DalException) {
        throw new BadRequestException(e.message);
      }
      throw e;
    }

    return true;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DeleteNotificationTemplate

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/usecases/delete-workflow/delete-workflow.command.ts
Tamaño: 265 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentWithUserCommand } from '@novu/application-generic';
import { IsDefined, IsString } from 'class-validator';

export class DeleteWorkflowCommand extends EnvironmentWithUserCommand {
  @IsString()
  @IsDefined()
  workflowIdOrInternalId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DeleteWorkflowCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/usecases/delete-workflow/delete-workflow.usecase.ts
Tamaño: 4695 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import {
  DeletePreferencesCommand,
  DeletePreferencesUseCase,
  GetWorkflowByIdsUseCase,
  Instrument,
  InstrumentUsecase,
  PinoLogger,
  SendWebhookMessage,
} from '@novu/application-generic';
import {
  ControlValuesRepository,
  LocalizationResourceEnum,
  MessageTemplateRepository,
  NotificationTemplateEntity,
  NotificationTemplateRepository,
} from '@novu/dal';
import { PreferencesTypeEnum, WebhookEventEnum, WebhookObjectTypeEnum } from '@novu/shared';
import { GetWorkflowWithPreferencesCommand } from '../get-workflow-with-preferences/get-workflow-with-preferences.command';
import { DeleteWorkflowCommand } from './delete-workflow.command';

@Injectable()
export class DeleteWorkflowUseCase {
  constructor(
    private notificationTemplateRepository: NotificationTemplateRepository,
    private messageTemplateRepository: MessageTemplateRepository,
    private getWorkflowByIdsUseCase: GetWorkflowByIdsUseCase,
    private controlValuesRepository: ControlValuesRepository,
    private deletePreferencesUsecase: DeletePreferencesUseCase,
    private moduleRef: ModuleRef,
    private logger: PinoLogger,
    private sendWebhookMessage: SendWebhookMessage
  ) {}

  @InstrumentUsecase()
  async execute(command: DeleteWorkflowCommand): Promise<void> {
    const workflowEntity = await this.getWorkflowByIdsUseCase.execute(
      GetWorkflowWithPreferencesCommand.create({
        ...command,
        workflowIdOrInternalId: command.workflowIdOrInternalId,
      })
    );

    await this.deleteRelatedEntities(command, workflowEntity);

    await this.sendWebhookMessage.execute({
      eventType: WebhookEventEnum.WORKFLOW_DELETED,
      objectType: WebhookObjectTypeEnum.WORKFLOW,
      payload: {
        object: workflowEntity as unknown as Record<string, unknown>,
      },
      organizationId: command.organizationId,
      environmentId: command.environmentId,
    });
  }

  @Instrument()
  private async deleteRelatedEntities(command: DeleteWorkflowCommand, workflow: NotificationTemplateEntity) {
    await this.notificationTemplateRepository.withTransaction(async () => {
      await this.controlValuesRepository.deleteMany({
        _environmentId: command.environmentId,
        _organizationId: command.organizationId,
        _workflowId: workflow._id,
      });

      if (workflow.steps.length > 0) {
        for (const step of workflow.steps) {
          await this.messageTemplateRepository.deleteById({
            _id: step._templateId,
            _environmentId: command.environmentId,
          });
        }
      }

      await this.deletePreferencesUsecase.execute(
        DeletePreferencesCommand.create({
          templateId: workflow._id,
          environmentId: command.environmentId,
          organizationId: command.organizationId,
          userId: command.userId,
          type: PreferencesTypeEnum.USER_WORKFLOW,
        })
      );

      await this.deletePreferencesUsecase.execute(
        DeletePreferencesCommand.create({
          templateId: workflow._id,
          environmentId: command.environmentId,
          organizationId: command.organizationId,
          userId: command.userId,
          type: PreferencesTypeEnum.WORKFLOW_RESOURCE,
        })
      );

      await this.deleteTranslationGroup(command);

      await this.notificationTemplateRepository.delete({
        _id: workflow._id,
        _organizationId: command.organizationId,
        _environmentId: command.environmentId,
      });
    });
  }

  private async deleteTranslationGroup(command: DeleteWorkflowCommand) {
    const isEnterprise = process.env.NOVU_ENTERPRISE === 'true' || process.env.CI_EE_TEST === 'true';
    const isSelfHosted = process.env.IS_SELF_HOSTED === 'true';

    if (!isEnterprise || isSelfHosted) {
      return;
    }

    try {
      const deleteTranslationGroup = this.moduleRef.get(require('@novu/ee-translation')?.DeleteTranslationGroup, {
        strict: false,
      });

      await deleteTranslationGroup.execute({
        resourceId: command.workflowIdOrInternalId,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        organizationId: command.organizationId,
        environmentId: command.environmentId,
        userId: command.userId,
      });
    } catch (error) {
      this.logger.error(`Failed to delete translations for workflow`, {
        workflowIdentifier: command.workflowIdOrInternalId,
        organizationId: command.organizationId,
        error: error instanceof Error ? error.message : String(error),
      });

      // translation group might not be present, so we can ignore the error
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - workflowEntity(await this.getWorkflowByIdsUseCase.execute(
      GetWorkflowWithPreferencesCommand.create({
       ...)
Declaraciones 'export' encontradas:
- export class DeleteWorkflowUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/usecases/get-active-integrations-status/get-active-integrations-status.command.ts
Tamaño: 363 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { NotificationTemplateEntity } from '@novu/dal';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

/**
 * @deprecated use commands in /workflows directory
 */
export class GetActiveIntegrationsStatusCommand extends EnvironmentWithUserCommand {
  workflows: NotificationTemplateEntity | NotificationTemplateEntity[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetActiveIntegrationsStatusCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/usecases/get-active-integrations-status/get-active-integrations-status.spec.ts
Tamaño: 2639 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Test } from '@nestjs/testing';
import { ChannelTypeEnum, EmailProviderIdEnum, InAppProviderIdEnum } from '@novu/shared';
import { IntegrationService, NotificationTemplateService, UserSession } from '@novu/testing';
import { expect } from 'chai';
import { SharedModule } from '../../../shared/shared.module';
import { WorkflowResponse } from '../../dtos/workflow-response.dto';
import { WorkflowModuleV1 } from '../../workflow-v1.module';
import { GetActiveIntegrationsStatusCommand } from './get-active-integrations-status.command';
import { GetActiveIntegrationsStatus } from './get-active-integrations-status.usecase';

describe('Get Active Integrations Status', () => {
  let useCase: GetActiveIntegrationsStatus;
  let session: UserSession;

  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [WorkflowModuleV1, SharedModule],
      providers: [],
    }).compile();

    session = new UserSession();
    await session.initialize();

    useCase = moduleRef.get<GetActiveIntegrationsStatus>(GetActiveIntegrationsStatus);
  });

  it('should get the active integrations status for workflow', async () => {
    const notificationTemplateService = new NotificationTemplateService(
      session.user._id,
      session.organization._id,
      session.environment._id
    );
    const template = await notificationTemplateService.createTemplate();

    const integrationService = new IntegrationService();
    await integrationService.deleteAllForOrganization(session.organization._id);
    await integrationService.createIntegration({
      environmentId: session.environment._id,
      organizationId: session.organization._id,
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
    });
    await integrationService.createIntegration({
      environmentId: session.environment._id,
      organizationId: session.organization._id,
      providerId: InAppProviderIdEnum.Novu,
      channel: ChannelTypeEnum.IN_APP,
    });

    const command = GetActiveIntegrationsStatusCommand.create({
      userId: session.user._id,
      organizationId: session.organization._id,
      environmentId: session.environment._id,
      workflows: template,
    });

    const result = (await useCase.execute(command)) as WorkflowResponse;

    expect(result.workflowIntegrationStatus?.hasActiveIntegrations).to.equal(true);
    expect(result.workflowIntegrationStatus?.channels[ChannelTypeEnum.EMAIL].hasActiveIntegrations).to.equal(true);
    expect(result.workflowIntegrationStatus?.channels[ChannelTypeEnum.PUSH].hasActiveIntegrations).to.equal(false);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - useCase(moduleRef.get<GetActiveIntegrationsStatus>(GetActiveIntegrationsStatus);
  });

  it('should get the...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/usecases/get-active-integrations-status/get-active-integrations-status.usecase.ts
Tamaño: 6472 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import {
  CalculateLimitNovuIntegration,
  CalculateLimitNovuIntegrationCommand,
  NotificationStep,
} from '@novu/application-generic';
import {
  ChannelTypeEnum,
  ChatProviderIdEnum,
  EmailProviderIdEnum,
  SmsProviderIdEnum,
  StepTypeEnum,
  WorkflowChannelsIntegrationStatus,
} from '@novu/shared';
import { IntegrationResponseDto } from '../../../integrations/dtos/integration-response.dto';
import { GetActiveIntegrationsCommand } from '../../../integrations/usecases/get-active-integration/get-active-integration.command';
import { GetActiveIntegrations } from '../../../integrations/usecases/get-active-integration/get-active-integration.usecase';
import { WorkflowResponse } from '../../dtos/workflow-response.dto';
import { GetActiveIntegrationsStatusCommand } from './get-active-integrations-status.command';

/**
 * @deprecated use usecases in /workflows directory
 */
@Injectable()
export class GetActiveIntegrationsStatus {
  constructor(
    private getActiveIntegrationUsecase: GetActiveIntegrations,
    private calculateLimitNovuIntegrationUsecase: CalculateLimitNovuIntegration
  ) {}

  async execute(command: GetActiveIntegrationsStatusCommand): Promise<WorkflowResponse[] | WorkflowResponse> {
    const defaultStateByChannelType = Object.keys(ChannelTypeEnum).reduce((prev, key) => {
      const channelType = ChannelTypeEnum[key];

      prev[channelType] = { hasActiveIntegrations: false };

      if (channelType === ChannelTypeEnum.EMAIL || channelType === ChannelTypeEnum.SMS) {
        prev[channelType] = { ...prev[channelType], hasPrimaryIntegrations: false };
      }

      return prev;
    }, {} as WorkflowChannelsIntegrationStatus);

    const activeIntegrations = await this.getActiveIntegrationUsecase.execute(
      GetActiveIntegrationsCommand.create({
        organizationId: command.organizationId,
        environmentId: command.environmentId,
        userId: command.userId,
      })
    );

    const activeIntegrationsByEnv = activeIntegrations.filter(
      (activeIntegration) => activeIntegration._environmentId === command.environmentId
    );

    const activeStateByChannelType = this.updateStateByChannelType(activeIntegrationsByEnv, defaultStateByChannelType);

    const activeStateByChannelTypeWithNovu = await this.processNovuProviders(
      activeIntegrationsByEnv,
      command,
      activeStateByChannelType
    );

    return this.updateActiveIntegrationsStatus(command.workflows, activeStateByChannelTypeWithNovu);
  }

  private updateStateByChannelType(
    activeIntegrations: IntegrationResponseDto[],
    stateByChannelType: WorkflowChannelsIntegrationStatus
  ): WorkflowChannelsIntegrationStatus {
    for (const integration of activeIntegrations) {
      const channelType = integration.channel;

      stateByChannelType[channelType].hasActiveIntegrations = integration.active;
      const isEmailChannel = channelType === ChannelTypeEnum.EMAIL;
      const isSmsChannel = channelType === ChannelTypeEnum.SMS;

      if ((isEmailChannel || isSmsChannel) && !stateByChannelType[channelType].hasPrimaryIntegrations) {
        stateByChannelType[channelType].hasPrimaryIntegrations = integration.primary;
      }
    }

    return stateByChannelType;
  }

  private updateActiveIntegrationsStatus(
    workflows: WorkflowResponse | WorkflowResponse[],
    activeChannelsStatus: WorkflowChannelsIntegrationStatus
  ) {
    if (Array.isArray(workflows)) {
      return workflows.map((workflow) => {
        const { hasActive, hasPrimary } = this.handleSteps(workflow.steps, activeChannelsStatus);
        workflow.workflowIntegrationStatus = {
          hasActiveIntegrations: hasActive,
          channels: activeChannelsStatus,
          hasPrimaryIntegrations: hasPrimary,
        };

        return workflow;
      });
    } else {
      const { hasActive, hasPrimary } = this.handleSteps(workflows.steps, activeChannelsStatus);

      return {
        ...workflows,
        workflowIntegrationStatus: {
          hasActiveIntegrations: hasActive,
          channels: activeChannelsStatus,
          hasPrimaryIntegrations: hasPrimary,
        },
      };
    }
  }

  private handleSteps(steps: NotificationStep[], activeChannelsStatus: WorkflowChannelsIntegrationStatus) {
    let hasActive = true;
    let hasPrimary: boolean | undefined;
    const uniqueSteps = Array.from(new Set(steps));
    for (const step of uniqueSteps) {
      const stepType = step.template?.type;
      const skipStep =
        stepType === StepTypeEnum.DELAY ||
        stepType === StepTypeEnum.DIGEST ||
        stepType === StepTypeEnum.TRIGGER ||
        stepType === StepTypeEnum.CUSTOM;
      const isStepWithPrimaryIntegration = stepType === StepTypeEnum.EMAIL || stepType === StepTypeEnum.SMS;
      if (stepType && !skipStep) {
        const { hasActiveIntegrations } = activeChannelsStatus[stepType];
        if (!hasActiveIntegrations) {
          hasActive = false;
        }

        if (isStepWithPrimaryIntegration) {
          const hasPrimaryIntegration = activeChannelsStatus[stepType].hasPrimaryIntegrations;
          if (!hasPrimaryIntegration) {
            hasPrimary = false;
          }
        }
      }
    }

    return { hasActive, hasPrimary };
  }

  private async processNovuProviders(
    activeIntegrations: IntegrationResponseDto[],
    command: GetActiveIntegrationsStatusCommand,
    stateByChannelType: WorkflowChannelsIntegrationStatus
  ) {
    const primaryNovuProviders = activeIntegrations.filter(
      (integration) =>
        (integration.providerId === EmailProviderIdEnum.Novu ||
          integration.providerId === SmsProviderIdEnum.Novu ||
          integration.providerId === ChatProviderIdEnum.Novu) &&
        integration.primary
    );

    for (const primaryNovuProvider of primaryNovuProviders) {
      const channelType = primaryNovuProvider.channel;
      let hasLimitReached = true;
      const limit = await this.calculateLimitNovuIntegrationUsecase.execute(
        CalculateLimitNovuIntegrationCommand.create({
          channelType,
          environmentId: command.environmentId,
          organizationId: command.organizationId,
        })
      );
      if (!limit) {
        hasLimitReached = true;
      } else {
        hasLimitReached = limit.limit === limit.count;
      }
      stateByChannelType[channelType].hasActiveIntegrations = !hasLimitReached;
    }

    return stateByChannelType;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - defaultStateByChannelType(Object.keys(ChannelTypeEnum).reduce((prev, key))
 - activeIntegrationsByEnv(activeIntegrations.filter(
      (activeIntegration))
 - hasPrimaryIntegrations(integration.primary;
      }
    }

    return stateByChannelType;
  }

  private updateActiveIntegr...)
 - primaryNovuProviders(activeIntegrations.filter(
      (integration))
Declaraciones 'export' encontradas:
- export class GetActiveIntegrationsStatus

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/usecases/get-notification-template/get-notification-template.command.ts
Tamaño: 423 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsString } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

/**
 * @deprecated
 * This command is deprecated and will be removed in the future.
 * Please use the GetWorkflowCommand instead.
 */
export class GetNotificationTemplateCommand extends EnvironmentWithUserCommand {
  @IsDefined()
  @IsString()
  workflowIdOrIdentifier: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetNotificationTemplateCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/usecases/get-notification-template/get-notification-template.usecase.ts
Tamaño: 1142 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { NotificationTemplateEntity } from '@novu/dal';
import { GetWorkflowWithPreferencesCommand } from '../get-workflow-with-preferences/get-workflow-with-preferences.command';
import { GetWorkflowWithPreferencesUseCase } from '../get-workflow-with-preferences/get-workflow-with-preferences.usecase';
import { GetNotificationTemplateCommand } from './get-notification-template.command';

/**
 * @deprecated
 * This usecase is deprecated and will be removed in the future.
 * Please use the GetWorkflow usecase instead.
 */
@Injectable()
export class GetNotificationTemplate {
  constructor(private getWorkflowWithPreferencesUseCase: GetWorkflowWithPreferencesUseCase) {}

  async execute(command: GetNotificationTemplateCommand): Promise<NotificationTemplateEntity> {
    const workflow = await this.getWorkflowWithPreferencesUseCase.execute(
      GetWorkflowWithPreferencesCommand.create({
        workflowIdOrInternalId: command.workflowIdOrIdentifier,
        environmentId: command.environmentId,
        organizationId: command.organizationId,
      })
    );

    return workflow;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetNotificationTemplate

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/usecases/get-notification-templates/get-notification-templates.command.ts
Tamaño: 485 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsNumber, IsOptional, IsString } from 'class-validator';

import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

/**
 * @deprecated
 * This command is deprecated and will be removed in the future.
 * Please use the GetWorkflowsCommand instead.
 */
export class GetNotificationTemplatesCommand extends EnvironmentWithUserCommand {
  @IsNumber()
  page: number;

  @IsNumber()
  limit: number;

  @IsOptional()
  @IsString()
  query?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetNotificationTemplatesCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/usecases/get-notification-templates/get-notification-templates.usecase.ts
Tamaño: 1970 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { NotificationTemplateEntity, NotificationTemplateRepository } from '@novu/dal';
import { WorkflowResponse } from '../../dtos/workflow-response.dto';
import { WorkflowsResponseDto } from '../../dtos/workflows.response.dto';
import { GetActiveIntegrationsStatusCommand } from '../get-active-integrations-status/get-active-integrations-status.command';
import { GetActiveIntegrationsStatus } from '../get-active-integrations-status/get-active-integrations-status.usecase';
import { GetNotificationTemplatesCommand } from './get-notification-templates.command';

/**
 * D@deprecated
 * This usecase is deprecated and will be removed in the future.
 * Please use the GetWorkflows usecase instead.
 */
@Injectable()
export class GetNotificationTemplates {
  constructor(
    private notificationTemplateRepository: NotificationTemplateRepository,
    private getActiveIntegrationsStatusUsecase: GetActiveIntegrationsStatus
  ) {}

  async execute(command: GetNotificationTemplatesCommand): Promise<WorkflowsResponseDto> {
    const { data: list, totalCount } = await this.notificationTemplateRepository.getList(
      command.organizationId,
      command.environmentId,
      command.page * command.limit,
      command.limit,
      command.query,
      true
    );

    const workflows = await this.updateHasActiveIntegrationFlag(list, command);

    return { page: command.page, data: workflows, totalCount, pageSize: command.limit };
  }

  private async updateHasActiveIntegrationFlag(
    workflows: NotificationTemplateEntity[],
    command: GetNotificationTemplatesCommand
  ): Promise<WorkflowResponse[]> {
    return (await this.getActiveIntegrationsStatusUsecase.execute(
      GetActiveIntegrationsStatusCommand.create({
        organizationId: command.organizationId,
        environmentId: command.environmentId,
        userId: command.userId,
        workflows,
      })
    )) as WorkflowResponse[];
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetNotificationTemplates

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/usecases/get-workflow-variables/get-workflow-variables.command.ts
Tamaño: 167 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class GetWorkflowVariablesCommand extends EnvironmentWithUserCommand {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetWorkflowVariablesCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/usecases/get-workflow-variables/get-workflow-variables.usecase.ts
Tamaño: 1987 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import { buildVariablesKey, CachedResponse, PinoLogger } from '@novu/application-generic';
import { SystemVariablesWithTypes } from '@novu/shared';
import { GetWorkflowVariablesCommand } from './get-workflow-variables.command';

/**
 * @deprecated use usecases in /workflows directory
 */
@Injectable()
export class GetWorkflowVariables {
  constructor(
    private moduleRef: ModuleRef,
    private logger: PinoLogger
  ) {
    this.logger.setContext(this.constructor.name);
  }

  async execute(command: GetWorkflowVariablesCommand) {
    const { environmentId, organizationId } = command;

    return await this.fetchVariables({
      _environmentId: environmentId,
      _organizationId: organizationId,
    });
  }

  @CachedResponse({
    builder: (command: { _environmentId: string; _organizationId: string }) =>
      buildVariablesKey({
        _environmentId: command._environmentId,
        _organizationId: command._organizationId,
      }),
  })
  private async fetchVariables({
    _environmentId,
    _organizationId,
  }: {
    _environmentId: string;
    _organizationId: string;
  }) {
    let translationVariables = {};

    try {
      if (process.env.NOVU_ENTERPRISE === 'true' || process.env.CI_EE_TEST === 'true') {
        if (!require('@novu/ee-shared-services')?.TranslationsService) {
          throw new BadRequestException('Translation module is not loaded');
        }
        const service = this.moduleRef.get(require('@novu/ee-shared-services')?.TranslationsService, { strict: false });
        translationVariables = await service.getTranslationVariables(_environmentId, _organizationId);
      }
    } catch (e) {
      this.logger.error({ err: e }, `Unexpected error while importing enterprise modules`, 'TranslationsService');
    }

    return {
      translations: translationVariables,
      system: SystemVariablesWithTypes,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetWorkflowVariables

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/usecases/get-workflow-with-preferences/get-workflow-with-preferences.command.ts
Tamaño: 459 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentCommand } from '@novu/application-generic';
import { ClientSession } from '@novu/dal';
import { Exclude } from 'class-transformer';
import { IsDefined, IsOptional, IsString } from 'class-validator';

export class GetWorkflowWithPreferencesCommand extends EnvironmentCommand {
  @IsDefined()
  @IsString()
  workflowIdOrInternalId: string;

  @IsOptional()
  @IsString()
  userId?: string;

  @Exclude()
  session?: ClientSession | null;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetWorkflowWithPreferencesCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/usecases/get-workflow-with-preferences/get-workflow-with-preferences.usecase.ts
Tamaño: 2428 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import {
  GetPreferences,
  GetPreferencesCommand,
  GetWorkflowByIdsUseCase,
  Instrument,
  InstrumentUsecase,
} from '@novu/application-generic';
import { NotificationTemplateEntity } from '@novu/dal';
import { buildWorkflowPreferencesFromPreferenceChannels, DEFAULT_WORKFLOW_PREFERENCES } from '@novu/shared';
import { WorkflowWithPreferencesResponseDto } from '../../dtos/get-workflow-with-preferences.dto';
import { GetWorkflowWithPreferencesCommand } from './get-workflow-with-preferences.command';

@Injectable()
export class GetWorkflowWithPreferencesUseCase {
  constructor(
    private getWorkflowByIdsUseCase: GetWorkflowByIdsUseCase,
    private getPreferences: GetPreferences
  ) {}

  @InstrumentUsecase()
  async execute(command: GetWorkflowWithPreferencesCommand): Promise<WorkflowWithPreferencesResponseDto> {
    const workflowEntity = await this.getWorkflowByIdsUseCase.execute({
      workflowIdOrInternalId: command.workflowIdOrInternalId,
      environmentId: command.environmentId,
      organizationId: command.organizationId,
      userId: command.userId,
      session: command.session,
    });

    const workflowPreferences = await this.getWorkflowPreferences(command, workflowEntity);

    /**
     * @deprecated - use `userPreferences` and `defaultPreferences` instead
     */
    const preferenceSettings = workflowPreferences
      ? GetPreferences.mapWorkflowPreferencesToChannelPreferences(workflowPreferences.preferences)
      : workflowEntity.preferenceSettings;
    const userPreferences = workflowPreferences
      ? workflowPreferences.source.USER_WORKFLOW
      : buildWorkflowPreferencesFromPreferenceChannels(workflowEntity.critical, workflowEntity.preferenceSettings);
    const defaultPreferences = workflowPreferences
      ? workflowPreferences.source.WORKFLOW_RESOURCE
      : DEFAULT_WORKFLOW_PREFERENCES;

    return {
      ...workflowEntity,
      preferenceSettings,
      userPreferences,
      defaultPreferences,
    };
  }

  @Instrument()
  private async getWorkflowPreferences(
    command: GetWorkflowWithPreferencesCommand,
    workflowEntity: NotificationTemplateEntity
  ) {
    return await this.getPreferences.safeExecute(
      GetPreferencesCommand.create({
        environmentId: command.environmentId,
        organizationId: command.organizationId,
        templateId: workflowEntity._id,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetWorkflowWithPreferencesUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/usecases/update-workflow/update-workflow.command.ts
Tamaño: 2694 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  ContentIssue,
  EnvironmentWithUserCommand,
  IStepControl,
  JSONSchema,
  NotificationStep,
  PreferencesRequired,
} from '@novu/application-generic';
import { ClientSession } from '@novu/dal';
import {
  CustomDataType,
  MAX_DESCRIPTION_LENGTH,
  MAX_NAME_LENGTH,
  MAX_TAG_LENGTH,
  ResourceTypeEnum,
  RuntimeIssue,
  SeverityLevelEnum,
  WorkflowStatusEnum,
} from '@novu/shared';
import { Exclude, Type } from 'class-transformer';
import {
  ArrayUnique,
  IsArray,
  IsBoolean,
  IsDefined,
  IsEnum,
  IsMongoId,
  IsObject,
  IsOptional,
  IsString,
  Length,
  ValidateIf,
  ValidateNested,
} from 'class-validator';

export class UpdateWorkflowCommand extends EnvironmentWithUserCommand {
  @IsDefined()
  @IsMongoId()
  id: string;

  @IsOptional()
  @IsString()
  @Length(1, MAX_NAME_LENGTH)
  name: string;

  @IsString()
  @IsOptional()
  @Length(0, MAX_DESCRIPTION_LENGTH)
  description?: string;

  @IsOptional()
  @IsArray()
  @ArrayUnique()
  @Length(1, MAX_TAG_LENGTH, { each: true })
  tags?: string[];

  @IsBoolean()
  @IsOptional()
  active?: boolean;

  @IsArray()
  @ValidateNested()
  @IsOptional()
  steps?: NotificationStep[];

  @IsOptional()
  @IsMongoId()
  notificationGroupId?: string;

  @IsObject()
  @ValidateNested()
  @Type(() => PreferencesRequired)
  @ValidateIf((object, value) => value !== null)
  @IsOptional()
  userPreferences?: PreferencesRequired | null;

  @IsBoolean()
  @IsOptional()
  critical?: boolean;

  @IsObject()
  @IsOptional()
  @ValidateNested()
  @Type(() => PreferencesRequired)
  defaultPreferences: PreferencesRequired;

  @ValidateNested()
  @IsOptional()
  replyCallback?: {
    active: boolean;
    url: string;
  };

  @IsOptional()
  data?: CustomDataType;

  @IsOptional()
  inputs?: IStepControl;

  @IsOptional()
  controls?: IStepControl;

  @IsOptional()
  rawData?: Record<string, unknown>;

  @IsOptional()
  payloadSchema?: JSONSchema | null;

  @IsOptional()
  @IsBoolean()
  validatePayload?: boolean;

  @IsOptional()
  @IsBoolean()
  isTranslationEnabled?: boolean;

  @IsEnum(ResourceTypeEnum)
  @IsDefined()
  type: ResourceTypeEnum;

  @IsString()
  @IsOptional()
  workflowId?: string;

  @IsObject()
  @IsOptional()
  @ValidateNested({ each: true })
  @Type(() => Array<ContentIssue>)
  issues?: Record<string, RuntimeIssue[]>;

  @IsEnum(WorkflowStatusEnum)
  @IsOptional()
  status?: WorkflowStatusEnum;

  @IsOptional()
  @IsString()
  updatedBy?: string;

  /**
   * Exclude session from the command to avoid serializing it in the response
   */
  @IsOptional()
  @Exclude()
  session?: ClientSession | null;

  @IsOptional()
  @IsEnum(SeverityLevelEnum)
  severity?: SeverityLevelEnum;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateWorkflowCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v1/usecases/update-workflow/update-workflow.usecase.ts
Tamaño: 24229 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import {
  AnalyticsService,
  ContentService,
  CreateChange,
  CreateChangeCommand,
  CreateMessageTemplate,
  CreateMessageTemplateCommand,
  DeleteMessageTemplate,
  DeleteMessageTemplateCommand,
  DeletePreferencesCommand,
  DeletePreferencesUseCase,
  GetPreferences,
  Instrument,
  InstrumentUsecase,
  isVariantEmpty,
  NotificationStep,
  NotificationStepVariantCommand,
  PinoLogger,
  PlatformException,
  ResourceValidatorService,
  UpdateMessageTemplate,
  UpdateMessageTemplateCommand,
  UpsertPreferences,
  UpsertUserWorkflowPreferencesCommand,
  UpsertWorkflowPreferencesCommand,
} from '@novu/application-generic';
import {
  ChangeRepository,
  ClientSession,
  ControlValuesRepository,
  LocalizationResourceEnum,
  MessageTemplateRepository,
  NotificationGroupRepository,
  NotificationStepData,
  NotificationStepEntity,
  NotificationTemplateEntity,
  NotificationTemplateRepository,
} from '@novu/dal';
import {
  buildWorkflowPreferences,
  ChangeEntityTypeEnum,
  ControlValuesLevelEnum,
  isBridgeWorkflow,
  PreferencesTypeEnum,
  ResourceOriginEnum,
} from '@novu/shared';
import { WorkflowWithPreferencesResponseDto } from '../../dtos/get-workflow-with-preferences.dto';
import { GetWorkflowWithPreferencesCommand } from '../get-workflow-with-preferences/get-workflow-with-preferences.command';
import { GetWorkflowWithPreferencesUseCase } from '../get-workflow-with-preferences/get-workflow-with-preferences.usecase';
import { UpdateWorkflowCommand } from './update-workflow.command';

/**
 * @deprecated - use `UpsertWorkflow` instead
 */
@Injectable()
export class UpdateWorkflow {
  constructor(
    private notificationTemplateRepository: NotificationTemplateRepository,
    private messageTemplateRepository: MessageTemplateRepository,
    private changeRepository: ChangeRepository,
    private notificationGroupRepository: NotificationGroupRepository,
    private createMessageTemplate: CreateMessageTemplate,
    private updateMessageTemplate: UpdateMessageTemplate,
    private deleteMessageTemplate: DeleteMessageTemplate,
    private createChange: CreateChange,
    private analyticsService: AnalyticsService,
    private logger: PinoLogger,
    protected moduleRef: ModuleRef,
    private upsertPreferences: UpsertPreferences,
    private deletePreferencesUsecase: DeletePreferencesUseCase,
    private getWorkflowWithPreferencesUseCase: GetWorkflowWithPreferencesUseCase,
    private controlValuesRepository: ControlValuesRepository,
    private resourceValidatorService: ResourceValidatorService
  ) {}

  @InstrumentUsecase()
  async execute(command: UpdateWorkflowCommand): Promise<WorkflowWithPreferencesResponseDto> {
    await this.validatePayload(command);

    const existingTemplate = await this.getWorkflowWithPreferencesUseCase.execute(
      GetWorkflowWithPreferencesCommand.create({
        workflowIdOrInternalId: command.id,
        environmentId: command.environmentId,
        organizationId: command.organizationId,
      })
    );
    if (!existingTemplate) throw new NotFoundException(`Notification template with id ${command.id} not found`);

    let updatePayload: Partial<WorkflowWithPreferencesResponseDto> = {};
    if (command.name) {
      updatePayload.name = command.name;
    }

    if (command.active !== undefined) {
      updatePayload.active = command.active;
    }

    if (command.severity !== undefined) {
      updatePayload.severity = command.severity;
    }

    if (command.description !== undefined) {
      updatePayload.description = command.description;
    }

    if (command.workflowId) {
      const isExistingIdentifier = await this.notificationTemplateRepository.findByTriggerIdentifier(
        command.environmentId,
        command.workflowId
      );

      if (isExistingIdentifier && isExistingIdentifier._id !== command.id) {
        throw new BadRequestException(`Workflow with identifier ${command.workflowId} already exists`);
      } else {
        updatePayload['triggers.0.identifier'] = command.workflowId;
      }
    }

    if (command.notificationGroupId) {
      const notificationGroup = this.notificationGroupRepository.findOne({
        _id: command.notificationGroupId,
        _environmentId: command.environmentId,
      });

      if (!notificationGroup)
        throw new NotFoundException(
          `Notification group with id ${command.notificationGroupId} not found, under environment ${command.environmentId}`
        );

      updatePayload._notificationGroupId = command.notificationGroupId;
    }

    const parentChangeId: string = await this.changeRepository.getChangeId(
      command.environmentId,
      ChangeEntityTypeEnum.NOTIFICATION_TEMPLATE,
      existingTemplate._id
    );

    const workflowUpdate = async (session?: ClientSession | null) => {
      if (command.steps) {
        updatePayload = this.updateTriggers(updatePayload, command.steps);

        updatePayload.steps = await this.updateMessageTemplates(command.steps, command, parentChangeId);

        await this.deleteRemovedSteps(existingTemplate.steps, command, parentChangeId);
      }

      if (command.tags) {
        updatePayload.tags = command.tags;
      }

      if (command.data) {
        updatePayload.data = command.data;
      }

      if (command.rawData) {
        updatePayload.rawData = command.rawData;
      }

      if (command.payloadSchema !== undefined) {
        updatePayload.payloadSchema = command.payloadSchema;
      }

      if (command.validatePayload !== undefined) {
        updatePayload.validatePayload = command.validatePayload;
      }

      if (command.status) {
        updatePayload.status = command.status;
      }

      if (command.issues) {
        updatePayload.issues = command.issues;
      }

      updatePayload._updatedBy = command.updatedBy;

      if (command.isTranslationEnabled !== undefined) {
        await this.toggleV2TranslationsForWorkflow(existingTemplate.triggers[0].identifier, command);
      }

      // defaultPreferences is required, so we always call the upsert
      await this.upsertPreferences.upsertWorkflowPreferences(
        UpsertWorkflowPreferencesCommand.create({
          templateId: command.id,
          preferences: command.defaultPreferences,
          environmentId: command.environmentId,
          organizationId: command.organizationId,
        })
      );

      if (command.userPreferences !== undefined || command.critical !== undefined) {
        /*
         * userPreferences is optional, so we need to check if it's defined before calling the upsert.
         * we also need to check if the legacy `critical` property is defined, because if provided,
         * it's used to set the `userPreferences.all.readOnly` property
         */

        updatePayload.critical = command.critical;

        this.analyticsService.track('Workflow critical status changed', command.userId, {
          _organization: command.organizationId,
          name: updatePayload.name ?? existingTemplate.name,
          description: updatePayload.description ?? existingTemplate.description,
          new_status: command.userPreferences?.all?.readOnly,
          tags: updatePayload.tags ?? existingTemplate.tags,
        });

        /*
         * This builder pattern is only needed for the `critical` property,
         * ensuring it's set in the `userPreferences.all.readOnly` property
         * when supplied.
         *
         * TODO: remove this once we deprecate the `critical` property
         * and use only the `userPreferences` object
         */
        const defaultUserPreferences = command.userPreferences ?? existingTemplate.userPreferences;
        const defaultCritical =
          command.userPreferences?.all?.readOnly ??
          command.critical ??
          existingTemplate.userPreferences?.all?.readOnly ??
          existingTemplate.critical;

        if (command.userPreferences === null) {
          await this.deletePreferencesUsecase.execute(
            DeletePreferencesCommand.create({
              templateId: command.id,
              environmentId: command.environmentId,
              organizationId: command.organizationId,
              userId: command.userId,
              type: PreferencesTypeEnum.USER_WORKFLOW,
            })
          );
        } else {
          const userPreferences = buildWorkflowPreferences(
            {
              all: {
                readOnly: defaultCritical,
              },
            },
            defaultUserPreferences ?? undefined
          );
          await this.upsertPreferences.upsertUserWorkflowPreferences(
            UpsertUserWorkflowPreferencesCommand.create({
              templateId: command.id,
              preferences: userPreferences,
              environmentId: command.environmentId,
              organizationId: command.organizationId,
              userId: command.userId,
            })
          );

          /** @deprecated - use `userPreferences` instead */
          const preferenceSettings = GetPreferences.mapWorkflowPreferencesToChannelPreferences(userPreferences);
          updatePayload.preferenceSettings = preferenceSettings;

          this.analyticsService.track('Update Preference Defaults - [Platform]', command.userId, {
            _organization: command.organizationId,
            critical: userPreferences?.all?.readOnly ?? false,
            ...preferenceSettings,
          });
        }
      }

      if (!Object.keys(updatePayload).length) {
        throw new BadRequestException('No properties found for update');
      }

      await this.notificationTemplateRepository.update(
        {
          _id: command.id,
          _environmentId: command.environmentId,
        },
        {
          $set: updatePayload,
        },
        { session }
      );
    };

    if (command.session) {
      // If session is provided, use it (we're already in a transaction)
      await workflowUpdate(command.session);
    } else {
      // If no session, create our own transaction
      await this.notificationTemplateRepository.withTransaction(async (session) => {
        await workflowUpdate(session);
      });
    }

    const notificationTemplateWithStepTemplate = await this.getWorkflowWithPreferencesUseCase.execute(
      GetWorkflowWithPreferencesCommand.create({
        environmentId: command.environmentId,
        organizationId: command.organizationId,
        workflowIdOrInternalId: command.id,
        session: command.session,
      })
    );

    if (!isBridgeWorkflow(command.type)) {
      const notificationTemplate = this.cleanNotificationTemplate(notificationTemplateWithStepTemplate);

      await this.createChange.execute(
        CreateChangeCommand.create({
          organizationId: command.organizationId,
          environmentId: command.environmentId,
          userId: command.userId,
          type: ChangeEntityTypeEnum.NOTIFICATION_TEMPLATE,
          item: notificationTemplate,
          changeId: parentChangeId,
        })
      );
    }

    this.analyticsService.track('Update Notification Template - [Platform]', command.userId, {
      _organization: command.organizationId,
      steps: command.steps?.length,
      channels: command.steps?.map((i) => i.template?.type),
      critical: command.userPreferences?.all?.readOnly,
    });

    try {
      if (
        (process.env.NOVU_ENTERPRISE === 'true' || process.env.CI_EE_TEST === 'true') &&
        notificationTemplateWithStepTemplate.origin === ResourceOriginEnum.NOVU_CLOUD_V1
      ) {
        if (!require('@novu/ee-shared-services')?.TranslationsService) {
          throw new PlatformException('Translation module is not loaded');
        }
        const service = this.moduleRef.get(require('@novu/ee-shared-services')?.TranslationsService, { strict: false });
        const locales = await service.createTranslationAnalytics(notificationTemplateWithStepTemplate);

        this.analyticsService.track('Locale used in workflow - [Translations]', command.userId, {
          _organization: command.organizationId,
          _environment: command.environmentId,
          workflowId: command.id,
          locales,
        });
      }
    } catch (e) {
      this.logger.error(e, `Unexpected error while importing enterprise modules`, 'TranslationsService');
    }

    return notificationTemplateWithStepTemplate;
  }

  private async validatePayload(command: UpdateWorkflowCommand) {
    if (command.steps) {
      await this.resourceValidatorService.validateStepsLimit(
        command.environmentId,
        command.organizationId,
        command.steps
      );
    }

    const variants = command.steps ? command.steps?.flatMap((step) => step.variants || []) : [];

    for (const variant of variants) {
      if (isVariantEmpty(variant)) {
        throw new BadRequestException(`Variant filters are required, variant name ${variant.name} id ${variant._id}`);
      }
    }
  }

  private async toggleV2TranslationsForWorkflow(workflowIdentifier: string, command: UpdateWorkflowCommand) {
    const isEnterprise = process.env.NOVU_ENTERPRISE === 'true' || process.env.CI_EE_TEST === 'true';
    const isSelfHosted = process.env.IS_SELF_HOSTED === 'true';

    if (!isEnterprise || isSelfHosted) {
      return;
    }

    try {
      const manageTranslations = this.moduleRef.get(require('@novu/ee-translation')?.ManageTranslations, {
        strict: false,
      });

      await manageTranslations.execute({
        enabled: command.isTranslationEnabled,
        resourceId: workflowIdentifier,
        resourceType: LocalizationResourceEnum.WORKFLOW,
        organizationId: command.organizationId,
        environmentId: command.environmentId,
        userId: command.userId,
      });
    } catch (error) {
      this.logger.error(
        `Failed to ${command.isTranslationEnabled ? 'enable' : 'disable'} V2 translations for workflow`,
        {
          workflowIdentifier,
          enabled: command.isTranslationEnabled,
          organizationId: command.organizationId,
          error: error instanceof Error ? error.message : String(error),
        }
      );

      throw error;
    }
  }

  @Instrument()
  private async updateMessageTemplates(
    steps: NotificationStep[],
    command: UpdateWorkflowCommand,
    parentChangeId: string
  ) {
    let parentStepId: string | null = null;
    const templateMessages: NotificationStepEntity[] = [];

    for (const message of steps) {
      let messageTemplateId = message._id;

      if (!message.template) {
        throw new BadRequestException(`Something un-expected happened, template couldn't be found`);
      }

      const updatedVariants = await this.updateVariants(message.variants, command, parentChangeId!);

      const messageTemplatePayload: CreateMessageTemplateCommand | UpdateMessageTemplateCommand = {
        type: message.template.type,
        name: message.template.name,
        content: message.template.content,
        variables: message.template.variables,
        organizationId: command.organizationId,
        environmentId: command.environmentId,
        userId: command.userId,
        contentType: message.template.contentType,
        cta: message.template.cta,
        feedId: message.template.feedId ? message.template.feedId : undefined,
        layoutId: message.template.layoutId || null,
        subject: message.template.subject,
        title: message.template.title,
        preheader: message.template.preheader,
        senderName: message.template.senderName,
        actor: message.template.actor,
        parentChangeId,
        code: message?.template.code,
        controls: message?.template.controls,
        output: message?.template.output,
        workflowType: command.type,
      };

      let messageTemplateExist = message._templateId;

      if (!messageTemplateExist && isBridgeWorkflow(command.type)) {
        const stepMessageTemplate = await this.messageTemplateRepository.findOne({
          _environmentId: command.environmentId,
          stepId: message.stepId,
          _parentId: command.id,
        });
        messageTemplateExist = stepMessageTemplate?._id;
      }

      const updatedTemplate = messageTemplateExist
        ? await this.updateMessageTemplate.execute(
            UpdateMessageTemplateCommand.create({
              templateId: message._templateId!,
              ...messageTemplatePayload,
            })
          )
        : await this.createMessageTemplate.execute(CreateMessageTemplateCommand.create(messageTemplatePayload));

      if (!messageTemplateExist) {
        this.analyticsService.track('Workflow step added', command.userId, {
          _organization: command.organizationId,
          _environment: command.environmentId,
          workflowId: command.id,
          type: messageTemplatePayload.type,
        });
      }

      messageTemplateId = updatedTemplate._id;

      const partialNotificationStep = this.getPartialTemplateStep(
        messageTemplateId,
        parentStepId,
        message,
        updatedVariants
      );

      templateMessages.push(partialNotificationStep as NotificationStepEntity);

      parentStepId = messageTemplateId || null;
    }

    return templateMessages;
  }

  @Instrument()
  private updateTriggers(
    updatePayload: Partial<WorkflowWithPreferencesResponseDto>,
    steps: NotificationStep[]
  ): Partial<WorkflowWithPreferencesResponseDto> {
    const updatePayloadResult: Partial<WorkflowWithPreferencesResponseDto> = {
      ...updatePayload,
    };

    const contentService = new ContentService();
    const { variables, reservedVariables } = contentService.extractMessageVariables(steps);

    updatePayloadResult['triggers.0.variables'] = variables.map((i) => {
      return {
        name: i.name,
        type: i.type,
      };
    });

    updatePayloadResult['triggers.0.reservedVariables'] = reservedVariables.map((i) => {
      return {
        type: i.type,
        variables: i.variables.map((variable) => {
          return {
            name: variable.name,
            type: variable.type,
          };
        }),
      };
    });

    const subscribersVariables = contentService.extractSubscriberMessageVariables(steps);

    updatePayloadResult['triggers.0.subscriberVariables'] = subscribersVariables.map((i) => {
      return {
        name: i,
      };
    });

    return updatePayloadResult;
  }

  private getPartialTemplateStep(
    stepId: string | undefined,
    parentStepId: string | null,
    message: NotificationStep,
    updatedVariants: NotificationStepData[]
  ) {
    const partialNotificationStep: Partial<NotificationStepEntity> = {
      _id: stepId,
      _templateId: stepId,
      _parentId: parentStepId,
    };

    if (message.filters != null) {
      partialNotificationStep.filters = message.filters;
    }

    if (message.active != null) {
      partialNotificationStep.active = message.active;
    }

    if (message.metadata != null) {
      partialNotificationStep.metadata = message.metadata;
    }

    if (message.shouldStopOnFail != null) {
      partialNotificationStep.shouldStopOnFail = message.shouldStopOnFail;
    }

    if (message.replyCallback != null) {
      partialNotificationStep.replyCallback = message.replyCallback;
    }

    if (message.uuid) {
      partialNotificationStep.uuid = message.uuid;
    }

    if (message.name) {
      partialNotificationStep.name = message.name;
    }

    if (message.stepId) {
      partialNotificationStep.stepId = message.stepId;
    }

    if (updatedVariants.length) {
      partialNotificationStep.variants = updatedVariants;
    }

    if (message.issues) {
      partialNotificationStep.issues = message.issues;
    }

    return partialNotificationStep;
  }

  private cleanNotificationTemplate(notificationTemplateWithStepTemplate: NotificationTemplateEntity) {
    const notificationTemplate = {
      ...notificationTemplateWithStepTemplate,
    };

    notificationTemplate.steps = notificationTemplateWithStepTemplate.steps.map((step) => {
      const { template, ...rest } = step;

      return rest;
    });

    return notificationTemplate;
  }

  private getRemovedSteps(existingSteps: NotificationStepEntity[], newSteps: NotificationStep[]) {
    const existingStepsIds = (existingSteps || []).flatMap((step) => [
      step._templateId,
      ...(step.variants || []).flatMap((variant) => variant._templateId),
    ]);

    const newStepsIds = (newSteps || []).flatMap((step) => [
      step._templateId,
      ...(step.variants || []).flatMap((variant) => variant._templateId),
    ]);

    return existingStepsIds.filter((id) => !newStepsIds.includes(id));
  }

  private async updateVariants(
    variants: NotificationStepVariantCommand[] | undefined,
    command: UpdateWorkflowCommand,
    parentChangeId: string
  ): Promise<NotificationStepData[]> {
    if (!variants?.length) return [];

    const variantsList: NotificationStepData[] = [];
    let parentVariantId: string | null = null;

    for (const variant of variants) {
      if (!variant.template) throw new BadRequestException(`Unexpected error: variants message template is missing`);

      const messageTemplatePayload: CreateMessageTemplateCommand | UpdateMessageTemplateCommand = {
        organizationId: command.organizationId,
        environmentId: command.environmentId,
        userId: command.userId,
        type: variant.template.type,
        name: variant.template.name,
        content: variant.template.content,
        variables: variant.template.variables,
        contentType: variant.template.contentType,
        cta: variant.template.cta,
        subject: variant.template.subject,
        title: variant.template.title,
        feedId: variant.template.feedId ? variant.template.feedId : undefined,
        layoutId: variant.template.layoutId || null,
        preheader: variant.template.preheader,
        senderName: variant.template.senderName,
        actor: variant.template.actor,
        parentChangeId,
        workflowType: command.type,
      };

      const messageTemplateExist = variant._templateId;
      const updatedVariant = messageTemplateExist
        ? await this.updateMessageTemplate.execute(
            UpdateMessageTemplateCommand.create({
              templateId: variant._templateId!,
              ...messageTemplatePayload,
            })
          )
        : await this.createMessageTemplate.execute(CreateMessageTemplateCommand.create(messageTemplatePayload));

      if (!updatedVariant._id)
        throw new BadRequestException(`Unexpected error: variants message template was not created`);

      variantsList.push({
        _id: updatedVariant._id,
        _templateId: updatedVariant._id,
        filters: variant.filters,
        _parentId: parentVariantId,
        active: variant.active,
        shouldStopOnFail: variant.shouldStopOnFail,
        replyCallback: variant.replyCallback,
        uuid: variant.uuid,
        name: variant.name,
        metadata: variant.metadata,
      });

      if (updatedVariant._id) {
        parentVariantId = updatedVariant._id;
      }
    }

    return variantsList;
  }

  @Instrument()
  private async deleteRemovedSteps(
    existingSteps: NotificationStepEntity[] | NotificationStepData[] | undefined,
    command: UpdateWorkflowCommand,
    parentChangeId: string
  ) {
    const removedStepsIds = this.getRemovedSteps(existingSteps || [], command.steps || []);

    for (const id of removedStepsIds) {
      await this.deleteMessageTemplate.execute(
        DeleteMessageTemplateCommand.create({
          organizationId: command.organizationId,
          environmentId: command.environmentId,
          userId: command.userId,
          messageTemplateId: id,
          parentChangeId,
          workflowType: command.type,
        })
      );

      await this.controlValuesRepository.delete({
        _environmentId: command.environmentId,
        _organizationId: command.organizationId,
        _workflowId: command.id,
        _stepId: id,
        level: ControlValuesLevelEnum.STEP_CONTROLS,
      });
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - workflowUpdate(async (session?: ClientSession | null))
 - preferenceSettings(preferenceSettings;

          this.analyticsService.track('Update Preference Defaults - [Platform]'...)
 - notificationTemplate(this.cleanNotificationTemplate(notificationTemplateWithStepTemplate);

      await this.createChange...)
 - variants(command.steps ? command.steps?.flatMap((step))
 - steps(notificationTemplateWithStepTemplate.steps.map((step))
 - existingStepsIds(existingSteps || []).flatMap((step))
 - newStepsIds(newSteps || []).flatMap((step))
Declaraciones 'export' encontradas:
- export class UpdateWorkflow

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/maily-test-data.ts
Tamaño: 13497 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { DEFAULT_ARRAY_ELEMENTS } from '../shared/usecases/create-variables-object/create-variables-object.usecase';

export function fullCodeSnippet() {
  return {
    type: 'doc',
    content: [
      {
        type: 'logo',
        attrs: {
          src: 'https://maily.to/brand/logo.png',
          alt: null,
          title: null,
          'maily-component': 'logo',
          size: 'md',
          alignment: 'left',
        },
      },
      {
        type: 'spacer',
        attrs: {
          height: 'xl',
        },
      },
      {
        type: 'heading',
        attrs: {
          textAlign: 'left',
          level: 2,
        },
        content: [
          {
            type: 'text',
            marks: [
              {
                type: 'bold',
              },
            ],
            text: 'Discover Maily',
          },
        ],
      },
      {
        type: 'paragraph',
        attrs: {
          textAlign: 'left',
        },
        content: [
          {
            type: 'text',
            text: 'Are you ready to transform your email communication? Introducing Maily, the powerful emaly.',
          },
        ],
      },
      {
        type: 'paragraph',
        attrs: {
          textAlign: 'left',
        },
        content: [
          {
            type: 'text',
            text: 'Elevate your email communication with Maily! Click below to try it out:',
          },
        ],
      },
      {
        type: 'button',
        attrs: {
          text: 'Try Maily Now →',
          url: '',
          alignment: 'left',
          variant: 'filled',
          borderRadius: 'round',
          buttonColor: '#000000',
          textColor: '#ffffff',
        },
      },
      {
        type: 'section',
        attrs: {
          showIfKey: 'payload.params.isPayedUser',
          borderRadius: 0,
          backgroundColor: '#f7f7f7',
          align: 'left',
          borderWidth: 1,
          borderColor: '#e2e2e2',
          paddingTop: 5,
          paddingRight: 5,
          paddingBottom: 5,
          paddingLeft: 5,
          marginTop: 0,
          marginRight: 0,
          marginBottom: 0,
          marginLeft: 0,
        },
        content: [
          {
            type: 'paragraph',
            attrs: {
              textAlign: 'left',
            },
            content: [
              {
                type: 'variable',
                attrs: {
                  id: 'payload.hidden.section',
                  label: null,
                  fallback: 'should be the fallback value',
                },
              },
              {
                type: 'text',
                text: ' ',
              },
              {
                type: 'variable',
                attrs: {
                  id: 'subscriber.firstName',
                  label: null,
                  fallback: 'should be the fallback value',
                },
              },
            ],
          },
        ],
      },
      {
        type: 'paragraph',
        attrs: {
          textAlign: 'left',
        },
        content: [
          {
            type: 'text',
            text: 'Join our vibrant community of users and developers on GitHub, where Maily is an ',
          },
          {
            type: 'text',
            marks: [
              {
                type: 'link',
                attrs: {
                  href: 'https://github.com/arikchakma/maily.to',
                  target: '_blank',
                  rel: 'noopener noreferrer nofollow',
                  class: null,
                },
              },
              {
                type: 'italic',
              },
            ],
            text: 'open-source',
          },
          {
            type: 'text',
            text: " project. Together, we'll shape the future of email editing.",
          },
        ],
      },
      {
        type: 'paragraph',
        attrs: {
          textAlign: 'left',
        },
        content: [
          {
            type: 'text',
            text: '@this is a placeholder value of name payload.body|| ',
          },
          {
            type: 'variable',
            attrs: {
              id: 'payload.body',
              label: null,
              fallback: null,
            },
          },
          {
            type: 'text',
            text: ' |||the value should have been here',
          },
        ],
      },
      {
        type: 'paragraph',
        attrs: {
          textAlign: 'left',
        },
        content: [
          {
            type: 'text',
            text: 'this is a regular for block showing multiple comments:',
          },
        ],
      },
      {
        type: 'paragraph',
        attrs: {
          textAlign: 'left',
        },
        content: [
          {
            type: 'text',
            text: 'This will be two for each one in another column: ',
          },
        ],
      },
      {
        type: 'columns',
        attrs: {
          width: '100%',
        },
        content: [
          {
            type: 'column',
            attrs: {
              columnId: '394bcc6f-c674-4d56-aced-f3f54434482e',
              width: 50,
              verticalAlign: 'top',
              borderRadius: 0,
              backgroundColor: 'transparent',
              borderWidth: 0,
              borderColor: 'transparent',
              paddingTop: 0,
              paddingRight: 0,
              paddingBottom: 0,
              paddingLeft: 0,
            },
            content: [
              {
                type: 'repeat',
                attrs: {
                  each: 'payload.origins',
                  isUpdatingKey: false,
                },
                content: [
                  {
                    type: 'orderedList',
                    attrs: {
                      start: 1,
                    },
                    content: [
                      {
                        type: 'listItem',
                        attrs: {
                          color: null,
                        },
                        content: [
                          {
                            type: 'paragraph',
                            attrs: {
                              textAlign: 'left',
                            },
                            content: [
                              {
                                type: 'text',
                                text: 'a list item: ',
                              },
                              {
                                type: 'variable',
                                attrs: {
                                  id: 'payload.origins.country',
                                  label: null,
                                },
                              },
                              {
                                type: 'variable',
                                attrs: {
                                  id: 'payload.origins.id',
                                  label: null,
                                },
                              },
                              {
                                type: 'variable',
                                attrs: {
                                  id: 'payload.origins.time',
                                  label: null,
                                },
                              },
                              {
                                type: 'text',
                                text: ' ',
                              },
                            ],
                          },
                        ],
                      },
                    ],
                  },
                ],
              },
            ],
          },
          {
            type: 'column',
            attrs: {
              columnId: 'a61ae45e-ea27-4a2b-a356-bfad769ea50f',
              width: 50,
              verticalAlign: 'top',
              borderRadius: 0,
              backgroundColor: 'transparent',
              borderWidth: 0,
              borderColor: 'transparent',
              paddingTop: 0,
              paddingRight: 0,
              paddingBottom: 0,
              paddingLeft: 0,
            },
            content: [
              {
                type: 'repeat',
                attrs: {
                  each: 'payload.students',
                  isUpdatingKey: false,
                },
                content: [
                  {
                    type: 'bulletList',
                    content: [
                      {
                        type: 'listItem',
                        attrs: {
                          color: null,
                        },
                        content: [
                          {
                            type: 'paragraph',
                            attrs: {
                              textAlign: 'left',
                            },
                            content: [
                              {
                                type: 'text',
                                text: 'bulleted list item: ',
                              },
                              {
                                type: 'variable',
                                attrs: {
                                  id: 'payload.students.id',
                                  label: null,
                                },
                              },
                              {
                                type: 'text',
                                text: '  and name: ',
                              },
                              {
                                type: 'variable',
                                attrs: {
                                  id: 'payload.students.name',
                                  label: null,
                                },
                              },
                              {
                                type: 'text',
                                text: ' ',
                              },
                            ],
                          },
                        ],
                      },
                      {
                        type: 'listItem',
                        attrs: {
                          color: null,
                        },
                        content: [
                          {
                            type: 'paragraph',
                            attrs: {
                              textAlign: 'left',
                            },
                            content: [
                              {
                                type: 'text',
                                text: 'buffer bullet item',
                              },
                            ],
                          },
                        ],
                      },
                    ],
                  },
                ],
              },
            ],
          },
        ],
      },
      {
        type: 'paragraph',
        attrs: {
          textAlign: 'left',
        },
      },
      {
        type: 'paragraph',
        attrs: {
          textAlign: 'left',
        },
        content: [
          {
            type: 'text',
            text: 'This will be a nested repeat block',
          },
        ],
      },
      {
        type: 'repeat',
        attrs: {
          each: 'payload.food.items',
          isUpdatingKey: false,
        },
        content: [
          {
            type: 'paragraph',
            attrs: {
              textAlign: 'left',
            },
            content: [
              {
                type: 'text',
                text: 'this is a food item with name  ',
              },
              {
                type: 'variable',
                attrs: {
                  id: 'payload.food.items.name',
                  label: null,
                },
              },
              {
                type: 'text',
                text: ' ',
              },
            ],
          },
        ],
      },
      {
        type: 'paragraph',
        attrs: {
          textAlign: 'left',
        },
      },
      {
        type: 'paragraph',
        attrs: {
          textAlign: 'left',
        },
        content: [
          {
            type: 'text',
            text: 'Regards,',
          },
          {
            type: 'hardBreak',
          },
          {
            type: 'text',
            text: 'Arikko',
          },
        ],
      },
    ],
  };
}

export function previewPayloadExample() {
  return {
    payload: {
      subject: {
        test: {
          payload: 'payload',
        },
      },
      params: {
        isPayedUser: true,
      },
      hidden: {
        section: 'section',
      },
      body: 'body',
      origins: Array(DEFAULT_ARRAY_ELEMENTS).fill({
        country: 'country',
        id: 'id',
        time: 'time',
      }),
      students: Array(DEFAULT_ARRAY_ELEMENTS).fill({
        id: 'id',
        name: 'name',
      }),
      food: {
        items: Array(DEFAULT_ARRAY_ELEMENTS).fill({
          name: 'name',
        }),
      },
    },
    subscriber: {
      firstName: 'John',
      lastName: 'Doe',
      email: 'user@example.com',
      phone: '+1234567890',
      avatar: 'https://example.com/avatar.png',
      locale: 'en_US',
      timezone: 'America/New_York',
      data: {},
    },
    steps: {},
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - fullCodeSnippet()
 - previewPayloadExample()
Declaraciones 'export' encontradas:
- export function fullCodeSnippet
- export function previewPayloadExample

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/workflow.controller.e2e.ts
Tamaño: 52501 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import {
  ContentIssueEnum,
  CreateWorkflowDto,
  DigestStepUpsertDto,
  EmailStepResponseDto,
  EmailStepUpsertDto,
  InAppStepResponseDto,
  InAppStepUpsertDto,
  JSONSchemaDto,
  ListWorkflowResponse,
  ResourceOriginEnum,
  StepTypeEnum,
  UpdateWorkflowDto,
  UpdateWorkflowDtoSteps,
  WorkflowCreationSourceEnum,
  WorkflowListResponseDto,
  WorkflowStatusEnum,
} from '@novu/api/models/components';
import { ErrorDto } from '@novu/api/models/errors';
import { WorkflowResponseDto } from '@novu/api/src/models/components';
import { PreferencesRepository } from '@novu/dal';
import {
  ApiServiceLevelEnum,
  DEFAULT_WORKFLOW_PREFERENCES,
  FeatureNameEnum,
  getFeatureForTierAsNumber,
  ShortIsPrefixEnum,
  slugify,
} from '@novu/shared';
import { UserSession } from '@novu/testing';
import chai, { expect } from 'chai';
import chaiSubset from 'chai-subset';
import { buildSlug } from '../shared/helpers/build-slug';
import {
  expectSdkExceptionGeneric,
  expectSdkValidationExceptionGeneric,
  initNovuClassSdkInternalAuth,
} from '../shared/helpers/e2e/sdk/e2e-sdk.helper';

chai.use(chaiSubset);

// TODO: Introduce test factories for steps and workflows and move the following build functions there
function buildInAppStep(overrides: Partial<InAppStepUpsertDto> = {}): InAppStepUpsertDto {
  return {
    name: 'In-App Test Step',
    type: 'in_app',
    controlValues: {
      subject: 'Test Subject',
      body: 'Test Body',
    },
    ...overrides,
  } as InAppStepUpsertDto;
}

function buildDigestStep(overrides: Partial<DigestStepUpsertDto> = {}): DigestStepUpsertDto {
  return {
    name: 'Digest Test Step',
    type: 'digest',
    controlValues: {
      amount: 1,
      unit: 'hours',
    },
    ...overrides,
  } as DigestStepUpsertDto;
}

function buildEmailStep(overrides: Partial<EmailStepUpsertDto> = {}): EmailStepUpsertDto {
  return {
    name: 'Email Test Step',
    type: 'email',
    controlValues: {
      subject: 'Test Email Subject',
      body: 'Test Email Body',
      disableOutputSanitization: false,
    },
    ...overrides,
  } as EmailStepUpsertDto;
}

// biome-ignore lint/suspicious/noExportsInTest: <explanation>
export function buildWorkflow(overrides: Partial<CreateWorkflowDto> = {}): CreateWorkflowDto {
  const name = overrides.name || 'Test Workflow';

  return {
    source: WorkflowCreationSourceEnum.Editor,
    name,
    workflowId: slugify(name),
    description: 'This is a test workflow',
    active: true,
    tags: ['tag1', 'tag2'],
    steps: [buildEmailStep(), buildInAppStep()],
    ...overrides,
  } as CreateWorkflowDto;
}

let session: UserSession;

function buildHeaders(overrideEnv?: string): HeadersInit {
  return {
    Authorization: session.token,
    'Novu-Environment-Id': overrideEnv || session.environment._id,
  };
}

async function createWorkflowAndExpectError(
  apiClient: Novu,
  createWorkflowDto: CreateWorkflowDto,
  expectedPartialErrorMsg?: string
): Promise<ErrorDto> {
  const res = await expectSdkExceptionGeneric(() => apiClient.workflows.create(createWorkflowDto));
  expect(res.error).to.be.ok;
  if (expectedPartialErrorMsg) {
    expect(res.error?.message).to.include(expectedPartialErrorMsg);
  }

  return res.error!;
}
async function createWorkflowAndExpectValidationError(
  apiClient: Novu,
  createWorkflowDto: CreateWorkflowDto,
  expectedPartialErrorMsg?: string
): Promise<ErrorDto> {
  const res = await expectSdkValidationExceptionGeneric(() => apiClient.workflows.create(createWorkflowDto));
  expect(res.error).to.be.ok;
  if (expectedPartialErrorMsg) {
    expect(JSON.stringify(res.error?.errors)).to.include(expectedPartialErrorMsg);
  }

  return res.error!;
}
async function createWorkflow(apiClient: Novu, createWorkflowDto: CreateWorkflowDto) {
  return (await apiClient.workflows.create(createWorkflowDto)).result;
}

describe('Workflow Controller E2E API Testing #novu-v2', () => {
  let apiClient: Novu;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    apiClient = initNovuClassSdkInternalAuth(session);
  });

  describe('Create workflow', () => {
    it('should allow creating two workflows for the same user with the same name', async () => {
      const name = `Test Workflow${new Date().toISOString()}`;
      await createWorkflowAndValidate(name);
      const createWorkflowDto: CreateWorkflowDto = buildWorkflow({ name });
      const workflowCreated = await createWorkflow(apiClient, createWorkflowDto);
      expect(workflowCreated.workflowId).to.include(`${slugify(name)}-`);
    });

    it('should generate a payload schema if only control values are provided during workflow creation', async () => {
      const steps: UpdateWorkflowDtoSteps[] = [
        {
          ...buildEmailStep(),
          controlValues: {
            body: 'Welcome {{payload.name}}',
            subject: 'Hello {{payload.name}}',
          },
        } as UpdateWorkflowDtoSteps,
      ];

      const createWorkflowDto: CreateWorkflowDto = buildWorkflow({
        steps,
        payloadSchema: {
          type: 'object',
          properties: {
            name: { type: 'string' },
          },
          required: [],
          additionalProperties: false,
        },
      });
      const workflow = await createWorkflow(apiClient, createWorkflowDto);

      expect(workflow).to.be.ok;

      expect(workflow.steps[0].variables).to.be.ok;

      const stepData = await getStepData(workflow.id, workflow.steps[0].id);
      expect(stepData.variables).to.be.ok;

      const { properties } = stepData.variables as JSONSchemaDto;
      expect(properties).to.be.ok;

      const payloadProperties = properties?.payload as JSONSchemaDto;
      expect(payloadProperties).to.be.ok;
      expect(payloadProperties.properties?.name).to.be.ok;
    });

    it('should not allow to create more than 20 workflows for a free organization', async () => {
      await session.updateOrganizationServiceLevel(ApiServiceLevelEnum.FREE);
      getFeatureForTierAsNumber(FeatureNameEnum.PLATFORM_MAX_WORKFLOWS, ApiServiceLevelEnum.FREE, false);
      for (let i = 0; i < 20; i += 1) {
        const createWorkflowDto: CreateWorkflowDto = buildWorkflow({ name: new Date().toISOString() + i });
        await createWorkflow(apiClient, createWorkflowDto);
      }

      const createWorkflowDto: CreateWorkflowDto = buildWorkflow({ name: new Date().toISOString() });
      const error = await createWorkflowAndExpectError(apiClient, createWorkflowDto);
      expect(error?.statusCode).eq(400);
    });

    it('should create workflow with payloadSchema and validatePayload fields', async () => {
      const payloadSchema = {
        type: 'object',
        properties: {
          name: {
            type: 'string',
            description: 'User name',
          },
          age: {
            type: 'number',
            minimum: 0,
          },
        },
        required: ['name'],
      };

      const createWorkflowDto: CreateWorkflowDto = {
        ...buildWorkflow({
          name: `Test Workflow with Schema ${new Date().toISOString()}`,
        }),
        payloadSchema,
        validatePayload: true,
      };

      const workflowCreated = await createWorkflow(apiClient, createWorkflowDto);

      expect(workflowCreated).to.be.ok;
      expect(workflowCreated.payloadSchema).to.deep.equal(payloadSchema);
      expect(workflowCreated.validatePayload).to.be.true;
    });

    it('should create workflow with validatePayload false', async () => {
      const createWorkflowDto: CreateWorkflowDto = {
        ...buildWorkflow({
          name: `Test Workflow No Validation ${new Date().toISOString()}`,
        }),
        validatePayload: false,
      };

      const workflowCreated = await createWorkflow(apiClient, createWorkflowDto);

      expect(workflowCreated).to.be.ok;
      expect(workflowCreated.validatePayload).to.be.false;
    });

    it('should reject workflow creation with invalid JSON schema', async () => {
      const invalidPayloadSchema = {
        type: 'invalid-type',
        properties: 'not-an-object',
      };

      const createWorkflowDto: CreateWorkflowDto = {
        ...buildWorkflow({
          name: `Test Invalid Schema ${new Date().toISOString()}`,
        }),
        payloadSchema: invalidPayloadSchema,
      };

      const error = await createWorkflowAndExpectValidationError(apiClient, createWorkflowDto);
      expect(error?.statusCode).to.equal(422);
      expect(JSON.stringify(error)).to.include('payloadSchema must be a valid JSON schema');
    });
  });

  describe('Update workflow', () => {
    it('should update control values', async () => {
      const nameSuffix = `Test Workflow${new Date().toISOString()}`;
      const workflowCreated: WorkflowResponseDto = await createWorkflowAndValidate(nameSuffix);
      const inAppControlValue = 'In-App Test';
      const emailControlValue = 'Email Test';
      const updateRequest: UpdateWorkflowDto = {
        origin: ResourceOriginEnum.NovuCloud,
        name: workflowCreated.name,
        preferences: {
          user: null,
        },
        steps: [
          buildInAppStep({ controlValues: { subject: inAppControlValue } }),
          buildEmailStep({ controlValues: { subject: emailControlValue } }),
        ],
        workflowId: workflowCreated.workflowId,
      } as UpdateWorkflowDto;
      const updatedWorkflow: WorkflowResponseDto = await updateWorkflow(
        workflowCreated.id,
        updateRequest as UpdateWorkflowDto
      );
      // TODO: Control values must be typed and accept only valid control values
      expect((updatedWorkflow.steps[0] as InAppStepResponseDto).controls.values.subject).to.be.equal(inAppControlValue);
      expect((updatedWorkflow.steps[1] as EmailStepResponseDto).controls.values.subject).to.be.equal(emailControlValue);
    });

    it('should keep the step id on updated ', async () => {
      const nameSuffix = `Test Workflow${new Date().toISOString()}`;
      const workflowCreated: WorkflowResponseDto = await createWorkflowAndValidate(nameSuffix);
      const updatedWorkflow = await updateWorkflow(workflowCreated.id, mapResponseToUpdateDto(workflowCreated));
      const updatedStep = updatedWorkflow.steps[0];
      const originalStep = workflowCreated.steps[0];
      expect(updatedStep.id).to.be.ok;
      expect(updatedStep.id).to.be.equal(originalStep.id);
    });

    it('should keep the step id on updated ', async () => {
      const nameSuffix = `Test Workflow${new Date().toISOString()}`;
      const workflowCreated: WorkflowResponseDto = await createWorkflowAndValidate(nameSuffix);
      expect(workflowCreated.steps.length).to.be.equal(2);

      // Verify that all step ids are unique
      const stepIds1 = workflowCreated.steps.map((step) => step.id);
      const uniqueStepIds1 = [...new Set(stepIds1)];
      expect(stepIds1.length).to.equal(uniqueStepIds1.length, 'All step ids should be unique on creation');

      // Add a step of an existing channel at the beginning of the steps array
      workflowCreated.steps = [buildInAppStep(), ...workflowCreated.steps] as any;
      const updatedWorkflow = await updateWorkflow(workflowCreated.id, mapResponseToUpdateDto(workflowCreated));
      expect(updatedWorkflow.steps.length).to.be.equal(3);

      // Verify that all step ids are unique
      const stepIds2 = workflowCreated.steps.map((step) => step.id);
      const uniqueStepIds2 = [...new Set(stepIds2)];
      expect(stepIds2.length).to.equal(uniqueStepIds2.length, 'All step ids should be unique after update');
    });

    it('should update user preferences', async () => {
      const nameSuffix = `Test Workflow${new Date().toISOString()}`;
      const workflowCreated: WorkflowResponseDto = await createWorkflowAndValidate(nameSuffix);
      const updatedWorkflow = await updateWorkflow(workflowCreated.id, {
        ...mapResponseToUpdateDto(workflowCreated),
        preferences: {
          user: { ...DEFAULT_WORKFLOW_PREFERENCES, all: { ...DEFAULT_WORKFLOW_PREFERENCES.all, enabled: false } },
        },
      });
      expect(updatedWorkflow.preferences.user, JSON.stringify(updatedWorkflow, null, 2)).to.be.ok;
      expect(updatedWorkflow.preferences?.user?.all.enabled, JSON.stringify(updatedWorkflow, null, 2)).to.be.false;

      const updatedWorkflow2 = await updateWorkflow(workflowCreated.id, {
        ...mapResponseToUpdateDto(workflowCreated),
        preferences: {
          user: null,
        },
      });
      expect(updatedWorkflow2.preferences.user).to.be.null;
      expect(updatedWorkflow2.preferences.default).to.be.ok;
    });

    it('should update by slugify ids', async () => {
      const workflowCreated = await createWorkflowAndValidate();
      const { id, workflowId, slug, updatedAt } = workflowCreated;

      await updateWorkflowAndValidate(id, updatedAt, {
        ...mapResponseToUpdateDto(workflowCreated),
        name: 'Test Workflow 1',
      });
      await updateWorkflowAndValidate(workflowId, updatedAt, {
        ...mapResponseToUpdateDto(workflowCreated),
        name: 'Test Workflow 2',
      });
      await updateWorkflowAndValidate(slug, updatedAt, {
        ...mapResponseToUpdateDto(workflowCreated),
        name: 'Test Workflow 3',
      });
    });

    it('should update workflow with payloadSchema and validatePayload fields', async () => {
      const workflowCreated = await createWorkflowAndValidate();
      const payloadSchema = {
        type: 'object',
        properties: {
          email: {
            type: 'string',
            format: 'email',
          },
          count: {
            type: 'number',
            minimum: 1,
          },
        },
        required: ['email'],
      };

      const updateRequest: UpdateWorkflowDto = {
        ...mapResponseToUpdateDto(workflowCreated),
        payloadSchema,
        validatePayload: true,
      } as UpdateWorkflowDto;

      const updatedWorkflow = await updateWorkflow(workflowCreated.id, updateRequest);

      expect(updatedWorkflow).to.be.ok;
      expect(updatedWorkflow.payloadSchema).to.deep.equal(payloadSchema);
      expect(updatedWorkflow.validatePayload).to.be.true;
    });

    it('should update workflow to disable payload validation', async () => {
      const workflowCreated = await createWorkflowAndValidate();

      const updateRequest: UpdateWorkflowDto = {
        ...mapResponseToUpdateDto(workflowCreated),
        validatePayload: false,
      } as UpdateWorkflowDto;

      const updatedWorkflow = await updateWorkflow(workflowCreated.id, updateRequest);

      expect(updatedWorkflow).to.be.ok;
      expect(updatedWorkflow.validatePayload).to.be.false;
    });
  });

  describe('List workflows', () => {
    it('should not return workflows with if not matching query', async () => {
      await createWorkflowAndValidate('XYZ');
      await createWorkflowAndValidate('XYZ2');
      const workflowSummaries = await getAllAndValidate({
        searchQuery: 'ABC',
        expectedTotalResults: 0,
        expectedArraySize: 0,
      });
      expect(workflowSummaries).to.be.empty;
    });

    it('should not return workflows if offset is bigger than the amount of available workflows', async () => {
      await create10Workflows('Test Workflow');
      await getAllAndValidate({
        searchQuery: 'Test Workflow',
        offset: 11,
        limit: 15,
        expectedTotalResults: 10,
        expectedArraySize: 0,
      });
    });

    it('should return all results within range', async () => {
      await create10Workflows('Test Workflow');
      await getAllAndValidate({
        searchQuery: 'Test Workflow',
        offset: 0,
        limit: 15,
        expectedTotalResults: 10,
        expectedArraySize: 10,
      });
    });

    it('should return results without query', async () => {
      await create10Workflows('Test Workflow');
      await getAllAndValidate({
        searchQuery: 'Test Workflow',
        offset: 0,
        limit: 15,
        expectedTotalResults: 10,
        expectedArraySize: 10,
      });
    });

    it('paginate workflows without overlap', async () => {
      await create10Workflows('Test Workflow');
      const listWorkflowResponse1 = await getAllAndValidate({
        searchQuery: 'Test Workflow',
        offset: 0,
        limit: 5,
        expectedTotalResults: 10,
        expectedArraySize: 5,
      });
      const listWorkflowResponse2 = await getAllAndValidate({
        searchQuery: 'Test Workflow',
        offset: 5,
        limit: 5,
        expectedTotalResults: 10,
        expectedArraySize: 5,
      });
      const idsDeduplicated = new Set([
        ...listWorkflowResponse1.map((workflow) => workflow.id),
        ...listWorkflowResponse2.map((workflow) => workflow.id),
      ]);
      expect(idsDeduplicated.size).to.be.equal(10);
    });

    async function createV0Workflow(id: number) {
      return await createWorkflowsV1({
        name: `Test V0 Workflow${id}`,
        description: 'This is a test description',
        tags: ['test-tag-api'],
        notificationGroupId: session.notificationGroups[0]._id,
        steps: [],
      });
    }

    async function searchWorkflowsV0(workflowId?: string) {
      return await searchWorkflowsV1(workflowId);
    }

    async function getV2WorkflowIdAndExternalId(prefix: string) {
      await create10Workflows(prefix);
      const listWorkflowResponse: ListWorkflowResponse = await listWorkflows(prefix, 0, 5);
      const workflowV2Id = listWorkflowResponse.workflows[0].id;
      const { workflowId } = listWorkflowResponse.workflows[0];

      return { workflowV2Id, workflowId, name: listWorkflowResponse.workflows[0].name };
    }

    it('old list endpoint should not retrieve the new workflow', async () => {
      const { workflowV2Id, name } = await getV2WorkflowIdAndExternalId('Test Workflow');
      const [, , workflowV0Created] = await Promise.all([
        createV0Workflow(1),
        createV0Workflow(2),
        createV0Workflow(3),
      ]);
      let workflowsFromSearch = await searchWorkflowsV0(workflowV0Created?.name);
      expect(workflowsFromSearch[0]._id).to.deep.eq(workflowV0Created._id);

      workflowsFromSearch = await searchWorkflowsV0();
      const ids = workflowsFromSearch?.map((workflow) => workflow._id);
      const found = ids?.some((localId) => localId === workflowV2Id);
      expect(found, `FoundIds:${ids} SearchedID:${workflowV2Id}`).to.be.false;

      workflowsFromSearch = await searchWorkflowsV0(name);
      expect(workflowsFromSearch?.length).to.eq(0);
    });
  });

  describe('Promote workflow', () => {
    it('should promote by creating a new workflow in production environment with the same properties', async () => {
      // Create a workflow in the development environment
      const createWorkflowDto = buildWorkflow({
        name: 'Promote Workflow',
        steps: [
          buildEmailStep({
            controlValues: { body: 'Example body', subject: 'Example subject', disableOutputSanitization: false },
          }),
          buildInAppStep({
            controlValues: { body: 'Example body' },
          }),
        ],
      } as CreateWorkflowDto);
      let devWorkflow = await createWorkflow(apiClient, createWorkflowDto);

      // Update the workflow name to make sure the workflow identifier is the same after promotion
      devWorkflow = await updateWorkflow(devWorkflow.id, {
        ...mapResponseToUpdateDto(devWorkflow),
        name: `${devWorkflow.name}-updated`,
      });
      devWorkflow = await getWorkflow(devWorkflow.id);

      // Switch to production environment and get its ID
      await session.switchToProdEnvironment();
      const prodEnvironmentId = session.environment._id;
      await session.switchToDevEnvironment();

      // Promote the workflow to production
      const prodWorkflow = await syncWorkflow(devWorkflow, prodEnvironmentId);

      // Verify that the promoted workflow has a new ID but the same workflowId
      expect(prodWorkflow.id).to.not.equal(devWorkflow.id);
      expect(prodWorkflow.workflowId).to.equal(devWorkflow.workflowId);

      // Check that all non-environment-specific properties are identical
      const propertiesToCompare = ['name', 'description', 'tags', 'preferences', 'status', 'type', 'origin'];
      propertiesToCompare.forEach((prop) => {
        expect(prodWorkflow[prop]).to.deep.equal(devWorkflow[prop], `Property ${prop} should match`);
      });

      // Verify that steps are correctly promoted
      expect(prodWorkflow.steps).to.have.lengthOf(devWorkflow.steps.length);
      for (const prodStep of prodWorkflow.steps) {
        const index = prodWorkflow.steps.indexOf(prodStep);
        const devStep = devWorkflow.steps[index];

        expect(prodStep.stepId).to.equal(devStep.stepId, 'Step ID should be the same');
        expect(prodStep.controls.values).to.deep.equal(devStep.controls.values, 'Step controlValues should match');
        expect(prodStep.name).to.equal(devStep.name, 'Step name should match');
        expect(prodStep.type).to.equal(devStep.type, 'Step type should match');
      }
    });

    it('should promote by updating an existing workflow in production environment', async () => {
      // Switch to production environment and get its ID
      await session.switchToProdEnvironment();
      const prodEnvironmentId = session.environment._id;
      await session.switchToDevEnvironment();

      // Create a workflow in the development environment
      const createWorkflowDto = buildWorkflow({
        name: 'Promote Workflow',
        steps: [
          buildEmailStep({
            controlValues: {
              body: 'Example body',
              subject: 'Example subject',
              disableOutputSanitization: false,
              editorType: 'html',
            },
          }),
          buildInAppStep({
            controlValues: { body: 'Example body', disableOutputSanitization: false },
          }),
        ],
      } as CreateWorkflowDto);
      const devWorkflow = await createWorkflow(apiClient, createWorkflowDto);

      // Promote the workflow to production
      const resPromoteCreate = await apiClient.workflows.sync(
        {
          targetEnvironmentId: prodEnvironmentId,
        },
        devWorkflow.id
      );
      const prodWorkflowCreated = resPromoteCreate.result;

      // Update the workflow in the development environment
      const updateDto: UpdateWorkflowDto = {
        ...mapResponseToUpdateDto(devWorkflow),
        name: 'Updated Name',
        description: 'Updated Description',
        // modify existing Email Step, add new InApp Steps, previously existing InApp Step is removed
        steps: [
          {
            ...buildEmailStep({
              controlValues: {
                body: 'Example body',
                editorType: 'html',
                subject: 'Example subject',
                disableOutputSanitization: false,
              },
            }),
            id: devWorkflow.steps[0].id,
            name: 'Updated Email Step',
          },
          {
            ...buildInAppStep({ controlValues: { body: 'Example body', disableOutputSanitization: false } }),
            name: 'New InApp Step',
          },
        ],
      } as UpdateWorkflowDto;
      await updateWorkflowAndValidate(devWorkflow.id, devWorkflow.updatedAt, updateDto);

      // Promote the updated workflow to production
      const resPromoteUpdate = await apiClient.workflows.sync(
        {
          targetEnvironmentId: prodEnvironmentId,
        },
        devWorkflow.id
      );

      const prodWorkflowUpdated = resPromoteUpdate.result;

      // Verify that IDs remain unchanged
      expect(prodWorkflowUpdated.id).to.equal(prodWorkflowCreated.id);
      expect(prodWorkflowUpdated.workflowId).to.equal(prodWorkflowCreated.workflowId);

      // Verify updated properties
      expect(prodWorkflowUpdated.name).to.equal('Updated Name');
      expect(prodWorkflowUpdated.description).to.equal('Updated Description');
      // Verify unchanged properties
      ['status', 'type', 'origin'].forEach((prop) => {
        expect(prodWorkflowUpdated[prop]).to.deep.equal(prodWorkflowCreated[prop], `Property ${prop} should match`);
      });

      // Verify updated steps
      expect(prodWorkflowUpdated.steps).to.have.lengthOf(2);
      expect(prodWorkflowUpdated.steps[0].name).to.equal('Updated Email Step');
      expect(prodWorkflowUpdated.steps[0].id).to.equal(prodWorkflowCreated.steps[0].id);
      expect(prodWorkflowUpdated.steps[0].stepId).to.equal(prodWorkflowCreated.steps[0].stepId);
      expect(prodWorkflowUpdated.steps[0].controls.values).to.deep.equal({
        body: 'Example body',
        subject: 'Example subject',
        disableOutputSanitization: false,
        editorType: 'html',
      });

      // Verify new created step
      expect(prodWorkflowUpdated.steps[1].name).to.equal('New InApp Step');
      expect(prodWorkflowUpdated.steps[1].id).to.not.equal(prodWorkflowCreated.steps[1].id);
      expect(prodWorkflowUpdated.steps[1].stepId).to.equal('new-in-app-step');
      expect(prodWorkflowUpdated.steps[1].controls.values).to.deep.equal({
        body: 'Example body',
        disableOutputSanitization: false,
      });
    });

    it('should throw an error if trying to promote to the same environment', async () => {
      const devWorkflow = await createWorkflowAndValidate('-promote-workflow');

      const { error } = await expectSdkExceptionGeneric(() =>
        apiClient.workflows.sync(
          {
            targetEnvironmentId: session.environment._id,
          },
          devWorkflow.id
        )
      );

      expect(error?.statusCode).to.equal(400);
      expect(error?.message).to.equal('Cannot sync workflow to the same environment');
    });

    it('should throw an error if the workflow to promote is not found', async () => {
      const { error } = await expectSdkExceptionGeneric(() =>
        apiClient.workflows.sync({ targetEnvironmentId: '123' }, '123')
      );

      expect(error?.statusCode).to.equal(404);
      expect(error?.message).to.equal('Workflow cannot be found');
      expect(error?.ctx?.workflowId).to.equal('123');
    });
  });

  describe('Get workflow', () => {
    it('should get by slugify ids', async () => {
      const workflowCreated = await createWorkflowAndValidate('XYZ');

      const internalId = workflowCreated.id;
      const workflowRetrievedByInternalId = await getWorkflow(internalId);
      expect(workflowRetrievedByInternalId.id).to.equal(internalId);

      const slugPrefixAndEncodedInternalId = buildSlug(`my-workflow`, ShortIsPrefixEnum.WORKFLOW, internalId);
      const workflowRetrievedBySlugPrefixAndEncodedInternalId = await getWorkflow(slugPrefixAndEncodedInternalId);
      expect(workflowRetrievedBySlugPrefixAndEncodedInternalId.id).to.equal(internalId);

      const workflowIdentifier = workflowCreated.workflowId;
      const workflowRetrievedByWorkflowIdentifier = await getWorkflow(workflowIdentifier);
      expect(workflowRetrievedByWorkflowIdentifier.id).to.equal(internalId);
    });

    it('should return 404 if workflow does not exist', async () => {
      const notExistingId = '123';
      const novuRestResult = await expectSdkExceptionGeneric(() => apiClient.workflows.get(notExistingId));
      expect(novuRestResult.error).to.be.ok;
      expect(novuRestResult.error!.statusCode).to.equal(404);
      expect(novuRestResult.error!.message).to.contain('Workflow');
      expect(novuRestResult.error!.ctx?.workflowId).to.contain(notExistingId);
    });
  });

  describe('Duplicate workflow', () => {
    it('should duplicate a workflow', async () => {
      const workflowCreated = await createWorkflowAndValidate('XYZ');
      const duplicatedWorkflow = (
        await apiClient.workflows.duplicate(
          {
            name: 'Duplicated Workflow',
          },
          workflowCreated.id
        )
      ).result;

      expect(duplicatedWorkflow?.id).to.not.equal(workflowCreated.id);
      expect(duplicatedWorkflow?.active).to.be.false;
      expect(duplicatedWorkflow?.name).to.equal('Duplicated Workflow');
      expect(duplicatedWorkflow?.description).to.equal(workflowCreated.description);
      expect(duplicatedWorkflow?.tags).to.deep.equal(workflowCreated.tags);
      expect(duplicatedWorkflow?.steps.length).to.equal(workflowCreated.steps.length);
      duplicatedWorkflow?.steps.forEach((step, index) => {
        expect(step.name).to.equal(workflowCreated.steps[index].name);
        expect(step.id).to.not.equal(workflowCreated.steps[index].id);
      });
      expect(duplicatedWorkflow?.preferences).to.deep.equal(workflowCreated.preferences);
    });

    it('should duplicate a workflow with overrides', async () => {
      const workflowCreated = await createWorkflowAndValidate('XYZ');
      const duplicatedWorkflow = (
        await apiClient.workflows.duplicate(
          {
            name: 'Duplicated Workflow',
            tags: ['tag1', 'tag2'],
            description: 'New Description',
          },
          workflowCreated.id
        )
      ).result;
      expect(duplicatedWorkflow?.id).to.not.equal(workflowCreated.id);
      expect(duplicatedWorkflow?.active).to.be.false;
      expect(duplicatedWorkflow?.name).to.equal('Duplicated Workflow');
      expect(duplicatedWorkflow?.description).to.equal('New Description');
      expect(duplicatedWorkflow?.tags).to.deep.equal(['tag1', 'tag2']);
    });

    it('should throw an error if the workflow to duplicate is not found', async () => {
      const res = await expectSdkExceptionGeneric(() =>
        apiClient.workflows.duplicate({ name: 'Duplicated Workflow' }, '123')
      );
      expect(res.error).to.be.ok;
      expect(res.error!.statusCode).to.equal(404);
      expect(res.error!.message).to.contain('Workflow');
      expect(res.error!.ctx?.workflowId).to.contain('123');
    });
  });

  describe('Get step data', () => {
    it('should get step by worflow slugify ids', async () => {
      const workflowCreated = await createWorkflowAndValidate('XYZ');
      const internalWorkflowId = workflowCreated.id;
      const stepId = workflowCreated.steps[0].id;

      const stepRetrievedByWorkflowInternalId = await getStepData(internalWorkflowId, stepId);
      expect(stepRetrievedByWorkflowInternalId.id).to.equal(stepId);

      const slugPrefixAndEncodedWorkflowInternalId = buildSlug(
        `my-workflow`,
        ShortIsPrefixEnum.WORKFLOW,
        internalWorkflowId
      );
      const stepRetrievedBySlugPrefixAndEncodedWorkflowInternalId = await getStepData(
        slugPrefixAndEncodedWorkflowInternalId,
        stepId
      );
      expect(stepRetrievedBySlugPrefixAndEncodedWorkflowInternalId.id).to.equal(stepId);

      const workflowIdentifier = workflowCreated.workflowId;
      const stepRetrievedByWorkflowIdentifier = await getStepData(workflowIdentifier, stepId);
      expect(stepRetrievedByWorkflowIdentifier.id).to.equal(stepId);
    });

    it('should get step by step slugify ids', async () => {
      const workflowCreated = await createWorkflowAndValidate('XYZ');
      const internalWorkflowId = workflowCreated.id;
      const stepId = workflowCreated.steps[0].id;

      const stepRetrievedByStepInternalId = await getStepData(internalWorkflowId, stepId);
      expect(stepRetrievedByStepInternalId.id).to.equal(stepId);

      const slugPrefixAndEncodedStepId = buildSlug(`my-step`, ShortIsPrefixEnum.STEP, stepId);
      const stepRetrievedBySlugPrefixAndEncodedStepId = await getStepData(
        internalWorkflowId,
        slugPrefixAndEncodedStepId
      );
      expect(stepRetrievedBySlugPrefixAndEncodedStepId.id).to.equal(stepId);

      const stepIdentifier = workflowCreated.steps[0].stepId;
      const stepRetrievedByStepIdentifier = await getStepData(internalWorkflowId, stepIdentifier);
      expect(stepRetrievedByStepIdentifier.id).to.equal(stepId);
    });

    describe('Variables', () => {
      it('should get step available variables', async () => {
        const steps = [
          {
            ...buildEmailStep(),
            controlValues: {
              body: 'Welcome to our newsletter {{subscriber.nonExistentValue}}{{payload.prefixBodyText2}}{{payload.prefixBodyText}}',
              editorType: 'html',
              subject: 'Welcome to our newsletter {{subjectText}} {{payload.prefixSubjectText}}',
            },
          },
          { ...buildInAppStep(), controlValues: { subject: 'Welcome to our newsletter {{inAppSubjectText}}' } },
        ];
        const createWorkflowDto: CreateWorkflowDto = buildWorkflow({
          steps: steps as UpdateWorkflowDtoSteps[],
          payloadSchema: {
            type: 'object',
            properties: {
              prefixBodyText2: { type: 'string' },
              prefixBodyText: { type: 'string' },
              prefixSubjectText: { type: 'string' },
            },
            required: [],
            additionalProperties: false,
          },
        });
        const res = await createWorkflow(apiClient, createWorkflowDto);
        const stepData = await getStepData(res.id, res.steps[0].id);
        const { variables } = stepData;

        if (typeof variables === 'boolean') throw new Error('Variables is not an object');
        const { properties } = variables;
        expect(properties).to.be.ok;
        if (!properties) throw new Error('Payload schema is not valid');
        const payloadVariables = properties.payload;
        expect(payloadVariables).to.be.ok;
        if (!payloadVariables) throw new Error('Payload schema is not valid');
        expect(JSON.stringify(payloadVariables)).to.contain('prefixBodyText2');
        expect(JSON.stringify(payloadVariables)).to.contain('prefixSubjectText');
      });
      it('should serve previous step variables with payload schema', async () => {
        const steps = [
          buildDigestStep(),
          { ...buildInAppStep(), controlValues: { subject: 'Welcome to our newsletter {{payload.inAppSubjectText}}' } },
        ];
        const createWorkflowDto: CreateWorkflowDto = buildWorkflow({
          steps: steps as UpdateWorkflowDtoSteps[],
          payloadSchema: {
            type: 'object',
            properties: {
              inAppSubjectText: { type: 'string' },
            },
            required: [],
            additionalProperties: false,
          },
        });
        const res = await createWorkflow(apiClient, createWorkflowDto);
        const novuRestResult = await apiClient.workflows.steps.retrieve(res.id, res.steps[1].id);
        const { variables } = novuRestResult.result;
        const variableList = getJsonSchemaPrimitiveProperties(variables as JSONSchemaDto);
        const hasStepVariables = variableList.some((variable) => variable.startsWith('steps.'));
        expect(hasStepVariables, JSON.stringify(variableList)).to.be.true;
      });
    });
  });

  describe('Patch workflow', () => {
    it('should work and allow us to turn workflow active on / off and have the status change accordingly', async () => {
      const workflowDto = await createWorkflow(apiClient, buildWorkflow());
      let updatedWorkflow = await patchWorkflow(workflowDto.id, false);
      expect(updatedWorkflow.status).to.equal(WorkflowStatusEnum.Inactive);
      updatedWorkflow = await patchWorkflow(workflowDto.id, true);
      expect(updatedWorkflow.status).to.equal(WorkflowStatusEnum.Active);
    });
  });

  describe('Delete workflow', () => {
    it('should delete a workflow', async () => {
      const { id, workflowId } = await createWorkflowAndValidate();
      await apiClient.workflows.delete(workflowId);
      const { error, successfulBody } = await expectSdkExceptionGeneric(() => apiClient.workflows.delete(workflowId));
      expect(error).to.be.ok;
      expect(error?.statusCode).to.equal(404);
      const preferencesRepository = new PreferencesRepository();
      const preferences = await preferencesRepository.find({
        _templateId: id,
        _organizationId: session.organization._id,
      });
      expect(preferences.length).to.equal(0);
    });
  });

  describe('Error handling', () => {
    it('should show status ok when no problems', async () => {
      const workflowCreated = await createWorkflowAndValidate();
      await getWorkflowAndValidate(workflowCreated);
    });

    describe('workflow validation issues', () => {
      it('should respond with 400 when name is empty', async () => {
        const createWorkflowDto: CreateWorkflowDto = buildWorkflow({ name: '' });

        await createWorkflowAndExpectValidationError(
          apiClient,
          createWorkflowDto,
          'name must be longer than or equal to 1 characters'
        );
      });

      it('should respond with 400 when name is too long', async () => {
        const createWorkflowDto: CreateWorkflowDto = buildWorkflow({
          name: Array.from({ length: 80 }).join('X'),
        });

        await createWorkflowAndExpectValidationError(
          apiClient,
          createWorkflowDto,
          'name must be shorter than or equal to 64 characters'
        );
      });

      it('should respond with 400 when description is too long', async () => {
        const createWorkflowDto: CreateWorkflowDto = buildWorkflow({
          description: Array.from({ length: 260 }).join('X'),
        });

        await createWorkflowAndExpectValidationError(
          apiClient,
          createWorkflowDto,
          'description must be shorter than or equal to 256 characters'
        );
      });

      it('should respond with 400 when description is too long on an update call', async () => {
        const createWorkflowDto = buildWorkflow();

        const res = await createWorkflow(apiClient, createWorkflowDto);
        const updateWorkflowDto: UpdateWorkflowDto = {
          ...mapResponseToUpdateDto(res),
          description: Array.from({ length: 260 }).join('X'),
        };

        const errorResult = await expectSdkValidationExceptionGeneric(() =>
          apiClient.workflows.update(updateWorkflowDto, res.id)
        );
        expect(errorResult.error).to.be.ok;
        expect(JSON.stringify(errorResult.error?.errors), JSON.stringify(errorResult.error)).to.include(
          'description must be shorter than or equal to 256 characters'
        );
      });

      it('should respond with 400 when a tag is too long', async () => {
        const createWorkflowDto: CreateWorkflowDto = buildWorkflow({
          tags: ['tag1', Array.from({ length: 70 }).join('X')],
        });

        await createWorkflowAndExpectValidationError(
          apiClient,
          createWorkflowDto,
          'each value in tags must be longer than or equal to 1 and shorter than or equal to 64 characters'
        );
      });

      it('should respond with 400 when a tag is empty', async () => {
        const createWorkflowDto: CreateWorkflowDto = buildWorkflow({
          tags: ['tag1', ''],
        });

        await createWorkflowAndExpectValidationError(
          apiClient,
          createWorkflowDto,
          'each value in tags must be longer than or equal to 1 and shorter than or equal to 64 characters'
        );
      });

      it('should respond with 400 when a duplicate tag is provided', async () => {
        const createWorkflowDto: CreateWorkflowDto = buildWorkflow({
          tags: ['tag1', 'tag1'],
        });

        await createWorkflowAndExpectValidationError(
          apiClient,
          createWorkflowDto,
          "All tags's elements must be unique"
        );
      });

      it('should respond with 400 when more than 16 tags are provided', async () => {
        const createWorkflowDto: CreateWorkflowDto = buildWorkflow({
          tags: Array.from({ length: 17 }).map((_, index) => `tag${index}`),
        });

        await createWorkflowAndExpectValidationError(
          apiClient,
          createWorkflowDto,
          'tags must contain no more than 16 elements'
        );
      });
    });

    describe('steps validation', () => {
      it('should throw 400 when name is empty', async () => {
        // @ts-expect-error
        const overrideDto = { steps: [{ ...buildEmailStep(), name: '' } as unknown as StepUpsertDto] };
        const createWorkflowDto: CreateWorkflowDto = buildWorkflow();
        const dtoWithoutName = { ...createWorkflowDto, ...overrideDto };

        await createWorkflowAndExpectValidationError(apiClient, dtoWithoutName, 'name');
      });

      describe('step control issues', () => {
        it('should return issues for all steps immediately', async () => {
          const createWorkflowDto: CreateWorkflowDto = buildWorkflow({
            steps: [
              {
                name: 'In-App Test Step',
                type: StepTypeEnum.InApp,
                controlValues: {
                  // body is missing on purpose
                  redirect: { url: 'not-good-url-please-replace', target: '_blank' },
                  primaryAction: {
                    label: 'primary',
                    redirect: { url: 'not-good-url-please-replace', target: '_blank' },
                  },
                  secondaryAction: {
                    label: 'secondary',
                    redirect: { url: 'not-good-url-please-replace', target: '_blank' },
                  },
                },
              },
            ],
          });

          const createdWorkflow = await createWorkflow(apiClient, createWorkflowDto);

          const stepData = await getStepData(createdWorkflow!.id, createdWorkflow!.steps[0].id);
          expect(stepData.issues!.controls!.body).to.eql([
            { message: 'Subject or body is required', issueType: 'MISSING_VALUE', variableName: 'body' },
          ]);

          // TODO: This should return a different type such as 'INVALID_URL'
          expect(stepData.issues!.controls!['redirect.url'][0].issueType).to.equal('MISSING_VALUE');
          expect(stepData.issues!.controls!['primaryAction.redirect.url'][0].issueType).to.equal('MISSING_VALUE');
          expect(stepData.issues!.controls!['secondaryAction.redirect.url'][0].issueType).to.equal('MISSING_VALUE');
        });

        it('should always show digest control value issues when illegal value provided', async () => {
          const steps = [{ ...buildDigestStep({ controlValues: { amount: 555, unit: 'days' } }) }];
          const workflowCreated = await createWorkflow(apiClient, buildWorkflow({ steps } as CreateWorkflowDto));
          const step = workflowCreated.steps[0];

          expect(step.issues?.controls?.amount[0].issueType).to.deep.equal(ContentIssueEnum.TierLimitExceeded);
          expect(step.issues?.controls?.unit[0].issueType).to.deep.equal(ContentIssueEnum.TierLimitExceeded);
        });

        it('should always show issues for illegal variables in control values', async () => {
          const createWorkflowDto: CreateWorkflowDto = buildWorkflow({
            steps: [
              {
                name: 'Email Test Step',
                type: StepTypeEnum.Email,
                controlValues: { body: 'Welcome {{}}', subject: 'Welcome {{}}' },
              },
            ],
          });

          const workflow = await createWorkflow(apiClient, createWorkflowDto);

          const stepData = await getStepData(workflow.id, workflow.steps[0].id);
          expect(stepData.issues, 'Step data should have issues').to.exist;
          expect(stepData.issues?.controls?.body, 'Step data should have body issues').to.exist;
          expect(stepData.issues?.controls?.body?.[0]?.variableName).to.equal('{{}}');
          expect(stepData.issues?.controls?.body?.[0]?.issueType).to.equal('ILLEGAL_VARIABLE_IN_CONTROL_VALUE');
        });
      });
    });
  });

  async function getWorkflow(id: string): Promise<WorkflowResponseDto> {
    const res = await apiClient.workflows.get(id);

    return res.result;
  }

  async function patchWorkflow(workflowId: string, active: boolean) {
    const res = await apiClient.workflows.patch(
      {
        active,
      },
      workflowId
    );

    return res.result;
  }

  async function updateWorkflow(id: string, workflow: UpdateWorkflowDto): Promise<WorkflowResponseDto> {
    const res = await apiClient.workflows.update(workflow, id);

    return res.result;
  }

  async function syncWorkflow(devWorkflow: WorkflowResponseDto, prodEnvironmentId: string) {
    const res = await apiClient.workflows.sync(
      {
        targetEnvironmentId: prodEnvironmentId,
      },
      devWorkflow.id
    );

    return res.result;
  }

  async function getStepData(workflowId: string, stepId: string, envId?: string) {
    const novuRestResult = await apiClient.workflows.steps.retrieve(workflowId, stepId, undefined, {
      fetchOptions: { headers: buildHeaders(envId) },
    });

    return novuRestResult.result;
  }

  async function updateWorkflowAndValidate(
    workflowRequestId: string,
    expectedPastUpdatedAt: string,
    updateRequest: UpdateWorkflowDto
  ): Promise<void> {
    const updatedWorkflow: WorkflowResponseDto = await updateWorkflow(workflowRequestId, updateRequest);
    const slug = buildSlug(updateRequest.name, ShortIsPrefixEnum.WORKFLOW, updatedWorkflow.id);

    expect(updatedWorkflow.slug).to.equal(slug);
    for (let i = 0; i < updateRequest.steps.length; i++) {
      const stepInRequest = updateRequest.steps[i];
      expect(stepInRequest.name).to.equal(updatedWorkflow.steps[i].name);
      expect(stepInRequest.type).to.equal(updatedWorkflow.steps[i].type);

      if (stepInRequest.controlValues) {
        expect(stepInRequest.controlValues).to.deep.equal(updatedWorkflow.steps[i].controls.values);
      }

      if ('id' in stepInRequest) {
        expect(buildSlug(stepInRequest.name, ShortIsPrefixEnum.STEP, stepInRequest.id!)).to.equal(
          updatedWorkflow.steps[i].slug
        );
      }
    }

    expect(new Date(updatedWorkflow.updatedAt)).to.be.greaterThan(new Date(expectedPastUpdatedAt));
  }

  async function create10Workflows(prefix: string = 'Test Workflow') {
    for (let i = 0; i < 10; i++) {
      await createWorkflowAndValidate(`${prefix}-${i}`);
    }
  }

  async function createWorkflowAndValidate(name: string = 'Test Workflow'): Promise<WorkflowResponseDto> {
    const createWorkflowDto: CreateWorkflowDto = buildWorkflow({ name });
    const res = await createWorkflow(apiClient, createWorkflowDto);
    validateCreateWorkflowResponse(res, createWorkflowDto);

    return res;
  }

  async function getWorkflowAndValidate(workflowCreated: WorkflowResponseDto) {
    const workflowRetrieved = await getWorkflow(workflowCreated.id);
    expect(workflowRetrieved).to.deep.equal(workflowCreated);
  }

  async function listWorkflows(query: string, offset: number, limit: number): Promise<ListWorkflowResponse> {
    return (await apiClient.workflows.list({ query, offset, limit })).result;
  }

  async function getAllAndValidate({
    msgPrefix = '',
    searchQuery = '',
    offset = 0,
    limit = 50,
    expectedTotalResults,
    expectedArraySize,
  }: {
    msgPrefix?: string;
    searchQuery: string;
    offset?: number;
    limit?: number;
    expectedTotalResults: number;
    expectedArraySize: number;
  }): Promise<WorkflowListResponseDto[]> {
    const listWorkflowResponse: ListWorkflowResponse = await listWorkflows(searchQuery, offset, limit);
    expect(listWorkflowResponse.workflows).lengthOf(expectedArraySize);
    expect(listWorkflowResponse.totalCount).to.be.equal(expectedTotalResults);

    return listWorkflowResponse.workflows;
  }

  function stringify(obj: unknown) {
    return JSON.stringify(obj, null, 2);
  }

  function mapResponseToUpdateDto(workflowResponse: WorkflowResponseDto): UpdateWorkflowDto {
    return {
      ...workflowResponse,
      steps: workflowResponse.steps.map(
        (step) =>
          ({
            id: step.id,
            type: step.type,
            name: step.name,
            controlValues: step.controls?.values || {},
          }) as UpdateWorkflowDtoSteps
      ),
    };
  }

  function assertWorkflowResponseBodyData(workflowResponseDto: WorkflowResponseDto) {
    expect(workflowResponseDto, stringify(workflowResponseDto)).to.be.ok;
    expect(workflowResponseDto.id, stringify(workflowResponseDto)).to.be.ok;
    expect(workflowResponseDto.updatedAt, stringify(workflowResponseDto)).to.be.ok;
    expect(workflowResponseDto.createdAt, stringify(workflowResponseDto)).to.be.ok;
    expect(workflowResponseDto.preferences, stringify(workflowResponseDto)).to.be.ok;
    expect(workflowResponseDto.status, stringify(workflowResponseDto)).to.be.ok;
    expect(workflowResponseDto.origin, stringify(workflowResponseDto)).to.be.eq(ResourceOriginEnum.NovuCloud);
    expect(Object.keys(workflowResponseDto.issues || {}).length, stringify(workflowResponseDto)).to.be.equal(0);
  }

  function assertStepResponse(workflowResponseDto: WorkflowResponseDto, createWorkflowDto: CreateWorkflowDto) {
    for (let i = 0; i < workflowResponseDto.steps.length; i++) {
      const stepInRequest = createWorkflowDto.steps[i];
      const step = workflowResponseDto.steps[i];
      expect(step.id, stringify(step)).to.be.ok;
      expect(step.slug, stringify(step)).to.be.ok;
      expect(step.name, stringify(step)).to.be.equal(stepInRequest.name);
      expect(step.type, stringify(step)).to.be.equal(stepInRequest.type);
    }
  }

  function validateCreateWorkflowResponse(
    workflowResponseDto: WorkflowResponseDto,
    createWorkflowDto: CreateWorkflowDto
  ) {
    assertWorkflowResponseBodyData(workflowResponseDto);
    assertStepResponse(workflowResponseDto, createWorkflowDto);
  }

  function getJsonSchemaPrimitiveProperties(schema: JSONSchemaDto, prefix: string = ''): string[] {
    if (!isJSONSchemaDto(schema)) {
      return [];
    }
    let properties: string[] = [];
    // Check if the schema has properties
    if (schema.properties) {
      for (const key in schema.properties) {
        const propertySchema = schema.properties[key];
        if (!isJSONSchemaDto(propertySchema)) {
          continue;
        }
        const propertyPath = prefix ? `${prefix}.${key}` : key;

        // Check if the property type is primitive
        if (isPrimitiveType(propertySchema)) {
          properties.push(propertyPath);
        } else {
          // If not primitive, recurse into the object
          properties = properties.concat(getJsonSchemaPrimitiveProperties(propertySchema, propertyPath));
        }
      }
    }

    // Check if the schema has items (for arrays)
    if (schema.items && isJSONSchemaDto(schema.items)) {
      // Assuming items is an object schema, we can treat it like a property
      if (isPrimitiveType(schema.items)) {
        properties.push(prefix); // If items are primitive, add the array itself
      } else {
        properties = properties.concat(getJsonSchemaPrimitiveProperties(schema.items, prefix));
      }
    }

    return properties;
  }

  function isJSONSchemaDto(obj: any): obj is JSONSchemaDto {
    // Check if the object has a 'type' property and is of type 'string'
    return typeof obj === 'object' && obj !== null && typeof obj.type === 'string';
  }

  function isPrimitiveType(schema: JSONSchemaDto): boolean {
    const primitiveTypes = ['string', 'number', 'boolean', 'null'];

    return primitiveTypes.includes((schema.type && (schema.type as string)) || '');
  }
});
const createWorkflowsV1 = async (templateBody: {
  name: string;
  description: string;
  tags: string[];
  notificationGroupId: string;
  steps: any[];
}): Promise<{ _id: string; name: string }> => {
  const res = await session.testAgent.post(`/v1/workflows`).send({
    name: templateBody.name,
    description: templateBody.description,
    tags: templateBody.tags,
    notificationGroupId: templateBody.notificationGroupId,
    steps: templateBody.steps,
  });
  expect(res.status).to.equal(201);

  return res.body.data;
};
const searchWorkflowsV1 = async (queryParams?: string): Promise<{ _id: string }[]> => {
  const query = new URLSearchParams();
  query.append('defaultLimit', '10');
  query.append('maxLimit', '50');
  if (queryParams) {
    query.append('query', queryParams);
  }

  const res = await session.testAgent.get(`/v1/workflows?${query.toString()}`);
  expect(res.status).to.equal(200);

  return res.body.data;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - buildInAppStep(overrides: Partial<InAppStepUpsertDto> = {})
 - buildDigestStep(overrides: Partial<DigestStepUpsertDto> = {})
 - buildEmailStep(overrides: Partial<EmailStepUpsertDto> = {})
 - buildWorkflow(overrides: Partial<CreateWorkflowDto> = {})
 - buildHeaders(overrideEnv?: string)
 - createWorkflowAndExpectError(apiClient: Novu,
  createWorkflowDto: CreateWorkflowDto,
  expectedPartialErrorMsg?: string)
 - createWorkflowAndExpectValidationError(apiClient: Novu,
  createWorkflowDto: CreateWorkflowDto,
  expectedPartialErrorMsg?: string)
 - createWorkflow(apiClient: Novu, createWorkflowDto: CreateWorkflowDto)
 - createV0Workflow(id: number)
 - searchWorkflowsV0(workflowId?: string)
 - getV2WorkflowIdAndExternalId(prefix: string)
 - getWorkflow(id: string)
 - patchWorkflow(workflowId: string, active: boolean)
 - updateWorkflow(id: string, workflow: UpdateWorkflowDto)
 - syncWorkflow(devWorkflow: WorkflowResponseDto, prodEnvironmentId: string)
 - getStepData(workflowId: string, stepId: string, envId?: string)
 - updateWorkflowAndValidate(workflowRequestId: string,
    expectedPastUpdatedAt: string,
    updateRequest: UpdateWorkflowDto)
 - create10Workflows(prefix: string = 'Test Workflow')
 - createWorkflowAndValidate(name: string = 'Test Workflow')
 - getWorkflowAndValidate(workflowCreated: WorkflowResponseDto)
 - listWorkflows(query: string, offset: number, limit: number)
 - getAllAndValidate({
    msgPrefix = '',
    searchQuery = '',
    offset = 0,
    limit = 50,
    expectedTotalResults,
    expectedArraySize,
  }: {
    msgPrefix?: string;
    searchQuery: string;
    offset?: number;
    limit?: number;
    expectedTotalResults: number;
    expectedArraySize: number;
  })
 - stringify(obj: unknown)
 - mapResponseToUpdateDto(workflowResponse: WorkflowResponseDto)
 - assertWorkflowResponseBodyData(workflowResponseDto: WorkflowResponseDto)
 - assertStepResponse(workflowResponseDto: WorkflowResponseDto, createWorkflowDto: CreateWorkflowDto)
 - validateCreateWorkflowResponse(workflowResponseDto: WorkflowResponseDto,
    createWorkflowDto: CreateWorkflowDto)
 - getJsonSchemaPrimitiveProperties(schema: JSONSchemaDto, prefix: string = '')
 - isJSONSchemaDto(obj: any)
 - isPrimitiveType(schema: JSONSchemaDto)
Asignaciones con arrow functions encontradas (posibles funciones):
 - res(await expectSdkExceptionGeneric(())
 - res(await expectSdkValidationExceptionGeneric(())
 - apiClient(initNovuClassSdkInternalAuth(session);
  });

  describe('Create workflow', ())
 - workflowCreated(await createWorkflow(apiClient, createWorkflowDto);
      expect(workflowCreated.workflowId).to.incl...)
 - payloadProperties(properties?.payload as JSONSchemaDto;
      expect(payloadProperties).to.be.ok;
      expect(payload...)
 - error(await createWorkflowAndExpectError(apiClient, createWorkflowDto);
      expect(error?.statusCode).eq...)
 - workflowCreated(await createWorkflow(apiClient, createWorkflowDto);

      expect(workflowCreated).to.be.ok;
      e...)
 - workflowCreated(await createWorkflow(apiClient, createWorkflowDto);

      expect(workflowCreated).to.be.ok;
      e...)
 - error(await createWorkflowAndExpectValidationError(apiClient, createWorkflowDto);
      expect(error?.stat...)
 - WorkflowResponseDto(await updateWorkflow(
        workflowCreated.id,
        updateRequest as UpdateWorkflowDto
      )...)
 - originalStep(workflowCreated.steps[0];
      expect(updatedStep.id).to.be.ok;
      expect(updatedStep.id).to.be....)
 - stepIds1(workflowCreated.steps.map((step))
 - stepIds2(workflowCreated.steps.map((step))
 - uniqueStepIds2([...new Set(stepIds2)];
      expect(stepIds2.length).to.equal(uniqueStepIds2.length, 'All step ids ...)
 - updatedWorkflow2(await updateWorkflow(workflowCreated.id, {
        ...mapResponseToUpdateDto(workflowCreated),
     ...)
 - updatedWorkflow(await updateWorkflow(workflowCreated.id, updateRequest);

      expect(updatedWorkflow).to.be.ok;
  ...)
 - updatedWorkflow(await updateWorkflow(workflowCreated.id, updateRequest);

      expect(updatedWorkflow).to.be.ok;
  ...)
 - workflowSummaries(await getAllAndValidate({
        searchQuery: 'ABC',
        expectedTotalResults: 0,
        expec...)
 - idsDeduplicated(new Set([
        ...listWorkflowResponse1.map((workflow))
 - ids(workflowsFromSearch?.map((workflow))
 - found(ids?.some((localId))
 - workflowsFromSearch(await searchWorkflowsV0(name);
      expect(workflowsFromSearch?.length).to.eq(0);
    });
  });

  ...)
 - propertiesToCompare(['name', 'description', 'tags', 'preferences', 'status', 'type', 'origin'];
      propertiesToCompar...)
 - devStep(devWorkflow.steps[index];

        expect(prodStep.stepId).to.equal(devStep.stepId, 'Step ID should ...)
 - prodWorkflowUpdated(resPromoteUpdate.result;

      // Verify that IDs remain unchanged
      expect(prodWorkflowUpdated...)
 - workflowRetrievedByWorkflowIdentifier(await getWorkflow(workflowIdentifier);
      expect(workflowRetrievedByWorkflowIdentifier.id).to.equ...)
 - novuRestResult(await expectSdkExceptionGeneric(())
 - duplicatedWorkflow(await apiClient.workflows.duplicate(
          {
            name: 'Duplicated Workflow',
          ...)
 - duplicatedWorkflow(await apiClient.workflows.duplicate(
          {
            name: 'Duplicated Workflow',
          ...)
 - res(await expectSdkExceptionGeneric(())
 - stepRetrievedByWorkflowIdentifier(await getStepData(workflowIdentifier, stepId);
      expect(stepRetrievedByWorkflowIdentifier.id).to...)
 - stepRetrievedByStepIdentifier(await getStepData(internalWorkflowId, stepIdentifier);
      expect(stepRetrievedByStepIdentifier.id...)
 - payloadVariables(properties.payload;
        expect(payloadVariables).to.be.ok;
        if (!payloadVariables) throw ...)
 - hasStepVariables(variableList.some((variable))
 - updatedWorkflow(await patchWorkflow(workflowDto.id, true);
      expect(updatedWorkflow.status).to.equal(WorkflowSta...)
 - preferences(await preferencesRepository.find({
        _templateId: id,
        _organizationId: session.organiz...)
 - workflowCreated(await createWorkflowAndValidate();
      await getWorkflowAndValidate(workflowCreated);
    });

   ...)
 - CreateWorkflowDto(buildWorkflow({ name: '' });

        await createWorkflowAndExpectValidationError(
          apiCli...)
 - CreateWorkflowDto(buildWorkflow({
          name: Array.from({ length: 80 }).join('X'),
        });

        await cre...)
 - CreateWorkflowDto(buildWorkflow({
          description: Array.from({ length: 260 }).join('X'),
        });

        a...)
 - errorResult(await expectSdkValidationExceptionGeneric(())
 - CreateWorkflowDto(buildWorkflow({
          tags: ['tag1', Array.from({ length: 70 }).join('X')],
        });

       ...)
 - CreateWorkflowDto(buildWorkflow({
          tags: ['tag1', ''],
        });

        await createWorkflowAndExpectVali...)
 - CreateWorkflowDto(buildWorkflow({
          tags: ['tag1', 'tag1'],
        });

        await createWorkflowAndExpect...)
 - CreateWorkflowDto(buildWorkflow({
          tags: Array.from({ length: 17 }).map((_, index))
 - dtoWithoutName({ ...createWorkflowDto, ...overrideDto };

        await createWorkflowAndExpectValidationError(apiC...)
 - stepData(await getStepData(createdWorkflow!.id, createdWorkflow!.steps[0].id);
          expect(stepData.issu...)
 - step(workflowCreated.steps[0];

          expect(step.issues?.controls?.amount[0].issueType).to.deep.equa...)
 - ListWorkflowResponse(await listWorkflows(searchQuery, offset, limit);
    expect(listWorkflowResponse.workflows).lengthOf...)
 - createWorkflowsV1(async (templateBody: {
  name: string;
  description: string;
  tags: string[];
  notificationGroupI...)
 - searchWorkflowsV1(async (queryParams?: string): Promise<{ _id: string }[]>)
Declaraciones 'export' encontradas:
- export function buildWorkflow

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/workflow.controller.ts
Tamaño: 12463 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ClassSerializerInterceptor, HttpStatus, Patch } from '@nestjs/common';
import {
  Body,
  Controller,
  Delete,
  Get,
  HttpCode,
  Param,
  Post,
  Put,
  Query,
  UseInterceptors,
} from '@nestjs/common/decorators';
import { ApiBody, ApiExcludeEndpoint, ApiOperation, ApiQuery, ApiTags } from '@nestjs/swagger';
import {
  ExternalApiAccessible,
  ParseSlugEnvironmentIdPipe,
  ParseSlugIdPipe,
  RequirePermissions,
  UserSession,
} from '@novu/application-generic';
import {
  ApiRateLimitCategoryEnum,
  DirectionEnum,
  PermissionsEnum,
  ResourceOriginEnum,
  UserSessionData,
} from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { ThrottlerCategory } from '../rate-limiting/guards/throttler.decorator';
import { ApiCommonResponses, ApiResponse } from '../shared/framework/response.decorator';
import { SdkGroupName, SdkMethodName } from '../shared/framework/swagger/sdk.decorators';
import { DeleteWorkflowCommand } from '../workflows-v1/usecases/delete-workflow/delete-workflow.command';
import { DeleteWorkflowUseCase } from '../workflows-v1/usecases/delete-workflow/delete-workflow.usecase';
import {
  CreateWorkflowDto,
  DuplicateWorkflowDto,
  GeneratePreviewRequestDto,
  GeneratePreviewResponseDto,
  GetListQueryParamsDto,
  ListWorkflowResponse,
  PatchWorkflowDto,
  StepResponseDto,
  StepUpsertDto,
  SyncWorkflowDto,
  UpdateWorkflowDto,
  WorkflowResponseDto,
  WorkflowTestDataResponseDto,
} from './dtos';
import {
  BuildStepDataCommand,
  BuildStepDataUsecase,
  BuildWorkflowTestDataUseCase,
  DuplicateWorkflowCommand,
  DuplicateWorkflowUseCase,
  GetWorkflowCommand,
  GetWorkflowUseCase,
  ListWorkflowsCommand,
  ListWorkflowsUseCase,
  PreviewCommand,
  PreviewUsecase,
  SyncToEnvironmentCommand,
  SyncToEnvironmentUseCase,
  UpsertStepDataCommand,
  UpsertWorkflowCommand,
  UpsertWorkflowUseCase,
  WorkflowTestDataCommand,
} from './usecases';
import { PatchWorkflowCommand, PatchWorkflowUsecase } from './usecases/patch-workflow';

@ThrottlerCategory(ApiRateLimitCategoryEnum.CONFIGURATION)
@ApiCommonResponses()
@Controller({ path: `/workflows`, version: '2' })
@UseInterceptors(ClassSerializerInterceptor)
@RequireAuthentication()
@ApiTags('Workflows')
export class WorkflowController {
  constructor(
    private upsertWorkflowUseCase: UpsertWorkflowUseCase,
    private getWorkflowUseCase: GetWorkflowUseCase,
    private listWorkflowsUseCase: ListWorkflowsUseCase,
    private deleteWorkflowUsecase: DeleteWorkflowUseCase,
    private syncToEnvironmentUseCase: SyncToEnvironmentUseCase,
    private previewUsecase: PreviewUsecase,
    private buildWorkflowTestDataUseCase: BuildWorkflowTestDataUseCase,
    private buildStepDataUsecase: BuildStepDataUsecase,
    private patchWorkflowUsecase: PatchWorkflowUsecase,
    private duplicateWorkflowUseCase: DuplicateWorkflowUseCase
  ) {}

  @Post('')
  @ApiOperation({
    summary: 'Create a workflow',
    description: 'Creates a new workflow in the Novu Cloud environment',
  })
  @ExternalApiAccessible()
  @ApiBody({ type: CreateWorkflowDto, description: 'Workflow creation details' })
  @ApiResponse(WorkflowResponseDto, 201)
  @RequirePermissions(PermissionsEnum.WORKFLOW_WRITE)
  async create(
    @UserSession(ParseSlugEnvironmentIdPipe) user: UserSessionData,
    @Body() createWorkflowDto: CreateWorkflowDto
  ): Promise<WorkflowResponseDto> {
    const upsertSteps = this.normalizeSteps(createWorkflowDto.steps);

    return this.upsertWorkflowUseCase.execute(
      UpsertWorkflowCommand.create({
        preserveWorkflowId: true,
        workflowDto: {
          ...createWorkflowDto,
          steps: upsertSteps,
          origin: ResourceOriginEnum.NOVU_CLOUD,
        },
        user,
      })
    );
  }

  @Put(':workflowId/sync')
  @ExternalApiAccessible()
  @ApiOperation({
    summary: 'Sync a workflow',
    description: 'Synchronizes a workflow to the target environment',
  })
  @ApiBody({ type: SyncWorkflowDto, description: 'Sync workflow details' })
  @ApiResponse(WorkflowResponseDto)
  @SdkMethodName('sync')
  @RequirePermissions(PermissionsEnum.WORKFLOW_WRITE)
  async sync(
    @UserSession() user: UserSessionData,
    @Param('workflowId', ParseSlugIdPipe) workflowIdOrInternalId: string,
    @Body() syncWorkflowDto: SyncWorkflowDto
  ): Promise<WorkflowResponseDto> {
    return this.syncToEnvironmentUseCase.execute(
      SyncToEnvironmentCommand.create({
        user,
        workflowIdOrInternalId,
        targetEnvironmentId: syncWorkflowDto.targetEnvironmentId,
      })
    );
  }

  @Put(':workflowId')
  @ExternalApiAccessible()
  @ApiOperation({
    summary: 'Update a workflow',
    description: 'Updates the details of an existing workflow, here **workflowId** is the identifier of the workflow',
  })
  @ApiBody({ type: UpdateWorkflowDto, description: 'Workflow update details' })
  @ApiResponse(WorkflowResponseDto)
  @RequirePermissions(PermissionsEnum.WORKFLOW_WRITE)
  async update(
    @UserSession(ParseSlugEnvironmentIdPipe) user: UserSessionData,
    @Param('workflowId', ParseSlugIdPipe) workflowIdOrInternalId: string,
    @Body() updateWorkflowDto: UpdateWorkflowDto
  ): Promise<WorkflowResponseDto> {
    const upsertSteps = this.normalizeSteps(updateWorkflowDto.steps);

    return await this.upsertWorkflowUseCase.execute(
      UpsertWorkflowCommand.create({
        workflowDto: {
          ...updateWorkflowDto,
          steps: upsertSteps,
        },
        user,
        workflowIdOrInternalId,
      })
    );
  }

  private normalizeSteps(steps: StepUpsertDto[]): UpsertStepDataCommand[] {
    return steps.map((step: StepUpsertDto) => ({
      ...step,
      controlValues: (step.controlValues as Record<string, unknown> | null | undefined) ?? null,
    }));
  }

  @Get(':workflowId')
  @ExternalApiAccessible()
  @ApiOperation({
    summary: 'Retrieve a workflow',
    description: 'Fetches details of a specific workflow by its unique identifier **workflowId**',
  })
  @ApiResponse(WorkflowResponseDto)
  @ApiQuery({
    name: 'environmentId',
    type: String,
    required: false,
  })
  @SdkMethodName('get')
  @RequirePermissions(PermissionsEnum.WORKFLOW_READ)
  async getWorkflow(
    @UserSession(ParseSlugEnvironmentIdPipe) user: UserSessionData,
    @Param('workflowId', ParseSlugIdPipe) workflowIdOrInternalId: string,
    @Query('environmentId') environmentId?: string
  ): Promise<WorkflowResponseDto> {
    return this.getWorkflowUseCase.execute(
      GetWorkflowCommand.create({
        workflowIdOrInternalId,
        user: {
          ...user,
          environmentId: environmentId || user.environmentId,
        },
      })
    );
  }

  @Delete(':workflowId')
  @ExternalApiAccessible()
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({
    summary: 'Delete a workflow',
    description: 'Removes a specific workflow by its unique identifier **workflowId**',
  })
  @SdkMethodName('delete')
  @RequirePermissions(PermissionsEnum.WORKFLOW_WRITE)
  async removeWorkflow(
    @UserSession(ParseSlugEnvironmentIdPipe) user: UserSessionData,
    @Param('workflowId', ParseSlugIdPipe) workflowIdOrInternalId: string
  ) {
    await this.deleteWorkflowUsecase.execute(
      DeleteWorkflowCommand.create({
        workflowIdOrInternalId,
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
      })
    );
  }

  @Get('')
  @ExternalApiAccessible()
  @ApiOperation({
    summary: 'List all workflows',
    description: 'Retrieves a list of workflows with optional filtering and pagination',
  })
  @ApiResponse(ListWorkflowResponse)
  @SdkMethodName('list')
  @RequirePermissions(PermissionsEnum.WORKFLOW_READ)
  async searchWorkflows(
    @UserSession(ParseSlugEnvironmentIdPipe) user: UserSessionData,
    @Query() query: GetListQueryParamsDto
  ): Promise<ListWorkflowResponse> {
    return this.listWorkflowsUseCase.execute(
      ListWorkflowsCommand.create({
        offset: Number(query.offset || '0'),
        limit: Number(query.limit || '50'),
        orderDirection: query.orderDirection ?? DirectionEnum.DESC,
        orderBy: query.orderBy ?? 'createdAt',
        searchQuery: query.query,
        tags: query.tags,
        status: query.status,
        user,
      })
    );
  }

  @Post(':workflowId/duplicate')
  @ApiOperation({
    summary: 'Duplicate a workflow',
    description:
      'Duplicates a workflow by its unique identifier **workflowId**. This will create a new workflow with the same steps and settings.',
  })
  @ApiBody({ type: DuplicateWorkflowDto })
  @ApiResponse(WorkflowResponseDto, 201)
  @SdkMethodName('duplicate')
  @RequirePermissions(PermissionsEnum.WORKFLOW_WRITE)
  async duplicateWorkflow(
    @UserSession(ParseSlugEnvironmentIdPipe) user: UserSessionData,
    @Param('workflowId', ParseSlugIdPipe) workflowIdOrInternalId: string,
    @Body() duplicateWorkflowDto: DuplicateWorkflowDto
  ): Promise<WorkflowResponseDto> {
    return this.duplicateWorkflowUseCase.execute(
      DuplicateWorkflowCommand.create({
        user,
        workflowIdOrInternalId,
        overrides: duplicateWorkflowDto,
      })
    );
  }

  @Post('/:workflowId/step/:stepId/preview')
  @ApiOperation({
    summary: 'Generate step preview',
    description: 'Generates a preview for a specific workflow step by its unique identifier **stepId**',
  })
  @ApiBody({ type: GeneratePreviewRequestDto, description: 'Preview generation details' })
  @ApiResponse(GeneratePreviewResponseDto, 201)
  @SdkGroupName('Workflows.Steps')
  @SdkMethodName('generatePreview')
  @RequirePermissions(PermissionsEnum.WORKFLOW_READ)
  async generatePreview(
    @UserSession(ParseSlugEnvironmentIdPipe) user: UserSessionData,
    @Param('workflowId', ParseSlugIdPipe) workflowIdOrInternalId: string,
    @Param('stepId', ParseSlugIdPipe) stepIdOrInternalId: string,
    @Body() generatePreviewRequestDto: GeneratePreviewRequestDto
  ): Promise<GeneratePreviewResponseDto> {
    return await this.previewUsecase.execute(
      PreviewCommand.create({
        user,
        workflowIdOrInternalId,
        stepIdOrInternalId,
        generatePreviewRequestDto,
      })
    );
  }

  @Get('/:workflowId/steps/:stepId')
  @ApiOperation({
    summary: 'Retrieve workflow step',
    description: 'Retrieves data for a specific step in a workflow',
  })
  @ApiResponse(StepResponseDto)
  @ExternalApiAccessible()
  @SdkGroupName('Workflows.Steps')
  @SdkMethodName('retrieve')
  @RequirePermissions(PermissionsEnum.WORKFLOW_READ)
  async getWorkflowStepData(
    @UserSession(ParseSlugEnvironmentIdPipe) user: UserSessionData,
    @Param('workflowId', ParseSlugIdPipe) workflowIdOrInternalId: string,
    @Param('stepId', ParseSlugIdPipe) stepIdOrInternalId: string
  ): Promise<StepResponseDto> {
    return await this.buildStepDataUsecase.execute(
      BuildStepDataCommand.create({ user, workflowIdOrInternalId, stepIdOrInternalId })
    );
  }

  @Patch('/:workflowId')
  @ExternalApiAccessible()
  @ApiOperation({
    summary: 'Update a workflow',
    description: 'Partially updates a workflow by its unique identifier **workflowId**',
  })
  @ApiBody({ type: PatchWorkflowDto, description: 'Workflow patch details' })
  @ApiResponse(WorkflowResponseDto)
  @SdkMethodName('patch')
  @RequirePermissions(PermissionsEnum.WORKFLOW_WRITE)
  async patchWorkflow(
    @UserSession(ParseSlugEnvironmentIdPipe) user: UserSessionData,
    @Param('workflowId', ParseSlugIdPipe) workflowIdOrInternalId: string,
    @Body() patchWorkflowDto: PatchWorkflowDto
  ): Promise<WorkflowResponseDto> {
    return await this.patchWorkflowUsecase.execute(
      PatchWorkflowCommand.create({ user, workflowIdOrInternalId, ...patchWorkflowDto })
    );
  }

  @Get('/:workflowId/test-data')
  @ApiOperation({
    summary: 'Retrieve workflow test data',
    description: 'Retrieves test data for a specific workflow by its unique identifier **workflowId**',
  })
  @ApiResponse(WorkflowTestDataResponseDto)
  @SdkMethodName('getTestData')
  @RequirePermissions(PermissionsEnum.WORKFLOW_READ)
  @ApiExcludeEndpoint()
  async getWorkflowTestData(
    @UserSession() user: UserSessionData,
    @Param('workflowId', ParseSlugIdPipe) workflowIdOrInternalId: string
  ): Promise<WorkflowTestDataResponseDto> {
    return this.buildWorkflowTestDataUseCase.execute(
      WorkflowTestDataCommand.create({
        workflowIdOrInternalId,
        user,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - upsertSteps(this.normalizeSteps(updateWorkflowDto.steps);

    return await this.upsertWorkflowUseCase.execute(
...)
Declaraciones 'export' encontradas:
- export class WorkflowController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/workflow.module.ts
Tamaño: 3873 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { MiddlewareConsumer, Module, NestModule } from '@nestjs/common';
import {
  DeletePreferencesUseCase,
  GetPreferences,
  GetWorkflowByIdsUseCase,
  ResourceValidatorService,
  TierRestrictionsValidateUsecase,
  UpsertControlValuesUseCase,
  UpsertPreferences,
} from '@novu/application-generic';

import { CommunityOrganizationRepository } from '@novu/dal';
import { AuthModule } from '../auth/auth.module';
import { BridgeModule } from '../bridge';
import { ChangeModule } from '../change/change.module';
import { IntegrationModule } from '../integrations/integrations.module';
import { LayoutsV2Module } from '../layouts-v2/layouts.module';
import { MessageTemplateModule } from '../message-template/message-template.module';
import { OutboundWebhooksModule } from '../outbound-webhooks/outbound-webhooks.module';
import { ControlValueSanitizerService } from '../shared/services/control-value-sanitizer.service';
import { SharedModule } from '../shared/shared.module';
import { CreateVariablesObject } from '../shared/usecases/create-variables-object/create-variables-object.usecase';
import { CreateWorkflow } from '../workflows-v1/usecases/create-workflow/create-workflow.usecase';
import { DeleteWorkflowUseCase } from '../workflows-v1/usecases/delete-workflow/delete-workflow.usecase';
import { GetWorkflowWithPreferencesUseCase } from '../workflows-v1/usecases/get-workflow-with-preferences/get-workflow-with-preferences.usecase';
import { UpdateWorkflow } from '../workflows-v1/usecases/update-workflow/update-workflow.usecase';
import {
  BuildStepDataUsecase,
  BuildVariableSchemaUsecase,
  BuildWorkflowTestDataUseCase,
  GetWorkflowUseCase,
  ListWorkflowsUseCase,
  PreviewUsecase,
  SyncToEnvironmentUseCase,
  UpsertWorkflowUseCase,
} from './usecases';
import { BuildStepIssuesUsecase } from './usecases/build-step-issues/build-step-issues.usecase';
import { DuplicateWorkflowUseCase } from './usecases/duplicate-workflow/duplicate-workflow.usecase';
import { PatchWorkflowUsecase } from './usecases/patch-workflow';
import { MockDataGeneratorService } from './usecases/preview/services/mock-data-generator.service';
import { PayloadMergerService } from './usecases/preview/services/payload-merger.service';
import { PreviewPayloadProcessorService } from './usecases/preview/services/preview-payload-processor.service';
import { PreviewErrorHandler } from './usecases/preview/utils/preview-error-handler';
import { WorkflowController } from './workflow.controller';

const DAL_REPOSITORIES = [CommunityOrganizationRepository];

const MODULES = [
  SharedModule,
  MessageTemplateModule,
  ChangeModule,
  AuthModule,
  BridgeModule,
  IntegrationModule,
  LayoutsV2Module,
  OutboundWebhooksModule.forRoot(),
];

@Module({
  imports: MODULES,
  controllers: [WorkflowController],
  providers: [
    ...DAL_REPOSITORIES,
    CreateWorkflow,
    UpdateWorkflow,
    UpsertWorkflowUseCase,
    ListWorkflowsUseCase,
    DeleteWorkflowUseCase,
    UpsertPreferences,
    DeletePreferencesUseCase,
    UpsertControlValuesUseCase,
    GetPreferences,
    GetWorkflowByIdsUseCase,
    GetWorkflowWithPreferencesUseCase,
    SyncToEnvironmentUseCase,
    BuildStepDataUsecase,
    PreviewUsecase,
    BuildWorkflowTestDataUseCase,
    GetWorkflowUseCase,
    DuplicateWorkflowUseCase,
    BuildVariableSchemaUsecase,
    PatchWorkflowUsecase,
    CreateVariablesObject,
    BuildStepIssuesUsecase,
    ResourceValidatorService,
    TierRestrictionsValidateUsecase,
    ControlValueSanitizerService,
    PayloadMergerService,
    PreviewPayloadProcessorService,
    MockDataGeneratorService,
    PreviewErrorHandler,
  ],
  exports: [UpsertWorkflowUseCase, SyncToEnvironmentUseCase, GetWorkflowUseCase, DeleteWorkflowUseCase],
})
export class WorkflowModule implements NestModule {
  configure(consumer: MiddlewareConsumer): MiddlewareConsumer | void {}
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class WorkflowModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/base-issue.dto.ts
Tamaño: 570 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IsOptional, IsString } from 'class-validator';

export class BaseIssueDto<T> {
  @ApiProperty({
    description: 'Type of the issue',
    type: 'string',
  })
  @IsString()
  issueType: T;

  @ApiPropertyOptional({
    description: 'Name of the variable related to the issue',
    type: 'string',
  })
  @IsOptional()
  @IsString()
  variableName?: string;

  @ApiProperty({
    description: 'Detailed message describing the issue',
    type: 'string',
  })
  @IsString()
  message: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class BaseIssueDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/base-step-issue.dto.ts
Tamaño: 650 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { ContentIssueEnum, IntegrationIssueEnum } from '@novu/shared';
import { IsEnum } from 'class-validator';
import { BaseIssueDto } from './base-issue.dto';

export class StepIssueDto extends BaseIssueDto<ContentIssueEnum | IntegrationIssueEnum> {
  @ApiProperty({
    description: 'Type of step issue',
    enum: [...Object.values(ContentIssueEnum), ...Object.values(IntegrationIssueEnum)],
    enumName: 'ContentIssueEnum | IntegrationIssueEnum',
  })
  @IsEnum([...Object.values(ContentIssueEnum), ...Object.values(IntegrationIssueEnum)])
  issueType: ContentIssueEnum | IntegrationIssueEnum;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class StepIssueDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/channel-preference.dto.ts
Tamaño: 354 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IsBoolean } from 'class-validator';

export class ChannelPreferenceDto {
  @ApiProperty({
    description:
      'A flag specifying if notification delivery is enabled for the channel. If true, notification delivery is enabled.',
    default: true,
  })
  @IsBoolean()
  enabled: boolean = true;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ChannelPreferenceDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/control-schemas.dto.ts
Tamaño: 195 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { JSONSchemaDto } from '../../shared/dtos/json-schema.dto';
import { UiSchema } from './ui-schema.dto';

export class ControlSchemasDto {
  schema: JSONSchemaDto;
  uiSchema?: UiSchema;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ControlSchemasDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/controls-metadata.dto.ts
Tamaño: 636 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional } from '@nestjs/swagger';
import { IsOptional, ValidateNested } from 'class-validator';
import { JSONSchemaDto } from '../../shared/dtos/json-schema.dto';
import { UiSchema } from './ui-schema.dto';

export class ControlsMetadataDto {
  @ApiPropertyOptional({
    description: 'JSON Schema for data',
    additionalProperties: true,
    type: () => Object,
  })
  @IsOptional()
  @ValidateNested()
  dataSchema?: JSONSchemaDto;

  @ApiPropertyOptional({
    description: 'UI Schema for rendering',
    type: UiSchema,
  })
  @IsOptional()
  @ValidateNested()
  uiSchema?: UiSchema;

  [key: string]: any;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ControlsMetadataDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/create-step.dto.ts
Tamaño: 6629 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional, getSchemaPath } from '@nestjs/swagger';
import { StepTypeEnum } from '@novu/shared';
import { IsEnum, IsObject, IsOptional, IsString, Matches } from 'class-validator';
import {
  ChatControlDto,
  CustomControlDto,
  DelayControlDto,
  DigestControlDto,
  EmailControlDto,
  InAppControlDto,
  PushControlDto,
  SmsControlDto,
  ThrottleControlDto,
} from './controls';

// Base DTO for common properties
export class BaseStepConfigDto {
  @ApiProperty({
    description: 'Database identifier of the step. Used for updating the step.',
    type: 'string',
    required: false,
  })
  @IsString()
  @IsOptional()
  _id?: string;

  @ApiPropertyOptional({ description: 'Unique identifier for the step' })
  @IsString()
  @Matches(/^[a-z0-9]+(?:-[a-z0-9]+)*$/, {
    message: 'must be a valid slug format (lowercase letters, numbers, and hyphens only)',
  })
  @IsOptional()
  stepId?: string;

  @ApiProperty({
    description: 'Name of the step',
  })
  @IsString()
  name: string;
}

// Specific DTOs for each step type
export class InAppStepUpsertDto extends BaseStepConfigDto {
  @ApiProperty({
    enum: StepTypeEnum,
    enumName: 'StepTypeEnum',
    description: 'Type of the step',
  })
  @IsEnum(StepTypeEnum)
  readonly type: StepTypeEnum = 'in_app' as StepTypeEnum;

  @ApiPropertyOptional({
    description: 'Control values for the In-App step.',
    oneOf: [{ $ref: getSchemaPath(InAppControlDto) }, { type: 'object', additionalProperties: true }],
  })
  @IsOptional()
  @IsObject()
  controlValues?: InAppControlDto | Record<string, unknown> | null;
}

export class EmailStepUpsertDto extends BaseStepConfigDto {
  @ApiProperty({
    enum: StepTypeEnum,
    enumName: 'StepTypeEnum',
    default: StepTypeEnum.EMAIL,
    description: 'Type of the step',
  })
  @IsEnum(StepTypeEnum)
  readonly type: StepTypeEnum = 'email' as StepTypeEnum;

  @ApiPropertyOptional({
    description: 'Control values for the Email step.',
    oneOf: [{ $ref: getSchemaPath(EmailControlDto) }, { type: 'object', additionalProperties: true }],
  })
  @IsOptional()
  @IsObject()
  controlValues?: EmailControlDto | Record<string, unknown> | null;
}

export class SmsStepUpsertDto extends BaseStepConfigDto {
  @ApiProperty({
    enum: StepTypeEnum,
    enumName: 'StepTypeEnum',
    default: StepTypeEnum.SMS,
    description: 'Type of the step',
  })
  @IsEnum(StepTypeEnum)
  readonly type: StepTypeEnum = 'sms' as StepTypeEnum;

  @ApiPropertyOptional({
    description: 'Control values for the SMS step.',
    oneOf: [{ $ref: getSchemaPath(SmsControlDto) }, { type: 'object', additionalProperties: true }],
  })
  @IsOptional()
  @IsObject()
  controlValues?: SmsControlDto | Record<string, unknown> | null;
}

export class PushStepUpsertDto extends BaseStepConfigDto {
  @ApiProperty({
    enum: StepTypeEnum,
    enumName: 'StepTypeEnum',
    default: StepTypeEnum.PUSH,
    description: 'Type of the step',
  })
  @IsEnum(StepTypeEnum)
  readonly type: StepTypeEnum = 'push' as StepTypeEnum;

  @ApiPropertyOptional({
    description: 'Control values for the Push step.',
    oneOf: [{ $ref: getSchemaPath(PushControlDto) }, { type: 'object', additionalProperties: true }],
  })
  @IsOptional()
  @IsObject()
  controlValues?: PushControlDto | Record<string, unknown> | null;
}

export class ChatStepUpsertDto extends BaseStepConfigDto {
  @ApiProperty({
    enum: StepTypeEnum,
    enumName: 'StepTypeEnum',
    default: StepTypeEnum.CHAT,
    description: 'Type of the step',
  })
  @IsEnum(StepTypeEnum)
  readonly type: StepTypeEnum = 'chat' as StepTypeEnum;

  @ApiPropertyOptional({
    description: 'Control values for the Chat step.',
    oneOf: [{ $ref: getSchemaPath(ChatControlDto) }, { type: 'object', additionalProperties: true }],
  })
  @IsOptional()
  @IsObject()
  controlValues?: ChatControlDto | Record<string, unknown> | null;
}

export class DelayStepUpsertDto extends BaseStepConfigDto {
  @ApiProperty({
    enum: StepTypeEnum,
    enumName: 'StepTypeEnum',
    default: StepTypeEnum.DELAY,
    description: 'Type of the step',
  })
  @IsEnum(StepTypeEnum)
  readonly type: StepTypeEnum = 'delay' as StepTypeEnum;

  @ApiPropertyOptional({
    description: 'Control values for the Delay step.',
    oneOf: [{ $ref: getSchemaPath(DelayControlDto) }, { type: 'object', additionalProperties: true }],
  })
  @IsOptional()
  @IsObject()
  controlValues?: DelayControlDto | Record<string, unknown> | null;
}

export class DigestStepUpsertDto extends BaseStepConfigDto {
  @ApiProperty({
    enum: StepTypeEnum,
    enumName: 'StepTypeEnum',
    default: StepTypeEnum.DIGEST,
    description: 'Type of the step',
  })
  @IsEnum(StepTypeEnum)
  readonly type: StepTypeEnum = 'digest' as StepTypeEnum;

  @ApiPropertyOptional({
    description: 'Control values for the Digest step.',
    oneOf: [{ $ref: getSchemaPath(DigestControlDto) }, { type: 'object', additionalProperties: true }],
  })
  @IsOptional()
  @IsObject()
  controlValues?: DigestControlDto | Record<string, unknown> | null;
}

export class ThrottleStepUpsertDto extends BaseStepConfigDto {
  @ApiProperty({
    enum: StepTypeEnum,
    enumName: 'StepTypeEnum',
    default: StepTypeEnum.THROTTLE,
    description: 'Type of the step',
  })
  @IsEnum(StepTypeEnum)
  readonly type: StepTypeEnum = 'throttle' as StepTypeEnum;

  @ApiPropertyOptional({
    description: 'Control values for the Throttle step.',
    oneOf: [{ $ref: getSchemaPath(ThrottleControlDto) }, { type: 'object', additionalProperties: true }],
  })
  @IsOptional()
  @IsObject()
  controlValues?: ThrottleControlDto | Record<string, unknown> | null;
}

export class CustomStepUpsertDto extends BaseStepConfigDto {
  @ApiProperty({
    enum: StepTypeEnum,
    enumName: 'StepTypeEnum',
    default: StepTypeEnum.CUSTOM,
    description: 'Type of the step',
  })
  @IsEnum(StepTypeEnum)
  readonly type: StepTypeEnum = 'custom' as StepTypeEnum;

  @ApiPropertyOptional({
    description: 'Control values for the Custom step.',
    oneOf: [{ $ref: getSchemaPath(CustomControlDto) }, { type: 'object', additionalProperties: true }],
  })
  @IsOptional()
  @IsObject()
  controlValues?: CustomControlDto | Record<string, unknown> | null;
}

/*
 * This export allows using StepUpsertDto as a type for the discriminated union.
 * The actual DTO used will be one of the specific step DTOs at runtime.
 */
export type StepUpsertDto =
  | InAppStepUpsertDto
  | EmailStepUpsertDto
  | SmsStepUpsertDto
  | PushStepUpsertDto
  | ChatStepUpsertDto
  | DelayStepUpsertDto
  | DigestStepUpsertDto
  | ThrottleStepUpsertDto
  | CustomStepUpsertDto;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class BaseStepConfigDto
- export class InAppStepUpsertDto
- export class EmailStepUpsertDto
- export class SmsStepUpsertDto
- export class PushStepUpsertDto
- export class ChatStepUpsertDto
- export class DelayStepUpsertDto
- export class DigestStepUpsertDto
- export class ThrottleStepUpsertDto
- export class CustomStepUpsertDto
- export  allows
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/create-workflow.dto.ts
Tamaño: 4753 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiExtraModels, ApiProperty, ApiPropertyOptional, getSchemaPath } from '@nestjs/swagger';
import { SeverityLevelEnum, StepTypeEnum, WorkflowCreationSourceEnum } from '@novu/shared';
import { Type } from 'class-transformer';
import { IsArray, IsEnum, IsOptional, IsString, Matches, ValidateNested } from 'class-validator';
import {
  ChatControlDto,
  CustomControlDto,
  DelayControlDto,
  DigestControlDto,
  EmailControlDto,
  InAppControlDto,
  PushControlDto,
  SmsControlDto,
  ThrottleControlDto,
} from './controls';
import {
  BaseStepConfigDto,
  ChatStepUpsertDto,
  CustomStepUpsertDto,
  DelayStepUpsertDto,
  DigestStepUpsertDto,
  EmailStepUpsertDto,
  InAppStepUpsertDto,
  PushStepUpsertDto,
  SmsStepUpsertDto,
  ThrottleStepUpsertDto,
} from './create-step.dto';
import { PreferencesRequestDto } from './preferences.request.dto';
import { WorkflowCommonsFields } from './workflow-commons.dto';

@ApiExtraModels(
  InAppStepUpsertDto,
  EmailStepUpsertDto,
  SmsStepUpsertDto,
  PushStepUpsertDto,
  ChatStepUpsertDto,
  DelayStepUpsertDto,
  DigestStepUpsertDto,
  ThrottleStepUpsertDto,
  CustomStepUpsertDto,
  InAppControlDto,
  EmailControlDto,
  SmsControlDto,
  PushControlDto,
  ChatControlDto,
  DelayControlDto,
  DigestControlDto,
  ThrottleControlDto,
  CustomControlDto
)
export class CreateWorkflowDto extends WorkflowCommonsFields {
  @ApiProperty({ description: 'Unique identifier for the workflow' })
  @IsString()
  @Matches(/^[a-z0-9]+(?:-[a-z0-9]+)*$/, {
    message: 'must be a valid slug format (lowercase letters, numbers, and hyphens only)',
  })
  workflowId: string;

  @ApiProperty({
    description: 'Steps of the workflow',
    type: 'array',
    items: {
      oneOf: [
        { $ref: getSchemaPath(InAppStepUpsertDto) },
        { $ref: getSchemaPath(EmailStepUpsertDto) },
        { $ref: getSchemaPath(SmsStepUpsertDto) },
        { $ref: getSchemaPath(PushStepUpsertDto) },
        { $ref: getSchemaPath(ChatStepUpsertDto) },
        { $ref: getSchemaPath(DelayStepUpsertDto) },
        { $ref: getSchemaPath(DigestStepUpsertDto) },
        { $ref: getSchemaPath(ThrottleStepUpsertDto) },
        { $ref: getSchemaPath(CustomStepUpsertDto) },
      ],
      discriminator: {
        propertyName: 'type',
        mapping: {
          [StepTypeEnum.IN_APP]: getSchemaPath(InAppStepUpsertDto),
          [StepTypeEnum.EMAIL]: getSchemaPath(EmailStepUpsertDto),
          [StepTypeEnum.SMS]: getSchemaPath(SmsStepUpsertDto),
          [StepTypeEnum.PUSH]: getSchemaPath(PushStepUpsertDto),
          [StepTypeEnum.CHAT]: getSchemaPath(ChatStepUpsertDto),
          [StepTypeEnum.DELAY]: getSchemaPath(DelayStepUpsertDto),
          [StepTypeEnum.DIGEST]: getSchemaPath(DigestStepUpsertDto),
          [StepTypeEnum.THROTTLE]: getSchemaPath(ThrottleStepUpsertDto),
          [StepTypeEnum.CUSTOM]: getSchemaPath(CustomStepUpsertDto),
        },
      },
    },
  })
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => BaseStepConfigDto, {
    discriminator: {
      property: 'type',
      subTypes: [
        { name: StepTypeEnum.IN_APP, value: InAppStepUpsertDto },
        { name: StepTypeEnum.EMAIL, value: EmailStepUpsertDto },
        { name: StepTypeEnum.SMS, value: SmsStepUpsertDto },
        { name: StepTypeEnum.PUSH, value: PushStepUpsertDto },
        { name: StepTypeEnum.CHAT, value: ChatStepUpsertDto },
        { name: StepTypeEnum.DELAY, value: DelayStepUpsertDto },
        { name: StepTypeEnum.DIGEST, value: DigestStepUpsertDto },
        { name: StepTypeEnum.THROTTLE, value: ThrottleStepUpsertDto },
        { name: StepTypeEnum.CUSTOM, value: CustomStepUpsertDto },
      ],
    },
    keepDiscriminatorProperty: true,
  })
  steps: (
    | InAppStepUpsertDto
    | EmailStepUpsertDto
    | SmsStepUpsertDto
    | PushStepUpsertDto
    | ChatStepUpsertDto
    | DelayStepUpsertDto
    | DigestStepUpsertDto
    | ThrottleStepUpsertDto
    | CustomStepUpsertDto
  )[];

  @ApiProperty({
    description: 'Source of workflow creation',
    enum: WorkflowCreationSourceEnum,
    enumName: 'WorkflowCreationSourceEnum',
    required: false,
    default: WorkflowCreationSourceEnum.EDITOR,
  })
  @IsOptional()
  @IsEnum(WorkflowCreationSourceEnum)
  __source?: WorkflowCreationSourceEnum;

  @ApiPropertyOptional({
    description: 'Workflow preferences',
    type: PreferencesRequestDto,
    required: false,
  })
  @IsOptional()
  @Type(() => PreferencesRequestDto)
  preferences?: PreferencesRequestDto;

  @ApiPropertyOptional({
    description: 'Severity of the workflow',
    required: false,
    enum: [...Object.values(SeverityLevelEnum)],
    enumName: 'SeverityLevelEnum',
  })
  @IsOptional()
  @IsEnum(SeverityLevelEnum)
  severity?: SeverityLevelEnum;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateWorkflowDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/duplicate-workflow.dto.ts
Tamaño: 819 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IsArray, IsBoolean, IsOptional, IsString } from 'class-validator';

export class DuplicateWorkflowDto {
  @ApiProperty({
    description: 'Name of the workflow',
    required: false,
  })
  @IsOptional()
  @IsString()
  name?: string;

  @ApiPropertyOptional({
    description: 'Tags associated with the workflow',
    type: [String],
  })
  @IsArray()
  @IsOptional()
  tags?: string[];

  @ApiProperty({
    description: 'Description of the workflow',
    required: false,
  })
  @IsString()
  @IsOptional()
  description?: string;

  @ApiPropertyOptional({
    description: 'Enable or disable translations for this workflow',
    required: false,
    default: false,
  })
  @IsOptional()
  @IsBoolean()
  isTranslationEnabled?: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DuplicateWorkflowDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/generate-preview-request.dto.ts
Tamaño: 669 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { IsObject, IsOptional } from 'class-validator';

import { PreviewPayloadDto } from './preview-payload.dto';

export class GeneratePreviewRequestDto {
  @ApiPropertyOptional({
    description: 'Optional control values',
    type: 'object',
    additionalProperties: true,
  })
  @IsOptional()
  @IsObject()
  controlValues?: Record<string, unknown>;

  @ApiPropertyOptional({
    description: 'Optional payload for preview generation',
    type: () => PreviewPayloadDto,
  })
  @IsOptional()
  @Type(() => PreviewPayloadDto)
  previewPayload?: PreviewPayloadDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GeneratePreviewRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/generate-preview-response.dto.ts
Tamaño: 8561 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiExtraModels, ApiProperty, ApiPropertyOptional, getSchemaPath } from '@nestjs/swagger';
import { ActionTypeEnum, ChannelTypeEnum } from '@novu/shared';
import { Type } from 'class-transformer';
import { IsEnum, IsNumber, IsObject, IsOptional, IsString, ValidateNested } from 'class-validator';
import { JSONSchemaDto } from '../../shared/dtos/json-schema.dto';
import { PreviewPayloadDto } from './preview-payload.dto';

export enum TimeUnitEnum {
  SECONDS = 'seconds',
  MINUTES = 'minutes',
  HOURS = 'hours',
  DAYS = 'days',
  WEEKS = 'weeks',
  MONTHS = 'months',
}

export enum RedirectTargetEnum {
  SELF = '_self',
  BLANK = '_blank',
  PARENT = '_parent',
  TOP = '_top',
  UNFENCED_TOP = '_unfencedTop',
}

export class RenderOutput {}

export class RedirectDto {
  @ApiProperty({
    description: 'URL to redirect to',
    type: 'string',
  })
  @IsString()
  url: string;

  @ApiPropertyOptional({
    description: 'Target of the redirect',
    enum: [...Object.values(RedirectTargetEnum)],
    enumName: 'RedirectTargetEnum',
  })
  @IsOptional()
  @IsEnum(RedirectTargetEnum)
  target?: RedirectTargetEnum;
}

export class ActionDto {
  @ApiProperty({
    description: 'Label for the action',
    type: 'string',
  })
  @IsString()
  label: string;

  @ApiPropertyOptional({
    description: 'Redirect details for the action',
    type: () => RedirectDto,
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => RedirectDto)
  redirect?: RedirectDto;
}

export class ChatRenderOutput extends RenderOutput {
  @ApiProperty({ description: 'Body of the chat message' })
  @IsString()
  body: string;
}

export class SmsRenderOutput extends RenderOutput {
  @ApiProperty({ description: 'Body of the SMS message' })
  @IsString()
  body: string;
}

export class PushRenderOutput extends RenderOutput {
  @ApiProperty({ description: 'Subject of the push notification' })
  @IsString()
  subject: string;

  @ApiProperty({ description: 'Body of the push notification' })
  @IsString()
  body: string;
}

export class EmailRenderOutput extends RenderOutput {
  @ApiProperty({ description: 'Subject of the email' })
  @IsString()
  subject: string;

  @ApiProperty({ description: 'Body of the email' })
  @IsString()
  body: string;
}

export class DigestRegularOutput {
  @ApiProperty({ description: 'Amount of time units' })
  @IsNumber()
  amount: number;

  @ApiProperty({
    description: 'Time unit',
    enum: [...Object.values(TimeUnitEnum)],
    enumName: 'TimeUnitEnum',
  })
  @IsEnum(TimeUnitEnum)
  unit: TimeUnitEnum;

  @ApiPropertyOptional({ description: 'Optional digest key' })
  @IsOptional()
  @IsString()
  digestKey?: string;

  @ApiPropertyOptional({
    description: 'Look back window configuration',
    type: 'object',
  })
  @IsOptional()
  @ValidateNested()
  lookBackWindow?: {
    amount: number;
    unit: TimeUnitEnum;
  };
}

export class DigestTimedOutput {
  @ApiProperty({ description: 'Cron expression' })
  @IsString()
  cron: string;

  @ApiPropertyOptional({ description: 'Optional digest key' })
  @IsOptional()
  @IsString()
  digestKey?: string;
}

export class DelayRenderOutput extends RenderOutput {
  @ApiProperty({ description: 'Type of delay' })
  @IsString()
  type: string;

  @ApiProperty({ description: 'Amount of time units' })
  @IsNumber()
  amount: number;

  @ApiProperty({
    description: 'Time unit',
    enum: [...Object.values(TimeUnitEnum)],
    enumName: 'TimeUnitEnum',
  })
  @IsEnum(TimeUnitEnum)
  unit: TimeUnitEnum;
}

export class InAppRenderOutput extends RenderOutput {
  @ApiPropertyOptional({ description: 'Subject of the in-app notification' })
  @IsOptional()
  @IsString()
  subject?: string;

  @ApiProperty({ description: 'Body of the in-app notification' })
  @IsString()
  body: string;

  @ApiPropertyOptional({ description: 'Avatar for the in-app notification' })
  @IsOptional()
  @IsString()
  avatar?: string;

  @ApiPropertyOptional({
    description: 'Primary action details',
    type: () => ActionDto,
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => ActionDto)
  primaryAction?: ActionDto;

  @ApiPropertyOptional({
    description: 'Secondary action details',
    type: () => ActionDto,
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => ActionDto)
  secondaryAction?: ActionDto;

  @ApiPropertyOptional({
    description: 'Additional data',
    type: 'object',
    additionalProperties: true,
  })
  @IsOptional()
  @IsObject()
  data?: Record<string, unknown>;

  @ApiPropertyOptional({
    description: 'Redirect details',
    type: () => RedirectDto,
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => RedirectDto)
  redirect?: RedirectDto;
}

@ApiExtraModels(
  EmailRenderOutput,
  InAppRenderOutput,
  SmsRenderOutput,
  PushRenderOutput,
  ChatRenderOutput,
  DigestRegularOutput,
  DigestTimedOutput,
  DelayRenderOutput
)
export class GeneratePreviewResponseDto {
  @ApiProperty({
    description: 'Preview payload example',
    type: () => PreviewPayloadDto,
  })
  @ValidateNested()
  @Type(() => PreviewPayloadDto)
  previewPayloadExample: PreviewPayloadDto;

  @ApiPropertyOptional({
    description: 'The payload schema that was used to generate the preview payload example',
    type: 'object',
    nullable: true,
    additionalProperties: true,
  })
  @IsOptional()
  schema?: any | null;

  @ApiProperty({
    description: 'Preview result',
    type: 'object',
    oneOf: [
      {
        type: 'object',
        additionalProperties: true,
      },
      {
        properties: {
          type: { enum: [ChannelTypeEnum.EMAIL] },
          preview: { $ref: getSchemaPath(EmailRenderOutput) },
        },
      },
      {
        properties: {
          type: { enum: [ChannelTypeEnum.EMAIL] },
          preview: { $ref: getSchemaPath(EmailRenderOutput) },
        },
      },
      {
        properties: {
          type: { enum: [ChannelTypeEnum.IN_APP] },
          preview: { $ref: getSchemaPath(InAppRenderOutput) },
        },
      },
      {
        properties: {
          type: { enum: [ChannelTypeEnum.SMS] },
          preview: { $ref: getSchemaPath(SmsRenderOutput) },
        },
      },
      {
        properties: {
          type: { enum: [ChannelTypeEnum.PUSH] },
          preview: { $ref: getSchemaPath(PushRenderOutput) },
        },
      },
      {
        properties: {
          type: { enum: [ChannelTypeEnum.CHAT] },
          preview: { $ref: getSchemaPath(ChatRenderOutput) },
        },
      },
      {
        properties: {
          type: { enum: [ActionTypeEnum.DELAY] },
          preview: { $ref: getSchemaPath(DigestRegularOutput) },
        },
      },
      {
        properties: {
          type: { enum: [ActionTypeEnum.DIGEST] },
          preview: { $ref: getSchemaPath(DigestRegularOutput) },
        },
      },
    ],
  })
  result:
    | {
        type: ChannelTypeEnum.EMAIL;
        preview: EmailRenderOutput;
      }
    | {
        type: ChannelTypeEnum.IN_APP;
        preview: InAppRenderOutput;
      }
    | {
        type: ChannelTypeEnum.SMS;
        preview: SmsRenderOutput;
      }
    | {
        type: ChannelTypeEnum.PUSH;
        preview: PushRenderOutput;
      }
    | {
        type: ChannelTypeEnum.CHAT;
        preview: ChatRenderOutput;
      }
    | {
        type: ActionTypeEnum.DELAY;
        preview: DigestRenderOutput;
      }
    | {
        type: ActionTypeEnum.DIGEST;
        preview: DigestRenderOutput;
      }
    | {
        type:
          | ChannelTypeEnum.EMAIL
          | ChannelTypeEnum.IN_APP
          | ChannelTypeEnum.SMS
          | ChannelTypeEnum.PUSH
          | ChannelTypeEnum.CHAT
          | ActionTypeEnum.DELAY
          | ActionTypeEnum.DIGEST;
        preview: Record<string, unknown>; // Allow empty object
      };
}

export class DigestOutputProcessor {
  static isDigestRegularOutput(output: unknown): output is DigestRegularOutput {
    if (typeof output !== 'object' || output === null) return false;

    const obj = output as { [key: string]: unknown };

    return typeof obj.amount === 'number' && Object.values(TimeUnitEnum).includes(obj.unit as TimeUnitEnum);
  }

  static isDigestTimedOutput(output: unknown): output is DigestTimedOutput {
    if (typeof output !== 'object' || output === null) return false;

    const obj = output as { [key: string]: unknown };

    return typeof obj.cron === 'string' && (typeof obj.digestKey === 'undefined' || typeof obj.digestKey === 'string');
  }
}

export type DigestRenderOutput = DigestRegularOutput | DigestTimedOutput;
type TimeType = 'regular';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - UNFENCED_TOP('_unfencedTop',
}

export class RenderOutput {}

export class RedirectDto {
  @ApiProperty({
    des...)
Declaraciones 'export' encontradas:
- export  enum
- export  enum
- export class RenderOutput
- export class RedirectDto
- export class ActionDto
- export class ChatRenderOutput
- export class SmsRenderOutput
- export class PushRenderOutput
- export class EmailRenderOutput
- export class DigestRegularOutput
- export class DigestTimedOutput
- export class DelayRenderOutput
- export class InAppRenderOutput
- export class GeneratePreviewResponseDto
- export class DigestOutputProcessor
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/get-list-query-params.ts
Tamaño: 1160 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional } from '@nestjs/swagger';
import { WorkflowStatusEnum } from '@novu/shared';
import { IsArray, IsEnum, IsOptional, IsString } from 'class-validator';
import { LimitOffsetPaginationQueryDto } from '../../shared/dtos/limit-offset-pagination.dto';
import { WorkflowResponseDto } from './workflow-response.dto';

export class GetListQueryParamsDto extends LimitOffsetPaginationQueryDto(WorkflowResponseDto, [
  'createdAt',
  'updatedAt',
  'name',
  'lastTriggeredAt',
]) {
  @ApiPropertyOptional({
    description: 'Search query to filter workflows',
    type: 'string',
    required: false,
  })
  @IsOptional()
  @IsString()
  query?: string;

  @ApiPropertyOptional({
    description: 'Filter workflows by tags',
    type: [String],
    required: false,
  })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  tags?: string[];

  @ApiPropertyOptional({
    description: 'Filter workflows by status',
    enum: WorkflowStatusEnum,
    enumName: 'WorkflowStatusEnum',
    type: [String],
    required: false,
  })
  @IsOptional()
  @IsArray()
  @IsEnum(WorkflowStatusEnum, { each: true })
  status?: WorkflowStatusEnum[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetListQueryParamsDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/index.ts
Tamaño: 1257 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './channel-preference.dto';
export * from './control-schemas.dto';
export * from './controls-metadata.dto';
export * from './create-step.dto';
export * from './create-workflow.dto';
export * from './duplicate-workflow.dto';
export * from './generate-preview-request.dto';
export * from './generate-preview-response.dto';
export * from './get-list-query-params';
export * from './integration-issue.dto';
export * from './list-workflow.dto';
export * from './patch-step-data.dto';
export * from './patch-workflow.dto';
export * from './preferences.request.dto';
export * from './preferences.response.dto';
export * from './preview-payload.dto';
export * from './runtime-issue.dto';
export * from './step.response.dto';
export * from './step-content-issue.dto';
export * from './step-issues.dto';
export * from './step-list-response.dto';
export * from './sync-workflow.dto';
export * from './ui-schema.dto';
export * from './ui-schema-property.dto';
export * from './update-workflow.dto';
export * from './workflow-commons.dto';
export * from './workflow-list-response.dto';
export * from './workflow-preference.dto';
export * from './workflow-preferences.dto';
export * from './workflow-response.dto';
export * from './workflow-test-data.dto';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/integration-issue.dto.ts
Tamaño: 498 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IntegrationIssueEnum } from '@novu/shared';
import { IsEnum } from 'class-validator';
import { BaseIssueDto } from './base-issue.dto';

export class StepIntegrationIssue extends BaseIssueDto<IntegrationIssueEnum> {
  @ApiProperty({
    description: 'Type of integration issue',
    enum: [...Object.values(IntegrationIssueEnum)],
    enumName: 'IntegrationIssueEnum',
  })
  @IsEnum(IntegrationIssueEnum)
  issueType: IntegrationIssueEnum;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class StepIntegrationIssue

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/list-workflow.dto.ts
Tamaño: 634 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { IsArray, IsNumber, ValidateNested } from 'class-validator';
import { WorkflowListResponseDto } from './workflow-list-response.dto';

export class ListWorkflowResponse {
  @ApiProperty({
    description: 'List of workflows',
    type: WorkflowListResponseDto,
    isArray: true,
  })
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => WorkflowListResponseDto)
  workflows: WorkflowListResponseDto[];

  @ApiProperty({
    description: 'Total number of workflows',
    type: 'number',
  })
  @IsNumber()
  totalCount: number;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ListWorkflowResponse

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/patch-step-data.dto.ts
Tamaño: 526 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional } from '@nestjs/swagger';
import { IsObject, IsOptional, IsString } from 'class-validator';

export class PatchStepDataDto {
  @ApiPropertyOptional({
    description: 'New name for the step',
    type: 'string',
  })
  @IsOptional()
  @IsString()
  name?: string;

  @ApiPropertyOptional({
    description: 'Control values for the step',
    type: 'object',
    nullable: true,
    additionalProperties: true,
  })
  @IsOptional()
  @IsObject()
  controlValues?: Record<string, unknown> | null;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class PatchStepDataDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/patch-workflow.dto.ts
Tamaño: 1607 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional } from '@nestjs/swagger';
import { IsArray, IsBoolean, IsObject, IsOptional, IsString } from 'class-validator';
import { IsValidJsonSchema } from '../../shared/validators/json-schema.validator';

export class PatchWorkflowDto {
  @ApiPropertyOptional({
    description: 'Activate or deactivate the workflow',
    type: 'boolean',
  })
  @IsOptional()
  @IsBoolean()
  active?: boolean;

  @ApiPropertyOptional({
    description: 'New name for the workflow',
    type: 'string',
  })
  @IsOptional()
  @IsString()
  name?: string;

  @ApiPropertyOptional({
    description: 'Updated description of the workflow',
    type: 'string',
  })
  @IsOptional()
  @IsString()
  description?: string;

  @ApiPropertyOptional({
    description: 'Tags associated with the workflow',
    type: 'array',
    items: { type: 'string' },
  })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  tags?: string[];

  @ApiPropertyOptional({
    description: 'The payload JSON Schema for the workflow',
    type: 'object',
    additionalProperties: true,
    nullable: true,
  })
  @IsOptional()
  @IsValidJsonSchema({
    message: 'payloadSchema must be a valid JSON schema',
    nullable: true,
  })
  payloadSchema?: object;

  @ApiPropertyOptional({
    description: 'Enable or disable payload schema validation',
    type: 'boolean',
  })
  @IsOptional()
  @IsBoolean()
  validatePayload?: boolean;

  @ApiPropertyOptional({
    description: 'Enable or disable translations for this workflow',
    type: 'boolean',
  })
  @IsOptional()
  @IsBoolean()
  isTranslationEnabled?: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class PatchWorkflowDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/preferences.request.dto.ts
Tamaño: 834 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional, getSchemaPath } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { IsOptional, ValidateNested } from 'class-validator';
import { WorkflowPreferencesDto } from './workflow-preferences.dto';

export class PreferencesRequestDto {
  @ApiPropertyOptional({
    description: 'User workflow preferences',
    oneOf: [{ $ref: getSchemaPath(WorkflowPreferencesDto) }],
    nullable: true,
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => WorkflowPreferencesDto)
  user: WorkflowPreferencesDto | null;

  @ApiPropertyOptional({
    description: 'Workflow-specific preferences',
    type: () => WorkflowPreferencesDto,
    nullable: true,
    required: false,
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => WorkflowPreferencesDto)
  workflow?: WorkflowPreferencesDto | null;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class PreferencesRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/preferences.response.dto.ts
Tamaño: 725 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { ValidateNested } from 'class-validator';
import { WorkflowPreferencesDto } from './workflow-preferences.dto';

export class WorkflowPreferencesResponseDto {
  @ApiPropertyOptional({
    description: 'User-specific workflow preferences',
    type: () => WorkflowPreferencesDto,
    nullable: true,
  })
  @ValidateNested()
  @Type(() => WorkflowPreferencesDto)
  user: WorkflowPreferencesDto | null;

  @ApiProperty({
    description: 'Default workflow preferences',
    type: () => WorkflowPreferencesDto,
  })
  @ValidateNested()
  @Type(() => WorkflowPreferencesDto)
  default: WorkflowPreferencesDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class WorkflowPreferencesResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/preview-payload.dto.ts
Tamaño: 1165 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional } from '@nestjs/swagger';
import { IsValidContextPayload } from '@novu/application-generic';
import { ContextPayload } from '@novu/shared';
import { Type } from 'class-transformer';
import { IsObject, IsOptional, ValidateNested } from 'class-validator';
import { ApiContextPayload } from '../../shared/framework/swagger';
import { SubscriberResponseDtoOptional } from '../../subscribers/dtos';

export class PreviewPayloadDto {
  @ApiPropertyOptional({
    description: 'Partial subscriber information',
    type: SubscriberResponseDtoOptional,
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => SubscriberResponseDtoOptional)
  subscriber?: SubscriberResponseDtoOptional;

  @ApiPropertyOptional({
    description: 'Payload data',
    type: 'object',
    additionalProperties: true,
  })
  @IsOptional()
  @IsObject()
  payload?: Record<string, unknown>;

  @ApiPropertyOptional({
    description: 'Steps data',
    type: 'object',
    additionalProperties: true,
  })
  @IsOptional()
  @IsObject()
  steps?: Record<string, unknown>;

  @ApiContextPayload()
  @IsOptional()
  @IsValidContextPayload()
  context?: ContextPayload;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class PreviewPayloadDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/runtime-issue.dto.ts
Tamaño: 168 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { WorkflowIssueTypeEnum } from '@novu/shared';

export class RuntimeIssueDto {
  issueType: WorkflowIssueTypeEnum;
  variableName?: string;
  message: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RuntimeIssueDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/step-content-issue.dto.ts
Tamaño: 474 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { ContentIssueEnum } from '@novu/shared';
import { IsEnum } from 'class-validator';
import { BaseIssueDto } from './base-issue.dto';

export class StepContentIssueDto extends BaseIssueDto<ContentIssueEnum> {
  @ApiProperty({
    description: 'Type of step content issue',
    enum: [...Object.values(ContentIssueEnum)],
    enumName: 'ContentIssueEnum',
  })
  @IsEnum(ContentIssueEnum)
  issueType: ContentIssueEnum;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class StepContentIssueDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/step-issues.dto.ts
Tamaño: 1030 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiExtraModels, ApiPropertyOptional, getSchemaPath } from '@nestjs/swagger';
import { RuntimeIssue } from '@novu/shared';
import { IsOptional, ValidateNested } from 'class-validator';
import { StepIntegrationIssue } from './integration-issue.dto';
import { StepContentIssueDto } from './step-content-issue.dto';

@ApiExtraModels(StepContentIssueDto, StepIntegrationIssue)
export class StepIssuesDto {
  @ApiPropertyOptional({
    description: 'Controls-related issues',
    type: 'object',
    additionalProperties: {
      type: 'array',
      items: {
        $ref: getSchemaPath(StepContentIssueDto),
      },
    },
  })
  @IsOptional()
  @ValidateNested()
  controls?: Record<string, RuntimeIssue[]>;

  @ApiPropertyOptional({
    description: 'Integration-related issues',
    type: 'object',
    additionalProperties: {
      type: 'array',
      items: {
        $ref: getSchemaPath(StepIntegrationIssue),
      },
    },
  })
  @IsOptional()
  @ValidateNested()
  integration?: Record<string, RuntimeIssue[]>;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class StepIssuesDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/step-list-response.dto.ts
Tamaño: 811 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { Slug, StepTypeEnum } from '@novu/shared';
import { Type } from 'class-transformer';
import { IsEnum, IsOptional, IsString, ValidateNested } from 'class-validator';
import { StepIssuesDto } from './step-issues.dto';

export class StepListResponseDto {
  @ApiProperty({ description: 'Slug of the step', type: 'string' })
  @IsString()
  slug: Slug;

  @ApiProperty({
    description: 'Type of the step',
    enum: [...Object.values(StepTypeEnum)],
    enumName: 'StepTypeEnum',
  })
  @IsEnum(StepTypeEnum)
  type: StepTypeEnum;

  @ApiPropertyOptional({
    description: 'Issues associated with the step',
    type: () => StepIssuesDto,
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => StepIssuesDto)
  issues?: StepIssuesDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class StepListResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/step.response.dto.ts
Tamaño: 2414 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { ResourceOriginEnum, Slug, StepTypeEnum } from '@novu/shared';
import { Type } from 'class-transformer';
import { IsEnum, IsOptional, IsString, ValidateNested } from 'class-validator';
import { JSONSchemaDto } from '../../shared/dtos/json-schema.dto';
import { ControlsMetadataDto } from './controls-metadata.dto';
import { StepIssuesDto } from './step-issues.dto';

export class StepResponseDto<T = Record<string, unknown>> {
  @ApiProperty({
    description: 'Controls metadata for the step',
    type: () => ControlsMetadataDto,
    required: true,
  })
  @ValidateNested()
  @Type(() => ControlsMetadataDto)
  controls: ControlsMetadataDto;

  @ApiPropertyOptional({
    description: 'Control values for the step (alias for controls.values)',
    type: 'object',
    additionalProperties: true,
  })
  controlValues?: T;

  @ApiProperty({
    description: 'JSON Schema for variables, follows the JSON Schema standard',
    additionalProperties: true,
    type: () => Object, // Use arrow function for type
  })
  @ValidateNested() // Consider adding options if needed
  @Type(() => JSONSchemaDto) // Import class-transformer decorator
  variables: JSONSchemaDto;

  @ApiProperty({ description: 'Unique identifier of the step' })
  @IsString()
  stepId: string;

  @ApiProperty({ description: 'Database identifier of the step' })
  @IsString()
  _id: string;

  @ApiProperty({ description: 'Name of the step' })
  @IsString()
  name: string;

  @ApiProperty({ description: 'Slug of the step', type: 'string' })
  @IsString()
  slug: Slug;

  @ApiProperty({
    description: 'Type of the step',
    enum: [...Object.values(StepTypeEnum)],
    enumName: 'StepTypeEnum',
  })
  @IsEnum(StepTypeEnum)
  type: StepTypeEnum;

  @ApiProperty({
    description: 'Origin of the step',
    enum: [...Object.values(ResourceOriginEnum)],
    enumName: 'ResourceOriginEnum',
  })
  @IsEnum(ResourceOriginEnum)
  origin: ResourceOriginEnum;

  @ApiProperty({ description: 'Workflow identifier' })
  @IsString()
  workflowId: string;

  @ApiProperty({ description: 'Workflow database identifier' })
  @IsString()
  workflowDatabaseId: string;

  @ApiPropertyOptional({
    description: 'Issues associated with the step',
    type: () => StepIssuesDto,
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => StepIssuesDto)
  issues?: StepIssuesDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - T(Record<string, unknown>> {
  @ApiProperty({
    description: 'Controls metadata for the step',
    t...)
Declaraciones 'export' encontradas:
- export class StepResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/sync-workflow.dto.ts
Tamaño: 286 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IsString } from 'class-validator';

export class SyncWorkflowDto {
  @ApiProperty({
    description: 'Target environment identifier to sync the workflow to',
    type: 'string',
  })
  @IsString()
  targetEnvironmentId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SyncWorkflowDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/ui-schema-property.dto.ts
Tamaño: 1350 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional, getSchemaPath } from '@nestjs/swagger';
import { UiComponentEnum } from '@novu/shared';
import { IsEnum, IsOptional, ValidateNested } from 'class-validator';

export class UiSchemaProperty {
  @ApiPropertyOptional({
    description: 'Placeholder for the UI Schema Property',
    anyOf: [
      {
        type: 'string',
      },
      {
        type: 'number',
      },
      {
        type: 'boolean',
      },
      {
        type: 'object',
        additionalProperties: true,
      },
      {
        type: 'array',
        items: {
          anyOf: [
            { type: 'string' },
            { type: 'number' },
            { type: 'boolean' },
            { type: 'object', additionalProperties: true },
          ],
        },
      },
    ],
    nullable: true,
  })
  @IsOptional()
  placeholder?: unknown;

  @ApiProperty({
    description: 'Component type for the UI Schema Property',
    enum: [...Object.values(UiComponentEnum)],
    enumName: 'UiComponentEnum',
  })
  @IsEnum(UiComponentEnum)
  component: UiComponentEnum;

  @ApiPropertyOptional({
    description: 'Properties of the UI Schema',
    type: 'object',
    additionalProperties: {
      $ref: getSchemaPath(UiSchemaProperty),
    },
  })
  @IsOptional()
  @ValidateNested()
  properties?: Record<string, UiSchemaProperty>;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UiSchemaProperty

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/ui-schema.dto.ts
Tamaño: 786 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiExtraModels, ApiPropertyOptional, getSchemaPath } from '@nestjs/swagger';
import { UiSchemaGroupEnum } from '@novu/shared';
import { IsOptional, ValidateNested } from 'class-validator';
import { UiSchemaProperty } from './ui-schema-property.dto';

@ApiExtraModels(UiSchemaProperty)
export class UiSchema {
  @ApiPropertyOptional({
    description: 'Group of the UI Schema',
    enum: [...Object.values(UiSchemaGroupEnum)],
    enumName: 'UiSchemaGroupEnum',
  })
  @IsOptional()
  group?: UiSchemaGroupEnum;

  @ApiPropertyOptional({
    description: 'Properties of the UI Schema',
    type: 'object',
    additionalProperties: {
      $ref: getSchemaPath(UiSchemaProperty),
    },
  })
  @IsOptional()
  @ValidateNested()
  properties?: Record<string, UiSchemaProperty>;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UiSchema

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/update-workflow.dto.ts
Tamaño: 3865 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiExtraModels, ApiProperty, ApiPropertyOptional, getSchemaPath } from '@nestjs/swagger';
import { ResourceOriginEnum, SeverityLevelEnum, StepTypeEnum } from '@novu/shared';
import { Type } from 'class-transformer';
import { IsArray, IsEnum, IsOptional, ValidateNested } from 'class-validator';
import {
  BaseStepConfigDto,
  ChatStepUpsertDto,
  CustomStepUpsertDto,
  DelayStepUpsertDto,
  DigestStepUpsertDto,
  EmailStepUpsertDto,
  InAppStepUpsertDto,
  PushStepUpsertDto,
  SmsStepUpsertDto,
} from './create-step.dto';
import { PreferencesRequestDto } from './preferences.request.dto';
import { WorkflowCommonsFields } from './workflow-commons.dto';

@ApiExtraModels(
  InAppStepUpsertDto,
  EmailStepUpsertDto,
  SmsStepUpsertDto,
  PushStepUpsertDto,
  ChatStepUpsertDto,
  DelayStepUpsertDto,
  DigestStepUpsertDto,
  CustomStepUpsertDto
)
export class UpdateWorkflowDto extends WorkflowCommonsFields {
  @ApiPropertyOptional({
    description: 'Workflow ID (allowed only for code-first workflows)',
    type: 'string',
  })
  @IsOptional()
  workflowId?: string;

  @ApiProperty({
    description: 'Steps of the workflow',
    type: 'array',
    items: {
      oneOf: [
        { $ref: getSchemaPath(InAppStepUpsertDto) },
        { $ref: getSchemaPath(EmailStepUpsertDto) },
        { $ref: getSchemaPath(SmsStepUpsertDto) },
        { $ref: getSchemaPath(PushStepUpsertDto) },
        { $ref: getSchemaPath(ChatStepUpsertDto) },
        { $ref: getSchemaPath(DelayStepUpsertDto) },
        { $ref: getSchemaPath(DigestStepUpsertDto) },
        { $ref: getSchemaPath(CustomStepUpsertDto) },
      ],
      discriminator: {
        propertyName: 'type',
        mapping: {
          [StepTypeEnum.IN_APP]: getSchemaPath(InAppStepUpsertDto),
          [StepTypeEnum.EMAIL]: getSchemaPath(EmailStepUpsertDto),
          [StepTypeEnum.SMS]: getSchemaPath(SmsStepUpsertDto),
          [StepTypeEnum.PUSH]: getSchemaPath(PushStepUpsertDto),
          [StepTypeEnum.CHAT]: getSchemaPath(ChatStepUpsertDto),
          [StepTypeEnum.DELAY]: getSchemaPath(DelayStepUpsertDto),
          [StepTypeEnum.DIGEST]: getSchemaPath(DigestStepUpsertDto),
          [StepTypeEnum.CUSTOM]: getSchemaPath(CustomStepUpsertDto),
        },
      },
    },
  })
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => BaseStepConfigDto, {
    discriminator: {
      property: 'type',
      subTypes: [
        { name: StepTypeEnum.IN_APP, value: InAppStepUpsertDto },
        { name: StepTypeEnum.EMAIL, value: EmailStepUpsertDto },
        { name: StepTypeEnum.SMS, value: SmsStepUpsertDto },
        { name: StepTypeEnum.PUSH, value: PushStepUpsertDto },
        { name: StepTypeEnum.CHAT, value: ChatStepUpsertDto },
        { name: StepTypeEnum.DELAY, value: DelayStepUpsertDto },
        { name: StepTypeEnum.DIGEST, value: DigestStepUpsertDto },
        { name: StepTypeEnum.CUSTOM, value: CustomStepUpsertDto },
      ],
    },
    keepDiscriminatorProperty: true,
  })
  steps: (
    | InAppStepUpsertDto
    | EmailStepUpsertDto
    | SmsStepUpsertDto
    | PushStepUpsertDto
    | ChatStepUpsertDto
    | DelayStepUpsertDto
    | DigestStepUpsertDto
    | CustomStepUpsertDto
  )[];

  @ApiProperty({
    description: 'Workflow preferences',
    type: () => PreferencesRequestDto,
  })
  @ValidateNested()
  @Type(() => PreferencesRequestDto)
  preferences: PreferencesRequestDto;

  @ApiProperty({
    description: 'Origin of the workflow',
    enum: [...Object.values(ResourceOriginEnum)],
    enumName: 'ResourceOriginEnum',
  })
  @IsEnum(ResourceOriginEnum)
  origin: ResourceOriginEnum;

  @ApiPropertyOptional({
    description: 'Severity of the workflow',
    required: false,
    enum: [...Object.values(SeverityLevelEnum)],
    enumName: 'SeverityLevelEnum',
  })
  @IsOptional()
  @IsEnum(SeverityLevelEnum)
  severity?: SeverityLevelEnum;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateWorkflowDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/user-response.dto.ts
Tamaño: 669 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IsOptional, IsString } from 'class-validator';

export class UserResponseDto {
  @ApiProperty({ description: 'User ID' })
  @IsString()
  _id: string;

  @ApiPropertyOptional({ type: 'string', description: 'User first name', nullable: true })
  @IsOptional()
  @IsString()
  firstName?: string;

  @ApiPropertyOptional({ type: 'string', description: 'User last name', nullable: true })
  @IsOptional()
  @IsString()
  lastName?: string | null;

  @ApiPropertyOptional({ type: 'string', description: 'User external ID', nullable: true })
  @IsOptional()
  @IsString()
  externalId?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UserResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/workflow-commons.dto.ts
Tamaño: 1573 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IsArray, IsBoolean, IsOptional, IsString } from 'class-validator';
import { IsValidJsonSchema } from '../../shared/validators/json-schema.validator';

export class WorkflowCommonsFields {
  @ApiProperty({ description: 'Name of the workflow' })
  @IsString()
  name: string;

  @ApiPropertyOptional({ description: 'Description of the workflow', required: false })
  @IsOptional()
  @IsString()
  description?: string;

  @ApiPropertyOptional({
    description: 'Tags associated with the workflow',
    type: [String],
    required: false,
  })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  tags?: string[];

  @ApiPropertyOptional({
    description: 'Whether the workflow is active',
    required: false,
    default: false,
  })
  @IsOptional()
  @IsBoolean()
  active?: boolean;

  @ApiPropertyOptional({
    description: 'Enable or disable payload schema validation',
    type: 'boolean',
  })
  @IsOptional()
  @IsBoolean()
  validatePayload?: boolean;

  @ApiPropertyOptional({
    description: 'The payload JSON Schema for the workflow',
    nullable: true,
    type: 'object',
    additionalProperties: true,
  })
  @IsOptional()
  @IsValidJsonSchema({
    message: 'payloadSchema must be a valid JSON schema',
    nullable: true,
  })
  payloadSchema?: object | null;

  @ApiPropertyOptional({
    description: 'Enable or disable translations for this workflow',
    required: false,
    default: false,
  })
  @IsOptional()
  @IsBoolean()
  isTranslationEnabled?: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class WorkflowCommonsFields

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/workflow-list-response.dto.ts
Tamaño: 3188 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, getSchemaPath } from '@nestjs/swagger';
import { ResourceOriginEnum, StepTypeEnum, WorkflowStatusEnum } from '@novu/shared';
import { Type } from 'class-transformer';
import { IsArray, IsBoolean, IsEnum, IsOptional, IsString, ValidateNested } from 'class-validator';
import { StepListResponseDto } from './step-list-response.dto';
import { UserResponseDto } from './user-response.dto';
import { WorkflowResponseDto } from './workflow-response.dto';

export class WorkflowListResponseDto {
  @ApiProperty({ description: 'Name of the workflow' })
  @IsString()
  name: string;

  @ApiProperty({
    description: 'Tags associated with the workflow',
    type: 'array',
    items: { type: 'string' },
    required: false,
  })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  tags?: string[];

  @ApiProperty({ description: 'Last updated timestamp' })
  @IsString()
  updatedAt: string;

  @ApiProperty({ description: 'Creation timestamp' })
  @IsString()
  createdAt: string;

  @ApiProperty({
    description: 'User who last updated the workflow',
    type: () => UserResponseDto,
    required: false,
    nullable: true,
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => UserResponseDto)
  updatedBy?: UserResponseDto;

  @ApiProperty({
    description: 'Timestamp of the last workflow publication',
    type: 'string',
    required: false,
    nullable: true,
  })
  @IsOptional()
  @IsString()
  lastPublishedAt?: string;

  @ApiProperty({
    description: 'User who last published the workflow',
    type: () => UserResponseDto,
    required: false,
    nullable: true,
  })
  @IsOptional()
  @Type(() => UserResponseDto)
  lastPublishedBy?: UserResponseDto;

  @ApiProperty({ description: 'Unique database identifier' })
  @IsString()
  _id: string;

  @ApiProperty({ description: 'Workflow identifier' })
  @IsString()
  workflowId: string;

  @ApiProperty({ description: 'Workflow slug' })
  @IsString()
  slug: string;

  @ApiProperty({
    description: 'Workflow status',
    enum: [...Object.values(WorkflowStatusEnum)],
    enumName: 'WorkflowStatusEnum',
  })
  status: WorkflowResponseDto['status'];

  @ApiProperty({
    description: 'Workflow origin',
    enum: [...Object.values(ResourceOriginEnum)],
    enumName: 'ResourceOriginEnum',
  })
  origin: WorkflowResponseDto['origin'];

  @ApiProperty({
    description: 'Timestamp of the last workflow trigger',
    required: false,
    nullable: true,
  })
  @IsOptional()
  @IsString()
  lastTriggeredAt?: string;

  @ApiProperty({
    description: 'Overview of step types in the workflow',
    type: 'array',
    items: {
      $ref: getSchemaPath('StepTypeEnum'),
    },
  })
  @IsArray()
  @IsEnum(StepTypeEnum, { each: true })
  stepTypeOverviews: StepTypeEnum[];

  @ApiProperty({
    description: 'Is translation enabled for the workflow',
    type: Boolean,
    required: false,
  })
  @IsOptional()
  @IsBoolean()
  isTranslationEnabled?: boolean;

  @ApiProperty({
    description: 'Steps of the workflow',
    type: StepListResponseDto,
    isArray: true,
  })
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => StepListResponseDto)
  steps: StepListResponseDto[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class WorkflowListResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/workflow-preference.dto.ts
Tamaño: 678 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IsBoolean } from 'class-validator';

export class WorkflowPreferenceDto {
  @ApiProperty({
    description:
      'A flag specifying if notification delivery is enabled for the workflow. If true, notification delivery' +
      ' is enabled by default for all channels. This setting can be overridden by the channel preferences.',
    default: true,
  })
  @IsBoolean()
  enabled: boolean = true;

  @ApiProperty({
    description:
      'A flag specifying if the preference is read-only. If true, the preference cannot be changed by the Subscriber.',
    default: false,
  })
  @IsBoolean()
  readOnly: boolean = false;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class WorkflowPreferenceDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/workflow-preferences.dto.ts
Tamaño: 1233 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiExtraModels, ApiProperty, getSchemaPath } from '@nestjs/swagger';
import { ChannelTypeEnum } from '@novu/shared';
import { Type } from 'class-transformer';
import { ValidateNested } from 'class-validator';
import { ChannelPreferenceDto } from './channel-preference.dto';
import { WorkflowPreferenceDto } from './workflow-preference.dto';

@ApiExtraModels(WorkflowPreferenceDto, ChannelPreferenceDto)
export class WorkflowPreferencesDto {
  @ApiProperty({
    description:
      'A preference for the workflow. The values specified here will be used if no preference is specified for a channel.',
    oneOf: [{ $ref: getSchemaPath(WorkflowPreferenceDto) }],
  })
  @ValidateNested()
  @Type(() => WorkflowPreferenceDto)
  all: WorkflowPreferenceDto;

  @ApiProperty({
    description: 'Preferences for different communication channels',
    type: 'object',
    additionalProperties: {
      $ref: '#/components/schemas/ChannelPreferenceDto',
    },
    example: {
      [ChannelTypeEnum.EMAIL]: {
        enabled: true,
      },
      [ChannelTypeEnum.SMS]: {
        enabled: false,
      },
    },
  })
  @ValidateNested()
  @Type(() => ChannelPreferenceDto)
  channels: Record<ChannelTypeEnum, ChannelPreferenceDto>;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class WorkflowPreferencesDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/workflow-response.dto.ts
Tamaño: 6817 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiExtraModels, ApiProperty, ApiPropertyOptional, getSchemaPath } from '@nestjs/swagger';
import {
  CreateWorkflowDto,
  ResourceOriginEnum,
  SeverityLevelEnum,
  Slug,
  StepTypeEnum,
  UpdateWorkflowDto,
  WorkflowStatusEnum,
} from '@novu/shared';
import { Type } from 'class-transformer';
import { IsEnum, IsOptional, IsString, ValidateNested } from 'class-validator';
import { WorkflowPreferencesResponseDto } from './preferences.response.dto';
import { RuntimeIssueDto } from './runtime-issue.dto';
import { StepResponseDto } from './step.response.dto';
import { ChatStepResponseDto } from './step-responses/chat-step.response.dto';
import { CustomStepResponseDto } from './step-responses/custom-step.response.dto';
import { DelayStepResponseDto } from './step-responses/delay-step.response.dto';
import { DigestStepResponseDto } from './step-responses/digest-step.response.dto';
import { EmailStepResponseDto } from './step-responses/email-step.response.dto';
import { InAppStepResponseDto } from './step-responses/in-app-step.response.dto';
import { PushStepResponseDto } from './step-responses/push-step.response.dto';
import { SmsStepResponseDto } from './step-responses/sms-step.response.dto';
import { ThrottleStepResponseDto } from './step-responses/throttle-step.response.dto';
import { UserResponseDto } from './user-response.dto';
import { WorkflowCommonsFields } from './workflow-commons.dto';

@ApiExtraModels(
  RuntimeIssueDto,
  StepResponseDto,
  EmailStepResponseDto,
  SmsStepResponseDto,
  PushStepResponseDto,
  ChatStepResponseDto,
  DelayStepResponseDto,
  DigestStepResponseDto,
  ThrottleStepResponseDto,
  CustomStepResponseDto,
  InAppStepResponseDto,
  UserResponseDto
)
export class WorkflowResponseDto extends WorkflowCommonsFields {
  @ApiProperty({ description: 'Database identifier of the workflow' })
  @IsString()
  _id: string;

  @ApiProperty({ description: 'Workflow identifier' })
  @IsString()
  workflowId: string;

  @ApiProperty({ description: 'Slug of the workflow', type: 'string' })
  @IsString()
  slug: Slug;

  @ApiProperty({ description: 'Last updated timestamp' })
  @IsString()
  updatedAt: string;

  @ApiProperty({ description: 'Creation timestamp' })
  @IsString()
  createdAt: string;

  @ApiPropertyOptional({
    description: 'User who last updated the workflow',
    type: () => UserResponseDto,
    nullable: true,
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => UserResponseDto)
  updatedBy?: UserResponseDto;

  @ApiPropertyOptional({
    description: 'Timestamp of the last workflow publication',
    type: 'string',
    nullable: true,
  })
  @IsOptional()
  @IsString()
  lastPublishedAt?: string | null;

  @ApiPropertyOptional({
    description: 'User who last published the workflow',
    type: () => UserResponseDto,
    nullable: true,
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => UserResponseDto)
  lastPublishedBy?: UserResponseDto | null;

  @ApiProperty({
    description: 'Steps of the workflow',
    type: 'array',
    items: {
      oneOf: [
        { $ref: getSchemaPath(InAppStepResponseDto) },
        { $ref: getSchemaPath(EmailStepResponseDto) },
        { $ref: getSchemaPath(SmsStepResponseDto) },
        { $ref: getSchemaPath(PushStepResponseDto) },
        { $ref: getSchemaPath(ChatStepResponseDto) },
        { $ref: getSchemaPath(DelayStepResponseDto) },
        { $ref: getSchemaPath(DigestStepResponseDto) },
        { $ref: getSchemaPath(CustomStepResponseDto) },
        { $ref: getSchemaPath(ThrottleStepResponseDto) },
      ],
      discriminator: {
        propertyName: 'type',
        mapping: {
          [StepTypeEnum.IN_APP]: getSchemaPath(InAppStepResponseDto),
          [StepTypeEnum.EMAIL]: getSchemaPath(EmailStepResponseDto),
          [StepTypeEnum.SMS]: getSchemaPath(SmsStepResponseDto),
          [StepTypeEnum.PUSH]: getSchemaPath(PushStepResponseDto),
          [StepTypeEnum.CHAT]: getSchemaPath(ChatStepResponseDto),
          [StepTypeEnum.DELAY]: getSchemaPath(DelayStepResponseDto),
          [StepTypeEnum.DIGEST]: getSchemaPath(DigestStepResponseDto),
          [StepTypeEnum.CUSTOM]: getSchemaPath(CustomStepResponseDto),
          [StepTypeEnum.THROTTLE]: getSchemaPath(ThrottleStepResponseDto),
        },
      },
    },
  })
  @ValidateNested({ each: true })
  @Type(() => StepResponseDto, {
    discriminator: {
      property: 'type',
      subTypes: [
        { name: StepTypeEnum.IN_APP, value: InAppStepResponseDto },
        { name: StepTypeEnum.EMAIL, value: EmailStepResponseDto },
        { name: StepTypeEnum.SMS, value: SmsStepResponseDto },
        { name: StepTypeEnum.PUSH, value: PushStepResponseDto },
        { name: StepTypeEnum.CHAT, value: ChatStepResponseDto },
        { name: StepTypeEnum.DELAY, value: DelayStepResponseDto },
        { name: StepTypeEnum.DIGEST, value: DigestStepResponseDto },
        { name: StepTypeEnum.CUSTOM, value: CustomStepResponseDto },
        { name: StepTypeEnum.THROTTLE, value: ThrottleStepResponseDto },
      ],
    },
    keepDiscriminatorProperty: true,
  })
  steps: StepResponseDto[];

  @ApiProperty({
    description: 'Origin of the workflow',
    enum: [...Object.values(ResourceOriginEnum)],
    enumName: 'ResourceOriginEnum',
  })
  @IsEnum(ResourceOriginEnum)
  origin: ResourceOriginEnum;

  @ApiProperty({
    description: 'Preferences for the workflow',
    type: () => WorkflowPreferencesResponseDto,
  })
  @ValidateNested()
  @Type(() => WorkflowPreferencesResponseDto)
  preferences: WorkflowPreferencesResponseDto;

  @ApiProperty({
    description: 'Status of the workflow',
    enum: [...Object.values(WorkflowStatusEnum)],
    enumName: 'WorkflowStatusEnum',
  })
  @IsEnum(WorkflowStatusEnum)
  status: WorkflowStatusEnum;

  @ApiPropertyOptional({
    description: 'Runtime issues for workflow creation and update',
    type: 'object',
    additionalProperties: {
      $ref: getSchemaPath(RuntimeIssueDto),
    },
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => RuntimeIssueDto)
  issues?: Record<WorkflowCreateAndUpdateKeys, RuntimeIssueDto>;

  @ApiPropertyOptional({
    description: 'Timestamp of the last workflow trigger',
    type: 'string',
    nullable: true,
  })
  @IsOptional()
  @IsString()
  lastTriggeredAt?: string;

  @ApiPropertyOptional({
    description: 'Generated payload example based on the payload schema',
    type: 'object',
    nullable: true,
    additionalProperties: true,
  })
  @IsOptional()
  payloadExample?: object | null;

  @ApiProperty({
    description: 'Severity of the workflow',
    enum: [...Object.values(SeverityLevelEnum)],
    enumName: 'SeverityLevelEnum',
  })
  @IsEnum(SeverityLevelEnum)
  severity: SeverityLevelEnum;
}

export type WorkflowCreateAndUpdateKeys = keyof CreateWorkflowDto | keyof UpdateWorkflowDto;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class WorkflowResponseDto
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/workflow-test-data.dto.ts
Tamaño: 604 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { ValidateNested } from 'class-validator';
import { JSONSchemaDto } from '../../shared/dtos/json-schema.dto';

export class WorkflowTestDataResponseDto {
  @ApiProperty({
    description: 'JSON Schema for recipient data',
    type: () => JSONSchemaDto,
  })
  @ValidateNested()
  @Type(() => JSONSchemaDto)
  to: JSONSchemaDto;

  @ApiProperty({
    description: 'JSON Schema for payload data',
    type: () => JSONSchemaDto,
  })
  @ValidateNested()
  @Type(() => JSONSchemaDto)
  payload: JSONSchemaDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class WorkflowTestDataResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/controls/chat-control.dto.ts
Tamaño: 354 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IsOptional, IsString, MinLength } from 'class-validator';
import { SkipControlDto } from './skip.dto';

export class ChatControlDto extends SkipControlDto {
  @ApiPropertyOptional({ description: 'Content of the chat message.' })
  @IsString()
  @IsOptional()
  body: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ChatControlDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/controls/custom-control.dto.ts
Tamaño: 350 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional } from '@nestjs/swagger';
import { IsObject, IsOptional } from 'class-validator';

export class CustomControlDto {
  @ApiPropertyOptional({
    description: 'Custom control values for the step.',
    type: 'object',
    additionalProperties: true,
  })
  @IsObject()
  @IsOptional()
  custom?: Record<string, unknown>;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CustomControlDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/controls/delay-control.dto.ts
Tamaño: 1358 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { DelayTypeEnum, TimeUnitEnum } from '@novu/shared';
import { IsEnum, IsNumber, IsOptional, IsString, Min, MinLength, ValidateIf } from 'class-validator';
import { SkipControlDto } from './skip.dto';

export class DelayControlDto extends SkipControlDto {
  @ApiProperty({
    description: "Type of the delay. Currently only 'regular' is supported by the schema.",
    enum: [DelayTypeEnum.REGULAR, DelayTypeEnum.TIMED],
    default: DelayTypeEnum.REGULAR,
  })
  @IsEnum([DelayTypeEnum.REGULAR, DelayTypeEnum.TIMED])
  @IsOptional()
  type?: DelayTypeEnum.REGULAR | DelayTypeEnum.TIMED;

  @ApiPropertyOptional({
    description: 'Amount of time to delay.',
    type: Number,
    minimum: 1,
  })
  @ValidateIf((obj) => obj.type === DelayTypeEnum.REGULAR)
  @IsNumber()
  @Min(1)
  @IsOptional()
  amount?: number;

  @ApiPropertyOptional({
    description: 'Unit of time for the delay amount.',
    enum: TimeUnitEnum,
  })
  @ValidateIf((obj) => obj.type === DelayTypeEnum.REGULAR)
  @IsEnum(TimeUnitEnum)
  @IsOptional()
  unit?: TimeUnitEnum;

  @ApiPropertyOptional({
    description: 'Cron expression for the delay. Min length 1.',
    type: String,
  })
  @ValidateIf((obj) => obj.type === DelayTypeEnum.TIMED)
  @IsString()
  @MinLength(1)
  @IsOptional()
  cron?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DelayControlDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/controls/digest-control.dto.ts
Tamaño: 2016 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional } from '@nestjs/swagger';
import { DigestTypeEnum, TimeUnitEnum } from '@novu/shared';
import { Type } from 'class-transformer';
import { IsEnum, IsNumber, IsOptional, IsString, Min, MinLength, ValidateIf, ValidateNested } from 'class-validator';
import { LookBackWindowDto } from './look-back-window.dto';
import { SkipControlDto } from './skip.dto';

export class DigestControlDto extends SkipControlDto {
  @ApiPropertyOptional({
    description: 'The type of digest strategy. Determines which fields are applicable.',
    enum: [DigestTypeEnum.REGULAR, DigestTypeEnum.TIMED],
  })
  @IsEnum([DigestTypeEnum.REGULAR, DigestTypeEnum.TIMED])
  @IsOptional()
  type?: DigestTypeEnum.REGULAR | DigestTypeEnum.TIMED;

  @ApiPropertyOptional({
    description: 'The amount of time for the digest interval (for REGULAR type). Min 1.',
    type: Number,
    minimum: 1,
  })
  @ValidateIf((obj) => obj.type === DigestTypeEnum.REGULAR)
  @IsNumber()
  @Min(1)
  @IsOptional()
  amount?: number;

  @ApiPropertyOptional({
    description: 'The unit of time for the digest interval (for REGULAR type).',
    enum: TimeUnitEnum,
  })
  @ValidateIf((obj) => obj.type === DigestTypeEnum.REGULAR)
  @IsEnum(TimeUnitEnum)
  @IsOptional()
  unit?: TimeUnitEnum;

  @ApiPropertyOptional({
    description: 'Configuration for look-back window (for REGULAR type).',
    type: LookBackWindowDto,
  })
  @ValidateIf((obj) => obj.type === DigestTypeEnum.REGULAR)
  @ValidateNested()
  @Type(() => LookBackWindowDto)
  @IsOptional()
  lookBackWindow?: LookBackWindowDto;

  @ApiPropertyOptional({
    description: 'Cron expression for TIMED digest. Min length 1.',
    type: String,
  })
  @ValidateIf((obj) => obj.type === DigestTypeEnum.TIMED)
  @IsString()
  @MinLength(1)
  @IsOptional()
  cron?: string;

  @ApiPropertyOptional({
    description: 'Specify a custom key for digesting events instead of the default event key.',
    type: String,
  })
  @IsString()
  @IsOptional()
  digestKey?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DigestControlDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/controls/email-control.dto.ts
Tamaño: 1232 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IsBoolean, IsOptional, IsString, MinLength, ValidateIf } from 'class-validator';
import { SkipControlDto } from './skip.dto';

export class EmailControlDto extends SkipControlDto {
  @ApiProperty({ description: 'Subject of the email.', minLength: 1 })
  @IsString()
  @IsOptional()
  subject: string;

  @ApiProperty({
    description: 'Body content of the email, either a valid Maily JSON object, or html string.',
    default: '',
  })
  @IsString()
  body: string = '';

  @ApiPropertyOptional({
    description: 'Type of editor to use for the body.',
    enum: ['block', 'html'],
    default: 'block',
  })
  @IsString()
  @IsOptional()
  editorType?: 'block' | 'html' = 'block';

  @ApiPropertyOptional({ description: 'Disable sanitization of the output.', default: false })
  @IsBoolean()
  @IsOptional()
  disableOutputSanitization?: boolean = false;

  @ApiPropertyOptional({
    type: String,
    description: 'Layout ID to use for the email. Null means no layout, undefined means default layout.',
    nullable: true,
  })
  @IsOptional()
  @ValidateIf((obj) => obj.layoutId !== null)
  @IsString()
  @MinLength(1)
  layoutId?: string | null;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - boolean(false;

  @ApiPropertyOptional({
    type: String,
    description: 'Layout ID to use for the email....)
Declaraciones 'export' encontradas:
- export class EmailControlDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/controls/in-app-control.dto.ts
Tamaño: 3392 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { IsBoolean, IsEnum, IsOptional, IsString, IsUrl, MinLength, ValidateIf, ValidateNested } from 'class-validator';
import { SkipControlDto } from './skip.dto';

// Define enum for redirect target based on Zod schema
enum RedirectTargetEnum {
  SELF = '_self',
  BLANK = '_blank',
  PARENT = '_parent',
  TOP = '_top',
  UNFENCED_TOP = '_unfencedTop',
}

class RedirectDto {
  @ApiPropertyOptional({ description: 'URL for redirection. Must be a valid URL or start with / or {{ variable }}.' })
  /*
   * Note: Cannot directly validate complex regex like schema's with class-validator decorators easily.
   * Basic IsUrl or IsString might be sufficient for DTO, relying on backend Zod validation.
   */
  @IsString() // Using IsString as IsUrl might be too strict for template variables
  @IsOptional()
  url?: string;

  @ApiPropertyOptional({
    description: 'Target window for the redirection.',
    enum: RedirectTargetEnum,
    default: RedirectTargetEnum.SELF,
  })
  @IsEnum(RedirectTargetEnum)
  @IsOptional()
  target?: RedirectTargetEnum;
}

class ActionDto {
  @ApiPropertyOptional({ description: 'Label for the action button.' })
  @IsString()
  @IsOptional()
  label?: string;

  @ApiPropertyOptional({ description: 'Redirect configuration for the action.', type: RedirectDto })
  @ValidateNested()
  @Type(() => RedirectDto)
  @IsOptional()
  redirect?: RedirectDto; // Changed from url to redirect object
}

export class InAppControlDto extends SkipControlDto {
  @ApiPropertyOptional({
    description: 'Content/body of the in-app message. Required if subject is empty.',
    minLength: 1,
  })
  @IsString()
  @MinLength(1)
  @ValidateIf((obj) => !obj.subject || obj.subject.length === 0)
  @IsOptional()
  body?: string;

  @ApiPropertyOptional({ description: 'Subject/title of the in-app message. Required if body is empty.', minLength: 1 })
  @IsString()
  @MinLength(1)
  @ValidateIf((obj) => !obj.body || obj.body.length === 0)
  @IsOptional()
  subject?: string;

  @ApiPropertyOptional({
    description: 'URL for an avatar image. Must be a valid URL or start with / or {{ variable }}.',
  })
  // Note: Cannot directly validate complex regex like schema's with class-validator decorators easily.
  @IsString() // Using IsString
  @IsOptional()
  avatar?: string;

  @ApiPropertyOptional({ description: 'Primary action button details.', type: ActionDto })
  @ValidateNested()
  @Type(() => ActionDto)
  @IsOptional()
  primaryAction?: ActionDto;

  @ApiPropertyOptional({ description: 'Secondary action button details.', type: ActionDto })
  @ValidateNested()
  @Type(() => ActionDto)
  @IsOptional()
  secondaryAction?: ActionDto;

  @ApiPropertyOptional({
    description: 'Redirection URL configuration for the main content click (if no actions defined/clicked)..',
    type: RedirectDto,
  })
  @ValidateNested()
  @Type(() => RedirectDto)
  @IsOptional()
  redirect?: RedirectDto;

  @ApiPropertyOptional({ description: 'Disable sanitization of the output.', default: false })
  @IsBoolean()
  @IsOptional()
  disableOutputSanitization?: boolean = false;

  @ApiPropertyOptional({
    description: 'Additional data payload for the step.',
    type: 'object',
    additionalProperties: true,
  })
  @IsOptional()
  data?: Record<string, unknown>;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - UNFENCED_TOP('_unfencedTop',
}

class RedirectDto {
  @ApiPropertyOptional({ description: 'URL for redirection. M...)
Declaraciones 'export' encontradas:
- export class InAppControlDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/controls/index.ts
Tamaño: 363 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './chat-control.dto';
export * from './custom-control.dto';
export * from './delay-control.dto';
export * from './digest-control.dto';
export * from './email-control.dto';
export * from './in-app-control.dto';
export * from './push-control.dto';
export * from './skip.dto';
export * from './sms-control.dto';
export * from './throttle-control.dto';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/controls/look-back-window.dto.ts
Tamaño: 496 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { TimeUnitEnum } from '@novu/shared';
import { IsEnum, IsNumber, Min } from 'class-validator';

export class LookBackWindowDto {
  @ApiProperty({
    description: 'Amount of time for the look-back window.',
    type: Number,
    minimum: 1,
  })
  @IsNumber()
  @Min(1)
  amount: number;

  @ApiProperty({
    description: 'Unit of time for the look-back window.',
    enum: TimeUnitEnum,
  })
  @IsEnum(TimeUnitEnum)
  unit: TimeUnitEnum;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class LookBackWindowDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/controls/push-control.dto.ts
Tamaño: 497 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IsOptional, IsString, MinLength } from 'class-validator';
import { SkipControlDto } from './skip.dto';

export class PushControlDto extends SkipControlDto {
  @ApiPropertyOptional({ description: 'Subject/title of the push notification.' })
  @IsString()
  @IsOptional()
  subject: string;

  @ApiPropertyOptional({ description: 'Body content of the push notification.' })
  @IsString()
  @IsOptional()
  body: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class PushControlDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/controls/skip.dto.ts
Tamaño: 979 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional } from '@nestjs/swagger';
import { IsObject, IsOptional } from 'class-validator';

export class SkipControlDto {
  @ApiPropertyOptional({
    description:
      'JSONLogic filter conditions for conditionally skipping the step execution. Supports complex logical operations with AND, OR, and comparison operators. See https://jsonlogic.com/ for full typing reference.',
    type: 'object',
    example: {
      and: [
        {
          '==': [
            {
              var: 'payload.tier',
            },
            'pro',
          ],
        },
        {
          '==': [
            {
              var: 'subscriber.data.role',
            },
            'admin',
          ],
        },
        {
          '>': [
            {
              var: 'payload.amount',
            },
            '4',
          ],
        },
      ],
    },
    additionalProperties: true,
  })
  @IsObject()
  @IsOptional()
  skip?: Record<string, unknown>;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SkipControlDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/controls/sms-control.dto.ts
Tamaño: 341 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IsOptional, IsString } from 'class-validator';
import { SkipControlDto } from './skip.dto';

export class SmsControlDto extends SkipControlDto {
  @ApiPropertyOptional({ description: 'Content of the SMS message.' })
  @IsString()
  @IsOptional()
  body: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SmsControlDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/controls/throttle-control.dto.ts
Tamaño: 2151 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { TimeUnitEnum } from '@novu/shared';
import { IsEnum, IsNumber, IsOptional, IsString, Max, Min, MinLength } from 'class-validator';
import { SkipControlDto } from './skip.dto';

// Throttle-specific time units (excluding seconds for performance reasons)
const ThrottleTimeUnitEnum = {
  MINUTES: TimeUnitEnum.MINUTES,
  HOURS: TimeUnitEnum.HOURS,
  DAYS: TimeUnitEnum.DAYS,
} as const;

// Throttle type enum
const ThrottleTypeEnum = {
  FIXED: 'fixed',
  DYNAMIC: 'dynamic',
} as const;

type ThrottleTimeUnit = (typeof ThrottleTimeUnitEnum)[keyof typeof ThrottleTimeUnitEnum];
type ThrottleType = (typeof ThrottleTypeEnum)[keyof typeof ThrottleTypeEnum];

export class ThrottleControlDto extends SkipControlDto {
  @ApiProperty({
    description: 'The type of throttle window.',
    enum: ThrottleTypeEnum,
    default: 'fixed',
  })
  @IsEnum(ThrottleTypeEnum)
  @IsOptional()
  type?: ThrottleType;

  @ApiPropertyOptional({
    description: 'The amount of time for the throttle window (required for fixed type).',
    type: Number,
    minimum: 1,
  })
  @IsNumber()
  @Min(1)
  @IsOptional()
  amount?: number;

  @ApiPropertyOptional({
    description: 'The unit of time for the throttle window (required for fixed type).',
    enum: ThrottleTimeUnitEnum,
  })
  @IsEnum(ThrottleTimeUnitEnum)
  @IsOptional()
  unit?: ThrottleTimeUnit;

  @ApiPropertyOptional({
    description: 'Key path to retrieve dynamic window value (required for dynamic type).',
    type: String,
    example: 'payload.timestamp',
  })
  @IsString()
  @MinLength(1)
  @IsOptional()
  dynamicKey?: string;

  @ApiPropertyOptional({
    description: 'The maximum number of executions allowed within the window. Defaults to 1.',
    type: Number,
    minimum: 1,
    default: 1,
  })
  @IsNumber()
  @Min(1)
  @Max(100)
  @IsOptional()
  threshold?: number;

  @ApiPropertyOptional({
    description:
      'Optional key for grouping throttle rules. If not provided, defaults to workflow and subscriber combination.',
    type: String,
  })
  @IsString()
  @IsOptional()
  throttleKey?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ThrottleControlDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/step-responses/chat-step.response.dto.ts
Tamaño: 1137 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { ValidateNested } from 'class-validator';
import { ChatControlDto } from '../controls/chat-control.dto';
import { ControlsMetadataDto } from '../controls-metadata.dto';
import { StepResponseDto } from '../step.response.dto';

class ChatControlsMetadataResponseDto extends ControlsMetadataDto {
  @ApiProperty({
    description: 'Control values specific to Chat',
    type: () => ChatControlDto,
  })
  @ValidateNested()
  @Type(() => ChatControlDto)
  declare values: ChatControlDto;
}

export class ChatStepResponseDto extends StepResponseDto<ChatControlDto> {
  @ApiProperty({
    description: 'Controls metadata for the chat step',
    type: () => ChatControlsMetadataResponseDto,
  })
  @ValidateNested()
  @Type(() => ChatControlsMetadataResponseDto)
  declare controls: ChatControlsMetadataResponseDto;

  @ApiPropertyOptional({
    description: 'Control values for the chat step',
    type: () => ChatControlDto,
  })
  @ValidateNested()
  @Type(() => ChatControlDto)
  declare controlValues?: ChatControlDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ChatStepResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/step-responses/custom-step.response.dto.ts
Tamaño: 1176 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { ValidateNested } from 'class-validator';
import { CustomControlDto } from '../controls/custom-control.dto';
import { ControlsMetadataDto } from '../controls-metadata.dto';
import { StepResponseDto } from '../step.response.dto';

class CustomControlsMetadataResponseDto extends ControlsMetadataDto {
  @ApiProperty({
    description: 'Control values specific to Custom step',
    type: () => CustomControlDto,
  })
  @ValidateNested()
  @Type(() => CustomControlDto)
  declare values: CustomControlDto;
}

export class CustomStepResponseDto extends StepResponseDto<CustomControlDto> {
  @ApiProperty({
    description: 'Controls metadata for the custom step',
    type: () => CustomControlsMetadataResponseDto,
  })
  @ValidateNested()
  @Type(() => CustomControlsMetadataResponseDto)
  declare controls: CustomControlsMetadataResponseDto;

  @ApiPropertyOptional({
    description: 'Control values for the custom step',
    type: () => CustomControlDto,
  })
  @ValidateNested()
  @Type(() => CustomControlDto)
  declare controlValues?: CustomControlDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CustomStepResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/step-responses/delay-step.response.dto.ts
Tamaño: 1154 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { ValidateNested } from 'class-validator';
import { DelayControlDto } from '../controls/delay-control.dto';
import { ControlsMetadataDto } from '../controls-metadata.dto';
import { StepResponseDto } from '../step.response.dto';

class DelayControlsMetadataResponseDto extends ControlsMetadataDto {
  @ApiProperty({
    description: 'Control values specific to Delay',
    type: () => DelayControlDto,
  })
  @ValidateNested()
  @Type(() => DelayControlDto)
  declare values: DelayControlDto;
}

export class DelayStepResponseDto extends StepResponseDto<DelayControlDto> {
  @ApiProperty({
    description: 'Controls metadata for the delay step',
    type: () => DelayControlsMetadataResponseDto,
  })
  @ValidateNested()
  @Type(() => DelayControlsMetadataResponseDto)
  declare controls: DelayControlsMetadataResponseDto;

  @ApiPropertyOptional({
    description: 'Control values for the delay step',
    type: () => DelayControlDto,
  })
  @ValidateNested()
  @Type(() => DelayControlDto)
  declare controlValues?: DelayControlDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DelayStepResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/step-responses/digest-step.response.dto.ts
Tamaño: 1171 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { ValidateNested } from 'class-validator';
import { DigestControlDto } from '../controls/digest-control.dto';
import { ControlsMetadataDto } from '../controls-metadata.dto';
import { StepResponseDto } from '../step.response.dto';

class DigestControlsMetadataResponseDto extends ControlsMetadataDto {
  @ApiProperty({
    description: 'Control values specific to Digest',
    type: () => DigestControlDto,
  })
  @ValidateNested()
  @Type(() => DigestControlDto)
  declare values: DigestControlDto;
}

export class DigestStepResponseDto extends StepResponseDto<DigestControlDto> {
  @ApiProperty({
    description: 'Controls metadata for the digest step',
    type: () => DigestControlsMetadataResponseDto,
  })
  @ValidateNested()
  @Type(() => DigestControlsMetadataResponseDto)
  declare controls: DigestControlsMetadataResponseDto;

  @ApiPropertyOptional({
    description: 'Control values for the digest step',
    type: () => DigestControlDto,
  })
  @ValidateNested()
  @Type(() => DigestControlDto)
  declare controlValues?: DigestControlDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DigestStepResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/step-responses/email-step.response.dto.ts
Tamaño: 1154 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { ValidateNested } from 'class-validator';
import { EmailControlDto } from '../controls/email-control.dto';
import { ControlsMetadataDto } from '../controls-metadata.dto';
import { StepResponseDto } from '../step.response.dto';

class EmailControlsMetadataResponseDto extends ControlsMetadataDto {
  @ApiProperty({
    description: 'Control values specific to Email',
    type: () => EmailControlDto,
  })
  @ValidateNested()
  @Type(() => EmailControlDto)
  declare values: EmailControlDto;
}

export class EmailStepResponseDto extends StepResponseDto<EmailControlDto> {
  @ApiProperty({
    description: 'Controls metadata for the email step',
    type: () => EmailControlsMetadataResponseDto,
  })
  @ValidateNested()
  @Type(() => EmailControlsMetadataResponseDto)
  declare controls: EmailControlsMetadataResponseDto;

  @ApiPropertyOptional({
    description: 'Control values for the email step',
    type: () => EmailControlDto,
  })
  @ValidateNested()
  @Type(() => EmailControlDto)
  declare controlValues?: EmailControlDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class EmailStepResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/step-responses/in-app-step.response.dto.ts
Tamaño: 1158 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { ValidateNested } from 'class-validator';
import { InAppControlDto } from '../controls/in-app-control.dto';
import { ControlsMetadataDto } from '../controls-metadata.dto';
import { StepResponseDto } from '../step.response.dto';

class InAppControlsMetadataResponseDto extends ControlsMetadataDto {
  @ApiProperty({
    description: 'Control values specific to In-App',
    type: () => InAppControlDto,
  })
  @ValidateNested()
  @Type(() => InAppControlDto)
  declare values: InAppControlDto;
}

export class InAppStepResponseDto extends StepResponseDto<InAppControlDto> {
  @ApiProperty({
    description: 'Controls metadata for the in-app step',
    type: () => InAppControlsMetadataResponseDto,
  })
  @ValidateNested()
  @Type(() => InAppControlsMetadataResponseDto)
  declare controls: InAppControlsMetadataResponseDto;

  @ApiPropertyOptional({
    description: 'Control values for the in-app step',
    type: () => InAppControlDto,
  })
  @ValidateNested()
  @Type(() => InAppControlDto)
  declare controlValues?: InAppControlDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class InAppStepResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/step-responses/push-step.response.dto.ts
Tamaño: 1137 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { ValidateNested } from 'class-validator';
import { PushControlDto } from '../controls/push-control.dto';
import { ControlsMetadataDto } from '../controls-metadata.dto';
import { StepResponseDto } from '../step.response.dto';

class PushControlsMetadataResponseDto extends ControlsMetadataDto {
  @ApiProperty({
    description: 'Control values specific to Push',
    type: () => PushControlDto,
  })
  @ValidateNested()
  @Type(() => PushControlDto)
  declare values: PushControlDto;
}

export class PushStepResponseDto extends StepResponseDto<PushControlDto> {
  @ApiProperty({
    description: 'Controls metadata for the push step',
    type: () => PushControlsMetadataResponseDto,
  })
  @ValidateNested()
  @Type(() => PushControlsMetadataResponseDto)
  declare controls: PushControlsMetadataResponseDto;

  @ApiPropertyOptional({
    description: 'Control values for the push step',
    type: () => PushControlDto,
  })
  @ValidateNested()
  @Type(() => PushControlDto)
  declare controlValues?: PushControlDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class PushStepResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/step-responses/sms-step.response.dto.ts
Tamaño: 1120 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { ValidateNested } from 'class-validator';
import { SmsControlDto } from '../controls/sms-control.dto';
import { ControlsMetadataDto } from '../controls-metadata.dto';
import { StepResponseDto } from '../step.response.dto';

class SmsControlsMetadataResponseDto extends ControlsMetadataDto {
  @ApiProperty({
    description: 'Control values specific to SMS',
    type: () => SmsControlDto,
  })
  @ValidateNested()
  @Type(() => SmsControlDto)
  declare values: SmsControlDto;
}

export class SmsStepResponseDto extends StepResponseDto<SmsControlDto> {
  @ApiProperty({
    description: 'Controls metadata for the SMS step',
    type: () => SmsControlsMetadataResponseDto,
  })
  @ValidateNested()
  @Type(() => SmsControlsMetadataResponseDto)
  declare controls: SmsControlsMetadataResponseDto;

  @ApiPropertyOptional({
    description: 'Control values for the SMS step',
    type: () => SmsControlDto,
  })
  @ValidateNested()
  @Type(() => SmsControlDto)
  declare controlValues?: SmsControlDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SmsStepResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/dtos/step-responses/throttle-step.response.dto.ts
Tamaño: 1205 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { ValidateNested } from 'class-validator';
import { ThrottleControlDto } from '../controls/throttle-control.dto';
import { ControlsMetadataDto } from '../controls-metadata.dto';
import { StepResponseDto } from '../step.response.dto';

class ThrottleControlsMetadataResponseDto extends ControlsMetadataDto {
  @ApiProperty({
    description: 'Control values specific to Throttle',
    type: () => ThrottleControlDto,
  })
  @ValidateNested()
  @Type(() => ThrottleControlDto)
  declare values: ThrottleControlDto;
}

export class ThrottleStepResponseDto extends StepResponseDto<ThrottleControlDto> {
  @ApiProperty({
    description: 'Controls metadata for the throttle step',
    type: () => ThrottleControlsMetadataResponseDto,
  })
  @ValidateNested()
  @Type(() => ThrottleControlsMetadataResponseDto)
  declare controls: ThrottleControlsMetadataResponseDto;

  @ApiPropertyOptional({
    description: 'Control values for the throttle step',
    type: () => ThrottleControlDto,
  })
  @ValidateNested()
  @Type(() => ThrottleControlDto)
  declare controlValues?: ThrottleControlDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ThrottleStepResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/e2e/generate-preview.e2e.ts
Tamaño: 96818 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { randomUUID } from 'node:crypto';
import { Novu } from '@novu/api';
import {
  ChannelTypeEnum,
  CreateWorkflowDto,
  EmailRenderOutput,
  GeneratePreviewRequestDto,
  GeneratePreviewResponseDto,
  PreviewPayloadDto,
  ResourceOriginEnum,
  StepTypeEnum,
  UpdateWorkflowDto,
  UpdateWorkflowDtoSteps,
  WorkflowCreationSourceEnum,
  WorkflowResponseDto,
} from '@novu/api/models/components';
import { EmailControlType } from '@novu/application-generic';
import { EnvironmentRepository, NotificationTemplateEntity, NotificationTemplateRepository } from '@novu/dal';
import { CronExpressionEnum, RedirectTargetEnum, slugify } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { beforeEach } from 'mocha';
import { initNovuClassSdkInternalAuth } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';
import { DEFAULT_ARRAY_ELEMENTS } from '../../shared/usecases/create-variables-object/create-variables-object.usecase';
import { buildWorkflowSchema } from '../../shared/utils/create-schema';
import { fullCodeSnippet, previewPayloadExample } from '../maily-test-data';
import { buildWorkflow } from '../workflow.controller.e2e';

const TEST_WORKFLOW_NAME = 'Test Workflow Name';
const SUBJECT_TEST_PAYLOAD = '{{payload.subject.test.payload}}';
const PLACEHOLDER_SUBJECT_INAPP = '{{payload.subject}}';
const PLACEHOLDER_SUBJECT_INAPP_PAYLOAD_VALUE = 'this is the replacement text for the placeholder';

describe('Workflow Step Preview - POST /:workflowId/step/:stepId/preview #novu-v2', async () => {
  let session: UserSession;
  const notificationTemplateRepository = new NotificationTemplateRepository();
  const environmentRepository = new EnvironmentRepository();
  let novuClient: Novu;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    novuClient = initNovuClassSdkInternalAuth(session);
  });

  it('should generate preview for in-app step', async () => {
    const payloadSchema = {
      type: 'object',
      properties: {
        placeholder: {
          type: 'object',
          properties: {
            body: {
              type: 'string',
            },
          },
        },
        primaryUrlLabel: {
          type: 'string',
        },
      },
    };
    const workflow = await createWorkflow({}, payloadSchema);
    await emulateExternalOrigin(workflow.id);

    const stepId = workflow.steps[0].id;
    const controlValues = {
      subject: `{{subscriber.firstName}} Hello, World! `,
      body: `Hello, World! {{payload.placeholder.body}}`,
      avatar: 'https://www.example.com/avatar.png',
      primaryAction: {
        label: '{{payload.primaryUrlLabel}}',
        redirect: {
          target: RedirectTargetEnum.BLANK,
          url: '/home/primary-action',
        },
      },
      secondaryAction: {
        label: 'Secondary Action',
        redirect: {
          target: RedirectTargetEnum.BLANK,
          url: '/home/secondary-action',
        },
      },
      data: {
        key: 'value',
      },
      redirect: {
        target: RedirectTargetEnum.BLANK,
        url: 'https://www.example.com/redirect',
      },
    };
    const previewPayload: PreviewPayloadDto = {
      subscriber: {
        firstName: 'John',
      },
      payload: {
        placeholder: {
          body: 'This is a body',
        },
        primaryUrlLabel: 'https://example.com',
      },
    };

    const { result } = await novuClient.workflows.steps.generatePreview({
      workflowId: workflow.id,
      stepId,
      generatePreviewRequestDto: { controlValues, previewPayload },
    });

    expect(result).to.deep.equal({
      schema: {
        type: 'object',
        properties: {
          payload: {
            type: 'object',
            properties: {
              placeholder: {
                type: 'object',
                properties: {
                  body: {
                    type: 'string',
                  },
                },
              },
              primaryUrlLabel: {
                type: 'string',
              },
            },
          },
          subscriber: {
            type: 'object',
            description: 'Schema representing the subscriber entity',
            properties: {
              firstName: {
                type: 'string',
                description: "Subscriber's first name",
              },
              lastName: {
                type: 'string',
                description: "Subscriber's last name",
              },
              email: {
                type: 'string',
                description: "Subscriber's email address",
              },
              phone: {
                type: 'string',
                description: "Subscriber's phone number (optional)",
              },
              avatar: {
                type: 'string',
                description: "URL to the subscriber's avatar image (optional)",
              },
              locale: {
                type: 'string',
                description: 'Locale for the subscriber (optional)',
              },
              timezone: {
                type: 'string',
                description: 'Timezone for the subscriber (optional)',
              },
              subscriberId: {
                type: 'string',
                description: 'Unique identifier for the subscriber',
              },
              isOnline: {
                type: 'boolean',
                description: 'Indicates if the subscriber is online (optional)',
              },
              lastOnlineAt: {
                type: 'string',
                format: 'date-time',
                description: 'The last time the subscriber was online (optional)',
              },
              data: {
                type: 'object',
                properties: {},
                required: [],
                additionalProperties: true,
              },
            },
            required: ['subscriberId'],
            additionalProperties: false,
          },
          steps: {
            type: 'object',
            properties: {},
            required: [],
            additionalProperties: false,
            description: 'Previous Steps Results',
          },
          workflow: buildWorkflowSchema(),
        },
        additionalProperties: false,
      },
      result: {
        preview: {
          subject: 'John Hello, World! ',
          body: 'Hello, World! This is a body',
          avatar: 'https://www.example.com/avatar.png',
          primaryAction: {
            label: 'https://example.com',
            redirect: {
              url: '/home/primary-action',
              target: '_blank',
            },
          },
          secondaryAction: {
            label: 'Secondary Action',
            redirect: {
              url: '/home/secondary-action',
              target: '_blank',
            },
          },
          redirect: {
            url: 'https://www.example.com/redirect',
            target: '_blank',
          },
          data: {
            key: 'value',
          },
        },
        type: 'in_app',
      },
      previewPayloadExample: {
        subscriber: {
          firstName: 'John',
          lastName: 'Doe',
          email: 'user@example.com',
          phone: '+1234567890',
          avatar: 'https://example.com/avatar.png',
          locale: 'en_US',
          timezone: 'America/New_York',
          data: {},
        },
        payload: {
          placeholder: {
            body: 'This is a body',
          },
          primaryUrlLabel: 'https://example.com',
        },
        steps: {},
      },
    });
  });

  it('should generate preview for in-app step, based on stored payload schema', async () => {
    const payloadSchema = {
      type: 'object',
      properties: {
        placeholder: {
          type: 'object',
          properties: {
            body: {
              type: 'string',
              default: 'Default body text',
            },
            random: {
              type: 'string',
            },
          },
        },
        primaryUrlLabel: {
          type: 'string',
          default: 'Click here',
        },
        organizationName: {
          type: 'string',
          default: 'Pokemon Organization',
        },
      },
    };
    const workflow = await createWorkflow({}, payloadSchema);
    await emulateExternalOrigin(workflow.id);

    const stepId = workflow.steps[0].id;
    const controlValues = {
      subject: `{{subscriber.firstName}} Hello, World! `,
      body: `Hello, World! {{payload.placeholder.body}} {{payload.placeholder.random}}`,
      avatar: 'https://www.example.com/avatar.png',
      primaryAction: {
        label: '{{payload.primaryUrlLabel}}',
        redirect: {
          target: RedirectTargetEnum.BLANK,
          url: '/home/primary-action',
        },
      },
      secondaryAction: {
        label: 'Secondary Action',
        redirect: {
          target: RedirectTargetEnum.BLANK,
          url: '/home/secondary-action',
        },
      },
      data: {
        key: 'value',
      },
      redirect: {
        target: RedirectTargetEnum.BLANK,
        url: 'https://www.example.com/redirect',
      },
    };
    const clientVariablesExample = {
      subscriber: {
        firstName: 'First Name',
      },
      payload: {
        primaryUrlLabel: 'New Click Here',
        placeholder: {
          random: 'random',
        },
      },
    };
    const { result } = await novuClient.workflows.steps.generatePreview({
      generatePreviewRequestDto: {
        controlValues,
        previewPayload: clientVariablesExample,
      },
      stepId,
      workflowId: workflow.id,
    });

    expect(result).to.deep.equal({
      result: {
        preview: {
          subject: 'First Name Hello, World! ',
          body: 'Hello, World! Default body text random',
          avatar: 'https://www.example.com/avatar.png',
          primaryAction: {
            label: 'New Click Here',
            redirect: {
              url: '/home/primary-action',
              target: '_blank',
            },
          },
          secondaryAction: {
            label: 'Secondary Action',
            redirect: {
              url: '/home/secondary-action',
              target: '_blank',
            },
          },
          redirect: {
            url: 'https://www.example.com/redirect',
            target: '_blank',
          },
          data: {
            key: 'value',
          },
        },
        type: 'in_app',
      },
      schema: {
        additionalProperties: false,
        properties: {
          payload: {
            properties: {
              organizationName: {
                default: 'Pokemon Organization',
                type: 'string',
              },
              placeholder: {
                properties: {
                  body: {
                    default: 'Default body text',
                    type: 'string',
                  },
                  random: {
                    type: 'string',
                  },
                },
                type: 'object',
              },
              primaryUrlLabel: {
                default: 'Click here',
                type: 'string',
              },
            },
            type: 'object',
          },
          subscriber: {
            additionalProperties: false,
            description: 'Schema representing the subscriber entity',
            properties: {
              firstName: {
                type: 'string',
                description: "Subscriber's first name",
              },
              lastName: {
                type: 'string',
                description: "Subscriber's last name",
              },
              email: {
                type: 'string',
                description: "Subscriber's email address",
              },
              phone: {
                type: 'string',
                description: "Subscriber's phone number (optional)",
              },
              avatar: {
                type: 'string',
                description: "URL to the subscriber's avatar image (optional)",
              },
              locale: {
                type: 'string',
                description: 'Locale for the subscriber (optional)',
              },
              timezone: {
                type: 'string',
                description: 'Timezone for the subscriber (optional)',
              },
              subscriberId: {
                type: 'string',
                description: 'Unique identifier for the subscriber',
              },
              isOnline: {
                type: 'boolean',
                description: 'Indicates if the subscriber is online (optional)',
              },
              lastOnlineAt: {
                type: 'string',
                format: 'date-time',
                description: 'The last time the subscriber was online (optional)',
              },
              data: {
                additionalProperties: true,
                properties: {},
                required: [],
                type: 'object',
              },
            },
            required: ['subscriberId'],
            type: 'object',
          },
          steps: {
            type: 'object',
            properties: {},
            required: [],
            additionalProperties: false,
            description: 'Previous Steps Results',
          },
          workflow: buildWorkflowSchema(),
        },
        type: 'object',
      },
      previewPayloadExample: {
        subscriber: {
          firstName: 'First Name',
          lastName: 'Doe',
          email: 'user@example.com',
          phone: '+1234567890',
          avatar: 'https://example.com/avatar.png',
          locale: 'en_US',
          timezone: 'America/New_York',
          data: {},
        },
        payload: {
          placeholder: {
            body: 'Default body text',
            random: 'random',
          },
          primaryUrlLabel: 'New Click Here',
          organizationName: 'Pokemon Organization',
        },
        steps: {},
      },
    });
  });

  it('should return 201 for non-existent workflow', async () => {
    const pay = {
      type: 'object',
      properties: {
        firstName: {
          type: 'string',
        },
        lastName: {
          type: 'string',
        },
        organizationName: {
          type: 'string',
        },
      },
    };
    const workflow = await createWorkflow({ payloadSchema: pay });

    const nonExistentWorkflowId = 'non-existent-id';
    const stepId = workflow.steps[0].id;
    const { result } = await novuClient.workflows.steps.generatePreview({
      generatePreviewRequestDto: {
        controlValues: {},
      },
      stepId,
      workflowId: nonExistentWorkflowId,
    });

    expect(result).to.deep.equal({
      schema: null,
      result: {
        preview: {},
      },
      previewPayloadExample: {},
    });
  });

  it('should return 201 for non-existent step', async () => {
    const pay = {
      type: 'object',
      properties: {
        firstName: {
          type: 'string',
        },
        lastName: {
          type: 'string',
        },
        organizationName: {
          type: 'string',
        },
      },
    };
    const workflow = await createWorkflow({ payloadSchema: pay });
    const nonExistentStepId = 'non-existent-step-id';
    const { result } = await novuClient.workflows.steps.generatePreview({
      generatePreviewRequestDto: {
        controlValues: {},
      },
      stepId: nonExistentStepId,
      workflowId: workflow.id,
    });

    expect(result).to.deep.equal({
      schema: null,
      result: {
        preview: {},
      },
      previewPayloadExample: {},
    });
  });

  it('should generate preview for email step with subscriber variables', async () => {
    const createWorkflowDto: CreateWorkflowDto = {
      tags: [],
      source: WorkflowCreationSourceEnum.Editor,
      name: 'Email Test Workflow',
      workflowId: `email-test-workflow-${randomUUID()}`,
      description: 'This is a test workflow',
      active: true,
      steps: [
        {
          name: 'Email Test Step',
          type: StepTypeEnum.Email,
          controlValues: {
            subject: 'Test Email Subject',
            body: 'Hello, {{subscriber.firstName}}!',
            disableOutputSanitization: false,
          },
        },
      ],
    };
    const { result: workflow } = await novuClient.workflows.create(createWorkflowDto);
    const stepId = workflow.steps[0].id;
    const controlValues = {
      subject: 'Test Email Subject',
      body: 'Hello, {{subscriber.firstName}}!',
      disableOutputSanitization: false,
    };
    const previewPayload: PreviewPayloadDto = {
      subscriber: {
        firstName: 'John',
      },
    };

    const { result } = await novuClient.workflows.steps.generatePreview({
      workflowId: workflow.id,
      stepId,
      generatePreviewRequestDto: { controlValues, previewPayload },
    });

    expect(result.result.preview.subject).to.contain('Test Email Subject');
    expect(result.result.preview.body).to.contain('Hello, John!');
  });

  it.skip('should generate preview for the email step with digest variables', async () => {
    const { workflowId, emailStepDatabaseId } = await createWorkflowWithEmailLookingAtDigestResult();

    // Helper function to validate digest event structure
    const validateDigestEvents = (events: any[], expectedPayload: any) => {
      expect(events).to.have.length(DEFAULT_ARRAY_ELEMENTS);
      events.forEach((event) => {
        expect(event).to.have.property('id').that.is.a('string');
        expect(event).to.have.property('time').that.is.a('string');
        expect(event).to.have.property('payload').that.deep.equals(expectedPayload);
      });
    };

    // testing the steps.digest-step.events.length variable
    const controlValues1 = {
      body: '{"type":"doc","content":[{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","text":"events length "},{"type":"variable","attrs":{"id":"steps.digest-step.events.length","label":null,"fallback":null,"required":false,"aliasFor":null}},{"type":"text","text":" "}]},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","text":" "}]}]}',
      subject: 'events length',
    };
    const previewResponse1 = await novuClient.workflows.steps.generatePreview({
      generatePreviewRequestDto: { controlValues: controlValues1, previewPayload: {} },
      stepId: emailStepDatabaseId,
      workflowId,
    });
    expect(previewResponse1.result.result.preview.body).to.contain(`events length ${DEFAULT_ARRAY_ELEMENTS}`);
    validateDigestEvents(previewResponse1.result.previewPayloadExample.steps?.['digest-step'].events, {
      foo: {
        bar: {
          first: 'example text',
          baz: {
            second: 'example text',
          },
        },
      },
      name: 'John Doe',
      items: [
        { foo: 'example text', bar: 'example text' },
        { foo: 'example text', bar: 'example text' },
        { foo: 'example text', bar: 'example text' },
      ],
      baz: 'example text',
      paragraph_link: 'https://example.com',
      heading_link: 'https://example.com',
      blockquote_link: 'https://example.com',
      bullet_link: 'https://example.com',
      button_link: 'https://example.com',
      image_variable: 'example text',
      image_link: 'https://example.com',
      inline_image_link: 'https://example.com',
      inline_image_url: 'https://example.com',
      numbered_link: 'https://example.com',
      third: 'example text',
    });

    // testing the steps.digest-step.eventCount variable
    const controlValues2 = {
      body: '{"type":"doc","content":[{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","text":"eventCount "},{"type":"variable","attrs":{"id":"steps.digest-step.eventCount","label":null,"fallback":null,"required":false,"aliasFor":null}},{"type":"text","text":" "}]}]}',
      subject: 'eventCount',
    };
    const previewResponse2 = await novuClient.workflows.steps.generatePreview({
      generatePreviewRequestDto: { controlValues: controlValues2, previewPayload: {} },
      stepId: emailStepDatabaseId,
      workflowId,
    });
    expect(previewResponse2.result.result.preview.body).to.contain(`eventCount ${DEFAULT_ARRAY_ELEMENTS}`);
    validateDigestEvents(previewResponse2.result.previewPayloadExample.steps?.['digest-step'].events, {
      foo: {
        bar: {
          first: 'example text',
          baz: {
            second: 'example text',
          },
        },
      },
      name: 'John Doe',
      items: [
        { foo: 'example text', bar: 'example text' },
        { foo: 'example text', bar: 'example text' },
        { foo: 'example text', bar: 'example text' },
      ],
      baz: 'example text',
      paragraph_link: 'https://example.com',
      heading_link: 'https://example.com',
      blockquote_link: 'https://example.com',
      bullet_link: 'https://example.com',
      button_link: 'https://example.com',
      image_variable: 'example text',
      image_link: 'https://example.com',
      inline_image_link: 'https://example.com',
      inline_image_url: 'https://example.com',
      numbered_link: 'https://example.com',
      third: 'example text',
    });

    // testing the steps.digest-step.events array and direct access to the first item
    const controlValues3 = {
      body: '{"type":"doc","content":[{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"variable","attrs":{"id":"steps.digest-step.events","label":null,"fallback":null,"required":false,"aliasFor":null}},{"type":"text","text":" "}]},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","text":"single variable: {{steps.digest-step.events[0].payload.foo.bar.first}}"}]}]}',
      subject: 'events',
    };
    const previewResponse3 = await novuClient.workflows.steps.generatePreview({
      generatePreviewRequestDto: { controlValues: controlValues3, previewPayload: {} },
      stepId: emailStepDatabaseId,
      workflowId,
    });
    // Check that the body contains the digest events array structure without asserting exact times
    expect(previewResponse3.result.result.preview.body).to.contain("'id':'example-id-1'");
    expect(previewResponse3.result.result.preview.body).to.contain("'foo':{");
    expect(previewResponse3.result.result.preview.body).to.contain("'time':");
    // Count the number of events in the rendered output
    const eventMatches = previewResponse3.result.result.preview.body.match(/'id':'example-id-\d+'/g);
    expect(eventMatches).to.have.length(DEFAULT_ARRAY_ELEMENTS);
    expect(previewResponse3.result.result.preview.body).to.contain('single variable: example text');
    validateDigestEvents(previewResponse3.result.previewPayloadExample.steps?.['digest-step'].events, {
      foo: {
        bar: {
          first: 'example text',
          baz: {
            second: 'example text',
          },
        },
      },
      name: 'John Doe',
      items: [
        { foo: 'example text', bar: 'example text' },
        { foo: 'example text', bar: 'example text' },
        { foo: 'example text', bar: 'example text' },
      ],
      baz: 'example text',
      paragraph_link: 'https://example.com',
      heading_link: 'https://example.com',
      blockquote_link: 'https://example.com',
      bullet_link: 'https://example.com',
      button_link: 'https://example.com',
      image_variable: 'example text',
      image_link: 'https://example.com',
      inline_image_link: 'https://example.com',
      inline_image_url: 'https://example.com',
      numbered_link: 'https://example.com',
      third: 'example text',
    });

    // testing the steps.digest-step.events[0].payload.foo variable
    const controlValues4 = {
      body: '{"type":"doc","content":[{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","text":"single variable: {{steps.digest-step.events[0].payload.foo}} "}]}]}',
      subject: 'events',
    };
    const previewResponse4 = await novuClient.workflows.steps.generatePreview({
      generatePreviewRequestDto: { controlValues: controlValues4, previewPayload: {} },
      stepId: emailStepDatabaseId,
      workflowId,
    });
    expect(previewResponse4.result.result.preview.body).to.contain(
      "single variable: {'bar':{'first':'example text','baz':{'second':'example text'}}}"
    );
    validateDigestEvents(previewResponse4.result.previewPayloadExample.steps?.['digest-step'].events, {
      foo: {
        bar: {
          first: 'example text',
          baz: {
            second: 'example text',
          },
        },
      },
      name: 'John Doe',
      items: [
        { foo: 'example text', bar: 'example text' },
        { foo: 'example text', bar: 'example text' },
        { foo: 'example text', bar: 'example text' },
      ],
      baz: 'example text',
      paragraph_link: 'https://example.com',
      heading_link: 'https://example.com',
      blockquote_link: 'https://example.com',
      bullet_link: 'https://example.com',
      button_link: 'https://example.com',
      image_variable: 'example text',
      image_link: 'https://example.com',
      inline_image_link: 'https://example.com',
      inline_image_url: 'https://example.com',
      numbered_link: 'https://example.com',
      third: 'example text',
    });

    // testing the countSummary and sentenceSummary variables
    const controlValues5 = {
      body: `{"type":"doc","content":[{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"variable","attrs":{"id":"steps.digest-step.eventCount | pluralize: 'notification', 'notifications'","label":null,"fallback":null,"required":false,"aliasFor":null}},{"type":"text","text":" "}]},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"variable","attrs":{"id":"steps.digest-step.events | toSentence: 'payload.name', 2, 'other'","label":null,"fallback":null,"required":false,"aliasFor":null}},{"type":"text","text":" "}]}]}`,
      subject: 'countSummary and sentenceSummary',
    };
    const previewResponse5 = await novuClient.workflows.steps.generatePreview({
      generatePreviewRequestDto: { controlValues: controlValues5, previewPayload: {} },
      stepId: emailStepDatabaseId,
      workflowId,
    });
    expect(previewResponse5.result.result.preview.body).to.contain(`${DEFAULT_ARRAY_ELEMENTS} notifications`);
    expect(previewResponse5.result.result.preview.body).to.contain(
      `John Doe, John Doe, and ${DEFAULT_ARRAY_ELEMENTS - 2} other`
    );
    validateDigestEvents(previewResponse5.result.previewPayloadExample.steps?.['digest-step'].events, {
      foo: {
        bar: {
          first: 'example text',
          baz: {
            second: 'example text',
          },
        },
      },
      name: 'John Doe',
      items: [
        { foo: 'example text', bar: 'example text' },
        { foo: 'example text', bar: 'example text' },
        { foo: 'example text', bar: 'example text' },
      ],
      baz: 'example text',
      paragraph_link: 'https://example.com',
      heading_link: 'https://example.com',
      blockquote_link: 'https://example.com',
      bullet_link: 'https://example.com',
      button_link: 'https://example.com',
      image_variable: 'example text',
      image_link: 'https://example.com',
      inline_image_link: 'https://example.com',
      inline_image_url: 'https://example.com',
      numbered_link: 'https://example.com',
      third: 'example text',
    });

    // testing the digest block with 3 variables combining current and full variable
    const controlValues6 = {
      body: `{"type":"doc","content":[{"type":"section","attrs":{"borderRadius":0,"backgroundColor":"#FFFFFF","align":"left","borderWidth":0,"borderColor":"#e2e2e2","paddingTop":0,"paddingRight":0,"paddingBottom":0,"paddingLeft":0,"marginTop":0,"marginRight":0,"marginBottom":0,"marginLeft":0,"showIfKey":null},"content":[{"type":"repeat","attrs":{"each":"steps.digest-step.events","isUpdatingKey":false,"showIfKey":null,"iterations":5},"content":[{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"variable","attrs":{"id":"steps.digest-step.events.payload.foo.bar.first","label":null,"fallback":null,"required":false,"aliasFor":null}},{"type":"text","text":" "}]},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"variable","attrs":{"id":"steps.digest-step.events.payload.foo.bar.baz.second","label":null,"fallback":null,"required":false,"aliasFor":null}},{"type":"text","text":" "}]},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"variable","attrs":{"id":"current.payload.third","label":null,"fallback":null,"required":false,"aliasFor":"steps.digest-step.events.payload.third"}},{"type":"text","text":" "}]}]},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"variable","attrs":{"id":"steps.digest-step.eventCount | minus: 5 | pluralize: 'more comment', ''","label":null,"fallback":null,"required":false,"aliasFor":null}}]}]}]}`,
      subject: 'digest block',
    };
    const previewResponse6 = await novuClient.workflows.steps.generatePreview({
      generatePreviewRequestDto: { controlValues: controlValues6, previewPayload: {} },
      stepId: emailStepDatabaseId,
      workflowId,
    });
    const countOccurrences = (str: string, searchStr: string) => (str.match(new RegExp(searchStr, 'g')) || []).length;
    expect(countOccurrences(previewResponse6.result.result.preview.body, 'first')).to.equal(DEFAULT_ARRAY_ELEMENTS);
    expect(countOccurrences(previewResponse6.result.result.preview.body, 'second')).to.equal(DEFAULT_ARRAY_ELEMENTS);
    expect(countOccurrences(previewResponse6.result.result.preview.body, 'third')).to.equal(DEFAULT_ARRAY_ELEMENTS);
    validateDigestEvents(previewResponse6.result.previewPayloadExample.steps?.['digest-step'].events, {
      foo: {
        bar: {
          first: 'example text',
          baz: {
            second: 'example text',
          },
        },
      },
      name: 'John Doe',
      items: [
        { foo: 'example text', bar: 'example text' },
        { foo: 'example text', bar: 'example text' },
        { foo: 'example text', bar: 'example text' },
      ],
      baz: 'example text',
      paragraph_link: 'https://example.com',
      heading_link: 'https://example.com',
      blockquote_link: 'https://example.com',
      bullet_link: 'https://example.com',
      button_link: 'https://example.com',
      image_variable: 'example text',
      image_link: 'https://example.com',
      inline_image_link: 'https://example.com',
      inline_image_url: 'https://example.com',
      numbered_link: 'https://example.com',
      third: 'example text',
    });
  });

  it('should allow using the static text and variables as a link on the email editor components', async () => {
    const { workflowId, emailStepDatabaseId } =
      await createWorkflowWithEmailLookingAtDigestResult(linkPayloadSchemaWithExamples);

    const controlValues = {
      body: '{"type":"doc","content":[{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","text":"Just the paragraph"}]},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"payload.paragraph_link","target":"_blank","rel":"noopener noreferrer nofollow","class":null,"isUrlVariable":true,"aliasFor":null}},{"type":"underline"}],"text":"Paragraph variable link"}]},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://paragraph.static.link","target":"_blank","rel":"noopener noreferrer nofollow","class":null,"isUrlVariable":false,"aliasFor":null}},{"type":"underline"}],"text":"Paragraph static link"}]},{"type":"heading","attrs":{"textAlign":null,"level":1,"showIfKey":null},"content":[{"type":"text","text":"Just the heading"}]},{"type":"heading","attrs":{"textAlign":null,"level":1,"showIfKey":null},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"payload.heading_link","target":"_blank","rel":"noopener noreferrer nofollow","class":null,"isUrlVariable":true,"aliasFor":null}},{"type":"underline"}],"text":"Heading text link"}]},{"type":"heading","attrs":{"textAlign":null,"level":1,"showIfKey":null},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://heading.static.link","target":"_blank","rel":"noopener noreferrer nofollow","class":null,"isUrlVariable":false,"aliasFor":null}},{"type":"underline"}],"text":"Heading static link"}]},{"type":"blockquote","content":[{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","text":"Just the blockquote"}]}]},{"type":"blockquote","content":[{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"payload.blockquote_link","target":"_blank","rel":"noopener noreferrer nofollow","class":null,"isUrlVariable":true,"aliasFor":null}},{"type":"underline"}],"text":"Blockquote text link"}]}]},{"type":"blockquote","content":[{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://blockquote.static.link","target":"_blank","rel":"noopener noreferrer nofollow","class":null,"isUrlVariable":false,"aliasFor":null}},{"type":"underline"}],"text":"Blockquote static link"}]}]},{"type":"bulletList","content":[{"type":"listItem","attrs":{"color":null},"content":[{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","text":"Just the bullet"}]}]},{"type":"listItem","attrs":{"color":null},"content":[{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"payload.bullet_link","target":"_blank","rel":"noopener noreferrer nofollow","class":null,"isUrlVariable":true,"aliasFor":null}},{"type":"underline"}],"text":"Bullet text link"}]}]},{"type":"listItem","attrs":{"color":null},"content":[{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://bullet.static.link","target":"_blank","rel":"noopener noreferrer nofollow","class":null,"isUrlVariable":false,"aliasFor":null}},{"type":"underline"}],"text":"Bullet static link"}]}]}]},{"type":"button","attrs":{"text":"Just the button","isTextVariable":false,"url":"","isUrlVariable":false,"alignment":"left","variant":"filled","borderRadius":"smooth","buttonColor":"#000000","textColor":"#ffffff","showIfKey":null,"paddingTop":10,"paddingRight":32,"paddingBottom":10,"paddingLeft":32,"width":"auto","aliasFor":null}},{"type":"button","attrs":{"text":"Button link","isTextVariable":false,"url":"payload.button_link","isUrlVariable":true,"alignment":"left","variant":"filled","borderRadius":"smooth","buttonColor":"#000000","textColor":"#ffffff","showIfKey":null,"paddingTop":10,"paddingRight":32,"paddingBottom":10,"paddingLeft":32,"width":"auto","aliasFor":null}},{"type":"button","attrs":{"text":"Button static link","isTextVariable":false,"url":"https://button.static.link","isUrlVariable":false,"alignment":"left","variant":"filled","borderRadius":"smooth","buttonColor":"#000000","textColor":"#ffffff","showIfKey":null,"paddingTop":10,"paddingRight":32,"paddingBottom":10,"paddingLeft":32,"width":"auto","aliasFor":null}},{"type":"image","attrs":{"src":"https://prod-novu-app-bucket.s3.us-east-1.amazonaws.com/assets/email-editor/header-hero-image.webp","alt":null,"title":null,"width":568,"height":153.79061371841155,"alignment":"center","externalLink":null,"isExternalLinkVariable":false,"borderRadius":0,"isSrcVariable":false,"aspectRatio":3.6933333333333334,"lockAspectRatio":true,"showIfKey":null,"aliasFor":null}},{"type":"image","attrs":{"src":"payload.image_variable","alt":null,"title":null,"width":"auto","height":"auto","alignment":"center","externalLink":null,"isExternalLinkVariable":false,"borderRadius":0,"isSrcVariable":true,"aspectRatio":null,"lockAspectRatio":true,"showIfKey":null,"aliasFor":null}},{"type":"image","attrs":{"src":"https://prod-novu-app-bucket.s3.us-east-1.amazonaws.com/assets/email-editor/header-hero-image.webp","alt":null,"title":null,"width":568,"height":153.79061371841155,"alignment":"center","externalLink":"payload.image_link","isExternalLinkVariable":true,"borderRadius":0,"isSrcVariable":false,"aspectRatio":3.6933333333333334,"lockAspectRatio":true,"showIfKey":null,"aliasFor":null}},{"type":"image","attrs":{"src":"https://prod-novu-app-bucket.s3.us-east-1.amazonaws.com/assets/email-editor/header-hero-image.webp","alt":null,"title":null,"width":568,"height":153.79061371841155,"alignment":"center","externalLink":"https://image.static.link","isExternalLinkVariable":false,"borderRadius":0,"isSrcVariable":false,"aspectRatio":3.6933333333333334,"lockAspectRatio":true,"showIfKey":null,"aliasFor":null}},{"type":"horizontalRule"},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"inlineImage","attrs":{"height":20,"width":20,"src":"https://maily.to/brand/logo.png","isSrcVariable":false,"alt":null,"title":null,"externalLink":null,"isExternalLinkVariable":false,"aliasFor":null}}]},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"inlineImage","attrs":{"height":20,"width":20,"src":"https://maily.to/brand/logo.png","isSrcVariable":false,"alt":null,"title":null,"externalLink":"payload.inline_image_link","isExternalLinkVariable":true,"aliasFor":null}}]},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"inlineImage","attrs":{"height":20,"width":20,"src":"https://maily.to/brand/logo.png","isSrcVariable":false,"alt":null,"title":null,"externalLink":"https://inline_image.static.link","isExternalLinkVariable":false,"aliasFor":null}}]},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"inlineImage","attrs":{"height":20,"width":20,"src":"payload.inline_image_url","isSrcVariable":true,"alt":null,"title":null,"externalLink":null,"isExternalLinkVariable":false,"aliasFor":null}}]},{"type":"orderedList","attrs":{"start":1},"content":[{"type":"listItem","attrs":{"color":null},"content":[{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","text":"Just the numbered list"}]}]},{"type":"listItem","attrs":{"color":null},"content":[{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"payload.numbered_link","target":"_blank","rel":"noopener noreferrer nofollow","class":null,"isUrlVariable":true,"aliasFor":null}},{"type":"underline"}],"text":"Numbered text link"}]}]},{"type":"listItem","attrs":{"color":null},"content":[{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://numbered.static.link","target":"_blank","rel":"noopener noreferrer nofollow","class":null,"isUrlVariable":false,"aliasFor":null}},{"type":"underline"}],"text":"Numbered static link"}]}]}]}]}',
      subject: 'all email editor components that support links',
    };
    const previewResponse = await novuClient.workflows.steps.generatePreview({
      generatePreviewRequestDto: { controlValues, previewPayload: {} },
      stepId: emailStepDatabaseId,
      workflowId,
    });

    // paragraph
    expect(previewResponse.result.result.preview.body).to.contain('Just the paragraph');
    expect(previewResponse.result.result.preview.body).to.contain('Paragraph variable link');
    expect(previewResponse.result.result.preview.body).to.contain('href="paragraph_link"');
    expect(previewResponse.result.result.preview.body).to.contain('Paragraph static link');
    expect(previewResponse.result.result.preview.body).to.contain('href="https://paragraph.static.link"');

    // heading
    expect(previewResponse.result.result.preview.body).to.contain('Just the heading');
    expect(previewResponse.result.result.preview.body).to.contain('Heading text link');
    expect(previewResponse.result.result.preview.body).to.contain('href="heading_link"');
    expect(previewResponse.result.result.preview.body).to.contain('Heading static link');
    expect(previewResponse.result.result.preview.body).to.contain('href="https://heading.static.link"');

    // blockquote
    expect(previewResponse.result.result.preview.body).to.contain('Just the blockquote');
    expect(previewResponse.result.result.preview.body).to.contain('Blockquote text link');
    expect(previewResponse.result.result.preview.body).to.contain('href="blockquote_link"');
    expect(previewResponse.result.result.preview.body).to.contain('Blockquote static link');
    expect(previewResponse.result.result.preview.body).to.contain('href="https://blockquote.static.link"');

    // bullet
    expect(previewResponse.result.result.preview.body).to.contain('Just the bullet');
    expect(previewResponse.result.result.preview.body).to.contain('Bullet text link');
    expect(previewResponse.result.result.preview.body).to.contain('href="bullet_link"');
    expect(previewResponse.result.result.preview.body).to.contain('Bullet static link');
    expect(previewResponse.result.result.preview.body).to.contain('href="https://bullet.static.link"');

    // button
    expect(previewResponse.result.result.preview.body).to.contain('Just the button');
    expect(previewResponse.result.result.preview.body).to.contain('Button link');
    expect(previewResponse.result.result.preview.body).to.contain('href="button_link"');
    expect(previewResponse.result.result.preview.body).to.contain('Button static link');
    expect(previewResponse.result.result.preview.body).to.contain('href="https://button.static.link"');

    // image
    expect(previewResponse.result.result.preview.body).to.contain(
      '<img title="Image" alt="Image" src="https://prod-novu-app-bucket.s3.us-east-1.amazonaws.com/assets/email-editor/header-hero-image.webp"'
    );
    expect(previewResponse.result.result.preview.body).to.contain(
      '<img title="Image" alt="Image" src="image_variable"'
    );
    expect(previewResponse.result.result.preview.body).to.contain(
      '<a href="image_link" rel="noopener noreferrer" style="display:block;max-width:100%;text-decoration:none" target="_blank"><img title="Image" alt="Image" src="https://prod-novu-app-bucket.s3.us-east-1.amazonaws.com/assets/email-editor/header-hero-image.webp"'
    );
    expect(previewResponse.result.result.preview.body).to.contain(
      '<a href="https://image.static.link" rel="noopener noreferrer" style="display:block;max-width:100%;text-decoration:none" target="_blank"><img title="Image" alt="Image" src="https://prod-novu-app-bucket.s3.us-east-1.amazonaws.com/assets/email-editor/header-hero-image.webp"'
    );

    // inline image
    expect(previewResponse.result.result.preview.body).to.contain('<img src="https://maily.to/brand/logo.png"');
    expect(previewResponse.result.result.preview.body).to.contain(
      '<a href="inline_image_link" rel="noopener noreferrer" style="display:inline;text-decoration:none" target="_blank"><img src="https://maily.to/brand/logo.png"'
    );
    expect(previewResponse.result.result.preview.body).to.contain(
      '<a href="https://inline_image.static.link" rel="noopener noreferrer" style="display:inline;text-decoration:none" target="_blank"><img src="https://maily.to/brand/logo.png"'
    );
    expect(previewResponse.result.result.preview.body).to.contain('<img src="inline_image_url"');

    // numbered list
    expect(previewResponse.result.result.preview.body).to.contain('Just the numbered list');
    expect(previewResponse.result.result.preview.body).to.contain('Numbered text link');
    expect(previewResponse.result.result.preview.body).to.contain('numbered_link');
    expect(previewResponse.result.result.preview.body).to.contain('Numbered static link');
    expect(previewResponse.result.result.preview.body).to.contain('https://numbered.static.link');

    // Validate the structure without hardcoded timestamps
    const actualPayload = previewResponse.result.previewPayloadExample;
    expect(actualPayload.subscriber).to.deep.equal({
      firstName: 'John',
      lastName: 'Doe',
      email: 'user@example.com',
      phone: '+1234567890',
      avatar: 'https://example.com/avatar.png',
      locale: 'en_US',
      timezone: 'America/New_York',
      data: {},
    });
    expect(actualPayload.payload).to.deep.equal({
      foo: 'example text',
      name: 'John Doe',
      items: [
        {
          foo: 'example text',
          bar: 'example text',
        },
        {
          foo: 'example text',
          bar: 'example text',
        },
        {
          foo: 'example text',
          bar: 'example text',
        },
      ],
      baz: 'example text',
      paragraph_link: 'paragraph_link',
      heading_link: 'heading_link',
      blockquote_link: 'blockquote_link',
      bullet_link: 'bullet_link',
      button_link: 'button_link',
      image_variable: 'image_variable',
      image_link: 'image_link',
      inline_image_link: 'inline_image_link',
      inline_image_url: 'inline_image_url',
      numbered_link: 'numbered_link',
    });

    // Validate digest step structure without hardcoded timestamps
    expect(actualPayload.steps).to.exist;
    expect(actualPayload.steps).to.have.property('digest-step');
    expect(actualPayload.steps!['digest-step']).to.have.property('eventCount', 3);
    expect(actualPayload.steps!['digest-step']).to.have.property('events');
    expect(actualPayload.steps!['digest-step'].events).to.have.length(3);

    // Validate each event has the required structure without checking exact timestamps
    actualPayload.steps!['digest-step'].events.forEach((event, index) => {
      expect(event).to.have.property('id', `example-id-${index + 1}`);
      expect(event).to.have.property('time').that.is.a('string');
      expect(event)
        .to.have.property('payload')
        .that.deep.equals({
          foo: 'example text',
          name: 'John Doe',
          items: [
            {
              foo: 'example text',
              bar: 'example text',
            },
            {
              foo: 'example text',
              bar: 'example text',
            },
            {
              foo: 'example text',
              bar: 'example text',
            },
          ],
          baz: 'example text',
          paragraph_link: 'paragraph_link',
          heading_link: 'heading_link',
          blockquote_link: 'blockquote_link',
          bullet_link: 'bullet_link',
          button_link: 'button_link',
          image_variable: 'image_variable',
          image_link: 'image_link',
          inline_image_link: 'inline_image_link',
          inline_image_url: 'inline_image_url',
          numbered_link: 'numbered_link',
        });
      // Validate that time is a valid ISO string
      expect(new Date(event.time)).to.be.a('date');
    });

    const previewResponse2 = await novuClient.workflows.steps.generatePreview({
      generatePreviewRequestDto: {
        controlValues,
        previewPayload: {
          payload: {
            paragraph_link: 'https://paragraph_link.com',
            heading_link: 'https://heading_link.com',
            blockquote_link: 'https://blockquote_link.com',
            bullet_link: 'https://bullet_link.com',
            button_link: 'https://button_link.com',
            image_variable: 'https://image_variable.com',
            image_link: 'https://image_link.com',
            inline_image_link: 'https://inline_image_link.com',
            inline_image_url: 'https://inline_image_url.com',
            numbered_link: 'https://numbered_link.com',
          },
        },
      },
      stepId: emailStepDatabaseId,
      workflowId,
    });

    expect(previewResponse2.result.result.preview.body).to.contain('href="https://paragraph_link.com"');
    expect(previewResponse2.result.result.preview.body).to.contain('href="https://heading_link.com"');
    expect(previewResponse2.result.result.preview.body).to.contain('href="https://blockquote_link.com"');
    expect(previewResponse2.result.result.preview.body).to.contain('href="https://bullet_link.com"');
    expect(previewResponse2.result.result.preview.body).to.contain('href="https://button_link.com"');
    expect(previewResponse2.result.result.preview.body).to.contain('src="https://image_variable.com"');
    expect(previewResponse2.result.result.preview.body).to.contain('href="https://image_link.com"');
    expect(previewResponse2.result.result.preview.body).to.contain('href="https://inline_image_link.com"');
    expect(previewResponse2.result.result.preview.body).to.contain('src="https://inline_image_url.com"');
    expect(previewResponse2.result.result.preview.body).to.contain('href="https://numbered_link.com"');
  });

  it('should allow using the static text, variables, current alias, as a link on the email editor components inside the repeat block', async () => {
    const enhancedPayloadSchema = {
      type: 'object',
      properties: {
        foo: {
          type: 'string',
        },
        name: {
          type: 'string',
        },
        items: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              foo: {
                type: 'string',
              },
              bar: {
                type: 'string',
              },
              paragraph_link: {
                type: 'string',
              },
              heading_link: {
                type: 'string',
              },
              blockquote_link: {
                type: 'string',
              },
              bullet_link: {
                type: 'string',
              },
              button_link: {
                type: 'string',
              },
              image: {
                type: 'string',
              },
              image_link: {
                type: 'string',
              },
              inline_image: {
                type: 'string',
              },
              inline_image_link: {
                type: 'string',
              },
              numbered_link: {
                type: 'string',
              },
            },
          },
        },
        baz: {
          type: 'string',
        },
        paragraph_link: {
          type: 'string',
        },
        heading_link: {
          type: 'string',
        },
        blockquote_link: {
          type: 'string',
        },
        bullet_link: {
          type: 'string',
        },
        button_link: {
          type: 'string',
        },
        image_variable: {
          type: 'string',
        },
        image_link: {
          type: 'string',
        },
        inline_image_link: {
          type: 'string',
        },
        inline_image_url: {
          type: 'string',
        },
        numbered_link: {
          type: 'string',
        },
      },
    };

    const { workflowId, emailStepDatabaseId } =
      await createWorkflowWithEmailLookingAtDigestResult(enhancedPayloadSchema);

    const controlValues = {
      body: '{"type":"doc","content":[{"type":"repeat","attrs":{"each":"payload.items","isUpdatingKey":false,"showIfKey":null,"iterations":0},"content":[{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","text":"Just the paragraph"}]},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"payload.items.paragraph_link","target":"_blank","rel":"noopener noreferrer nofollow","class":null,"isUrlVariable":true,"aliasFor":null}},{"type":"underline"}],"text":"Paragraph variable link"}]},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"current.paragraph_link","target":"_blank","rel":"noopener noreferrer nofollow","class":null,"isUrlVariable":true,"aliasFor":"payload.items.paragraph_link"}},{"type":"underline"}],"text":"Paragraph current variable link"}]},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://paragraph.static.link","target":"_blank","rel":"noopener noreferrer nofollow","class":null,"isUrlVariable":false,"aliasFor":null}},{"type":"underline"}],"text":"Paragraph static link"}]},{"type":"heading","attrs":{"textAlign":null,"level":1,"showIfKey":null},"content":[{"type":"text","text":"Just the heading"}]},{"type":"heading","attrs":{"textAlign":null,"level":1,"showIfKey":null},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"payload.items.heading_link","target":"_blank","rel":"noopener noreferrer nofollow","class":null,"isUrlVariable":true,"aliasFor":null}},{"type":"underline"}],"text":"Heading variable link"}]},{"type":"heading","attrs":{"textAlign":null,"level":1,"showIfKey":null},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"current.heading_link","target":"_blank","rel":"noopener noreferrer nofollow","class":null,"isUrlVariable":true,"aliasFor":"payload.items.heading_link"}},{"type":"underline"}],"text":"Heading current variable link"}]},{"type":"heading","attrs":{"textAlign":null,"level":1,"showIfKey":null},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://heading.static.link","target":"_blank","rel":"noopener noreferrer nofollow","class":null,"isUrlVariable":false,"aliasFor":null}},{"type":"underline"}],"text":"Heading static link"}]},{"type":"blockquote","content":[{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","text":"Just the blockquote"}]}]},{"type":"blockquote","content":[{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"payload.items.blockquote_link","target":"_blank","rel":"noopener noreferrer nofollow","class":null,"isUrlVariable":true,"aliasFor":null}},{"type":"underline"}],"text":"Blockquote variable link"}]}]},{"type":"blockquote","content":[{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"current.blockquote_link","target":"_blank","rel":"noopener noreferrer nofollow","class":null,"isUrlVariable":true,"aliasFor":"payload.items.blockquote_link"}},{"type":"underline"}],"text":"Blockquote current variable link"}]}]},{"type":"blockquote","content":[{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://blockquote.static.link","target":"_blank","rel":"noopener noreferrer nofollow","class":null,"isUrlVariable":false,"aliasFor":null}},{"type":"underline"}],"text":"Blockquote static link"}]}]},{"type":"bulletList","content":[{"type":"listItem","attrs":{"color":""},"content":[{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","text":"Just the bullet"}]}]},{"type":"listItem","attrs":{"color":""},"content":[{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"payload.items.bullet_link","target":"_blank","rel":"noopener noreferrer nofollow","class":null,"isUrlVariable":true,"aliasFor":null}},{"type":"underline"}],"text":"Bullet variable link"}]}]},{"type":"listItem","attrs":{"color":""},"content":[{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"current.bullet_link","target":"_blank","rel":"noopener noreferrer nofollow","class":null,"isUrlVariable":true,"aliasFor":"payload.items.bullet_link"}},{"type":"underline"}],"text":"Bullet current variable link"}]}]},{"type":"listItem","attrs":{"color":""},"content":[{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://bullet.static.link","target":"_blank","rel":"noopener noreferrer nofollow","class":null,"isUrlVariable":false,"aliasFor":null}},{"type":"underline"}],"text":"Bullet static link"}]}]}]},{"type":"button","attrs":{"text":"Just the button","isTextVariable":false,"url":"","isUrlVariable":false,"alignment":"left","variant":"filled","borderRadius":"smooth","buttonColor":"#000000","textColor":"#ffffff","showIfKey":null,"paddingTop":10,"paddingRight":32,"paddingBottom":10,"paddingLeft":32,"width":"auto","aliasFor":null}},{"type":"button","attrs":{"text":"Button variable link","isTextVariable":false,"url":"payload.items.button_link","isUrlVariable":true,"alignment":"left","variant":"filled","borderRadius":"smooth","buttonColor":"#000000","textColor":"#ffffff","showIfKey":null,"paddingTop":10,"paddingRight":32,"paddingBottom":10,"paddingLeft":32,"width":"auto","aliasFor":null}},{"type":"button","attrs":{"text":"Button current variable link","isTextVariable":false,"url":"current.button_link","isUrlVariable":true,"alignment":"left","variant":"filled","borderRadius":"smooth","buttonColor":"#000000","textColor":"#ffffff","showIfKey":null,"paddingTop":10,"paddingRight":32,"paddingBottom":10,"paddingLeft":32,"width":"auto","aliasFor":"payload.items.button_link"}},{"type":"button","attrs":{"text":"Button static link","isTextVariable":false,"url":"https://button.static.link","isUrlVariable":false,"alignment":"left","variant":"filled","borderRadius":"smooth","buttonColor":"#000000","textColor":"#ffffff","showIfKey":null,"paddingTop":10,"paddingRight":32,"paddingBottom":10,"paddingLeft":32,"width":"auto","aliasFor":null}},{"type":"horizontalRule"},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","text":"Just the image"}]},{"type":"image","attrs":{"src":"https://prod-novu-app-bucket.s3.us-east-1.amazonaws.com/assets/email-editor/header-hero-image.webp","alt":null,"title":null,"width":566,"height":153.24909747292418,"alignment":"center","externalLink":null,"isExternalLinkVariable":false,"borderRadius":0,"isSrcVariable":false,"aspectRatio":3.6933333333333334,"lockAspectRatio":true,"showIfKey":null,"aliasFor":null}},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","text":"Image variable"}]},{"type":"image","attrs":{"src":"payload.items.image","alt":null,"title":null,"width":"auto","height":"auto","alignment":"center","externalLink":null,"isExternalLinkVariable":false,"borderRadius":0,"isSrcVariable":true,"aspectRatio":null,"lockAspectRatio":true,"showIfKey":null,"aliasFor":null}},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","text":"Image current variable"}]},{"type":"image","attrs":{"src":"current.image","alt":null,"title":null,"width":"auto","height":"auto","alignment":"center","externalLink":null,"isExternalLinkVariable":false,"borderRadius":0,"isSrcVariable":true,"aspectRatio":null,"lockAspectRatio":true,"showIfKey":null,"aliasFor":"payload.items.image"}},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","text":"Image link variable"}]},{"type":"image","attrs":{"src":"https://prod-novu-app-bucket.s3.us-east-1.amazonaws.com/assets/email-editor/header-hero-image.webp","alt":null,"title":null,"width":566,"height":153.24909747292418,"alignment":"center","externalLink":"payload.items.image_link","isExternalLinkVariable":true,"borderRadius":0,"isSrcVariable":false,"aspectRatio":3.6933333333333334,"lockAspectRatio":true,"showIfKey":null,"aliasFor":null}},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","text":"Image current link variable"}]},{"type":"image","attrs":{"src":"https://prod-novu-app-bucket.s3.us-east-1.amazonaws.com/assets/email-editor/header-hero-image.webp","alt":null,"title":null,"width":566,"height":153.24909747292418,"alignment":"center","externalLink":"current.image_link","isExternalLinkVariable":true,"borderRadius":0,"isSrcVariable":false,"aspectRatio":3.6933333333333334,"lockAspectRatio":true,"showIfKey":null,"aliasFor":"payload.items.image_link"}},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","text":"Image static link"}]},{"type":"image","attrs":{"src":"https://prod-novu-app-bucket.s3.us-east-1.amazonaws.com/assets/email-editor/header-hero-image.webp","alt":null,"title":null,"width":566,"height":153.24909747292418,"alignment":"center","externalLink":"https://image.static.link","isExternalLinkVariable":false,"borderRadius":0,"isSrcVariable":false,"aspectRatio":3.6933333333333334,"lockAspectRatio":true,"showIfKey":null,"aliasFor":null}},{"type":"horizontalRule"},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","text":"Inline image"}]},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"inlineImage","attrs":{"height":20,"width":20,"src":"https://maily.to/brand/logo.png","isSrcVariable":false,"alt":null,"title":null,"externalLink":null,"isExternalLinkVariable":false,"aliasFor":null}}]},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","text":"Inline image variable"}]},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"inlineImage","attrs":{"height":20,"width":20,"src":"payload.items.inline_image","isSrcVariable":true,"alt":null,"title":null,"externalLink":null,"isExternalLinkVariable":false,"aliasFor":null}}]},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","text":"Inline image current variable"}]},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"inlineImage","attrs":{"height":20,"width":20,"src":"current.inline_image","isSrcVariable":true,"alt":null,"title":null,"externalLink":null,"isExternalLinkVariable":false,"aliasFor":"payload.items.inline_image"}}]},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","text":"Inline image link variable"}]},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"inlineImage","attrs":{"height":20,"width":20,"src":"https://maily.to/brand/logo.png","isSrcVariable":false,"alt":null,"title":null,"externalLink":"payload.items.inline_image_link","isExternalLinkVariable":true,"aliasFor":null}}]},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","text":"Inline image current link variable"}]},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"inlineImage","attrs":{"height":20,"width":20,"src":"https://maily.to/brand/logo.png","isSrcVariable":false,"alt":null,"title":null,"externalLink":"current.inline_image_link","isExternalLinkVariable":true,"aliasFor":"payload.items.inline_image_link"}}]},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","text":"Inline image static link"}]},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"inlineImage","attrs":{"height":20,"width":20,"src":"https://maily.to/brand/logo.png","isSrcVariable":false,"alt":null,"title":null,"externalLink":"https://inline_image.static.link","isExternalLinkVariable":false,"aliasFor":null}}]},{"type":"horizontalRule"},{"type":"orderedList","attrs":{"start":1},"content":[{"type":"listItem","attrs":{"color":null},"content":[{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","text":"Just the numbered list"}]}]},{"type":"listItem","attrs":{"color":null},"content":[{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"payload.items.numbered_link","target":"_blank","rel":"noopener noreferrer nofollow","class":null,"isUrlVariable":true,"aliasFor":null}},{"type":"underline"}],"text":"Numbered variable link"}]}]},{"type":"listItem","attrs":{"color":null},"content":[{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"current.numbered_link","target":"_blank","rel":"noopener noreferrer nofollow","class":null,"isUrlVariable":true,"aliasFor":"payload.items.numbered_link"}},{"type":"underline"}],"text":"Numbered current variable link"}]}]},{"type":"listItem","attrs":{"color":null},"content":[{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","marks":[{"type":"link","attrs":{"href":"https://numbered.static.link","target":"_blank","rel":"noopener noreferrer nofollow","class":null,"isUrlVariable":false,"aliasFor":null}},{"type":"underline"}],"text":"Numbered static link"}]}]}]},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null}}]},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null}}]}',
      subject: 'all email editor components that support links inside the repeat block',
    };
    const previewResponse = await novuClient.workflows.steps.generatePreview({
      generatePreviewRequestDto: {
        controlValues,
        previewPayload: { payload: { items: Array(6).fill({ paragraph_link: 'paragraph_link' }) } },
      },
      stepId: emailStepDatabaseId,
      workflowId,
    });

    const countOccurrences = (str: string, searchStr: string) => (str.match(new RegExp(searchStr, 'g')) || []).length;

    expect(previewResponse.result.result.preview.body).to.contain('Paragraph variable link');
    expect(previewResponse.result.result.preview.body).to.contain('Paragraph current variable link');
    expect(countOccurrences(previewResponse.result.result.preview.body, 'href="paragraph_link"')).to.equal(
      DEFAULT_ARRAY_ELEMENTS * 4
    );
    expect(previewResponse.result.result.preview.body).to.contain('Paragraph static link');
    expect(previewResponse.result.result.preview.body).to.contain('href="https://paragraph.static.link"');

    console.log('Blockquote');
    // blockquote
    expect(previewResponse.result.result.preview.body).to.contain('Just the blockquote');
    expect(previewResponse.result.result.preview.body).to.contain('Blockquote variable link');
    expect(previewResponse.result.result.preview.body).to.contain('Blockquote current variable link');
    expect(previewResponse.result.result.preview.body).to.contain('Blockquote static link');
    expect(previewResponse.result.result.preview.body).to.contain('href="https://blockquote.static.link"');

    // bullet
    expect(previewResponse.result.result.preview.body).to.contain('Just the bullet');
    expect(previewResponse.result.result.preview.body).to.contain('Bullet variable link');
    expect(previewResponse.result.result.preview.body).to.contain('Bullet current variable link');

    expect(previewResponse.result.result.preview.body).to.contain('Bullet static link');
    expect(previewResponse.result.result.preview.body).to.contain('href="https://bullet.static.link"');

    // button
    expect(previewResponse.result.result.preview.body).to.contain('Just the button');
    expect(previewResponse.result.result.preview.body).to.contain('Button variable link');
    expect(previewResponse.result.result.preview.body).to.contain('Button current variable link');

    expect(previewResponse.result.result.preview.body).to.contain('Button static link');
    expect(previewResponse.result.result.preview.body).to.contain('href="https://button.static.link"');

    // image
    expect(previewResponse.result.result.preview.body).to.contain(
      '<img title="Image" alt="Image" src="https://prod-novu-app-bucket.s3.us-east-1.amazonaws.com/assets/email-editor/header-hero-image.webp"'
    );

    expect(previewResponse.result.result.preview.body).to.contain(
      '<a href="https://image.static.link" rel="noopener noreferrer" style="display:block;max-width:100%;text-decoration:none" target="_blank"><img title="Image" alt="Image" src="https://prod-novu-app-bucket.s3.us-east-1.amazonaws.com/assets/email-editor/header-hero-image.webp"'
    );

    // inline image
    expect(previewResponse.result.result.preview.body).to.contain('<img src="https://maily.to/brand/logo.png"');

    expect(previewResponse.result.result.preview.body).to.contain(
      '<a href="https://inline_image.static.link" rel="noopener noreferrer" style="display:inline;text-decoration:none" target="_blank"><img src="https://maily.to/brand/logo.png"'
    );

    // numbered list
    expect(previewResponse.result.result.preview.body).to.contain('Just the numbered list');
    expect(previewResponse.result.result.preview.body).to.contain('Numbered variable link');
    expect(previewResponse.result.result.preview.body).to.contain('Numbered current variable link');

    expect(previewResponse.result.result.preview.body).to.contain('Numbered static link');
    expect(previewResponse.result.result.preview.body).to.contain('href="https://numbered.static.link"');
  });

  describe('Hydration testing', () => {
    it.skip(` should hydrate previous step in iterator email --> digest`, async () => {
      const { workflowId, emailStepDatabaseId, digestStepId } = await createWorkflowWithEmailLookingAtDigestResult();
      const requestDto = {
        controlValues: getTestControlValues(digestStepId)[StepTypeEnum.Email],
        previewPayload: { payload: { subject: PLACEHOLDER_SUBJECT_INAPP_PAYLOAD_VALUE } },
      };
      const previewResponseDto = await generatePreview(novuClient, workflowId, emailStepDatabaseId, requestDto);
      expect(previewResponseDto.result!.preview).to.exist;
      expect(previewResponseDto.previewPayloadExample).to.exist;
      expect(previewResponseDto.previewPayloadExample?.steps?.[digestStepId]).to.be.ok;
      if (previewResponseDto.result!.type !== ChannelTypeEnum.Email) {
        throw new Error('Expected email');
      }
      const preview = previewResponseDto.result!.preview.body;
      expect(previewResponseDto.result!.preview.body).to.contain('{{item.payload.country}}');
    });

    it(` should hydrate previous step in iterator sms looking at inApp`, async () => {
      const { workflowId, smsDatabaseStepId, inAppStepId } = await createWorkflowWithSmsLookingAtInAppResult();
      const requestDto = buildDtoNoPayload(StepTypeEnum.Sms, inAppStepId);
      const previewResponseDto = await generatePreview(novuClient, workflowId, smsDatabaseStepId, requestDto);
      expect(previewResponseDto.result!.preview).to.exist;
      expect(previewResponseDto.previewPayloadExample).to.exist;
      expect(previewResponseDto.previewPayloadExample?.steps).to.be.ok;
      if (previewResponseDto.result?.type === 'sms' && previewResponseDto.result?.preview.body) {
        expect(previewResponseDto.result!.preview.body).to.contain(`[[true]]`);
      }
    });
  });

  it(`IN_APP :should match the body in the preview response`, async () => {
    const { stepDatabaseId, workflowId, stepId } = await createWorkflowAndReturnId(novuClient, StepTypeEnum.InApp);
    const controlValues = buildInAppControlValues();
    const requestDto = {
      controlValues,
      previewPayload: { payload: { subject: PLACEHOLDER_SUBJECT_INAPP_PAYLOAD_VALUE } },
    };
    const previewResponseDto = await generatePreview(novuClient, workflowId, stepDatabaseId, requestDto);
    expect(previewResponseDto.result!.preview).to.exist;
    controlValues.subject = controlValues.subject!.replace(
      PLACEHOLDER_SUBJECT_INAPP,
      PLACEHOLDER_SUBJECT_INAPP_PAYLOAD_VALUE
    );
    if (previewResponseDto.result?.type !== 'in_app') {
      throw new Error('should have a in-app preview ');
    }
    expect(previewResponseDto.result.preview.subject).to.deep.equal(
      'John Hello, World! this is the replacement text for the placeholder'
    );
  });

  describe('Happy Path, no payload, expected same response as requested', () => {
    // TODO: this test is not working as expected
    it('in_app: should match the body in the preview response', async () => {
      const previewResponseDto = await createWorkflowAndPreview(StepTypeEnum.InApp, 'InApp');

      expect(previewResponseDto.result).to.exist;
      if (!previewResponseDto.result) {
        throw new Error('missing preview');
      }
      if (previewResponseDto.result!.type !== 'in_app') {
        throw new Error('should be in app preview type');
      }
      const inApp = getTestControlValues().in_app;
      const previewRequestWithoutTheRedirect = {
        ...inApp,
        subject: "John Hello, World! {'test':{'payload':'example text'}}",
        body: 'Hello, World! This is an example message.',
        primaryAction: { label: 'https://example.com' },
      };
      expect(previewResponseDto.result!.preview).to.deep.equal(previewRequestWithoutTheRedirect);
    });

    it('sms: should match the body in the preview response', async () => {
      const previewResponseDto = await createWorkflowAndPreview(StepTypeEnum.Sms, 'SMS');

      expect(previewResponseDto.result!.preview).to.exist;
      expect(previewResponseDto.previewPayloadExample).to.exist;
      expect(previewResponseDto.previewPayloadExample.subscriber, 'Expecting to find subscriber in the payload').to
        .exist;

      expect(previewResponseDto.result!.preview).to.deep.equal({ body: ' Hello, World! John' });
    });

    it('push: should match the body in the preview response', async () => {
      const previewResponseDto = await createWorkflowAndPreview(StepTypeEnum.Push, 'Push');

      expect(previewResponseDto.result!.preview).to.exist;
      expect(previewResponseDto.previewPayloadExample).to.exist;
      expect(previewResponseDto.previewPayloadExample.subscriber, 'Expecting to find subscriber in the payload').to
        .exist;

      expect(previewResponseDto.result!.preview).to.deep.equal({
        subject: 'Hello, World!',
        body: 'Hello, World! John',
      });
    });

    it('chat: should match the body in the preview response', async () => {
      const previewResponseDto = await createWorkflowAndPreview(StepTypeEnum.Chat, 'Chat');

      expect(previewResponseDto.result!.preview).to.exist;
      expect(previewResponseDto.previewPayloadExample).to.exist;
      expect(previewResponseDto.previewPayloadExample.subscriber, 'Expecting to find subscriber in the payload').to
        .exist;

      expect(previewResponseDto.result!.preview).to.deep.equal({ body: 'Hello, World! John' });
    });

    it('email: should match the body in the preview response', async () => {
      const previewResponseDto = await createWorkflowAndPreview(StepTypeEnum.Email, 'Email');
      const preview = previewResponseDto.result.preview as EmailRenderOutput;

      expect(previewResponseDto.result.type).to.equal(StepTypeEnum.Email);

      expect(preview).to.exist;
      expect(preview.body).to.exist;
      expect(preview.subject).to.exist;
      expect(preview.body).to.contain(previewPayloadExample().payload.body);
      expect(preview.subject).to.contain(`Hello, World! example text`);
      expect(previewResponseDto.previewPayloadExample).to.exist;
      expect(previewResponseDto.previewPayloadExample).to.have.property('payload');
      expect(previewResponseDto.previewPayloadExample).to.have.property('subscriber');
      expect(previewResponseDto.previewPayloadExample.payload).to.have.property('subject');
      expect(previewResponseDto.previewPayloadExample.payload.subject.test).to.have.property('payload');
    });

    async function createWorkflowAndPreview(type: StepTypeEnum, description: string) {
      const { stepDatabaseId, workflowId } = await createWorkflowAndReturnId(novuClient, type);
      const requestDto = buildDtoNoPayload(type);

      return await generatePreview(novuClient, workflowId, stepDatabaseId, requestDto);
    }
  });

  describe('payload sanitation', () => {
    it('Should produce a correct payload when pipe is used etc {{payload.variable | upper}}', async () => {
      const { stepDatabaseId, workflowId } = await createWorkflowAndReturnId(novuClient, StepTypeEnum.Sms);
      const requestDto = {
        controlValues: {
          body: 'This is a legal placeholder with a pipe [{{payload.variableName | upcase}}the pipe should show in the preview]',
        },
      };
      const previewResponseDto = await generatePreview(novuClient, workflowId, stepDatabaseId, requestDto);
      expect(previewResponseDto.result!.preview).to.exist;
      if (previewResponseDto.result!.type !== 'sms') {
        throw new Error('Expected sms');
      }
      expect(previewResponseDto.result!.preview.body).to.contain('JOHN DOE');
      expect(previewResponseDto.previewPayloadExample).to.exist;
    });

    it('Should not fail if inApp is providing partial URL in redirect', async () => {
      const steps = [{ name: 'IN_APP_STEP_SHOULD_NOT_FAIL', type: StepTypeEnum.InApp }];
      const createDto = buildWorkflow({
        steps,
        payloadSchema: {
          type: 'object',
          properties: {
            placeholder: {
              type: 'object',
              properties: {
                body: { type: 'string' },
              },
            },
            secondaryUrl: { type: 'string' },
            subject: { type: 'string' },
          },
          required: [],
          additionalProperties: false,
        },
      });
      const novuRestResult = await novuClient.workflows.create(createDto);
      const controlValues = {
        subject: `{{subscriber.firstName}} Hello, World! ${PLACEHOLDER_SUBJECT_INAPP}`,
        body: `Hello, World! {{payload.placeholder.body}}`,
        avatar: 'https://www.example.com/avatar.png',
        primaryAction: {
          label: '{{payload.secondaryUrl}}',
          redirect: {
            target: RedirectTargetEnum.BLANK,
          },
        },
        secondaryAction: null,
        redirect: {
          target: RedirectTargetEnum.BLANK,
          url: '   ',
        },
      };
      const workflowSlug = novuRestResult.result?.slug;
      const stepSlug = novuRestResult.result?.steps[0].slug;
      const stepDataDto = await updateWorkflow(workflowSlug, {
        ...mapResponseToUpdateDto(novuRestResult.result),
        steps: [
          {
            type: novuRestResult.result.steps[0].type,
            name: novuRestResult.result.steps[0].name,
            id: novuRestResult.result.steps[0].id,
            ...buildInAppControlValueWithAPlaceholderInTheUrl(),
          },
        ],
      });
      const generatePreviewResponseDto = await generatePreview(novuClient, workflowSlug, stepSlug, {
        controlValues,
      });
      if (generatePreviewResponseDto.result?.type === ChannelTypeEnum.InApp) {
        expect(generatePreviewResponseDto.result.preview.body).to.equal(
          {
            subject: `{{subscriber.firstName}} Hello, World! ${PLACEHOLDER_SUBJECT_INAPP}`,
            body: `Hello, World! This is an example message.`,
            avatar: 'https://www.example.com/avatar.png',
            primaryAction: {
              label: '{{payload.secondaryUrl}}',
              redirect: {
                target: RedirectTargetEnum.BLANK,
              },
            },
            secondaryAction: null,
            redirect: {
              target: RedirectTargetEnum.BLANK,
              url: '   ',
            },
          }.body
        );
      }
    });

    it('should merge the user provided payload with the BE generated payload', async () => {
      const { workflowId, emailStepDatabaseId } = await createWorkflowWithEmailLookingAtDigestResult();

      // Helper function to validate digest event structure (reused from above)
      const validateDigestEventsInMergeTest = (events: any[], expectedPayload: any) => {
        expect(events).to.have.length(DEFAULT_ARRAY_ELEMENTS);
        events.forEach((event, index) => {
          expect(event).to.have.property('id').that.is.a('string');
          expect(event).to.have.property('time').that.is.a('string');
          expect(event).to.have.property('payload').that.deep.equals(expectedPayload);
          // Validate that IDs are unique and follow the pattern
          expect(event.id).to.equal(`example-id-${index + 1}`);
          // Validate that times are ISO strings and incrementing
          expect(new Date(event.time)).to.be.a('date');
        });
      };

      // testing the default preview payload is generated when no user payload is provided
      const controlValues1 = {
        body: '{"type":"doc","content":[{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","text":"events length "},{"type":"variable","attrs":{"id":"steps.digest-step.events.length","label":null,"fallback":null,"required":false,"aliasFor":null}},{"type":"text","text":" "}]},{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","text":" "}]}]}',
        subject: 'events length',
      };
      const previewResponse1 = await novuClient.workflows.steps.generatePreview({
        generatePreviewRequestDto: { controlValues: controlValues1, previewPayload: {} },
        stepId: emailStepDatabaseId,
        workflowId,
      });

      validateDigestEventsInMergeTest(previewResponse1.result.previewPayloadExample.steps?.['digest-step'].events, {
        third: 'example text',
        name: 'John Doe',
        items: [
          { foo: 'example text', bar: 'example text' },
          { foo: 'example text', bar: 'example text' },
          { foo: 'example text', bar: 'example text' },
        ],
        foo: {
          bar: {
            first: 'example text',
            baz: {
              second: 'example text',
            },
          },
        },
        baz: 'example text',
        paragraph_link: 'https://example.com',
        heading_link: 'https://example.com',
        blockquote_link: 'https://example.com',
        bullet_link: 'https://example.com',
        button_link: 'https://example.com',
        image_variable: 'example text',
        image_link: 'https://example.com',
        inline_image_link: 'https://example.com',
        inline_image_url: 'https://example.com',
        numbered_link: 'https://example.com',
      });
    });
  });

  describe('Missing Required ControlValues', () => {
    const channelTypes = [{ type: StepTypeEnum.InApp, description: 'InApp' }];

    channelTypes.forEach(({ type }) => {
      // TODO: We need to get back to the drawing board on this one to make the preview action of the framework more forgiving
      it(`[${type}] will generate gracefully the preview if the control values are missing`, async () => {
        const { stepDatabaseId, workflowId, stepId } = await createWorkflowAndReturnId(novuClient, type);
        const requestDto = buildDtoWithMissingControlValues(type, stepId);

        const previewResponseDto = await generatePreview(novuClient, workflowId, stepDatabaseId, requestDto);

        expect(previewResponseDto.result).to.not.eql({ preview: {} });
      });
    });
  });

  async function updateWorkflow(id: string, workflow: UpdateWorkflowDto): Promise<WorkflowResponseDto> {
    const res = await novuClient.workflows.update(workflow, id);

    return res.result;
  }

  function mapResponseToUpdateDto(workflowResponse: WorkflowResponseDto): UpdateWorkflowDto {
    return {
      ...workflowResponse,
      steps: workflowResponse.steps.map(
        (step) =>
          ({
            id: step.id,
            type: step.type,
            name: step.name,
            controlValues: step.controls?.values || {},
          }) as UpdateWorkflowDtoSteps
      ),
    };
  }

  const defaultPayloadSchema = {
    type: 'object',
    properties: {
      foo: {
        type: 'object',
        properties: {
          bar: {
            type: 'object',
            properties: {
              first: {
                type: 'string',
              },
              baz: {
                type: 'object',
                properties: {
                  second: {
                    type: 'string',
                  },
                },
              },
            },
          },
        },
      },
      name: {
        type: 'string',
      },
      items: {
        type: 'array',
        items: {
          type: 'object',
          properties: {
            foo: {
              type: 'string',
            },
            bar: {
              type: 'string',
            },
          },
        },
      },
      baz: {
        type: 'string',
      },
      paragraph_link: {
        type: 'string',
      },
      heading_link: {
        type: 'string',
      },
      blockquote_link: {
        type: 'string',
      },
      bullet_link: {
        type: 'string',
      },
      button_link: {
        type: 'string',
      },
      image_variable: {
        type: 'string',
      },
      image_link: {
        type: 'string',
      },
      inline_image_link: {
        type: 'string',
      },
      inline_image_url: {
        type: 'string',
      },
      numbered_link: {
        type: 'string',
      },
      third: {
        type: 'string',
      },
    },
  };

  const linkPayloadSchemaWithExamples = {
    type: 'object',
    properties: {
      foo: {
        type: 'string',
      },
      name: {
        type: 'string',
      },
      items: {
        type: 'array',
        items: {
          type: 'object',
          properties: {
            foo: {
              type: 'string',
            },
            bar: {
              type: 'string',
            },
          },
        },
      },
      baz: {
        type: 'string',
      },
      paragraph_link: {
        type: 'string',
        example: 'paragraph_link',
      },
      heading_link: {
        type: 'string',
        example: 'heading_link',
      },
      blockquote_link: {
        type: 'string',
        example: 'blockquote_link',
      },
      bullet_link: {
        type: 'string',
        example: 'bullet_link',
      },
      button_link: {
        type: 'string',
        example: 'button_link',
      },
      image_variable: {
        type: 'string',
        example: 'image_variable',
      },
      image_link: {
        type: 'string',
        example: 'image_link',
      },
      inline_image_link: {
        type: 'string',
        example: 'inline_image_link',
      },
      inline_image_url: {
        type: 'string',
        example: 'inline_image_url',
      },
      numbered_link: {
        type: 'string',
        example: 'numbered_link',
      },
    },
  };

  async function createWorkflowWithEmailLookingAtDigestResult(payloadSchema = defaultPayloadSchema) {
    const createWorkflowDto: CreateWorkflowDto = {
      tags: [],
      source: WorkflowCreationSourceEnum.Editor,
      name: 'John',
      workflowId: `john-${randomUUID()}`,
      description: 'This is a test workflow',
      active: true,
      payloadSchema,
      steps: [
        {
          name: 'DigestStep',
          type: StepTypeEnum.Digest,
          controlValues: {
            amount: 1,
            unit: 'hours',
          },
        },
        {
          name: 'Email Test Step',
          type: StepTypeEnum.Email,
          controlValues: {
            subject: 'Test Email Subject',
            body: 'Test Email Body',
            disableOutputSanitization: false,
          },
        },
      ],
    };
    const workflowResult = await novuClient.workflows.create(createWorkflowDto);

    return {
      workflowId: workflowResult.result.id,
      emailStepDatabaseId: workflowResult.result.steps[1].id,
      digestStepId: workflowResult.result.steps[0].stepId,
    };
  }

  async function createWorkflowWithSmsLookingAtInAppResult() {
    const createWorkflowDto: CreateWorkflowDto = {
      tags: [],
      source: WorkflowCreationSourceEnum.Editor,
      name: 'John',
      workflowId: `john-${randomUUID()}`,
      description: 'This is a test workflow',
      active: true,
      steps: [
        {
          name: 'InAppStep',
          type: StepTypeEnum.InApp,
          controlValues: {
            subject: 'Test Subject',
            body: 'Test Body',
          },
        },
        {
          name: 'SmsStep',
          type: StepTypeEnum.Sms,
          controlValues: {
            body: 'Test SMS Body',
          },
        },
      ],
    };
    const workflowResult = await novuClient.workflows.create(createWorkflowDto);

    return {
      workflowId: workflowResult.result.id,
      smsDatabaseStepId: workflowResult.result.steps[1].id,
      inAppStepId: workflowResult.result.steps[0].stepId,
    };
  }

  async function createWorkflow(
    overrides: Partial<NotificationTemplateEntity> = {},
    payloadSchema?: any
  ): Promise<WorkflowResponseDto> {
    const createWorkflowDto: CreateWorkflowDto = {
      source: WorkflowCreationSourceEnum.Editor,
      name: TEST_WORKFLOW_NAME,
      workflowId: `${slugify(TEST_WORKFLOW_NAME)}`,
      description: 'This is a test workflow',
      active: true,
      payloadSchema,
      steps: [
        {
          name: 'In-App Test Step',
          type: StepTypeEnum.InApp,
          controlValues: {
            subject: 'Test Subject',
            body: 'Test Body',
          },
        },
        {
          name: 'Email Test Step',
          type: StepTypeEnum.Email,
          controlValues: {
            subject: 'Test Email Subject',
            body: 'Test Email Body',
          },
        },
      ],
    };

    const res = await novuClient.workflows.create(createWorkflowDto);

    await notificationTemplateRepository.updateOne(
      {
        _organizationId: session.organization._id,
        _environmentId: session.environment._id,
        _id: res.result.id,
      },
      {
        ...overrides,
      }
    );

    return res.result;
  }

  /**
   * Emulate external origin bridge with the local bridge
   */
  async function emulateExternalOrigin(_workflowId: string) {
    await notificationTemplateRepository.updateOne(
      {
        _organizationId: session.organization._id,
        _environmentId: session.environment._id,
        _id: _workflowId,
      },
      {
        origin: ResourceOriginEnum.External,
      }
    );

    await environmentRepository.updateOne(
      {
        _id: session.environment._id,
      },
      {
        bridge: { url: `http://localhost:${process.env.PORT}/v1/environments/${session.environment._id}/bridge` },
      }
    );
  }
});

function buildDtoNoPayload(stepTypeEnum: StepTypeEnum, stepId?: string): GeneratePreviewRequestDto {
  return {
    controlValues: getTestControlValues(stepId)[stepTypeEnum],
  };
}

function buildEmailControlValuesPayload(): EmailControlType {
  return {
    subject: `Hello, World! ${SUBJECT_TEST_PAYLOAD}`,
    body: JSON.stringify(fullCodeSnippet()),
    disableOutputSanitization: false,
  };
}

function buildInAppControlValues() {
  return {
    subject: `{{subscriber.firstName}} Hello, World! ${PLACEHOLDER_SUBJECT_INAPP}`,
    body: `Hello, World! {{payload.placeholder.body}}`,
    avatar: 'https://www.example.com/avatar.png',
    primaryAction: {
      label: '{{payload.primaryUrlLabel}}',
      redirect: {
        target: RedirectTargetEnum.BLANK,
      },
    },
    secondaryAction: {
      label: 'Secondary Action',
      redirect: {
        target: RedirectTargetEnum.BLANK,
        url: '/home/secondary-action',
      },
    },
    data: {
      key: 'value',
    },
    redirect: {
      target: RedirectTargetEnum.BLANK,
      url: 'https://www.example.com/redirect',
    },
  };
}

function buildInAppControlValueWithAPlaceholderInTheUrl() {
  return {
    subject: `{{subscriber.firstName}} Hello, World! ${PLACEHOLDER_SUBJECT_INAPP}`,
    body: `Hello, World! {{payload.placeholder.body}}`,
    avatar: 'https://www.example.com/avatar.png',
    primaryAction: {
      label: '{{payload.secondaryUrlLabel}}',
      redirect: {
        url: '{{payload.secondaryUrl}}',
        target: RedirectTargetEnum.BLANK,
      },
    },
    secondaryAction: {
      label: 'Secondary Action',
      redirect: {
        target: RedirectTargetEnum.BLANK,
        url: '',
      },
    },
    redirect: {
      target: RedirectTargetEnum.BLANK,
      url: '   ',
    },
  };
}
function buildSmsControlValuesPayload(stepId: string | undefined) {
  return {
    body: `${stepId ? ` [[{{steps.${stepId}.seen}}]]` : ''} Hello, World! {{subscriber.firstName}}`,
  };
}

function buildPushControlValuesPayload() {
  return {
    subject: 'Hello, World!',
    body: 'Hello, World! {{subscriber.firstName}}',
  };
}

function buildChatControlValuesPayload() {
  return {
    body: 'Hello, World! {{subscriber.firstName}}',
  };
}
function buildDigestControlValuesPayload() {
  return {
    cron: CronExpressionEnum.EVERY_DAY_AT_8AM,
  };
}

export const getTestControlValues = (stepId?: string) => ({
  [StepTypeEnum.Sms]: buildSmsControlValuesPayload(stepId),
  [StepTypeEnum.Email]: buildEmailControlValuesPayload(),
  [StepTypeEnum.Push]: buildPushControlValuesPayload(),
  [StepTypeEnum.Chat]: buildChatControlValuesPayload(),
  [StepTypeEnum.InApp]: buildInAppControlValues(),
  [StepTypeEnum.Digest]: buildDigestControlValuesPayload(),
});

export async function createWorkflowAndReturnId(workflowsClient: Novu, type: StepTypeEnum) {
  const createWorkflowDto = buildWorkflow({
    payloadSchema: {
      type: 'object',
      properties: {
        variableName: { type: 'string' },
        placeholder: {
          type: 'object',
          properties: {
            body: { type: 'string' },
            random: { type: 'string' },
          },
        },
        primaryUrlLabel: { type: 'string' },
        secondaryUrl: { type: 'string' },
        organizationName: { type: 'string' },
        firstName: { type: 'string' },
        lastName: { type: 'string' },
        orderId: { type: 'string' },
        subject: {
          type: 'object',
          properties: {
            test: {
              type: 'object',
              properties: {
                payload: { type: 'string' },
              },
            },
          },
        },
        params: {
          type: 'object',
          properties: {
            isPayedUser: { type: 'boolean' },
          },
        },
        hidden: {
          type: 'object',
          properties: {
            section: { type: 'string' },
          },
        },
        body: { type: 'string' },
        food: {
          type: 'object',
          properties: {
            items: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  name: { type: 'string' },
                },
              },
            },
          },
        },
        origins: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              country: { type: 'string' },
              id: { type: 'string' },
              time: { type: 'string' },
            },
          },
        },
        students: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              id: { type: 'string' },
              name: { type: 'string' },
            },
          },
        },
      },
      required: [],
      additionalProperties: false,
    },
  });
  createWorkflowDto.steps[0].type = type as any;
  const workflowResult = await workflowsClient.workflows.create(createWorkflowDto);

  return {
    workflowId: workflowResult.result.id,
    stepDatabaseId: workflowResult.result.steps[0].id,
    stepId: workflowResult.result.steps[0].stepId,
  };
}

export async function generatePreview(
  workflowsClient: Novu,
  workflowId: string,
  stepDatabaseId: string,
  dto: GeneratePreviewRequestDto
): Promise<GeneratePreviewResponseDto> {
  return (
    await workflowsClient.workflows.steps.generatePreview({
      workflowId,
      stepId: stepDatabaseId,
      generatePreviewRequestDto: dto,
    })
  ).result;
}

function buildDtoWithMissingControlValues(stepTypeEnum: StepTypeEnum, stepId: string): GeneratePreviewRequestDto {
  const stepTypeToElement = getTestControlValues(stepId)[stepTypeEnum];
  if (stepTypeEnum === StepTypeEnum.Email) {
    delete stepTypeToElement.subject;
  } else {
    delete stepTypeToElement.body;
  }

  return {
    controlValues: stepTypeToElement,
    previewPayload: { payload: { subject: PLACEHOLDER_SUBJECT_INAPP_PAYLOAD_VALUE } },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - createWorkflowAndPreview(type: StepTypeEnum, description: string)
 - updateWorkflow(id: string, workflow: UpdateWorkflowDto)
 - mapResponseToUpdateDto(workflowResponse: WorkflowResponseDto)
 - createWorkflowWithEmailLookingAtDigestResult(payloadSchema = defaultPayloadSchema)
 - createWorkflowWithSmsLookingAtInAppResult()
 - createWorkflow(overrides: Partial<NotificationTemplateEntity> = {},
    payloadSchema?: any)
 - emulateExternalOrigin(_workflowId: string)
 - buildDtoNoPayload(stepTypeEnum: StepTypeEnum, stepId?: string)
 - buildEmailControlValuesPayload()
 - buildInAppControlValues()
 - buildInAppControlValueWithAPlaceholderInTheUrl()
 - buildSmsControlValuesPayload(stepId: string | undefined)
 - buildPushControlValuesPayload()
 - buildChatControlValuesPayload()
 - buildDigestControlValuesPayload()
 - createWorkflowAndReturnId(workflowsClient: Novu, type: StepTypeEnum)
 - generatePreview(workflowsClient: Novu,
  workflowId: string,
  stepDatabaseId: string,
  dto: GeneratePreviewRequestDto)
 - buildDtoWithMissingControlValues(stepTypeEnum: StepTypeEnum, stepId: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - PLACEHOLDER_SUBJECT_INAPP_PAYLOAD_VALUE('this is the replacement text for the placeholder';

describe('Workflow Step Preview - POST /:workfl...)
 - environmentRepository(new EnvironmentRepository();
  let novuClient: Novu;

  beforeEach(async ())
 - novuClient(initNovuClassSdkInternalAuth(session);
  });

  it('should generate preview for in-app step', async ...)
 - validateDigestEvents(events: any[], expectedPayload: any))
 - countOccurrences(str: string, searchStr: string))
 - actualPayload(previewResponse.result.previewPayloadExample;
    expect(actualPayload.subscriber).to.deep.equal({
 ...)
 - href("https://numbered_link.com"');
  });

  it('should allow using the static text, variables, current a...)
 - countOccurrences(str: string, searchStr: string))
 - href("https://numbered.static.link"');
  });

  describe('Hydration testing', ())
 - preview(previewResponseDto.result!.preview.body;
      expect(previewResponseDto.result!.preview.body).to.co...)
 - previewRequestWithoutTheRedirect({
        ...inApp,
        subject: "John Hello, World! {'test':{'payload':'example text'}}",
     ...)
 - previewResponseDto(await createWorkflowAndPreview(StepTypeEnum.Sms, 'SMS');

      expect(previewResponseDto.result!.pr...)
 - previewResponseDto(await createWorkflowAndPreview(StepTypeEnum.Push, 'Push');

      expect(previewResponseDto.result!....)
 - previewResponseDto(await createWorkflowAndPreview(StepTypeEnum.Chat, 'Chat');

      expect(previewResponseDto.result!....)
 - requestDto(buildDtoNoPayload(type);

      return await generatePreview(novuClient, workflowId, stepDatabaseId,...)
 - validateDigestEventsInMergeTest(events: any[], expectedPayload: any))
 - previewResponse1(await novuClient.workflows.steps.generatePreview({
        generatePreviewRequestDto: { controlValue...)
 - channelTypes([{ type: StepTypeEnum.InApp, description: 'InApp' }];

    channelTypes.forEach(({ type }))
 - res(await novuClient.workflows.update(workflow, id);

    return res.result;
  }

  function mapResponse...)
 - getTestControlValues(stepId?: string))
Declaraciones 'export' encontradas:
- export  const
- export  async
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/e2e/list-workflows.e2e.ts
Tamaño: 4594 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import {
  CreateWorkflowDto,
  DirectionEnum,
  WorkflowCreationSourceEnum,
  WorkflowResponseDto,
  WorkflowResponseDtoSortField,
  WorkflowStatusEnum,
} from '@novu/api/models/components';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdkInternalAuth } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('List Workflows - /workflows (GET) #novu-v2', () => {
  let session: UserSession;
  let novuClient: Novu;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    novuClient = initNovuClassSdkInternalAuth(session);
  });

  describe('Pagination and Search', () => {
    it('should correctly paginate workflows', async () => {
      const workflowIds: string[] = [];
      for (let i = 0; i < 15; i += 1) {
        const workflow = await createWorkflow(`Test Workflow ${i}`);
        workflowIds.push(workflow.id);
      }

      const { result: firstPage } = await novuClient.workflows.list({ limit: 10, offset: 0 });

      expect(firstPage.workflows).to.have.length(10);
      expect(firstPage.totalCount).to.equal(15);

      const { result: secondPage } = await novuClient.workflows.list({ limit: 10, offset: 10 });

      expect(secondPage.workflows).to.have.length(5);
      expect(secondPage.totalCount).to.equal(15);

      const firstPageIds = firstPage.workflows.map((workflow) => workflow.id);
      const secondPageIds = secondPage.workflows.map((workflow) => workflow.id);
      const uniqueIds = new Set([...firstPageIds, ...secondPageIds]);

      expect(uniqueIds.size).to.equal(15);
    });

    it('should correctly search workflows by name', async () => {
      const searchTerm = 'SEARCHABLE-WORKFLOW';

      // Create workflows with different names
      await createWorkflow(`${searchTerm}-1`);
      await createWorkflow(`${searchTerm}-2`);
      await createWorkflow('Different Workflow');

      const { result } = await novuClient.workflows.list({ query: searchTerm });

      expect(result.workflows).to.have.length(2);
      expect(result.workflows[0].name).to.include(searchTerm);
      expect(result.workflows[1].name).to.include(searchTerm);
    });
  });

  describe('Sorting', () => {
    it('should sort workflows by creation date in descending order by default', async () => {
      await createWorkflow('First Workflow');
      await delay(100); // Ensure different creation times
      await createWorkflow('Second Workflow');

      const { result } = await novuClient.workflows.list({});

      expect(result.workflows[0].name).to.equal('Second Workflow');
      expect(result.workflows[1].name).to.equal('First Workflow');
    });

    it('should sort workflows by creation date in ascending order when specified', async () => {
      await createWorkflow('First Workflow');
      await delay(100); // Ensure different creation times
      await createWorkflow('Second Workflow');

      const { result } = await novuClient.workflows.list({
        orderDirection: DirectionEnum.Asc,
        orderBy: WorkflowResponseDtoSortField.Name,
      });

      expect(result.workflows[0].name).to.equal('First Workflow');
      expect(result.workflows[1].name).to.equal('Second Workflow');
    });
  });

  describe('Response Structure', () => {
    it('should return correct workflow fields in response', async () => {
      const workflowName = 'Test Workflow Structure';
      const createdWorkflow = await createWorkflow(workflowName);

      const { result } = await novuClient.workflows.list({});
      const { result: topics } = await novuClient.topics.list({});
      console.log(topics);
      const returnedWorkflow = result.workflows[0];

      expect(returnedWorkflow).to.include({
        id: createdWorkflow.id,
        name: workflowName,
        workflowId: createdWorkflow.workflowId,
        status: WorkflowStatusEnum.Active,
      });
      expect(returnedWorkflow.createdAt).to.be.a('string');
      expect(returnedWorkflow.updatedAt).to.be.a('string');
    });
  });

  async function createWorkflow(name: string): Promise<WorkflowResponseDto> {
    const createWorkflowDto: CreateWorkflowDto = {
      name,
      workflowId: name.toLowerCase().replace(/\s+/g, '-'),
      source: WorkflowCreationSourceEnum.Editor,
      active: true,
      steps: [],
    };

    const { result } = await novuClient.workflows.create(createWorkflowDto);

    return result;
  }

  function delay(ms: number): Promise<void> {
    return new Promise((resolve) => {
      setTimeout(resolve, ms);
    });
  }
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - createWorkflow(name: string)
 - delay(ms: number)
Asignaciones con arrow functions encontradas (posibles funciones):
 - novuClient(initNovuClassSdkInternalAuth(session);
  });

  describe('Pagination and Search', ())
 - firstPageIds(firstPage.workflows.map((workflow))
 - secondPageIds(secondPage.workflows.map((workflow))
 - uniqueIds(new Set([...firstPageIds, ...secondPageIds]);

      expect(uniqueIds.size).to.equal(15);
    });

 ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/e2e/upsert-workflow.e2e.ts
Tamaño: 19127 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import {
  CreateLayoutDto,
  CreateWorkflowDto,
  EmailStepResponseDto,
  InAppControlDto,
  JSONSchemaDto,
  LayoutCreationSourceEnum,
  LayoutResponseDto,
  StepTypeEnum,
  UpdateWorkflowDto,
  WorkflowCreationSourceEnum,
  WorkflowResponseDto,
} from '@novu/api/models/components';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdkInternalAuth } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

interface ITestStepConfig {
  type: StepTypeEnum;
  controlValues: Record<string, string>;
}

describe('Upsert Workflow #novu-v2', () => {
  let session: UserSession;
  let novuClient: Novu;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    novuClient = initNovuClassSdkInternalAuth(session);
  });

  describe('POST /v2/workflows/:workflowId', () => {
    it('should throw error when workflowId is not a valid slug', async () => {
      try {
        await createWorkflow({
          name: 'Test Workflow',
          workflowId: '_test-workflow-123_',
          steps: [],
        });

        // Should not reach this point
        expect.fail('Expected BadRequestException to be thrown');
      } catch (error) {
        expect(error.statusCode).to.equal(422);
        expect(error.message).to.contain('Validation Error');
        expect(error.errors).to.exist;
        expect(error.errors.general.messages[0]).to.contain(
          'must be a valid slug format (lowercase letters, numbers, and hyphens only)'
        );
      }
    });

    it('should create a workflow with a preserved workflowId', async () => {
      const workflow = await createWorkflow({
        name: 'Test Workflow',
        workflowId: 'test-workflow-123',
        steps: [],
      });

      expect(workflow.name).to.equal('Test Workflow');
      expect(workflow.workflowId).to.equal('test-workflow-123');
    });

    it('should create a workflow and preserve stepId', async () => {
      const workflow = await createWorkflow({
        name: 'Test Workflow',
        workflowId: 'test-workflow-123',
        steps: [
          {
            name: 'Test Step',
            stepId: 'test-step-123',
            type: StepTypeEnum.InApp,
            controlValues: {
              body: 'Test Body',
            },
          },
        ],
      });

      expect(workflow.name).to.equal('Test Workflow');
      expect(workflow.workflowId).to.equal('test-workflow-123');
      expect(workflow.steps.length).to.equal(1);
      expect(workflow.steps[0].id).to.exist;
      expect(workflow.steps[0].type).to.equal(StepTypeEnum.InApp);
      expect(workflow.steps[0].stepId).to.equal('test-step-123');
      expect(workflow.steps[0].controls).to.exist;
      expect(workflow.steps[0].controls.values).to.exist;
      expect((workflow.steps[0].controls.values as InAppControlDto).body).to.equal('Test Body');
    });
  });

  describe('PUT /v2/workflows/:workflowId', () => {
    describe('single step workflows', () => {
      it('when step is deleted it should not remove variable if it is used in another step', async () => {
        const workflow = await createWorkflow({
          name: 'Test Workflow',
          workflowId: `test-workflow-${Date.now()}`,
          source: WorkflowCreationSourceEnum.Editor,
          active: true,
          payloadSchema: {
            type: 'object',
            properties: {
              first_variable: { type: 'string' },
              second_variable: { type: 'string' },
            },
            required: [],
            additionalProperties: false,
          },
          steps: [
            {
              name: `IN_APP 1`,
              type: StepTypeEnum.InApp,
              controlValues: {
                body: '{{payload.first_variable}}',
              },
            },
            {
              name: `IN_APP 2`,
              type: StepTypeEnum.InApp,
              controlValues: {
                body: '{{payload.second_variable}}',
              },
            },
            {
              name: `CHAT 1`,
              type: StepTypeEnum.Chat,
              controlValues: {
                body: '{{payload.first_variable}}',
              },
            },
          ],
        });
        const chatStep = workflow.steps[2];
        const chatPayloadVariables = chatStep.variables.properties?.payload;

        expect(chatPayloadVariables).to.exist;
        expect((chatPayloadVariables as JSONSchemaDto)?.properties).to.have.property('first_variable');
        expect((chatPayloadVariables as JSONSchemaDto)?.properties).to.have.property('second_variable');

        // delete the first step
        const updatedWorkflow = await updateWorkflow(workflow.slug, {
          ...mapResponseToUpdateDto(workflow),
          steps: mapResponseToUpdateDto(workflow).steps.slice(1),
        });

        const updatedChatStep = updatedWorkflow.steps[0];
        const updatedChatPayloadVariables = updatedChatStep.variables.properties?.payload;
        expect(updatedChatPayloadVariables).to.exist;
        expect((updatedChatPayloadVariables as JSONSchemaDto)?.properties).to.have.property('first_variable');
        expect((updatedChatPayloadVariables as JSONSchemaDto)?.properties).to.have.property('second_variable');
      });
    });

    describe('email step layoutId functionality', () => {
      it('should skip layout rendering when converting Maily JSON to HTML with assigned layoutId', async () => {
        // First create a layout with distinctive HTML content
        const layout = await createLayout({
          name: 'Test Layout for skipLayoutRendering',
          layoutId: 'test-layout-skip-rendering',
          source: LayoutCreationSourceEnum.Dashboard,
        });

        const mailyJsonContent = JSON.stringify({
          type: 'doc',
          content: [
            {
              type: 'paragraph',
              content: [
                {
                  type: 'text',
                  text: 'This is email content that should not include layout HTML.',
                },
              ],
            },
          ],
        });

        // Create workflow with email step that has layoutId assigned
        const workflow = await createWorkflow({
          name: 'Test Workflow with Layout',
          workflowId: `test-workflow-layout-${Date.now()}`,
          source: WorkflowCreationSourceEnum.Editor,
          active: true,
          steps: [
            {
              name: `Email Step with Layout`,
              type: StepTypeEnum.Email,
              controlValues: {
                subject: 'Test Email with Layout',
                body: mailyJsonContent,
                editorType: 'block',
                layoutId: layout.layoutId,
              },
            },
          ],
        });

        // Switch to HTML editor - this should trigger skipLayoutRendering
        const updatedWorkflow = await updateWorkflow(workflow.slug, {
          ...workflow,
          steps: [
            {
              ...workflow.steps[0],
              controlValues: {
                ...workflow.steps[0].controls.values,
                editorType: 'html',
              },
            },
          ],
        });

        const updatedEmailStep = updatedWorkflow.steps[0] as EmailStepResponseDto;

        expect(updatedEmailStep.controls.values.editorType).to.equal('html');
        expect(updatedEmailStep.controls.values.layoutId).to.equal(layout.layoutId);

        // The body should contain the converted HTML from Maily JSON
        expect(updatedEmailStep.controls.values.body).to.not.contain('<!DOCTYPE');
        expect(updatedEmailStep.controls.values.body).to.not.contain('<html');
        expect(updatedEmailStep.controls.values.body).to.contain(
          'This is email content that should not include layout HTML'
        );
      });

      it('should not use layoutId when null is provided', async () => {
        await createLayout({
          name: 'Test Layout',
          layoutId: 'test-layout',
          source: LayoutCreationSourceEnum.Dashboard,
        });

        const workflow = await createWorkflow({
          name: 'Test Email Workflow',
          workflowId: `test-email-workflow-${Date.now()}`,
          source: WorkflowCreationSourceEnum.Editor,
          active: true,
          steps: [
            {
              name: `Email Step`,
              type: StepTypeEnum.Email,
              controlValues: {
                subject: 'Test Subject',
                body: 'Test Body',
                layoutId: null,
              },
            },
          ],
        });

        const emailStep = workflow.steps[0] as EmailStepResponseDto;
        expect(emailStep.type).to.equal(StepTypeEnum.Email);

        expect(emailStep.controls.values.layoutId).to.equal(null);
      });

      it('should keep layoutId as undefined when not specified and there is no default layout', async () => {
        const workflow = await createWorkflow({
          name: 'Test Email Workflow',
          workflowId: `test-email-workflow-${Date.now()}`,
          source: WorkflowCreationSourceEnum.Editor,
          active: true,
          steps: [
            {
              name: `Email Step`,
              type: StepTypeEnum.Email,
              controlValues: {
                subject: 'Test Subject',
                body: 'Test Body',
              },
            },
          ],
        });

        const emailStep = workflow.steps[0] as EmailStepResponseDto;
        expect(emailStep.type).to.equal(StepTypeEnum.Email);
        expect(emailStep.controls.values.layoutId).to.be.undefined;
      });

      it('should keep layoutId as undefined when not specified and there is a default layout', async () => {
        await createLayout({
          name: 'Test Layout',
          layoutId: 'test-layout-id',
          source: LayoutCreationSourceEnum.Dashboard,
        });

        const workflow = await createWorkflow({
          name: 'Test Email Workflow',
          workflowId: `test-email-workflow-${Date.now()}`,
          source: WorkflowCreationSourceEnum.Editor,
          active: true,
          steps: [
            {
              name: `Email Step`,
              type: StepTypeEnum.Email,
              controlValues: {
                subject: 'Test Subject',
                body: 'Test Body',
              },
            },
          ],
        });

        const emailStep = workflow.steps[0] as EmailStepResponseDto;
        expect(emailStep.type).to.equal(StepTypeEnum.Email);
        expect(emailStep.controls.values.layoutId).to.be.undefined;
      });

      it('should throw error when creating email step with invalid layoutId', async () => {
        try {
          await createWorkflow({
            name: 'Test Email Workflow Invalid',
            workflowId: `test-email-workflow-invalid-${Date.now()}`,
            source: WorkflowCreationSourceEnum.Editor,
            active: true,
            steps: [
              {
                name: `Email Step`,
                type: StepTypeEnum.Email,
                controlValues: {
                  subject: 'Test Subject',
                  body: 'Test Body',
                  layoutId: 'non-existent-layout-id-12345',
                },
              },
            ],
          });

          // Should not reach this point
          expect.fail('Expected BadRequestException to be thrown');
        } catch (error) {
          expect(error.message).to.contain('Layout not found');
        }
      });

      it('should throw error when updating email step with invalid layoutId', async () => {
        try {
          const workflow = await createWorkflow({
            name: 'Test Email Workflow Update Invalid',
            workflowId: `test-email-workflow-update-invalid-${Date.now()}`,
            source: WorkflowCreationSourceEnum.Editor,
            active: true,
            steps: [
              {
                name: `Email Step`,
                type: StepTypeEnum.Email,
                controlValues: {
                  subject: 'Test Subject',
                  body: 'Test Body',
                },
              },
            ],
          });

          await updateWorkflow(workflow.slug, {
            ...mapResponseToUpdateDto(workflow),
            steps: [
              {
                ...mapResponseToUpdateDto(workflow).steps[0],
                type: StepTypeEnum.Email,
                controlValues: {
                  subject: 'Test Subject',
                  body: 'Test Body',
                  layoutId: 'invalid-layout-id-67890',
                },
              },
            ],
          });

          // Should not reach this point
          expect.fail('Expected BadRequestException to be thrown');
        } catch (error) {
          expect(error.message).to.contain('Layout not found for id');
        }
      });

      it('should allow updating layoutId to specific value', async () => {
        const layout = await createLayout({
          name: 'Custom Layout',
          layoutId: 'custom-layout',
          source: LayoutCreationSourceEnum.Dashboard,
        });

        const workflow = await createWorkflow({
          name: 'Test Email Workflow',
          workflowId: `test-email-workflow-${Date.now()}`,
          source: WorkflowCreationSourceEnum.Editor,
          active: true,
          steps: [
            {
              name: `Email Step`,
              type: StepTypeEnum.Email,
              controlValues: {
                subject: 'Test Subject',
                body: 'Test Body',
              },
            },
          ],
        });

        // Update the workflow with a specific layoutId
        const updatedWorkflow = await updateWorkflow(workflow.slug, {
          ...mapResponseToUpdateDto(workflow),
          steps: [
            {
              ...mapResponseToUpdateDto(workflow).steps[0],
              type: StepTypeEnum.Email,
              controlValues: {
                subject: 'Test Subject',
                body: 'Test Body',
                layoutId: layout.layoutId,
              },
            },
          ],
        });

        const emailStep = updatedWorkflow.steps[0] as EmailStepResponseDto;
        expect(emailStep.type).to.equal(StepTypeEnum.Email);
        expect(emailStep.controls.values.layoutId).to.equal(layout.layoutId);
      });

      it('should allow updating layoutId to undefined to remove layout', async () => {
        const layout = await createLayout({
          name: 'Custom Layout',
          layoutId: 'custom-layout',
          source: LayoutCreationSourceEnum.Dashboard,
        });

        const workflow = await createWorkflow({
          name: 'Test Email Workflow',
          workflowId: `test-email-workflow-${Date.now()}`,
          source: WorkflowCreationSourceEnum.Editor,
          active: true,
          steps: [
            {
              name: `Email Step`,
              type: StepTypeEnum.Email,
              controlValues: {
                subject: 'Test Subject',
                body: 'Test Body',
                layoutId: layout.layoutId,
              },
            },
          ],
        });

        // Update the workflow to remove layout
        const updatedWorkflow = await updateWorkflow(workflow.slug, {
          ...mapResponseToUpdateDto(workflow),
          steps: [
            {
              ...mapResponseToUpdateDto(workflow).steps[0],
              type: StepTypeEnum.Email,
              controlValues: {
                subject: 'Test Subject',
                body: 'Test Body',
                layoutId: undefined,
              },
            },
          ],
        });

        const emailStep = updatedWorkflow.steps[0] as EmailStepResponseDto;
        expect(emailStep.type).to.equal(StepTypeEnum.Email);
        expect(emailStep.controls.values.layoutId).to.be.undefined;
      });
    });

    it('when switching the editor type it should convert the body value', async () => {
      const workflow = await createWorkflow({
        name: 'Test Workflow',
        workflowId: `test-workflow-${Date.now()}`,
        source: WorkflowCreationSourceEnum.Editor,
        active: true,
        steps: [
          {
            name: `Email`,
            type: StepTypeEnum.Email,
            controlValues: {
              disableOutputSanitization: false,
              editorType: 'block',
              body: '{"type":"doc","content":[{"type":"paragraph","attrs":{"textAlign":null,"showIfKey":null},"content":[{"type":"text","text":"test"}]}]}',
              subject: 'subject',
            },
          },
        ],
      });

      const updatedWorkflow = await updateWorkflow(workflow.slug, {
        ...workflow,
        steps: [
          {
            ...workflow.steps[0],
            controlValues: {
              ...workflow.steps[0].controls.values,
              editorType: 'html',
            },
          },
        ],
      });

      const updatedEmailStep = updatedWorkflow.steps[0] as EmailStepResponseDto;

      expect(updatedEmailStep.controls.values.editorType).to.equal('html');
      expect(updatedEmailStep.controls.values.body).to.contain('<html');
      expect(updatedEmailStep.controls.values.body).to.contain('<body');
      expect(updatedEmailStep.controls.values.body).to.contain(`>
              test
            </p>`);
      expect(updatedEmailStep.controls.values.body).to.contain('</body>');
      expect(updatedEmailStep.controls.values.body).to.contain('</html>');

      const updatedWorkflow2 = await updateWorkflow(workflow.slug, {
        ...workflow,
        steps: [
          {
            ...workflow.steps[0],
            controlValues: {
              ...updatedEmailStep.controls.values,
              editorType: 'block',
            },
          },
        ],
      });

      const updatedEmailStep2 = updatedWorkflow2.steps[0] as EmailStepResponseDto;
      expect(updatedEmailStep2.controls.values.editorType).to.equal('block');
      expect(updatedEmailStep2.controls.values.body).to.equal('');
    });
  });

  async function createLayout(layout: CreateLayoutDto): Promise<LayoutResponseDto> {
    const { result: createLayoutBody } = await novuClient.layouts.create(layout);

    return createLayoutBody;
  }

  async function createWorkflow(workflow: CreateWorkflowDto): Promise<WorkflowResponseDto> {
    const { result: createWorkflowBody } = await novuClient.workflows.create(workflow);

    return createWorkflowBody;
  }

  async function updateWorkflow(workflowSlug: string, workflow: UpdateWorkflowDto): Promise<WorkflowResponseDto> {
    const { result: updateWorkflowBody } = await novuClient.workflows.update(workflow, workflowSlug);

    return updateWorkflowBody;
  }

  function mapResponseToUpdateDto(workflowResponse: WorkflowResponseDto): UpdateWorkflowDto {
    return {
      ...workflowResponse,
      steps: workflowResponse.steps.map((step) => ({
        id: step.id,
        type: step.type,
        name: step.name,
        controlValues: step.controls?.values || {},
      })),
    };
  }
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - createLayout(layout: CreateLayoutDto)
 - createWorkflow(workflow: CreateWorkflowDto)
 - updateWorkflow(workflowSlug: string, workflow: UpdateWorkflowDto)
 - mapResponseToUpdateDto(workflowResponse: WorkflowResponseDto)
Asignaciones con arrow functions encontradas (posibles funciones):
 - novuClient(initNovuClassSdkInternalAuth(session);
  });

  describe('POST /v2/workflows/:workflowId', ())
 - workflow(await createWorkflow({
        name: 'Test Workflow',
        workflowId: 'test-workflow-123',
     ...)
 - workflow(await createWorkflow({
        name: 'Test Workflow',
        workflowId: 'test-workflow-123',
     ...)
 - updatedChatPayloadVariables(updatedChatStep.variables.properties?.payload;
        expect(updatedChatPayloadVariables).to.exist;...)
 - updatedEmailStep(updatedWorkflow.steps[0] as EmailStepResponseDto;

        expect(updatedEmailStep.controls.values.e...)
 - emailStep(workflow.steps[0] as EmailStepResponseDto;
        expect(emailStep.type).to.equal(StepTypeEnum.Emai...)
 - emailStep(workflow.steps[0] as EmailStepResponseDto;
        expect(emailStep.type).to.equal(StepTypeEnum.Emai...)
 - emailStep(workflow.steps[0] as EmailStepResponseDto;
        expect(emailStep.type).to.equal(StepTypeEnum.Emai...)
 - workflow(await createWorkflow({
            name: 'Test Email Workflow Update Invalid',
            workflowI...)
 - emailStep(updatedWorkflow.steps[0] as EmailStepResponseDto;
        expect(emailStep.type).to.equal(StepTypeEn...)
 - emailStep(updatedWorkflow.steps[0] as EmailStepResponseDto;
        expect(emailStep.type).to.equal(StepTypeEn...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/exceptions/invalid-step.exception.ts
Tamaño: 306 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { InternalServerErrorException } from '@nestjs/common';

export class InvalidStepException extends InternalServerErrorException {
  constructor(problematicStepId: string) {
    super({ message: 'persisted step was found Invalid, potential bug to be investigated ', step: problematicStepId });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class InvalidStepException

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/exceptions/step-id-missing.exception.ts
Tamaño: 480 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { InternalServerErrorException } from '@nestjs/common';

export class StepIdMissingException extends InternalServerErrorException {
  constructor(workflowId: string) {
    super({ message: `StepId is missing for the workflowId: ${workflowId}`, workflowId });
  }
}

export class OriginMissingException extends InternalServerErrorException {
  constructor(workflowId: string) {
    super({
      message: 'Origin is missing on the workflow',
      workflowId,
    });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class StepIdMissingException
- export class OriginMissingException

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/workflows-v2/exceptions/step-not-found-exception.ts
Tamaño: 717 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { InternalServerErrorException, NotFoundException } from '@nestjs/common';

export class StepNotFoundException extends NotFoundException {
  constructor(stepDatabaseId: string) {
    super({ message: 'Step cannot be found using the UUID Supplied', stepDatabaseId });
  }
}
export class StepMissingControlsException extends InternalServerErrorException {
  constructor(stepDatabaseId: string, step: any) {
    super({ message: 'Step cannot be found using the UUID Supplied', stepDatabaseId, step });
  }
}
export class StepMissingStepIdException extends InternalServerErrorException {
  constructor(stepDatabaseId: string, step: any) {
    super({ message: 'Step Missing StepId', stepDatabaseId, step });
  }
}
