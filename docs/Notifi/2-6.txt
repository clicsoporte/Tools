


describe('defaultOutputEscape', () => {
  it('should convert arrays to strings with single quotes', () => {
    // prettier-ignore
    const array = ['a', 'b', 'c'];

    const result = defaultOutputEscape(array);
    expect(result).toBe("['a','b','c']");
  });

  it('should convert objects to strings with single quotes', () => {
    // prettier-ignore
    const obj = { a: 1, b: 'test' };
    const result = defaultOutputEscape(obj);
    expect(result).toBe("{'a':1,'b':'test'}");
  });

  it('should handle nested objects and arrays', () => {
    // prettier-ignore
    const complex = { a: [1, 2], b: { c: 'test' } };
    const result = defaultOutputEscape(complex);
    expect(result).toBe("{'a':[1,2],'b':{'c':'test'}}");
  });

  it('should escape newlines in strings', () => {
    const str = 'line1\nline2';
    const result = defaultOutputEscape(str);
    expect(result).toBe('line1\\nline2');
  });

  it('should convert primitives to strings', () => {
    expect(defaultOutputEscape(123)).toBe('123');
    expect(defaultOutputEscape(true)).toBe('true');
    expect(defaultOutputEscape(false)).toBe('false');
    expect(defaultOutputEscape(null)).toBe('');
    expect(defaultOutputEscape(undefined)).toBe('');
  });
});

describe('stringifyDataStructureWithSingleQuotes', () => {
  it('should convert a simple array to a string with single quotes', () => {
    const myTestArray = ['a', 'b', 'c'];
    const converted = stringifyDataStructureWithSingleQuotes(myTestArray);
    expect(converted).toStrictEqual("['a','b','c']");
  });

  it('should convert an array with nested objects to a string with single quotes', () => {
    const myTestObject = [{ text: 'cat' }, { text: 'dog' }];
    const converted = stringifyDataStructureWithSingleQuotes(myTestObject);
    expect(converted).toStrictEqual("[{'text':'cat'},{'text':'dog'}]");
  });

  it('should convert an object with nested objects to a string with single quotes', () => {
    const myTestObject = { comments: [{ text: 'cat' }, { text: 'dog' }] };
    const converted = stringifyDataStructureWithSingleQuotes(myTestObject);
    expect(converted).toStrictEqual("{'comments':[{'text':'cat'},{'text':'dog'}]}");
  });

  it('should convert an object with nested objects to a string with single quotes and spaces', () => {
    const myTestObject = { comments: [{ text: 'cat' }, { text: 'dog' }] };
    const converted = stringifyDataStructureWithSingleQuotes(myTestObject, 2);
    expect(converted).toStrictEqual(
      `{\\n  'comments': [\\n    {\\n      'text': 'cat'\\n    },\\n    {\\n      'text': 'dog'\\n    }\\n  ]\\n}`
    );
  });

  it('should convert a string to a string without single quotes', () => {
    const myTestString = 'hello';
    const converted = stringifyDataStructureWithSingleQuotes(myTestString);
    expect(converted).toStrictEqual('hello');
  });

  it('should convert a number to a string without single quotes', () => {
    const myTestNumber = 123;
    const converted = stringifyDataStructureWithSingleQuotes(myTestNumber);
    expect(converted).toStrictEqual('123');
  });

  it('should convert a boolean to a string without single quotes', () => {
    const myTestBoolean = true;
    const converted = stringifyDataStructureWithSingleQuotes(myTestBoolean);
    expect(converted).toStrictEqual('true');
  });

  it('should convert null to an empty string', () => {
    const myTestNull = null;
    const converted = stringifyDataStructureWithSingleQuotes(myTestNull);
    expect(converted).toStrictEqual('');
  });

  it('should convert undefined to an empty string', () => {
    const myTestUndefined = undefined;
    const converted = stringifyDataStructureWithSingleQuotes(myTestUndefined);
    expect(converted).toStrictEqual('');
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - engine(createLiquidEngine();
    expect(engine).toBeInstanceOf(Liquid);
  });

  it('should register the de...)
 - result(await engine.parseAndRender(template, data);
    expect(result).toBe("{'a':1,'b':'test'}");
  });

 ...)
 - result(await engine.parseAndRender(template, data);
    expect(result).toBe('John, Jane and 2 others');
  }...)
 - result(await engine.parseAndRender(template, data);
    expect(result).toBe('John, Jane, and 2 others');
  ...)
 - result(await engine.parseAndRender(template, data);
    expect(result).toBe('1 other');
  });

  it('should...)
 - result(await engine.parseAndRender(template, data);
    expect(result).toBe('activities');
  });

  it('sho...)
 - result(await engine.parseAndRender(template, data);

    expect(result).toContain(
      "Users: [{'name':'...)
 - compiledString(await engine.render(templateString, {
      payload: event.payload,
      subscriber: event.subscrib...)
 - result(JSON.parse(compiledString);

    expect(result.subject).toBe('Hello, Alice');
    expect(result.cont...)
 - result(JSON.parse(rendered);

    expect(result.email.subject).toBe('Welcome John');
    expect(result.emai...)
 - result(await engine.parseAndRender(template, data);

    expect(result).toContain('Previous step result: su...)
 - result(await engine.parseAndRender(template, data);
    expect(result).toContain('Items:');
    expect(resu...)
 - jsonResult(await engine.parseAndRender(jsonTemplate, data);
    expect(jsonResult).toBe('Line 1\\nLine 2\\nLine...)
 - result(defaultOutputEscape(array);
    expect(result).toBe("['a','b','c']");
  });

  it('should convert ob...)
 - result(defaultOutputEscape(obj);
    expect(result).toBe("{'a':1,'b':'test'}");
  });

  it('should handle ...)
 - result(defaultOutputEscape(complex);
    expect(result).toBe("{'a':[1,2],'b':{'c':'test'}}");
  });

  it('...)
 - result(defaultOutputEscape(str);
    expect(result).toBe('line1\\nline2');
  });

  it('should convert prim...)
 - converted(stringifyDataStructureWithSingleQuotes(myTestArray);
    expect(converted).toStrictEqual("['a','b','...)
 - converted(stringifyDataStructureWithSingleQuotes(myTestObject);
    expect(converted).toStrictEqual("[{'text':...)
 - converted(stringifyDataStructureWithSingleQuotes(myTestObject);
    expect(converted).toStrictEqual("{'comment...)
 - converted(stringifyDataStructureWithSingleQuotes(myTestObject, 2);
    expect(converted).toStrictEqual(
      ...)
 - converted(stringifyDataStructureWithSingleQuotes(myTestString);
    expect(converted).toStrictEqual('hello');
...)
 - converted(stringifyDataStructureWithSingleQuotes(myTestNumber);
    expect(converted).toStrictEqual('123');
  ...)
 - converted(stringifyDataStructureWithSingleQuotes(myTestBoolean);
    expect(converted).toStrictEqual('true');
...)
 - converted(stringifyDataStructureWithSingleQuotes(myTestNull);
    expect(converted).toStrictEqual('');
  });

...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/utils/liquid.utils.ts
Tamaño: 2330 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Liquid, LiquidOptions } from 'liquidjs';
import { digest } from '../filters/digest';
import { pluralize } from '../filters/pluralize';
import { toSentence } from '../filters/to-sentence';
/**
 * Default output escape function that properly handles objects, arrays, and strings with newlines.
 *
 * @param output - The value to escape
 * @returns The escaped value as a string
 */
export function defaultOutputEscape(output: unknown): string {
  // For objects and arrays, use the existing function
  if (Array.isArray(output) || (typeof output === 'object' && output !== null)) {
    return stringifyDataStructureWithSingleQuotes(output);
  }
  // For strings that might contain newlines, ensure proper escaping
  else if (typeof output === 'string' && output.includes('\n')) {
    return output.replace(/\n/g, '\\n');
  } else {
    return output === undefined || output === null ? '' : String(output as unknown);
  }
}

/**
 * Converts a data structure to a string with single quotes,
 * converting primitives to strings.
 * @param value The value to convert
 * @returns A string with single quotes around objects and arrays, and the stringified value itself if it's not an object or array
 */
export const stringifyDataStructureWithSingleQuotes = (value: unknown, spaces: number = 0): string => {
  if (Array.isArray(value) || (typeof value === 'object' && value !== null)) {
    const valueStringified = JSON.stringify(value, null, spaces);
    const valueSingleQuotes = valueStringified.replace(/"/g, "'");
    const valueEscapedNewLines = valueSingleQuotes.replace(/\n/g, '\\n');

    return valueEscapedNewLines;
  } else {
    return value === undefined || value === null ? '' : String(value as unknown);
  }
};

/**
 * Creates a configured Liquid instance with Novu's default settings.
 */
export function createLiquidEngine(options?: LiquidOptions): Liquid {
  const liquidEngine = new Liquid({
    outputEscape: defaultOutputEscape,
    ...options,
  });

  // Register default filters
  liquidEngine.registerFilter('json', (value: unknown, spaces: number) =>
    stringifyDataStructureWithSingleQuotes(value, spaces)
  );
  liquidEngine.registerFilter('digest', digest);
  liquidEngine.registerFilter('toSentence', toSentence);
  liquidEngine.registerFilter('pluralize', pluralize);

  return liquidEngine;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - defaultOutputEscape(output: unknown)
 - if(Array.isArray(output)
 - createLiquidEngine(options?: LiquidOptions)
Asignaciones con arrow functions encontradas (posibles funciones):
 - number(0): string)
 - liquidEngine(new Liquid({
    outputEscape: defaultOutputEscape,
    ...options,
  });

  // Register default fil...)
Declaraciones 'export' encontradas:
- export function defaultOutputEscape
- export  const
- export function createLiquidEngine

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/utils/log.utils.ts
Tamaño: 868 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import chalk from 'chalk';

export const log = {
  info: (message: string) => chalk.blue(message),
  warning: (message: string) => chalk.yellow(message),
  error: (message: string) => chalk.red(message),
  success: (message: string) => chalk.green(message),
  underline: (message: string) => chalk.underline(message),
  bold: (message: string) => chalk.bold(message),
};
export const EMOJI = {
  SUCCESS: log.success('✔'),
  ERROR: log.error('✗'),
  WARNING: log.warning('⚠'),
  INFO: log.info('ℹ'),
  ARROW: log.bold('→'),
  MOCK: log.info('○'),
  HYDRATED: log.bold(log.info('→')),
  STEP: log.info('σ'),
  ACTION: log.info('α'),
  DURATION: log.info('Δ'),
  PROVIDER: log.info('⚙'),
  OUTPUT: log.info('⇢'),
  INPUT: log.info('⇠'),
  WORKFLOW: log.info('ω'),
  STATE: log.info('σ'),
  EXECUTE: log.info('ε'),
  PREVIEW: log.info('ρ'),
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - log({
  info: (message: string))
Declaraciones 'export' encontradas:
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/utils/object.utils.ts
Tamaño: 1619 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export function deepMerge(target: Record<string, unknown>, source: Record<string, unknown>): Record<string, unknown> {
  const output: Record<string, unknown> = { ...target };

  for (const key of Object.keys(source)) {
    const value = source[key];

    // If the value is an object and not an array, we need to merge it deeply
    if (value && typeof value === 'object' && !Array.isArray(value)) {
      // If the target doesn't have this key, create an empty object
      output[key] = deepMerge(
        (output[key] as Record<string, unknown>) || {}, // Ensure it's treated as an object
        value as Record<string, unknown> // Ensure the value is treated as an object
      );
    } else if (Array.isArray(value)) {
      // Replace the existing array with the source array
      output[key] = value; // Directly assign the source array
    } else {
      // Otherwise, just assign the value from the source
      output[key] = value;
    }
  }

  return output;
}

export function getNestedValue(obj: Record<string, unknown>, path: string): string {
  const value = path.split('.').reduce((current: unknown, key) => {
    if (current && typeof current === 'object') {
      return (current as Record<string, unknown>)[key];
    }

    return undefined;
  }, obj);

  if (value === null || value === undefined) return '';
  if (typeof value === 'string') return value;
  if (typeof value === 'number' || typeof value === 'boolean') return String(value);
  if (typeof value === 'object') {
    const stringified = JSON.stringify(value);

    return stringified === '{}' ? '' : stringified;
  }

  return '';
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - deepMerge(target: Record<string, unknown>, source: Record<string, unknown>)
 - getNestedValue(obj: Record<string, unknown>, path: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - value(path.split('.').reduce((current: unknown, key))
Declaraciones 'export' encontradas:
- export function deepMerge
- export function getNestedValue

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/utils/options.utils.ts
Tamaño: 312 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export function resolveApiUrl(providedApiUrl?: string): string {
  return providedApiUrl || process.env.NOVU_API_URL || 'https://api.novu.co';
}

export function resolveSecretKey(providedSecretKey?: string): string {
  return providedSecretKey || process.env.NOVU_SECRET_KEY || process.env.NOVU_API_KEY || '';
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - resolveApiUrl(providedApiUrl?: string)
 - resolveSecretKey(providedSecretKey?: string)
Declaraciones 'export' encontradas:
- export function resolveApiUrl
- export function resolveSecretKey

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/utils/platform.utils.ts
Tamaño: 330 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { IResponseError } from '../shared';

/**
 * Validate (type-guard) that an error response matches our IResponseError interface.
 */
export const checkIsResponseError = (err: unknown): err is IResponseError => {
  return !!err && typeof err === 'object' && 'error' in err && 'message' in err && 'statusCode' in err;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - checkIsResponseError(err: unknown): err is IResponseError)
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/utils/sanitize.utils.test.ts
Tamaño: 4546 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { describe, expect, it } from 'vitest';
import { sanitizeHtmlInObject } from './sanitize.utils';

const scriptBody = `<script>alert('Hello there')</script>`;

describe('sanitize util', () => {
  it('should remove script tags from an object', () => {
    const myTestObject = {
      property: scriptBody,
      numberItem: 0,
      nullItem: null,
      emptyObjectItem: {},
      booleanItem: true,
      listOfStrings: [scriptBody, scriptBody],
      moreProperties: {
        property: scriptBody,
        listOfStrings: [scriptBody, scriptBody],
      },
      listOfObjects: [{ property: scriptBody }, { property: scriptBody }],
    };

    const result = sanitizeHtmlInObject(myTestObject);

    expect(result).toStrictEqual({
      property: '',
      numberItem: 0,
      nullItem: null,
      emptyObjectItem: {},
      booleanItem: true,
      listOfStrings: ['', ''],
      moreProperties: { property: '', listOfStrings: ['', ''] },
      listOfObjects: [{ property: '' }, { property: '' }],
    });
  });

  it('should convert camelCased attributes to lowercase', () => {
    const myTestObject = {
      input:
        '<table align="center" width="100%" border="0" cellPadding="0" cellSpacing="0" role="presentation"><tr><td>Hello</td></tr></table>',
    };

    const result = sanitizeHtmlInObject(myTestObject);

    expect(result).toStrictEqual({
      input:
        '<table align="center" width="100%" border="0" cellpadding="0" cellspacing="0" role="presentation"><tr><td>Hello</td></tr></table>',
    });
  });

  type TestCase = {
    tag: string;
    input: string;
    expected: string;
  };

  const keepTagTestCases: TestCase[] = [
    {
      tag: 'body',
      input: '<body>Hello</body>',
      expected: '<body>Hello</body>',
    },
    {
      tag: 'div',
      input: '<div>Hello</div>',
      expected: '<div>Hello</div>',
    },
    {
      tag: 'table',
      input: '<table><tr><td>Hello</td></tr></table>',
      expected: '<table><tr><td>Hello</td></tr></table>',
    },
    {
      tag: 'a',
      input: '<a href="https://example.com">Hello</a>',
      expected: '<a href="https://example.com">Hello</a>',
    },
    {
      tag: 'img',
      input: '<img src="https://example.com/image.jpg" alt="Hello" />',
      expected: '<img src="https://example.com/image.jpg" alt="Hello" />',
    },
    {
      tag: 'p',
      input: '<p>Hello</p>',
      expected: '<p>Hello</p>',
    },
    {
      tag: 'span',
      input: '<span>Hello</span>',
      expected: '<span>Hello</span>',
    },
    {
      tag: 'DOCTYPE',
      input:
        '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">',
      expected:
        '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">',
    },
    {
      tag: 'title',
      input: '<title>Hello</title>',
      expected: '<title>Hello</title>',
    },
    {
      tag: 'meta',
      input: '<meta name="description" content="Hello" />',
      expected: '<meta name="description" content="Hello" />',
    },
    {
      tag: 'link',
      input: '<link rel="stylesheet" href="https://example.com/style.css" />',
      expected: '<link rel="stylesheet" href="https://example.com/style.css" />',
    },
    {
      tag: 'style',
      input: '<style>body { background-color: red; }</style>',
      expected: '<style>body { background-color: red; }</style>',
    },
    {
      tag: 'br',
      input: '<br />',
      expected: '<br />',
    },
    {
      tag: 'hr',
      input: '<hr />',
      expected: '<hr />',
    },
  ];

  keepTagTestCases.forEach(({ tag, input, expected }) => {
    it(`should not remove <${tag}> tags`, () => {
      const myTestObject = { input };
      const result = sanitizeHtmlInObject(myTestObject);
      expect(result).toStrictEqual({ input: expected });
    });
  });

  const removeTagTestCases: TestCase[] = [
    {
      tag: 'script',
      input: scriptBody,
      expected: '',
    },
    {
      tag: 'button',
      input: '<button>Click me</button>',
      expected: 'Click me',
    },
    {
      tag: 'iframe',
      input: '<iframe src="https://example.com"></iframe>',
      expected: '',
    },
  ];

  removeTagTestCases.forEach(({ tag, input, expected }) => {
    it(`should remove <${tag}> tags`, () => {
      const myTestObject = { input };
      const result = sanitizeHtmlInObject(myTestObject);
      expect(result).toStrictEqual({ input: expected });
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - scriptBody(`<script>alert('Hello there')</script>`;

describe('sanitize util', ())
 - result(sanitizeHtmlInObject(myTestObject);

    expect(result).toStrictEqual({
      property: '',
      nu...)
 - href("https://example.com/style.css" />',
    },
    {
      tag: 'style',
      input: '<style>body { ba...)
 - src("https://example.com"></iframe>',
      expected: '',
    },
  ];

  removeTagTestCases.forEach(({ t...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/utils/sanitize.utils.ts
Tamaño: 2603 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import sanitizeTypes, { IOptions } from 'sanitize-html';

/**
 * Options for the sanitize-html library.
 *
 * We are providing a permissive approach by default, with the exception of
 * disabling `script` tags.
 *
 * @see https://www.npmjs.com/package/sanitize-html#default-options
 */
const sanitizeOptions: IOptions = {
  /**
   * Additional tags to allow.
   */
  allowedTags: sanitizeTypes.defaults.allowedTags.concat([
    'style',
    'img',
    'html',
    'head',
    'body',
    'link',
    'meta',
    'title',
  ]),
  // Setting this to false to allow all attributes.
  allowedAttributes: false,
  /**
   * Required to disable console warnings when allowing style tags.
   *
   * We are allowing style tags to support the use of styles in the In-App Editor.
   * This is a known security risk through an XSS attack vector,
   * but we are accepting this risk by dropping support for IE11.
   *
   * @see https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html#remote-style-sheet
   */
  allowVulnerableTags: true,
  /**
   * Required to disable formatting of style attributes. This is useful to retain
   * formatting of style attributes in the In-App Editor.
   */
  parseStyleAttributes: false,
  parser: {
    // Convert the case of attribute names to lowercase.
    lowerCaseAttributeNames: true,
  },
};

export const sanitizeHTML = (html: string): string => {
  if (!html) {
    return html;
  }

  // Sanitize-html removes the DOCTYPE tag, so we need to add it back.
  const doctypeRegex = /^<!DOCTYPE .*?>/;
  const doctypeTags = html.match(doctypeRegex);
  const cleanHtml = sanitizeTypes(html, sanitizeOptions);

  const cleanHtmlWithDocType = doctypeTags ? doctypeTags[0] + cleanHtml : cleanHtml;

  return cleanHtmlWithDocType;
};

export const sanitizeHtmlInObject = <T extends Record<string, unknown>>(object: T): T => {
  return Object.keys(object).reduce((acc, key: keyof T) => {
    const value = object[key];

    if (typeof value === 'string') {
      acc[key] = sanitizeHTML(value) as T[keyof T];
    } else if (Array.isArray(value)) {
      acc[key] = value.map((item) => {
        if (typeof item === 'string') {
          return sanitizeHTML(item);
        } else if (typeof item === 'object') {
          return sanitizeHtmlInObject(item);
        } else {
          return item;
        }
      }) as T[keyof T];
    } else if (typeof value === 'object' && value !== null) {
      acc[key] = sanitizeHtmlInObject(value as Record<string, unknown>) as T[keyof T];
    } else {
      acc[key] = value;
    }

    return acc;
  }, {} as T);
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - sanitizeHTML(html: string): string)
 - sanitizeHtmlInObject(<T extends Record<string, unknown>>(object: T): T)
Declaraciones 'export' encontradas:
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/utils/string.utils.test.ts
Tamaño: 593 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { describe, expect, it } from 'vitest';
import { toConstantCase } from './string.utils';

describe('convert to constant case', () => {
  it('converts properties correctly', () => {
    const myTestObject = {
      aProperty: 'A_PROPERTY',
      someMoreWords: 'SOME_MORE_WORDS',
      single: 'SINGLE',
      ALLCAPS: 'ALLCAPS',
      StartWithCap: 'START_WITH_CAP',
    };

    Object.entries(myTestObject).reduce((_acc, [prop, value]: [string, string]) => {
      const converted = toConstantCase(prop);
      expect(converted).toEqual(value);

      return '';
    }, '');
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - myTestObject({
      aProperty: 'A_PROPERTY',
      someMoreWords: 'SOME_MORE_WORDS',
      single: 'SINGLE',
   ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/utils/string.utils.ts
Tamaño: 684 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/// <reference lib="es2021" />

export const toConstantCase = (str: string): string =>
  str
    .replaceAll(/([a-z])([A-Z])/g, '$1_$2')
    .replaceAll(/[\s-]+/g, '_')
    .toUpperCase();

/**
 * Converts an enum to a pretty string,
 * wrapping the values in backticks and joining them with a comma
 * @param _enum The enum
 * @returns A pretty string
 */

export const enumToPrettyString = <T extends Object>(_enum: T): string =>
  Object.values(_enum)
    .map((method) => `\`${method}\``)
    .join(', ');

export const toPascalCase = (str: string): string =>
  str.replaceAll(/(\w)(\w*)/g, (_, first, rest) => first.toUpperCase() + rest.toLowerCase()).replaceAll(/[\s-]+/g, '');


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - toConstantCase(str: string): string)
 - enumToPrettyString(<T extends Object>(_enum: T): string)
 - toPascalCase(str: string): string)
Declaraciones 'export' encontradas:
- export  const
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/validators/base.validator.ts
Tamaño: 1820 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { FromSchema, FromSchemaUnvalidated, JsonSchema, Schema, ZodSchema } from '../types/schema.types';
import type { ValidateResult } from '../types/validator.types';
import { JsonSchemaValidator } from './json-schema.validator';
import { ZodValidator } from './zod.validator';

const zodValidator = new ZodValidator();
const jsonSchemaValidator = new JsonSchemaValidator();

/**
 * Validate data against a schema.
 *
 * @param schema - The schema to validate the data against.
 * @param data - The data to validate.
 * @returns The validated data.
 */
export const validateData = async <
  T_Schema extends Schema = Schema,
  T_Unvalidated extends Record<string, unknown> = FromSchemaUnvalidated<T_Schema>,
  T_Validated extends Record<string, unknown> = FromSchema<T_Schema>,
>(
  schema: T_Schema,
  data: T_Unvalidated
): Promise<ValidateResult<T_Validated>> => {
  /**
   * TODO: Replace type coercion with async type guard when available.
   *
   * @see https://github.com/microsoft/typescript/issues/37681
   */
  if (await zodValidator.canHandle(schema)) {
    return zodValidator.validate(data, schema as ZodSchema);
  } else if (await jsonSchemaValidator.canHandle(schema)) {
    return jsonSchemaValidator.validate(data, schema as JsonSchema);
  }

  throw new Error('Invalid schema');
};

/**
 * Transform a schema to a JSON schema.
 *
 * @param schema - The schema to transform.
 * @returns The transformed JSON schema.
 */
export const transformSchema = async (schema: Schema): Promise<JsonSchema> => {
  if (await zodValidator.canHandle(schema)) {
    return zodValidator.transformToJsonSchema(schema as ZodSchema);
  } else if (await jsonSchemaValidator.canHandle(schema)) {
    return jsonSchemaValidator.transformToJsonSchema(schema as JsonSchema);
  }

  throw new Error('Invalid schema');
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - transformSchema(async (schema: Schema): Promise<JsonSchema>)
Declaraciones 'export' encontradas:
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/validators/index.ts
Tamaño: 34 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './base.validator';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/validators/json-schema.validator.ts
Tamaño: 2761 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { ValidateFunction as AjvValidateFunction, ErrorObject } from 'ajv';
import Ajv from 'ajv';
import addFormats from 'ajv-formats';
import { ImportRequirement } from '../types/import.types';
import type { FromSchema, FromSchemaUnvalidated, JsonSchema, Schema } from '../types/schema.types';
import type { ValidateResult, Validator } from '../types/validator.types';
import { cloneData } from '../utils/clone.utils';
import { checkDependencies } from '../utils/import.utils';

export class JsonSchemaValidator implements Validator<JsonSchema> {
  /**
   * Json schema validation has no required dependencies as they are included in
   * the `@novu/framework` package dependencies.
   */
  readonly requiredImports: readonly ImportRequirement[] = [];

  private readonly ajv: Ajv;

  /**
   * Cache of compiled schemas.
   *
   * Schema compilation into ajv validator is costly, so we cache the compiled schemas
   * to avoid recompiling the same schema multiple times.
   */
  private readonly compiledSchemas: Map<JsonSchema, AjvValidateFunction>;

  constructor() {
    this.ajv = new Ajv({
      // https://ajv.js.org/options.html#usedefaults
      useDefaults: true,
      // https://ajv.js.org/options.html#removeadditional
      removeAdditional: 'failing',
    });
    addFormats(this.ajv);
    this.compiledSchemas = new Map();
  }

  async canHandle(schema: Schema): Promise<boolean> {
    const canHandle =
      (schema as JsonSchema).type === 'object' ||
      !!(schema as JsonSchema).anyOf ||
      !!(schema as JsonSchema).allOf ||
      !!(schema as JsonSchema).oneOf;

    if (canHandle) {
      await checkDependencies(this.requiredImports, 'JSON schema');
    }

    return canHandle;
  }

  async validate<
    T_Schema extends JsonSchema = JsonSchema,
    T_Unvalidated = FromSchemaUnvalidated<T_Schema>,
    T_Validated = FromSchema<T_Schema>,
  >(data: T_Unvalidated, schema: T_Schema): Promise<ValidateResult<T_Validated>> {
    let validateFn = this.compiledSchemas.get(schema);

    if (!validateFn) {
      validateFn = this.ajv.compile(schema);
      this.compiledSchemas.set(schema, validateFn);
    }
    // ajv mutates the data, so we need to clone it to avoid side effects
    const clonedData = cloneData(data);

    const valid = validateFn(clonedData);

    if (valid) {
      return { success: true, data: clonedData as unknown as T_Validated };
    } else {
      return {
        success: false,
        errors: (validateFn.errors as ErrorObject<string, Record<string, unknown>, unknown>[]).map((err) => ({
          path: err.instancePath,
          message: err.message as string,
        })),
      };
    }
  }

  async transformToJsonSchema(schema: JsonSchema): Promise<JsonSchema> {
    return schema;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - valid(validateFn(clonedData);

    if (valid) {
      return { success: true, data: clonedData as unknown ...)
Declaraciones 'export' encontradas:
- export class JsonSchemaValidator

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/validators/validator.test.ts
Tamaño: 19461 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { describe, expect, it } from 'vitest';
import { z } from 'zod';
import { JsonSchema, Schema, ZodSchema } from '../types/schema.types';
import { transformSchema, validateData } from './base.validator';

const schemas = ['zod', 'json'] as const;

describe('validators', () => {
  describe('validateData', () => {
    type ValidateDataTestCase = {
      title: string;
      schemas: {
        zod: ZodSchema | null;
        json: JsonSchema;
      };
      payload: Record<string, unknown>;
      result: {
        success: boolean;
        data?: Record<string, unknown>;
        errors?: {
          zod: { message: string; path: string }[] | null;
          json: { message: string; path: string }[];
        };
      };
    };
    const testCases: ValidateDataTestCase[] = [
      {
        title: 'should successfully validate data',
        schemas: {
          zod: z.object({ name: z.string() }),
          json: { type: 'object', properties: { name: { type: 'string' } } } as const,
        },
        payload: { name: 'John' },
        result: {
          success: true,
          data: { name: 'John' },
        },
      },
      {
        title: 'should remove additional properties and successfully validate',
        schemas: {
          zod: z.object({ name: z.string() }),
          json: { type: 'object', properties: { name: { type: 'string' } }, additionalProperties: false } as const,
        },
        payload: { name: 'John', age: 30 },
        result: {
          success: true,
          data: { name: 'John' },
        },
      },
      {
        title: 'should return errors when given invalid types',
        schemas: {
          zod: z.object({ name: z.string() }),
          json: { type: 'object', properties: { name: { type: 'string' } } } as const,
        },
        payload: { name: 123 },
        result: {
          success: false,
          errors: {
            // TODO: error normalization
            json: [{ message: 'must be string', path: '/name' }],
            zod: [{ message: 'Expected string, received number', path: '/name' }],
          },
        },
      },
      {
        title: 'should validate nested properties successfully',
        schemas: {
          zod: z.object({ name: z.string(), nested: z.object({ age: z.number() }) }),
          json: {
            type: 'object',
            properties: {
              name: { type: 'string' },
              nested: { type: 'object', properties: { age: { type: 'number' } } },
            },
          } as const,
        },
        payload: { name: 'John', nested: { age: 30 } },
        result: {
          success: true,
          data: { name: 'John', nested: { age: 30 } },
        },
      },
      {
        title: 'should return errors for invalid nested properties',
        schemas: {
          zod: z.object({ name: z.string(), nested: z.object({ age: z.number() }) }),
          json: {
            type: 'object',
            properties: {
              name: { type: 'string' },
              nested: { type: 'object', properties: { age: { type: 'number' } } },
            },
          } as const,
        },
        payload: { name: 'John', nested: { age: '30' } },
        result: {
          success: false,
          errors: {
            zod: [{ message: 'Expected number, received string', path: '/nested/age' }],
            json: [{ message: 'must be number', path: '/nested/age' }],
          },
        },
      },
      {
        title: 'should successfully validate a polymorphic oneOf schema',
        schemas: {
          zod: null, // Zod has no support for `oneOf`
          json: {
            oneOf: [
              { type: 'object', properties: { stringType: { type: 'string' } }, required: ['stringType'] },
              { type: 'object', properties: { numberType: { type: 'number' } }, required: ['numberType'] },
              { type: 'object', properties: { booleanType: { type: 'boolean' } }, required: ['booleanType'] },
            ],
          } as const,
        },
        payload: {
          stringType: '123',
        },
        result: {
          success: true,
          data: {
            stringType: '123',
          },
        },
      },
      {
        title: 'should return errors for invalid polymorphic oneOf schema',
        schemas: {
          zod: null, // Zod has no support for `oneOf`
          json: {
            oneOf: [
              { type: 'object', properties: { stringType: { type: 'string' } }, required: ['stringType'] },
              { type: 'object', properties: { numberType: { type: 'number' } }, required: ['numberType'] },
              { type: 'object', properties: { booleanType: { type: 'boolean' } }, required: ['booleanType'] },
            ],
          } as const,
        },
        payload: {
          stringType: '123',
          numberType: 123,
        },
        result: {
          success: false,
          errors: {
            json: [{ message: 'must match exactly one schema in oneOf', path: '' }],
            zod: null, // Zod has no support for `oneOf`
          },
        },
      },
      {
        title: 'should successfully validate a polymorphic allOf schema',
        schemas: {
          zod: null, // Zod has no support for `oneOf`
          json: {
            allOf: [
              { type: 'object', properties: { stringType: { type: 'string' } }, required: ['stringType'] },
              { type: 'object', properties: { numberType: { type: 'number' } }, required: ['numberType'] },
              { type: 'object', properties: { booleanType: { type: 'boolean' } }, required: ['booleanType'] },
            ],
          } as const,
        },
        payload: {
          stringType: '123',
          numberType: 123,
          booleanType: true,
        },
        result: {
          success: true,
          data: {
            stringType: '123',
            numberType: 123,
            booleanType: true,
          },
        },
      },
      {
        title: 'should return errors for invalid polymorphic `allOf` schema',
        schemas: {
          zod: null, // Zod has no support for `allOf`
          json: {
            allOf: [
              { type: 'object', properties: { stringType: { type: 'string' } }, required: ['stringType'] },
              { type: 'object', properties: { numberType: { type: 'number' } }, required: ['numberType'] },
              { type: 'object', properties: { booleanType: { type: 'boolean' } }, required: ['booleanType'] },
            ],
          } as const,
        },
        payload: {
          stringType: '123',
        },
        result: {
          success: false,
          errors: {
            json: [{ message: "must have required property 'numberType'", path: '' }],
            zod: null, // Zod has no support for `allOf`
          },
        },
      },
      {
        title: 'should successfully validate polymorphic `anyOf` properties',
        schemas: {
          zod: z.discriminatedUnion('type', [
            z.object({ type: z.literal('stringType'), stringVal: z.string() }),
            z.object({ type: z.literal('numberType'), numVal: z.number() }),
            z.object({ type: z.literal('booleanType'), boolVal: z.boolean() }),
          ]),
          json: {
            anyOf: [
              {
                type: 'object',
                properties: { type: { type: 'string', const: 'stringType' }, stringVal: { type: 'string' } },
                additionalProperties: false,
                required: ['type', 'stringVal'],
              },
              {
                type: 'object',
                properties: { type: { type: 'string', const: 'numberType' }, numVal: { type: 'number' } },
                additionalProperties: false,
                required: ['type', 'numVal'],
              },
              {
                type: 'object',
                properties: { type: { type: 'string', const: 'booleanType' }, boolVal: { type: 'boolean' } },
                additionalProperties: false,
                required: ['type', 'boolVal'],
              },
            ],
          } as const,
        },
        payload: { type: 'stringType', stringVal: '123' },
        result: {
          success: true,
          data: { type: 'stringType', stringVal: '123' },
        },
      },
      {
        title: 'should return errors for invalid polymorphic `anyOf` properties',
        schemas: {
          zod: z.discriminatedUnion('type', [
            z.object({ type: z.literal('stringType'), stringVal: z.string() }),
            z.object({ type: z.literal('numberType'), numVal: z.number() }),
            z.object({ type: z.literal('booleanType'), boolVal: z.boolean() }),
          ]),
          json: {
            anyOf: [
              {
                type: 'object',
                properties: { type: { type: 'string', const: 'stringType' }, stringVal: { type: 'string' } },
                additionalProperties: false,
                required: ['type', 'stringVal'],
              },
              {
                type: 'object',
                properties: { type: { type: 'string', const: 'numberType' }, numVal: { type: 'number' } },
                additionalProperties: false,
                required: ['type', 'numVal'],
              },
              {
                type: 'object',
                properties: { type: { type: 'string', const: 'booleanType' }, boolVal: { type: 'boolean' } },
                additionalProperties: false,
                required: ['type', 'boolVal'],
              },
            ],
          } as const,
        },
        payload: { type: 'numberType', numVal: '123' },
        result: {
          success: false,
          errors: {
            zod: [{ message: 'Expected number, received string', path: '/numVal' }],
            /*
             * TODO: use discriminator to get the correct error message.
             *
             * The `discriminator` property is only supported in OpenAPI 3.1.
             * https://swagger.io/docs/specification/data-models/inheritance-and-polymorphism/
             *
             * Ajv has added limited support for the `discriminator` keyword, however because it isn't
             * yet part of the JSON Schema standard, we can't rely on it.
             *
             * When using `discriminator`, the error message can be reduced to:
             * { message: 'must be number', path: '/elements/1/numVal' },
             *
             * @see https://ajv.js.org/json-schema.html#discriminator
             */
            json: [
              {
                message: "must have required property 'stringVal'",
                path: '',
              },
              {
                message: 'must be number',
                path: '/numVal',
              },
              {
                message: "must have required property 'boolVal'",
                path: '',
              },
              {
                message: 'must match a schema in anyOf',
                path: '',
              },
            ],
          },
        },
      },
    ];

    schemas.forEach((schema) => {
      describe(`using ${schema}`, () => {
        testCases
          .filter((testCase) => testCase.schemas[schema] !== null)
          .forEach((testCase) => {
            it(testCase.title, async () => {
              const result = await validateData(testCase.schemas[schema] as Schema, testCase.payload);
              expect(result).toEqual({
                success: testCase.result.success,
                data: testCase.result.data,
                errors: testCase.result.errors?.[schema],
              });
            });
          });
      });
    });

    it('should throw an error for invalid schema', async () => {
      const schema = { invalidKey: 'test' } as const;

      // @ts-expect-error - we are testing the type guard
      await expect(validateData(schema, {})).rejects.toThrow('Invalid schema');
    });
  });

  describe('transformSchema', () => {
    type TransformSchemaTestCase = {
      title: string;
      schemas: {
        zod: ZodSchema | null;
        json: JsonSchema;
      };
      result: JsonSchema;
    };
    const testCases: TransformSchemaTestCase[] = [
      {
        title: 'should transform a simple object schema',
        schemas: {
          zod: z.object({ name: z.string(), age: z.number() }),
          json: {
            type: 'object',
            properties: { name: { type: 'string' }, age: { type: 'number' } },
            required: ['name', 'age'],
            additionalProperties: false,
          } as const,
        },
        result: {
          type: 'object',
          properties: { name: { type: 'string' }, age: { type: 'number' } },
          required: ['name', 'age'],
          additionalProperties: false,
        },
      },
      {
        title: 'should transform a nested object schema',
        schemas: {
          zod: z.object({ name: z.string(), nested: z.object({ age: z.number() }) }),
          json: {
            type: 'object',
            properties: {
              name: { type: 'string' },
              nested: {
                type: 'object',
                properties: { age: { type: 'number' } },
                required: ['age'],
                additionalProperties: false,
              },
            },
            required: ['name', 'nested'],
            additionalProperties: false,
          } as const,
        },
        result: {
          type: 'object',
          properties: {
            name: { type: 'string' },
            nested: {
              type: 'object',
              properties: { age: { type: 'number' } },
              required: ['age'],
              additionalProperties: false,
            },
          },
          required: ['name', 'nested'],
          additionalProperties: false,
        },
      },
      {
        title: 'should transform a polymorphic `oneOf` schema',
        schemas: {
          zod: null, // Zod has no support for `oneOf`
          json: {
            oneOf: [
              { type: 'object', properties: { stringType: { type: 'string' } }, required: ['stringType'] },
              { type: 'object', properties: { numberType: { type: 'string' } }, required: ['numberType'] },
              { type: 'object', properties: { booleanType: { type: 'string' } }, required: ['booleanType'] },
            ],
          } as const,
        },
        result: {
          oneOf: [
            { type: 'object', properties: { stringType: { type: 'string' } }, required: ['stringType'] },
            { type: 'object', properties: { numberType: { type: 'string' } }, required: ['numberType'] },
            { type: 'object', properties: { booleanType: { type: 'string' } }, required: ['booleanType'] },
          ],
        },
      },
      {
        title: 'should transform a polymorphic `allOf` schema',
        schemas: {
          zod: null, // Zod has no support for `anyOf`
          json: {
            allOf: [
              { type: 'object', properties: { stringType: { type: 'string' } }, required: ['stringType'] },
              { type: 'object', properties: { numberType: { type: 'string' } }, required: ['numberType'] },
              { type: 'object', properties: { booleanType: { type: 'string' } }, required: ['booleanType'] },
            ],
          } as const,
        },
        result: {
          allOf: [
            { type: 'object', properties: { stringType: { type: 'string' } }, required: ['stringType'] },
            { type: 'object', properties: { numberType: { type: 'string' } }, required: ['numberType'] },
            { type: 'object', properties: { booleanType: { type: 'string' } }, required: ['booleanType'] },
          ],
        },
      },
      {
        title: 'should transform a polymorphic `anyOf` schema',
        schemas: {
          zod: z.object({
            elements: z.array(
              z.discriminatedUnion('type', [
                z.object({ type: z.literal('stringType'), stringVal: z.string() }),
                z.object({ type: z.literal('numberType'), numVal: z.number() }),
                z.object({ type: z.literal('booleanType'), boolVal: z.boolean() }),
              ])
            ),
          }),
          json: {
            type: 'object',
            properties: {
              elements: {
                type: 'array',
                items: {
                  anyOf: [
                    {
                      type: 'object',
                      properties: { type: { type: 'string', const: 'stringType' }, stringVal: { type: 'string' } },
                      additionalProperties: false,
                      required: ['type', 'stringVal'],
                    },
                    {
                      type: 'object',
                      properties: { type: { type: 'string', const: 'numberType' }, numVal: { type: 'number' } },
                      additionalProperties: false,
                      required: ['type', 'numVal'],
                    },
                    {
                      type: 'object',
                      properties: { type: { type: 'string', const: 'booleanType' }, boolVal: { type: 'boolean' } },
                      additionalProperties: false,
                      required: ['type', 'boolVal'],
                    },
                  ],
                },
              },
            },
            additionalProperties: false,
            required: ['elements'],
          } as const,
        },
        result: {
          type: 'object',
          properties: {
            elements: {
              type: 'array',
              items: {
                anyOf: [
                  {
                    type: 'object',
                    properties: { type: { type: 'string', const: 'stringType' }, stringVal: { type: 'string' } },
                    additionalProperties: false,
                    required: ['type', 'stringVal'],
                  },
                  {
                    type: 'object',
                    properties: { type: { type: 'string', const: 'numberType' }, numVal: { type: 'number' } },
                    additionalProperties: false,
                    required: ['type', 'numVal'],
                  },
                  {
                    type: 'object',
                    properties: { type: { type: 'string', const: 'booleanType' }, boolVal: { type: 'boolean' } },
                    additionalProperties: false,
                    required: ['type', 'boolVal'],
                  },
                ],
              },
            },
          },
          additionalProperties: false,
          required: ['elements'],
        },
      },
    ];

    schemas.forEach((schema) => {
      describe(`using ${schema}`, () => {
        testCases
          .filter((testCase) => testCase.schemas[schema] !== null)
          .forEach((testCase) => {
            it(testCase.title, async () => {
              const result = await transformSchema(testCase.schemas[schema] as Schema);
              expect(result).deep.contain(testCase.result);
            });
          });
      });
    });

    it('should throw an error for invalid schema', async () => {
      const schema = { invalidKey: 'test' } as const;

      // @ts-expect-error - we are testing the type guard
      await expect(transformSchema(schema)).rejects.toThrow('Invalid schema');
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - schemas(['zod', 'json'] as const;

describe('validators', ())
 - result(await validateData(testCase.schemas[schema] as Schema, testCase.payload);
              expect(resul...)
 - schema({ invalidKey: 'test' } as const;

      // @ts-expect-error - we are testing the type guard
      aw...)
 - result(await transformSchema(testCase.schemas[schema] as Schema);
              expect(result).deep.contain...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/src/validators/zod.validator.ts
Tamaño: 1786 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ImportRequirement } from '../types/import.types';
import type {
  FromSchema,
  FromSchemaUnvalidated,
  JsonSchema,
  Schema,
  ZodSchema,
  ZodSchemaMinimal,
} from '../types/schema.types';
import type { ValidateResult, Validator } from '../types/validator.types';
import { checkDependencies } from '../utils/import.utils';

export class ZodValidator implements Validator<ZodSchema> {
  readonly requiredImports: readonly ImportRequirement[] = [
    {
      name: 'zod',
      import: import('zod'),
      exports: ['ZodType'],
    },
    {
      name: 'zod-to-json-schema',
      import: import('zod-to-json-schema'),
      exports: ['zodToJsonSchema'],
    },
  ];

  async canHandle(schema: Schema): Promise<boolean> {
    const canHandle = (schema as ZodSchemaMinimal).safeParseAsync !== undefined;

    if (canHandle) {
      await checkDependencies(this.requiredImports, 'Zod schema');
    }

    return canHandle;
  }

  async validate<
    T_Schema extends ZodSchema = ZodSchema,
    T_Unvalidated = FromSchemaUnvalidated<T_Schema>,
    T_Validated = FromSchema<T_Schema>,
  >(data: T_Unvalidated, schema: T_Schema): Promise<ValidateResult<T_Validated>> {
    const result = await schema.safeParseAsync(data);
    if (result.success) {
      return { success: true, data: result.data as T_Validated };
    } else {
      return {
        success: false,
        errors: result.error.errors.map((err) => ({
          path: `/${err.path.join('/')}`,
          message: err.message,
        })),
      };
    }
  }

  async transformToJsonSchema(schema: ZodSchema): Promise<JsonSchema> {
    const { zodToJsonSchema } = await import('zod-to-json-schema');

    // TODO: zod-to-json-schema is not using JSONSchema7
    return zodToJsonSchema(schema) as JsonSchema;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - result(await schema.safeParseAsync(data);
    if (result.success) {
      return { success: true, data: res...)
Declaraciones 'export' encontradas:
- export class ZodValidator

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/framework/sveltekit/package.json
Tamaño: 50 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "main": "../dist/cjs/servers/sveltekit.cjs"
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"main": "../dist/cjs/servers/sveltekit.cjs"
}
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/.gitignore
Tamaño: 16 bytes
Lenguaje detectado: GITIGNORE

### CONTENIDO ORIGINAL ###

index.directcss


### ANALISIS AUTOMATICO (ESPAÑOL) ###

index.directcss
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/CHANGELOG.md
Tamaño: 28466 bytes
Lenguaje detectado: Markdown

### CONTENIDO ORIGINAL ###

## v3.10.1 (2025-09-22)

### 🩹 Fixes

- **js, react:** fix created at date issue ([8af3afee3d](https://github.com/novuhq/novu/commit/8af3afee3d))

### ❤️ Thank You

- Dima Grossman @scopsy

## v3.10.0 (2025-09-22)

### 🚀 Features

- **react, js:** Add preferenceSort support to preferences UI fixes NV-6608 ([#9109](https://github.com/novuhq/novu/pull/9109))
- **dashboard:** allow updating subscribers schedule fixes NV-6617 ([#9118](https://github.com/novuhq/novu/pull/9118))
- **react,js:** default schedule and useSchedule hook fixes NV-6616 ([#9110](https://github.com/novuhq/novu/pull/9110))
- **js:** inbox subscribers schedule fixes NV-6616 ([#9103](https://github.com/novuhq/novu/pull/9103))
- **js, api-service, react:** add permanent delete option for notifications fixes NV-6613 ([#9095](https://github.com/novuhq/novu/pull/9095))
- **js:** schedule sub module fixes NV-6615 ([#9080](https://github.com/novuhq/novu/pull/9080))

### 🩹 Fixes

- **api-service,dashboard,worker:** subscriber schedule bug bashing fixes fixes NV-6691 ([#9167](https://github.com/novuhq/novu/pull/9167))

### ❤️ Thank You

- Dima Grossman @scopsy
- Paweł Tymczuk @LetItRock

## v3.9.3 (2025-09-03)

### 🩹 Fixes

- **js,react:** Fix ui shift for dropdown popover position fixes NV-6493 ([#9057](https://github.com/novuhq/novu/pull/9057))

### ❤️ Thank You

- Dima Grossman @scopsy

## v3.9.2 (2025-09-03)

### 🚀 Features

- **js,react,api-service:** inbox allow filtering preferences by workflow criticality fixes NV-6577 ([#9011](https://github.com/novuhq/novu/pull/9011))

### 🩹 Fixes

- **js:** correct archiveAllRead endpoint URL to match server implementation fixes NV-6612 ([#9052](https://github.com/novuhq/novu/pull/9052))
- **js,react:** re-export types for the react-native package; fix partysocket event target polyfill fixes NV-6448 ([#9036](https://github.com/novuhq/novu/pull/9036))
- **react-native:** expo unable to resolve novu internal module fixes NV-6485 ([#8965](https://github.com/novuhq/novu/pull/8965))

### ❤️ Thank You

- Dima Grossman
- Paweł Tymczuk @LetItRock

## v3.9.1 (2025-08-27)

### 🚀 Features

- **js,react,nextjs:** inbox appearance keys as a callback with the context prop fixes NV-6447 ([#8983](https://github.com/novuhq/novu/pull/8983))
- **js,react:** inbox render props for avatar, default and custom actions fixes NV-6535 ([#8977](https://github.com/novuhq/novu/pull/8977))
- **dashboard:** edited the product onboarding fixes MRK-1000 ([#8945](https://github.com/novuhq/novu/pull/8945))
- **js:** auto-load new notifications on first inbox open fixes NV-5976 ([#8935](https://github.com/novuhq/novu/pull/8935))
- **js,react,api-service,ws:** support severity in inbox components and hooks fixes NV-6470 ([#8913](https://github.com/novuhq/novu/pull/8913))
- **js:** severity support in js sdk fixes NV-6469 ([#8884](https://github.com/novuhq/novu/pull/8884))

### 🩹 Fixes

- **js:** unread dot indicator layout shift fixes NV-6461 ([#8943](https://github.com/novuhq/novu/pull/8943))
- **js:** new notification count in banner with multiple tabs fixes NV-6514 ([#8934](https://github.com/novuhq/novu/pull/8934))

### ❤️ Thank You

- Adam Chmara @ChmaraX
- Emil Pearce @iampearceman
- Paweł Tymczuk @LetItRock

## v3.8.1 (2025-08-13)

### 🚀 Features

- **api,js:** add tx id to inbox notification fixes NV-6457 ([#8907](https://github.com/novuhq/novu/pull/8907))
- **js,react:** useNotifications hook realtime updates fixes NV-5502 ([#8892](https://github.com/novuhq/novu/pull/8892))

### 🩹 Fixes

- **root:** nx release publish issue for syntax error fixes NV-6506 ([#8922](https://github.com/novuhq/novu/pull/8922))

### ❤️ Thank You

- Adam Chmara @ChmaraX
- Himanshu Garg @merrcury

## v3.7.0 (2025-07-22)

### 🚀 Features

- **react,js,api-service:** Add seen status and behaviour to inbox component fixes NV-6179 ([#8704](https://github.com/novuhq/novu/pull/8704))
- **worker,js,react:** subscriber timezone aware delivery fixes NV-6239 ([#8674](https://github.com/novuhq/novu/pull/8674))
- **worker,js:** Durable workers socket management ([#8578](https://github.com/novuhq/novu/pull/8578))
- **react,js,nextjs,react-native:** create new inbox session on subscriber change ([#8417](https://github.com/novuhq/novu/pull/8417))
- **inbox:** backwards compatible inbox keyless ([b6b42a9f43](https://github.com/novuhq/novu/commit/b6b42a9f43))
- **root:** create keyless environment ([#8276](https://github.com/novuhq/novu/pull/8276))
- **api-service:** add data attribute filtering for inbox notifications ([#8338](https://github.com/novuhq/novu/pull/8338))

### 🩹 Fixes

- **root:** bring back eslint and web app build ([#8505](https://github.com/novuhq/novu/pull/8505))
- **js:** increase bottom padding for inbox preferences to prevent footer gradient clickability issues NV-6005 ([#8428](https://github.com/novuhq/novu/pull/8428))
- version bump react packages ([62ff7ee154](https://github.com/novuhq/novu/commit/62ff7ee154))
- **inbox:** change redirect urls for keyless ([d663dfa5bc](https://github.com/novuhq/novu/commit/d663dfa5bc))
- novu react rc 4 release ([b737df7335](https://github.com/novuhq/novu/commit/b737df7335))

### ❤️ Thank You

- Dima Grossman @scopsy
- George Djabarov @djabarovgeorge
- Paweł Tymczuk @LetItRock

## v3.4.0 (2025-05-16)

### 🚀 Features

- **js,react:** inbox preference grouping ([#8310](https://github.com/novuhq/novu/pull/8310))
- **js,react:** inbox and styles under the shadow root ([#8262](https://github.com/novuhq/novu/pull/8262))
- **js:** override icon set for inbox component ([#8293](https://github.com/novuhq/novu/pull/8293))
- **js:** headless bulk update preferences ([#8296](https://github.com/novuhq/novu/pull/8296))

### ❤️ Thank You

- Dima Grossman @scopsy
- Paweł Tymczuk @LetItRock

# v3.3.1 (2025-05-07)

### 🩹 Fixes

- **js:** inbox datepicker dark theme enhancements ([#8260](https://github.com/novuhq/novu/pull/8260))

### ❤️ Thank You

- Adam Chmara @ChmaraX

## v3.3.0 (2025-05-07)

### 🚀 Features

- **js,dashboard:** inbox snooze improvements ([#8251](https://github.com/novuhq/novu/pull/8251))
- **js,api,dashboard:** snooze inbox functionality ([#8228](https://github.com/novuhq/novu/pull/8228))
- **js,react:** add snooze functionality ([#8230](https://github.com/novuhq/novu/pull/8230))
- **repo:** Polish changelogs for packages ([a932bd38e4](https://github.com/novuhq/novu/commit/a932bd38e4))

### 🩹 Fixes

- **js:** Fix appearance elements access bug ([#8213](https://github.com/novuhq/novu/pull/8213))

### ❤️ Thank You

- Adam Chmara @ChmaraX
- George Desipris @desiprisg
- Paweł Tymczuk @LetItRock

## v3.2.0 (2025-04-30)

### 🚀 Features

- **react:** upsert firstName, lastName, and email on session init ([#8142](https://github.com/novuhq/novu/pull/8142))

### ❤️ Thank You

- George Djabarov @djabarovgeorge

## v3.1.0 (2025-04-11)

### 🚀 Features

- **js:** Include CSS in bundle ([#8105](https://github.com/novuhq/novu/pull/8105))

### 🩹 Fixes

- **js,react,nextjs:** Named type exports ([#8084](https://github.com/novuhq/novu/pull/8084))
- **js:** Fix event triggering ([#8102](https://github.com/novuhq/novu/pull/8102))
- **js:** inbox align dropdown icons and labels ([4ceed203f3](https://github.com/novuhq/novu/commit/4ceed203f3))
- **headless:** update Preferences.tsx ([#7928](https://github.com/novuhq/novu/pull/7928))

### ❤️ Thank You

- George Desipris @desiprisg

## v3.0.3 (2025-03-31)

### 🚀 Features

- **root:** add no only github action ([#7692](https://github.com/novuhq/novu/pull/7692))

### 🩹 Fixes

- **api-service:** Remove lock from cached entity 2nd try ([#7979](https://github.com/novuhq/novu/pull/7979))
- **root:** simplify service dependencies in docker-compose.yml ([#7993](https://github.com/novuhq/novu/pull/7993))
- **root:** Stop updating lock-file when releasing new packages ([2107336ae2](https://github.com/novuhq/novu/commit/2107336ae2))
- **api-service:** remove-lock-from-cached-entity ([#7923](https://github.com/novuhq/novu/pull/7923))
- **root:** add NEW_RELIC_ENABLED to docker community ([#7943](https://github.com/novuhq/novu/pull/7943))
- **root:** remove healthcheck option in docker-compose.yml ([#7929](https://github.com/novuhq/novu/pull/7929))
- **js:** inbox align dropdown icons and labels ([4ceed203f3](https://github.com/novuhq/novu/commit/4ceed203f3))
- **headless:** update Preferences.tsx ([#7928](https://github.com/novuhq/novu/pull/7928))
- **api-service:** Remove redlock ([#7845](https://github.com/novuhq/novu/pull/7845))
- **js:** Stop appending / to all fetch requests ([#7922](https://github.com/novuhq/novu/pull/7922))
- **js:** inbox calculation for the cta unread count when multiple tabs ([#7907](https://github.com/novuhq/novu/pull/7907))
- **js:** Fix count context filter ([#7905](https://github.com/novuhq/novu/pull/7905))
- **js:** Fix body color of default notification ([#7904](https://github.com/novuhq/novu/pull/7904))
- **js:** preferences collapsible state ([#7902](https://github.com/novuhq/novu/pull/7902))
- **js:** Fix hidden global preferences ([#7901](https://github.com/novuhq/novu/pull/7901))
- **js:** Generate line heights and adjust actions position ([#7895](https://github.com/novuhq/novu/pull/7895))
- **js:** fix the bell unread dot ([#7887](https://github.com/novuhq/novu/pull/7887))
- **js:** Removing tailwind base styles as they are already under .novu ([#7884](https://github.com/novuhq/novu/pull/7884))
- **js:** Fix infinite scroll behaviour ([#7888](https://github.com/novuhq/novu/pull/7888))
- **js:** Align pref header, hide preferences with 0 channels ([#7878](https://github.com/novuhq/novu/pull/7878))
- **api-service:** fix idices not created in mongo-test ([#7857](https://github.com/novuhq/novu/pull/7857))
- **js:** Fix deprecated JSDoc annotation ([#7873](https://github.com/novuhq/novu/pull/7873))
- **root:** unhandled promise reject and undefined ff kind ([#7732](https://github.com/novuhq/novu/pull/7732))
- **api-service:** remove only on e2e ([#7691](https://github.com/novuhq/novu/pull/7691))

### ❤️ Thank You

- Aaron Ritter @Aaron-Ritter
- Biswajeet Das @BiswaViraj
- GalTidhar @tatarco
- George Desipris @desiprisg
- George Djabarov @djabarovgeorge
- Himanshu Garg @merrcury
- Ikko Eltociear Ashimine
- Pawan Jain
- Paweł
- Paweł Tymczuk @LetItRock
- Sokratis Vidros @SokratisVidros

## 3.0.1 (2025-03-24)

### 🚀 Features

- **js:** create channel per env subscriber ([#7939](https://github.com/novuhq/novu/pull/7939))
- **js,api-service:** inbox dev mode footer ([#7937](https://github.com/novuhq/novu/pull/7937))

### 🩹 Fixes

- **js:** inbox align dropdown icons and labels ([4ceed203f](https://github.com/novuhq/novu/commit/4ceed203f))

### ❤️ Thank You

- Aaron Ritter @Aaron-Ritter
- GalTidhar @tatarco
- George Djabarov @djabarovgeorge
- Pawan Jain
- Paweł
- Paweł Tymczuk @LetItRock
- Sokratis Vidros @SokratisVidros

# 3.0.0 (2025-03-17)

### 🚀 Features

- **js,react:** inbox subject, body render props ([#7886](https://github.com/novuhq/novu/pull/7886))
- **js:** better control over socket connection ([#7865](https://github.com/novuhq/novu/pull/7865))
- **js:** Inbox retheme improvements ([#7867](https://github.com/novuhq/novu/pull/7867))
- **js:** Inbox retheme ([#7759](https://github.com/novuhq/novu/pull/7759))

### 🩹 Fixes

- **headless:** update Preferences.tsx ([#7928](https://github.com/novuhq/novu/pull/7928))
- **js:** Stop appending / to all fetch requests ([#7922](https://github.com/novuhq/novu/pull/7922))
- **js:** inbox calculation for the cta unread count when multiple tabs ([#7907](https://github.com/novuhq/novu/pull/7907))
- **js:** Fix count context filter ([#7905](https://github.com/novuhq/novu/pull/7905))
- **js:** Fix body color of default notification ([#7904](https://github.com/novuhq/novu/pull/7904))
- **js:** preferences collapsible state ([#7902](https://github.com/novuhq/novu/pull/7902))
- **js:** Fix hidden global preferences ([#7901](https://github.com/novuhq/novu/pull/7901))
- **js:** Generate line heights and adjust actions position ([#7895](https://github.com/novuhq/novu/pull/7895))
- **js:** fix the bell unread dot ([#7887](https://github.com/novuhq/novu/pull/7887))
- **js:** Removing tailwind base styles as they are already under .novu ([#7884](https://github.com/novuhq/novu/pull/7884))
- **js:** Fix infinite scroll behaviour ([#7888](https://github.com/novuhq/novu/pull/7888))
- **js:** Align pref header, hide preferences with 0 channels ([#7878](https://github.com/novuhq/novu/pull/7878))
- **js:** Fix deprecated JSDoc annotation ([#7873](https://github.com/novuhq/novu/pull/7873))

### ❤️ Thank You

- GalTidhar @tatarco
- George Desipris @desiprisg
- Ikko Eltociear Ashimine
- Paweł Tymczuk @LetItRock
- Sokratis Vidros @SokratisVidros

## 2.6.6 (2025-02-25)

### 🚀 Features

- **api-service:** system limits & update pricing pages ([#7718](https://github.com/novuhq/novu/pull/7718))
- **root:** add no only github action ([#7692](https://github.com/novuhq/novu/pull/7692))

### 🩹 Fixes

- **root:** unhandled promise reject and undefined ff kind ([#7732](https://github.com/novuhq/novu/pull/7732))
- **api-service:** remove only on e2e ([#7691](https://github.com/novuhq/novu/pull/7691))

### ❤️ Thank You

- GalTidhar @tatarco
- George Djabarov @djabarovgeorge

## 2.6.5 (2025-02-07)

### 🚀 Features

- **js:** add powered by link ([#7680](https://github.com/novuhq/novu/pull/7680))
- Update README.md ([bb63172dd](https://github.com/novuhq/novu/commit/bb63172dd))
- **readme:** Update README.md ([955cbeab0](https://github.com/novuhq/novu/commit/955cbeab0))
- quick start updates readme ([88b3b6628](https://github.com/novuhq/novu/commit/88b3b6628))
- **readme:** update readme ([e5ea61812](https://github.com/novuhq/novu/commit/e5ea61812))
- **api-service:** add internal sdk ([#7599](https://github.com/novuhq/novu/pull/7599))
- **dashboard:** step conditions editor ui ([#7502](https://github.com/novuhq/novu/pull/7502))
- **api:** add query parser ([#7267](https://github.com/novuhq/novu/pull/7267))
- **api:** Nv 5033 additional removal cycle found unneeded elements ([#7283](https://github.com/novuhq/novu/pull/7283))
- **api:** Nv 4966 e2e testing happy path - messages ([#7248](https://github.com/novuhq/novu/pull/7248))
- **dashboard:** Implement email step editor & mini preview ([#7129](https://github.com/novuhq/novu/pull/7129))
- **api:** converted bulk trigger to use SDK ([#7166](https://github.com/novuhq/novu/pull/7166))
- **application-generic:** add SUBSCRIBER_WIDGET_JWT_EXPIRATION_TIME env variable ([#7105](https://github.com/novuhq/novu/pull/7105))

### 🩹 Fixes

- **dashboard,js:** Fix line breaks being ignored ([#7675](https://github.com/novuhq/novu/pull/7675))
- **js:** Await read action in Inbox ([#7653](https://github.com/novuhq/novu/pull/7653))
- **api:** duplicated subscribers created due to race condition ([#7646](https://github.com/novuhq/novu/pull/7646))
- **api-service:** add missing environment variable ([#7553](https://github.com/novuhq/novu/pull/7553))
- **api:** Fix failing API e2e tests ([78c385ec7](https://github.com/novuhq/novu/commit/78c385ec7))
- **api-service:** E2E improvements ([#7461](https://github.com/novuhq/novu/pull/7461))
- **novu:** automatically create indexes on startup ([#7431](https://github.com/novuhq/novu/pull/7431))
- **js:** Inbox DX fixes ([#7396](https://github.com/novuhq/novu/pull/7396))
- **api:** @novu/api -> @novu/api-service ([#7348](https://github.com/novuhq/novu/pull/7348))
- **js:** add missing on click event for dropdown tabs ([#7342](https://github.com/novuhq/novu/pull/7342))
- **js:** Remove @novu/shared dependency" ([#7206](https://github.com/novuhq/novu/pull/7206))
- **js:** Remove @novu/shared dependency ([#6906](https://github.com/novuhq/novu/pull/6906))

### ❤️ Thank You

- Aminul Islam @AminulBD
- Dima Grossman @scopsy
- GalTidhar @tatarco
- George Desipris @desiprisg
- George Djabarov @djabarovgeorge
- Lucky @L-U-C-K-Y
- Pasha
- Pawan Jain
- Paweł Tymczuk @LetItRock
- Sokratis Vidros @SokratisVidros

## 2.6.4 (2024-12-24)

### 🩹 Fixes

- **js:** add missing on click event for dropdown tabs ([#7342](https://github.com/novuhq/novu/pull/7342))
- **js:** Remove @novu/shared dependency" ([#7206](https://github.com/novuhq/novu/pull/7206))
- **js:** Remove @novu/shared dependency ([#6906](https://github.com/novuhq/novu/pull/6906))

### ❤️ Thank You

- Dima Grossman @scopsy
- GalTidhar @tatarco
- George Desipris @desiprisg
- George Djabarov @djabarovgeorge
- Pasha
- Pawan Jain
- Sokratis Vidros @SokratisVidros

## 2.6.3 (2024-11-26)

### 🚀 Features

- **dashboard:** Add test inbox for full E2E test journey ([#7117](https://github.com/novuhq/novu/pull/7117))
- **js:** Popover props ([#7112](https://github.com/novuhq/novu/pull/7112))
- **dashboard:** Codemirror liquid filter support ([#7122](https://github.com/novuhq/novu/pull/7122))
- **root:** add support chat app ID to environment variables in d… ([#7120](https://github.com/novuhq/novu/pull/7120))
- **root:** Add base Dockerfile for GHCR with Node.js and dependencies ([#7100](https://github.com/novuhq/novu/pull/7100))

### 🩹 Fixes

- **js:** Truncate workflow name and center empty notifications text ([#7123](https://github.com/novuhq/novu/pull/7123))
- **api:** Migrate subscriber global preferences before workflow preferences ([#7118](https://github.com/novuhq/novu/pull/7118))
- **api, dal, framework:** fix the uneven and unused dependencies ([#7103](https://github.com/novuhq/novu/pull/7103))

### 🧱 Updated Dependencies

- Updated @novu/client to 2.0.3

### ❤️ Thank You

- Biswajeet Das @BiswaViraj
- George Desipris @desiprisg
- Himanshu Garg @merrcury
- Richard Fontein @rifont

## 2.0.2 (2024-11-19)

### 🚀 Features

- **api:** Delete subscriber channel preference when updating global channel ([#6767](https://github.com/novuhq/novu/pull/6767))
- **framework:** CJS/ESM for framework ([#6707](https://github.com/novuhq/novu/pull/6707))
- **js:** Com 208 improve the dx of the novu on function to return the cleanup ([#6650](https://github.com/novuhq/novu/pull/6650))
- **js:** update icons and add backdrop-filter ([#6629](https://github.com/novuhq/novu/pull/6629))
- **js, react, shared:** user agents ([#6626](https://github.com/novuhq/novu/pull/6626))
- **js:** Com 229 update the in app preview component in the web app to ([#6600](https://github.com/novuhq/novu/pull/6600))
- **api, js, react:** Com 244 hide critical workflow preferences from inbox ([#6574](https://github.com/novuhq/novu/pull/6574))
- **js:** html comment powered by novu ([#6588](https://github.com/novuhq/novu/pull/6588))
- **js,react:** Export InboxContent component ([#6531](https://github.com/novuhq/novu/pull/6531))
- **js:** custom scrollbars ([#6560](https://github.com/novuhq/novu/pull/6560))
- **js,react:** Expose dark theme ([#6530](https://github.com/novuhq/novu/pull/6530))
- **js:** make tooltip smaller ([#6539](https://github.com/novuhq/novu/pull/6539))
- **js,react:** inbox allow filtering preferences by tags ([#6519](https://github.com/novuhq/novu/pull/6519))
- **js:** Add colorShadow variable to appearance ([#6526](https://github.com/novuhq/novu/pull/6526))
- **js:** Popover and collapse animations ([#6506](https://github.com/novuhq/novu/pull/6506))
- **js:** hide branding ([#6513](https://github.com/novuhq/novu/pull/6513))
- **api:** add option to remove Novu branding in the inbox ([#6498](https://github.com/novuhq/novu/pull/6498))
- **js:** Fix events sharing by replacing singleton with DI ([#6454](https://github.com/novuhq/novu/pull/6454))
- **js:** Allow markdown bold syntax for default notification ([#6495](https://github.com/novuhq/novu/pull/6495))
- **js:** hide properties from instances ([#6496](https://github.com/novuhq/novu/pull/6496))
- **react:** Introduce hooks ([#6419](https://github.com/novuhq/novu/pull/6419))
- **js,react:** inbox preferences cache ([#6400](https://github.com/novuhq/novu/pull/6400))
- **framework:** cta support with target ([#6394](https://github.com/novuhq/novu/pull/6394))
- **js:** Revise localization keys DX ([#6380](https://github.com/novuhq/novu/pull/6380))
- **js:** Dynamic localization keys and data-localization attribute ([#6383](https://github.com/novuhq/novu/pull/6383))
- **framework,js:** expose the data property on the in-app step and notification object ([#6391](https://github.com/novuhq/novu/pull/6391))
- **js:** Pixel perfect implementation ([#6360](https://github.com/novuhq/novu/pull/6360))
- **js:** Improve perceived loading state ([#6379](https://github.com/novuhq/novu/pull/6379))
- **js:** Com 159 disable updating preferences for critical worklows ([#6347](https://github.com/novuhq/novu/pull/6347))
- **js:** Include headers and tabs in separate components ([#6323](https://github.com/novuhq/novu/pull/6323))
- **js:** Use render props universally with a single argument ([#6341](https://github.com/novuhq/novu/pull/6341))
- **js:** Recalculate notification date each minute ([#6320](https://github.com/novuhq/novu/pull/6320))
- **js:** Add a bell emoji as separator for targetable classes ([#6297](https://github.com/novuhq/novu/pull/6297))
- **js:** inbox load css with the link element in header ([#6269](https://github.com/novuhq/novu/pull/6269))
- **react:** readme ([#6272](https://github.com/novuhq/novu/pull/6272))
- **js:** Com 123 implement the new notifications cta handler ([#6267](https://github.com/novuhq/novu/pull/6267))
- **js:** New notifications notice ([#6223](https://github.com/novuhq/novu/pull/6223))
- **js:** date formatting and absolute actions ([#6257](https://github.com/novuhq/novu/pull/6257))
- **js:** inbox sdk manage pagination state in cache ([#6206](https://github.com/novuhq/novu/pull/6206))
- **react:** Com 40 create the novureact package ([#6167](https://github.com/novuhq/novu/pull/6167))
- **js:** Com 111 refactor naming settings to preferences ([#6183](https://github.com/novuhq/novu/pull/6183))
- **js:** inbox tabs ([#6149](https://github.com/novuhq/novu/pull/6149))
- **js:** Introduce a Tooltip primitive ([#6189](https://github.com/novuhq/novu/pull/6189))
- **js:** inbox support multiple counts for the provided filters ([#6159](https://github.com/novuhq/novu/pull/6159))
- **js:** Default notification component ([#6163](https://github.com/novuhq/novu/pull/6163))
- **js:** Com 95 add preferences method to sdk and UI ([#6117](https://github.com/novuhq/novu/pull/6117))
- **js:** Improve style() functionality ([#6170](https://github.com/novuhq/novu/pull/6170))
- **js:** Implement the renderNotification prop ([#6125](https://github.com/novuhq/novu/pull/6125))
- **js:** inbox - single websocket connection across tabs ([#6099](https://github.com/novuhq/novu/pull/6099))
- **js:** Notification list ([#6002](https://github.com/novuhq/novu/pull/6002))
- **js:** Com 82 implement filters on sdk ([#6060](https://github.com/novuhq/novu/pull/6060))
- **js:** Button variants, asChild on Popover ([#6057](https://github.com/novuhq/novu/pull/6057))
- **js:** Auto apply generic appearance keys via style() ([#6041](https://github.com/novuhq/novu/pull/6041))
- **root:** Fix JS build and introduce playground applications ([#5988](https://github.com/novuhq/novu/pull/5988))
- **js:** Enforce appearance keys ([#5984](https://github.com/novuhq/novu/pull/5984))
- **js:** Create component renderer ([#5953](https://github.com/novuhq/novu/pull/5953))
- **js:** Introduce baseTheme prop and theme merging ([#5851](https://github.com/novuhq/novu/pull/5851))
- **js:** Flatten localization prop type ([#5858](https://github.com/novuhq/novu/pull/5858))
- **js:** Localization infra ([#5822](https://github.com/novuhq/novu/pull/5822))
- **js:** Scope variables under class of id ([#5820](https://github.com/novuhq/novu/pull/5820))
- **js:** Introduce UI ([#5746](https://github.com/novuhq/novu/pull/5746))
- **api:** inbox - the new get notifications endpoint ([#5792](https://github.com/novuhq/novu/pull/5792))
- **api:** the new inbox controller ([#5735](https://github.com/novuhq/novu/pull/5735))
- **js:** handling the web socket connection and events ([#5704](https://github.com/novuhq/novu/pull/5704))
- **js:** js sdk preferences ([#5701](https://github.com/novuhq/novu/pull/5701))
- **js:** js sdk feeds module ([#5688](https://github.com/novuhq/novu/pull/5688))
- **js:** lazy session initialization and interface fixes ([#5665](https://github.com/novuhq/novu/pull/5665))
- **js:** the base js sdk package scaffolding ([#5654](https://github.com/novuhq/novu/pull/5654))

### 🩹 Fixes

- **js:** build types ([#6732](https://github.com/novuhq/novu/pull/6732))
- **js:** Bypass cache during novu.notifications.list() ([#6690](https://github.com/novuhq/novu/pull/6690))
- **js:** Stabilize JS build process ([#6695](https://github.com/novuhq/novu/pull/6695))
- **js:** incorrect date ([#6641](https://github.com/novuhq/novu/pull/6641))
- **js:** Com 246 the notification mark as actions appears to be under the text content ([#6593](https://github.com/novuhq/novu/pull/6593))
- **root:** Build only public packages during preview deployments ([#6590](https://github.com/novuhq/novu/pull/6590))
- **js:** not allowed cursor when disabled ([#6565](https://github.com/novuhq/novu/pull/6565))
- **js:** add elements from basetheme ([#6558](https://github.com/novuhq/novu/pull/6558))
- **js:** css where ([#6550](https://github.com/novuhq/novu/pull/6550))
- **js:** preference row ([#6545](https://github.com/novuhq/novu/pull/6545))
- **js:** icon alignment ([#6538](https://github.com/novuhq/novu/pull/6538))
- **js:** Com 234 improve spacing for time and subject text in notifications ([#6534](https://github.com/novuhq/novu/pull/6534))
- **js:** add mising () ([#6524](https://github.com/novuhq/novu/pull/6524))
- **js:** Com 228 fix state persistence issue for global workflow preferences ([#6509](https://github.com/novuhq/novu/pull/6509))
- **js:** Fix notification skeleton padding and action wrap ([#6481](https://github.com/novuhq/novu/pull/6481))
- **js:** Don't render subject as bold ([#6505](https://github.com/novuhq/novu/pull/6505))
- **js:** fixed the optimistic update value for the complete and revert actions ([#6473](https://github.com/novuhq/novu/pull/6473))
- **js,react:** inbox support custom navigate function for the relative redirect urls ([#6444](https://github.com/novuhq/novu/pull/6444))
- **js:** Fix action blinking on default notification ([#6448](https://github.com/novuhq/novu/pull/6448))
- **js:** show the new messages pill when there are more than x notifications ([#6395](https://github.com/novuhq/novu/pull/6395))
- **js:** inbox notifications component gets remounting when render notification prop changes ([#6429](https://github.com/novuhq/novu/pull/6429))
- **api,js:** inbox api send workflow identifier ([#6402](https://github.com/novuhq/novu/pull/6402))
- **js,react:** inbox custom bell unread count not updating ([#6362](https://github.com/novuhq/novu/pull/6362))
- **js:** Add a minimum height to notification list ([#6298](https://github.com/novuhq/novu/pull/6298))
- **js:** call counts if tabs exists ([#6287](https://github.com/novuhq/novu/pull/6287))
- **js:** show loading when changing filters ([#6277](https://github.com/novuhq/novu/pull/6277))
- **js:** button padding and preferences response ([#6274](https://github.com/novuhq/novu/pull/6274))
- **js:** Set inbox width top level ([#6194](https://github.com/novuhq/novu/pull/6194))
- **js:** Fix checkmark for selected value and localize text ([#6104](https://github.com/novuhq/novu/pull/6104))
- **js:** Scope inbox notification status context ([#6080](https://github.com/novuhq/novu/pull/6080))
- **js:** Fix build types ([#6064](https://github.com/novuhq/novu/pull/6064))
- **js:** Popover focus trap and dismissal ([#6049](https://github.com/novuhq/novu/pull/6049))
- **js:** Fix portal default props ([#6000](https://github.com/novuhq/novu/pull/6000))
- **js:** Export NovuUI from ui directory only ([#5998](https://github.com/novuhq/novu/pull/5998))
- **js:** Use key prefix instead of id for alpha shades ([#5890](https://github.com/novuhq/novu/pull/5890))

### ❤️ Thank You

- Adam Chmara
- Biswajeet Das @BiswaViraj
- George Desipris @desiprisg
- Paweł Tymczuk @LetItRock
- Richard Fontein @rifont
- Sokratis Vidros @SokratisVidros


### ANALISIS AUTOMATICO (ESPAÑOL) ###

## v3.10.1 (2025-09-22)
### 🩹 Fixes
- **js, react:** fix created at date issue ([8af3afee3d](https://github.com/novuhq/novu/commit/8af3afee3d))
### ❤️ Thank You
## v3.10.0 (2025-09-22)
### 🚀 Features
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/README.md
Tamaño: 2247 bytes
Lenguaje detectado: Markdown

### CONTENIDO ORIGINAL ###

# Novu's JavaScript SDK

The `@novu/js` package provides a JavaScript SDK for building custom inbox notification experiences.
The package provides a low-level API for interacting with the Novu platform In-App notifications.

## Installation

Install `@novu/js` npm package in your app

```bash
npm install @novu/js
```

## Getting Started

Add the below code in your application

```ts
import { Novu } from '@novu/js';

const novu = new Novu({
  applicationIdentifier: 'YOUR_NOVU_APPLICATION_IDENTIFIER',
  subscriber: 'YOUR_INTERNAL_SUBSCRIBER_ID',
});

const { data: notifications, error } = await novu.notifications.list();
```

|| Info: you can find the `applicationIdentifier` in the Novu dashboard under the API keys page.

## HMAC Encryption

When HMAC encryption is enabled in your Novu environment, you need to provide both `subscriberHash` and optionally `contextHash` to secure your requests.

### Subscriber HMAC

Generate a subscriber hash on your backend:

```ts
import { createHmac } from 'crypto';

const subscriberHash = createHmac('sha256', process.env.NOVU_API_KEY)
  .update(subscriberId)
  .digest('hex');
```

Pass it to the Novu instance:

```ts
const novu = new Novu({
  applicationIdentifier: 'YOUR_NOVU_APPLICATION_IDENTIFIER',
  subscriber: 'SUBSCRIBER_ID',
  subscriberHash: 'SUBSCRIBER_HASH_VALUE',
});
```

### Context HMAC (Optional)

If you're using the `context` option to pass additional data, generate a context hash on your backend:

```ts
import { createHmac } from 'crypto';
import { canonicalize } from '@tufjs/canonical-json';

const context = { tenant: 'acme', app: 'dashboard' };
const contextHash = createHmac('sha256', process.env.NOVU_API_KEY)
  .update(canonicalize(context))
  .digest('hex');
```

Pass both context and contextHash to the Novu instance:

```ts
const novu = new Novu({
  applicationIdentifier: 'YOUR_NOVU_APPLICATION_IDENTIFIER',
  subscriber: 'SUBSCRIBER_ID',
  subscriberHash: 'SUBSCRIBER_HASH_VALUE',
  context: { tenant: 'acme', app: 'dashboard' },
  contextHash: 'CONTEXT_HASH_VALUE',
});
```

> Note: When HMAC encryption is enabled and `context` is provided, the `contextHash` is required. The hash is order-independent, so `{a:1, b:2}` produces the same hash as `{b:2, a:1}`.


### ANALISIS AUTOMATICO (ESPAÑOL) ###

# Novu's JavaScript SDK
The `@novu/js` package provides a JavaScript SDK for building custom inbox notification experiences.
The package provides a low-level API for interacting with the Novu platform In-App notifications.
## Installation
## Getting Started
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/jest.config.cjs
Tamaño: 191 bytes
Lenguaje detectado: CJS

### CONTENIDO ORIGINAL ###

module.exports = {
  preset: 'ts-jest',
  setupFiles: ['./jest.setup.ts'],
  globals: {
    NOVU_API_VERSION: '2024-06-26',
    PACKAGE_NAME: '@novu/js',
    PACKAGE_VERSION: 'test',
  },
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

module.exports = {
preset: 'ts-jest',
setupFiles: ['./jest.setup.ts'],
globals: {
NOVU_API_VERSION: '2024-06-26',
Contiene 'require' o 'module.exports' (posible Node.js).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/jest.setup.ts
Tamaño: 0 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###



### ANALISIS AUTOMATICO (ESPAÑOL) ###

No se detectaron funciones/exportaciones con heurística JS/TS.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/package.cjs.json
Tamaño: 25 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "type": "commonjs"
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"type": "commonjs"
}
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/package.esm.json
Tamaño: 23 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "type": "module"
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"type": "module"
}
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/package.json
Tamaño: 4132 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "name": "@novu/js",
  "version": "3.10.1",
  "repository": "https://github.com/novuhq/novu",
  "description": "Novu JavaScript SDK for <Inbox />",
  "author": "",
  "license": "ISC",
  "main": "dist/cjs/index.js",
  "module": "dist/esm/index.mjs",
  "types": "dist/cjs/index.d.ts",
  "exports": {
    ".": {
      "import": {
        "types": "./dist/esm/index.d.mts",
        "default": "./dist/esm/index.mjs"
      },
      "require": {
        "types": "./dist/cjs/index.d.ts",
        "default": "./dist/cjs/index.js"
      }
    },
    "./ui": {
      "import": {
        "types": "./dist/esm/ui/index.d.mts",
        "default": "./dist/esm/ui/index.mjs"
      },
      "require": {
        "types": "./dist/cjs/ui/index.d.ts",
        "default": "./dist/cjs/ui/index.js"
      }
    },
    "./themes": {
      "import": {
        "types": "./dist/esm/themes/index.d.mts",
        "default": "./dist/esm/themes/index.mjs"
      },
      "require": {
        "types": "./dist/cjs/themes/index.d.ts",
        "default": "./dist/cjs/themes/index.js"
      }
    },
    "./internal": {
      "import": {
        "types": "./dist/esm/internal/index.d.mts",
        "default": "./dist/esm/internal/index.mjs"
      },
      "require": {
        "types": "./dist/cjs/internal/index.d.ts",
        "default": "./dist/cjs/internal/index.js"
      }
    }
  },
  "files": [
    "dist/cjs",
    "dist/esm",
    "dist/index.css",
    "dist/novu.min.js",
    "dist/novu.min.js.gz",
    "ui/**/*",
    "themes/**/*",
    "internal/**/*"
  ],
  "sideEffects": false,
  "private": false,
  "publishConfig": {
    "access": "public"
  },
  "scripts": {
    "clean": "rimraf ./dist",
    "start:server": "http-server ./dist -p 4010",
    "prebuild": "cp ./src/ui/index.css ./src/ui/index.directcss",
    "build": "pnpm run clean && NODE_ENV=production tsup",
    "postbuild": "rm ./src/ui/index.directcss && ./scripts/copy-package-json.sh && node scripts/size-limit.mjs && pnpm run check-exports",
    "build:umd": "webpack --config webpack.config.cjs",
    "build:watch": "concurrently \"pnpm run prebuild\" \"NODE_ENV=development pnpm run tsup:watch\" \"pnpm run start:server\"",
    "tsup:watch": "tsup --watch --onSuccess 'tsup --dts-only'",
    "check-exports": "attw --pack .",
    "check": "biome check .",
    "check:fix": "biome check --write .",
    "test": "jest",
    "publish:rc": "pnpm publish --tag rc"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "@arethetypeswrong/cli": "^0.17.4",
    "@types/jest": "^29.2.3",
    "@types/node": "^20.15.0",
    "autoprefixer": "^10.4.0",
    "bytes-iec": "^3.1.1",
    "chalk": "^5.3.0",
    "compression-webpack-plugin": "^10.0.0",
    "concurrently": "^5.3.0",
    "cssnano": "^7.0.4",
    "esbuild-plugin-compress": "^1.0.1",
    "esbuild-plugin-inline-import": "^1.0.4",
    "esbuild-plugin-solid": "^0.6.0",
    "http-server": "^0.13.0",
    "jest": "^29.3.1",
    "postcss": "^8.4.38",
    "postcss-load-config": "^6.0.1",
    "postcss-prefix-selector": "^1.16.1",
    "postcss-preset-env": "^9.5.14",
    "solid-devtools": "^0.29.2",
    "tailwindcss": "^3.4.4",
    "tailwindcss-animate": "^1.0.7",
    "terser-webpack-plugin": "^5.3.9",
    "tiny-glob": "^0.2.9",
    "ts-jest": "^29.0.3",
    "ts-loader": "~9.4.0",
    "tsup": "^8.1.0",
    "tsup-preset-solid": "^2.2.0",
    "typescript": "5.6.2",
    "webpack": "^5.74.0",
    "webpack-bundle-analyzer": "^4.9.0",
    "webpack-cli": "^5.1.4"
  },
  "dependencies": {
    "@floating-ui/dom": "^1.6.13",
    "@kobalte/core": "^0.13.10",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "event-target-polyfill": "^0.0.4",
    "mitt": "^3.0.1",
    "partysocket": "^1.1.4",
    "socket.io-client": "4.7.2",
    "solid-floating-ui": "^0.3.1",
    "solid-js": "^1.9.4",
    "solid-motionone": "^1.0.3",
    "tailwind-merge": "^2.4.0"
  },
  "nx": {
    "tags": [
      "type:package"
    ]
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"name": "@novu/js",
"version": "3.10.1",
"repository": "https://github.com/novuhq/novu",
"description": "Novu JavaScript SDK for <Inbox />",
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/postcss.config.js
Tamaño: 130 bytes
Lenguaje detectado: JavaScript

### CONTENIDO ORIGINAL ###

module.exports = {
  plugins: {
    autoprefixer: {},
    tailwindcss: {},
    cssnano: {
      preset: 'default',
    },
  },
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

No se detectaron funciones/exportaciones con heurística JS/TS.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/project.json
Tamaño: 444 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "name": "@novu/js",
  "sourceRoot": "packages/js/src",
  "projectType": "library",
  "targets": {
    "lint": {
      "executor": "nx:run-commands",
      "options": {
        "command": "npx biome lint packages/js"
      }
    },
    "nx-release-publish": {
      "executor": "nx:run-commands",
      "options": {
        "command": "cd packages/js && pnpm publish --access public --no-git-checks ${NX_PUBLISH_ARGS:-}"
      }
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"name": "@novu/js",
"sourceRoot": "packages/js/src",
"projectType": "library",
"targets": {
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/tailwind.config.js
Tamaño: 4851 bytes
Lenguaje detectado: JavaScript

### CONTENIDO ORIGINAL ###

function defaultColor(baseName) {
  return `var(--${baseName})`;
}

function generateColorShades(baseName) {
  return {
    25: `var(--${baseName}-25)`,
    50: `var(--${baseName}-50)`,
    100: `var(--${baseName}-100)`,
    200: `var(--${baseName}-200)`,
    300: `var(--${baseName}-300)`,
    400: `var(--${baseName}-400)`,
    500: `var(--${baseName}-500)`,
    600: `var(--${baseName}-600)`,
    700: `var(--${baseName}-700)`,
    800: `var(--${baseName}-800)`,
    900: `var(--${baseName}-900)`,
  };
}

/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ['./src/**/*.{js,jsx,ts,tsx}'],
  prefix: 'nt-',
  corePlugins: {
    preflight: false,
  },
  theme: {
    extend: {
      colors: {
        primary: { DEFAULT: defaultColor('nv-color-primary'), ...generateColorShades('nv-color-primary') },
        'primary-alpha': generateColorShades('nv-color-primary-alpha'),
        'primary-foreground': defaultColor('nv-color-primary-foreground'),
        'primary-foreground-alpha': generateColorShades('nv-color-primary-foreground-alpha'),
        secondary: { DEFAULT: defaultColor('nv-color-secondary'), ...generateColorShades('nv-color-secondary') },
        'secondary-alpha': generateColorShades('nv-color-secondary-alpha'),
        'secondary-foreground': defaultColor('nv-color-secondary-foreground'),
        'secondary-foreground-alpha': generateColorShades('nv-color-secondary-foreground-alpha'),
        counter: { DEFAULT: defaultColor('nv-color-counter'), ...generateColorShades('nv-color-counter') },
        'counter-foreground': defaultColor('nv-color-counter-foreground'),
        'counter-foreground-alpha': generateColorShades('nv-color-accent-foreground-alpha'),
        background: defaultColor('nv-color-background'),
        'background-alpha': generateColorShades('nv-color-background-alpha'),
        foreground: defaultColor('nv-color-foreground'),
        'foreground-alpha': generateColorShades('nv-color-foreground-alpha'),
        'neutral-alpha': generateColorShades('nv-color-neutral-alpha'),
        shadow: defaultColor('nv-color-shadow'),
        ring: defaultColor('nv-color-ring'),
        stripes: defaultColor('nv-color-stripes'),
        border: defaultColor('nv-color-neutral-alpha-100'),
        'severity-high': defaultColor('nv-color-severity-high'),
        'severity-high-alpha': generateColorShades('nv-color-severity-high-alpha'),
        'severity-medium': defaultColor('nv-color-severity-medium'),
        'severity-medium-alpha': generateColorShades('nv-color-severity-medium-alpha'),
        'severity-low': defaultColor('nv-color-severity-low'),
        'severity-low-alpha': generateColorShades('nv-color-severity-low-alpha'),
      },
      borderRadius: {
        none: 'var(--nv-radius-none)',
        sm: 'var(--nv-radius-sm)',
        DEFAULT: 'var(--nv-radius-base)',
        md: 'var(--nv-radius-md)',
        lg: 'var(--nv-radius-lg)',
        xl: 'var(--nv-radius-xl)',
        '2xl': 'var(--nv-radius-2xl)',
        full: 'var(--nv-radius-full)',
      },
      boxShadow: {
        popover:
          '0px 8px 26px 0px oklch(from var(--nv-color-shadow) l c h / 0.08), 0px 2px 6px 0px oklch(from var(--nv-color-shadow) l c h / 0.12)',
        dropdown:
          '0px 12px 16px -4px oklch(from var(--nv-color-shadow) l c h / 0.08), 0px 4px 6px -2px oklch(from var(--nv-color-shadow) l c h / 0.03)',
        tooltip: '0 5px 20px 0 oklch(from var(--nv-color-shadow) l c h / 0.08)',
      },
      fontSize: {
        xs: ['var(--nv-font-size-xs)', { lineHeight: 'var(--nv-line-height-xs)' }],
        sm: ['var(--nv-font-size-sm)', { lineHeight: 'var(--nv-line-height-sm)' }],
        base: ['var(--nv-font-size-base)', { lineHeight: 'var(--nv-line-height-base)' }],
        lg: ['var(--nv-font-size-lg)', { lineHeight: 'var(--nv-line-height-lg)' }],
        xl: ['var(--nv-font-size-xl)', { lineHeight: 'var(--nv-line-height-xl)' }],
        '2xl': ['var(--nv-font-size-2xl)', { lineHeight: 'var(--nv-line-height-2xl)' }],
        '3xl': ['var(--nv-font-size-3xl)', { lineHeight: 'var(--nv-line-height-3xl)' }],
        '4xl': ['var(--nv-font-size-4xl)', { lineHeight: 'var(--nv-line-height-4xl)' }],
      },
      backgroundImage: {
        'dev-stripes-gradient':
          'repeating-linear-gradient(135deg, oklch(from var(--nv-color-stripes) l c h / 0.1) 25%, oklch(from var(--nv-color-stripes) l c h / 0.1) 50%, oklch(from var(--nv-color-stripes) l c h / 0.2) 50%, oklch(from var(--nv-color-stripes) l c h / 0.2) 75%)',
      },
      animation: {
        stripes: 'stripes 1s linear infinite paused',
      },
      keyframes: {
        stripes: {
          '0%': { transform: 'translateX(0)' },
          '100%': { transform: 'translateX(calc(var(--stripes-size) * -1))' },
        },
      },
    },
  },
  plugins: [require('tailwindcss-animate')],
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - defaultColor(baseName)
 - generateColorShades(baseName)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/test-sdk.ts
Tamaño: 351 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/* cspell:disable */
import { Novu } from './src';

const test = async () => {
  const novu = new Novu({
    applicationIdentifier: 'i2Xc50K5Apnf',
    subscriberId: '6447afe9d89122e250412c10',
    backendUrl: 'http://localhost:3000',
  });

  const { data: notifications } = await novu.notifications.list();
  console.log(notifications);
};

test();


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - test(async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/tsconfig.cjs.json
Tamaño: 116 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "CommonJS",
    "outDir": "./dist/cjs"
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"extends": "./tsconfig.json",
"compilerOptions": {
"module": "CommonJS",
"outDir": "./dist/cjs"
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/tsconfig.json
Tamaño: 621 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "strict": true,
    "target": "ES6",
    "module": "ESNext",
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "jsx": "preserve",
    "jsxImportSource": "solid-js",
    "baseUrl": ".",
    "outDir": "./dist/esm",
    "emitDecoratorMetadata": false,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "typeRoots": ["./node_modules/@types"],
    "sourceMap": true,
    "declaration": true,
    "declarationMap": true,
    "removeComments": false
  },
  "include": ["src/**/*", "src/**/*.d.ts"],
  "exclude": ["node_modules", "**/node_modules/*"]
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"extends": "../../tsconfig.json",
"compilerOptions": {
"strict": true,
"target": "ES6",
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/tsup.config.ts
Tamaño: 3126 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { execSync } from 'child_process';
import { compress } from 'esbuild-plugin-compress';
import inlineImportPlugin from 'esbuild-plugin-inline-import';
import { solidPlugin } from 'esbuild-plugin-solid';
import fs from 'fs';
import path from 'path';
import postcss from 'postcss';
import loadPostcssConfig from 'postcss-load-config';
import { defineConfig, Options } from 'tsup';
import { name, version } from './package.json';

const processCSS = async (css: string, filePath: string) => {
  const { plugins, options } = await loadPostcssConfig({}, filePath);
  const result = await postcss(plugins).process(css, { ...options, from: filePath });

  return result.css;
};

const buildCSS = async () => {
  const cssFilePath = path.join(__dirname, './src/ui/index.css');
  const destinationCssFilePath = path.join(__dirname, './dist/index.css');
  const css = fs.readFileSync(cssFilePath, 'utf-8');
  const processedCss = await processCSS(css, cssFilePath);
  fs.writeFileSync(destinationCssFilePath, processedCss);
};

const isProd = process.env.NODE_ENV === 'production';
const isPreview = process.env.IS_PREVIEW === 'true';

let previewLastCommitHash: string | undefined; // Default value
if (isPreview) {
  try {
    previewLastCommitHash = execSync('git rev-parse HEAD').toString().trim();
  } catch (error) {
    console.error('Error getting commit hash:', error);
    // Optionally re-throw or handle as needed.
  }
}

const baseConfig: Options = {
  splitting: true,
  sourcemap: false,
  clean: true,
  esbuildPlugins: [
    inlineImportPlugin({
      filter: /^directcss:/,
      transform: async (contents, args) => {
        const processedCss = processCSS(contents, args.path);

        return processedCss;
      },
    }),
    solidPlugin(),
  ],
};

const baseModuleConfig: Options = {
  ...baseConfig,
  treeshake: true,
  dts: true,
  entry: {
    index: './src/index.ts',
    'ui/index': './src/ui/index.ts',
    'themes/index': './src/ui/themes/index.ts',
    'internal/index': './src/ui/internal/index.ts',
  },
  define: {
    NOVU_API_VERSION: `"2024-06-26"`,
    PACKAGE_NAME: `"${name}"`,
    PACKAGE_VERSION: `"${version}"`,
    __DEV__: `${isProd ? false : true}`,
    __PREVIEW_LAST_COMMIT_HASH__: `"${previewLastCommitHash || ''}"`,
  },
};

export default defineConfig((config: Options) => {
  const cjs: Options = {
    ...baseModuleConfig,
    format: 'cjs',
    outDir: 'dist/cjs',
    tsconfig: 'tsconfig.cjs.json',
  };

  const esm: Options = {
    ...baseModuleConfig,
    format: 'esm',
    outDir: 'dist/esm',
    tsconfig: 'tsconfig.json',
  };

  const umd: Options = {
    ...baseConfig,
    entry: { novu: 'src/umd.ts' },
    format: ['iife'],
    minify: true,
    dts: false,
    outExtension: () => {
      return {
        js: '.min.js',
      };
    },
    esbuildPlugins: [
      ...(baseConfig.esbuildPlugins ? baseConfig.esbuildPlugins : []),
      compress({
        gzip: true,
        brotli: false,
        outputDir: '.',
        exclude: ['**/*.map'],
      }),
    ],
    onSuccess: async () => {
      await buildCSS();
    },
  };

  return [cjs, esm, umd];
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - processCSS(async (css: string, filePath: string))
 - buildCSS(async ())
 - Options({
  splitting: true,
  sourcemap: false,
  clean: true,
  esbuildPlugins: [
    inlineImportPlugin({...)
 - Options({
  ...baseConfig,
  treeshake: true,
  dts: true,
  entry: {
    index: './src/index.ts',
    'ui/i...)
 - Options({
    ...baseConfig,
    entry: { novu: 'src/umd.ts' },
    format: ['iife'],
    minify: true,
    ...)
Declaraciones 'export' encontradas:
- export default  defineConfig

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/webpack.config.cjs
Tamaño: 1331 bytes
Lenguaje detectado: CJS

### CONTENIDO ORIGINAL ###

const path = require('path');
const webpack = require('webpack');
const CompressionPlugin = require('compression-webpack-plugin');
const TerserPlugin = require('terser-webpack-plugin');
const { name, version } = require('./package.json');
// const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;

const isProd = process.env?.NODE_ENV === 'production';

module.exports = {
  entry: './src/umd.ts',
  mode: 'production',
  devtool: 'hidden-source-map',
  resolve: {
    extensions: ['.ts', '.js'],
  },
  output: {
    library: 'NotificationCenterWebComponent',
    libraryTarget: 'umd',
    filename: 'novu.min.js',
    path: path.resolve(__dirname, 'dist'),
  },
  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          compress: true,
          sourceMap: false,
        },
      }),
    ],
  },
  module: {
    rules: [
      {
        test: /\.tsx?$/,
        use: 'ts-loader',
        exclude: /node_modules/,
      },
    ],
  },
  plugins: [
    new webpack.DefinePlugin({
      PACKAGE_NAME: `"${name}"`,
      PACKAGE_VERSION: `"${version}"`,
      __DEV__: `${!isProd}`,
    }),
    new CompressionPlugin({
      test: /\.js(\?.*)?$/i,
      threshold: 10240,
      minRatio: 0.6,
    }),
    // new BundleAnalyzerPlugin(),
  ],
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

const path = require('path');
const webpack = require('webpack');
const CompressionPlugin = require('compression-webpack-plugin');
const TerserPlugin = require('terser-webpack-plugin');
const { name, version } = require('./package.json');
// const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
Contiene 'require' o 'module.exports' (posible Node.js).
Menciona package.json.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/.vscode/settings.json
Tamaño: 143 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "typescript.preferences.importModuleSpecifier": "relative",
  "editor.codeActionsOnSave": {
    "source.organizeImports": "explicit"
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"typescript.preferences.importModuleSpecifier": "relative",
"editor.codeActionsOnSave": {
"source.organizeImports": "explicit"
}
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/internal/package.json
Tamaño: 137 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "main": "../dist/cjs/internal/index.js",
  "module": "../dist/esm/internal/index.mjs",
  "types": "../dist/cjs/internal/index.d.ts"
}

### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"main": "../dist/cjs/internal/index.js",
"module": "../dist/esm/internal/index.mjs",
"types": "../dist/cjs/internal/index.d.ts"
}
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/scripts/copy-package-json.sh
Tamaño: 104 bytes
Lenguaje detectado: Shell

### CONTENIDO ORIGINAL ###

#!/bin/sh

cp ./package.cjs.json ./dist/cjs/package.json 
cp ./package.esm.json ./dist/esm/package.json


### ANALISIS AUTOMATICO (ESPAÑOL) ###

#!/bin/sh
cp ./package.cjs.json ./dist/cjs/package.json
cp ./package.esm.json ./dist/esm/package.json
Menciona package.json.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/scripts/size-limit.mjs
Tamaño: 1807 bytes
Lenguaje detectado: MJS

### CONTENIDO ORIGINAL ###

import bytes from 'bytes-iec';
import chalk from 'chalk';
import fs from 'fs/promises';
import path from 'path';

const baseDir = process.cwd();
const umdPath = path.resolve(baseDir, './dist/novu.min.js');
const umdGzipPath = path.resolve(baseDir, './dist/novu.min.js.gz');

const formatBytes = (size) => {
  return bytes.format(size, { unitSeparator: ' ' });
};

const modules = [
  {
    name: 'UMD minified',
    filePath: umdPath,
    limitInBytes: 175_000,
  },
  {
    name: 'UMD gzip',
    filePath: umdGzipPath,
    limitInBytes: 52_000,
  },
];

const checkFiles = async () => {
  const result = [];
  for (const module of modules) {
    const { name, filePath, limitInBytes } = module;
    const stats = await fs.stat(filePath);
    const passed = stats.size <= limitInBytes;
    result.push({ name, passed, size: formatBytes(stats.size), limit: formatBytes(limitInBytes) });
  }

  return result;
};

const calculateSizes = async () => {
  console.log(chalk.gray('🚧 Checking the build dist files...\n'));

  const checks = await checkFiles();
  const anyFailed = checks.some((check) => !check.passed);

  checks.forEach((check) => {
    const { name, passed, size, limit } = check;

    if (!passed) {
      console.log(chalk.yellow(`The ${name} file has failed the size limit.`));
      console.log(chalk.yellow(`Current size is "${size}" and the limit is "${limit}".\n`));
    } else {
      console.log(chalk.green(`The ${name} file has passed the size limit.`));
      console.log(chalk.green(`Current size is "${size}" and the limit is "${limit}".\n`));
    }
  });

  if (anyFailed) {
    console.log(chalk.bold.red('\nThe build has reached the dist files size limits! 🚨\n'));

    process.exit(1);
  } else {
    console.log(chalk.green('All good! 🙌'));
  }
};

calculateSizes();


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import bytes from 'bytes-iec';
import chalk from 'chalk';
import fs from 'fs/promises';
import path from 'path';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/base-module.test.ts
Tamaño: 2300 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { InboxService } from './api';
import { BaseModule } from './base-module';
import { NovuEventEmitter } from './event-emitter';

beforeAll(() => jest.spyOn(global, 'fetch'));
afterAll(() => jest.restoreAllMocks());

describe('callWithSession(fn)', () => {
  test('should invoke callback function immediately if session is initialized', async () => {
    const emitter = new NovuEventEmitter();
    const bm = new BaseModule({
      inboxServiceInstance: {
        isSessionInitialized: true,
      } as InboxService,
      eventEmitterInstance: emitter,
    });

    const cb = jest.fn();
    bm.callWithSession(cb);
    expect(cb).toHaveBeenCalled();
  });

  test('should invoke callback function as soon as session is initialized', async () => {
    const emitter = new NovuEventEmitter();
    const bm = new BaseModule({
      inboxServiceInstance: {} as InboxService,
      eventEmitterInstance: emitter,
    });

    const cb = jest.fn();

    bm.callWithSession(cb);
    expect(cb).not.toHaveBeenCalled();

    emitter.emit('session.initialize.resolved', {
      args: {
        applicationIdentifier: 'foo',
        subscriber: {
          subscriberId: 'bar',
        },
      },
      data: {
        token: 'cafebabe',
        totalUnreadCount: 10,
        unreadCount: {
          severity: {
            high: 1,
            medium: 2,
            low: 3,
            none: 4,
          },
          total: 10,
        },
        removeNovuBranding: true,
        isDevelopmentMode: true,
        maxSnoozeDurationHours: 24,
      },
    });

    expect(cb).toHaveBeenCalled();
  });

  test('should return an error if session initialization failed', async () => {
    const emitter = new NovuEventEmitter();
    const bm = new BaseModule({
      inboxServiceInstance: {} as InboxService,
      eventEmitterInstance: emitter,
    });

    emitter.emit('session.initialize.resolved', {
      args: {
        applicationIdentifier: 'foo',
        subscriber: {
          subscriberId: 'bar',
        },
      },
      error: new Error('Failed to initialize session'),
    });

    const cb = jest.fn();
    const result = await bm.callWithSession(cb);
    expect(result).toEqual({
      error: new Error('Failed to initialize session, please contact the support'),
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - cb(jest.fn();
    bm.callWithSession(cb);
    expect(cb).toHaveBeenCalled();
  });

  test('should invo...)
 - cb(jest.fn();

    bm.callWithSession(cb);
    expect(cb).not.toHaveBeenCalled();

    emitter.emit('se...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/base-module.ts
Tamaño: 1885 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { InboxService } from './api';
import { NovuEventEmitter } from './event-emitter';
import { Result, Session } from './types';
import { NovuError } from './utils/errors';

interface CallQueueItem {
  fn: () => Promise<unknown>;
  resolve: (value: any | PromiseLike<any>) => void;
  reject: (reason?: unknown) => void;
}

export class BaseModule {
  protected _inboxService: InboxService;
  protected _emitter: NovuEventEmitter;
  #callsQueue: CallQueueItem[] = [];
  #sessionError: unknown;

  constructor({
    inboxServiceInstance,
    eventEmitterInstance,
  }: {
    inboxServiceInstance: InboxService;
    eventEmitterInstance: NovuEventEmitter;
  }) {
    this._emitter = eventEmitterInstance;
    this._inboxService = inboxServiceInstance;
    this._emitter.on('session.initialize.resolved', ({ error, data }) => {
      if (data) {
        this.onSessionSuccess(data);
        this.#callsQueue.forEach(async ({ fn, resolve }) => {
          resolve(await fn());
        });
        this.#callsQueue = [];
      } else if (error) {
        this.onSessionError(error);
        this.#sessionError = error;
        this.#callsQueue.forEach(({ resolve }) => {
          resolve({ error: new NovuError('Failed to initialize session, please contact the support', error) });
        });
        this.#callsQueue = [];
      }
    });
  }

  protected onSessionSuccess(_: Session): void {}

  protected onSessionError(_: unknown): void {}

  async callWithSession<T>(fn: () => Result<T>): Result<T> {
    if (this._inboxService.isSessionInitialized) {
      return fn();
    }

    if (this.#sessionError) {
      return Promise.resolve({
        error: new NovuError('Failed to initialize session, please contact the support', this.#sessionError),
      });
    }

    return new Promise((resolve, reject) => {
      this.#callsQueue.push({ fn, resolve, reject });
    });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - _inboxService(inboxServiceInstance;
    this._emitter.on('session.initialize.resolved', ({ error, data }))
 - sessionError(error;
        this.#callsQueue.forEach(({ resolve }))
 - callsQueue([];
      }
    });
  }

  protected onSessionSuccess(_: Session): void {}

  protected onSessionErr...)
Declaraciones 'export' encontradas:
- export class BaseModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/global.d.ts
Tamaño: 213 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { Novu } from './novu';

export {};

declare global {
  const NOVU_API_VERSION: string;
  const PACKAGE_NAME: string;
  const PACKAGE_VERSION: string;
  interface Window {
    Novu: typeof Novu;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/index.ts
Tamaño: 762 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export type { EventHandler, Events, SocketEventNames } from './event-emitter';
export { Novu } from './novu';
export {
  ChannelPreference,
  ChannelType,
  Context,
  DaySchedule,
  DefaultSchedule,
  FiltersCountResponse,
  InboxNotification,
  ListNotificationsResponse,
  Notification,
  NotificationFilter,
  NotificationStatus,
  NovuError,
  NovuOptions,
  Preference,
  PreferenceLevel,
  PreferencesResponse,
  Schedule,
  SeverityLevelEnum,
  StandardNovuOptions,
  Subscriber,
  TimeRange,
  UnreadCount,
  WebSocketEvent,
  WeeklySchedule,
  WorkflowCriticalityEnum,
} from './types';
export {
  areSeveritiesEqual,
  areTagsEqual,
  checkNotificationDataFilter,
  checkNotificationMatchesFilter,
  isSameFilter,
} from './utils/notification-utils';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/novu.test.ts
Tamaño: 2189 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from './novu';

const mockSessionResponse = { data: { token: 'cafebabe' } };

const mockNotificationsResponse = {
  data: [],
  hasMore: true,
  filter: { tags: [], read: false, archived: false },
};

async function mockFetch(url: string, reqInit: Request) {
  if (url.includes('/session')) {
    return {
      ok: true,
      status: 200,
      json: async () => mockSessionResponse,
    };
  }
  if (url.includes('/notifications')) {
    return {
      ok: true,
      status: 200,
      json: async () => mockNotificationsResponse,
    };
  }
  throw new Error(`Unmocked request: ${url}`);
}

beforeAll(() => jest.spyOn(global, 'fetch'));
afterAll(() => jest.restoreAllMocks());

describe('Novu', () => {
  const applicationIdentifier = 'foo';
  const subscriberId = 'bar';

  beforeEach(() => {
    // @ts-ignore
    global.fetch.mockImplementation(mockFetch) as jest.Mock;
  });

  describe('http client', () => {
    test('should call the notifications.list after the session is initialized', async () => {
      const options = {
        limit: 10,
        offset: 0,
      };

      const novu = new Novu({ applicationIdentifier, subscriberId });
      expect(fetch).toHaveBeenNthCalledWith(1, 'https://api.novu.co/v1/inbox/session', {
        method: 'POST',
        body: JSON.stringify({ applicationIdentifier, subscriber: { subscriberId } }),
        headers: {
          'Content-Type': 'application/json',
          'Novu-API-Version': '2024-06-26',
          'User-Agent': '@novu/js@test',
        },
      });

      const { data } = await novu.notifications.list(options);
      expect(fetch).toHaveBeenNthCalledWith(2, 'https://api.novu.co/v1/inbox/notifications?limit=10', {
        method: 'GET',
        body: undefined,
        headers: {
          Authorization: 'Bearer cafebabe',
          'Content-Type': 'application/json',
          'Novu-API-Version': '2024-06-26',
          'User-Agent': '@novu/js@test',
        },
      });

      expect(data).toEqual({
        notifications: mockNotificationsResponse.data,
        hasMore: mockNotificationsResponse.hasMore,
        filter: mockNotificationsResponse.filter,
      });
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - mockFetch(url: string, reqInit: Request)
Asignaciones con arrow functions encontradas (posibles funciones):
 - mockNotificationsResponse({
  data: [],
  hasMore: true,
  filter: { tags: [], read: false, archived: false },
};

async funct...)
 - subscriberId('bar';

  beforeEach(())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/novu.ts
Tamaño: 4675 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { InboxService } from './api';
import type { EventHandler, EventNames, Events } from './event-emitter';
import { NovuEventEmitter } from './event-emitter';
import { Notifications } from './notifications';
import { Preferences } from './preferences';
import { Session } from './session';
import type { Context, NovuOptions, Subscriber } from './types';
import { buildContextKey, buildSubscriber } from './ui/internal';
import { createSocket } from './ws';
import type { BaseSocketInterface } from './ws/base-socket';

export class Novu implements Pick<NovuEventEmitter, 'on'> {
  #emitter: NovuEventEmitter;
  #session: Session;
  #inboxService: InboxService;

  public readonly notifications: Notifications;
  public readonly preferences: Preferences;
  public readonly socket: BaseSocketInterface;

  public on: <Key extends EventNames>(eventName: Key, listener: EventHandler<Events[Key]>) => () => void;
  /**
   * @deprecated
   * Use the cleanup function returned by the "on" method instead.
   */
  public off: <Key extends EventNames>(eventName: Key, listener: EventHandler<Events[Key]>) => void;

  public get applicationIdentifier() {
    return this.#session.applicationIdentifier;
  }

  public get subscriberId() {
    return this.#session.subscriberId;
  }

  public get context() {
    return this.#session.context;
  }

  public get contextKey() {
    return buildContextKey(this.#session.context);
  }

  constructor(options: NovuOptions) {
    this.#inboxService = new InboxService({
      apiUrl: options.apiUrl || options.backendUrl,
      userAgent: options.__userAgent,
    });
    this.#emitter = new NovuEventEmitter();
    this.#session = new Session(
      {
        applicationIdentifier: options.applicationIdentifier || '',
        subscriberHash: options.subscriberHash,
        subscriber: buildSubscriber({ subscriberId: options.subscriberId, subscriber: options.subscriber }),
        defaultSchedule: options.defaultSchedule,
        context: options.context,
        contextHash: options.contextHash,
      },
      this.#inboxService,
      this.#emitter
    );

    this.#session.initialize();
    this.notifications = new Notifications({
      useCache: options.useCache ?? true,
      inboxServiceInstance: this.#inboxService,
      eventEmitterInstance: this.#emitter,
    });
    this.preferences = new Preferences({
      useCache: options.useCache ?? true,
      inboxServiceInstance: this.#inboxService,
      eventEmitterInstance: this.#emitter,
    });
    this.socket = createSocket({
      socketUrl: options.socketUrl,
      eventEmitterInstance: this.#emitter,
      inboxServiceInstance: this.#inboxService,
    });

    this.on = (eventName, listener) => {
      if (this.socket.isSocketEvent(eventName)) {
        this.socket.connect();
      }

      const cleanup = this.#emitter.on(eventName, listener);

      return () => {
        cleanup();
      };
    };

    this.off = (eventName, listener) => {
      this.#emitter.off(eventName, listener);
    };
  }

  public async changeSubscriber(options: { subscriber: Subscriber; subscriberHash?: string }): Promise<void> {
    await this.#session.initialize({
      applicationIdentifier: this.#session.applicationIdentifier || '',
      subscriberHash: options.subscriberHash,
      subscriber: options.subscriber,
      // Preserve existing context and contextHash
      context: this.#session.context,
      contextHash: this.#session.contextHash,
    });

    // Clear cache and reconnect socket with new token
    this.notifications.cache.clearAll();

    // Disconnect and reconnect socket to use new JWT token
    const disconnectResult = await this.socket.disconnect();
    if (!disconnectResult.error) {
      await this.socket.connect();
    }
  }

  public async changeContext(options: { context: Context; contextHash?: string }): Promise<void> {
    const currentSubscriber = this.#session.subscriber;
    if (!currentSubscriber) {
      throw new Error('Cannot change context without an active subscriber');
    }

    await this.#session.initialize({
      applicationIdentifier: this.#session.applicationIdentifier || '',
      // Preserve existing subscriber and subscriberHash
      subscriberHash: this.#session.subscriberHash,
      subscriber: currentSubscriber,
      context: options.context,
      contextHash: options.contextHash,
    });

    // Clear cache and reconnect socket with new token
    this.notifications.cache.clearAll();

    // Disconnect and reconnect socket to use new JWT token
    const disconnectResult = await this.socket.disconnect();
    if (!disconnectResult.error) {
      await this.socket.connect();
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - on(eventName, listener))
 - cleanup(this.#emitter.on(eventName, listener);

      return ())
 - off(eventName, listener))
Declaraciones 'export' encontradas:
- export class Novu

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/types.ts
Tamaño: 5911 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { NovuError } from './utils/errors';

export type { FiltersCountResponse, ListNotificationsResponse, Notification } from './notifications';
export type { Preference } from './preferences/preference';
export type { Schedule } from './preferences/schedule';
export type { NovuError } from './utils/errors';

declare global {
  /**
   * If you want to provide custom types for the notification.data object,
   * simply redeclare this rule in the global namespace.
   * Every notification object will use the provided type.
   */
  interface NotificationData {
    [k: string]: unknown;
  }
}

export enum NotificationStatus {
  READ = 'read',
  SEEN = 'seen',
  SNOOZED = 'snoozed',
  UNREAD = 'unread',
  UNSEEN = 'unseen',
  UNSNOOZED = 'unsnoozed',
}

export enum NotificationButton {
  PRIMARY = 'primary',
  SECONDARY = 'secondary',
}

export enum NotificationActionStatus {
  PENDING = 'pending',
  DONE = 'done',
}

export enum PreferenceLevel {
  GLOBAL = 'global',
  TEMPLATE = 'template',
}

export enum ChannelType {
  IN_APP = 'in_app',
  EMAIL = 'email',
  SMS = 'sms',
  CHAT = 'chat',
  PUSH = 'push',
}

export enum WebSocketEvent {
  RECEIVED = 'notification_received',
  UNREAD = 'unread_count_changed',
  UNSEEN = 'unseen_count_changed',
}

export enum SocketType {
  SOCKET_IO = 'socket.io',
  PARTY_SOCKET = 'partysocket',
}

export enum SeverityLevelEnum {
  HIGH = 'high',
  MEDIUM = 'medium',
  LOW = 'low',
  NONE = 'none',
}

export enum WorkflowCriticalityEnum {
  CRITICAL = 'critical',
  NON_CRITICAL = 'nonCritical',
  ALL = 'all',
}

export type UnreadCount = {
  total: number;
  severity: Record<SeverityLevelEnum, number>;
};

export type Session = {
  token: string;
  /** @deprecated Use unreadCount.total instead */
  totalUnreadCount: number;
  unreadCount: UnreadCount;
  removeNovuBranding: boolean;
  isDevelopmentMode: boolean;
  maxSnoozeDurationHours: number;
  applicationIdentifier?: string;
  contextKeys?: string[];
};

export type Subscriber = {
  id?: string;
  subscriberId: string;
  firstName?: string;
  lastName?: string;
  email?: string;
  phone?: string;
  avatar?: string;
  locale?: string;
  data?: Record<string, unknown>;
  timezone?: string;
};

export type Redirect = {
  url: string;
  target?: '_self' | '_blank' | '_parent' | '_top' | '_unfencedTop';
};

export enum ActionTypeEnum {
  PRIMARY = 'primary',
  SECONDARY = 'secondary',
}

export type Action = {
  label: string;
  isCompleted: boolean;
  redirect?: Redirect;
};

export type Workflow = {
  id: string;
  identifier: string;
  name: string;
  critical: boolean;
  tags?: string[];
  severity: SeverityLevelEnum;
};

export type InboxNotification = {
  id: string;
  transactionId: string;
  subject?: string;
  body: string;
  to: Subscriber;
  isRead: boolean;
  isSeen: boolean;
  isArchived: boolean;
  isSnoozed: boolean;
  snoozedUntil?: string | null;
  deliveredAt?: string[];
  createdAt: string;
  readAt?: string | null;
  firstSeenAt?: string | null;
  archivedAt?: string | null;
  avatar?: string;
  primaryAction?: Action;
  secondaryAction?: Action;
  channelType: ChannelType;
  tags?: string[];
  data?: NotificationData;
  redirect?: Redirect;
  workflow?: Workflow;
  severity: SeverityLevelEnum;
};

export type NotificationFilter = {
  tags?: string[];
  read?: boolean;
  archived?: boolean;
  snoozed?: boolean;
  seen?: boolean;
  data?: Record<string, unknown>;
  severity?: SeverityLevelEnum | SeverityLevelEnum[];
};

export type ChannelPreference = {
  email?: boolean;
  sms?: boolean;
  in_app?: boolean;
  chat?: boolean;
  push?: boolean;
};

export type PaginatedResponse<T = unknown> = {
  data: T[];
  hasMore: boolean;
  totalCount: number;
  pageSize: number;
  page: number;
};

export type TimeRange = {
  start: string;
  end: string;
};

export type DaySchedule = {
  isEnabled: boolean;
  hours?: Array<TimeRange>;
};

export type WeeklySchedule = {
  monday?: DaySchedule;
  tuesday?: DaySchedule;
  wednesday?: DaySchedule;
  thursday?: DaySchedule;
  friday?: DaySchedule;
  saturday?: DaySchedule;
  sunday?: DaySchedule;
};

export type DefaultSchedule = {
  isEnabled?: boolean;
  weeklySchedule?: WeeklySchedule;
};

export type ContextValue =
  | string
  | {
      id: string;
      data?: Record<string, unknown>;
    };

export type Context = Partial<Record<string, ContextValue>>;

export type PreferencesResponse = {
  level: PreferenceLevel;
  enabled: boolean;
  channels: ChannelPreference;
  overrides?: IPreferenceOverride[];
  workflow?: Workflow;
  schedule?: {
    isEnabled: boolean;
    weeklySchedule?: WeeklySchedule;
  };
};

export enum PreferenceOverrideSourceEnum {
  SUBSCRIBER = 'subscriber',
  TEMPLATE = 'template',
  WORKFLOW_OVERRIDE = 'workflowOverride',
}

export type IPreferenceOverride = {
  channel: ChannelType;
  source: PreferenceOverrideSourceEnum;
};

export type TODO = any;

export type Result<D = undefined, E = NovuError> = Promise<{
  data?: D;
  error?: E;
}>;

type KeylessNovuOptions = {} & { [K in string]?: never }; // empty object,disallows all unknown keys

export type StandardNovuOptions = {
  /** @deprecated Use apiUrl instead  */
  backendUrl?: string;
  /** @internal Should be used internally for testing purposes */
  __userAgent?: string;
  applicationIdentifier: string;
  subscriberHash?: string;
  contextHash?: string;
  apiUrl?: string;
  socketUrl?: string;
  useCache?: boolean;
  defaultSchedule?: DefaultSchedule;
  context?: Context;
} & (
  | {
      // TODO: Backward compatibility support - remove in future versions (see NV-5801)
      /** @deprecated Use subscriber prop instead */
      subscriberId: string;
      subscriber?: never;
    }
  | {
      subscriber: Subscriber | string;
      subscriberId?: never;
    }
);

export type NovuOptions = KeylessNovuOptions | StandardNovuOptions;

export type Prettify<T> = { [K in keyof T]: T[K] } & {};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  enum
- export  enum
- export  enum
- export  enum
- export  enum
- export  enum
- export  enum
- export  enum
- export  enum
- export  type
- export  type
- export  type
- export  type
- export  enum
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  enum
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/umd.ts
Tamaño: 66 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from './novu';

// @ts-ignore
window.Novu = Novu;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

No se detectaron funciones/exportaciones con heurística JS/TS.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/api/http-client.test.ts
Tamaño: 6685 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { HttpClient } from './http-client';

// Mock the global fetch function
const mockFetch = jest.fn();
global.fetch = mockFetch;

describe('HttpClient', () => {
  let httpClient: HttpClient;

  beforeEach(() => {
    httpClient = new HttpClient();
    mockFetch.mockClear();

    // Default mock implementation for fetch
    mockFetch.mockImplementation(async () => {
      return {
        ok: true,
        status: 200,
        json: async () => ({ data: { result: 'success' } }),
      } as Response;
    });
  });

  describe('Constructor', () => {
    it('should use default options when none provided', () => {
      const client = new HttpClient();
      expect((client as any).apiUrl).toBe('https://api.novu.co/v1');
      expect((client as any).apiVersion).toBe('v1');
      expect((client as any).headers['User-Agent']).toBe(`${PACKAGE_NAME}@${PACKAGE_VERSION}`);
    });

    it('should use custom options when provided', () => {
      const client = new HttpClient({
        apiUrl: 'https://custom-api.example.com',
        apiVersion: 'v2',
        userAgent: 'custom-agent',
      });
      expect((client as any).apiUrl).toBe('https://custom-api.example.com/v2');
      expect((client as any).apiVersion).toBe('v2');
      expect((client as any).headers['User-Agent']).toBe('custom-agent');
    });
  });

  describe('setAuthorizationToken', () => {
    it('should set the Authorization header with Bearer token', () => {
      httpClient.setAuthorizationToken('test-token');
      expect((httpClient as any).headers.Authorization).toBe('Bearer test-token');
    });
  });

  describe('setHeaders', () => {
    it('should merge new headers with existing ones', () => {
      const initialContentType = (httpClient as any).headers['Content-Type'];
      httpClient.setHeaders({
        'X-Custom-Header': 'custom-value',
      });

      expect((httpClient as any).headers['Content-Type']).toBe(initialContentType);
      expect((httpClient as any).headers['X-Custom-Header']).toBe('custom-value');
    });
  });

  describe('HTTP methods', () => {
    it('should make a GET request', async () => {
      await httpClient.get('/test-path');

      expect(mockFetch).toHaveBeenCalledTimes(1);
      const [url, options] = mockFetch.mock.calls[0];

      expect(url).toBe('https://api.novu.co/v1/test-path');
      expect(options.method).toBe('GET');
      expect(options.body).toBeUndefined();
    });

    it('should make a GET request with search params', async () => {
      const searchParams = new URLSearchParams({ key: 'value' });
      await httpClient.get('/test-path', searchParams);

      expect(mockFetch).toHaveBeenCalledTimes(1);
      const [url] = mockFetch.mock.calls[0];

      expect(url).toBe('https://api.novu.co/v1/test-path?key=value');
    });

    it('should make a POST request with body', async () => {
      const body = { data: 'test-data' };
      await httpClient.post('/test-path', body);

      expect(mockFetch).toHaveBeenCalledTimes(1);
      const [url, options] = mockFetch.mock.calls[0];

      expect(url).toBe('https://api.novu.co/v1/test-path');
      expect(options.method).toBe('POST');
      expect(options.body).toBe(JSON.stringify(body));
    });

    it('should make a PATCH request with body', async () => {
      const body = { data: 'test-data' };
      await httpClient.patch('/test-path', body);

      expect(mockFetch).toHaveBeenCalledTimes(1);
      const [url, options] = mockFetch.mock.calls[0];

      expect(url).toBe('https://api.novu.co/v1/test-path');
      expect(options.method).toBe('PATCH');
      expect(options.body).toBe(JSON.stringify(body));
    });

    it('should make a DELETE request with body', async () => {
      const body = { id: 'test-id' };
      await httpClient.delete('/test-path', body);

      expect(mockFetch).toHaveBeenCalledTimes(1);
      const [url, options] = mockFetch.mock.calls[0];

      expect(url).toBe('https://api.novu.co/v1/test-path');
      expect(options.method).toBe('DELETE');
      expect(options.body).toBe(JSON.stringify(body));
    });
  });

  describe('response handling', () => {
    it('should unwrap envelope by default', async () => {
      mockFetch.mockImplementationOnce(async () => {
        return {
          ok: true,
          status: 200,
          json: async () => ({ data: { result: 'success' } }),
        } as Response;
      });

      const result = await httpClient.get('/test-path');
      expect(result).toEqual({ result: 'success' });
    });

    it('should return full response when unwrapEnvelope is false', async () => {
      mockFetch.mockImplementationOnce(async () => {
        return {
          ok: true,
          status: 200,
          json: async () => ({ data: { result: 'success' }, meta: { page: 1 } }),
        } as Response;
      });

      const result = await httpClient.get('/test-path', undefined, false);
      expect(result).toEqual({ data: { result: 'success' }, meta: { page: 1 } });
    });

    it('should return undefined for 204 status', async () => {
      mockFetch.mockImplementationOnce(async () => {
        return {
          ok: true,
          status: 204,
          json: async () => ({}),
        } as Response;
      });

      const result = await httpClient.delete('/test-path');
      expect(result).toBeUndefined();
    });

    it('should throw error for non-ok responses', async () => {
      mockFetch.mockImplementationOnce(async () => {
        return {
          ok: false,
          status: 400,
          json: async () => ({ message: 'Bad Request' }),
        } as Response;
      });

      await expect(httpClient.get('/test-path')).rejects.toThrow(
        `${PACKAGE_NAME}@${PACKAGE_VERSION} error. Status: 400, Message: Bad Request`
      );
    });
  });

  describe('URL handling', () => {
    it('should properly append query parameters', async () => {
      const searchParams = new URLSearchParams();
      searchParams.append('limit', '10');
      searchParams.append('filter', 'active');

      await httpClient.get('/test-path', searchParams);

      const [url] = mockFetch.mock.calls[0];
      expect(url).toBe('https://api.novu.co/v1/test-path?limit=10&filter=active');
    });

    it('should handle paths with leading and trailing slashes', async () => {
      await httpClient.get('//test-path//');

      const [url] = mockFetch.mock.calls[0];
      expect(url).toBe('https://api.novu.co/v1/test-path');
    });

    it('should handle empty path segments', async () => {
      await httpClient.get('test-path///nested');

      const [url] = mockFetch.mock.calls[0];
      expect(url).toBe('https://api.novu.co/v1/test-path/nested');
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - fetch(mockFetch;

describe('HttpClient', ())
 - httpClient(new HttpClient();
    mockFetch.mockClear();

    // Default mock implementation for fetch
    mockF...)
 - client(new HttpClient();
      expect((client as any).apiUrl).toBe('https://api.novu.co/v1');
      expect(...)
 - client(new HttpClient({
        apiUrl: 'https://custom-api.example.com',
        apiVersion: 'v2',
       ...)
 - initialContentType(httpClient as any).headers['Content-Type'];
      httpClient.setHeaders({
        'X-Custom-Header':...)
 - key(value');
    });

    it('should make a POST request with body', async ())
 - result(await httpClient.get('/test-path');
      expect(result).toEqual({ result: 'success' });
    });

  ...)
 - result(await httpClient.get('/test-path', undefined, false);
      expect(result).toEqual({ data: { result:...)
 - result(await httpClient.delete('/test-path');
      expect(result).toBeUndefined();
    });

    it('should...)
 - filter(active');
    });

    it('should handle paths with leading and trailing slashes', async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/api/http-client.ts
Tamaño: 4023 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export type HttpClientOptions = {
  apiVersion?: string;
  apiUrl?: string;
  userAgent?: string;
  headers?: Record<string, string>;
};

export const DEFAULT_API_VERSION = 'v1';
const DEFAULT_USER_AGENT = `${PACKAGE_NAME}@${PACKAGE_VERSION}`;

export class HttpClient {
  // Environment variable for local development that overrides the default API endpoint without affecting the Inbox DX
  private DEFAULT_BACKEND_URL =
    (typeof window !== 'undefined' && (window as any).NOVU_LOCAL_BACKEND_URL) || 'https://api.novu.co';

  private apiUrl: string;
  private apiVersion: string;
  private headers: Record<string, string>;

  constructor(options: HttpClientOptions = {}) {
    const {
      apiVersion = DEFAULT_API_VERSION,
      apiUrl = this.DEFAULT_BACKEND_URL,
      userAgent = DEFAULT_USER_AGENT,
      headers = {},
    } = options || {};
    this.apiVersion = apiVersion;
    this.apiUrl = `${apiUrl}/${apiVersion}`;
    this.headers = {
      'Novu-API-Version': NOVU_API_VERSION,
      'Content-Type': 'application/json',
      'User-Agent': userAgent,
      ...headers,
    };
  }

  setAuthorizationToken(token: string) {
    this.headers.Authorization = `Bearer ${token}`;
  }

  setKeylessHeader(identifier?: string) {
    const keylessAppIdentifier =
      identifier ||
      (typeof window !== 'undefined' && window.localStorage?.getItem('novu_keyless_application_identifier'));

    if (!keylessAppIdentifier || !keylessAppIdentifier.startsWith('pk_keyless_')) {
      return;
    }

    this.headers['Novu-Application-Identifier'] = keylessAppIdentifier;
  }

  setHeaders(headers: Record<string, string>) {
    this.headers = {
      ...this.headers,
      ...headers,
    };
  }

  async get<T>(path: string, searchParams?: URLSearchParams, unwrapEnvelope = true) {
    return this.doFetch<T>({
      path,
      searchParams,
      options: {
        method: 'GET',
      },
      unwrapEnvelope,
    });
  }

  async post<T>(path: string, body?: any, options?: RequestInit) {
    return this.doFetch<T>({
      path,
      options: {
        method: 'POST',
        body,
        headers: options?.headers,
      },
    });
  }

  async patch<T>(path: string, body?: any) {
    return this.doFetch<T>({
      path,
      options: {
        method: 'PATCH',
        body,
      },
    });
  }

  async delete<T>(path: string, body?: any) {
    return this.doFetch<T>({
      path,
      options: {
        method: 'DELETE',
        body,
      },
    });
  }

  private async doFetch<T>({
    path,
    searchParams,
    options,
    unwrapEnvelope = true,
  }: {
    path: string;
    searchParams?: URLSearchParams;
    options?: RequestInit;
    unwrapEnvelope?: boolean;
  }) {
    const fullUrl = combineUrl(this.apiUrl, path, searchParams ? `?${searchParams.toString()}` : '');
    const reqInit = {
      method: options?.method || 'GET',
      headers: { ...this.headers, ...(options?.headers || {}) },
      body: options?.body ? JSON.stringify(options.body) : undefined,
    };

    const response = await fetch(fullUrl, reqInit);

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(`${this.headers['User-Agent']} error. Status: ${response.status}, Message: ${errorData.message}`);
    }
    if (response.status === 204) {
      return undefined as unknown as T;
    }

    const res = await response.json();

    return (unwrapEnvelope ? res.data : res) as Promise<T>;
  }
}

function combineUrl(...args: string[]): string {
  return (
    args
      .reduce<string[]>((acc, part) => {
        if (part) {
          /*
           * 1. Replace multiple slashes with a single slash unless they are part of a protocol (http:, https:)
           * 2. Remove leading and trailing slashes
           */
          acc.push(part.replace(/(?<!https?:)\/+/g, '/').replace(/^\/+|\/+$/g, ''));
        }

        return acc;
      }, [])
      .join('/')
      // For search params, replace /foo/?bar=42 with /foo?bar=42
      .replace(/\/\?/, '?')
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - combineUrl(...args: string[])
Asignaciones con arrow functions encontradas (posibles funciones):
 - res(await response.json();

    return (unwrapEnvelope ? res.data : res) as Promise<T>;
  }
}

function ...)
Declaraciones 'export' encontradas:
- export  type
- export  const
- export class HttpClient

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/api/inbox-service.ts
Tamaño: 9172 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type {
  ActionTypeEnum,
  ChannelPreference,
  Context,
  DefaultSchedule,
  InboxNotification,
  NotificationFilter,
  PreferencesResponse,
  Session,
  SeverityLevelEnum,
  Subscriber,
  WeeklySchedule,
  WorkflowCriticalityEnum,
} from '../types';
import { HttpClient, HttpClientOptions } from './http-client';

export type InboxServiceOptions = HttpClientOptions;

const INBOX_ROUTE = '/inbox';
const INBOX_NOTIFICATIONS_ROUTE = `${INBOX_ROUTE}/notifications`;

export class InboxService {
  isSessionInitialized = false;
  #httpClient: HttpClient;

  constructor(options: InboxServiceOptions = {}) {
    this.#httpClient = new HttpClient(options);
  }

  async initializeSession({
    applicationIdentifier,
    subscriberHash,
    contextHash,
    subscriber,
    defaultSchedule,
    context,
  }: {
    applicationIdentifier?: string;
    subscriberHash?: string;
    contextHash?: string;
    subscriber?: Subscriber;
    defaultSchedule?: DefaultSchedule;
    context?: Context;
  }): Promise<Session> {
    const response = (await this.#httpClient.post(`${INBOX_ROUTE}/session`, {
      applicationIdentifier,
      subscriberHash,
      contextHash,
      subscriber,
      defaultSchedule,
      context,
    })) as Session;
    this.#httpClient.setAuthorizationToken(response.token);
    this.#httpClient.setKeylessHeader(response.applicationIdentifier);
    this.isSessionInitialized = true;

    return response;
  }

  fetchNotifications({
    after,
    archived,
    limit = 10,
    offset,
    read,
    tags,
    snoozed,
    seen,
    data,
    severity,
  }: {
    tags?: string[];
    read?: boolean;
    archived?: boolean;
    snoozed?: boolean;
    seen?: boolean;
    limit?: number;
    after?: string;
    offset?: number;
    data?: Record<string, unknown>;
    severity?: SeverityLevelEnum | SeverityLevelEnum[];
  }): Promise<{ data: InboxNotification[]; hasMore: boolean; filter: NotificationFilter }> {
    const searchParams = new URLSearchParams(`limit=${limit}`);
    if (after) {
      searchParams.append('after', after);
    }
    if (offset) {
      searchParams.append('offset', `${offset}`);
    }
    if (tags) {
      for (const tag of tags) {
        searchParams.append('tags[]', tag);
      }
    }
    if (read !== undefined) {
      searchParams.append('read', `${read}`);
    }
    if (archived !== undefined) {
      searchParams.append('archived', `${archived}`);
    }
    if (snoozed !== undefined) {
      searchParams.append('snoozed', `${snoozed}`);
    }
    if (seen !== undefined) {
      searchParams.append('seen', `${seen}`);
    }
    if (data !== undefined) {
      searchParams.append('data', JSON.stringify(data));
    }
    if (severity && Array.isArray(severity)) {
      for (const el of severity) {
        searchParams.append('severity[]', el);
      }
    } else if (severity) {
      searchParams.append('severity', severity);
    }

    return this.#httpClient.get(INBOX_NOTIFICATIONS_ROUTE, searchParams, false);
  }

  count({
    filters,
  }: {
    filters: Array<{
      tags?: string[];
      read?: boolean;
      archived?: boolean;
      snoozed?: boolean;
      seen?: boolean;
      data?: Record<string, unknown>;
      severity?: SeverityLevelEnum | SeverityLevelEnum[];
    }>;
  }): Promise<{
    data: Array<{
      count: number;
      filter: NotificationFilter;
    }>;
  }> {
    return this.#httpClient.get(
      `${INBOX_NOTIFICATIONS_ROUTE}/count`,
      new URLSearchParams({
        filters: JSON.stringify(filters),
      }),
      false
    );
  }

  read(notificationId: string): Promise<InboxNotification> {
    return this.#httpClient.patch(`${INBOX_NOTIFICATIONS_ROUTE}/${notificationId}/read`);
  }

  unread(notificationId: string): Promise<InboxNotification> {
    return this.#httpClient.patch(`${INBOX_NOTIFICATIONS_ROUTE}/${notificationId}/unread`);
  }

  archive(notificationId: string): Promise<InboxNotification> {
    return this.#httpClient.patch(`${INBOX_NOTIFICATIONS_ROUTE}/${notificationId}/archive`);
  }

  unarchive(notificationId: string): Promise<InboxNotification> {
    return this.#httpClient.patch(`${INBOX_NOTIFICATIONS_ROUTE}/${notificationId}/unarchive`);
  }

  snooze(notificationId: string, snoozeUntil: string): Promise<InboxNotification> {
    return this.#httpClient.patch(`${INBOX_NOTIFICATIONS_ROUTE}/${notificationId}/snooze`, { snoozeUntil });
  }

  unsnooze(notificationId: string): Promise<InboxNotification> {
    return this.#httpClient.patch(`${INBOX_NOTIFICATIONS_ROUTE}/${notificationId}/unsnooze`);
  }

  readAll({ tags, data }: { tags?: string[]; data?: Record<string, unknown> }): Promise<void> {
    return this.#httpClient.post(`${INBOX_NOTIFICATIONS_ROUTE}/read`, {
      tags,
      data: data ? JSON.stringify(data) : undefined,
    });
  }

  archiveAll({ tags, data }: { tags?: string[]; data?: Record<string, unknown> }): Promise<void> {
    return this.#httpClient.post(`${INBOX_NOTIFICATIONS_ROUTE}/archive`, {
      tags,
      data: data ? JSON.stringify(data) : undefined,
    });
  }

  archiveAllRead({ tags, data }: { tags?: string[]; data?: Record<string, unknown> }): Promise<void> {
    return this.#httpClient.post(`${INBOX_NOTIFICATIONS_ROUTE}/read-archive`, {
      tags,
      data: data ? JSON.stringify(data) : undefined,
    });
  }

  delete(notificationId: string): Promise<void> {
    return this.#httpClient.delete(`${INBOX_NOTIFICATIONS_ROUTE}/${notificationId}/delete`);
  }

  deleteAll({ tags, data }: { tags?: string[]; data?: Record<string, unknown> }): Promise<void> {
    return this.#httpClient.post(`${INBOX_NOTIFICATIONS_ROUTE}/delete`, {
      tags,
      data: data ? JSON.stringify(data) : undefined,
    });
  }

  markAsSeen({
    notificationIds,
    tags,
    data,
  }: {
    notificationIds?: string[];
    tags?: string[];
    data?: Record<string, unknown>;
  }): Promise<void> {
    return this.#httpClient.post(`${INBOX_NOTIFICATIONS_ROUTE}/seen`, {
      notificationIds,
      tags,
      data: data ? JSON.stringify(data) : undefined,
    });
  }

  seen(notificationId: string): Promise<void> {
    return this.markAsSeen({ notificationIds: [notificationId] });
  }

  completeAction({
    actionType,
    notificationId,
  }: {
    notificationId: string;
    actionType: ActionTypeEnum;
  }): Promise<InboxNotification> {
    return this.#httpClient.patch(`${INBOX_NOTIFICATIONS_ROUTE}/${notificationId}/complete`, {
      actionType,
    });
  }

  revertAction({
    actionType,
    notificationId,
  }: {
    notificationId: string;
    actionType: ActionTypeEnum;
  }): Promise<InboxNotification> {
    return this.#httpClient.patch(`${INBOX_NOTIFICATIONS_ROUTE}/${notificationId}/revert`, {
      actionType,
    });
  }

  fetchPreferences({
    tags,
    severity,
    criticality,
  }: {
    tags?: string[];
    severity?: SeverityLevelEnum | SeverityLevelEnum[];
    criticality: WorkflowCriticalityEnum;
  }): Promise<PreferencesResponse[]> {
    const queryParams = new URLSearchParams();
    if (tags) {
      for (const tag of tags) {
        queryParams.append('tags[]', tag);
      }
    }
    if (severity && Array.isArray(severity)) {
      for (const el of severity) {
        queryParams.append('severity[]', el);
      }
    } else if (severity) {
      queryParams.append('severity', severity);
    }
    if (criticality) {
      queryParams.append('criticality', criticality);
    }

    const query = queryParams.size ? `?${queryParams.toString()}` : '';

    return this.#httpClient.get(`${INBOX_ROUTE}/preferences${query}`);
  }

  bulkUpdatePreferences(
    preferences: Array<
      {
        workflowId: string;
      } & ChannelPreference
    >
  ): Promise<PreferencesResponse[]> {
    return this.#httpClient.patch(`${INBOX_ROUTE}/preferences/bulk`, { preferences });
  }

  updateGlobalPreferences(
    preferences: ChannelPreference & {
      schedule?: {
        isEnabled?: boolean;
        weeklySchedule?: WeeklySchedule;
      };
    }
  ): Promise<PreferencesResponse> {
    return this.#httpClient.patch(`${INBOX_ROUTE}/preferences`, preferences);
  }

  updateWorkflowPreferences({
    workflowId,
    channels,
  }: {
    workflowId: string;
    channels: ChannelPreference;
  }): Promise<PreferencesResponse> {
    return this.#httpClient.patch(`${INBOX_ROUTE}/preferences/${workflowId}`, channels);
  }

  fetchGlobalPreferences(): Promise<PreferencesResponse> {
    return this.#httpClient.get(`${INBOX_ROUTE}/preferences/global`);
  }

  triggerHelloWorldEvent(): Promise<unknown> {
    const payload = {
      name: 'hello-world',
      to: {
        subscriberId: 'keyless-subscriber-id',
      },
      payload: {
        subject: 'Novu Keyless Environment',
        body: "You're using a keyless demo environment. For full access to Novu features and cloud integration, obtain your API key.",
        primaryActionText: 'Obtain API Key',
        primaryActionUrl: 'https://go.novu.co/keyless',
        secondaryActionText: 'Explore Documentation',
        secondaryActionUrl: 'https://go.novu.co/keyless-docs',
      },
    };

    return this.#httpClient.post('/inbox/events', payload);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export class InboxService

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/api/index.ts
Tamaño: 64 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './http-client';
export * from './inbox-service';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/cache/in-memory-cache.ts
Tamaño: 652 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { Cache } from './types';

export class InMemoryCache<T> implements Cache<T> {
  #cache: Map<string, T>;

  constructor() {
    this.#cache = new Map();
  }

  get(key: string): T | undefined {
    return this.#cache.get(key);
  }

  getValues(): T[] {
    return Array.from(this.#cache.values());
  }

  entries(): [string, T][] {
    return Array.from(this.#cache.entries());
  }

  keys(): string[] {
    return Array.from(this.#cache.keys());
  }

  set(key: string, value: T): void {
    this.#cache.set(key, value);
  }

  remove(key: string): void {
    this.#cache.delete(key);
  }

  clear(): void {
    this.#cache.clear();
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class InMemoryCache

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/cache/index.ts
Tamaño: 60 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export { NotificationsCache } from './notifications-cache';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/cache/notifications-cache.test.ts
Tamaño: 16422 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { InboxService } from '../api';
import { NovuEventEmitter } from '../event-emitter';
import { ListNotificationsArgs, ListNotificationsResponse, Notification } from '../notifications';
import { ChannelType, SeverityLevelEnum } from '../types';
import { NotificationsCache } from './notifications-cache';

describe('NotificationsCache', () => {
  let notificationsCache: NotificationsCache;
  let mockEmitter: NovuEventEmitter;
  let mockInboxService: InboxService;
  let notification1: Notification;
  let notification2: Notification;

  beforeEach(() => {
    mockEmitter = {
      on: jest.fn(),
      emit: jest.fn(),
    } as unknown as NovuEventEmitter;

    mockInboxService = {
      fetchNotifications: jest.fn(),
    } as unknown as InboxService;
    notificationsCache = new NotificationsCache({
      emitter: mockEmitter,
    });

    notification1 = new Notification(
      {
        id: '1',
        transactionId: 'tx-1',
        body: 'test1',
        isRead: false,
        isArchived: false,
        isSeen: false,
        isSnoozed: false,
        to: { id: '1', subscriberId: '1' },
        createdAt: new Date().toISOString(),
        channelType: ChannelType.IN_APP,
        workflow: {
          id: 'test-workflow-1',
          critical: true,
          identifier: 'test-workflow-1',
          name: 'Test Workflow 1',
          tags: ['tag1'],
          severity: SeverityLevelEnum.NONE,
        },
        severity: SeverityLevelEnum.NONE,
      },
      mockEmitter,
      mockInboxService
    );
    notification2 = new Notification(
      {
        id: '2',
        transactionId: 'tx-2',
        body: 'test2',
        isRead: false,
        isSeen: false,
        isArchived: false,
        isSnoozed: false,
        to: { id: '2', subscriberId: '2' },
        createdAt: new Date().toISOString(),
        channelType: ChannelType.IN_APP,
        workflow: {
          id: 'test-workflow-2',
          critical: false,
          identifier: 'test-workflow-2',
          name: 'Test Workflow 2',
          tags: ['tag1'],
          severity: SeverityLevelEnum.NONE,
        },
        severity: SeverityLevelEnum.NONE,
      },
      mockEmitter,
      mockInboxService
    );
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('should set and get notifications from the cache', () => {
    const args = { tags: ['tag1'], limit: 10, offset: 0 };
    const data = {
      hasMore: false,
      filter: {},
      notifications: [notification1],
    };

    notificationsCache.set(args, data);
    const result = notificationsCache.getAll(args);

    expect(result).toEqual(data);
  });

  it('should clear specific filter from the cache', () => {
    const args = { tags: ['tag1'], limit: 10, offset: 0 };
    const data = {
      hasMore: false,
      filter: {},
      notifications: [notification1],
    };
    notificationsCache.set(args, data);

    const filter = { tags: args.tags };
    notificationsCache.clear(filter);

    const result = notificationsCache.getAll(args);
    expect(result).toBeUndefined();
  });

  it('should clear specific filter from the cache but leave the others', () => {
    const args1 = { tags: ['tag1'], limit: 10, offset: 0 };
    const args2 = { tags: ['newsletter'], limit: 10, offset: 0 };
    const data = {
      hasMore: false,
      filter: {},
      notifications: [notification1],
    };
    notificationsCache.set(args1, data);
    notificationsCache.set(args2, data);

    const filter = { tags: args1.tags };
    notificationsCache.clear(filter);

    const result1 = notificationsCache.getAll(args1);
    expect(result1).toBeUndefined();
    const result2 = notificationsCache.getAll(args2);
    expect(result2).toEqual(data);
  });

  it('should clear all caches', () => {
    const args1 = { tags: ['tag1'], limit: 10, offset: 0 };
    const args2 = { tags: ['newsletter'], limit: 10, offset: 0 };
    const data = {
      hasMore: false,
      filter: {},
      notifications: [notification1],
    };
    notificationsCache.set(args1, data);
    notificationsCache.set(args2, data);

    notificationsCache.clearAll();

    const result1 = notificationsCache.getAll(args1);
    expect(result1).toBeUndefined();
    const result2 = notificationsCache.getAll(args2);
    expect(result2).toBeUndefined();
  });

  it('should get unique notifications based on tags', () => {
    const args1 = { tags: ['tag1'], limit: 10, offset: 0 };
    const data1: ListNotificationsResponse = {
      hasMore: false,
      filter: {},
      notifications: [notification1],
    };

    const args2 = { tags: ['tag1'], limit: 10, offset: 1 };
    const data2: ListNotificationsResponse = {
      hasMore: false,
      filter: {},
      notifications: [notification2],
    };

    const args3 = { tags: ['tag2'], limit: 10, offset: 1 };
    const data3: ListNotificationsResponse = {
      hasMore: false,
      filter: {},
      notifications: [notification2],
    };

    notificationsCache.set(args1, data1);
    notificationsCache.set(args2, data2);
    notificationsCache.set(args3, data3);

    const result = notificationsCache.getUniqueNotifications({ tags: ['tag1'] });
    expect(result).toEqual([notification1, notification2]);
  });

  it('should get unique read notifications based on tags', () => {
    const updated1 = new Notification({ ...notification1, isRead: true }, mockEmitter, mockInboxService);
    const updated2 = new Notification({ ...notification2, isRead: true }, mockEmitter, mockInboxService);
    const updated3 = new Notification({ ...notification2, id: '3' }, mockEmitter, mockInboxService);

    const args1 = { tags: ['tag1'], limit: 10, offset: 0 };
    const data1: ListNotificationsResponse = {
      hasMore: false,
      filter: {},
      notifications: [updated1, updated2],
    };

    const args2 = { tags: ['tag1'], limit: 10, offset: 1 };
    const data2: ListNotificationsResponse = {
      hasMore: false,
      filter: {},
      notifications: [updated3],
    };

    const args3 = { tags: ['tag2'], limit: 10, offset: 0 };
    const data3: ListNotificationsResponse = {
      hasMore: false,
      filter: {},
      notifications: [notification2],
    };

    notificationsCache.set(args1, data1);
    notificationsCache.set(args2, data2);
    notificationsCache.set(args3, data3);

    let result = notificationsCache.getUniqueNotifications({ tags: ['tag1'], read: true });
    expect(result).toEqual([updated1, updated2]);

    result = notificationsCache.getUniqueNotifications({ tags: ['tag2'] });
    expect(result).toEqual([notification2]);
  });

  it('should update notification and emit single event', () => {
    const args: ListNotificationsArgs = { limit: 10, offset: 0, tags: ['tag1'], read: false, archived: false };
    const updatedNotification = new Notification(
      { ...notification1, body: 'Updated Notification' },
      mockEmitter,
      mockInboxService
    );
    const data: ListNotificationsResponse = { hasMore: false, filter: {}, notifications: [notification1] };

    notificationsCache.set(args, data);
    (notificationsCache as any).handleNotificationEvent()({ data: updatedNotification });

    expect(mockEmitter.emit).toHaveBeenCalledWith('notifications.list.updated', {
      data: {
        hasMore: false,
        filter: {},
        notifications: [updatedNotification],
      },
    });
  });

  it('should remove notification and emit single event', () => {
    const args: ListNotificationsArgs = { limit: 10, offset: 0, tags: ['tag1'], read: false, archived: false };
    const updatedNotification = new Notification(
      { ...notification1, body: 'Updated Notification' },
      mockEmitter,
      mockInboxService
    );
    const data: ListNotificationsResponse = { hasMore: false, filter: {}, notifications: [notification1] };

    notificationsCache.set(args, data);
    (notificationsCache as any).handleNotificationEvent({ remove: true })({ data: updatedNotification });

    expect(mockEmitter.emit).toHaveBeenCalledWith('notifications.list.updated', {
      data: {
        hasMore: false,
        filter: {},
        notifications: [],
      },
    });
  });

  it('should update notification for different filters and emit two events', () => {
    const filter1 = { tags: ['tag1'], read: false, archived: false };
    const filter2 = { tags: ['tag2'], read: false, archived: false };
    const args1: ListNotificationsArgs = { limit: 10, offset: 0, ...filter1 };
    const args2: ListNotificationsArgs = { limit: 10, offset: 0, ...filter2 };
    const updatedNotification = new Notification(
      { ...notification1, body: 'Updated Notification' },
      mockEmitter,
      mockInboxService
    );

    notificationsCache.set(args1, { hasMore: false, filter: filter1, notifications: [notification1, notification2] });
    notificationsCache.set(args2, { hasMore: false, filter: filter2, notifications: [notification1, notification2] });
    (notificationsCache as any).handleNotificationEvent()({ data: updatedNotification });

    expect(mockEmitter.emit).toHaveBeenCalledTimes(2);
    expect(mockEmitter.emit).toHaveBeenNthCalledWith(1, 'notifications.list.updated', {
      data: {
        hasMore: false,
        filter: filter1,
        notifications: [updatedNotification, notification2],
      },
    });
    expect(mockEmitter.emit).toHaveBeenNthCalledWith(2, 'notifications.list.updated', {
      data: {
        hasMore: false,
        filter: filter2,
        notifications: [updatedNotification, notification2],
      },
    });
  });

  it('should remove notification for different filters and emit two events', () => {
    const filter1 = { tags: ['tag1'], read: false, archived: false };
    const filter2 = { tags: ['tag2'], read: false, archived: false };
    const args1: ListNotificationsArgs = { limit: 10, offset: 0, ...filter1 };
    const args2: ListNotificationsArgs = { limit: 10, offset: 0, ...filter2 };
    const updatedNotification = new Notification(
      { ...notification1, body: 'Updated Notification' },
      mockEmitter,
      mockInboxService
    );

    notificationsCache.set(args1, { hasMore: false, filter: filter1, notifications: [notification1, notification2] });
    notificationsCache.set(args2, { hasMore: false, filter: filter2, notifications: [notification1, notification2] });
    (notificationsCache as any).handleNotificationEvent({ remove: true })({ data: updatedNotification });

    expect(mockEmitter.emit).toHaveBeenCalledTimes(2);
    expect(mockEmitter.emit).toHaveBeenNthCalledWith(1, 'notifications.list.updated', {
      data: {
        hasMore: false,
        filter: filter1,
        notifications: [notification2],
      },
    });
    expect(mockEmitter.emit).toHaveBeenNthCalledWith(2, 'notifications.list.updated', {
      data: {
        hasMore: false,
        filter: filter2,
        notifications: [notification2],
      },
    });
  });

  it('should update multiple notifications and emit single event', () => {
    const args: ListNotificationsArgs = { limit: 10, offset: 0, tags: ['tag1'], read: false, archived: false };
    const updatedNotification1 = new Notification(
      { ...notification1, body: 'Updated Notification' },
      mockEmitter,
      mockInboxService
    );
    const updatedNotification2 = new Notification(
      { ...notification2, body: 'Updated Notification' },
      mockEmitter,
      mockInboxService
    );
    const data: ListNotificationsResponse = {
      hasMore: false,
      filter: {},
      notifications: [notification1, notification2],
    };

    notificationsCache.set(args, data);
    (notificationsCache as any).handleNotificationEvent()({
      data: [updatedNotification1, updatedNotification2],
    });

    expect(mockEmitter.emit).toHaveBeenCalledWith('notifications.list.updated', {
      data: {
        hasMore: false,
        filter: {},
        notifications: [updatedNotification1, updatedNotification2],
      },
    });
  });

  it('should remove multiple notifications and emit single event', () => {
    const args: ListNotificationsArgs = { limit: 10, offset: 0, tags: ['tag1'], read: false, archived: false };
    const updatedNotification1 = new Notification(
      { ...notification1, body: 'Updated Notification' },
      mockEmitter,
      mockInboxService
    );
    const updatedNotification2 = new Notification(
      { ...notification2, body: 'Updated Notification' },
      mockEmitter,
      mockInboxService
    );
    const notification3 = new Notification({ ...notification1, id: '3' }, mockEmitter, mockInboxService);
    const data: ListNotificationsResponse = {
      hasMore: false,
      filter: {},
      notifications: [notification1, notification2, notification3],
    };

    notificationsCache.set(args, data);
    (notificationsCache as any).handleNotificationEvent({ remove: true })({
      data: [updatedNotification1, updatedNotification2],
    });

    expect(mockEmitter.emit).toHaveBeenCalledWith('notifications.list.updated', {
      data: {
        hasMore: false,
        filter: {},
        notifications: [notification3],
      },
    });
  });

  it('should update multiple notifications for different filters and emit two events', () => {
    const filter1 = { tags: ['tag1'], read: false, archived: false };
    const filter2 = { tags: ['tag2'], read: false, archived: false };
    const args1: ListNotificationsArgs = { limit: 10, offset: 0, ...filter1 };
    const args2: ListNotificationsArgs = { limit: 10, offset: 0, ...filter2 };
    const updatedNotification1 = new Notification(
      { ...notification1, body: 'Updated Notification' },
      mockEmitter,
      mockInboxService
    );
    const updatedNotification2 = new Notification(
      { ...notification2, body: 'Updated Notification' },
      mockEmitter,
      mockInboxService
    );

    notificationsCache.set(args1, {
      hasMore: false,
      filter: filter1,
      notifications: [notification1],
    });
    notificationsCache.set(args2, {
      hasMore: false,
      filter: filter2,
      notifications: [notification2],
    });
    (notificationsCache as any).handleNotificationEvent()({
      data: [updatedNotification1, updatedNotification2],
    });

    expect(mockEmitter.emit).toHaveBeenCalledTimes(2);
    expect(mockEmitter.emit).toHaveBeenNthCalledWith(1, 'notifications.list.updated', {
      data: {
        hasMore: false,
        filter: filter1,
        notifications: [updatedNotification1],
      },
    });
    expect(mockEmitter.emit).toHaveBeenNthCalledWith(2, 'notifications.list.updated', {
      data: {
        hasMore: false,
        filter: filter2,
        notifications: [updatedNotification2],
      },
    });
  });

  it('should remove multiple notifications for different filters and emit two events', () => {
    const filter1 = { tags: ['tag1'], read: false, archived: false };
    const filter2 = { tags: ['tag2'], read: false, archived: false };
    const args1: ListNotificationsArgs = { limit: 10, offset: 0, ...filter1 };
    const args2: ListNotificationsArgs = { limit: 10, offset: 0, ...filter2 };
    const updatedNotification1 = new Notification(
      { ...notification1, body: 'Updated Notification' },
      mockEmitter,
      mockInboxService
    );
    const updatedNotification2 = new Notification(
      { ...notification2, body: 'Updated Notification' },
      mockEmitter,
      mockInboxService
    );
    const notification3 = new Notification({ ...notification1, id: '3' }, mockEmitter, mockInboxService);

    notificationsCache.set(args1, {
      hasMore: false,
      filter: filter1,
      notifications: [notification1, notification3],
    });
    notificationsCache.set(args2, {
      hasMore: false,
      filter: filter2,
      notifications: [notification2, notification3],
    });
    (notificationsCache as any).handleNotificationEvent({ remove: true })({
      data: [updatedNotification1, updatedNotification2],
    });

    expect(mockEmitter.emit).toHaveBeenCalledTimes(2);
    expect(mockEmitter.emit).toHaveBeenNthCalledWith(1, 'notifications.list.updated', {
      data: {
        hasMore: false,
        filter: filter1,
        notifications: [notification3],
      },
    });
    expect(mockEmitter.emit).toHaveBeenNthCalledWith(2, 'notifications.list.updated', {
      data: {
        hasMore: false,
        filter: filter2,
        notifications: [notification3],
      },
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - notification2(new Notification(
      {
        id: '2',
        transactionId: 'tx-2',
        body: 'test2',
   ...)
 - result(notificationsCache.getAll(args);

    expect(result).toEqual(data);
  });

  it('should clear specif...)
 - result(notificationsCache.getAll(args);
    expect(result).toBeUndefined();
  });

  it('should clear speci...)
 - result2(notificationsCache.getAll(args2);
    expect(result2).toEqual(data);
  });

  it('should clear all c...)
 - result2(notificationsCache.getAll(args2);
    expect(result2).toBeUndefined();
  });

  it('should get uniqu...)
 - result(notificationsCache.getUniqueNotifications({ tags: ['tag1'] });
    expect(result).toEqual([notificat...)
 - result(notificationsCache.getUniqueNotifications({ tags: ['tag2'] });
    expect(result).toEqual([notificat...)
 - ListNotificationsResponse({ hasMore: false, filter: {}, notifications: [notification1] };

    notificationsCache.set(args, da...)
 - ListNotificationsResponse({ hasMore: false, filter: {}, notifications: [notification1] };

    notificationsCache.set(args, da...)
 - updatedNotification(new Notification(
      { ...notification1, body: 'Updated Notification' },
      mockEmitter,
     ...)
 - updatedNotification(new Notification(
      { ...notification1, body: 'Updated Notification' },
      mockEmitter,
     ...)
 - ListNotificationsResponse({
      hasMore: false,
      filter: {},
      notifications: [notification1, notification2],
    }...)
 - ListNotificationsResponse({
      hasMore: false,
      filter: {},
      notifications: [notification1, notification2, notifi...)
 - updatedNotification2(new Notification(
      { ...notification2, body: 'Updated Notification' },
      mockEmitter,
     ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/cache/notifications-cache.ts
Tamaño: 9726 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { NotificationEvents, NovuEventEmitter } from '../event-emitter';
import type {
  ArchivedArgs,
  CompleteArgs,
  DeletedArgs,
  ListNotificationsArgs,
  ListNotificationsResponse,
  Notification,
  ReadArgs,
  RevertArgs,
  SeenArgs,
  SnoozeArgs,
  UnarchivedArgs,
  UnreadArgs,
  UnsnoozeArgs,
} from '../notifications';
import type { NotificationFilter } from '../types';
import { areDataEqual, areTagsEqual, isSameFilter } from '../utils/notification-utils';
import { InMemoryCache } from './in-memory-cache';
import type { Cache } from './types';

const excludeEmpty = ({
  tags,
  data,
  read,
  archived,
  snoozed,
  seen,
  severity,
  limit,
  offset,
  after,
}: ListNotificationsArgs) =>
  Object.entries({ tags, data, read, archived, snoozed, seen, severity, limit, offset, after })
    .filter(([_, value]) => value !== null && value !== undefined && !(Array.isArray(value) && value.length === 0))
    .reduce((acc, [key, value]) => {
      // @ts-expect-error
      acc[key] = value;

      return acc;
    }, {});

const getCacheKey = ({
  tags,
  data,
  read,
  archived,
  snoozed,
  seen,
  severity,
  limit,
  offset,
  after,
}: ListNotificationsArgs): string => {
  return JSON.stringify(excludeEmpty({ tags, data, read, archived, snoozed, seen, severity, limit, offset, after }));
};

const getFilterKey = ({
  tags,
  data,
  read,
  archived,
  snoozed,
  seen,
  severity,
}: Pick<ListNotificationsArgs, 'tags' | 'data' | 'read' | 'archived' | 'snoozed' | 'seen' | 'severity'>): string => {
  return JSON.stringify(excludeEmpty({ tags, data, read, archived, snoozed, seen, severity }));
};

const getFilter = (key: string): NotificationFilter => {
  return JSON.parse(key);
};

// these events should update the notification in the cache
const updateEvents: NotificationEvents[] = [
  'notification.read.pending',
  'notification.read.resolved',
  'notification.unread.pending',
  'notification.unread.resolved',
  'notification.complete_action.pending',
  'notification.complete_action.resolved',
  'notification.revert_action.pending',
  'notification.revert_action.resolved',
  'notifications.read_all.pending',
  'notifications.read_all.resolved',
];

// these events should remove the notification from the cache
const removeEvents: NotificationEvents[] = [
  'notification.archive.pending',
  'notification.unarchive.pending',
  'notification.snooze.pending',
  'notification.unsnooze.pending',
  'notification.delete.pending',
  'notifications.archive_all.pending',
  'notifications.archive_all_read.pending',
  'notifications.delete_all.pending',
];

// Union type for all possible args in notification events
type NotificationEventArgs =
  | ReadArgs
  | UnreadArgs
  | ArchivedArgs
  | UnarchivedArgs
  | DeletedArgs
  | SeenArgs
  | SnoozeArgs
  | UnsnoozeArgs
  | CompleteArgs
  | RevertArgs
  | { tags?: string[]; data?: Record<string, unknown> } // for bulk operations
  | { notificationIds: string[] } // for seen_all operations
  | Record<string, never>; // for empty args

export class NotificationsCache {
  #emitter: NovuEventEmitter;
  /**
   * The key is the stringified notifications filter, the values are the paginated notifications.
   */
  #cache: Cache<ListNotificationsResponse>;

  constructor({ emitter }: { emitter: NovuEventEmitter }) {
    this.#emitter = emitter;
    updateEvents.forEach((event) => {
      this.#emitter.on(event, this.handleNotificationEvent());
    });
    removeEvents.forEach((event) => {
      this.#emitter.on(event, this.handleNotificationEvent({ remove: true }));
    });
    this.#cache = new InMemoryCache();
  }

  private updateNotification = (key: string, data: Notification): boolean => {
    const notificationsResponse = this.#cache.get(key);
    if (!notificationsResponse) {
      return false;
    }

    const index = notificationsResponse.notifications.findIndex((el) => el.id === data.id);
    if (index === -1) {
      return false;
    }

    const updatedNotifications = [...notificationsResponse.notifications];
    updatedNotifications[index] = data;

    this.#cache.set(key, { ...notificationsResponse, notifications: updatedNotifications });

    return true;
  };

  private removeNotification = (key: string, data: Notification): boolean => {
    const notificationsResponse = this.#cache.get(key);
    if (!notificationsResponse) {
      return false;
    }

    const index = notificationsResponse.notifications.findIndex((el) => el.id === data.id);
    if (index === -1) {
      return false;
    }

    const newNotifications = [...notificationsResponse.notifications];
    newNotifications.splice(index, 1);

    this.#cache.set(key, {
      ...notificationsResponse,
      notifications: newNotifications,
    });

    return true;
  };

  private handleNotificationEvent =
    ({ remove }: { remove: boolean } = { remove: false }) =>
    (event: { data?: unknown; args?: NotificationEventArgs }): void => {
      const { data, args } = event;

      let notifications: Notification[] = [];

      if (data !== undefined && data !== null) {
        if (
          Array.isArray(data) &&
          data.every((item): item is Notification => typeof item === 'object' && 'id' in item)
        ) {
          notifications = data;
        } else if (typeof data === 'object' && 'id' in data) {
          notifications = [data as Notification];
        }
      } else if (remove && args) {
        if ('notification' in args && args.notification) {
          notifications = [args.notification];
        } else if ('notificationId' in args && args.notificationId) {
          const foundNotifications: Notification[] = [];
          this.#cache.keys().forEach((key) => {
            const cachedResponse = this.#cache.get(key);
            if (cachedResponse) {
              const found = cachedResponse.notifications.find((n) => n.id === args.notificationId);
              if (found) {
                foundNotifications.push(found);
              }
            }
          });
          notifications = foundNotifications;
        }
      }

      if (notifications.length === 0) {
        return;
      }

      const uniqueFilterKeys = new Set<string>();
      this.#cache.keys().forEach((key) => {
        notifications.forEach((notification) => {
          let isNotificationFound = false;
          if (remove) {
            isNotificationFound = this.removeNotification(key, notification);
          } else {
            isNotificationFound = this.updateNotification(key, notification);
          }

          if (isNotificationFound) {
            uniqueFilterKeys.add(getFilterKey(getFilter(key)));
          }
        });
      });

      uniqueFilterKeys.forEach((key) => {
        const notificationsResponse = this.getAggregated(getFilter(key));

        this.#emitter.emit('notifications.list.updated', {
          data: notificationsResponse,
        });
      });
    };

  private getAggregated(filter: NotificationFilter): ListNotificationsResponse {
    const cacheKeys = this.#cache.keys().filter((key) => {
      const parsedFilter = getFilter(key);

      return isSameFilter(parsedFilter, filter);
    });

    return cacheKeys
      .map((key) => this.#cache.get(key))
      .reduce<ListNotificationsResponse>(
        (acc, el) => {
          if (!el) {
            return acc;
          }

          return {
            hasMore: el.hasMore,
            filter: el.filter,
            notifications: [...acc.notifications, ...el.notifications],
          };
        },
        { hasMore: false, filter: {}, notifications: [] }
      );
  }

  has(args: ListNotificationsArgs): boolean {
    return this.#cache.get(getCacheKey(args)) !== undefined;
  }

  set(args: ListNotificationsArgs, data: ListNotificationsResponse): void {
    this.#cache.set(getCacheKey(args), data);
  }

  update(args: ListNotificationsArgs, data: ListNotificationsResponse): void {
    this.set(args, data);
    const notificationsResponse = this.getAggregated(getFilter(getCacheKey(args)));
    this.#emitter.emit('notifications.list.updated', {
      data: notificationsResponse,
    });
  }

  getAll(args: ListNotificationsArgs): ListNotificationsResponse | undefined {
    if (this.has(args)) {
      return this.getAggregated({
        tags: args.tags,
        data: args.data,
        read: args.read,
        snoozed: args.snoozed,
        archived: args.archived,
        seen: args.seen,
        severity: args.severity,
      });
    }
  }

  /**
   * Get unique notifications based on specified filter fields.
   * The same tags and data can be applied to multiple filters which means that the same notification can be duplicated.
   */
  getUniqueNotifications({
    tags,
    read,
    data,
  }: Pick<ListNotificationsArgs, 'tags' | 'read' | 'data'>): Array<Notification> {
    const keys = this.#cache.keys();
    const uniqueNotifications = new Map<string, Notification>();

    keys.forEach((key) => {
      const filter = getFilter(key);

      if (areTagsEqual(tags, filter.tags) && areDataEqual(data, filter.data)) {
        const value = this.#cache.get(key);
        if (!value) {
          return;
        }

        value.notifications
          .filter((el) => typeof read === 'undefined' || read === el.isRead)
          .forEach((notification) => {
            uniqueNotifications.set(notification.id, notification);
          });
      }
    });

    return Array.from(uniqueNotifications.values());
  }

  clear(filter: NotificationFilter): void {
    const keys = this.#cache.keys();
    keys.forEach((key) => {
      if (isSameFilter(getFilter(key), filter)) {
        this.#cache.remove(key);
      }
    });
  }

  clearAll(): void {
    this.#cache.clear();
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - excludeEmpty({
  tags,
  data,
  read,
  archived,
  snoozed,
  seen,
  severity,
  limit,
  offset,
  after,
}: ...)
 - getCacheKey({
  tags,
  data,
  read,
  archived,
  snoozed,
  seen,
  severity,
  limit,
  offset,
  after,
}: ...)
 - getFilterKey({
  tags,
  data,
  read,
  archived,
  snoozed,
  seen,
  severity,
}: Pick<ListNotificationsArgs, ...)
 - getFilter(key: string): NotificationFilter)
 - emitter(emitter;
    updateEvents.forEach((event))
 - updateNotification(key: string, data: Notification): boolean)
 - index(notificationsResponse.notifications.findIndex((el))
 - removeNotification(key: string, data: Notification): boolean)
 - index(notificationsResponse.notifications.findIndex((el))
 - found(cachedResponse.notifications.find((n))
 - uniqueFilterKeys(new Set<string>();
      this.#cache.keys().forEach((key))
 - isNotificationFound(this.updateNotification(key, notification);
          }

          if (isNotificationFound) {
      ...)
 - cacheKeys(this.#cache.keys().filter((key))
 - parsedFilter(getFilter(key);

      return isSameFilter(parsedFilter, filter);
    });

    return cacheKeys
    ...)
 - uniqueNotifications(new Map<string, Notification>();

    keys.forEach((key))
 - value(this.#cache.get(key);
        if (!value) {
          return;
        }

        value.notifications...)
 - keys(this.#cache.keys();
    keys.forEach((key))
Declaraciones 'export' encontradas:
- export class NotificationsCache

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/cache/preferences-cache.ts
Tamaño: 4598 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { NovuEventEmitter, PreferenceEvents, PreferenceScheduleEvents } from '../event-emitter';
import { Schedule } from '../preferences';
import { Preference } from '../preferences/preference';
import { ListPreferencesArgs } from '../preferences/types';
import { PreferenceLevel } from '../types';
import { InMemoryCache } from './in-memory-cache';
import type { Cache } from './types';

// these events should update the preferences in the cache
const updateEvents: PreferenceEvents[] = [
  'preference.update.pending',
  'preference.update.resolved',
  'preferences.bulk_update.pending',
  'preferences.bulk_update.resolved',
];

const scheduleUpdateEvents: PreferenceScheduleEvents[] = [
  'preference.schedule.update.pending',
  'preference.schedule.update.resolved',
];

const excludeEmpty = ({ tags, severity }: ListPreferencesArgs) =>
  Object.entries({ tags, severity }).reduce((acc, [key, value]) => {
    if (value === null || value === undefined || (Array.isArray(value) && value.length === 0)) {
      return acc;
    }
    // @ts-expect-error
    acc[key] = value;

    return acc;
  }, {});

const getCacheKey = ({ tags, severity }: ListPreferencesArgs): string => {
  return JSON.stringify(excludeEmpty({ tags, severity }));
};

export class PreferencesCache {
  #emitter: NovuEventEmitter;
  #cache: Cache<Preference[]>;

  constructor({ emitterInstance }: { emitterInstance: NovuEventEmitter }) {
    this.#emitter = emitterInstance;
    for (const event of updateEvents) {
      this.#emitter.on(event, this.handlePreferenceEvent);
    }
    for (const event of scheduleUpdateEvents) {
      this.#emitter.on(event, this.handleScheduleEvent);
    }
    this.#cache = new InMemoryCache();
  }

  private updatePreference = (key: string, data: Preference): boolean => {
    const preferences = this.#cache.get(key);
    if (!preferences) {
      return false;
    }

    const index = preferences.findIndex(
      (el) =>
        el.workflow?.id === data.workflow?.id || (el.level === data.level && data.level === PreferenceLevel.GLOBAL)
    );
    if (index === -1) {
      return false;
    }

    const updatedPreferences = [...preferences];
    updatedPreferences[index] = data;

    this.#cache.set(key, updatedPreferences);

    return true;
  };

  private updatePreferenceSchedule = (key: string, data: Schedule): boolean => {
    const preferences = this.#cache.get(key);
    if (!preferences) {
      return false;
    }

    const index = preferences.findIndex((el) => el.level === PreferenceLevel.GLOBAL);
    if (index === -1) {
      return false;
    }

    const updatedPreferences = [...preferences];
    updatedPreferences[index].schedule = data;

    this.#cache.set(key, updatedPreferences);

    return true;
  };

  private handleScheduleEvent = ({ data }: { data?: Schedule }): void => {
    if (!data) {
      return;
    }

    const cacheKeys = this.#cache.keys();
    const uniqueFilterKeys = new Set<string>();
    for (const key of cacheKeys) {
      const hasUpdatedPreference = this.updatePreferenceSchedule(key, data);

      const updatedPreference = this.#cache.get(key);
      if (!hasUpdatedPreference || !updatedPreference) {
        continue;
      }

      uniqueFilterKeys.add(key);
    }

    for (const key of uniqueFilterKeys) {
      this.#emitter.emit('preferences.list.updated', {
        data: this.#cache.get(key) ?? [],
      });
    }
  };

  private handlePreferenceEvent = ({ data }: { data?: Preference | Preference[] }): void => {
    if (!data) {
      return;
    }

    const preferences = Array.isArray(data) ? data : [data];

    const uniqueFilterKeys = new Set<string>();
    this.#cache.keys().forEach((key) => {
      preferences.forEach((preference) => {
        const hasUpdatedPreference = this.updatePreference(key, preference);

        const updatedPreference = this.#cache.get(key);
        if (!hasUpdatedPreference || !updatedPreference) {
          return;
        }

        uniqueFilterKeys.add(key);
      });
    });

    uniqueFilterKeys.forEach((key) => {
      this.#emitter.emit('preferences.list.updated', {
        data: this.#cache.get(key) ?? [],
      });
    });
  };

  has(args: ListPreferencesArgs): boolean {
    return this.#cache.get(getCacheKey(args)) !== undefined;
  }

  set(args: ListPreferencesArgs, data: Preference[]): void {
    this.#cache.set(getCacheKey(args), data);
  }

  getAll(args: ListPreferencesArgs): Preference[] | undefined {
    if (this.has(args)) {
      return this.#cache.get(getCacheKey(args));
    }
  }

  clearAll(): void {
    this.#cache.clear();
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - excludeEmpty({ tags, severity }: ListPreferencesArgs))
 - getCacheKey({ tags, severity }: ListPreferencesArgs): string)
 - updatePreference(key: string, data: Preference): boolean)
 - index(preferences.findIndex(
      (el))
 - updatePreferenceSchedule(key: string, data: Schedule): boolean)
 - index(preferences.findIndex((el))
 - handleScheduleEvent({ data }: { data?: Schedule }): void)
 - handlePreferenceEvent({ data }: { data?: Preference | Preference[] }): void)
 - uniqueFilterKeys(new Set<string>();
    this.#cache.keys().forEach((key))
 - updatedPreference(this.#cache.get(key);
        if (!hasUpdatedPreference || !updatedPreference) {
          return;
 ...)
Declaraciones 'export' encontradas:
- export class PreferencesCache

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/cache/schedule-cache.ts
Tamaño: 1996 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { NovuEventEmitter, PreferenceScheduleEvents } from '../event-emitter';
import { Schedule } from '../preferences';
import { InMemoryCache } from './in-memory-cache';
import type { Cache } from './types';

// these events should update the schedule in the cache
const updateEvents: PreferenceScheduleEvents[] = [
  'preference.schedule.update.pending',
  'preference.schedule.update.resolved',
];

const getCacheKey = (): string => {
  return 'schedule';
};

export class ScheduleCache {
  #emitter: NovuEventEmitter;
  #cache: Cache<Schedule>;

  constructor({ emitterInstance }: { emitterInstance: NovuEventEmitter }) {
    this.#emitter = emitterInstance;
    for (const event of updateEvents) {
      this.#emitter.on(event, this.handleScheduleEvent);
    }
    this.#cache = new InMemoryCache();
  }

  private updateScheduleInCache = (key: string, data: Schedule): boolean => {
    const schedule = this.#cache.get(key);
    if (!schedule) {
      return false;
    }

    this.#cache.set(key, data);

    return true;
  };

  private handleScheduleEvent = ({ data }: { data?: Schedule }): void => {
    if (!data) {
      return;
    }

    const uniqueFilterKeys = new Set<string>();
    const keys = this.#cache.keys();
    for (const key of keys) {
      const hasUpdatedSchedule = this.updateScheduleInCache(key, data);

      const updatedSchedule = this.#cache.get(key);
      if (!hasUpdatedSchedule || !updatedSchedule) {
        continue;
      }

      uniqueFilterKeys.add(key);
    }

    for (const key of uniqueFilterKeys) {
      this.#emitter.emit('preference.schedule.get.updated', {
        data: this.#cache.get(key)!,
      });
    }
  };

  has(): boolean {
    return this.#cache.get(getCacheKey()) !== undefined;
  }

  set(data: Schedule): void {
    this.#cache.set(getCacheKey(), data);
  }

  getAll(): Schedule | undefined {
    if (this.has()) {
      return this.#cache.get(getCacheKey());
    }
  }

  clearAll(): void {
    this.#cache.clear();
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - getCacheKey(): string)
 - updateScheduleInCache(key: string, data: Schedule): boolean)
 - handleScheduleEvent({ data }: { data?: Schedule }): void)
Declaraciones 'export' encontradas:
- export class ScheduleCache

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/cache/types.ts
Tamaño: 251 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export type Cache<T = unknown> = {
  get: (key: string) => T | undefined;
  getValues: () => T[];
  entries: () => [string, T][];
  keys: () => string[];
  set: (key: string, value: T) => void;
  remove: (key: string) => void;
  clear: () => void;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/event-emitter/index.ts
Tamaño: 63 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './novu-event-emitter';
export * from './types';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/event-emitter/novu-event-emitter.ts
Tamaño: 709 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import mitt, { Emitter } from 'mitt';
import { EventHandler, EventNames, Events } from './types';

export class NovuEventEmitter {
  #mittEmitter: Emitter<Events>;

  constructor() {
    this.#mittEmitter = mitt();
  }

  on<Key extends EventNames>(eventName: Key, listener: EventHandler<Events[Key]>): () => void {
    this.#mittEmitter.on(eventName, listener);

    return () => {
      this.off(eventName, listener);
    };
  }

  off<Key extends EventNames>(eventName: Key, listener: EventHandler<Events[Key]>): void {
    this.#mittEmitter.off(eventName, listener);
  }

  emit<Key extends EventNames>(type: Key, event?: Events[Key]): void {
    this.#mittEmitter.emit(type, event as Events[Key]);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - mittEmitter(mitt();
  }

  on<Key extends EventNames>(eventName: Key, listener: EventHandler<Events[Key]>): ())
Declaraciones 'export' encontradas:
- export class NovuEventEmitter

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/event-emitter/types.ts
Tamaño: 7040 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type {
  ArchivedArgs,
  CompleteArgs,
  CountArgs,
  CountResponse,
  DeletedArgs,
  ListNotificationsArgs,
  ListNotificationsResponse,
  Notification,
  ReadArgs,
  RevertArgs,
  SeenArgs,
  SnoozeArgs,
  UnarchivedArgs,
  UnreadArgs,
  UnsnoozeArgs,
} from '../notifications';
import { Preference } from '../preferences/preference';
import { Schedule } from '../preferences/schedule';
import { ListPreferencesArgs, UpdatePreferenceArgs, UpdateScheduleArgs } from '../preferences/types';
import type { InitializeSessionArgs } from '../session';
import { Session, WebSocketEvent } from '../types';

type NovuPendingEvent<A, D = undefined> = {
  args: A;
  data?: D;
};
type NovuResolvedEvent<A, D> = NovuPendingEvent<A, D> & {
  error?: unknown;
};
// two possible status of the event: pending, resolved
type EventName<T extends string> = `${T}.pending` | `${T}.resolved`;
// infer the "status" of the event based on the string `module.action.status`
type EventStatus<T extends string> = `${T extends `${infer _}.${infer __}.${infer V}` ? V : never}`;
// based on the key it returns the event pending, success or error object
type EventObject<K extends string, ARGS, DATA, EVENT_STATUS = EventStatus<K>> = EVENT_STATUS extends 'pending'
  ? NovuPendingEvent<ARGS, DATA>
  : NovuResolvedEvent<ARGS, DATA>;

type BaseEvents<T extends string, ARGS, DATA> = {
  [key in `${EventName<T>}`]: EventObject<key, ARGS, DATA>;
};

type SessionInitializeEvents = BaseEvents<'session.initialize', InitializeSessionArgs, Session>;
type NotificationsFetchEvents = BaseEvents<'notifications.list', ListNotificationsArgs, ListNotificationsResponse>;
type NotificationsFetchCountEvents = BaseEvents<'notifications.count', CountArgs, CountResponse>;
type NotificationReadEvents = BaseEvents<'notification.read', ReadArgs, Notification>;
type NotificationUnreadEvents = BaseEvents<'notification.unread', UnreadArgs, Notification>;
type NotificationSeenEvents = BaseEvents<'notification.seen', SeenArgs, Notification>;
type NotificationArchiveEvents = BaseEvents<'notification.archive', ArchivedArgs, Notification>;
type NotificationUnarchiveEvents = BaseEvents<'notification.unarchive', UnarchivedArgs, Notification>;
type NotificationDeleteEvents = BaseEvents<'notification.delete', DeletedArgs, Notification>;
type NotificationSnoozeEvents = BaseEvents<'notification.snooze', SnoozeArgs, Notification>;
type NotificationUnsnoozeEvents = BaseEvents<'notification.unsnooze', UnsnoozeArgs, Notification>;
type NotificationCompleteActionEvents = BaseEvents<'notification.complete_action', CompleteArgs, Notification>;
type NotificationRevertActionEvents = BaseEvents<'notification.revert_action', RevertArgs, Notification>;
type NotificationsReadAllEvents = BaseEvents<
  'notifications.read_all',
  { tags?: string[]; data?: Record<string, unknown> },
  Notification[]
>;
type NotificationsSeenAllEvents = BaseEvents<
  'notifications.seen_all',
  { notificationIds: string[] } | { tags?: string[]; data?: Record<string, unknown> } | {},
  Notification[]
>;
type NotificationsArchivedAllEvents = BaseEvents<
  'notifications.archive_all',
  { tags?: string[]; data?: Record<string, unknown> },
  Notification[]
>;
type NotificationsReadArchivedAllEvents = BaseEvents<
  'notifications.archive_all_read',
  { tags?: string[]; data?: Record<string, unknown> },
  Notification[]
>;
type NotificationsDeletedAllEvents = BaseEvents<
  'notifications.delete_all',
  { tags?: string[]; data?: Record<string, unknown> },
  Notification[]
>;
type PreferencesFetchEvents = BaseEvents<'preferences.list', ListPreferencesArgs, Preference[]>;
type PreferenceUpdateEvents = BaseEvents<'preference.update', UpdatePreferenceArgs, Preference>;
type PreferencesBulkUpdateEvents = BaseEvents<'preferences.bulk_update', Array<UpdatePreferenceArgs>, Preference[]>;
type PreferenceScheduleGetEvents = BaseEvents<'preference.schedule.get', undefined, Schedule>;
type PreferenceScheduleUpdateEvents = BaseEvents<'preference.schedule.update', UpdateScheduleArgs, Schedule>;
type SocketConnectEvents = BaseEvents<'socket.connect', { socketUrl: string }, undefined>;
export type NotificationReceivedEvent = `notifications.${WebSocketEvent.RECEIVED}`;
export type NotificationUnseenEvent = `notifications.${WebSocketEvent.UNSEEN}`;
export type NotificationUnreadEvent = `notifications.${WebSocketEvent.UNREAD}`;
type SocketEvents = {
  [key in NotificationReceivedEvent]: { result: Notification };
} & {
  [key in NotificationUnseenEvent]: { result: number };
} & {
  [key in NotificationUnreadEvent]: { result: { total: number; severity: Record<string, number> } };
};

/**
 * Events that are emitted by Novu Event Emitter.
 *
 * The event name consists of second pattern: module.action.status
 * - module: the name of the module
 * - action: the action that is being performed
 * - status: the status of the action, could be pending or resolved
 *
 * Each event has a corresponding payload that is associated with the event:
 * - pending: the args that are passed to the action and the optional optimistic value
 * - resolved: the args that are passed to the action and the result of the action or the error that is thrown
 */
export type Events = SessionInitializeEvents &
  NotificationsFetchEvents & {
    'notifications.list.updated': { data: ListNotificationsResponse };
  } & NotificationsFetchCountEvents &
  PreferencesFetchEvents & {
    'preferences.list.updated': { data: Preference[] };
  } & PreferenceUpdateEvents &
  PreferencesBulkUpdateEvents &
  PreferenceScheduleGetEvents &
  PreferenceScheduleUpdateEvents & {
    'preference.schedule.get.updated': { data: Schedule };
  } & SocketConnectEvents &
  SocketEvents &
  NotificationReadEvents &
  NotificationUnreadEvents &
  NotificationSeenEvents &
  NotificationArchiveEvents &
  NotificationUnarchiveEvents &
  NotificationDeleteEvents &
  NotificationSnoozeEvents &
  NotificationUnsnoozeEvents &
  NotificationCompleteActionEvents &
  NotificationRevertActionEvents &
  NotificationsReadAllEvents &
  NotificationsSeenAllEvents &
  NotificationsArchivedAllEvents &
  NotificationsReadArchivedAllEvents &
  NotificationsDeletedAllEvents;

export type EventNames = keyof Events;
export type SocketEventNames = keyof SocketEvents;
export type NotificationEvents = keyof (NotificationReadEvents &
  NotificationUnreadEvents &
  NotificationSeenEvents &
  NotificationArchiveEvents &
  NotificationUnarchiveEvents &
  NotificationDeleteEvents &
  NotificationSnoozeEvents &
  NotificationUnsnoozeEvents &
  NotificationCompleteActionEvents &
  NotificationRevertActionEvents &
  NotificationsReadAllEvents &
  NotificationsSeenAllEvents &
  NotificationsArchivedAllEvents &
  NotificationsReadArchivedAllEvents &
  NotificationsDeletedAllEvents);
export type PreferenceEvents = keyof (PreferenceUpdateEvents & PreferencesBulkUpdateEvents);
export type PreferenceScheduleEvents = keyof (PreferenceScheduleGetEvents & PreferenceScheduleUpdateEvents);

export type EventHandler<T = unknown> = (event: T) => void;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/notifications/helpers.ts
Tamaño: 17723 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { InboxService } from '../api';
import type { NotificationsCache } from '../cache';
import type { NovuEventEmitter } from '../event-emitter';
import { Action, ActionTypeEnum, NotificationFilter, Result } from '../types';
import { NovuError } from '../utils/errors';
import { Notification } from './notification';
import type {
  ArchivedArgs,
  CompleteArgs,
  DeletedArgs,
  ReadArgs,
  RevertArgs,
  SeenArgs,
  SnoozeArgs,
  UnarchivedArgs,
  UnreadArgs,
  UnsnoozeArgs,
} from './types';

export const read = async ({
  emitter,
  apiService,
  args,
}: {
  emitter: NovuEventEmitter;
  apiService: InboxService;
  args: ReadArgs;
}): Result<Notification> => {
  const { notificationId, optimisticValue } = getNotificationDetails(
    args,
    {
      isRead: true,
      readAt: new Date().toISOString(),
      isArchived: false,
      archivedAt: undefined,
    },
    {
      emitter,
      apiService,
    }
  );

  try {
    emitter.emit('notification.read.pending', {
      args,
      data: optimisticValue,
    });

    const response = await apiService.read(notificationId);

    const updatedNotification = new Notification(response, emitter, apiService);
    emitter.emit('notification.read.resolved', { args, data: updatedNotification });

    return { data: updatedNotification };
  } catch (error) {
    emitter.emit('notification.read.resolved', { args, error });

    return { error: new NovuError('Failed to read notification', error) };
  }
};

export const unread = async ({
  emitter,
  apiService,
  args,
}: {
  emitter: NovuEventEmitter;
  apiService: InboxService;
  args: UnreadArgs;
}): Result<Notification> => {
  const { notificationId, optimisticValue } = getNotificationDetails(
    args,
    {
      isRead: false,
      readAt: null,
      isArchived: false,
      archivedAt: undefined,
    },
    {
      emitter,
      apiService,
    }
  );
  try {
    emitter.emit('notification.unread.pending', {
      args,
      data: optimisticValue,
    });

    const response = await apiService.unread(notificationId);

    const updatedNotification = new Notification(response, emitter, apiService);
    emitter.emit('notification.unread.resolved', { args, data: updatedNotification });

    return { data: updatedNotification };
  } catch (error) {
    emitter.emit('notification.unread.resolved', { args, error });

    return { error: new NovuError('Failed to unread notification', error) };
  }
};

export const seen = async ({
  emitter,
  apiService,
  args,
}: {
  emitter: NovuEventEmitter;
  apiService: InboxService;
  args: SeenArgs;
}): Result<Notification> => {
  const { notificationId, optimisticValue } = getNotificationDetails(
    args,
    {
      isSeen: true,
    },
    {
      emitter,
      apiService,
    }
  );

  try {
    emitter.emit('notification.seen.pending', {
      args,
      data: optimisticValue,
    });

    await apiService.seen(notificationId);

    if (!optimisticValue) {
      throw new Error('Failed to create optimistic value for notification');
    }

    const updatedNotification = new Notification(optimisticValue, emitter, apiService);
    emitter.emit('notification.seen.resolved', { args, data: updatedNotification });

    return { data: updatedNotification };
  } catch (error) {
    emitter.emit('notification.seen.resolved', { args, error });

    return { error: new NovuError('Failed to mark notification as seen', error) };
  }
};

export const archive = async ({
  emitter,
  apiService,
  args,
}: {
  emitter: NovuEventEmitter;
  apiService: InboxService;
  args: ArchivedArgs;
}): Result<Notification> => {
  const { notificationId, optimisticValue } = getNotificationDetails(
    args,
    {
      isArchived: true,
      archivedAt: new Date().toISOString(),
      isRead: true,
      readAt: new Date().toISOString(),
    },
    {
      emitter,
      apiService,
    }
  );

  try {
    emitter.emit('notification.archive.pending', {
      args,
      data: optimisticValue,
    });

    const response = await apiService.archive(notificationId);

    const updatedNotification = new Notification(response, emitter, apiService);
    emitter.emit('notification.archive.resolved', { args, data: updatedNotification });

    return { data: updatedNotification };
  } catch (error) {
    emitter.emit('notification.archive.resolved', { args, error });

    return { error: new NovuError('Failed to archive notification', error) };
  }
};

export const unarchive = async ({
  emitter,
  apiService,
  args,
}: {
  emitter: NovuEventEmitter;
  apiService: InboxService;
  args: UnarchivedArgs;
}): Result<Notification> => {
  const { notificationId, optimisticValue } = getNotificationDetails(
    args,
    {
      isArchived: false,
      archivedAt: null,
      isRead: true,
      readAt: new Date().toISOString(),
    },
    {
      emitter,
      apiService,
    }
  );

  try {
    emitter.emit('notification.unarchive.pending', {
      args,
      data: optimisticValue,
    });

    const response = await apiService.unarchive(notificationId);

    const updatedNotification = new Notification(response, emitter, apiService);
    emitter.emit('notification.unarchive.resolved', { args, data: updatedNotification });

    return { data: updatedNotification };
  } catch (error) {
    emitter.emit('notification.unarchive.resolved', { args, error });

    return { error: new NovuError('Failed to unarchive notification', error) };
  }
};

export const snooze = async ({
  emitter,
  apiService,
  args,
}: {
  emitter: NovuEventEmitter;
  apiService: InboxService;
  args: SnoozeArgs;
}): Result<Notification> => {
  const { notificationId, optimisticValue } = getNotificationDetails(
    args,
    {
      isSnoozed: true,
      snoozedUntil: args.snoozeUntil,
    },
    {
      emitter,
      apiService,
    }
  );

  try {
    emitter.emit('notification.snooze.pending', {
      args,
      data: optimisticValue,
    });

    const response = await apiService.snooze(notificationId, args.snoozeUntil);

    const updatedNotification = new Notification(response, emitter, apiService);
    emitter.emit('notification.snooze.resolved', { args, data: updatedNotification });

    return { data: updatedNotification };
  } catch (error) {
    emitter.emit('notification.snooze.resolved', { args, error });

    return { error: new NovuError('Failed to snooze notification', error) };
  }
};

export const unsnooze = async ({
  emitter,
  apiService,
  args,
}: {
  emitter: NovuEventEmitter;
  apiService: InboxService;
  args: UnsnoozeArgs;
}): Result<Notification> => {
  const { notificationId, optimisticValue } = getNotificationDetails(
    args,
    {
      isSnoozed: false,
      snoozedUntil: null,
    },
    {
      emitter,
      apiService,
    }
  );

  try {
    emitter.emit('notification.unsnooze.pending', {
      args,
      data: optimisticValue,
    });

    const response = await apiService.unsnooze(notificationId);

    const updatedNotification = new Notification(response, emitter, apiService);
    emitter.emit('notification.unsnooze.resolved', { args, data: updatedNotification });

    return { data: updatedNotification };
  } catch (error) {
    emitter.emit('notification.unsnooze.resolved', { args, error });

    return { error: new NovuError('Failed to unsnooze notification', error) };
  }
};

export const completeAction = async ({
  emitter,
  apiService,
  args,
  actionType,
}: {
  emitter: NovuEventEmitter;
  apiService: InboxService;
  args: CompleteArgs;
  actionType: ActionTypeEnum;
}): Result<Notification> => {
  const optimisticUpdate: Partial<Notification> =
    actionType === ActionTypeEnum.PRIMARY
      ? {
          primaryAction: {
            ...(('notification' in args ? args.notification.primaryAction : {}) as any),
            isCompleted: true,
          },
        }
      : {
          secondaryAction: {
            ...(('notification' in args ? args.notification.secondaryAction : {}) as any),
            isCompleted: true,
          },
        };
  const { notificationId, optimisticValue } = getNotificationDetails(args, optimisticUpdate, {
    emitter,
    apiService,
  });

  try {
    emitter.emit('notification.complete_action.pending', {
      args,
      data: optimisticValue,
    });

    const response = await apiService.completeAction({ actionType, notificationId });

    const updatedNotification = new Notification(response, emitter, apiService);
    emitter.emit('notification.complete_action.resolved', { args, data: updatedNotification });

    return { data: updatedNotification };
  } catch (error) {
    emitter.emit('notification.complete_action.resolved', { args, error });

    return { error: new NovuError(`Failed to complete ${actionType} action on the notification`, error) };
  }
};

export const revertAction = async ({
  emitter,
  apiService,
  args,
  actionType,
}: {
  emitter: NovuEventEmitter;
  apiService: InboxService;
  args: RevertArgs;
  actionType: ActionTypeEnum;
}): Result<Notification> => {
  const optimisticUpdate: Partial<Notification> =
    actionType === ActionTypeEnum.PRIMARY
      ? {
          primaryAction: {
            ...(('notification' in args ? args.notification.primaryAction : {}) as any),
            isCompleted: false,
          },
        }
      : {
          secondaryAction: {
            ...(('notification' in args ? args.notification.secondaryAction : {}) as any),
            isCompleted: false,
          },
        };

  const { notificationId, optimisticValue } = getNotificationDetails(args, optimisticUpdate, {
    emitter,
    apiService,
  });

  try {
    emitter.emit('notification.revert_action.pending', {
      args,
      data: optimisticValue,
    });

    const response = await apiService.revertAction({ actionType, notificationId });

    const updatedNotification = new Notification(response, emitter, apiService);
    emitter.emit('notification.revert_action.resolved', { args, data: updatedNotification });

    return { data: updatedNotification };
  } catch (error) {
    emitter.emit('notification.revert_action.resolved', { args, error });

    return { error: new NovuError('Failed to fetch notifications', error) };
  }
};

const getNotificationDetails = (
  args: ReadArgs | UnreadArgs | ArchivedArgs | UnarchivedArgs | SnoozeArgs | UnsnoozeArgs,
  update: Partial<Notification>,
  dependencies: {
    emitter: NovuEventEmitter;
    apiService: InboxService;
  }
): { notificationId: string; optimisticValue?: Notification } => {
  if ('notification' in args) {
    return {
      notificationId: args.notification.id,
      optimisticValue: new Notification(
        { ...args.notification, ...update },
        dependencies.emitter,
        dependencies.apiService
      ),
    };
  } else {
    return {
      notificationId: args.notificationId,
    };
  }
};

export const readAll = async ({
  emitter,
  inboxService,
  notificationsCache,
  tags,
  data,
}: {
  emitter: NovuEventEmitter;
  inboxService: InboxService;
  notificationsCache: NotificationsCache;
  tags?: NotificationFilter['tags'];
  data?: Record<string, unknown>;
}): Result<void> => {
  try {
    const notifications = notificationsCache.getUniqueNotifications({ tags, data });
    const optimisticNotifications = notifications.map(
      (notification) =>
        new Notification(
          {
            ...notification,
            isRead: true,
            readAt: new Date().toISOString(),
            isArchived: false,
            archivedAt: undefined,
          },
          emitter,
          inboxService
        )
    );
    emitter.emit('notifications.read_all.pending', { args: { tags, data }, data: optimisticNotifications });

    await inboxService.readAll({ tags, data });

    emitter.emit('notifications.read_all.resolved', { args: { tags, data }, data: optimisticNotifications });

    return {};
  } catch (error) {
    emitter.emit('notifications.read_all.resolved', { args: { tags, data }, error });

    return { error: new NovuError('Failed to read all notifications', error) };
  }
};

export const seenAll = async ({
  emitter,
  inboxService,
  notificationsCache,
  notificationIds,
  tags,
  data,
}: {
  emitter: NovuEventEmitter;
  inboxService: InboxService;
  notificationsCache: NotificationsCache;
  notificationIds?: string[];
  tags?: NotificationFilter['tags'];
  data?: Record<string, unknown>;
}): Result<void> => {
  try {
    const notifications = notificationsCache.getUniqueNotifications({ tags, data });

    // Filter notifications by IDs if provided
    const filteredNotifications =
      notificationIds && notificationIds.length > 0
        ? notifications.filter((notification) => notificationIds.includes(notification.id))
        : notifications;

    const optimisticNotifications = filteredNotifications.map(
      (notification) =>
        new Notification(
          {
            ...notification,
            isSeen: true,
            firstSeenAt: notification.firstSeenAt || new Date().toISOString(),
          },
          emitter,
          inboxService
        )
    );

    emitter.emit('notifications.seen_all.pending', {
      args: { notificationIds, tags, data },
      data: optimisticNotifications,
    });

    await inboxService.markAsSeen({ notificationIds, tags, data });

    emitter.emit('notifications.seen_all.resolved', {
      args: { notificationIds, tags, data },
      data: optimisticNotifications,
    });

    return {};
  } catch (error) {
    emitter.emit('notifications.seen_all.resolved', { args: { notificationIds, tags, data }, error });

    return { error: new NovuError('Failed to mark all notifications as seen', error) };
  }
};

export const archiveAll = async ({
  emitter,
  inboxService,
  notificationsCache,
  tags,
  data,
}: {
  emitter: NovuEventEmitter;
  inboxService: InboxService;
  notificationsCache: NotificationsCache;
  tags?: NotificationFilter['tags'];
  data?: Record<string, unknown>;
}): Result<void> => {
  try {
    const notifications = notificationsCache.getUniqueNotifications({ tags, data });
    const optimisticNotifications = notifications.map(
      (notification) =>
        new Notification(
          {
            ...notification,
            isRead: true,
            readAt: new Date().toISOString(),
            isArchived: true,
            archivedAt: new Date().toISOString(),
          },
          emitter,
          inboxService
        )
    );
    emitter.emit('notifications.archive_all.pending', { args: { tags, data }, data: optimisticNotifications });

    await inboxService.archiveAll({ tags, data });

    emitter.emit('notifications.archive_all.resolved', { args: { tags, data }, data: optimisticNotifications });

    return {};
  } catch (error) {
    emitter.emit('notifications.archive_all.resolved', { args: { tags, data }, error });

    return { error: new NovuError('Failed to archive all notifications', error) };
  }
};

export const archiveAllRead = async ({
  emitter,
  inboxService,
  notificationsCache,
  tags,
  data,
}: {
  emitter: NovuEventEmitter;
  inboxService: InboxService;
  notificationsCache: NotificationsCache;
  tags?: NotificationFilter['tags'];
  data?: Record<string, unknown>;
}): Result<void> => {
  try {
    const notifications = notificationsCache.getUniqueNotifications({ tags, data, read: true });
    const optimisticNotifications = notifications.map(
      (notification) =>
        new Notification(
          { ...notification, isArchived: true, archivedAt: new Date().toISOString() },
          emitter,
          inboxService
        )
    );
    emitter.emit('notifications.archive_all_read.pending', { args: { tags, data }, data: optimisticNotifications });

    await inboxService.archiveAllRead({ tags, data });

    emitter.emit('notifications.archive_all_read.resolved', { args: { tags, data }, data: optimisticNotifications });

    return {};
  } catch (error) {
    emitter.emit('notifications.archive_all_read.resolved', { args: { tags, data }, error });

    return { error: new NovuError('Failed to archive all read notifications', error) };
  }
};

export const deleteNotification = async ({
  emitter,
  apiService,
  args,
}: {
  emitter: NovuEventEmitter;
  apiService: InboxService;
  args: DeletedArgs;
}): Result<void> => {
  const { notificationId } = getNotificationDetails(
    args,
    {},
    {
      emitter,
      apiService,
    }
  );

  try {
    emitter.emit('notification.delete.pending', {
      args,
    });

    await apiService.delete(notificationId);

    emitter.emit('notification.delete.resolved', { args });

    return {};
  } catch (error) {
    emitter.emit('notification.delete.resolved', { args, error });

    return { error: new NovuError('Failed to delete notification', error) };
  }
};

export const deleteAll = async ({
  emitter,
  inboxService,
  notificationsCache,
  tags,
  data,
}: {
  emitter: NovuEventEmitter;
  inboxService: InboxService;
  notificationsCache: NotificationsCache;
  tags?: NotificationFilter['tags'];
  data?: Record<string, unknown>;
}): Result<void> => {
  try {
    // Get notifications that match the filter for optimistic removal
    const notifications = notificationsCache.getUniqueNotifications({ tags, data });

    emitter.emit('notifications.delete_all.pending', { args: { tags, data }, data: notifications });

    await inboxService.deleteAll({ tags, data });

    emitter.emit('notifications.delete_all.resolved', { args: { tags, data } });

    return {};
  } catch (error) {
    emitter.emit('notifications.delete_all.resolved', { args: { tags, data }, error });

    return { error: new NovuError('Failed to delete all notifications', error) };
  }
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - read(async ({
  emitter,
  apiService,
  args,
}: {
  emitter: NovuEventEmitter;
  apiService: InboxServi...)
 - unread(async ({
  emitter,
  apiService,
  args,
}: {
  emitter: NovuEventEmitter;
  apiService: InboxServi...)
 - seen(async ({
  emitter,
  apiService,
  args,
}: {
  emitter: NovuEventEmitter;
  apiService: InboxServi...)
 - archive(async ({
  emitter,
  apiService,
  args,
}: {
  emitter: NovuEventEmitter;
  apiService: InboxServi...)
 - unarchive(async ({
  emitter,
  apiService,
  args,
}: {
  emitter: NovuEventEmitter;
  apiService: InboxServi...)
 - snooze(async ({
  emitter,
  apiService,
  args,
}: {
  emitter: NovuEventEmitter;
  apiService: InboxServi...)
 - unsnooze(async ({
  emitter,
  apiService,
  args,
}: {
  emitter: NovuEventEmitter;
  apiService: InboxServi...)
 - completeAction(async ({
  emitter,
  apiService,
  args,
  actionType,
}: {
  emitter: NovuEventEmitter;
  apiServi...)
 - revertAction(async ({
  emitter,
  apiService,
  args,
  actionType,
}: {
  emitter: NovuEventEmitter;
  apiServi...)
 - getNotificationDetails(args: ReadArgs | UnreadArgs | ArchivedArgs | UnarchivedArgs | SnoozeArgs | UnsnoozeArgs,
  update: P...)
 - readAll(async ({
  emitter,
  inboxService,
  notificationsCache,
  tags,
  data,
}: {
  emitter: NovuEventE...)
 - optimisticNotifications(notifications.map(
      (notification))
 - seenAll(async ({
  emitter,
  inboxService,
  notificationsCache,
  notificationIds,
  tags,
  data,
}: {
  ...)
 - filteredNotifications(notificationIds && notificationIds.length > 0
        ? notifications.filter((notification))
 - optimisticNotifications(filteredNotifications.map(
      (notification))
 - archiveAll(async ({
  emitter,
  inboxService,
  notificationsCache,
  tags,
  data,
}: {
  emitter: NovuEventE...)
 - optimisticNotifications(notifications.map(
      (notification))
 - archiveAllRead(async ({
  emitter,
  inboxService,
  notificationsCache,
  tags,
  data,
}: {
  emitter: NovuEventE...)
 - optimisticNotifications(notifications.map(
      (notification))
 - deleteNotification(async ({
  emitter,
  apiService,
  args,
}: {
  emitter: NovuEventEmitter;
  apiService: InboxServi...)
 - deleteAll(async ({
  emitter,
  inboxService,
  notificationsCache,
  tags,
  data,
}: {
  emitter: NovuEventE...)
Declaraciones 'export' encontradas:
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/notifications/index.ts
Tamaño: 90 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './notification';
export * from './notifications';
export * from './types';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/notifications/notification.ts
Tamaño: 6327 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { InboxService } from '../api';
import { EventHandler, EventNames, Events, NovuEventEmitter } from '../event-emitter';
import { ActionTypeEnum, InboxNotification, Result } from '../types';
import {
  archive,
  completeAction,
  deleteNotification,
  read,
  revertAction,
  seen,
  snooze,
  unarchive,
  unread,
  unsnooze,
} from './helpers';

export class Notification implements Pick<NovuEventEmitter, 'on'>, InboxNotification {
  #emitter: NovuEventEmitter;
  #inboxService: InboxService;

  readonly id: InboxNotification['id'];
  readonly transactionId: InboxNotification['transactionId'];
  readonly subject?: InboxNotification['subject'];
  readonly body: InboxNotification['body'];
  readonly to: InboxNotification['to'];
  readonly isRead: InboxNotification['isRead'];
  readonly isSeen: InboxNotification['isSeen'];
  readonly isArchived: InboxNotification['isArchived'];
  readonly isSnoozed: InboxNotification['isSnoozed'];
  readonly snoozedUntil?: InboxNotification['snoozedUntil'];
  readonly deliveredAt?: InboxNotification['deliveredAt'];
  readonly createdAt: InboxNotification['createdAt'];
  readonly readAt?: InboxNotification['readAt'];
  readonly firstSeenAt?: InboxNotification['firstSeenAt'];
  readonly archivedAt?: InboxNotification['archivedAt'];
  readonly avatar?: InboxNotification['avatar'];
  readonly primaryAction?: InboxNotification['primaryAction'];
  readonly secondaryAction?: InboxNotification['secondaryAction'];
  readonly channelType: InboxNotification['channelType'];
  readonly tags: InboxNotification['tags'];
  readonly redirect: InboxNotification['redirect'];
  readonly data?: InboxNotification['data'];
  readonly workflow?: InboxNotification['workflow'];
  readonly severity: InboxNotification['severity'];

  constructor(notification: InboxNotification, emitter: NovuEventEmitter, inboxService: InboxService) {
    this.#emitter = emitter;
    this.#inboxService = inboxService;

    this.id = notification.id;
    this.transactionId = notification.transactionId;
    this.subject = notification.subject;
    this.body = notification.body;
    this.to = notification.to;
    this.isRead = notification.isRead;
    this.isSeen = notification.isSeen;
    this.isArchived = notification.isArchived;
    this.isSnoozed = notification.isSnoozed;
    this.snoozedUntil = notification.snoozedUntil;
    this.deliveredAt = notification.deliveredAt;
    this.createdAt = notification.createdAt;
    this.readAt = notification.readAt;
    this.firstSeenAt = notification.firstSeenAt;
    this.archivedAt = notification.archivedAt;
    this.avatar = notification.avatar;
    this.primaryAction = notification.primaryAction;
    this.secondaryAction = notification.secondaryAction;
    this.channelType = notification.channelType;
    this.tags = notification.tags;
    this.redirect = notification.redirect;
    this.data = notification.data;
    this.workflow = notification.workflow;
    this.severity = notification.severity;
  }

  read(): Result<Notification> {
    return read({
      emitter: this.#emitter,
      apiService: this.#inboxService,
      args: {
        notification: this,
      },
    });
  }

  unread(): Result<Notification> {
    return unread({
      emitter: this.#emitter,
      apiService: this.#inboxService,
      args: {
        notification: this,
      },
    });
  }

  seen(): Result<Notification> {
    return seen({
      emitter: this.#emitter,
      apiService: this.#inboxService,
      args: {
        notification: this,
      },
    });
  }

  archive(): Result<Notification> {
    return archive({
      emitter: this.#emitter,
      apiService: this.#inboxService,
      args: {
        notification: this,
      },
    });
  }

  unarchive(): Result<Notification> {
    return unarchive({
      emitter: this.#emitter,
      apiService: this.#inboxService,
      args: {
        notification: this,
      },
    });
  }

  delete(): Result<void> {
    return deleteNotification({
      emitter: this.#emitter,
      apiService: this.#inboxService,
      args: {
        notification: this,
      },
    });
  }

  snooze(snoozeUntil: string): Result<Notification> {
    return snooze({
      emitter: this.#emitter,
      apiService: this.#inboxService,
      args: {
        notification: this,
        snoozeUntil,
      },
    });
  }

  unsnooze(): Result<Notification> {
    return unsnooze({
      emitter: this.#emitter,
      apiService: this.#inboxService,
      args: { notification: this },
    });
  }

  completePrimary(): Result<Notification> {
    if (!this.primaryAction) {
      throw new Error('Primary action is not available');
    }

    return completeAction({
      emitter: this.#emitter,
      apiService: this.#inboxService,
      args: {
        notification: this,
      },
      actionType: ActionTypeEnum.PRIMARY,
    });
  }

  completeSecondary(): Result<Notification> {
    if (!this.primaryAction) {
      throw new Error('Secondary action is not available');
    }

    return completeAction({
      emitter: this.#emitter,
      apiService: this.#inboxService,
      args: {
        notification: this,
      },
      actionType: ActionTypeEnum.SECONDARY,
    });
  }

  revertPrimary(): Result<Notification> {
    if (!this.primaryAction) {
      throw new Error('Primary action is not available');
    }

    return revertAction({
      emitter: this.#emitter,
      apiService: this.#inboxService,
      args: {
        notification: this,
      },
      actionType: ActionTypeEnum.PRIMARY,
    });
  }

  revertSecondary(): Result<Notification> {
    if (!this.primaryAction) {
      throw new Error('Secondary action is not available');
    }

    return revertAction({
      emitter: this.#emitter,
      apiService: this.#inboxService,
      args: {
        notification: this,
      },
      actionType: ActionTypeEnum.SECONDARY,
    });
  }

  on<Key extends EventNames>(eventName: Key, listener: EventHandler<Events[Key]>): () => void {
    const cleanup = this.#emitter.on(eventName, listener);

    return () => {
      cleanup();
    };
  }

  /**
   * @deprecated
   * Use the cleanup function returned by the "on" method instead.
   */
  off<Key extends EventNames>(eventName: Key, listener: EventHandler<Events[Key]>): void {
    this.#emitter.off(eventName, listener);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - severity(notification.severity;
  }

  read(): Result<Notification> {
    return read({
      emitter: this.#...)
 - cleanup(this.#emitter.on(eventName, listener);

    return ())
Declaraciones 'export' encontradas:
- export class Notification

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/notifications/notifications.ts
Tamaño: 10539 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { InboxService } from '../api';
import { BaseModule } from '../base-module';
import { NotificationsCache } from '../cache';
import { NovuEventEmitter } from '../event-emitter';
import { ActionTypeEnum, NotificationFilter, Result } from '../types';
import { NovuError } from '../utils/errors';
import {
  archive,
  archiveAll,
  archiveAllRead,
  completeAction,
  deleteAll,
  deleteNotification,
  read,
  readAll,
  revertAction,
  seen,
  seenAll,
  snooze,
  unarchive,
  unread,
  unsnooze,
} from './helpers';
import { Notification } from './notification';
import type {
  ArchivedArgs,
  BaseArgs,
  CompleteArgs,
  CountArgs,
  CountResponse,
  DeletedArgs,
  FilterCountArgs,
  FilterCountResponse,
  FiltersCountArgs,
  FiltersCountResponse,
  InstanceArgs,
  ListNotificationsArgs,
  ListNotificationsResponse,
  ReadArgs,
  RevertArgs,
  SeenArgs,
  SnoozeArgs,
  UnarchivedArgs,
  UnreadArgs,
  UnsnoozeArgs,
} from './types';

export class Notifications extends BaseModule {
  #useCache: boolean;

  readonly cache: NotificationsCache;

  constructor({
    useCache,
    inboxServiceInstance,
    eventEmitterInstance,
  }: {
    useCache: boolean;
    inboxServiceInstance: InboxService;
    eventEmitterInstance: NovuEventEmitter;
  }) {
    super({
      eventEmitterInstance,
      inboxServiceInstance,
    });
    this.cache = new NotificationsCache({
      emitter: eventEmitterInstance,
    });
    this.#useCache = useCache;
  }

  get inboxService(): InboxService {
    return this._inboxService;
  }

  async list({ limit = 10, ...restOptions }: ListNotificationsArgs = {}): Result<ListNotificationsResponse> {
    return this.callWithSession(async () => {
      const args = { limit, ...restOptions };
      try {
        const shouldUseCache = 'useCache' in args ? args.useCache : this.#useCache;
        let data: ListNotificationsResponse | undefined = shouldUseCache ? this.cache.getAll(args) : undefined;
        this._emitter.emit('notifications.list.pending', { args, data });

        if (!data) {
          const response = await this._inboxService.fetchNotifications({
            limit,
            ...restOptions,
          });

          data = {
            hasMore: response.hasMore,
            filter: response.filter,
            notifications: response.data.map((el) => new Notification(el, this._emitter, this._inboxService)),
          };

          if (shouldUseCache) {
            this.cache.set(args, data);
            data = this.cache.getAll(args);
          }
        }

        this._emitter.emit('notifications.list.resolved', { args, data });

        return { data };
      } catch (error) {
        this._emitter.emit('notifications.list.resolved', { args, error });

        return { error: new NovuError('Failed to fetch notifications', error) };
      }
    });
  }

  async count(args?: FilterCountArgs): Result<FilterCountResponse>;
  async count(args?: FiltersCountArgs): Result<FiltersCountResponse>;
  async count(args: CountArgs): Result<CountResponse> {
    return this.callWithSession(async () => {
      const filters: NotificationFilter[] = args && 'filters' in args ? args.filters : [{ ...args }];

      try {
        this._emitter.emit('notifications.count.pending', { args });

        const response = await this._inboxService.count({
          filters,
        });

        const data = args && 'filters' in args ? { counts: response.data } : response.data[0];

        this._emitter.emit('notifications.count.resolved', {
          args,
          data,
        });

        return { data };
      } catch (error) {
        this._emitter.emit('notifications.count.resolved', { args, error });

        return { error: new NovuError('Failed to count notifications', error) };
      }
    });
  }

  async read(args: BaseArgs): Result<Notification>;
  async read(args: InstanceArgs): Result<Notification>;
  async read(args: ReadArgs): Result<Notification> {
    return this.callWithSession(async () =>
      read({
        emitter: this._emitter,
        apiService: this._inboxService,
        args,
      })
    );
  }

  async unread(args: BaseArgs): Result<Notification>;
  async unread(args: InstanceArgs): Result<Notification>;
  async unread(args: UnreadArgs): Result<Notification> {
    return this.callWithSession(async () =>
      unread({
        emitter: this._emitter,
        apiService: this._inboxService,
        args,
      })
    );
  }

  async seen(args: BaseArgs): Result<Notification>;
  async seen(args: InstanceArgs): Result<Notification>;
  async seen(args: SeenArgs): Result<Notification> {
    return this.callWithSession(async () =>
      seen({
        emitter: this._emitter,
        apiService: this._inboxService,
        args,
      })
    );
  }

  async archive(args: BaseArgs): Result<Notification>;
  async archive(args: InstanceArgs): Result<Notification>;
  async archive(args: ArchivedArgs): Result<Notification> {
    return this.callWithSession(async () =>
      archive({
        emitter: this._emitter,
        apiService: this._inboxService,
        args,
      })
    );
  }

  async unarchive(args: BaseArgs): Result<Notification>;
  async unarchive(args: InstanceArgs): Result<Notification>;
  async unarchive(args: UnarchivedArgs): Result<Notification> {
    return this.callWithSession(async () =>
      unarchive({
        emitter: this._emitter,
        apiService: this._inboxService,
        args,
      })
    );
  }

  async delete(args: BaseArgs): Result<void>;
  async delete(args: InstanceArgs): Result<void>;
  async delete(args: DeletedArgs): Result<void> {
    return this.callWithSession(async () =>
      deleteNotification({
        emitter: this._emitter,
        apiService: this._inboxService,
        args,
      })
    );
  }

  async snooze(args: SnoozeArgs): Result<Notification> {
    return this.callWithSession(async () =>
      snooze({
        emitter: this._emitter,
        apiService: this._inboxService,
        args,
      })
    );
  }

  async unsnooze(args: BaseArgs): Result<Notification>;
  async unsnooze(args: InstanceArgs): Result<Notification>;
  async unsnooze(args: UnsnoozeArgs): Result<Notification> {
    return this.callWithSession(async () =>
      unsnooze({
        emitter: this._emitter,
        apiService: this._inboxService,
        args,
      })
    );
  }

  async completePrimary(args: BaseArgs): Result<Notification>;
  async completePrimary(args: InstanceArgs): Result<Notification>;
  async completePrimary(args: CompleteArgs): Result<Notification> {
    return this.callWithSession(async () =>
      completeAction({
        emitter: this._emitter,
        apiService: this._inboxService,
        args,
        actionType: ActionTypeEnum.PRIMARY,
      })
    );
  }

  async completeSecondary(args: BaseArgs): Result<Notification>;
  async completeSecondary(args: InstanceArgs): Result<Notification>;
  async completeSecondary(args: CompleteArgs): Result<Notification> {
    return this.callWithSession(async () =>
      completeAction({
        emitter: this._emitter,
        apiService: this._inboxService,
        args,
        actionType: ActionTypeEnum.SECONDARY,
      })
    );
  }

  async revertPrimary(args: BaseArgs): Result<Notification>;
  async revertPrimary(args: InstanceArgs): Result<Notification>;
  async revertPrimary(args: RevertArgs): Result<Notification> {
    return this.callWithSession(async () =>
      revertAction({
        emitter: this._emitter,
        apiService: this._inboxService,
        args,
        actionType: ActionTypeEnum.PRIMARY,
      })
    );
  }

  async revertSecondary(args: BaseArgs): Result<Notification>;
  async revertSecondary(args: InstanceArgs): Result<Notification>;
  async revertSecondary(args: RevertArgs): Result<Notification> {
    return this.callWithSession(async () =>
      revertAction({
        emitter: this._emitter,
        apiService: this._inboxService,
        args,
        actionType: ActionTypeEnum.SECONDARY,
      })
    );
  }

  async readAll({
    tags,
    data,
  }: {
    tags?: NotificationFilter['tags'];
    data?: Record<string, unknown>;
  } = {}): Result<void> {
    return this.callWithSession(async () =>
      readAll({
        emitter: this._emitter,
        inboxService: this._inboxService,
        notificationsCache: this.cache,
        tags,
        data,
      })
    );
  }

  async seenAll(
    args:
      | { notificationIds: string[] }
      | { tags?: NotificationFilter['tags']; data?: Record<string, unknown> }
      | {} = {}
  ): Result<void> {
    return this.callWithSession(async () => {
      if ('notificationIds' in args) {
        return seenAll({
          emitter: this._emitter,
          inboxService: this._inboxService,
          notificationsCache: this.cache,
          notificationIds: args.notificationIds,
        });
      } else {
        return seenAll({
          emitter: this._emitter,
          inboxService: this._inboxService,
          notificationsCache: this.cache,
          tags: 'tags' in args ? args.tags : undefined,
          data: 'data' in args ? args.data : undefined,
        });
      }
    });
  }

  async archiveAll({
    tags,
    data,
  }: {
    tags?: NotificationFilter['tags'];
    data?: Record<string, unknown>;
  } = {}): Result<void> {
    return this.callWithSession(async () =>
      archiveAll({
        emitter: this._emitter,
        inboxService: this._inboxService,
        notificationsCache: this.cache,
        tags,
        data,
      })
    );
  }

  async archiveAllRead({ tags, data }: { tags?: string[]; data?: Record<string, unknown> } = {}): Result<void> {
    return this.callWithSession(async () =>
      archiveAllRead({
        emitter: this._emitter,
        inboxService: this._inboxService,
        notificationsCache: this.cache,
        tags,
        data,
      })
    );
  }

  async deleteAll({
    tags,
    data,
  }: {
    tags?: NotificationFilter['tags'];
    data?: Record<string, unknown>;
  } = {}): Result<void> {
    return this.callWithSession(async () =>
      deleteAll({
        emitter: this._emitter,
        inboxService: this._inboxService,
        notificationsCache: this.cache,
        tags,
        data,
      })
    );
  }

  clearCache({ filter }: { filter?: NotificationFilter } = {}): void {
    if (filter) {
      this.cache.clear(filter ?? {});
      return;
    }

    this.cache.clearAll();
  }

  async triggerHelloWorldEvent(): Promise<any> {
    return this._inboxService.triggerHelloWorldEvent();
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - ListNotificationsArgs({}): Result<ListNotificationsResponse> {
    return this.callWithSession(async ())
 - data({
            hasMore: response.hasMore,
            filter: response.filter,
            notificati...)
 - data(this.cache.getAll(args);
          }
        }

        this._emitter.emit('notifications.list.resol...)
 - data(args && 'filters' in args ? { counts: response.data } : response.data[0];

        this._emitter.emi...)
Declaraciones 'export' encontradas:
- export class Notifications

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/notifications/types.ts
Tamaño: 2113 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { ActionTypeEnum, NotificationFilter, SeverityLevelEnum } from '../types';
import { Notification } from './notification';

export type ListNotificationsArgs = {
  tags?: string[];
  read?: boolean;
  data?: Record<string, unknown>;
  archived?: boolean;
  snoozed?: boolean;
  seen?: boolean;
  severity?: SeverityLevelEnum | SeverityLevelEnum[];
  limit?: number;
  after?: string;
  offset?: number;
  useCache?: boolean;
};

export type ListNotificationsResponse = { notifications: Notification[]; hasMore: boolean; filter: NotificationFilter };

export type FilterCountArgs = {
  tags?: string[];
  data?: Record<string, unknown>;
  read?: boolean;
  archived?: boolean;
  snoozed?: boolean;
  seen?: boolean;
  severity?: SeverityLevelEnum | SeverityLevelEnum[];
};

export type FiltersCountArgs = {
  filters: Array<{
    tags?: string[];
    read?: boolean;
    archived?: boolean;
    snoozed?: boolean;
    seen?: boolean;
    data?: Record<string, unknown>;
    severity?: SeverityLevelEnum | SeverityLevelEnum[];
  }>;
};

export type CountArgs = undefined | FilterCountArgs | FiltersCountArgs;

export type FilterCountResponse = {
  count: number;
  filter: NotificationFilter;
};

export type FiltersCountResponse = {
  counts: Array<{
    count: number;
    filter: NotificationFilter;
  }>;
};

export type CountResponse = FilterCountResponse | FiltersCountResponse;

export type BaseArgs = {
  notificationId: string;
};

export type InstanceArgs = {
  notification: Notification;
};

export type ActionTypeArgs = { actionType: ActionTypeEnum };

export type ReadArgs = BaseArgs | InstanceArgs;
export type UnreadArgs = BaseArgs | InstanceArgs;
export type ArchivedArgs = BaseArgs | InstanceArgs;
export type UnarchivedArgs = BaseArgs | InstanceArgs;
export type DeletedArgs = BaseArgs | InstanceArgs;
export type SeenArgs = BaseArgs | InstanceArgs;
export type SnoozeArgs = (BaseArgs | InstanceArgs) & {
  snoozeUntil: string;
};
export type UnsnoozeArgs = BaseArgs | InstanceArgs;
export type CompleteArgs = BaseArgs | InstanceArgs;
export type RevertArgs = BaseArgs | InstanceArgs;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/notifications/visibility-tracker.ts
Tamaño: 8581 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { InboxService } from '../api';

interface VisibilityOptions {
  intersectionThreshold: number; // default: 0.5 (50% visible)
  visibilityDuration: number; // default: 1000ms (1 second)
  batchDelay: number; // default: 500ms
  maxBatchSize: number; // default: 20
  enabled: boolean; // default: true
  rootMargin: string; // default: '0px'
}

const DEFAULT_OPTIONS: VisibilityOptions = {
  intersectionThreshold: 0.5,
  visibilityDuration: 1000,
  batchDelay: 500,
  maxBatchSize: 20,
  enabled: true,
  rootMargin: '0px',
};

export class NotificationVisibilityTracker {
  /*
   * Session-based tracking: notifications marked as seen in current session won't be marked again
   * Only resets when tracker is destroyed (inbox closes)
   */
  private seenNotifications = new Set<string>();
  private pendingNotifications = new Map<string, number>();
  private pendingBatch = new Set<string>();
  private batchTimer: number | null = null;
  private visibilityTimer: number | null = null;
  private observer: IntersectionObserver | null = null;
  private elementToNotificationMap = new WeakMap<Element, string>();
  private observedElements = new Set<Element>();
  private options: VisibilityOptions;

  constructor(
    private inboxService: InboxService,
    options: Partial<VisibilityOptions> = {}
  ) {
    this.options = { ...DEFAULT_OPTIONS, ...options };
    this.initializeObserver();
    this.startVisibilityTimer();
  }

  private initializeObserver(): void {
    if (!this.options.enabled || typeof window === 'undefined' || !('IntersectionObserver' in window)) {
      return;
    }

    this.observer = new IntersectionObserver((entries) => this.handleIntersection(entries), {
      threshold: this.options.intersectionThreshold,
      rootMargin: this.options.rootMargin,
    });
  }

  private startVisibilityTimer(): void {
    if (!this.options.enabled || typeof window === 'undefined') {
      return;
    }

    /*
     * Do an immediate check to update tracking state for any already-visible notifications
     * This won't mark them as seen yet, just starts tracking their visibility duration
     */
    this.checkAllElementsVisibility();

    // Continue checking every second to track visibility duration
    this.visibilityTimer = window.setInterval(() => {
      this.checkAllElementsVisibility();
    }, 1000);
  }

  private checkAllElementsVisibility(): void {
    // Check all observed elements manually
    this.observedElements.forEach((element) => {
      const notificationId = this.elementToNotificationMap.get(element);
      // Skip if already marked as seen in this session
      if (!notificationId || this.seenNotifications.has(notificationId)) {
        return;
      }

      const rect = element.getBoundingClientRect();
      const isVisible = this.isElementVisible(rect);

      if (isVisible) {
        // If not already tracking, start tracking
        if (!this.pendingNotifications.has(notificationId)) {
          this.pendingNotifications.set(notificationId, Date.now());
        }
      } else {
        // Not visible anymore, stop tracking
        this.pendingNotifications.delete(notificationId);
      }
    });

    // Process notifications that have been visible long enough
    this.processVisibleNotifications();
  }

  private isElementVisible(rect: DOMRect): boolean {
    const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
    const viewportWidth = window.innerWidth || document.documentElement.clientWidth;

    // Check if element is in viewport
    const verticalInView = rect.top < viewportHeight && rect.bottom > 0;
    const horizontalInView = rect.left < viewportWidth && rect.right > 0;

    if (!verticalInView || !horizontalInView) {
      return false;
    }

    // Calculate how much of the element is visible
    const visibleHeight = Math.min(rect.bottom, viewportHeight) - Math.max(rect.top, 0);
    const visibleWidth = Math.min(rect.right, viewportWidth) - Math.max(rect.left, 0);
    const visibleArea = visibleHeight * visibleWidth;
    const totalArea = rect.height * rect.width;

    // Check if visible area meets threshold
    return totalArea > 0 && visibleArea / totalArea >= this.options.intersectionThreshold;
  }

  private handleIntersection(entries: IntersectionObserverEntry[]): void {
    const now = Date.now();

    entries.forEach((entry) => {
      const notificationId = this.elementToNotificationMap.get(entry.target);
      if (!notificationId || this.seenNotifications.has(notificationId)) {
        return;
      }

      if (entry.isIntersecting) {
        this.pendingNotifications.set(notificationId, now);
      } else {
        this.pendingNotifications.delete(notificationId);
      }
    });

    // Process notifications that have been visible long enough
    this.processVisibleNotifications();
  }

  private processVisibleNotifications(): void {
    const now = Date.now();
    const notificationsToMark: string[] = [];

    this.pendingNotifications.forEach((startTime, notificationId) => {
      if (now - startTime >= this.options.visibilityDuration) {
        notificationsToMark.push(notificationId);
        // Add to session tracking - won't be marked as seen again until inbox reopens
        this.seenNotifications.add(notificationId);
      }
    });

    // Remove processed notifications from pending
    notificationsToMark.forEach((id) => {
      this.pendingNotifications.delete(id);
    });

    if (notificationsToMark.length > 0) {
      this.addToBatch(notificationsToMark);
    }
  }

  private addToBatch(notificationIds: string[]): void {
    // Add to current batch
    notificationIds.forEach((id) => {
      this.pendingBatch.add(id);
    });

    // Schedule processing if not already scheduled
    this.scheduleBatchProcessing();
  }

  private scheduleBatchProcessing(): void {
    if (this.batchTimer !== null) {
      return; // Already scheduled
    }

    this.batchTimer = window.setTimeout(() => {
      this.processBatch();
    }, this.options.batchDelay);
  }

  private async processBatch(): Promise<void> {
    this.batchTimer = null;

    // Get all notifications in the pending batch
    const notificationsToSend = Array.from(this.pendingBatch);
    this.pendingBatch.clear();

    if (notificationsToSend.length === 0) {
      return;
    }

    // Process in chunks if batch is too large
    const chunks = this.chunkArray(notificationsToSend, this.options.maxBatchSize);

    try {
      await Promise.all(chunks.map((chunk) => this.inboxService.markAsSeen({ notificationIds: chunk })));
    } catch (error) {
      // On error, remove the failed notifications from seen set so they can be retried
      notificationsToSend.forEach((id) => {
        this.seenNotifications.delete(id);
      });
      console.error('Failed to mark notifications as seen:', error);
    }
  }

  private chunkArray<T>(array: T[], size: number): T[][] {
    const chunks: T[][] = [];
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size));
    }

    return chunks;
  }

  observe(element: Element, notificationId: string): void {
    if (!this.observer || this.seenNotifications.has(notificationId)) {
      return;
    }

    this.elementToNotificationMap.set(element, notificationId);
    this.observedElements.add(element);
    this.observer.observe(element);
  }

  unobserve(element: Element): void {
    if (!this.observer) {
      return;
    }

    const notificationId = this.elementToNotificationMap.get(element);
    if (notificationId) {
      this.pendingNotifications.delete(notificationId);
      this.pendingBatch.delete(notificationId);
      this.elementToNotificationMap.delete(element);
      this.observedElements.delete(element);
    }

    this.observer.unobserve(element);
  }

  destroy(): void {
    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
    }

    if (this.batchTimer !== null) {
      window.clearTimeout(this.batchTimer);
      this.batchTimer = null;
    }

    if (this.visibilityTimer !== null) {
      window.clearInterval(this.visibilityTimer);
      this.visibilityTimer = null;
    }

    this.seenNotifications.clear();
    this.pendingNotifications.clear();
    this.pendingBatch.clear();
    this.observedElements.clear();
  }

  // Force process any pending batches (useful for cleanup)
  async flush(): Promise<void> {
    if (this.batchTimer !== null) {
      window.clearTimeout(this.batchTimer);
      this.batchTimer = null;
      await this.processBatch();
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - observer(new IntersectionObserver((entries))
 - visibilityTimer(window.setInterval(())
 - now(Date.now();

    entries.forEach((entry))
 - batchTimer(window.setTimeout(())
 - chunks(this.chunkArray(notificationsToSend, this.options.maxBatchSize);

    try {
      await Promise.all(...)
Declaraciones 'export' encontradas:
- export class NotificationVisibilityTracker

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/preferences/helpers.ts
Tamaño: 7419 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { InboxService } from '../api';
import { PreferencesCache } from '../cache/preferences-cache';
import { ScheduleCache } from '../cache/schedule-cache';
import type { NovuEventEmitter } from '../event-emitter';
import type { ChannelPreference, Result } from '../types';
import { ChannelType, PreferenceLevel } from '../types';
import { NovuError } from '../utils/errors';
import { Preference } from './preference';
import { Schedule } from './schedule';
import type { UpdatePreferenceArgs, UpdateScheduleArgs } from './types';

type UpdatePreferenceParams = {
  emitter: NovuEventEmitter;
  apiService: InboxService;
  cache: PreferencesCache;
  scheduleCache: ScheduleCache;
  useCache: boolean;
  args: UpdatePreferenceArgs;
};

type BulkUpdatePreferenceParams = {
  emitter: NovuEventEmitter;
  apiService: InboxService;
  cache: PreferencesCache;
  scheduleCache: ScheduleCache;
  useCache: boolean;
  args: Array<UpdatePreferenceArgs>;
};

type UpdateScheduleParams = {
  emitter: NovuEventEmitter;
  apiService: InboxService;
  cache: ScheduleCache;
  useCache: boolean;
  args: UpdateScheduleArgs;
};

export const updatePreference = async ({
  emitter,
  apiService,
  cache,
  scheduleCache,
  useCache,
  args,
}: UpdatePreferenceParams): Result<Preference> => {
  const { channels } = args;
  const workflowId = 'workflowId' in args ? args.workflowId : args.preference.workflow?.id;

  try {
    emitter.emit('preference.update.pending', {
      args,
      data:
        'preference' in args
          ? new Preference(
              {
                ...args.preference,
                channels: {
                  ...args.preference.channels,
                  ...channels,
                },
              },
              {
                emitterInstance: emitter,
                inboxServiceInstance: apiService,
                cache,
                scheduleCache,
                useCache,
              }
            )
          : undefined,
    });

    let response;
    if (workflowId) {
      response = await apiService.updateWorkflowPreferences({ workflowId, channels });
    } else {
      optimisticUpdateWorkflowPreferences({ emitter, apiService, cache, scheduleCache, useCache, args });
      response = await apiService.updateGlobalPreferences(channels);
    }

    const preference = new Preference(response, {
      emitterInstance: emitter,
      inboxServiceInstance: apiService,
      cache,
      scheduleCache,
      useCache,
    });
    emitter.emit('preference.update.resolved', { args, data: preference });

    return { data: preference };
  } catch (error) {
    emitter.emit('preference.update.resolved', { args, error });

    return { error: new NovuError('Failed to update preference', error) };
  }
};

export const bulkUpdatePreference = async ({
  emitter,
  apiService,
  cache,
  scheduleCache,
  useCache,
  args,
}: BulkUpdatePreferenceParams): Result<Preference[]> => {
  const globalPreference = args.find((arg) => 'preference' in arg && arg.preference.level === PreferenceLevel.GLOBAL);
  if (globalPreference) {
    return { error: new NovuError('Global preference is not supported in bulk update', '') };
  }

  try {
    const optimisticallyUpdatedPreferences = args
      .map((arg) =>
        'preference' in arg
          ? new Preference(
              {
                ...arg.preference,
                channels: {
                  ...arg.preference.channels,
                  ...arg.channels,
                },
              },
              {
                emitterInstance: emitter,
                inboxServiceInstance: apiService,
                cache,
                scheduleCache,
                useCache,
              }
            )
          : undefined
      )
      .filter((el) => el !== undefined);

    emitter.emit('preferences.bulk_update.pending', {
      args,
      data: optimisticallyUpdatedPreferences,
    });

    const preferencesToUpdate = args.map((arg) => ({
      workflowId:
        'workflowId' in arg
          ? arg.workflowId
          : (arg.preference.workflow?.id ?? arg.preference.workflow?.identifier ?? ''),
      ...arg.channels,
    }));
    const response = await apiService.bulkUpdatePreferences(preferencesToUpdate);

    const preferences = response.map(
      (el) =>
        new Preference(el, {
          emitterInstance: emitter,
          inboxServiceInstance: apiService,
          cache,
          scheduleCache,
          useCache,
        })
    );
    emitter.emit('preferences.bulk_update.resolved', { args, data: preferences });

    return { data: preferences };
  } catch (error) {
    emitter.emit('preferences.bulk_update.resolved', { args, error });

    return { error: new NovuError('Failed to bulk update preferences', error) };
  }
};

const optimisticUpdateWorkflowPreferences = ({
  emitter,
  apiService,
  cache,
  scheduleCache,
  useCache,
  args,
}: UpdatePreferenceParams): void => {
  const allPreferences = useCache ? cache?.getAll({}) : undefined;

  allPreferences?.forEach((el) => {
    if (el.level === PreferenceLevel.TEMPLATE) {
      const mergedPreference = {
        ...el,
        channels: Object.entries(el.channels).reduce((acc, [key, value]) => {
          const channelType = key as ChannelType;
          acc[channelType] = args.channels[channelType] ?? value;

          return acc;
        }, {} as ChannelPreference),
      };
      const updatedPreference =
        'preference' in args
          ? new Preference(mergedPreference, {
              emitterInstance: emitter,
              inboxServiceInstance: apiService,
              cache,
              scheduleCache,
              useCache,
            })
          : undefined;

      if (updatedPreference) {
        emitter.emit('preference.update.pending', {
          args: {
            workflowId: el.workflow?.id ?? '',
            channels: updatedPreference.channels,
          },
          data: updatedPreference,
        });
      }
    }
  });
};

export const updateSchedule = async ({
  emitter,
  apiService,
  cache,
  useCache,
  args,
}: UpdateScheduleParams): Result<Schedule> => {
  try {
    const { isEnabled, weeklySchedule } = args;
    const optimisticallyUpdatedSchedule = new Schedule(
      {
        isEnabled,
        weeklySchedule,
      },
      {
        emitterInstance: emitter,
        inboxServiceInstance: apiService,
        cache,
        useCache,
      }
    );
    emitter.emit('preference.schedule.update.pending', { args, data: optimisticallyUpdatedSchedule });

    // Call the API to update global preferences
    const response = await apiService.updateGlobalPreferences({
      schedule: {
        isEnabled,
        weeklySchedule,
      },
    });

    // Create new Schedule instance with updated data
    const updatedSchedule = new Schedule(
      {
        isEnabled: response.schedule?.isEnabled,
        weeklySchedule: response.schedule?.weeklySchedule,
      },
      {
        emitterInstance: emitter,
        inboxServiceInstance: apiService,
        cache,
        useCache,
      }
    );

    emitter.emit('preference.schedule.update.resolved', {
      args,
      data: updatedSchedule,
    });

    return { data: updatedSchedule };
  } catch (error) {
    emitter.emit('preference.schedule.update.resolved', { args, error });
    return { error: new NovuError('Failed to update preference', error) };
  }
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - updatePreference(async ({
  emitter,
  apiService,
  cache,
  scheduleCache,
  useCache,
  args,
}: UpdatePreferenceP...)
 - bulkUpdatePreference(async ({
  emitter,
  apiService,
  cache,
  scheduleCache,
  useCache,
  args,
}: BulkUpdatePrefere...)
 - globalPreference(args.find((arg))
 - optimisticallyUpdatedPreferences(args
      .map((arg))
 - preferencesToUpdate(args.map((arg))
 - preferences(response.map(
      (el))
 - optimisticUpdateWorkflowPreferences({
  emitter,
  apiService,
  cache,
  scheduleCache,
  useCache,
  args,
}: UpdatePreferenceParams):...)
 - allPreferences(useCache ? cache?.getAll({}) : undefined;

  allPreferences?.forEach((el))
 - mergedPreference({
        ...el,
        channels: Object.entries(el.channels).reduce((acc, [key, value]))
 - updateSchedule(async ({
  emitter,
  apiService,
  cache,
  useCache,
  args,
}: UpdateScheduleParams): Result<Sche...)
Declaraciones 'export' encontradas:
- export  const
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/preferences/index.ts
Tamaño: 98 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './preference-schedule';
export * from './preferences';
export * from './schedule';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/preferences/preference-schedule.ts
Tamaño: 2366 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { InboxService } from '../api';
import { BaseModule } from '../base-module';
import { ScheduleCache } from '../cache/schedule-cache';
import { NovuEventEmitter } from '../event-emitter';
import { Result } from '../types';
import { updateSchedule } from './helpers';
import { Schedule } from './schedule';
import { UpdateScheduleArgs } from './types';

export class PreferenceSchedule extends BaseModule {
  #useCache: boolean;

  readonly cache: ScheduleCache;

  constructor({
    cache,
    useCache,
    inboxServiceInstance,
    eventEmitterInstance,
  }: {
    cache: ScheduleCache;
    useCache: boolean;
    inboxServiceInstance: InboxService;
    eventEmitterInstance: NovuEventEmitter;
  }) {
    super({
      eventEmitterInstance,
      inboxServiceInstance,
    });
    this.cache = cache;
    this.#useCache = useCache;
  }

  async get(): Result<Schedule> {
    return this.callWithSession(async () => {
      try {
        let data: Schedule | undefined = this.#useCache ? this.cache.getAll() : undefined;
        this._emitter.emit('preference.schedule.get.pending', { args: undefined, data });

        if (!data) {
          const globalPreference = await this._inboxService.fetchGlobalPreferences();

          data = new Schedule(
            {
              isEnabled: globalPreference?.schedule?.isEnabled,
              weeklySchedule: globalPreference?.schedule?.weeklySchedule,
            },
            {
              emitterInstance: this._emitter,
              inboxServiceInstance: this._inboxService,
              cache: this.cache,
              useCache: this.#useCache,
            }
          );

          if (this.#useCache) {
            this.cache.set(data);
            data = this.cache.getAll();
          }
        }

        this._emitter.emit('preference.schedule.get.resolved', {
          args: undefined,
          data,
        });

        return { data };
      } catch (error) {
        this._emitter.emit('preference.schedule.get.resolved', { args: undefined, error });
        throw error;
      }
    });
  }

  async update(args: UpdateScheduleArgs): Result<Schedule> {
    return this.callWithSession(() =>
      updateSchedule({
        emitter: this._emitter,
        apiService: this._inboxService,
        cache: this.cache,
        useCache: this.#useCache,
        args,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - useCache(useCache;
  }

  async get(): Result<Schedule> {
    return this.callWithSession(async ())
 - data(this.cache.getAll();
          }
        }

        this._emitter.emit('preference.schedule.get.reso...)
Declaraciones 'export' encontradas:
- export class PreferenceSchedule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/preferences/preference.ts
Tamaño: 2326 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { InboxService } from '../api';
import { PreferencesCache } from '../cache/preferences-cache';
import { ScheduleCache } from '../cache/schedule-cache';
import { NovuEventEmitter } from '../event-emitter';
import { ChannelPreference, PreferenceLevel, Prettify, Result, Workflow } from '../types';
import { updatePreference } from './helpers';
import { Schedule, ScheduleLike } from './schedule';
import { UpdatePreferenceArgs } from './types';

type PreferenceLike = Pick<Preference, 'level' | 'enabled' | 'channels' | 'workflow'> & { schedule?: ScheduleLike };

export class Preference {
  #emitter: NovuEventEmitter;
  #apiService: InboxService;
  #cache: PreferencesCache;
  #scheduleCache: ScheduleCache;
  #useCache: boolean;

  readonly level: PreferenceLevel;
  readonly enabled: boolean;
  readonly channels: ChannelPreference;
  readonly workflow?: Workflow;
  schedule: Schedule;

  constructor(
    preference: PreferenceLike,
    {
      emitterInstance,
      inboxServiceInstance,
      cache,
      scheduleCache,
      useCache,
    }: {
      emitterInstance: NovuEventEmitter;
      inboxServiceInstance: InboxService;
      cache: PreferencesCache;
      scheduleCache: ScheduleCache;
      useCache: boolean;
    }
  ) {
    this.#emitter = emitterInstance;
    this.#apiService = inboxServiceInstance;
    this.#cache = cache;
    this.#scheduleCache = scheduleCache;
    this.#useCache = useCache;
    this.level = preference.level;
    this.enabled = preference.enabled;
    this.channels = preference.channels;
    this.workflow = preference.workflow;
    this.schedule = new Schedule(
      { ...preference.schedule },
      { emitterInstance, inboxServiceInstance, cache: scheduleCache, useCache }
    );
  }

  update({
    channels,
    channelPreferences,
  }: Prettify<
    Pick<UpdatePreferenceArgs, 'channels'> & {
      /** @deprecated Use channels instead */
      channelPreferences?: ChannelPreference;
    }
  >): Result<Preference> {
    return updatePreference({
      emitter: this.#emitter,
      apiService: this.#apiService,
      cache: this.#cache,
      scheduleCache: this.#scheduleCache,
      useCache: this.#useCache,
      args: {
        workflowId: this.workflow?.id,
        channels: channels || channelPreferences,
        preference: this,
      },
    });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Preference

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/preferences/preferences.ts
Tamaño: 3680 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { InboxService } from '../api';
import { BaseModule } from '../base-module';
import { PreferencesCache } from '../cache/preferences-cache';
import { ScheduleCache } from '../cache/schedule-cache';
import { NovuEventEmitter } from '../event-emitter';
import { Result, WorkflowCriticalityEnum } from '../types';
import { bulkUpdatePreference, updatePreference } from './helpers';
import { Preference } from './preference';
import { PreferenceSchedule } from './preference-schedule';
import type { BasePreferenceArgs, InstancePreferenceArgs, ListPreferencesArgs, UpdatePreferenceArgs } from './types';

export class Preferences extends BaseModule {
  #useCache: boolean;

  readonly cache: PreferencesCache;
  readonly scheduleCache: ScheduleCache;
  readonly schedule: PreferenceSchedule;

  constructor({
    useCache,
    inboxServiceInstance,
    eventEmitterInstance,
  }: {
    useCache: boolean;
    inboxServiceInstance: InboxService;
    eventEmitterInstance: NovuEventEmitter;
  }) {
    super({
      eventEmitterInstance,
      inboxServiceInstance,
    });
    this.cache = new PreferencesCache({
      emitterInstance: this._emitter,
    });
    this.scheduleCache = new ScheduleCache({
      emitterInstance: this._emitter,
    });
    this.#useCache = useCache;
    this.schedule = new PreferenceSchedule({
      cache: this.scheduleCache,
      useCache,
      inboxServiceInstance,
      eventEmitterInstance,
    });
  }

  async list(args: ListPreferencesArgs = {}): Result<Preference[]> {
    return this.callWithSession(async () => {
      try {
        let data = this.#useCache ? this.cache.getAll(args) : undefined;
        this._emitter.emit('preferences.list.pending', { args, data });

        if (!data) {
          const response = await this._inboxService.fetchPreferences({
            tags: args.tags,
            severity: args.severity,
            criticality: args.criticality ?? WorkflowCriticalityEnum.NON_CRITICAL,
          });
          data = response.map(
            (el) =>
              new Preference(el, {
                emitterInstance: this._emitter,
                inboxServiceInstance: this._inboxService,
                cache: this.cache,
                scheduleCache: this.scheduleCache,
                useCache: this.#useCache,
              })
          );

          if (this.#useCache) {
            this.cache.set(args, data);
            data = this.cache.getAll(args);
          }
        }

        this._emitter.emit('preferences.list.resolved', { args, data });

        return { data };
      } catch (error) {
        this._emitter.emit('preferences.list.resolved', { args, error });
        throw error;
      }
    });
  }

  async update(args: BasePreferenceArgs): Result<Preference>;
  async update(args: InstancePreferenceArgs): Result<Preference>;
  async update(args: UpdatePreferenceArgs): Result<Preference> {
    return this.callWithSession(() =>
      updatePreference({
        emitter: this._emitter,
        apiService: this._inboxService,
        cache: this.cache,
        scheduleCache: this.scheduleCache,
        useCache: this.#useCache,
        args,
      })
    );
  }

  async bulkUpdate(args: Array<BasePreferenceArgs>): Result<Preference[]>;
  async bulkUpdate(args: Array<InstancePreferenceArgs>): Result<Preference[]>;
  async bulkUpdate(args: Array<UpdatePreferenceArgs>): Result<Preference[]> {
    return this.callWithSession(() =>
      bulkUpdatePreference({
        emitter: this._emitter,
        apiService: this._inboxService,
        cache: this.cache,
        scheduleCache: this.scheduleCache,
        useCache: this.#useCache,
        args,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - ListPreferencesArgs({}): Result<Preference[]> {
    return this.callWithSession(async ())
 - data(response.map(
            (el))
 - data(this.cache.getAll(args);
          }
        }

        this._emitter.emit('preferences.list.resolve...)
Declaraciones 'export' encontradas:
- export class Preferences

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/preferences/schedule.ts
Tamaño: 1669 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { InboxService } from '../api';
import { ScheduleCache } from '../cache/schedule-cache';
import { NovuEventEmitter } from '../event-emitter';
import { Result, WeeklySchedule } from '../types';
import { updateSchedule } from './helpers';
import { UpdateScheduleArgs } from './types';

export type ScheduleLike = Partial<Pick<Schedule, 'isEnabled' | 'weeklySchedule'>>;

export class Schedule {
  #emitter: NovuEventEmitter;
  #apiService: InboxService;
  #cache: ScheduleCache;
  #useCache: boolean;

  readonly isEnabled: boolean | undefined;
  readonly weeklySchedule: WeeklySchedule | undefined;

  constructor(
    schedule: ScheduleLike,
    {
      emitterInstance,
      inboxServiceInstance,
      cache,
      useCache,
    }: {
      emitterInstance: NovuEventEmitter;
      inboxServiceInstance: InboxService;
      cache: ScheduleCache;
      useCache: boolean;
    }
  ) {
    this.#emitter = emitterInstance;
    this.#apiService = inboxServiceInstance;
    this.#cache = cache;
    this.#useCache = useCache;
    this.isEnabled = schedule.isEnabled;
    this.weeklySchedule = schedule.weeklySchedule;
  }

  async update(args: UpdateScheduleArgs): Result<Schedule> {
    const hasWeeklySchedule = !!args.weeklySchedule || !!this.weeklySchedule;

    return updateSchedule({
      emitter: this.#emitter,
      apiService: this.#apiService,
      cache: this.#cache,
      useCache: this.#useCache,
      args: {
        isEnabled: args.isEnabled ?? this.isEnabled,
        ...(hasWeeklySchedule && {
          weeklySchedule: {
            ...this.weeklySchedule,
            ...args.weeklySchedule,
          },
        }),
      },
    });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export class Schedule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/preferences/types.ts
Tamaño: 854 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  ChannelPreference,
  Preference,
  PreferenceLevel,
  SeverityLevelEnum,
  WeeklySchedule,
  WorkflowCriticalityEnum,
} from '../types';

export type FetchPreferencesArgs = {
  level?: PreferenceLevel;
  tags?: string[];
  severity?: SeverityLevelEnum | SeverityLevelEnum[];
  criticality?: WorkflowCriticalityEnum;
};

export type ListPreferencesArgs = {
  tags?: string[];
  severity?: SeverityLevelEnum | SeverityLevelEnum[];
  criticality?: WorkflowCriticalityEnum;
};

export type BasePreferenceArgs = {
  workflowId: string;
  channels: ChannelPreference;
};

export type InstancePreferenceArgs = {
  preference: Preference;
  channels: ChannelPreference;
};

export type UpdatePreferenceArgs = BasePreferenceArgs | InstancePreferenceArgs;

export type UpdateScheduleArgs = {
  isEnabled?: boolean;
  weeklySchedule?: WeeklySchedule;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/session/index.ts
Tamaño: 52 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './session';
export * from './types';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/session/session.ts
Tamaño: 3749 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { InboxService } from '../api';
import { NovuEventEmitter } from '../event-emitter';
import { isBrowser } from '../utils/is-browser';
import { InitializeSessionArgs } from './types';

export class Session {
  #emitter: NovuEventEmitter;
  #inboxService: InboxService;
  #options: InitializeSessionArgs;

  constructor(
    options: InitializeSessionArgs,
    inboxServiceInstance: InboxService,
    eventEmitterInstance: NovuEventEmitter
  ) {
    this.#emitter = eventEmitterInstance;
    this.#inboxService = inboxServiceInstance;
    this.#options = options;
  }

  public get applicationIdentifier() {
    return this.#options.applicationIdentifier;
  }

  public get subscriberId() {
    return this.#options.subscriber?.subscriberId;
  }

  public get context() {
    return this.#options.context;
  }

  public get subscriberHash() {
    return this.#options.subscriberHash;
  }

  public get contextHash() {
    return this.#options.contextHash;
  }

  public get subscriber() {
    return this.#options.subscriber;
  }

  private handleApplicationIdentifier(method: 'get' | 'store' | 'delete', identifier?: string): string | null {
    if (typeof window === 'undefined' || !window.localStorage) {
      return null;
    }

    const key = 'novu_keyless_application_identifier';

    switch (method) {
      case 'get': {
        return window.localStorage.getItem(key);
      }

      case 'store': {
        if (identifier) {
          window.localStorage.setItem(key, identifier);
        }

        return null;
      }
      case 'delete': {
        window.localStorage.removeItem(key);

        return null;
      }
      default:
        return null;
    }
  }

  public async initialize(options?: InitializeSessionArgs): Promise<void> {
    const subscriberUnchanged = this.#options.subscriber?.subscriberId === options?.subscriber?.subscriberId;
    const contextUnchanged = JSON.stringify(this.#options.context) === JSON.stringify(options?.context);

    if (subscriberUnchanged && contextUnchanged) {
      return;
    }

    try {
      if (options) {
        this.#options = options;
      }
      const { subscriber, subscriberHash, contextHash, applicationIdentifier, defaultSchedule, context } =
        this.#options;
      let currentTimezone: string | undefined;
      if (isBrowser()) {
        currentTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
      }

      let finalApplicationIdentifier = applicationIdentifier;
      if (!finalApplicationIdentifier) {
        const storedAppId = this.handleApplicationIdentifier('get');
        if (storedAppId) {
          finalApplicationIdentifier = storedAppId;
        }
      } else {
        this.handleApplicationIdentifier('delete');
      }
      this.#emitter.emit('session.initialize.pending', { args: this.#options });

      const response = await this.#inboxService.initializeSession({
        applicationIdentifier: finalApplicationIdentifier,
        subscriberHash,
        contextHash,
        subscriber: {
          ...subscriber,
          subscriberId: subscriber?.subscriberId ?? '',
          timezone: subscriber?.timezone ?? currentTimezone,
        },
        defaultSchedule,
        context,
      });

      if (response?.applicationIdentifier?.startsWith('pk_keyless_')) {
        this.handleApplicationIdentifier('store', response.applicationIdentifier);
      }

      if (!response?.applicationIdentifier?.startsWith('pk_keyless_')) {
        this.handleApplicationIdentifier('delete');
      }

      this.#emitter.emit('session.initialize.resolved', { args: this.#options, data: response });
    } catch (error) {
      this.#emitter.emit('session.initialize.resolved', { args: this.#options, error });
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Session

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/session/types.ts
Tamaño: 459 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Context, DefaultSchedule, Subscriber } from '../types';

export type KeylessInitializeSessionArgs = {} & { [K in string]?: never }; // empty object,disallows all unknown keys

export type InitializeSessionArgs =
  | KeylessInitializeSessionArgs
  | {
      applicationIdentifier: string;
      subscriber: Subscriber;
      subscriberHash?: string;
      contextHash?: string;
      defaultSchedule?: DefaultSchedule;
      context?: Context;
    };


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/index.css
Tamaño: 7851 bytes
Lenguaje detectado: CSS

### CONTENIDO ORIGINAL ###

.novu {
  :where(*),
  :where(*) ::before,
  :where(*) ::after,
  :where(*)::before,
  :where(*)::after {
    box-sizing: border-box;
    border-width: 0;
    border-style: solid;
    border-color: #e5e7eb;
  }

  :where(html, :host) {
    line-height: 1.5; /* 1 */
    -webkit-text-size-adjust: 100%; /* 2 */
    -moz-tab-size: 4; /* 3 */
    -o-tab-size: 4;
    tab-size: 4; /* 3 */
    font-family:
      ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; /* 4 */
    font-feature-settings: normal; /* 5 */
    font-variation-settings: normal; /* 6 */
    -webkit-tap-highlight-color: transparent; /* 7 */
  }

  :where(body) {
    margin: 0; /* 1 */
    line-height: inherit; /* 2 */
  }

  :where(hr) {
    height: 0; /* 1 */
    color: inherit; /* 2 */
    border-top-width: 1px; /* 3 */
  }

  :where(abbr:where([title])) {
    -webkit-text-decoration: underline dotted;
    text-decoration: underline dotted;
  }

  :where(h1, h2, h3, h4, h5, h6) {
    font-size: inherit;
    font-weight: inherit;
  }

  :where(a) {
    color: inherit;
    text-decoration: inherit;
  }

  :where(b, strong) {
    font-weight: bolder;
  }

  :where(code, kbd, samp, pre) {
    font-family:
      ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; /* 1 */
    font-feature-settings: normal; /* 2 */
    font-variation-settings: normal; /* 3 */
    font-size: 1em; /* 4 */
  }

  :where(small) {
    font-size: 80%;
  }

  :where(sub, sup) {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
  }

  :where(sub) {
    bottom: -0.25em;
  }

  :where(sup) {
    top: -0.5em;
  }

  :where(table) {
    text-indent: 0; /* 1 */
    border-color: inherit; /* 2 */
    border-collapse: collapse; /* 3 */
  }

  :where(button, input, optgroup, select, textarea) {
    font-family: inherit; /* 1 */
    font-feature-settings: inherit; /* 1 */
    font-variation-settings: inherit; /* 1 */
    font-size: 100%; /* 1 */
    font-weight: inherit; /* 1 */
    line-height: inherit; /* 1 */
    letter-spacing: inherit; /* 1 */
    color: inherit; /* 1 */
    margin: 0; /* 2 */
    padding: 0; /* 3 */
  }

  :where(button, select) {
    text-transform: none;
  }

  :where(button, input:where([type="button"]), input:where([type="reset"]), input:where([type="submit"])) {
    -webkit-appearance: button; /* 1 */
    background-color: transparent; /* 2 */
    background-image: none; /* 2 */
  }

  :where(:-moz-focusring) {
    outline: auto;
  }

  :where(:-moz-ui-invalid) {
    box-shadow: none;
  }

  :where(progress) {
    vertical-align: baseline;
  }

  :where(*)::-webkit-inner-spin-button,
  :where(*)::-webkit-outer-spin-button {
    height: auto;
  }

  :where([type="search"]) {
    -webkit-appearance: textfield; /* 1 */
    outline-offset: -2px; /* 2 */
  }

  :where(*)::-webkit-search-decoration {
    -webkit-appearance: none;
  }

  :where(*)::-webkit-file-upload-button {
    -webkit-appearance: button; /* 1 */
    font: inherit; /* 2 */
  }

  :where(summary) {
    display: list-item;
  }

  :where(blockquote, dl, dd, h1, h2, h3, h4, h5, h6, hr, figure, p, pre) {
    margin: 0;
  }

  :where(fieldset) {
    margin: 0;
    padding: 0;
  }

  :where(legend) {
    padding: 0;
  }

  :where(ol, ul, menu) {
    list-style: none;
    margin: 0;
    padding: 0;
  }

  :where(dialog) {
    padding: 0;
  }

  :where(textarea) {
    resize: vertical;
  }

  :where(input)::-moz-placeholder,
  :where(textarea)::-moz-placeholder {
    opacity: 1; /* 1 */
    color: #9ca3af; /* 2 */
  }

  :where(input)::placeholder,
  :where(textarea)::placeholder {
    opacity: 1; /* 1 */
    color: #9ca3af; /* 2 */
  }

  :where(button, [role="button"]) {
    cursor: pointer;
  }

  :where(:disabled) {
    cursor: default;
  }

  :where(img, svg, video, canvas, audio, iframe, embed, object) {
    display: block; /* 1 */
    vertical-align: middle; /* 2 */
  }

  :where(img, video) {
    max-width: 100%;
    height: auto;
  }

  :where([hidden]) {
    display: none;
  }

  :where(*),
  :where(*) ::before,
  :where(*) ::after,
  :where(*)::before,
  :where(*)::after {
    --tw-border-spacing-x: 0;
    --tw-border-spacing-y: 0;
    --tw-translate-x: 0;
    --tw-translate-y: 0;
    --tw-rotate: 0;
    --tw-skew-x: 0;
    --tw-skew-y: 0;
    --tw-scale-x: 1;
    --tw-scale-y: 1;
    --tw-pan-x: ;
    --tw-pan-y: ;
    --tw-pinch-zoom: ;
    --tw-scroll-snap-strictness: proximity;
    --tw-gradient-from-position: ;
    --tw-gradient-via-position: ;
    --tw-gradient-to-position: ;
    --tw-ordinal: ;
    --tw-slashed-zero: ;
    --tw-numeric-figure: ;
    --tw-numeric-spacing: ;
    --tw-numeric-fraction: ;
    --tw-ring-inset: ;
    --tw-ring-offset-width: 0px;
    --tw-ring-offset-color: #fff;
    --tw-ring-color: rgb(59 130 246 / 0.5);
    --tw-ring-offset-shadow: 0 0 #0000;
    --tw-ring-shadow: 0 0 #0000;
    --tw-shadow: 0 0 #0000;
    --tw-shadow-colored: 0 0 #0000;
    --tw-blur: ;
    --tw-brightness: ;
    --tw-contrast: ;
    --tw-grayscale: ;
    --tw-hue-rotate: ;
    --tw-invert: ;
    --tw-saturate: ;
    --tw-sepia: ;
    --tw-drop-shadow: ;
    --tw-backdrop-blur: ;
    --tw-backdrop-brightness: ;
    --tw-backdrop-contrast: ;
    --tw-backdrop-grayscale: ;
    --tw-backdrop-hue-rotate: ;
    --tw-backdrop-invert: ;
    --tw-backdrop-opacity: ;
    --tw-backdrop-saturate: ;
    --tw-backdrop-sepia: ;
    --tw-contain-size: ;
    --tw-contain-layout: ;
    --tw-contain-paint: ;
    --tw-contain-style: ;
  }

  :where(*) ::backdrop {
    --tw-border-spacing-x: 0;
    --tw-border-spacing-y: 0;
    --tw-translate-x: 0;
    --tw-translate-y: 0;
    --tw-rotate: 0;
    --tw-skew-x: 0;
    --tw-skew-y: 0;
    --tw-scale-x: 1;
    --tw-scale-y: 1;
    --tw-pan-x: ;
    --tw-pan-y: ;
    --tw-pinch-zoom: ;
    --tw-scroll-snap-strictness: proximity;
    --tw-gradient-from-position: ;
    --tw-gradient-via-position: ;
    --tw-gradient-to-position: ;
    --tw-ordinal: ;
    --tw-slashed-zero: ;
    --tw-numeric-figure: ;
    --tw-numeric-spacing: ;
    --tw-numeric-fraction: ;
    --tw-ring-inset: ;
    --tw-ring-offset-width: 0px;
    --tw-ring-offset-color: #fff;
    --tw-ring-color: rgb(59 130 246 / 0.5);
    --tw-ring-offset-shadow: 0 0 #0000;
    --tw-ring-shadow: 0 0 #0000;
    --tw-shadow: 0 0 #0000;
    --tw-shadow-colored: 0 0 #0000;
    --tw-blur: ;
    --tw-brightness: ;
    --tw-contrast: ;
    --tw-grayscale: ;
    --tw-hue-rotate: ;
    --tw-invert: ;
    --tw-saturate: ;
    --tw-sepia: ;
    --tw-drop-shadow: ;
    --tw-backdrop-blur: ;
    --tw-backdrop-brightness: ;
    --tw-backdrop-contrast: ;
    --tw-backdrop-grayscale: ;
    --tw-backdrop-hue-rotate: ;
    --tw-backdrop-invert: ;
    --tw-backdrop-opacity: ;
    --tw-backdrop-saturate: ;
    --tw-backdrop-sepia: ;
    --tw-contain-size: ;
    --tw-contain-layout: ;
    --tw-contain-paint: ;
    --tw-contain-style: ;
  }

  /* Scrollbar */
  scrollbar-color: var(--nv-color-secondary-foreground-alpha-300) transparent;

  /* Webkit Safari */
  ::-webkit-scrollbar {
    width: 0.5rem;
    height: 0.5rem;
  }

  ::-webkit-scrollbar-thumb {
    background-color: var(--nv-color-secondary-foreground-alpha-300);
    border-radius: 0.25rem;
    background-clip: "padding-box";
  }

  ::-webkit-scrollbar-track,
  ::-webkit-scrollbar-corner {
    background-color: transparent;
  }

  input::-webkit-outer-spin-button,
  input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  /* Hide spin buttons in Firefox */
  input[type="number"] {
    -moz-appearance: textfield;
  }
}

/* biome-ignore lint/suspicious/noUnknownAtRules: tailwind */
@tailwind components;
/* biome-ignore lint/suspicious/noUnknownAtRules: tailwind */
@tailwind utilities;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

.novu {
:where(*),
:where(*) ::before,
:where(*) ::after,
:where(*)::before,
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/index.ts
Tamaño: 741 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export type { Notification } from '../notifications';
export type { InboxPage, InboxProps } from './components';
export type { BaseNovuUIOptions, NovuUIOptions } from './novuUI';
export { NovuUI } from './novuUI';
export {
  Appearance,
  AppearanceCallback,
  AppearanceCallbackFunction,
  AppearanceCallbackKeys,
  AppearanceKey,
  BellRenderer,
  BodyRenderer,
  ElementStyles,
  Elements,
  IconKey,
  IconOverrides,
  IconRenderer,
  Localization,
  LocalizationKey,
  NotificationActionClickHandler,
  NotificationClickHandler,
  NotificationRenderer,
  NotificationStatus,
  NovuProviderProps,
  PreferenceGroups,
  PreferencesFilter,
  PreferencesSort,
  RouterPush,
  SubjectRenderer,
  Tab,
  Theme,
  Variables,
} from './types';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/novuUI.tsx
Tamaño: 6785 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Accessor, ComponentProps, createSignal, Setter } from 'solid-js';
import { MountableElement, render } from 'solid-js/web';
import type { NovuOptions } from '../types';
import { NovuComponent, NovuComponentName, novuComponents, Renderer } from './components/Renderer';
import { generateRandomString } from './helpers';
import type {
  Appearance,
  BaseNovuProviderProps,
  Localization,
  NovuProviderProps,
  PreferenceGroups,
  PreferencesFilter,
  PreferencesSort,
  RouterPush,
  Tab,
} from './types';

export type NovuUIOptions = NovuProviderProps;
export type BaseNovuUIOptions = BaseNovuProviderProps;
export class NovuUI {
  #dispose: (() => void) | null = null;
  #container: Accessor<Node | null | undefined>;
  #setContainer: Setter<Node | null | undefined>;
  #rootElement: HTMLElement;
  #mountedElements;
  #setMountedElements;
  #appearance;
  #setAppearance;
  #localization;
  #setLocalization;
  #options;
  #setOptions;
  #tabs: Accessor<Array<Tab>>;
  #setTabs;
  #routerPush: Accessor<RouterPush | undefined>;
  #setRouterPush: Setter<RouterPush | undefined>;
  #preferencesFilter: Accessor<PreferencesFilter | undefined>;
  #setPreferencesFilter: Setter<PreferencesFilter | undefined>;
  #preferenceGroups: Accessor<PreferenceGroups | undefined>;
  #setPreferenceGroups: Setter<PreferenceGroups | undefined>;
  #preferencesSort: Accessor<PreferencesSort | undefined>;
  #setPreferencesSort: Setter<PreferencesSort | undefined>;
  #predefinedNovu;
  id: string;

  constructor(props: NovuProviderProps) {
    this.id = generateRandomString(16);
    const [appearance, setAppearance] = createSignal(props.appearance);
    const [localization, setLocalization] = createSignal(props.localization);
    const [options, setOptions] = createSignal(props.options);
    const [mountedElements, setMountedElements] = createSignal(new Map<MountableElement, NovuComponent>());
    const [tabs, setTabs] = createSignal(props.tabs ?? []);
    const [preferencesFilter, setPreferencesFilter] = createSignal(props.preferencesFilter);
    const [preferenceGroups, setPreferenceGroups] = createSignal(props.preferenceGroups);
    const [preferencesSort, setPreferencesSort] = createSignal(props.preferencesSort);
    const [routerPush, setRouterPush] = createSignal(props.routerPush);
    const [container, setContainer] = createSignal(this.#getContainerElement(props.container));
    this.#mountedElements = mountedElements;
    this.#setMountedElements = setMountedElements;
    this.#appearance = appearance;
    this.#setAppearance = setAppearance;
    this.#localization = localization;
    this.#setLocalization = setLocalization;
    this.#options = options;
    this.#setOptions = setOptions;
    this.#tabs = tabs;
    this.#setTabs = setTabs;
    this.#routerPush = routerPush;
    this.#setRouterPush = setRouterPush;
    this.#predefinedNovu = props.novu;
    this.#preferencesFilter = preferencesFilter;
    this.#setPreferencesFilter = setPreferencesFilter;
    this.#preferenceGroups = preferenceGroups;
    this.#setPreferenceGroups = setPreferenceGroups;
    this.#preferencesSort = preferencesSort;
    this.#setPreferencesSort = setPreferencesSort;
    this.#container = container;
    this.#setContainer = setContainer;

    this.#mountComponentRenderer();
  }

  #getContainerElement(container?: Node | string | null): Node | null | undefined {
    if (container === null || container === undefined) {
      return container;
    }

    if (typeof container === 'string') {
      return document.querySelector(container) ?? document.getElementById(container);
    }

    return container;
  }

  #mountComponentRenderer(): void {
    if (this.#dispose !== null) {
      return;
    }

    this.#rootElement = document.createElement('div');
    this.#rootElement.setAttribute('id', `novu-ui-${this.id}`);

    const container = this.#container();
    (container ?? document.body).appendChild(this.#rootElement);

    const dispose = render(
      () => (
        <Renderer
          novuUI={this}
          nodes={this.#mountedElements()}
          options={this.#options()}
          appearance={this.#appearance()}
          localization={this.#localization()}
          tabs={this.#tabs()}
          preferencesFilter={this.#preferencesFilter()}
          preferenceGroups={this.#preferenceGroups()}
          preferencesSort={this.#preferencesSort()}
          routerPush={this.#routerPush()}
          novu={this.#predefinedNovu}
          container={this.#container()}
        />
      ),
      this.#rootElement
    );

    this.#dispose = dispose;
  }

  #updateComponentProps(element: MountableElement, props: unknown) {
    this.#setMountedElements((oldMountedElements) => {
      const newMountedElements = new Map(oldMountedElements);
      const mountedElement = newMountedElements.get(element);
      if (mountedElement) {
        newMountedElements.set(element, { ...mountedElement, props });
      }

      return newMountedElements;
    });
  }

  mountComponent<T extends NovuComponentName>({
    name,
    element,
    props: componentProps,
  }: {
    name: T;
    element: MountableElement;
    props?: ComponentProps<(typeof novuComponents)[T]>;
  }) {
    if (this.#mountedElements().has(element)) {
      return this.#updateComponentProps(element, componentProps);
    }

    this.#setMountedElements((oldNodes) => {
      const newNodes = new Map(oldNodes);
      newNodes.set(element, { name, props: componentProps });

      return newNodes;
    });
  }

  unmountComponent(element: MountableElement) {
    this.#setMountedElements((oldMountedElements) => {
      const newMountedElements = new Map(oldMountedElements);
      newMountedElements.delete(element);

      return newMountedElements;
    });
  }

  updateAppearance(appearance?: Appearance) {
    this.#setAppearance(appearance);
  }

  updateLocalization(localization?: Localization) {
    this.#setLocalization(localization);
  }

  updateOptions(options: NovuOptions) {
    this.#setOptions(options);
  }

  updateTabs(tabs?: Array<Tab>) {
    this.#setTabs(tabs ?? []);
  }

  updatePreferencesFilter(preferencesFilter?: PreferencesFilter) {
    this.#setPreferencesFilter(preferencesFilter);
  }

  updatePreferenceGroups(preferenceGroups?: PreferenceGroups) {
    this.#setPreferenceGroups(preferenceGroups);
  }

  updatePreferencesSort(preferencesSort?: PreferencesSort) {
    this.#setPreferencesSort(() => preferencesSort);
  }

  updateRouterPush(routerPush?: RouterPush) {
    this.#setRouterPush(() => routerPush);
  }

  updateContainer(container?: Node | string | null) {
    this.#setContainer(this.#getContainerElement(container));
  }

  unmount(): void {
    this.#dispose?.();
    this.#dispose = null;
    this.#rootElement?.remove();
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Accessor, ComponentProps, createSignal, Setter } from 'solid-js';
import { MountableElement, render } from 'solid-js/web';
import type { NovuOptions } from '../types';
import { NovuComponent, NovuComponentName, novuComponents, Renderer } from './components/Renderer';
import { generateRandomString } from './helpers';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/types.ts
Tamaño: 12987 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Schedule } from 'src/preferences';
import type { Notification } from '../notifications';
import { Novu } from '../novu';
import {
  type NotificationFilter,
  type NovuOptions,
  type Preference,
  type UnreadCount,
  WorkflowCriticalityEnum,
} from '../types';
import { appearanceKeys } from './config';
import { Localization } from './context/LocalizationContext';

export type NotificationClickHandler = (notification: Notification) => void;
export type NotificationActionClickHandler = (notification: Notification) => void;

export type NotificationRenderer = (el: HTMLDivElement, notification: Notification) => () => void;
export type AvatarRenderer = (el: HTMLDivElement, notification: Notification) => () => void;
export type SubjectRenderer = (el: HTMLDivElement, notification: Notification) => () => void;
export type BodyRenderer = (el: HTMLDivElement, notification: Notification) => () => void;
export type DefaultActionsRenderer = (el: HTMLDivElement, notification: Notification) => () => void;
export type CustomActionsRenderer = (el: HTMLDivElement, notification: Notification) => () => void;
export type BellRenderer = (el: HTMLDivElement, unreadCount: UnreadCount) => () => void;
export type RouterPush = (path: string) => void;

export type Tab = {
  label: string;
  /**
   * @deprecated Use `filter` instead
   */
  value?: Array<string>;
  filter?: Pick<NotificationFilter, 'tags' | 'data' | 'severity'>;
};

export type CSSProperties = {
  [key: string]: string | number;
};

export type ElementStyles = string | CSSProperties;

export type Variables = {
  colorBackground?: string;
  colorForeground?: string;
  colorPrimary?: string;
  colorPrimaryForeground?: string;
  colorSecondary?: string;
  colorSecondaryForeground?: string;
  colorCounter?: string;
  colorCounterForeground?: string;
  colorNeutral?: string;
  colorShadow?: string;
  colorRing?: string;
  fontSize?: string;
  borderRadius?: string;
  colorStripes?: string;
  colorSeverityHigh?: string;
  colorSeverityMedium?: string;
  colorSeverityLow?: string;
};

export type AppearanceCallback = {
  // Bell
  bellDot: (context: { unreadCount: { total: number; severity: Record<string, number> } }) => string;
  bellIcon: (context: { unreadCount: { total: number; severity: Record<string, number> } }) => string;
  bellContainer: (context: { unreadCount: { total: number; severity: Record<string, number> } }) => string;
  severityHigh__bellContainer: (context: {
    unreadCount: { total: number; severity: Record<string, number> };
  }) => string;
  severityMedium__bellContainer: (context: {
    unreadCount: { total: number; severity: Record<string, number> };
  }) => string;
  severityLow__bellContainer: (context: { unreadCount: { total: number; severity: Record<string, number> } }) => string;
  bellSeverityGlow: (context: { unreadCount: { total: number; severity: Record<string, number> } }) => string;
  severityGlowHigh__bellSeverityGlow: (context: {
    unreadCount: { total: number; severity: Record<string, number> };
  }) => string;
  severityGlowMedium__bellSeverityGlow: (context: {
    unreadCount: { total: number; severity: Record<string, number> };
  }) => string;
  severityGlowLow__bellSeverityGlow: (context: {
    unreadCount: { total: number; severity: Record<string, number> };
  }) => string;

  // Preferences list shared between preferences and grouped preferences
  preferencesContainer: (context: {
    preferences?: Preference[];
    groups: Array<{ name: string; preferences: Preference[] }>;
  }) => string;

  // Preference
  workflowContainer: (context: { preference: Preference }) => string;
  workflowLabelContainer: (context: { preference: Preference }) => string;
  workflowLabelHeader: (context: { preference: Preference }) => string;
  workflowLabelHeaderContainer: (context: { preference: Preference }) => string;
  workflowLabelIcon: (context: { preference: Preference }) => string;
  workflowLabel: (context: { preference: Preference }) => string;
  workflowArrow__icon: (context: { preference: Preference }) => string;
  workflowContainerRight__icon: (context: { preference: Preference }) => string;

  // Channel
  channelsContainer: (context: { preference: Preference }) => string;
  channelName: (context: { preference: Preference }) => string;

  // Channel Row shared between preferences and grouped preferences
  channelContainer: (context: {
    preference?: Preference;
    preferenceGroup?: { name: string; preferences: Preference[] };
  }) => string;
  channelLabelContainer: (context: {
    preference?: Preference;
    preferenceGroup?: { name: string; preferences: Preference[] };
  }) => string;
  channelIconContainer: (context: {
    preference?: Preference;
    preferenceGroup?: { name: string; preferences: Preference[] };
  }) => string;
  channelLabel: (context: {
    preference?: Preference;
    preferenceGroup?: { name: string; preferences: Preference[] };
  }) => string;
  channelSwitchContainer: (context: {
    preference?: Preference;
    preferenceGroup?: { name: string; preferences: Preference[] };
  }) => string;
  channel__icon: (context: {
    preference?: Preference;
    preferenceGroup?: { name: string; preferences: Preference[] };
  }) => string;

  // Schedule
  scheduleContainer: (context: { schedule?: Schedule }) => string;
  scheduleHeader: (context: { schedule?: Schedule }) => string;
  scheduleLabelContainer: (context: { schedule?: Schedule }) => string;
  scheduleLabelScheduleIcon: (context: { schedule?: Schedule }) => string;
  scheduleLabelInfoIcon: (context: { schedule?: Schedule }) => string;
  scheduleLabel: (context: { schedule?: Schedule }) => string;
  scheduleActionsContainer: (context: { schedule?: Schedule }) => string;
  scheduleActionsContainerRight: (context: { schedule?: Schedule }) => string;
  scheduleBody: (context: { schedule?: Schedule }) => string;
  scheduleDescription: (context: { schedule?: Schedule }) => string;
  scheduleTable: (context: { schedule?: Schedule }) => string;
  scheduleTableHeader: (context: { schedule?: Schedule }) => string;
  scheduleHeaderColumn: (context: { schedule?: Schedule }) => string;
  scheduleTableBody: (context: { schedule?: Schedule }) => string;
  scheduleBodyRow: (context: { schedule?: Schedule }) => string;
  scheduleBodyColumn: (context: { schedule?: Schedule }) => string;
  scheduleInfoContainer: (context: { schedule?: Schedule }) => string;
  scheduleInfoIcon: (context: { schedule?: Schedule }) => string;
  scheduleInfo: (context: { schedule?: Schedule }) => string;

  // Day Schedule Copy
  dayScheduleCopyTitle: (context: { schedule?: Schedule }) => string;
  dayScheduleCopyIcon: (context: { schedule?: Schedule }) => string;
  dayScheduleCopySelectAll: (context: { schedule?: Schedule }) => string;
  dayScheduleCopyDay: (context: { schedule?: Schedule }) => string;
  dayScheduleCopyFooterContainer: (context: { schedule?: Schedule }) => string;

  // Preferences Group
  preferencesGroupContainer: (context: { preferenceGroup: { name: string; preferences: Preference[] } }) => string;
  preferencesGroupHeader: (context: { preferenceGroup: { name: string; preferences: Preference[] } }) => string;
  preferencesGroupLabelContainer: (context: { preferenceGroup: { name: string; preferences: Preference[] } }) => string;
  preferencesGroupLabelIcon: (context: { preferenceGroup: { name: string; preferences: Preference[] } }) => string;
  preferencesGroupLabel: (context: { preferenceGroup: { name: string; preferences: Preference[] } }) => string;
  preferencesGroupActionsContainer: (context: {
    preferenceGroup: { name: string; preferences: Preference[] };
  }) => string;
  preferencesGroupActionsContainerRight__icon: (context: {
    preferenceGroup: { name: string; preferences: Preference[] };
  }) => string;
  preferencesGroupBody: (context: { preferenceGroup: { name: string; preferences: Preference[] } }) => string;
  preferencesGroupChannels: (context: { preferenceGroup: { name: string; preferences: Preference[] } }) => string;
  preferencesGroupInfo: (context: { preferenceGroup: { name: string; preferences: Preference[] } }) => string;
  preferencesGroupInfoIcon: (context: { preferenceGroup: { name: string; preferences: Preference[] } }) => string;
  preferencesGroupWorkflows: (context: { preferenceGroup: { name: string; preferences: Preference[] } }) => string;

  // Notification list
  notificationList: (context: { notifications: Notification[] }) => string;
  notificationListContainer: (context: { notifications: Notification[] }) => string;

  // Notification
  notification: (context: { notification: Notification }) => string;
  severityHigh__notification: (context: { notification: Notification }) => string;
  severityMedium__notification: (context: { notification: Notification }) => string;
  severityLow__notification: (context: { notification: Notification }) => string;
  notificationBar: (context: { notification: Notification }) => string;
  severityHigh__notificationBar: (context: { notification: Notification }) => string;
  severityMedium__notificationBar: (context: { notification: Notification }) => string;
  severityLow__notificationBar: (context: { notification: Notification }) => string;
  notificationImageLoadingFallback: (context: { notification: Notification }) => string;
  notificationImage: (context: { notification: Notification }) => string;
  notificationContent: (context: { notification: Notification }) => string;
  notificationTextContainer: (context: { notification: Notification }) => string;
  notificationSubject: (context: { notification: Notification }) => string;
  notificationBody: (context: { notification: Notification }) => string;
  notificationDefaultActions: (context: { notification: Notification }) => string;
  notificationCustomActions: (context: { notification: Notification }) => string;
  notificationPrimaryAction__button: (context: { notification: Notification }) => string;
  notificationSecondaryAction__button: (context: { notification: Notification }) => string;
  notificationDate: (context: { notification: Notification }) => string;
  notificationDeliveredAt__badge: (context: { notification: Notification }) => string;
  notificationDeliveredAt__icon: (context: { notification: Notification }) => string;
  notificationSnoozedUntil__icon: (context: { notification: Notification }) => string;
  notificationDot: (context: { notification: Notification }) => string;
};
export type AppearanceCallbackKeys = keyof AppearanceCallback;
export type AppearanceCallbackFunction<K extends AppearanceCallbackKeys> = AppearanceCallback[K];
export type AppearanceKey = (typeof appearanceKeys)[number];
export type Elements = Partial<
  {
    // regular appearance keys with static styles
    [K in Exclude<AppearanceKey, AppearanceCallbackKeys>]: ElementStyles;
  } & {
    // callback keys that can be either static styles or callback functions
    [K in Extract<AppearanceKey, AppearanceCallbackKeys>]: ElementStyles | AppearanceCallbackFunction<K>;
  }
>;

export type IconKey =
  | 'bell'
  | 'clock'
  | 'arrowDropDown'
  | 'dots'
  | 'markAsRead'
  | 'cogs'
  | 'trash'
  | 'markAsArchived'
  | 'markAsArchivedRead'
  | 'markAsUnread'
  | 'markAsUnarchived'
  | 'unsnooze'
  | 'arrowRight'
  | 'arrowLeft'
  | 'unread'
  | 'sms'
  | 'inApp'
  | 'email'
  | 'push'
  | 'chat'
  | 'check'
  | 'arrowDown'
  | 'routeFill'
  | 'info'
  | 'nodeTree'
  | 'calendarSchedule'
  | 'copy';

export type IconRenderer = (el: HTMLDivElement, props: { class?: string }) => () => void;

export type IconOverrides = {
  [key in IconKey]?: IconRenderer;
};

export type Theme = {
  variables?: Variables;
  elements?: Elements;
  animations?: boolean;
  icons?: IconOverrides;
};
export type Appearance = Theme & { baseTheme?: Theme | Theme[] };

export type BaseNovuProviderProps = {
  container?: Node | string | null;
  appearance?: Appearance;
  localization?: Localization;
  options: NovuOptions;
  tabs?: Array<Tab>;
  preferencesFilter?: PreferencesFilter;
  preferenceGroups?: PreferenceGroups;
  preferencesSort?: PreferencesSort;
  routerPush?: RouterPush;
  novu?: Novu;
};

export type NovuProviderProps = BaseNovuProviderProps & {
  renderNotification?: NotificationRenderer;
  renderBell?: BellRenderer;
};

export enum NotificationStatus {
  UNREAD_READ = 'unreadRead',
  UNREAD = 'unread',
  ARCHIVED = 'archived',
  SNOOZED = 'snoozed',
}

export type PreferencesFilter = Pick<NotificationFilter, 'tags' | 'severity'> & {
  criticality?: WorkflowCriticalityEnum;
};

export type PreferencesSort = (a: Preference, b: Preference) => number;

type PreferenceFilterFunction = (args: { preferences: Preference[] }) => Preference[];

type PreferenceGroupFilter = (PreferencesFilter & { workflowIds?: string[] }) | PreferenceFilterFunction;

export type PreferenceGroups = Array<{
  name: string;
  filter: PreferenceGroupFilter;
}>;

export { Localization, LocalizationKey } from './context/LocalizationContext';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - NotificationClickHandler(notification: Notification))
 - NotificationActionClickHandler(notification: Notification))
 - NotificationRenderer(el: HTMLDivElement, notification: Notification))
 - AvatarRenderer(el: HTMLDivElement, notification: Notification))
 - SubjectRenderer(el: HTMLDivElement, notification: Notification))
 - BodyRenderer(el: HTMLDivElement, notification: Notification))
 - DefaultActionsRenderer(el: HTMLDivElement, notification: Notification))
 - CustomActionsRenderer(el: HTMLDivElement, notification: Notification))
 - BellRenderer(el: HTMLDivElement, unreadCount: UnreadCount))
 - RouterPush(path: string))
 - AppearanceCallback({
  // Bell
  bellDot: (context: { unreadCount: { total: number; severity: Record<string, number> } ...)
 - IconRenderer(el: HTMLDivElement, props: { class?: string }))
 - PreferencesSort(a: Preference, b: Preference))
 - PreferenceFilterFunction(args: { preferences: Preference[] }))
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  type
- export  enum
- export  type
- export  type
- export  type
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/api/index.ts
Tamaño: 25 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './hooks';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/api/hooks/index.ts
Tamaño: 202 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './useArchiveAll';
export * from './useArchiveAllRead';
export * from './useDeleteAll';
export * from './useNotifications';
export * from './usePreferences';
export * from './useReadAll';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/api/hooks/useArchiveAll.ts
Tamaño: 569 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { NotificationFilter } from '../../../types';
import { useNovu } from '../../context';

export const useArchiveAll = (props?: { onSuccess?: () => void; onError?: (err: unknown) => void }) => {
  const novu = useNovu();

  const archiveAll = async ({
    tags,
    data,
  }: {
    tags?: NotificationFilter['tags'];
    data?: Record<string, unknown>;
  } = {}) => {
    try {
      await novu.notifications.archiveAll({ tags, data });
      props?.onSuccess?.();
    } catch (error) {
      props?.onError?.(error);
    }
  };

  return { archiveAll };
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - useArchiveAll(props?: { onSuccess?: ())
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/api/hooks/useArchiveAllRead.ts
Tamaño: 588 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { NotificationFilter } from '../../../types';
import { useNovu } from '../../context';

export const useArchiveAllRead = (props?: { onSuccess?: () => void; onError?: (err: unknown) => void }) => {
  const novu = useNovu();

  const archiveAllRead = async ({
    tags,
    data,
  }: {
    tags?: NotificationFilter['tags'];
    data?: NotificationFilter['data'];
  } = {}) => {
    try {
      await novu.notifications.archiveAllRead({ tags, data });
      props?.onSuccess?.();
    } catch (error) {
      props?.onError?.(error);
    }
  };

  return { archiveAllRead };
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - useArchiveAllRead(props?: { onSuccess?: ())
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/api/hooks/useDeleteAll.ts
Tamaño: 565 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { NotificationFilter } from '../../../types';
import { useNovu } from '../../context';

export const useDeleteAll = (props?: { onSuccess?: () => void; onError?: (err: unknown) => void }) => {
  const novu = useNovu();

  const deleteAll = async ({
    tags,
    data,
  }: {
    tags?: NotificationFilter['tags'];
    data?: Record<string, unknown>;
  } = {}) => {
    try {
      await novu.notifications.deleteAll({ tags, data });
      props?.onSuccess?.();
    } catch (error) {
      props?.onError?.(error);
    }
  };

  return { deleteAll };
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - useDeleteAll(props?: { onSuccess?: ())
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/api/hooks/useNotifications.ts
Tamaño: 1786 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Accessor, createEffect, onCleanup, onMount } from 'solid-js';
import { ListNotificationsArgs, ListNotificationsResponse } from '../../../notifications';
import type { NotificationFilter } from '../../../types';
import { isSameFilter } from '../../../utils/notification-utils';
import { useNovu } from '../../context';
import { createInfiniteScroll } from '../../helpers';

type UseNotificationsInfiniteScrollProps = {
  options: Accessor<Exclude<ListNotificationsArgs, 'offset'>>;
};

export const useNotificationsInfiniteScroll = (props: UseNotificationsInfiniteScrollProps) => {
  const novu = useNovu();
  let filter = { ...props.options() };

  const [data, { initialLoading, setEl, end, mutate, reset }] = createInfiniteScroll(
    async (after) => {
      const { data } = await novu.notifications.list({ ...(props.options() || {}), after });

      return { data: data?.notifications ?? [], hasMore: data?.hasMore ?? false };
    },
    {
      paginationField: 'id',
    }
  );

  onMount(() => {
    const listener = ({ data }: { data: ListNotificationsResponse }) => {
      if (!data || !isSameFilter(filter, data.filter)) {
        return;
      }

      mutate({ data: data.notifications, hasMore: data.hasMore });
    };

    const cleanup = novu.on('notifications.list.updated', listener);

    onCleanup(() => cleanup());
  });

  createEffect(async () => {
    const newFilter = { ...props.options() };
    if (isSameFilter(filter, newFilter)) {
      return;
    }

    novu.notifications.clearCache();
    await reset();
    filter = newFilter;
  });

  const refetch = async ({ filter }: { filter?: NotificationFilter }) => {
    novu.notifications.clearCache({ filter });
    await reset();
  };

  return { data, initialLoading, setEl, end, refetch };
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - useNotificationsInfiniteScroll(props: UseNotificationsInfiniteScrollProps))
 - listener({ data }: { data: ListNotificationsResponse }))
 - cleanup(novu.on('notifications.list.updated', listener);

    onCleanup(())
 - refetch(async ({ filter }: { filter?: NotificationFilter }))
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/api/hooks/usePreferences.ts
Tamaño: 1146 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { createEffect, createResource, createSignal, onCleanup, onMount } from 'solid-js';
import { Preference } from '../../../preferences/preference';
import { FetchPreferencesArgs } from '../../../preferences/types';
import { useNovu } from '../../context';

export const usePreferences = (options?: FetchPreferencesArgs) => {
  const novu = useNovu();

  const [loading, setLoading] = createSignal(true);
  const [preferences, { mutate, refetch }] = createResource(options || {}, async ({ tags, severity, criticality }) => {
    try {
      const response = await novu.preferences.list({ tags, severity, criticality });

      return response.data;
    } catch (error) {
      console.error('Error fetching preferences:', error);
      throw error;
    }
  });

  onMount(() => {
    const listener = ({ data }: { data: Preference[] }) => {
      if (!data) {
        return;
      }

      mutate(data);
    };

    const cleanup = novu.on('preferences.list.updated', listener);

    onCleanup(() => cleanup());
  });

  createEffect(() => {
    setLoading(preferences.loading);
  });

  return { preferences, loading, mutate, refetch };
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - usePreferences(options?: FetchPreferencesArgs))
 - response(await novu.preferences.list({ tags, severity, criticality });

      return response.data;
    } cat...)
 - listener({ data }: { data: Preference[] }))
 - cleanup(novu.on('preferences.list.updated', listener);

    onCleanup(())
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/api/hooks/useReadAll.ts
Tamaño: 557 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { NotificationFilter } from '../../../types';
import { useNovu } from '../../context';

export const useReadAll = (props?: { onSuccess?: () => void; onError?: (err: unknown) => void }) => {
  const novu = useNovu();

  const readAll = async ({
    tags,
    data,
  }: {
    tags?: NotificationFilter['tags'];
    data?: Record<string, unknown>;
  } = {}) => {
    try {
      await novu.notifications.readAll({ tags, data });
      props?.onSuccess?.();
    } catch (error) {
      props?.onError?.(error);
    }
  };

  return { readAll };
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - useReadAll(props?: { onSuccess?: ())
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/components/ExternalElementRenderer.tsx
Tamaño: 574 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { createEffect, JSX, onCleanup, splitProps } from 'solid-js';

type ExternalElementMounterProps = JSX.HTMLAttributes<HTMLDivElement> & {
  render: (el: HTMLDivElement) => () => void;
};

export const ExternalElementRenderer = (props: ExternalElementMounterProps) => {
  let ref: HTMLDivElement;
  const [local, rest] = splitProps(props, ['render']);

  createEffect(() => {
    const unmount = local.render(ref);

    onCleanup(() => {
      unmount();
    });
  });

  return (
    <div
      ref={(el) => {
        ref = el;
      }}
      {...rest}
    />
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { createEffect, JSX, onCleanup, splitProps } from 'solid-js';
type ExternalElementMounterProps = JSX.HTMLAttributes<HTMLDivElement> & {
render: (el: HTMLDivElement) => () => void;
};
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/Inbox.tsx
Tamaño: 6621 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { type OffsetOptions, type Placement } from '@floating-ui/dom';
import { createMemo, createSignal, Match, Show, Switch } from 'solid-js';
import { useInboxContext } from '../context';
import { cn, useStyle } from '../helpers';
import type {
  AvatarRenderer,
  BellRenderer,
  BodyRenderer,
  CustomActionsRenderer,
  DefaultActionsRenderer,
  NotificationActionClickHandler,
  NotificationClickHandler,
  NotificationRenderer,
  SubjectRenderer,
} from '../types';
import { Bell, Footer, Header, Preferences } from './elements';
import { PreferencesHeader } from './elements/Preferences/PreferencesHeader';
import { InboxTabs } from './InboxTabs';
import { NotificationList } from './Notification';
import { Button, Popover } from './primitives';

export type NotificationRendererProps = {
  renderNotification: NotificationRenderer;
  renderAvatar?: never;
  renderSubject?: never;
  renderBody?: never;
  renderDefaultActions?: never;
  renderCustomActions?: never;
};

export type SubjectBodyRendererProps = {
  renderNotification?: never;
  renderAvatar?: AvatarRenderer;
  renderSubject?: SubjectRenderer;
  renderBody?: BodyRenderer;
  renderDefaultActions?: DefaultActionsRenderer;
  renderCustomActions?: CustomActionsRenderer;
};

export type NoRendererProps = {
  renderNotification?: undefined;
  renderAvatar?: undefined;
  renderSubject?: undefined;
  renderBody?: undefined;
  renderDefaultActions?: undefined;
  renderCustomActions?: undefined;
};

export type InboxProps = {
  open?: boolean;
  renderBell?: BellRenderer;
  onNotificationClick?: NotificationClickHandler;
  onPrimaryActionClick?: NotificationActionClickHandler;
  onSecondaryActionClick?: NotificationActionClickHandler;
  placement?: Placement;
  placementOffset?: OffsetOptions;
} & (NotificationRendererProps | SubjectBodyRendererProps | NoRendererProps);

export enum InboxPage {
  Notifications = 'notifications',
  Preferences = 'preferences',
}

export type InboxContentProps = {
  onNotificationClick?: NotificationClickHandler;
  onPrimaryActionClick?: NotificationActionClickHandler;
  onSecondaryActionClick?: NotificationActionClickHandler;
  initialPage?: InboxPage;
  hideNav?: boolean;
} & (NotificationRendererProps | SubjectBodyRendererProps | NoRendererProps);

export const InboxContent = (props: InboxContentProps) => {
  const { isDevelopmentMode } = useInboxContext();
  const [currentPage, setCurrentPage] = createSignal<InboxPage>(props.initialPage || InboxPage.Notifications);
  const { tabs, filter } = useInboxContext();
  const style = useStyle();

  const navigateToPage = createMemo(() => (page: InboxPage) => {
    if (props.hideNav) {
      return undefined;
    }

    return () => {
      setCurrentPage(page);
    };
  });

  return (
    <div
      class={style({
        key: 'inboxContent',
        className: cn(
          'nt-h-full nt-flex nt-flex-col [&_.nv-preferencesContainer]:nt-pb-8 [&_.nv-notificationList]:nt-pb-8',
          {
            '[&_.nv-preferencesContainer]:nt-pb-12 [&_.nv-notificationList]:nt-pb-12': isDevelopmentMode(),
            '[&_.nv-preferencesContainer]:nt-pb-8 [&_.nv-notificationList]:nt-pb-8': !isDevelopmentMode(),
          }
        ),
      })}
    >
      <Switch>
        <Match when={currentPage() === InboxPage.Notifications}>
          <Header navigateToPreferences={navigateToPage()(InboxPage.Preferences)} />
          <Show
            keyed
            when={tabs() && tabs().length > 0}
            fallback={
              <NotificationList
                renderNotification={props.renderNotification}
                renderAvatar={props.renderAvatar}
                renderSubject={props.renderSubject}
                renderBody={props.renderBody}
                renderDefaultActions={props.renderDefaultActions}
                renderCustomActions={props.renderCustomActions}
                onNotificationClick={props.onNotificationClick}
                onPrimaryActionClick={props.onPrimaryActionClick}
                onSecondaryActionClick={props.onSecondaryActionClick}
                filter={filter()}
              />
            }
          >
            <InboxTabs
              renderNotification={props.renderNotification}
              renderAvatar={props.renderAvatar}
              renderSubject={props.renderSubject}
              renderBody={props.renderBody}
              renderDefaultActions={props.renderDefaultActions}
              renderCustomActions={props.renderCustomActions}
              onNotificationClick={props.onNotificationClick}
              onPrimaryActionClick={props.onPrimaryActionClick}
              onSecondaryActionClick={props.onSecondaryActionClick}
              tabs={tabs()}
            />
          </Show>
        </Match>
        <Match when={currentPage() === InboxPage.Preferences}>
          <PreferencesHeader navigateToNotifications={navigateToPage()(InboxPage.Notifications)} />
          <Preferences />
        </Match>
      </Switch>
      <Footer />
    </div>
  );
};

export const Inbox = (props: InboxProps) => {
  const style = useStyle();
  const { isOpened, setIsOpened } = useInboxContext();
  const isOpen = () => props?.open ?? isOpened();

  return (
    <Popover.Root open={isOpen()} onOpenChange={setIsOpened} placement={props.placement} offset={props.placementOffset}>
      <Popover.Trigger
        asChild={(triggerProps) => (
          <Button class={style({ key: 'inbox__popoverTrigger' })} variant="ghost" size="icon" {...triggerProps}>
            <Bell renderBell={props.renderBell} />
          </Button>
        )}
      />
      <Popover.Content appearanceKey="inbox__popoverContent" portal>
        <Show
          when={props.renderNotification}
          fallback={
            <InboxContent
              renderAvatar={props.renderAvatar}
              renderSubject={props.renderSubject}
              renderBody={props.renderBody}
              renderDefaultActions={props.renderDefaultActions}
              renderCustomActions={props.renderCustomActions}
              onNotificationClick={props.onNotificationClick}
              onPrimaryActionClick={props.onPrimaryActionClick}
              onSecondaryActionClick={props.onSecondaryActionClick}
            />
          }
        >
          <InboxContent
            renderNotification={props.renderNotification}
            onNotificationClick={props.onNotificationClick}
            onPrimaryActionClick={props.onPrimaryActionClick}
            onSecondaryActionClick={props.onSecondaryActionClick}
          />
        </Show>
      </Popover.Content>
    </Popover.Root>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { type OffsetOptions, type Placement } from '@floating-ui/dom';
import { createMemo, createSignal, Match, Show, Switch } from 'solid-js';
import { useInboxContext } from '../context';
import { cn, useStyle } from '../helpers';
import type {
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/Renderer.tsx
Tamaño: 5763 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

// @ts-expect-error inline import esbuild syntax
import css from 'directcss:../index.directcss';
import { For, onCleanup, onMount } from 'solid-js';
import { MountableElement, Portal } from 'solid-js/web';
import { Novu } from '../../novu';
import type { NovuOptions } from '../../types';
import { NovuUI } from '..';
import {
  AppearanceProvider,
  CountProvider,
  FocusManagerProvider,
  InboxProvider,
  LocalizationProvider,
  NovuProvider,
} from '../context';
import { NOVU_DEFAULT_CSS_ID } from '../helpers/utils';
import type {
  Appearance,
  Localization,
  PreferenceGroups,
  PreferencesFilter,
  PreferencesSort,
  RouterPush,
  Tab,
} from '../types';
import { Bell, Root } from './elements';
import { Inbox, InboxContent, InboxContentProps, InboxPage } from './Inbox';

export const novuComponents = {
  Inbox,
  InboxContent,
  Bell,
  Notifications: (props: Omit<InboxContentProps, 'hideNav' | 'initialPage'>) => {
    if (props.renderNotification) {
      const { renderBody, renderSubject, renderAvatar, renderDefaultActions, renderCustomActions, ...otherProps } =
        props;

      return <InboxContent {...otherProps} hideNav={true} initialPage={InboxPage.Notifications} />;
    }

    const { renderNotification, ...propsWithoutRenderNotification } = props;

    return <InboxContent {...propsWithoutRenderNotification} hideNav={true} initialPage={InboxPage.Notifications} />;
  },
  Preferences: (props: Omit<InboxContentProps, 'hideNav' | 'initialPage'>) => {
    if (props.renderNotification) {
      const { renderBody, renderSubject, renderAvatar, renderDefaultActions, renderCustomActions, ...otherProps } =
        props;

      return <InboxContent {...otherProps} hideNav={true} initialPage={InboxPage.Preferences} />;
    }

    const { renderNotification, ...propsWithoutRenderNotification } = props;

    return <InboxContent {...propsWithoutRenderNotification} hideNav={true} initialPage={InboxPage.Preferences} />;
  },
};

export type NovuComponent = { name: NovuComponentName; props?: any };

export type NovuMounterProps = NovuComponent & { element: MountableElement };

export type NovuComponentName = keyof typeof novuComponents;

export type NovuComponentControls = {
  mount: (params: NovuMounterProps) => void;
  unmount: (params: { element: MountableElement }) => void;
  updateProps: (params: { element: MountableElement; props: unknown }) => void;
};

type RendererProps = {
  novuUI: NovuUI;
  appearance?: Appearance;
  nodes: Map<MountableElement, NovuComponent>;
  localization?: Localization;
  options: NovuOptions;
  tabs: Array<Tab>;
  preferencesFilter?: PreferencesFilter;
  preferenceGroups?: PreferenceGroups;
  preferencesSort?: PreferencesSort;
  routerPush?: RouterPush;
  novu?: Novu;
  container?: Node | null | undefined;
};

export const Renderer = (props: RendererProps) => {
  const nodes = () => [...props.nodes.keys()];

  onMount(() => {
    const id = NOVU_DEFAULT_CSS_ID;
    const root = props.container instanceof ShadowRoot ? props.container : document;
    const el = root.getElementById(id);
    if (el) {
      return;
    }

    const styleEl = document.createElement('style');
    styleEl.id = id;
    styleEl.innerHTML = css;

    const stylesContainer = props.container ?? document.head;
    stylesContainer.insertBefore(styleEl, stylesContainer.firstChild);

    onCleanup(() => {
      styleEl.remove();
    });
  });

  return (
    <NovuProvider options={props.options} novu={props.novu}>
      <LocalizationProvider localization={props.localization}>
        <AppearanceProvider id={props.novuUI.id} appearance={props.appearance} container={props.container}>
          <FocusManagerProvider>
            <InboxProvider
              applicationIdentifier={props.options?.applicationIdentifier}
              tabs={props.tabs}
              preferencesFilter={props.preferencesFilter}
              preferenceGroups={props.preferenceGroups}
              preferencesSort={props.preferencesSort}
              routerPush={props.routerPush}
            >
              <CountProvider>
                <For each={nodes()}>
                  {(node) => {
                    const novuComponent = () => props.nodes.get(node)!;
                    let portalDivElement: HTMLDivElement;
                    const Component = novuComponents[novuComponent().name];

                    onMount(() => {
                      /*
                       ** return here if not `<Notifications /> or `<Preferences />`
                       ** since we only want to override some styles for those to work properly
                       ** due to the extra divs being introduced by the renderer/mounter
                       */
                      if (!['Notifications', 'Preferences', 'InboxContent'].includes(novuComponent().name)) return;

                      if (node instanceof HTMLElement) {
                        node.style.height = '100%';
                      }
                      if (portalDivElement) {
                        portalDivElement.style.height = '100%';
                      }
                    });

                    return (
                      <Portal
                        mount={node}
                        ref={(el) => {
                          portalDivElement = el;
                        }}
                      >
                        <Root>
                          <Component {...novuComponent().props} />
                        </Root>
                      </Portal>
                    );
                  }}
                </For>
              </CountProvider>
            </InboxProvider>
          </FocusManagerProvider>
        </AppearanceProvider>
      </LocalizationProvider>
    </NovuProvider>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

// @ts-expect-error inline import esbuild syntax
import css from 'directcss:../index.directcss';
import { For, onCleanup, onMount } from 'solid-js';
import { MountableElement, Portal } from 'solid-js/web';
import { Novu } from '../../novu';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/index.ts
Tamaño: 83 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './elements';
export * from './Inbox';
export * from './primitives';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/components/InboxTabs/InboxTab.tsx
Tamaño: 2836 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { ComponentProps, createMemo, JSX, Show } from 'solid-js';
import { useFilteredUnreadCount, useInboxContext } from '../../context';
import { ClassName, cn, getTagsFromTab, useStyle } from '../../helpers';
import { NotificationStatus, Tab } from '../../types';
import { Dropdown, dropdownItemVariants, Tabs } from '../primitives';
import { tabsTriggerVariants } from '../primitives/Tabs/TabsTrigger';

const getDisplayCount = (count: number) => (count >= 100 ? '99+' : count);

export const InboxTabUnreadNotificationsCount = (props: { count: number }) => {
  const style = useStyle();
  const displayCount = createMemo(() => getDisplayCount(props.count));

  return (
    <span
      class={style({
        key: 'notificationsTabsTriggerCount',
        className: 'nt-rounded-full nt-bg-counter nt-px-[6px] nt-text-counter-foreground nt-text-sm',
      })}
    >
      {displayCount()}
    </span>
  );
};

export const InboxTab = (props: Tab & { class?: ClassName }) => {
  const { status } = useInboxContext();
  const style = useStyle();
  const unreadCount = useFilteredUnreadCount({
    filter: { tags: getTagsFromTab(props), data: props.filter?.data, severity: props.filter?.severity },
  });

  return (
    <Tabs.Trigger
      value={props.label}
      class={style({
        key: 'notificationsTabs__tabsTrigger',
        className: cn(tabsTriggerVariants(), 'nt-flex nt-gap-2', props.class),
      })}
    >
      <span
        class={style({
          key: 'notificationsTabsTriggerLabel',
          className: 'nt-text-sm nt-font-medium',
        })}
      >
        {props.label}
      </span>
      <Show when={status() !== NotificationStatus.ARCHIVED && unreadCount()}>
        <InboxTabUnreadNotificationsCount count={unreadCount()} />
      </Show>
    </Tabs.Trigger>
  );
};

type InboxDropdownTabProps = Pick<ComponentProps<(typeof Dropdown)['Item']>, 'onClick'> &
  Tab & {
    rightIcon: JSX.Element;
  };
export const InboxDropdownTab = (props: InboxDropdownTabProps) => {
  const { status } = useInboxContext();
  const style = useStyle();
  const unreadCount = useFilteredUnreadCount({
    filter: { tags: getTagsFromTab(props), data: props.filter?.data, severity: props.filter?.severity },
  });

  return (
    <Dropdown.Item
      class={style({
        key: 'moreTabs__dropdownItem',
        className: cn(dropdownItemVariants(), 'nt-flex nt-justify-between nt-gap-2'),
      })}
      onClick={props.onClick}
    >
      <span
        class={style({
          key: 'moreTabs__dropdownItemLabel',
          className: 'nt-mr-auto',
        })}
      >
        {props.label}
      </span>
      {props.rightIcon}
      <Show when={status() !== NotificationStatus.ARCHIVED && unreadCount()}>
        <InboxTabUnreadNotificationsCount count={unreadCount()} />
      </Show>
    </Dropdown.Item>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { ComponentProps, createMemo, JSX, Show } from 'solid-js';
import { useFilteredUnreadCount, useInboxContext } from '../../context';
import { ClassName, cn, getTagsFromTab, useStyle } from '../../helpers';
import { NotificationStatus, Tab } from '../../types';
import { Dropdown, dropdownItemVariants, Tabs } from '../primitives';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/InboxTabs/InboxTabs.tsx
Tamaño: 6373 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { createMemo, For, Show } from 'solid-js';
import { useInboxContext, useUnreadCounts } from '../../context';
import { cn, getTagsFromTab, useStyle } from '../../helpers';
import { useTabsDropdown } from '../../helpers/useTabsDropdown';
import { Check as DefaultCheck } from '../../icons';
import { ArrowDown as DefaultArrowDown } from '../../icons/ArrowDown';
import {
  AvatarRenderer,
  BodyRenderer,
  CustomActionsRenderer,
  DefaultActionsRenderer,
  NotificationActionClickHandler,
  NotificationClickHandler,
  NotificationRenderer,
  NotificationStatus,
  SubjectRenderer,
  Tab,
} from '../../types';
import { NotificationList } from '../Notification';
import { Button, Dropdown, Tabs } from '../primitives';
import { IconRendererWrapper } from '../shared/IconRendererWrapper';
import { InboxDropdownTab, InboxTab as InboxTabComponent, InboxTabUnreadNotificationsCount } from './InboxTab';

const tabsDropdownTriggerVariants = () =>
  `nt-relative after:nt-absolute after:nt-content-[''] after:nt-bottom-0 after:nt-left-0 ` +
  `after:nt-w-full after:nt-h-[2px] after:nt-border-b-2 nt-mb-[0.625rem]`;
type InboxTabsProps = {
  renderNotification?: NotificationRenderer;
  renderAvatar?: AvatarRenderer;
  renderSubject?: SubjectRenderer;
  renderBody?: BodyRenderer;
  renderDefaultActions?: DefaultActionsRenderer;
  renderCustomActions?: CustomActionsRenderer;
  onNotificationClick?: NotificationClickHandler;
  onPrimaryActionClick?: NotificationActionClickHandler;
  onSecondaryActionClick?: NotificationActionClickHandler;
  tabs: Array<Tab>;
};
export const InboxTabs = (props: InboxTabsProps) => {
  const style = useStyle();
  const { activeTab, status, setActiveTab, filter } = useInboxContext();
  const { dropdownTabs, setTabsList, visibleTabs } = useTabsDropdown({ tabs: props.tabs });
  const dropdownTabsUnreadCounts = useUnreadCounts({
    filters: dropdownTabs().map((tab) => ({ tags: getTagsFromTab(tab), data: tab.filter?.data })),
  });

  const checkIconClass = style({
    key: 'moreTabs__dropdownItemRight__icon',
    className: 'nt-size-3',
    iconKey: 'check',
  });
  const options = createMemo(() =>
    dropdownTabs().map((tab) => ({
      ...tab,
      rightIcon:
        tab.label === activeTab() ? (
          <IconRendererWrapper
            iconKey="check"
            class={checkIconClass}
            fallback={<DefaultCheck class={checkIconClass} />}
          />
        ) : undefined,
    }))
  );
  const dropdownTabsUnreadSum = createMemo(() =>
    dropdownTabsUnreadCounts().reduce((accumulator, currentValue) => accumulator + currentValue, 0)
  );

  const isTabsDropdownActive = createMemo(() =>
    dropdownTabs()
      .map((tab) => tab.label)
      .includes(activeTab())
  );

  const moreTabsIconClass = style({
    key: 'moreTabs__icon',
    className: 'nt-size-5',
    iconKey: 'arrowDown',
  });

  return (
    <Tabs.Root
      appearanceKey="notificationsTabs__tabsRoot"
      class="nt-flex nt-flex-col nt-flex-1 nt-min-h-0"
      value={activeTab()}
      onChange={setActiveTab}
    >
      <Show
        when={visibleTabs().length > 0}
        fallback={
          <Tabs.List
            ref={setTabsList}
            appearanceKey="notificationsTabs__tabsList"
            class="nt-bg-neutral-alpha-25 nt-px-4"
          >
            {props.tabs.map((tab) => (
              <InboxTabComponent {...tab} class="nt-invisible" />
            ))}
          </Tabs.List>
        }
      >
        <Tabs.List appearanceKey="notificationsTabs__tabsList" class="nt-bg-neutral-alpha-25 nt-px-4">
          <For each={visibleTabs()}>{(tab) => <InboxTabComponent {...tab} />}</For>
          <Show when={dropdownTabs().length > 0}>
            <Dropdown.Root>
              <Dropdown.Trigger
                appearanceKey="moreTabs__dropdownTrigger"
                asChild={(triggerProps) => (
                  <Button
                    variant="unstyled"
                    size="iconSm"
                    appearanceKey="moreTabs__button"
                    {...triggerProps}
                    class={cn(
                      tabsDropdownTriggerVariants(),
                      'nt-ml-auto',
                      isTabsDropdownActive()
                        ? 'after:nt-border-b-primary'
                        : 'after:nt-border-b-transparent nt-text-foreground-alpha-700'
                    )}
                  >
                    <IconRendererWrapper
                      iconKey="arrowDown"
                      class={moreTabsIconClass}
                      fallback={<DefaultArrowDown class={moreTabsIconClass} />}
                    />
                    <Show when={status() !== NotificationStatus.ARCHIVED && dropdownTabsUnreadSum()}>
                      <InboxTabUnreadNotificationsCount count={dropdownTabsUnreadSum()} />
                    </Show>
                  </Button>
                )}
              />
              <Dropdown.Content appearanceKey="moreTabs__dropdownContent">
                <For each={options()}>
                  {(option) => <InboxDropdownTab onClick={() => setActiveTab(option.label)} {...option} />}
                </For>
              </Dropdown.Content>
            </Dropdown.Root>
          </Show>
        </Tabs.List>
      </Show>

      {props.tabs.map((tab) => (
        <Tabs.Content
          value={tab.label}
          class={style({
            key: 'notificationsTabs__tabsContent',
            className: cn(
              activeTab() === tab.label ? 'nt-block' : 'nt-hidden',
              'nt-overflow-auto nt-flex-1 nt-flex nt-flex-col nt-min-h-0'
            ),
          })}
        >
          <NotificationList
            renderNotification={props.renderNotification}
            renderAvatar={props.renderAvatar}
            renderSubject={props.renderSubject}
            renderBody={props.renderBody}
            renderDefaultActions={props.renderDefaultActions}
            renderCustomActions={props.renderCustomActions}
            onNotificationClick={props.onNotificationClick}
            onPrimaryActionClick={props.onPrimaryActionClick}
            onSecondaryActionClick={props.onSecondaryActionClick}
            filter={{ ...filter(), tags: getTagsFromTab(tab), data: tab.filter?.data, severity: tab.filter?.severity }}
          />
        </Tabs.Content>
      ))}
    </Tabs.Root>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { createMemo, For, Show } from 'solid-js';
import { useInboxContext, useUnreadCounts } from '../../context';
import { cn, getTagsFromTab, useStyle } from '../../helpers';
import { useTabsDropdown } from '../../helpers/useTabsDropdown';
import { Check as DefaultCheck } from '../../icons';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/InboxTabs/index.ts
Tamaño: 29 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './InboxTabs';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/components/Notification/DefaultNotification.tsx
Tamaño: 16665 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { createEffect, createMemo, createSignal, For, JSX, Show } from 'solid-js';

import type { Notification } from '../../../notifications';
import { ActionTypeEnum, SeverityLevelEnum } from '../../../types';
import { useInboxContext, useLocalization } from '../../context';
import { cn, formatSnoozedUntil, formatToRelativeTime, useStyle } from '../../helpers';
import { Clock as DefaultClock } from '../../icons/Clock';
import {
  AppearanceCallback,
  AppearanceKey,
  AvatarRenderer,
  type BodyRenderer,
  CustomActionsRenderer,
  DefaultActionsRenderer,
  type NotificationActionClickHandler,
  type NotificationClickHandler,
  type SubjectRenderer,
} from '../../types';
import { ExternalElementRenderer } from '../ExternalElementRenderer';
import Markdown from '../elements/Markdown';
import { Button } from '../primitives';
import { Badge } from '../primitives/Badge';
import { IconRendererWrapper } from '../shared/IconRendererWrapper';
import { renderNotificationActions } from './NotificationActions';

type DefaultNotificationProps = {
  notification: Notification;
  renderAvatar?: AvatarRenderer;
  renderSubject?: SubjectRenderer;
  renderBody?: BodyRenderer;
  renderDefaultActions?: DefaultActionsRenderer;
  renderCustomActions?: CustomActionsRenderer;
  onNotificationClick?: NotificationClickHandler;
  onPrimaryActionClick?: NotificationActionClickHandler;
  onSecondaryActionClick?: NotificationActionClickHandler;
};

const SEVERITY_TO_BAR_KEYS: Record<SeverityLevelEnum, AppearanceKey> = {
  [SeverityLevelEnum.NONE]: 'notificationBar',
  [SeverityLevelEnum.HIGH]: 'severityHigh__notificationBar',
  [SeverityLevelEnum.MEDIUM]: 'severityMedium__notificationBar',
  [SeverityLevelEnum.LOW]: 'severityLow__notificationBar',
};

const SEVERITY_TO_NOTIFICATION_KEYS: Record<SeverityLevelEnum, AppearanceKey> = {
  [SeverityLevelEnum.NONE]: 'notification',
  [SeverityLevelEnum.HIGH]: 'severityHigh__notification',
  [SeverityLevelEnum.MEDIUM]: 'severityMedium__notification',
  [SeverityLevelEnum.LOW]: 'severityLow__notification',
};

export const DefaultNotification = (props: DefaultNotificationProps) => {
  const style = useStyle();
  const { t, locale } = useLocalization();
  const { navigate, status } = useInboxContext();
  const [minutesPassed, setMinutesPassed] = createSignal(0);

  const createdAt = createMemo(() => {
    minutesPassed(); // register as dep

    return formatToRelativeTime({ fromDate: new Date(props.notification.createdAt), locale: locale() });
  });
  const snoozedUntil = createMemo(() => {
    minutesPassed(); // register as dep
    if (!props.notification.snoozedUntil) {
      return null;
    }

    return formatSnoozedUntil({ untilDate: new Date(props.notification.snoozedUntil), locale: locale() });
  });
  const deliveredAt = createMemo(() => {
    minutesPassed(); // register as dep

    if (!props.notification.deliveredAt || !Array.isArray(props.notification.deliveredAt)) {
      return null;
    }

    return props.notification.deliveredAt.map((date) =>
      formatToRelativeTime({ fromDate: new Date(date), locale: locale() })
    );
  });

  createEffect(() => {
    const interval = setInterval(() => {
      setMinutesPassed((prev) => prev + 1);
    }, 1000 * 60);

    return () => clearInterval(interval);
  });

  const handleNotificationClick: JSX.EventHandlerUnion<HTMLAnchorElement, MouseEvent> = async (e) => {
    e.stopPropagation();
    e.preventDefault();

    if (!props.notification.isRead) {
      await props.notification.read();
    }

    props.onNotificationClick?.(props.notification);

    navigate(props.notification.redirect?.url, props.notification.redirect?.target);
  };

  const handleActionButtonClick = async (action: ActionTypeEnum, e: MouseEvent) => {
    e.stopPropagation();

    if (action === ActionTypeEnum.PRIMARY) {
      await props.notification.completePrimary();
      props.onPrimaryActionClick?.(props.notification);

      navigate(props.notification.primaryAction?.redirect?.url, props.notification.primaryAction?.redirect?.target);
    } else {
      await props.notification.completeSecondary();
      props.onSecondaryActionClick?.(props.notification);

      navigate(props.notification.secondaryAction?.redirect?.url, props.notification.secondaryAction?.redirect?.target);
    }
  };

  return (
    <a
      class={style({
        key: SEVERITY_TO_NOTIFICATION_KEYS[props.notification.severity],
        className: cn(
          'nt-transition nt-w-full nt-text-sm hover:nt-bg-primary-alpha-25 nt-group nt-relative nt-flex nt-items-start nt-p-4 nt-gap-2',
          '[&:not(:first-child)]:nt-border-t nt-border-neutral-alpha-100',
          {
            'nt-cursor-pointer': !props.notification.isRead || !!props.notification.redirect?.url,
            'nt-bg-severity-high-alpha-100 hover:nt-bg-severity-high-alpha-50':
              props.notification.severity === SeverityLevelEnum.HIGH,
            'nt-bg-severity-medium-alpha-100 hover:nt-bg-severity-medium-alpha-50':
              props.notification.severity === SeverityLevelEnum.MEDIUM,
            'nt-bg-severity-low-alpha-100 hover:nt-bg-severity-low-alpha-50':
              props.notification.severity === SeverityLevelEnum.LOW,
          }
        ),
        context: { notification: props.notification } satisfies Parameters<AppearanceCallback['notification']>[0],
      })}
      onClick={handleNotificationClick}
    >
      <div
        class={style({
          key: SEVERITY_TO_BAR_KEYS[props.notification.severity],
          className: cn('nt-transition nt-absolute nt-left-0 nt-top-0 nt-bottom-0 nt-w-[3px]', {
            'nt-bg-severity-high group-hover:nt-bg-severity-high-alpha-500':
              props.notification.severity === SeverityLevelEnum.HIGH,
            'nt-bg-severity-medium group-hover:nt-bg-severity-medium-alpha-500':
              props.notification.severity === SeverityLevelEnum.MEDIUM,
            'nt-bg-severity-low group-hover:nt-bg-severity-low-alpha-500':
              props.notification.severity === SeverityLevelEnum.LOW,
          }),
          context: { notification: props.notification } satisfies Parameters<AppearanceCallback['notificationBar']>[0],
        })}
      />

      <Show
        when={props.renderAvatar}
        fallback={
          <Show
            when={props.notification.avatar}
            fallback={
              <div
                class={style({
                  key: 'notificationImageLoadingFallback',
                  className: 'nt-size-8 nt-rounded-lg nt-shrink-0 nt-aspect-square',
                  context: { notification: props.notification } satisfies Parameters<
                    AppearanceCallback['notificationImageLoadingFallback']
                  >[0],
                })}
              />
            }
          >
            <img
              class={style({
                key: 'notificationImage',
                className: 'nt-size-8 nt-rounded-lg nt-object-cover nt-aspect-square',
                context: { notification: props.notification } satisfies Parameters<
                  AppearanceCallback['notificationImage']
                >[0],
              })}
              src={props.notification.avatar}
            />
          </Show>
        }
      >
        {(renderAvatar) => <ExternalElementRenderer render={(el) => renderAvatar()(el, props.notification)} />}
      </Show>

      <div
        class={style({
          key: 'notificationContent',
          className: 'nt-flex nt-flex-col nt-gap-2 nt-w-full',
          context: { notification: props.notification } satisfies Parameters<
            AppearanceCallback['notificationContent']
          >[0],
        })}
      >
        <div
          class={style({
            key: 'notificationTextContainer',
            context: { notification: props.notification } satisfies Parameters<
              AppearanceCallback['notificationTextContainer']
            >[0],
          })}
        >
          <Show
            when={props.renderSubject}
            fallback={
              <Show when={props.notification.subject}>
                {(subject) => (
                  <Markdown
                    appearanceKey="notificationSubject"
                    class="nt-text-start nt-font-medium nt-whitespace-pre-wrap [word-break:break-word]"
                    strongAppearanceKey="notificationSubject__strong"
                    context={{ notification: props.notification }}
                  >
                    {subject()}
                  </Markdown>
                )}
              </Show>
            }
          >
            {(renderSubject) => <ExternalElementRenderer render={(el) => renderSubject()(el, props.notification)} />}
          </Show>
          <Show
            when={props.renderBody}
            fallback={
              <Markdown
                appearanceKey="notificationBody"
                strongAppearanceKey="notificationBody__strong"
                class="nt-text-start nt-whitespace-pre-wrap nt-text-foreground-alpha-600 [word-break:break-word]"
                context={{ notification: props.notification }}
              >
                {props.notification.body}
              </Markdown>
            }
          >
            {(renderBody) => <ExternalElementRenderer render={(el) => renderBody()(el, props.notification)} />}
          </Show>
        </div>

        <Show
          when={props.renderDefaultActions}
          fallback={
            <div
              class={style({
                key: 'notificationDefaultActions',
                className: `nt-absolute nt-transition nt-duration-100 nt-ease-out nt-gap-0.5 nt-flex nt-shrink-0 nt-opacity-0 group-hover:nt-opacity-100 group-focus-within:nt-opacity-100 nt-justify-center nt-items-center nt-bg-background/90 nt-right-3 nt-top-3 nt-border nt-border-neutral-alpha-100 nt-rounded-lg nt-backdrop-blur-lg nt-p-0.5`,
                context: { notification: props.notification } satisfies Parameters<
                  AppearanceCallback['notificationDefaultActions']
                >[0],
              })}
            >
              {renderNotificationActions(props.notification, status)}
            </div>
          }
        >
          {(renderDefaultActions) => (
            <ExternalElementRenderer render={(el) => renderDefaultActions()(el, props.notification)} />
          )}
        </Show>

        <Show
          when={props.renderCustomActions}
          fallback={
            <Show when={props.notification.primaryAction || props.notification.secondaryAction}>
              <div
                class={style({
                  key: 'notificationCustomActions',
                  className: 'nt-flex nt-flex-wrap nt-gap-2',
                  context: { notification: props.notification } satisfies Parameters<
                    AppearanceCallback['notificationCustomActions']
                  >[0],
                })}
              >
                <Show when={props.notification.primaryAction} keyed>
                  {(primaryAction) => (
                    <Button
                      appearanceKey="notificationPrimaryAction__button"
                      variant="default"
                      onClick={(e) => handleActionButtonClick(ActionTypeEnum.PRIMARY, e)}
                      context={{ notification: props.notification }}
                    >
                      {primaryAction.label}
                    </Button>
                  )}
                </Show>
                <Show when={props.notification.secondaryAction} keyed>
                  {(secondaryAction) => (
                    <Button
                      appearanceKey="notificationSecondaryAction__button"
                      variant="secondary"
                      onClick={(e) => handleActionButtonClick(ActionTypeEnum.SECONDARY, e)}
                      context={{ notification: props.notification }}
                    >
                      {secondaryAction.label}
                    </Button>
                  )}
                </Show>
              </div>
            </Show>
          }
        >
          {(renderCustomActions) => (
            <ExternalElementRenderer render={(el) => renderCustomActions()(el, props.notification)} />
          )}
        </Show>

        <div
          class={style({
            key: 'notificationDate',
            className: 'nt-text-foreground-alpha-400 nt-flex nt-items-center nt-gap-1',
            context: { notification: props.notification } satisfies Parameters<
              AppearanceCallback['notificationDate']
            >[0],
          })}
        >
          <Show
            when={snoozedUntil()}
            fallback={
              <Show when={deliveredAt()} fallback={createdAt()}>
                {(deliveredAt) => (
                  <Show when={deliveredAt().length >= 2} fallback={createdAt()}>
                    {' '}
                    <For each={deliveredAt().slice(-2)}>
                      {(date, index) => (
                        <>
                          <Show when={index() === 0}>{date} ·</Show>
                          <Show when={index() === 1}>
                            <Badge
                              appearanceKey="notificationDeliveredAt__badge"
                              context={{ notification: props.notification }}
                            >
                              <IconRendererWrapper
                                iconKey="clock"
                                class={style({
                                  key: 'notificationDeliveredAt__icon',
                                  className: 'nt-size-3',
                                  iconKey: 'clock',
                                  context: { notification: props.notification } satisfies Parameters<
                                    AppearanceCallback['notificationDeliveredAt__icon']
                                  >[0],
                                })}
                                fallback={
                                  <DefaultClock
                                    class={style({
                                      key: 'notificationDeliveredAt__icon',
                                      className: 'nt-size-3',
                                      iconKey: 'clock',
                                      context: { notification: props.notification } satisfies Parameters<
                                        AppearanceCallback['notificationDeliveredAt__icon']
                                      >[0],
                                    })}
                                  />
                                }
                              />
                              {date}
                            </Badge>
                          </Show>
                        </>
                      )}
                    </For>
                  </Show>
                )}
              </Show>
            }
          >
            {(snoozedUntil) => (
              <>
                <IconRendererWrapper
                  iconKey="clock"
                  class={style({
                    key: 'notificationSnoozedUntil__icon',
                    className: 'nt-size-3',
                    iconKey: 'clock',
                    context: { notification: props.notification } satisfies Parameters<
                      AppearanceCallback['notificationSnoozedUntil__icon']
                    >[0],
                  })}
                  fallback={
                    <DefaultClock
                      class={style({
                        key: 'notificationSnoozedUntil__icon',
                        className: 'nt-size-3',
                        iconKey: 'clock',
                        context: { notification: props.notification } satisfies Parameters<
                          AppearanceCallback['notificationSnoozedUntil__icon']
                        >[0],
                      })}
                    />
                  }
                />
                {t('notification.snoozedUntil')} · {snoozedUntil()}
              </>
            )}
          </Show>
        </div>
      </div>

      <div class="nt-w-1.5 nt-flex nt-justify-center nt-shrink-0">
        <Show when={!props.notification.isRead}>
          <span
            class={style({
              key: 'notificationDot',
              className: 'nt-size-1.5 nt-bg-primary nt-rounded-full',
              context: { notification: props.notification } satisfies Parameters<
                AppearanceCallback['notificationDot']
              >[0],
            })}
          />
        </Show>
      </div>
    </a>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { createEffect, createMemo, createSignal, For, JSX, Show } from 'solid-js';
import type { Notification } from '../../../notifications';
import { ActionTypeEnum, SeverityLevelEnum } from '../../../types';
import { useInboxContext, useLocalization } from '../../context';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/Notification/NewMessagesCta.tsx
Tamaño: 904 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Component, createMemo, JSX, Show } from 'solid-js';
import { useLocalization } from '../../context';
import { Button } from '../primitives';

export const NewMessagesCta: Component<{
  onClick?: JSX.EventHandlerUnion<HTMLButtonElement, MouseEvent>;
  count: number;
}> = (props) => {
  const shouldRender = createMemo(() => !!props.count);
  const { t } = useLocalization();

  return (
    <Show when={shouldRender()}>
      <Button
        appearanceKey="notificationListNewNotificationsNotice__button"
        class="nt-absolute nt-w-fit nt-h-fit nt-top-0 nt-mx-auto nt-inset-2 nt-z-10 nt-rounded-full hover:nt-bg-primary-600 nt-animate-in nt-slide-in-from-top-2 nt-fade-in"
        onClick={props.onClick}
        data-localization="notifications.newNotifications"
      >
        {t('notifications.newNotifications', { notificationCount: props.count })}
      </Button>
    </Show>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Component, createMemo, JSX, Show } from 'solid-js';
import { useLocalization } from '../../context';
import { Button } from '../primitives';
export const NewMessagesCta: Component<{
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/Notification/Notification.tsx
Tamaño: 1725 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Show } from 'solid-js';
import type { Notification as NotificationType } from '../../../notifications';
import type {
  AvatarRenderer,
  BodyRenderer,
  CustomActionsRenderer,
  DefaultActionsRenderer,
  NotificationActionClickHandler,
  NotificationClickHandler,
  NotificationRenderer,
  SubjectRenderer,
} from '../../types';
import { ExternalElementRenderer } from '../ExternalElementRenderer';
import { DefaultNotification } from './DefaultNotification';

type NotificationProps = {
  notification: NotificationType;
  renderNotification?: NotificationRenderer;
  renderAvatar?: AvatarRenderer;
  renderSubject?: SubjectRenderer;
  renderBody?: BodyRenderer;
  renderDefaultActions?: DefaultActionsRenderer;
  renderCustomActions?: CustomActionsRenderer;
  onNotificationClick?: NotificationClickHandler;
  onPrimaryActionClick?: NotificationActionClickHandler;
  onSecondaryActionClick?: NotificationActionClickHandler;
};

export const Notification = (props: NotificationProps) => {
  return (
    <Show
      when={props.renderNotification}
      fallback={
        <DefaultNotification
          notification={props.notification}
          renderAvatar={props.renderAvatar}
          renderSubject={props.renderSubject}
          renderBody={props.renderBody}
          renderDefaultActions={props.renderDefaultActions}
          renderCustomActions={props.renderCustomActions}
          onNotificationClick={props.onNotificationClick}
          onPrimaryActionClick={props.onPrimaryActionClick}
          onSecondaryActionClick={props.onSecondaryActionClick}
        />
      }
    >
      <ExternalElementRenderer render={(el) => props.renderNotification!(el, props.notification)} />
    </Show>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Show } from 'solid-js';
import type { Notification as NotificationType } from '../../../notifications';
import type {
AvatarRenderer,
BodyRenderer,
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/Notification/NotificationActions.tsx
Tamaño: 14268 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { createMemo, createSignal, For, JSX } from 'solid-js';
import type { Notification } from '../../../notifications';
import { useInboxContext, useLocalization } from '../../context';
import { useStyle } from '../../helpers';
import { MarkAsUnarchived as DefaultMarkAsUnarchived } from '../../icons';
import { Clock, Clock as DefaultClock } from '../../icons/Clock';
import { MarkAsArchived as DefaultMarkAsArchived } from '../../icons/MarkAsArchived';
import { MarkAsRead as DefaultMarkAsRead } from '../../icons/MarkAsRead';
import { MarkAsUnread as DefaultMarkAsUnread } from '../../icons/MarkAsUnread';
import { Unsnooze as DefaultUnsnooze } from '../../icons/Unsnooze';
import { LocalizationKey, NotificationStatus } from '../../types';
import { Button, Dropdown, dropdownItemVariants, Popover } from '../primitives';
import { Tooltip } from '../primitives/Tooltip';
import { IconRendererWrapper } from '../shared/IconRendererWrapper';
import { SnoozeDateTimePicker } from './SnoozeDateTimePicker';

export const SNOOZE_PRESETS = [
  {
    key: 'snooze.options.anHourFromNow',
    hours: 1,
    getDate: () => new Date(Date.now() + 1 * 60 * 60 * 1000),
  },
  {
    key: 'snooze.options.inOneDay',
    hours: 24,
    getDate: () => {
      const date = new Date(Date.now() + 1 * 24 * 60 * 60 * 1000);
      date.setHours(9, 0, 0, 0);

      return date;
    },
  },
  {
    key: 'snooze.options.inOneWeek',
    hours: 168,
    getDate: () => {
      const date = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);
      date.setHours(9, 0, 0, 0);

      return date;
    },
  },
] satisfies {
  key: Extract<LocalizationKey, `snooze.options.${string}`>;
  hours: number;
  getDate: () => Date;
}[];

export const formatSnoozeOption = (
  preset: (typeof SNOOZE_PRESETS)[number],
  t: (key: LocalizationKey) => string,
  locale: string
): { label: string; time: string } => {
  const date = preset.getDate();

  // Format weekday (e.g., "Wed")
  const dayName = new Intl.DateTimeFormat(locale, { weekday: 'short' }).format(date);

  // Format date and month (e.g., "26 Mar")
  const dateMonth = new Intl.DateTimeFormat(locale, { day: 'numeric', month: 'short' }).format(date);

  // Format time (e.g., "9:00 PM")
  const timeString = new Intl.DateTimeFormat(locale, { hour: 'numeric', minute: 'numeric' }).format(date);

  // Combine to e.g. "Wed, 26 Mar, 9:00 PM"
  return { label: t(preset.key), time: `${dayName}, ${dateMonth}, ${timeString}` };
};

const SnoozeDropdownItem = (props: {
  label: string;
  time: string;
  onClick?: (e: MouseEvent) => void;
  asChild?: (props: any) => JSX.Element;
}) => {
  const style = useStyle();
  const snoozeItemIconClass = style({
    key: 'notificationSnooze__dropdownItem__icon',
    className: 'nt-size-3 nt-text-foreground-alpha-400 nt-mr-2',
    iconKey: 'clock',
  });

  const content = (
    <>
      <div
        class={style({
          key: 'dropdownItem',
          className: 'nt-flex nt-items-center nt-flex-1',
        })}
      >
        <IconRendererWrapper
          iconKey="clock"
          class={snoozeItemIconClass}
          fallback={<DefaultClock class={snoozeItemIconClass} />}
        />
        <span
          class={style({
            key: 'dropdownItemLabel',
          })}
        >
          {props.label}
        </span>
      </div>
      <span
        class={style({
          key: 'dropdownItemRight__icon',
          className: 'nt-text-foreground-alpha-300 nt-ml-2 nt-text-xs',
        })}
      >
        {props.time}
      </span>
    </>
  );

  if (props.asChild) {
    return props.asChild({
      class: style({
        key: 'notificationSnooze__dropdownItem',
        className: dropdownItemVariants(),
      }),
      onClick: props.onClick,
      children: content,
    });
  }

  return (
    <Dropdown.Item
      appearanceKey="notificationSnooze__dropdownItem"
      onClick={props.onClick}
      class={style({
        key: 'dropdownItem',
        className: 'nt-justify-between',
      })}
    >
      {content}
    </Dropdown.Item>
  );
};

export const ReadButton = (props: { notification: Notification }) => {
  const style = useStyle();
  const { t } = useLocalization();
  const readIconClass = style({
    key: 'notificationRead__icon',
    className: 'nt-size-3',
    iconKey: 'markAsRead',
  });

  return (
    <Tooltip.Root>
      <Tooltip.Trigger
        asChild={(childProps) => (
          <Button
            appearanceKey="notificationRead__button"
            size="iconSm"
            variant="ghost"
            {...childProps}
            onClick={async (e) => {
              e.stopPropagation();
              await props.notification.read();
            }}
          >
            <IconRendererWrapper
              iconKey="markAsRead"
              class={readIconClass}
              fallback={<DefaultMarkAsRead class={readIconClass} />}
            />
          </Button>
        )}
      />
      <Tooltip.Content data-localization="notification.actions.read.tooltip">
        {t('notification.actions.read.tooltip')}
      </Tooltip.Content>
    </Tooltip.Root>
  );
};

export const UnreadButton = (props: { notification: Notification }) => {
  const style = useStyle();
  const { t } = useLocalization();
  const unreadIconClass = style({
    key: 'notificationUnread__icon',
    className: 'nt-size-3',
    iconKey: 'markAsUnread',
  });

  return (
    <Tooltip.Root>
      <Tooltip.Trigger
        asChild={(childProps) => (
          <Button
            appearanceKey="notificationUnread__button"
            size="iconSm"
            variant="ghost"
            {...childProps}
            onClick={async (e) => {
              e.stopPropagation();
              await props.notification.unread();
            }}
          >
            <IconRendererWrapper
              iconKey="markAsUnread"
              class={unreadIconClass}
              fallback={<DefaultMarkAsUnread class={unreadIconClass} />}
            />
          </Button>
        )}
      />
      <Tooltip.Content data-localization="notification.actions.unread.tooltip">
        {t('notification.actions.unread.tooltip')}
      </Tooltip.Content>
    </Tooltip.Root>
  );
};

export const ArchiveButton = (props: { notification: Notification }) => {
  const style = useStyle();
  const { t } = useLocalization();
  const archiveIconClass = style({
    key: 'notificationArchive__icon',
    className: 'nt-size-3',
    iconKey: 'markAsArchived',
  });

  return (
    <Tooltip.Root>
      <Tooltip.Trigger
        asChild={(childProps) => (
          <Button
            appearanceKey="notificationArchive__button"
            size="iconSm"
            variant="ghost"
            {...childProps}
            onClick={async (e) => {
              e.stopPropagation();
              await props.notification.archive();
            }}
          >
            <IconRendererWrapper
              iconKey="markAsArchived"
              class={archiveIconClass}
              fallback={<DefaultMarkAsArchived class={archiveIconClass} />}
            />
          </Button>
        )}
      />
      <Tooltip.Content data-localization="notification.actions.archive.tooltip">
        {t('notification.actions.archive.tooltip')}
      </Tooltip.Content>
    </Tooltip.Root>
  );
};

export const UnarchiveButton = (props: { notification: Notification }) => {
  const style = useStyle();
  const { t } = useLocalization();
  const unarchiveIconClass = style({
    key: 'notificationArchive__icon',
    className: 'nt-size-3',
    iconKey: 'markAsUnarchived',
  });

  return (
    <Tooltip.Root>
      <Tooltip.Trigger
        asChild={(childProps) => (
          <Button
            appearanceKey="notificationUnarchive__button"
            size="iconSm"
            variant="ghost"
            {...childProps}
            onClick={async (e) => {
              e.stopPropagation();
              await props.notification.unarchive();
            }}
          >
            <IconRendererWrapper
              iconKey="markAsUnarchived"
              class={unarchiveIconClass}
              fallback={<DefaultMarkAsUnarchived class={unarchiveIconClass} />}
            />
          </Button>
        )}
      />
      <Tooltip.Content data-localization="notification.actions.unarchive.tooltip">
        {t('notification.actions.unarchive.tooltip')}
      </Tooltip.Content>
    </Tooltip.Root>
  );
};

export const UnsnoozeButton = (props: { notification: Notification }) => {
  const style = useStyle();
  const { t } = useLocalization();
  const unsnoozeIconClass = style({
    key: 'notificationUnsnooze__icon',
    className: 'nt-size-3',
    iconKey: 'unsnooze',
  });

  return (
    <Tooltip.Root>
      <Tooltip.Trigger
        asChild={(childProps) => (
          <Button
            appearanceKey="notificationUnsnooze__button"
            size="iconSm"
            variant="ghost"
            {...childProps}
            onClick={async (e) => {
              e.stopPropagation();
              await props.notification.unsnooze();
            }}
          >
            <IconRendererWrapper
              iconKey="unsnooze"
              class={unsnoozeIconClass}
              fallback={<DefaultUnsnooze class={unsnoozeIconClass} />}
            />
          </Button>
        )}
      />
      <Tooltip.Content data-localization="notification.actions.unsnooze.tooltip">
        {t('notification.actions.unsnooze.tooltip')}
      </Tooltip.Content>
    </Tooltip.Root>
  );
};

export const SnoozeButton = (props: { notification: Notification }) => {
  const style = useStyle();
  const { t, locale } = useLocalization();
  const { maxSnoozeDurationHours } = useInboxContext();
  const [isSnoozeDateTimePickerOpen, setIsSnoozeDateTimePickerOpen] = createSignal(false);
  const snoozeButtonIconClass = style({
    key: 'notificationSnooze__icon',
    className: 'nt-size-3',
    iconKey: 'clock',
  });

  const availableSnoozePresets = createMemo(() => {
    if (!maxSnoozeDurationHours()) return SNOOZE_PRESETS;

    return SNOOZE_PRESETS.filter((preset) => preset.hours <= maxSnoozeDurationHours());
  });

  return (
    <Tooltip.Root>
      <Tooltip.Trigger
        asChild={(tooltipProps) => (
          <Dropdown.Root>
            <Dropdown.Trigger
              {...tooltipProps}
              asChild={(popoverProps) => (
                <Button
                  appearanceKey="notificationSnooze__button"
                  size="iconSm"
                  variant="ghost"
                  {...popoverProps}
                  onClick={(e) => {
                    e.stopPropagation();
                    popoverProps.onClick?.(e);
                  }}
                >
                  <IconRendererWrapper
                    iconKey="clock"
                    class={snoozeButtonIconClass}
                    fallback={<Clock class={snoozeButtonIconClass} />}
                  />
                </Button>
              )}
            />
            <Dropdown.Content portal appearanceKey="notificationSnooze__dropdownContent">
              <For each={availableSnoozePresets()}>
                {(preset) => {
                  const option = formatSnoozeOption(preset, t, locale());

                  return (
                    <SnoozeDropdownItem
                      label={option.label}
                      time={option.time}
                      onClick={async (e) => {
                        e.stopPropagation();
                        await props.notification.snooze(preset.getDate().toISOString());
                      }}
                    />
                  );
                }}
              </For>

              <Popover.Root
                open={isSnoozeDateTimePickerOpen()}
                onOpenChange={setIsSnoozeDateTimePickerOpen}
                placement="bottom-start"
              >
                <SnoozeDropdownItem
                  label={t('snooze.options.customTime')}
                  time=""
                  asChild={(childProps) => (
                    <Popover.Trigger
                      {...childProps}
                      onClick={(e) => {
                        e.stopPropagation();
                        childProps.onClick?.(e);
                      }}
                    />
                  )}
                />
                <Popover.Content
                  portal
                  class={style({
                    key: 'notificationSnoozeCustomTime_popoverContent',
                    className: 'nt-size-fit nt-w-[260px]',
                  })}
                >
                  <SnoozeDateTimePicker
                    maxDurationHours={maxSnoozeDurationHours()}
                    onSelect={async (date) => {
                      await props.notification.snooze(date.toISOString());
                    }}
                    onCancel={() => {
                      setIsSnoozeDateTimePickerOpen(false);
                    }}
                  />
                </Popover.Content>
              </Popover.Root>
            </Dropdown.Content>
          </Dropdown.Root>
        )}
      />
      <Tooltip.Content data-localization="notification.actions.snooze.tooltip">
        {t('notification.actions.snooze.tooltip')}
      </Tooltip.Content>
    </Tooltip.Root>
  );
};

// Helper function to render the appropriate actions based on notification state
export const renderNotificationActions = (notification: Notification, status: () => NotificationStatus) => {
  const { isSnoozeEnabled } = useInboxContext();

  // Handle snoozed state - only show unsnooze
  if (notification.isSnoozed) {
    return <UnsnoozeButton notification={notification} />;
  }

  // Handle archived state - only show unarchive
  if (notification.isArchived) {
    return <UnarchiveButton notification={notification} />;
  }

  // Handle normal state - show read/unread, snooze, archive
  return (
    <>
      {status() !== NotificationStatus.ARCHIVED &&
        (notification.isRead ? (
          <UnreadButton notification={notification} />
        ) : (
          <ReadButton notification={notification} />
        ))}
      {isSnoozeEnabled() && <SnoozeButton notification={notification} />}
      <ArchiveButton notification={notification} />
    </>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { createMemo, createSignal, For, JSX } from 'solid-js';
import type { Notification } from '../../../notifications';
import { useInboxContext, useLocalization } from '../../context';
import { useStyle } from '../../helpers';
import { MarkAsUnarchived as DefaultMarkAsUnarchived } from '../../icons';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/Notification/NotificationList.tsx
Tamaño: 5451 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { createEffect, createMemo, For, JSX, onCleanup, Show } from 'solid-js';
import type { NotificationFilter } from '../../../types';
import { useNotificationsInfiniteScroll } from '../../api';
import { DEFAULT_LIMIT, useInboxContext, useNewMessagesCount } from '../../context';
import { useStyle } from '../../helpers';
import { useNotificationVisibility } from '../../helpers/useNotificationVisibility';
import type {
  AppearanceCallback,
  AvatarRenderer,
  BodyRenderer,
  CustomActionsRenderer,
  DefaultActionsRenderer,
  NotificationActionClickHandler,
  NotificationClickHandler,
  NotificationRenderer,
  SubjectRenderer,
} from '../../types';
import { NewMessagesCta } from './NewMessagesCta';
import { Notification } from './Notification';
import { NotificationListSkeleton } from './NotificationListSkeleton';

type NotificationListProps = {
  renderNotification?: NotificationRenderer;
  renderAvatar?: AvatarRenderer;
  renderSubject?: SubjectRenderer;
  renderBody?: BodyRenderer;
  renderDefaultActions?: DefaultActionsRenderer;
  renderCustomActions?: CustomActionsRenderer;
  onNotificationClick?: NotificationClickHandler;
  onPrimaryActionClick?: NotificationActionClickHandler;
  onSecondaryActionClick?: NotificationActionClickHandler;
  limit?: number | undefined;
  filter?: NotificationFilter;
};

export const NotificationList = (props: NotificationListProps) => {
  const options = createMemo(() => ({ ...props.filter, limit: props.limit }));
  const style = useStyle();
  const { data, setEl, end, refetch, initialLoading } = useNotificationsInfiniteScroll({ options });
  const { count, reset: resetNewMessagesCount } = useNewMessagesCount({
    filter: { tags: props.filter?.tags ?? [], data: props.filter?.data ?? {}, severity: props.filter?.severity },
  });
  const { setLimit } = useInboxContext();
  const ids = createMemo(() => data().map((n) => n.id));
  const { observeNotification, unobserveNotification } = useNotificationVisibility();
  let notificationListElement: HTMLDivElement;

  createEffect(() => {
    setLimit(props.limit || DEFAULT_LIMIT);
  });

  const handleOnNewMessagesClick: JSX.EventHandlerUnion<HTMLButtonElement, MouseEvent> = async (e) => {
    e.stopPropagation();
    resetNewMessagesCount();
    refetch({ filter: props.filter });
    notificationListElement.scrollTo({ top: 0 });
  };

  return (
    <div
      class={style({
        key: 'notificationListContainer',
        className: 'nt-relative nt-border-t nt-border-t-neutral-alpha-200 nt-h-full nt-overflow-hidden',
        context: { notifications: data() } satisfies Parameters<AppearanceCallback['notificationListContainer']>[0],
      })}
    >
      <NewMessagesCta count={count()} onClick={handleOnNewMessagesClick} />
      <div
        ref={(el) => {
          notificationListElement = el;
        }}
        class={style({
          key: 'notificationList',
          className: 'nt-relative nt-h-full nt-flex nt-flex-col nt-overflow-y-auto',
          context: { notifications: data() } satisfies Parameters<AppearanceCallback['notificationList']>[0],
        })}
      >
        <Show when={data().length > 0} fallback={<NotificationListSkeleton loading={initialLoading()} />}>
          <For each={ids()}>
            {(_, index) => {
              const notification = () => data()[index()];

              return (
                <div
                  ref={(el) => {
                    // Start observing this notification for visibility tracking
                    observeNotification(el, notification().id);

                    // Set up cleanup when element is removed
                    const observer = new MutationObserver((mutations) => {
                      mutations.forEach((mutation) => {
                        mutation.removedNodes.forEach((node) => {
                          if (node === el) {
                            unobserveNotification(el);
                            observer.disconnect();
                          }
                        });
                      });
                    });

                    if (el.parentElement) {
                      observer.observe(el.parentElement, { childList: true });
                    }

                    // Cleanup function to disconnect observer when ref changes
                    onCleanup(() => {
                      observer.disconnect();
                      unobserveNotification(el);
                    });
                  }}
                >
                  <Notification
                    notification={notification()}
                    renderNotification={props.renderNotification}
                    renderAvatar={props.renderAvatar}
                    renderSubject={props.renderSubject}
                    renderBody={props.renderBody}
                    renderDefaultActions={props.renderDefaultActions}
                    renderCustomActions={props.renderCustomActions}
                    onNotificationClick={props.onNotificationClick}
                    onPrimaryActionClick={props.onPrimaryActionClick}
                    onSecondaryActionClick={props.onSecondaryActionClick}
                  />
                </div>
              );
            }}
          </For>
          <Show when={!end()}>
            <div ref={setEl}>
              <NotificationListSkeleton loading={true} />
            </div>
          </Show>
        </Show>
      </div>
    </div>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { createEffect, createMemo, For, JSX, onCleanup, Show } from 'solid-js';
import type { NotificationFilter } from '../../../types';
import { useNotificationsInfiniteScroll } from '../../api';
import { DEFAULT_LIMIT, useInboxContext, useNewMessagesCount } from '../../context';
import { useStyle } from '../../helpers';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/Notification/NotificationListSkeleton.tsx
Tamaño: 5865 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Show } from 'solid-js';
import { useInboxContext, useNovu } from '../../context';
import { useLocalization } from '../../context/LocalizationContext';
import { useStyle } from '../../helpers/useStyle';
import { Bell } from '../../icons';
import { Key } from '../../icons/Key';
import { Button } from '../primitives/Button';
import { Motion } from '../primitives/Motion';
import { SkeletonAvatar, SkeletonText } from '../primitives/Skeleton';

type NotificationListSkeletonProps = {
  loading?: boolean;
};

export const NotificationListSkeleton = (props: NotificationListSkeletonProps) => {
  const style = useStyle();
  const { t } = useLocalization();
  const { isKeyless } = useInboxContext();

  return (
    <div
      class={style({
        key: 'notificationListEmptyNoticeContainer',
        className:
          'nt-flex nt-flex-col nt-items-center nt-h-fit nt-w-full nt-text-sm nt-text-foreground-alpha-400 nt-text-center',
      })}
    >
      <Motion.div
        animate={{
          scale: props.loading ? 1 : 0.7,
        }}
        transition={{ duration: 0.6, easing: [0.39, 0.24, 0.3, 1], delay: 0.3 }}
        class={style({
          key: 'notificationList__skeleton',
          className: 'nt-flex nt-relative nt-mx-auto nt-flex-col nt-w-full nt-mb-4',
        })}
      >
        {Array.from({ length: 5 }).map((_, i) => (
          <Motion.div
            animate={{
              marginBottom: props.loading ? 0 : '16px',
              borderWidth: props.loading ? 0 : '1px',
              borderRadius: props.loading ? 0 : 'var(--nv-radius-lg)',
            }}
            transition={{ duration: 0.5, delay: 0.3, easing: 'ease-in-out' }}
            class={style({
              key: 'notificationList__skeletonContent',
              className: 'nt-flex nt-border-neutral-alpha-50 nt-items-center nt-gap-3 nt-p-3 nt-bg-neutral-alpha-25',
            })}
          >
            <SkeletonAvatar
              appearanceKey="notificationList__skeletonAvatar"
              class="nt-w-8 nt-h-8 nt-rounded-full nt-bg-neutral-alpha-100"
            />
            <div
              class={style({
                key: 'notificationList__skeletonItem',
                className: 'nt-flex nt-flex-col nt-gap-2 nt-flex-1',
              })}
            >
              <SkeletonText
                appearanceKey="notificationList__skeletonText"
                class="nt-h-2 nt-w-1/3 nt-bg-neutral-alpha-50 nt-rounded"
              />
              <SkeletonText
                appearanceKey="notificationList__skeletonText"
                class="nt-h-2 nt-w-2/3 nt-bg-neutral-alpha-50 nt-rounded"
              />
            </div>
          </Motion.div>
        ))}
        <div
          class={style({
            key: 'notificationListEmptyNoticeOverlay',
            className:
              'nt-absolute nt-size-full nt-z-10 nt-inset-0 nt-bg-gradient-to-b nt-from-transparent nt-to-background',
          })}
        />
      </Motion.div>
      <Show when={!props.loading}>
        <Motion.p
          initial={{ opacity: 0, y: -4, filter: 'blur(4px)' }}
          animate={{ opacity: props.loading ? 0 : 1, y: 0, filter: 'blur(0px)' }}
          transition={{ duration: 0.7, easing: [0.39, 0.24, 0.3, 1], delay: 0.6 }}
          class={style({
            key: 'notificationListEmptyNotice',
            className: 'nt-text-center',
          })}
        >
          {isKeyless() ? (
            <KeylessEmptyState />
          ) : (
            <p data-localization="notifications.emptyNotice">{t('notifications.emptyNotice')}</p>
          )}
        </Motion.p>
      </Show>
    </div>
  );
};

function KeylessEmptyState() {
  const style = useStyle();
  const novu = useNovu();

  return (
    <div
      class={style({
        key: 'notificationListEmptyNotice',
        className: 'nt--mt-[50px]',
      })}
    >
      <p
        class={style({
          key: 'strong',
          className: 'nt-text-[#000000] nt-mb-1',
        })}
      >
        Trigger your notification. No setup needed.
      </p>
      <p
        class={style({
          key: 'notificationListEmptyNotice',
          className: 'nt-mb-4',
        })}
      >
        {`Temporary <Inbox />, data will expire in 24h. Connect API key to persists messages, enable
                preferences, and connect email.`}
      </p>
      <div
        class={style({
          key: 'notificationListEmptyNotice',
          className: 'nt-flex nt-gap-4 nt-justify-center',
        })}
      >
        <Button
          variant="secondary"
          size="sm"
          class={style({
            key: 'notificationListEmptyNotice',
            className:
              'nt-h-8 nt-px-4 nt-flex nt-items-center nt-justify-center nt-gap-2 nt-bg-white nt-border nt-border-neutral-alpha-100 nt-shadow-sm nt-text-[12px] nt-font-medium',
          })}
          onClick={() => window.open('https://go.novu.co/keyless', '_blank', 'noopener noreferrer')}
        >
          <Key
            class={style({
              key: 'lockIcon',
              className: 'nt-size-4 nt-mr-2',
            })}
          />
          Get API key
        </Button>
        <div>
          <Button
            variant="default"
            size="sm"
            class={style({
              key: 'notificationListEmptyNotice',
              className:
                'nt-h-8 nt-px-4 nt-flex nt-items-center nt-justify-center nt-gap-2 nt-bg-neutral-900 nt-text-white nt-shadow-sm nt-text-[12px] nt-font-medium',
            })}
            onClick={() => novu.notifications.triggerHelloWorldEvent()}
          >
            <Bell
              class={style({
                key: 'bellIcon',
                className: 'nt-size-4 nt-mr-2',
              })}
            />
            Send 'Hello World!'
          </Button>
        </div>
      </div>
    </div>
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Show } from 'solid-js';
import { useInboxContext, useNovu } from '../../context';
import { useLocalization } from '../../context/LocalizationContext';
import { useStyle } from '../../helpers/useStyle';
import { Bell } from '../../icons';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/Notification/SnoozeDateTimePicker.tsx
Tamaño: 6453 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Component, createEffect, createMemo, createSignal, onCleanup, Show } from 'solid-js';
import { useLocalization } from '../../context/LocalizationContext';
import { useStyle } from '../../helpers';
import { Button } from '../primitives/Button';
import { DatePicker, DatePickerCalendar, DatePickerHeader } from '../primitives/DatePicker';
import { TimePicker, TimeValue } from '../primitives/TimePicker';
import { Tooltip } from '../primitives/Tooltip';

const fiveMinutesFromNow = () => {
  const futureTime = new Date(Date.now() + 5 * 60 * 1000);
  const hours = futureTime.getHours();
  const isPM = hours >= 12;

  let hour;
  if (hours === 0) {
    hour = 12; // 12 AM
  } else if (hours === 12) {
    hour = 12; // 12 PM
  } else {
    hour = hours % 12; // 1-11 AM/PM
  }

  return {
    hour,
    minute: futureTime.getMinutes(),
    isPM,
  };
};

/**
 * Converts a 12-hour format time to 24-hour hours value
 * Correctly handles the special case of 12 AM/PM:
 * - 12:00 AM = 00:00 (midnight)
 * - 12:00 PM = 12:00 (noon)
 */
const convertTo24Hour = (time: TimeValue): number => {
  if (time.isPM) {
    return time.hour === 12 ? 12 : time.hour + 12;
  } else {
    return time.hour === 12 ? 0 : time.hour;
  }
};

const REFRESH_INTERVAL = 5_000;

interface SnoozeDateTimePickerProps {
  onSelect?: (date: Date) => void;
  onCancel?: () => void;
  maxDurationHours?: number;
}

export const SnoozeDateTimePicker: Component<SnoozeDateTimePickerProps> = (props) => {
  const style = useStyle();
  const { t } = useLocalization();
  const [selectedDate, setSelectedDate] = createSignal<Date | null>(null);
  const [timeValue, setTimeValue] = createSignal<TimeValue>(fiveMinutesFromNow());
  const [currentTime, setCurrentTime] = createSignal(new Date());

  // Update current time every N seconds to ensure validation remains accurate
  createEffect(() => {
    const interval = setInterval(() => {
      setCurrentTime(new Date());
    }, REFRESH_INTERVAL);

    onCleanup(() => clearInterval(interval));
  });

  const onDateTimeSelect = () => {
    if (selectedDate() && timeValue()) {
      const date = new Date(selectedDate()!);
      const hours = convertTo24Hour(timeValue());

      date.setHours(hours, timeValue().minute, 0, 0);
      props.onSelect?.(date);
    }
  };

  const maxDays = () => {
    if (!props.maxDurationHours) return 0;

    return Math.ceil(props.maxDurationHours / 24);
  };

  const getSelectedDateTime = (): Date | null => {
    if (!selectedDate() || !timeValue()) return null;

    const date = new Date(selectedDate()!);
    const hours = convertTo24Hour(timeValue());
    date.setHours(hours, timeValue().minute, 0, 0);

    return date;
  };

  const isTimeInPast = createMemo(() => {
    const dateTime = getSelectedDateTime();
    if (!dateTime) return false;

    // The time must be at least 3 minutes in the future
    const minAllowedDateTime = new Date(currentTime().getTime() + 3 * 60 * 1000);

    return dateTime < minAllowedDateTime;
  });

  const isTimeExceedingMaxDuration = createMemo(() => {
    const dateTime = getSelectedDateTime();
    if (!dateTime || !props.maxDurationHours) return false;

    const maxAllowedDateTime = new Date(currentTime().getTime() + props.maxDurationHours * 60 * 60 * 1000);

    return dateTime > maxAllowedDateTime;
  });

  const applyButtonEnabled = createMemo(() => {
    if (!selectedDate() || !timeValue()) {
      return false;
    }

    // Check if the date is in the future (at least 3 minutes)
    if (isTimeInPast()) {
      return false;
    }

    // Check if date exceeds max duration (if set)
    if (props.maxDurationHours && isTimeExceedingMaxDuration()) {
      return false;
    }

    return true;
  });

  const getTooltipMessage = createMemo(() => {
    if (isTimeInPast()) {
      return t('snooze.datePicker.pastDateTooltip');
    }

    if (isTimeExceedingMaxDuration()) {
      return t('snooze.datePicker.exceedingLimitTooltip', { days: maxDays() });
    }

    return t('snooze.datePicker.noDateSelectedTooltip');
  });

  return (
    <div
      class={style({
        key: 'snoozeDatePicker',
        className: 'nt-bg-background nt-rounded-md nt-shadow-lg nt-w-[260px]',
      })}
      onClick={(e) => e.stopPropagation()}
    >
      <DatePicker onDateChange={(date) => setSelectedDate(date)} maxDays={maxDays()}>
        <DatePickerHeader />

        <DatePickerCalendar />
      </DatePicker>

      <div
        class={style({
          key: 'snoozeDatePicker__timePickerContainer',
          className:
            'nt-flex nt-flex-row nt-justify-between nt-p-2 nt-items-center nt-border-t nt-border-neutral-200 nt-border-b',
        })}
      >
        <p
          class={style({
            key: 'snoozeDatePicker__timePickerLabel',
            className: 'nt-text-sm nt-font-medium nt-text-foreground-alpha-700 nt-p-2',
          })}
        >
          {t('snooze.datePicker.timePickerLabel')}
        </p>
        <TimePicker value={timeValue()} onChange={setTimeValue} />
      </div>

      <div
        class={style({
          key: 'snoozeDatePicker__actions',
          className: 'nt-flex nt-flex-row nt-justify-end nt-gap-2 nt-p-2',
        })}
      >
        <Button
          appearanceKey="snoozeDatePickerCancel__button"
          variant="secondary"
          class="nt-h-7 nt-w-[60px] nt-px-2"
          onClick={props.onCancel}
        >
          {t('snooze.datePicker.cancel')}
        </Button>

        <Show
          when={applyButtonEnabled()}
          fallback={
            <Tooltip.Root>
              <Tooltip.Trigger
                asChild={(props) => (
                  <Button
                    appearanceKey="snoozeDatePickerApply__button"
                    class="nt-h-7 nt-w-[60px] nt-px-2 !nt-pointer-events-auto"
                    onClick={onDateTimeSelect}
                    disabled={true}
                    {...props}
                  >
                    {t('snooze.datePicker.apply')}
                  </Button>
                )}
              />
              <Tooltip.Content>{getTooltipMessage()}</Tooltip.Content>
            </Tooltip.Root>
          }
        >
          <Button
            appearanceKey="snoozeDatePickerApply__button"
            class="nt-h-7 nt-w-[60px] nt-px-2"
            onClick={onDateTimeSelect}
          >
            {t('snooze.datePicker.apply')}
          </Button>
        </Show>
      </div>
    </div>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Component, createEffect, createMemo, createSignal, onCleanup, Show } from 'solid-js';
import { useLocalization } from '../../context/LocalizationContext';
import { useStyle } from '../../helpers';
import { Button } from '../primitives/Button';
import { DatePicker, DatePickerCalendar, DatePickerHeader } from '../primitives/DatePicker';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/Notification/index.ts
Tamaño: 126 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './Notification';
export * from './NotificationActions';
export { NotificationList } from './NotificationList';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/components/elements/Footer.tsx
Tamaño: 5827 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Show } from 'solid-js';
import { useInboxContext, useNovu } from 'src/ui/context';
import { isBrowser } from 'src/utils/is-browser';
import { DEFAULT_API_VERSION } from '../../../api/http-client';
import { cn } from '../../helpers';
import { Novu } from '../../icons';
import { ArrowUpRight } from '../../icons/ArrowUpRight';
import { CopyToClipboard } from '../primitives/CopyToClipboard';
import { Tooltip } from '../primitives/Tooltip';

const stripes = `before:nt-content-[""] before:nt-absolute before:nt-inset-0 before:-nt-right-[calc(0+var(--stripes-size))] before:[mask-image:linear-gradient(transparent_0%,black)] before:nt-bg-dev-stripes-gradient before:nt-bg-[length:var(--stripes-size)_var(--stripes-size)] before:nt-animate-stripes before:hover:[animation-play-state:running]`;
const commonAfter = 'after:nt-content-[""] after:nt-absolute after:nt-inset-0 after:-nt-top-12';
const devModeGradient = `${commonAfter} after:nt-bg-[linear-gradient(180deg,transparent,oklch(from_var(--nv-color-stripes)_l_c_h_/_0.07)_55%,transparent),linear-gradient(180deg,transparent,oklch(from_var(--nv-color-background)_l_c_h_/_0.9)_55%,transparent)]`;
const prodModeGradient = `${commonAfter} after:nt-bg-[linear-gradient(180deg,transparent,oklch(from_var(--nv-color-background)_l_c_h_/_0.9)_55%,transparent)]`;

export const Footer = () => {
  const { hideBranding, isDevelopmentMode, isKeyless } = useInboxContext();
  const novu = useNovu();

  async function handleTriggerHelloWorld() {
    try {
      await novu.notifications.triggerHelloWorldEvent();
      // TODO: maybe add some user feedback on success?
    } catch (error) {
      // Error is already logged by the service, but you could add UI feedback here
      console.error('Failed to send Hello World from UI via novu.notifications:', error);
    }
  }

  return (
    <Show when={!hideBranding() || isDevelopmentMode()}>
      <div
        class={cn(
          `nt-relative nt-flex nt-shrink-0 nt-flex-col nt-justify-center nt-items-center nt-gap-1 nt-mt-auto nt-py-3 nt-text-foreground-alpha-400`,
          {
            [stripes]: isDevelopmentMode(),
            [devModeGradient]: isDevelopmentMode(),
            'nt-bg-[oklch(from_var(--nv-color-stripes)_l_c_h_/_0.1)]': isDevelopmentMode(),
            [prodModeGradient]: !isDevelopmentMode(),
          }
        )}
        style={{
          '--stripes-size': '15px',
        }}
      >
        <div class="nt-flex nt-items-center nt-gap-1">
          <Show when={isDevelopmentMode()}>
            <span class="nt-z-10 nt-text-xs nt-text-stripes">
              {isKeyless() ? (
                <Tooltip.Root>
                  <Tooltip.Trigger class="">
                    <a
                      href="https://go.novu.co/keyless?utm_campaign=keyless-mode"
                      target="_blank"
                      rel="noopener noreferrer"
                    >
                      Keyless mode
                    </a>
                  </Tooltip.Trigger>
                  <Tooltip.Content>
                    Temporary &lt;Inbox /&gt;. All data will expire in 24 hours.
                    <br />
                    Connect API key to persist.
                  </Tooltip.Content>
                </Tooltip.Root>
              ) : (
                'Development mode'
              )}
            </span>
          </Show>
          <Show when={isDevelopmentMode() && !hideBranding()}>
            <span class="nt-z-10 nt-text-xs">•</span>
          </Show>
          <Show when={!hideBranding()}>
            <a
              href={`https://go.novu.co/powered?ref=${getCurrentDomain()}`}
              target="_blank"
              class="nt-z-10 nt-flex nt-items-center nt-gap-1 nt-justify-center"
            >
              <span class="nt-text-xs">Inbox by</span>
              <Novu class="nt-size-2.5" />
              <span class="nt-text-xs">Novu</span>
            </a>
          </Show>
        </div>
        <Show when={isKeyless()}>
          <div class="nt-z-10 nt-flex nt-items-center nt-gap-1 nt-text-xs nt-text-secondary-foreground">
            <a
              href="https://go.novu.co/keyless"
              class="nt-underline nt-flex nt-items-center nt-gap-0.5"
              target="_blank"
              rel="noopener noreferrer"
            >
              Get API key
              <ArrowUpRight class="nt-ml-1" />
            </a>
            <span>•</span>
            <CopyToClipboard textToCopy={getCurlCommand()}>
              <span class="nt-underline">Copy cURL</span>
            </CopyToClipboard>
            <span>•</span>
            <button
              type="button"
              class="nt-underline"
              onClick={(e) => {
                e.preventDefault();
                handleTriggerHelloWorld();
              }}
            >
              Send notification
            </button>
          </div>
        </Show>
      </div>
    </Show>
  );
};

function getCurrentDomain() {
  if (isBrowser()) {
    return window.location.hostname;
  }

  return '';
}

function getCurlCommand() {
  const identifier = window.localStorage.getItem('novu_keyless_application_identifier');
  if (!identifier) {
    console.error('Novu application identifier not found for cURL command.');

    return '';
  }
  const DEFAULT_BACKEND_URL =
    (typeof window !== 'undefined' && (window as any).NOVU_LOCAL_BACKEND_URL) || 'https://api.novu.co';

  return `curl -X POST \
  ${DEFAULT_BACKEND_URL}/${DEFAULT_API_VERSION}/events/trigger \
  -H 'Authorization: Keyless ${identifier}' \
  -H 'Content-Type: application/json' \
  -d '{
    "name": "hello-world",
    "to": {
      "subscriberId": "keyless-subscriber-id"
    },
    "payload": {
      "body": "New From Keyless Environment",
      "subject": "Hello World!"
    }
  }'`;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Show } from 'solid-js';
import { useInboxContext, useNovu } from 'src/ui/context';
import { isBrowser } from 'src/utils/is-browser';
import { DEFAULT_API_VERSION } from '../../../api/http-client';
import { cn } from '../../helpers';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/elements/Markdown.tsx
Tamaño: 1548 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { createMemo, For, JSX, splitProps } from 'solid-js';
import { cn, useStyle } from '../../helpers';
import { parseMarkdownIntoTokens } from '../../internal';
import { AppearanceKey } from '../../types';

const Bold = (props: { children?: JSX.Element; appearanceKey?: AppearanceKey }) => {
  const style = useStyle();

  return (
    <strong
      class={style({
        key: props.appearanceKey || 'strong',
        className: 'nt-font-semibold',
      })}
    >
      {props.children}
    </strong>
  );
};
const Text = (props: { children?: JSX.Element }) => props.children;

type MarkdownProps = JSX.HTMLAttributes<HTMLParagraphElement> & {
  appearanceKey: AppearanceKey;
  strongAppearanceKey: AppearanceKey;
  children: string;
  context?: Record<string, unknown>;
};
const Markdown = (props: MarkdownProps) => {
  const [local, rest] = splitProps(props, ['class', 'children', 'appearanceKey', 'strongAppearanceKey', 'context']);
  const style = useStyle();

  const tokens = createMemo(() => parseMarkdownIntoTokens(local.children));

  return (
    <p
      class={style({
        key: local.appearanceKey,
        className: cn(local.class),
        context: local.context,
      })}
      {...rest}
    >
      <For each={tokens()}>
        {(token) => {
          if (token.type === 'bold') {
            return <Bold appearanceKey={local.strongAppearanceKey}>{token.content}</Bold>;
          } else {
            return <Text>{token.content}</Text>;
          }
        }}
      </For>
    </p>
  );
};

export default Markdown;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { createMemo, For, JSX, splitProps } from 'solid-js';
import { cn, useStyle } from '../../helpers';
import { parseMarkdownIntoTokens } from '../../internal';
import { AppearanceKey } from '../../types';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/elements/Root.tsx
Tamaño: 813 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Show, splitProps } from 'solid-js';
import { JSX } from 'solid-js/jsx-runtime';
import { useAppearance, useInboxContext } from '../../context';
import { cn, useStyle } from '../../helpers';

type RootProps = JSX.IntrinsicElements['div'];
export const Root = (props: RootProps) => {
  const [_, rest] = splitProps(props, ['class']);
  const { id } = useAppearance();
  const style = useStyle();
  const { hideBranding } = useInboxContext();

  return (
    <>
      <Show when={!hideBranding()}>{new Comment(' Powered by Novu - https://novu.co ')}</Show>
      <div
        id={`novu-root-${id()}`}
        class={style({
          key: 'root',
          className: cn('novu', id(), 'nt-text-foreground nt-h-full [interpolate-size:allow-keywords]'),
        })}
        {...rest}
      />
    </>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Show, splitProps } from 'solid-js';
import { JSX } from 'solid-js/jsx-runtime';
import { useAppearance, useInboxContext } from '../../context';
import { cn, useStyle } from '../../helpers';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/elements/index.ts
Tamaño: 131 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './Bell';
export * from './Footer';
export * from './Header';
export * from './Preferences';
export * from './Root';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/components/elements/Bell/Bell.tsx
Tamaño: 744 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Component, Show } from 'solid-js';
import { useUnreadCount } from '../../../context';
import { BellRenderer } from '../../../types';
import { ExternalElementRenderer } from '../../ExternalElementRenderer';
import { BellContainer } from './DefaultBellContainer';

type BellProps = {
  renderBell?: BellRenderer;
};
/* This is also going to be exported as a separate component. Keep it pure. */
export const Bell: Component<BellProps> = (props) => {
  const { unreadCount } = useUnreadCount();

  return (
    <Show when={props.renderBell} fallback={<BellContainer unreadCount={unreadCount()} />}>
      <ExternalElementRenderer render={(el) => (props.renderBell ? props.renderBell(el, unreadCount()) : () => {})} />
    </Show>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Component, Show } from 'solid-js';
import { useUnreadCount } from '../../../context';
import { BellRenderer } from '../../../types';
import { ExternalElementRenderer } from '../../ExternalElementRenderer';
import { BellContainer } from './DefaultBellContainer';
/* This is also going to be exported as a separate component. Keep it pure. */
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/elements/Bell/DefaultBellContainer.tsx
Tamaño: 4520 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { createMemo, Show } from 'solid-js';
import { SeverityLevelEnum } from '../../../../types';
import { cn, useStyle } from '../../../helpers';
import { Bell as DefaultBell } from '../../../icons';
import { AppearanceCallback, AppearanceKey } from '../../../types';
import { IconRendererWrapper } from '../../shared/IconRendererWrapper';

type DefaultBellContainerProps = {
  unreadCount: { total: number; severity: Record<string, number> };
};

const SEVERITY_GLOW_KEYS: Record<SeverityLevelEnum, AppearanceKey> = {
  [SeverityLevelEnum.NONE]: 'bellSeverityGlow',
  [SeverityLevelEnum.HIGH]: 'severityGlowHigh__bellSeverityGlow',
  [SeverityLevelEnum.MEDIUM]: 'severityGlowMedium__bellSeverityGlow',
  [SeverityLevelEnum.LOW]: 'severityGlowLow__bellSeverityGlow',
};

const SEVERITY_TO_CONTAINER_KEYS: Record<SeverityLevelEnum, AppearanceKey> = {
  [SeverityLevelEnum.NONE]: 'bellContainer',
  [SeverityLevelEnum.HIGH]: 'severityHigh__bellContainer',
  [SeverityLevelEnum.MEDIUM]: 'severityMedium__bellContainer',
  [SeverityLevelEnum.LOW]: 'severityLow__bellContainer',
};

export const BellContainer = (props: DefaultBellContainerProps) => {
  const style = useStyle();

  const severity = createMemo(() => {
    if (props.unreadCount.severity[SeverityLevelEnum.HIGH] > 0) {
      return SeverityLevelEnum.HIGH;
    } else if (props.unreadCount.severity[SeverityLevelEnum.MEDIUM] > 0) {
      return SeverityLevelEnum.MEDIUM;
    } else if (props.unreadCount.severity[SeverityLevelEnum.LOW] > 0) {
      return SeverityLevelEnum.LOW;
    }

    return SeverityLevelEnum.NONE;
  });

  const unreadCount = createMemo(() => props.unreadCount);

  return (
    <span
      class={style({
        key: SEVERITY_TO_CONTAINER_KEYS[severity()],
        className: cn(
          'nt-size-4 nt-flex nt-justify-center nt-items-center nt-relative nt-text-foreground nt-cursor-pointer [&_stop]:nt-transition-[stop-color]',
          {
            '[--bell-gradient-start:var(--nv-color-severity-high)] [--bell-gradient-end:oklch(from_var(--nv-color-severity-high)_45%_c_h)]':
              severity() === SeverityLevelEnum.HIGH,
            '[--bell-gradient-start:var(--nv-color-severity-medium)] [--bell-gradient-end:oklch(from_var(--nv-color-severity-medium)_45%_c_h)]':
              severity() === SeverityLevelEnum.MEDIUM,
            '[--bell-gradient-start:var(--nv-color-severity-low)] [--bell-gradient-end:oklch(from_var(--nv-color-severity-low)_45%_c_h)]':
              severity() === SeverityLevelEnum.LOW,
          }
        ),
        context: { unreadCount: unreadCount() } satisfies Parameters<AppearanceCallback['bellContainer']>[0],
      })}
    >
      <div
        class={style({
          key: SEVERITY_GLOW_KEYS[severity()],
          className: cn(
            'nt-transition nt-absolute nt-inset-0 -nt-m-1 nt-rounded-full before:nt-content-[""] before:nt-absolute before:nt-inset-0 before:nt-rounded-full before:nt-m-1',
            {
              'nt-bg-severity-high-alpha-100 before:nt-bg-severity-high-alpha-200':
                severity() === SeverityLevelEnum.HIGH,
              'nt-bg-severity-medium-alpha-100 before:nt-bg-severity-medium-alpha-200':
                severity() === SeverityLevelEnum.MEDIUM,
              'nt-bg-severity-low-alpha-100 before:nt-bg-severity-low-alpha-200': severity() === SeverityLevelEnum.LOW,
            }
          ),
          context: { unreadCount: unreadCount() } satisfies Parameters<AppearanceCallback['bellContainer']>[0],
        })}
      />

      <IconRendererWrapper
        iconKey="bell"
        class={style({
          key: 'bellIcon',
          className: 'nt-size-4',
          context: { unreadCount: unreadCount() } satisfies Parameters<AppearanceCallback['bellIcon']>[0],
        })}
        fallback={
          <DefaultBell
            class={style({
              key: 'bellIcon',
              className: 'nt-size-4',
              context: { unreadCount: unreadCount() } satisfies Parameters<AppearanceCallback['bellIcon']>[0],
            })}
          />
        }
      />
      <Show when={props.unreadCount.total > 0}>
        <span
          class={style({
            key: 'bellDot',
            className:
              'nt-absolute nt-top-0 nt-right-0 nt-block nt-size-2 nt-transform nt-bg-counter nt-rounded-full nt-border nt-border-background',
            context: { unreadCount: unreadCount() } satisfies Parameters<AppearanceCallback['bellDot']>[0],
          })}
        />
      </Show>
    </span>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { createMemo, Show } from 'solid-js';
import { SeverityLevelEnum } from '../../../../types';
import { cn, useStyle } from '../../../helpers';
import { Bell as DefaultBell } from '../../../icons';
import { AppearanceCallback, AppearanceKey } from '../../../types';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/elements/Bell/index.ts
Tamaño: 24 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './Bell';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/components/elements/Header/ActionsContainer.tsx
Tamaño: 1167 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Show } from 'solid-js';
import { useStyle } from '../../../helpers';
import { Cogs as DefaultCogs } from '../../../icons';
import { Button } from '../../primitives';
import { IconRendererWrapper } from '../../shared/IconRendererWrapper';
import { MoreActionsDropdown } from './MoreActionsDropdown';

type ActionsContainerProps = {
  showPreferences?: () => void;
};

export const ActionsContainer = (props: ActionsContainerProps) => {
  const style = useStyle();
  const cogsIconClass = style({
    key: 'icon',
    className: 'nt-size-5',
    iconKey: 'cogs',
  });

  return (
    <div
      class={style({
        key: 'moreActionsContainer',
        className: 'nt-flex nt-gap-3',
      })}
    >
      <MoreActionsDropdown />
      <Show when={props.showPreferences}>
        {(showPreferences) => (
          <Button appearanceKey="preferences__button" variant="ghost" size="iconSm" onClick={showPreferences()}>
            <IconRendererWrapper
              iconKey="cogs"
              class={cogsIconClass}
              fallback={<DefaultCogs class={cogsIconClass} />}
            />
          </Button>
        )}
      </Show>
    </div>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Show } from 'solid-js';
import { useStyle } from '../../../helpers';
import { Cogs as DefaultCogs } from '../../../icons';
import { Button } from '../../primitives';
import { IconRendererWrapper } from '../../shared/IconRendererWrapper';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/elements/Header/Header.tsx
Tamaño: 658 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { useStyle } from '../../../helpers';
import { StatusDropdown } from '../InboxStatus/InboxStatusDropdown';
import { ActionsContainer } from './ActionsContainer';

type HeaderProps = {
  navigateToPreferences?: () => void;
};

export const Header = (props: HeaderProps) => {
  const style = useStyle();

  return (
    <div
      class={style({
        key: 'inboxHeader',
        className:
          'nt-flex nt-bg-neutral-alpha-25 nt-shrink-0 nt-justify-between nt-items-center nt-w-full nt-pb-2 nt-pt-2.5 nt-px-4',
      })}
    >
      <StatusDropdown />
      <ActionsContainer showPreferences={props.navigateToPreferences} />
    </div>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { useStyle } from '../../../helpers';
import { StatusDropdown } from '../InboxStatus/InboxStatusDropdown';
import { ActionsContainer } from './ActionsContainer';
type HeaderProps = {
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/elements/Header/MoreActionsDropdown.tsx
Tamaño: 1414 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Show } from 'solid-js';
import { useInboxContext } from 'src/ui/context';
import { useStyle } from '../../../helpers';
import { Dots as DefaultDots } from '../../../icons';
import { NotificationStatus } from '../../../types';
import { Button, Dropdown } from '../../primitives';
import { IconRendererWrapper } from '../../shared/IconRendererWrapper';
import { MoreActionsOptions } from './MoreActionsOptions';

export const MoreActionsDropdown = () => {
  const style = useStyle();
  const { status } = useInboxContext();
  const dotsIconClass = style({
    key: 'moreActions__dots',
    className: 'nt-size-5',
    iconKey: 'dots',
  });

  return (
    <Show when={status() !== NotificationStatus.ARCHIVED && status() !== NotificationStatus.SNOOZED}>
      <Dropdown.Root>
        <Dropdown.Trigger
          class={style({
            key: 'moreActions__dropdownTrigger',
          })}
          asChild={(triggerProps) => (
            <Button variant="ghost" size="iconSm" {...triggerProps}>
              <IconRendererWrapper
                iconKey="dots"
                class={dotsIconClass}
                fallback={<DefaultDots class={dotsIconClass} />}
              />
            </Button>
          )}
        />
        <Dropdown.Content appearanceKey="moreActions__dropdownContent">
          <MoreActionsOptions />
        </Dropdown.Content>
      </Dropdown.Root>
    </Show>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Show } from 'solid-js';
import { useInboxContext } from 'src/ui/context';
import { useStyle } from '../../../helpers';
import { Dots as DefaultDots } from '../../../icons';
import { NotificationStatus } from '../../../types';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/elements/Header/MoreActionsOptions.tsx
Tamaño: 2866 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSXElement } from 'solid-js';
import { JSX as SolidJSX } from 'solid-js/jsx-runtime';
import { useArchiveAll, useArchiveAllRead, useReadAll } from '../../../api';
import { StringLocalizationKey, useInboxContext, useLocalization } from '../../../context';
import { cn, useStyle } from '../../../helpers';
import { MarkAsArchived, MarkAsArchivedRead, MarkAsRead } from '../../../icons';
import { IconKey, IconOverrides } from '../../../types';
import { Dropdown, dropdownItemVariants } from '../../primitives';
import { IconRendererWrapper } from '../../shared/IconRendererWrapper';

type IconComponentType = (props?: SolidJSX.HTMLAttributes<SVGSVGElement>) => JSXElement;

const iconKeyToComponentMap: { [key in keyof IconOverrides]?: IconComponentType } = {
  markAsRead: MarkAsRead,
  markAsArchived: MarkAsArchived,
  markAsArchivedRead: MarkAsArchivedRead,
};

export const MoreActionsOptions = () => {
  const { filter } = useInboxContext();
  const { readAll } = useReadAll();
  const { archiveAll } = useArchiveAll();
  const { archiveAllRead } = useArchiveAllRead();

  return (
    <>
      <ActionsItem
        localizationKey="notifications.actions.readAll"
        onClick={() => readAll({ tags: filter().tags, data: filter().data })}
        iconKey="markAsRead"
      />
      <ActionsItem
        localizationKey="notifications.actions.archiveAll"
        onClick={() => archiveAll({ tags: filter().tags, data: filter().data })}
        iconKey="markAsArchived"
      />
      <ActionsItem
        localizationKey="notifications.actions.archiveRead"
        onClick={() => archiveAllRead({ tags: filter().tags, data: filter().data })}
        iconKey="markAsArchivedRead"
      />
    </>
  );
};

export const ActionsItem = (props: {
  localizationKey: StringLocalizationKey;
  onClick: () => void;
  iconKey: IconKey;
}) => {
  const style = useStyle();
  const { t } = useLocalization();
  const DefaultIconComponent = iconKeyToComponentMap[props.iconKey];
  const moreActionsIconClass = style({
    key: 'moreActions__dropdownItemLeft__icon',
    className: 'nt-size-3',
    iconKey: props.iconKey,
  });

  return (
    <Dropdown.Item
      class={style({
        key: 'moreActions__dropdownItem',
        className: cn(dropdownItemVariants(), 'nt-flex nt-gap-2'),
      })}
      onClick={props.onClick}
    >
      <IconRendererWrapper
        iconKey={props.iconKey}
        class={moreActionsIconClass}
        fallback={
          DefaultIconComponent &&
          DefaultIconComponent({
            class: moreActionsIconClass,
          })
        }
      />
      <span
        data-localization={props.localizationKey}
        class={style({
          key: 'moreActions__dropdownItemLabel',
          className: 'nt-leading-none',
        })}
      >
        {t(props.localizationKey)}
      </span>
    </Dropdown.Item>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSXElement } from 'solid-js';
import { JSX as SolidJSX } from 'solid-js/jsx-runtime';
import { useArchiveAll, useArchiveAllRead, useReadAll } from '../../../api';
import { StringLocalizationKey, useInboxContext, useLocalization } from '../../../context';
import { cn, useStyle } from '../../../helpers';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/elements/Header/index.ts
Tamaño: 26 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './Header';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/components/elements/InboxStatus/InboxStatusDropdown.tsx
Tamaño: 1874 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { useInboxContext, useLocalization } from '../../../context';
import { cn, useStyle } from '../../../helpers';
import { ArrowDropDown as DefaultArrowDropDown } from '../../../icons';
import { Button, buttonVariants, Dropdown } from '../../primitives';
import { IconRendererWrapper } from '../../shared/IconRendererWrapper';
import { inboxFilterLocalizationKeys } from './constants';
import { StatusOptions } from './InboxStatusOptions';

export const StatusDropdown = () => {
  const style = useStyle();
  const { status, setStatus } = useInboxContext();
  const { t } = useLocalization();
  const arrowDropDownIconClass = style({
    key: 'inboxStatus__dropdownItemRight__icon',
    className: 'nt-text-foreground-alpha-600 nt-size-4',
    iconKey: 'arrowDropDown',
  });

  return (
    <Dropdown.Root>
      <Dropdown.Trigger
        class={style({
          key: 'inboxStatus__dropdownTrigger',
          className: cn(buttonVariants({ variant: 'unstyled', size: 'none' }), 'nt-gap-0.5'),
        })}
        asChild={(triggerProps) => (
          <Button variant="unstyled" size="none" {...triggerProps}>
            <span
              data-localization={inboxFilterLocalizationKeys[status()]}
              class={style({
                key: 'inboxStatus__title',
                className: 'nt-text-base',
              })}
            >
              {t(inboxFilterLocalizationKeys[status()])}
            </span>
            <IconRendererWrapper
              iconKey="arrowDropDown"
              class={arrowDropDownIconClass}
              fallback={<DefaultArrowDropDown class={arrowDropDownIconClass} />}
            />
          </Button>
        )}
      />
      <Dropdown.Content appearanceKey="inboxStatus__dropdownContent">
        <StatusOptions setStatus={setStatus} status={status()} />
      </Dropdown.Content>
    </Dropdown.Root>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { useInboxContext, useLocalization } from '../../../context';
import { cn, useStyle } from '../../../helpers';
import { ArrowDropDown as DefaultArrowDropDown } from '../../../icons';
import { Button, buttonVariants, Dropdown } from '../../primitives';
import { IconRendererWrapper } from '../../shared/IconRendererWrapper';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/elements/InboxStatus/InboxStatusOptions.tsx
Tamaño: 3402 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { For, Show } from 'solid-js';
import { JSX } from 'solid-js/jsx-runtime';
import { StringLocalizationKey, useInboxContext, useLocalization } from '../../../context';
import { cn, useStyle } from '../../../helpers';
import { Clock, Check as DefaultCheck, MarkAsArchived, MarkAsUnread, Unread } from '../../../icons';
import { IconKey, NotificationStatus } from '../../../types';
import { Dropdown, dropdownItemVariants } from '../../primitives/Dropdown';
import { IconRendererWrapper } from '../../shared/IconRendererWrapper';
import { notificationStatusOptionsLocalizationKeys } from './constants';

const cases = [
  {
    status: NotificationStatus.UNREAD_READ,
    iconKey: 'unread',
    icon: Unread,
  },
  {
    status: NotificationStatus.UNREAD,
    iconKey: 'unread',
    icon: MarkAsUnread,
  },
  {
    status: NotificationStatus.SNOOZED,
    iconKey: 'clock',
    icon: Clock,
  },
  {
    status: NotificationStatus.ARCHIVED,
    iconKey: 'markAsArchived',
    icon: MarkAsArchived,
  },
] satisfies { status: NotificationStatus; iconKey: IconKey; icon: () => JSX.Element }[];

export const StatusOptions = (props: {
  setStatus: (status: NotificationStatus) => void;
  status: NotificationStatus;
}) => {
  const { isSnoozeEnabled } = useInboxContext();

  const filteredCases = () => {
    return cases.filter((c) => c.status !== NotificationStatus.SNOOZED || isSnoozeEnabled());
  };

  return (
    <For each={filteredCases()}>
      {(c) => (
        <StatusItem
          localizationKey={notificationStatusOptionsLocalizationKeys[c.status]}
          onClick={() => {
            props.setStatus(c.status);
          }}
          isSelected={props.status === c.status}
          icon={c.icon}
          iconKey={c.iconKey}
        />
      )}
    </For>
  );
};

export const StatusItem = (props: {
  localizationKey: StringLocalizationKey;
  onClick: () => void;
  isSelected?: boolean;
  icon: () => JSX.Element;
  iconKey: IconKey;
}) => {
  const style = useStyle();
  const { t } = useLocalization();
  const itemIconClass = style({
    key: 'inboxStatus__dropdownItemLeft__icon',
    className: 'nt-size-3',
    iconKey: props.iconKey,
  });
  const checkIconClass = style({
    key: 'inboxStatus__dropdownItemCheck__icon',
    className: 'nt-size-3',
    iconKey: 'check',
  });

  return (
    <Dropdown.Item
      class={style({
        key: 'inboxStatus__dropdownItem',
        className: cn(dropdownItemVariants(), 'nt-flex nt-gap-8 nt-justify-between'),
      })}
      onClick={props.onClick}
    >
      <span
        class={style({
          key: 'inboxStatus__dropdownItemLabelContainer',
          className: 'nt-flex nt-gap-2 nt-items-center',
        })}
      >
        <IconRendererWrapper
          iconKey={props.iconKey}
          class={itemIconClass}
          fallback={<span class={itemIconClass}>{props.icon()}</span>}
        />

        <span
          data-localization={props.localizationKey}
          class={style({
            key: 'inboxStatus__dropdownItemLabel',
            className: 'nt-leading-none',
          })}
        >
          {t(props.localizationKey)}
        </span>
      </span>
      <Show when={props.isSelected}>
        <IconRendererWrapper
          iconKey="check"
          class={checkIconClass}
          fallback={<DefaultCheck class={checkIconClass} />}
        />
      </Show>
    </Dropdown.Item>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { For, Show } from 'solid-js';
import { JSX } from 'solid-js/jsx-runtime';
import { StringLocalizationKey, useInboxContext, useLocalization } from '../../../context';
import { cn, useStyle } from '../../../helpers';
import { Clock, Check as DefaultCheck, MarkAsArchived, MarkAsUnread, Unread } from '../../../icons';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/elements/InboxStatus/constants.ts
Tamaño: 699 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { LocalizationKey, NotificationStatus } from '../../../types';

export const notificationStatusOptionsLocalizationKeys = {
  unreadRead: 'inbox.filters.dropdownOptions.default',
  unread: 'inbox.filters.dropdownOptions.unread',
  archived: 'inbox.filters.dropdownOptions.archived',
  snoozed: 'inbox.filters.dropdownOptions.snoozed',
} as const satisfies Record<NotificationStatus, LocalizationKey>;

export const inboxFilterLocalizationKeys = {
  unreadRead: 'inbox.filters.labels.default',
  unread: 'inbox.filters.labels.unread',
  archived: 'inbox.filters.labels.archived',
  snoozed: 'inbox.filters.labels.snoozed',
} as const satisfies Record<NotificationStatus, LocalizationKey>;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/components/elements/Preferences/ChannelRow.tsx
Tamaño: 6898 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX } from 'solid-js';
import { ChannelPreference, ChannelType, Preference } from '../../../../types';
import { useStyle } from '../../../helpers';
import {
  Chat as DefaultChat,
  Email as DefaultEmail,
  InApp as DefaultInApp,
  Push as DefaultPush,
  Sms as DefaultSms,
} from '../../../icons';
import { AppearanceCallback, AppearanceKey, IconKey } from '../../../types';
import { Switch, SwitchState } from '../../primitives/Switch';
import { IconRendererWrapper } from '../../shared/IconRendererWrapper';

type ChannelRowProps = {
  channel: { channel: ChannelType; state: SwitchState };
  channelIcon?: () => JSX.Element;
  workflowId?: string;
  onChange: (channels: ChannelPreference) => void;
  preference?: Preference;
  preferenceGroup?: { name: string; preferences: Preference[] };
};

export const ChannelRow = (props: ChannelRowProps) => {
  const style = useStyle();

  const updatePreference = async (enabled: boolean) => {
    props.onChange({ [props.channel.channel]: enabled });
  };

  const onChange = async (checked: boolean) => {
    await updatePreference(checked);
  };

  const state = () => props.channel.state;
  const channel = () => props.channel.channel;

  return (
    <div
      class={style({
        key: 'channelContainer',
        className:
          'nt-flex nt-justify-between nt-items-center nt-gap-2 data-[disabled=true]:nt-text-foreground-alpha-600',
        context: { preference: props.preference, preferenceGroup: props.preferenceGroup } satisfies Parameters<
          AppearanceCallback['channelContainer']
        >[0],
      })}
    >
      <div
        class={style({
          key: 'channelLabelContainer',
          className: 'nt-flex nt-items-center nt-gap-2 nt-text-foreground',
          context: { preference: props.preference, preferenceGroup: props.preferenceGroup } satisfies Parameters<
            AppearanceCallback['channelLabelContainer']
          >[0],
        })}
      >
        <div
          class={style({
            key: 'channelIconContainer',
            className: 'nt-p-1 nt-rounded-md nt-bg-neutral-alpha-25 nt-text-foreground-alpha-300',
            context: { preference: props.preference, preferenceGroup: props.preferenceGroup } satisfies Parameters<
              AppearanceCallback['channelIconContainer']
            >[0],
          })}
        >
          <ChannelIcon
            appearanceKey="channel__icon"
            channel={channel()}
            class="nt-size-3"
            preference={props.preference}
            preferenceGroup={props.preferenceGroup}
          />
        </div>
        <span
          class={style({
            key: 'channelLabel',
            className: 'nt-text-sm nt-font-semibold',
            context: { preference: props.preference, preferenceGroup: props.preferenceGroup } satisfies Parameters<
              AppearanceCallback['channelLabel']
            >[0],
          })}
        >
          {getLabel(channel())}
        </span>
      </div>
      <div
        class={style({
          key: 'channelSwitchContainer',
          className: 'nt-flex nt-items-center',
          context: { preference: props.preference, preferenceGroup: props.preferenceGroup } satisfies Parameters<
            AppearanceCallback['channelSwitchContainer']
          >[0],
        })}
      >
        <Switch
          state={state()}
          onChange={(newState) => onChange(newState === 'enabled')}
          disabled={props.preference?.workflow?.critical}
        />
      </div>
    </div>
  );
};

type ChannelIconProps = JSX.IntrinsicElements['svg'] & {
  appearanceKey: AppearanceKey;
  channel: ChannelType;
  preference?: Preference;
  preferenceGroup?: { name: string; preferences: Preference[] };
};
const ChannelIcon = (props: ChannelIconProps) => {
  const style = useStyle();

  const iconMap: Record<ChannelType, { key: IconKey; component: JSX.Element }> = {
    [ChannelType.IN_APP]: {
      key: 'inApp',
      component: (
        <DefaultInApp
          class={style({
            key: props.appearanceKey,
            className: props.class,
            iconKey: 'inApp',
            context: { preference: props.preference, preferenceGroup: props.preferenceGroup } satisfies Parameters<
              AppearanceCallback['channel__icon']
            >[0],
          })}
        />
      ),
    },
    [ChannelType.EMAIL]: {
      key: 'email',
      component: (
        <DefaultEmail
          class={style({
            key: props.appearanceKey,
            className: props.class,
            iconKey: 'email',
            context: { preference: props.preference, preferenceGroup: props.preferenceGroup } satisfies Parameters<
              AppearanceCallback['channel__icon']
            >[0],
          })}
        />
      ),
    },
    [ChannelType.PUSH]: {
      key: 'push',
      component: (
        <DefaultPush
          class={style({
            key: props.appearanceKey,
            className: props.class,
            iconKey: 'push',
            context: { preference: props.preference, preferenceGroup: props.preferenceGroup } satisfies Parameters<
              AppearanceCallback['channel__icon']
            >[0],
          })}
        />
      ),
    },
    [ChannelType.SMS]: {
      key: 'sms',
      component: (
        <DefaultSms
          class={style({
            key: props.appearanceKey,
            className: props.class,
            iconKey: 'sms',
            context: { preference: props.preference, preferenceGroup: props.preferenceGroup } satisfies Parameters<
              AppearanceCallback['channel__icon']
            >[0],
          })}
        />
      ),
    },
    [ChannelType.CHAT]: {
      key: 'chat',
      component: (
        <DefaultChat
          class={style({
            key: props.appearanceKey,
            className: props.class,
            iconKey: 'chat',
            context: { preference: props.preference, preferenceGroup: props.preferenceGroup } satisfies Parameters<
              AppearanceCallback['channel__icon']
            >[0],
          })}
        />
      ),
    },
  };

  const iconData = iconMap[props.channel];

  if (!iconData) {
    return null;
  }

  return (
    <IconRendererWrapper
      iconKey={iconData.key}
      fallback={iconData.component}
      class={style({
        key: props.appearanceKey,
        className: props.class,
        iconKey: iconData.key,
        context: { preference: props.preference } satisfies Parameters<AppearanceCallback['channel__icon']>[0],
      })}
    />
  );
};

export const getLabel = (channel: ChannelType) => {
  switch (channel) {
    case ChannelType.IN_APP:
      return 'In-App';
    case ChannelType.EMAIL:
      return 'Email';
    case ChannelType.PUSH:
      return 'Push';
    case ChannelType.SMS:
      return 'SMS';
    case ChannelType.CHAT:
      return 'Chat';
    default:
      return '';
  }
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX } from 'solid-js';
import { ChannelPreference, ChannelType, Preference } from '../../../../types';
import { useStyle } from '../../../helpers';
import {
Chat as DefaultChat,
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/elements/Preferences/DayScheduleCopy.tsx
Tamaño: 8190 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Accessor, createEffect, createMemo, createSignal, createUniqueId, For } from 'solid-js';
import { Schedule } from '../../../../preferences';
import { WeeklySchedule } from '../../../../types';
import { useLocalization } from '../../../../ui/context/LocalizationContext';
import { cn } from '../../../../ui/helpers';
import { useStyle } from '../../../../ui/helpers/useStyle';
import { Copy } from '../../../../ui/icons';
import { AppearanceCallback } from '../../../../ui/types';
import { Button, Checkbox, Dropdown } from '../../primitives';
import { Tooltip } from '../../primitives/Tooltip';
import { IconRenderer } from '../../shared/IconRendererWrapper';
import { weekDays } from './utils';

const NOVU_EVENT_CLOSE_DAY_SCHEDULE_COPY_COMPONENT = 'novu.close-day-schedule-copy-component';

type DayScheduleCopyProps = {
  day: Accessor<keyof WeeklySchedule>;
  schedule: Accessor<Schedule | undefined>;
  disabled?: boolean;
};

export const DayScheduleCopy = (props: DayScheduleCopyProps) => {
  const id = createUniqueId();
  const style = useStyle();
  const { t } = useLocalization();
  const [isOpen, setIsOpen] = createSignal<boolean>(false);
  const [selectedDays, setSelectedDays] = createSignal<Array<keyof WeeklySchedule>>([props.day()]);
  const [isAllSelected, setIsAllSelected] = createSignal<boolean>(false);
  const allWeekDaysSelected = createMemo(() => selectedDays().length === weekDays.length);
  const reset = () => {
    setSelectedDays([props.day()]);
    setIsAllSelected(false);
    setIsOpen(false);
  };
  const onOpenChange = createMemo(() => (isOpen: boolean) => {
    if (isOpen) {
      // close other copy times to dropdowns
      document.dispatchEvent(new CustomEvent(NOVU_EVENT_CLOSE_DAY_SCHEDULE_COPY_COMPONENT, { detail: { id } }));
    }
    setTimeout(() => {
      // set is open after a short delay to ensure nicer animation
      if (!isOpen) {
        reset();
      } else {
        setIsOpen(isOpen);
      }
    }, 50);
  });

  createEffect(() => {
    const listener = (event: CustomEvent<{ id: string }>) => {
      const data = event.detail;
      if (data.id !== id) {
        reset();
      }
    };

    // @ts-expect-error custom event
    document.addEventListener(NOVU_EVENT_CLOSE_DAY_SCHEDULE_COPY_COMPONENT, listener);

    return () => {
      // @ts-expect-error custom event
      document.removeEventListener(NOVU_EVENT_CLOSE_DAY_SCHEDULE_COPY_COMPONENT, listener);
    };
  });

  return (
    <Tooltip.Root>
      <Tooltip.Trigger
        disabled={props.disabled}
        asChild={(childProps) => (
          <Dropdown.Root placement="right" offset={0} open={isOpen()} onOpenChange={onOpenChange()}>
            <Dropdown.Trigger
              disabled={props.disabled}
              class={style({
                key: 'dayScheduleCopy__dropdownTrigger',
                className: 'nt-w-full',
              })}
            >
              <Button size="iconSm" variant="ghost" {...childProps}>
                <IconRenderer
                  iconKey="copy"
                  class={style({
                    key: 'dayScheduleCopyIcon',
                    className: cn(
                      'nt-text-foreground-alpha-600 nt-size-3.5 group-hover:nt-opacity-100 nt-opacity-0 nt-transition-opacity nt-duration-200',
                      {
                        'group-hover:nt-opacity-0': props.disabled,
                      }
                    ),
                    context: { schedule: props.schedule() } satisfies Parameters<
                      AppearanceCallback['dayScheduleCopyIcon']
                    >[0],
                  })}
                  fallback={Copy}
                />
              </Button>
            </Dropdown.Trigger>
            <Dropdown.Content
              portal
              appearanceKey="dayScheduleCopy__dropdownContent"
              class="nt-rounded-md nt-min-w-[220px] nt-max-w-[220px] nt-p-1"
            >
              <span
                class={style({
                  key: 'dayScheduleCopyTitle',
                  className: 'nt-text-sm nt-text-neutral-600  nt-mb-3 nt-text-left',
                  context: { schedule: props.schedule() } satisfies Parameters<
                    AppearanceCallback['dayScheduleCopyTitle']
                  >[0],
                })}
                data-localization="preferences.schedule.dayScheduleCopy.title"
              >
                {t('preferences.schedule.dayScheduleCopy.title')}
              </span>
              <span
                class={style({
                  key: 'dayScheduleCopySelectAll',
                  className: 'nt-flex nt-items-center nt-gap-2 nt-text-sm nt-text-neutral-600 nt-mb-2',
                  context: { schedule: props.schedule() } satisfies Parameters<
                    AppearanceCallback['dayScheduleCopySelectAll']
                  >[0],
                })}
                data-localization="preferences.schedule.dayScheduleCopy.selectAll"
              >
                <Checkbox
                  checked={isAllSelected() || allWeekDaysSelected()}
                  onChange={(checked) => {
                    setIsAllSelected(checked);
                    setSelectedDays(checked ? weekDays : [props.day()]);
                  }}
                />
                {t('preferences.schedule.dayScheduleCopy.selectAll')}
              </span>
              <For each={weekDays}>
                {(day) => (
                  <span
                    class={style({
                      key: 'dayScheduleCopyDay',
                      className: 'nt-flex nt-items-center nt-gap-2 nt-text-sm nt-text-neutral-600 nt-mb-2',
                      context: { schedule: props.schedule() } satisfies Parameters<
                        AppearanceCallback['dayScheduleCopyDay']
                      >[0],
                    })}
                    data-localization={`preferences.schedule.${day}`}
                  >
                    <Checkbox
                      value={'checked'}
                      onChange={(value) =>
                        setSelectedDays(value ? [...selectedDays(), day] : selectedDays().filter((d) => d !== day))
                      }
                      checked={selectedDays().includes(day) || day === props.day()}
                      disabled={day === props.day()}
                    />
                    {t(`preferences.schedule.${day}`)}
                  </span>
                )}
              </For>
              <div
                class={style({
                  key: 'dayScheduleCopyFooterContainer',
                  className: 'nt-flex nt-justify-end nt-border-t nt-border-neutral-alpha-100 nt-pt-2',
                  context: { schedule: props.schedule() } satisfies Parameters<
                    AppearanceCallback['dayScheduleCopyFooterContainer']
                  >[0],
                })}
              >
                <Button
                  onClick={() => {
                    const currentDay = props.day();
                    const daysToCopy = selectedDays().filter((day) => day !== currentDay);
                    const dayToCopy = props.schedule()?.weeklySchedule?.[currentDay];
                    if (dayToCopy) {
                      props.schedule()?.update({
                        weeklySchedule: {
                          ...props.schedule()?.weeklySchedule,
                          ...daysToCopy.reduce((acc, day) => {
                            acc[day] = dayToCopy;
                            return acc;
                          }, {} as WeeklySchedule),
                        },
                      });
                    }
                    reset();
                  }}
                  data-localization="preferences.schedule.dayScheduleCopy.apply"
                >
                  {t('preferences.schedule.dayScheduleCopy.apply')}
                </Button>
              </div>
            </Dropdown.Content>
          </Dropdown.Root>
        )}
      />
      <Tooltip.Content data-localization="preferences.schedule.copyTimesTo">
        {t('preferences.schedule.copyTimesTo')}
      </Tooltip.Content>
    </Tooltip.Root>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Accessor, createEffect, createMemo, createSignal, createUniqueId, For } from 'solid-js';
import { Schedule } from '../../../../preferences';
import { WeeklySchedule } from '../../../../types';
import { useLocalization } from '../../../../ui/context/LocalizationContext';
import { cn } from '../../../../ui/helpers';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/elements/Preferences/DefaultPreferences.tsx
Tamaño: 1157 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { createMemo, Index, Show } from 'solid-js';

import { ChannelPreference, Preference } from '../../../../types';
import { PreferencesListSkeleton } from './PreferencesListSkeleton';
import { PreferencesRow } from './PreferencesRow';

export const DefaultPreferences = (props: {
  workflowPreferences?: Preference[];
  loading?: boolean;
  updatePreference: (preference: Preference) => (channels: ChannelPreference) => void;
}) => {
  const workflowPreferences = createMemo(() => props.workflowPreferences);

  const updatePreference = (workflowIdentifier?: string) => (channels: ChannelPreference) => {
    const preference = workflowPreferences()?.find((pref) => pref.workflow?.identifier === workflowIdentifier);
    if (!preference) return;

    props.updatePreference(preference)(channels);
  };

  return (
    <Show when={workflowPreferences()?.length} fallback={<PreferencesListSkeleton loading={props.loading} />}>
      <Index each={workflowPreferences()}>
        {(preference) => {
          return <PreferencesRow iconKey="routeFill" preference={preference()} onChange={updatePreference} />;
        }}
      </Index>
    </Show>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { createMemo, Index, Show } from 'solid-js';
import { ChannelPreference, Preference } from '../../../../types';
import { PreferencesListSkeleton } from './PreferencesListSkeleton';
import { PreferencesRow } from './PreferencesRow';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/elements/Preferences/GroupedPreferences.tsx
Tamaño: 1060 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Index, Show } from 'solid-js';

import { ChannelPreference, Preference } from '../../../../types';
import { GroupedPreferencesRow } from './GroupedPreferencesRow';
import { PreferencesListSkeleton } from './PreferencesListSkeleton';

export const GroupedPreferences = (props: {
  groups: Array<{ name: string; preferences: Preference[] }>;
  loading?: boolean;
  updatePreference: (preference: Preference) => (channels: ChannelPreference) => void;
  bulkUpdatePreferences: (preferences: Preference[]) => (channels: ChannelPreference) => void;
}) => {
  const groups = () => props.groups;

  return (
    <Show when={props.groups.length && !props.loading} fallback={<PreferencesListSkeleton loading={props.loading} />}>
      <Index each={groups()}>
        {(group) => {
          return (
            <GroupedPreferencesRow
              group={group()}
              bulkUpdatePreferences={props.bulkUpdatePreferences}
              updatePreference={props.updatePreference}
            />
          );
        }}
      </Index>
    </Show>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Index, Show } from 'solid-js';
import { ChannelPreference, Preference } from '../../../../types';
import { GroupedPreferencesRow } from './GroupedPreferencesRow';
import { PreferencesListSkeleton } from './PreferencesListSkeleton';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/elements/Preferences/GroupedPreferencesRow.tsx
Tamaño: 11233 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { createMemo, createSignal, Index, Show } from 'solid-js';
import { AppearanceCallback } from 'src/ui/types';
import { ChannelPreference, ChannelType, Preference } from '../../../../types';
import { useLocalization } from '../../../context';
import { useStyle } from '../../../helpers';
import { ArrowDropDown as DefaultArrowDropDown } from '../../../icons/ArrowDropDown';
import { Info as DefaultInfo } from '../../../icons/Info';
import { NodeTree as DefaultNodeTree } from '../../../icons/NodeTree';
import { Collapsible } from '../../primitives/Collapsible';
import { Switch, SwitchState } from '../../primitives/Switch';
import { IconRendererWrapper } from '../../shared/IconRendererWrapper';
import { ChannelRow } from './ChannelRow';
import { PreferencesRow } from './PreferencesRow';

export const GroupedPreferencesRow = (props: {
  group: { name: string; preferences: Preference[] };
  updatePreference: (preference: Preference) => (channels: ChannelPreference) => void;
  bulkUpdatePreferences: (preferences: Preference[]) => (channels: ChannelPreference) => void;
}) => {
  const style = useStyle();
  const { t } = useLocalization();
  const [isOpened, setIsOpened] = createSignal(false);

  const uniqueChannels = createMemo(() => {
    return props.group.preferences.reduce(
      (acc, preference) => {
        Object.keys(preference.channels).forEach((el) => {
          const channel = el as keyof ChannelPreference;
          const currentState = acc[channel];
          const preferenceState = preference.channels[channel] ? 'enabled' : 'disabled';
          if (!currentState) {
            acc[channel] = preferenceState;
          } else {
            acc[channel] = currentState !== preferenceState ? 'indeterminate' : preferenceState;
          }
        });

        return acc;
      },
      {} as Record<keyof ChannelPreference, SwitchState>
    );
  });

  const groupState = createMemo(() => {
    const someIndeterminate = Object.values(uniqueChannels()).some((state) => state === 'indeterminate');
    if (someIndeterminate) {
      return 'indeterminate';
    }

    const allEnabled = Object.values(uniqueChannels()).every((state) => state === 'enabled');
    const allDisabled = Object.values(uniqueChannels()).every((state) => state === 'disabled');

    if (allEnabled) {
      return 'enabled';
    }

    if (allDisabled) {
      return 'disabled';
    }

    return 'indeterminate';
  });

  const updateGroupPreferences = (newState: SwitchState) => {
    const channels = Object.keys(uniqueChannels()).reduce((acc, channel) => {
      acc[channel as keyof ChannelPreference] = newState === 'enabled';

      return acc;
    }, {} as ChannelPreference);
    props.bulkUpdatePreferences(props.group.preferences)(channels);
  };

  const updatePreference = (workflowIdentifier?: string) => (channels: ChannelPreference) => {
    const preference = props.group.preferences.find((pref) => pref.workflow?.identifier === workflowIdentifier);
    if (!preference) return;

    props.updatePreference(preference)(channels);
  };

  const updatePreferencesForChannel = (channel: string) => (channels: ChannelPreference) => {
    const filteredPreferences = props.group.preferences.filter((preference) =>
      Object.keys(preference.channels).some((key) => key === channel)
    );

    props.bulkUpdatePreferences(filteredPreferences)(channels);
  };

  const preferences = createMemo(() => props.group.preferences);

  return (
    <Show when={Object.keys(uniqueChannels()).length > 0}>
      <div
        class={style({
          key: 'preferencesGroupContainer',
          className: 'nt-bg-neutral-alpha-25 nt-rounded-lg nt-border nt-border-neutral-alpha-50',
          context: {
            preferenceGroup: props.group,
          } satisfies Parameters<AppearanceCallback['preferencesGroupContainer']>[0],
        })}
        data-open={isOpened()}
      >
        <div
          class={style({
            key: 'preferencesGroupHeader',
            className:
              'nt-flex nt-justify-between nt-p-2 nt-flex-nowrap nt-self-stretch nt-cursor-pointer nt-items-center nt-overflow-hidden',
            context: { preferenceGroup: props.group } satisfies Parameters<
              AppearanceCallback['preferencesGroupHeader']
            >[0],
          })}
          onClick={() => {
            setIsOpened((prev) => !prev);
          }}
        >
          <div
            class={style({
              key: 'preferencesGroupLabelContainer',
              className: 'nt-overflow-hidden nt-flex nt-items-center nt-gap-1',
              context: { preferenceGroup: props.group } satisfies Parameters<
                AppearanceCallback['preferencesGroupLabelContainer']
              >[0],
            })}
          >
            <IconRendererWrapper
              iconKey="nodeTree"
              class={style({
                key: 'preferencesGroupLabelIcon',
                className: 'nt-text-foreground-alpha-600 nt-size-3.5',
                context: { preferenceGroup: props.group } satisfies Parameters<
                  AppearanceCallback['preferencesGroupLabelIcon']
                >[0],
              })}
              fallback={
                <DefaultNodeTree
                  class={style({
                    key: 'preferencesGroupLabelIcon',
                    className: 'nt-text-foreground-alpha-600 nt-size-3.5',
                    context: { preferenceGroup: props.group } satisfies Parameters<
                      AppearanceCallback['preferencesGroupLabelIcon']
                    >[0],
                  })}
                />
              }
            />
            <span
              class={style({
                key: 'preferencesGroupLabel',
                className: 'nt-text-sm nt-font-semibold nt-truncate nt-text-start',
                context: { preferenceGroup: props.group } satisfies Parameters<
                  AppearanceCallback['preferencesGroupLabel']
                >[0],
              })}
              data-open={isOpened()}
            >
              {props.group.name}
            </span>
          </div>
          <div
            class={style({
              key: 'preferencesGroupActionsContainer',
              className: 'nt-flex nt-items-center nt-gap-1',
              context: { preferenceGroup: props.group } satisfies Parameters<
                AppearanceCallback['preferencesGroupActionsContainer']
              >[0],
            })}
          >
            <Switch state={groupState()} onChange={updateGroupPreferences} />
            <span
              class={style({
                key: 'preferencesGroupActionsContainerRight__icon',
                className:
                  'nt-text-foreground-alpha-600 nt-transition-all nt-duration-200 data-[open=true]:nt-transform data-[open=true]:nt-rotate-180',
                context: { preferenceGroup: props.group } satisfies Parameters<
                  AppearanceCallback['preferencesGroupActionsContainerRight__icon']
                >[0],
              })}
              data-open={isOpened()}
            >
              <IconRendererWrapper
                iconKey="arrowDropDown"
                class={style({
                  key: 'moreTabs__icon',
                  className: 'nt-size-4',
                })}
                fallback={
                  <DefaultArrowDropDown
                    class={style({
                      key: 'moreTabs__icon',
                      className: 'nt-size-4',
                    })}
                  />
                }
              />
            </span>
          </div>
        </div>
        <Collapsible open={isOpened()}>
          <div
            class={style({
              key: 'preferencesGroupBody',
              className: 'nt-flex nt-flex-col nt-gap-1 nt-overflow-hidden',
              context: { preferenceGroup: props.group } satisfies Parameters<
                AppearanceCallback['preferencesGroupBody']
              >[0],
            })}
          >
            <div
              class={style({
                key: 'preferencesGroupChannels',
                className:
                  'nt-flex nt-bg-background nt-border-t nt-border-b nt-border-neutral-alpha-50 nt-p-2 nt-flex-col nt-gap-1 nt-overflow-hidden',
                context: { preferenceGroup: props.group } satisfies Parameters<
                  AppearanceCallback['preferencesGroupChannels']
                >[0],
              })}
            >
              <Index each={Object.keys(uniqueChannels())}>
                {(channel) => {
                  return (
                    <ChannelRow
                      channel={{
                        channel: channel() as ChannelType,
                        state: uniqueChannels()[channel() as keyof ChannelPreference],
                      }}
                      onChange={updatePreferencesForChannel(channel())}
                      preferenceGroup={props.group}
                    />
                  );
                }}
              </Index>
              <span
                class={style({
                  key: 'preferencesGroupInfo',
                  className:
                    'nt-text-sm nt-text-start nt-text-foreground-alpha-400 nt-mt-1 nt-flex nt-items-center nt-gap-1',
                  context: { preferenceGroup: props.group } satisfies Parameters<
                    AppearanceCallback['preferencesGroupInfo']
                  >[0],
                })}
                data-localization="preferences.group.info"
              >
                <IconRendererWrapper
                  iconKey="info"
                  class={style({
                    key: 'preferencesGroupInfoIcon',
                    className: 'nt-size-4',
                    context: { preferenceGroup: props.group } satisfies Parameters<
                      AppearanceCallback['preferencesGroupInfoIcon']
                    >[0],
                  })}
                  fallback={
                    <DefaultInfo
                      class={style({
                        key: 'preferencesGroupInfoIcon',
                        className: 'nt-size-4',
                        context: { preferenceGroup: props.group } satisfies Parameters<
                          AppearanceCallback['preferencesGroupInfoIcon']
                        >[0],
                      })}
                    />
                  }
                />
                {t('preferences.group.info')}
              </span>
            </div>
            <div
              class={style({
                key: 'preferencesGroupWorkflows',
                className: 'nt-flex nt-p-2 nt-flex-col nt-gap-1 nt-overflow-hidden',
                context: { preferenceGroup: props.group } satisfies Parameters<
                  AppearanceCallback['preferencesGroupWorkflows']
                >[0],
              })}
            >
              <Index each={preferences()}>
                {(preference) => (
                  <PreferencesRow iconKey="routeFill" preference={preference()} onChange={updatePreference} />
                )}
              </Index>
            </div>
          </div>
        </Collapsible>
      </div>
    </Show>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { createMemo, createSignal, Index, Show } from 'solid-js';
import { AppearanceCallback } from 'src/ui/types';
import { ChannelPreference, ChannelType, Preference } from '../../../../types';
import { useLocalization } from '../../../context';
import { useStyle } from '../../../helpers';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/elements/Preferences/Preferences.tsx
Tamaño: 5845 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { createEffect, createMemo, Show } from 'solid-js';
import { AppearanceCallback } from 'src/ui/types';
import { Preference } from '../../../../preferences/preference';
import { ChannelPreference, PreferenceLevel } from '../../../../types';
import { usePreferences } from '../../../api';
import { setDynamicLocalization } from '../../../config';
import { useInboxContext, useNovu } from '../../../context';
import { useStyle } from '../../../helpers';
import { DefaultPreferences } from './DefaultPreferences';
import { GroupedPreferences } from './GroupedPreferences';
import { PreferencesListSkeleton } from './PreferencesListSkeleton';
import { PreferencesRow } from './PreferencesRow';
import { ScheduleRow } from './ScheduleRow';

/* This is also going to be exported as a separate component. Keep it pure. */
export const Preferences = () => {
  const novu = useNovu();
  const style = useStyle();
  const { preferencesFilter, preferenceGroups, preferencesSort } = useInboxContext();

  const { preferences, loading } = usePreferences({
    tags: preferencesFilter()?.tags,
    severity: preferencesFilter()?.severity,
    criticality: preferencesFilter()?.criticality,
  });

  const allPreferences = createMemo(() => {
    const globalPreference = preferences()?.find((preference) => preference.level === PreferenceLevel.GLOBAL);
    let workflowPreferences = preferences()?.filter((preference) => preference.level === PreferenceLevel.TEMPLATE);

    if (workflowPreferences && preferencesSort()) {
      workflowPreferences = [...workflowPreferences].sort(preferencesSort());
    }

    return { globalPreference, workflowPreferences };
  });

  createEffect(() => {
    // Register the names as localizable
    setDynamicLocalization((prev) => ({
      ...prev,
      ...allPreferences().workflowPreferences?.reduce<Record<string, string>>((acc, preference) => {
        if (preference.workflow?.identifier && preference.workflow?.name) {
          acc[preference.workflow.identifier] = preference.workflow.name;
        }

        return acc;
      }, {}),
    }));
  });

  const updatePreference = (preference?: Preference) => async (channels: ChannelPreference) => {
    await preference?.update({
      channels,
    });
  };

  const bulkUpdatePreferences = (preferences: Preference[]) => async (channels: ChannelPreference) => {
    await novu.preferences.bulkUpdate(
      preferences.map((el) => {
        const oldChannels = Object.keys(el.channels);
        const channelsToUpdate = Object.keys(channels)
          .filter((channel) => oldChannels.includes(channel))
          .reduce((acc, channel) => {
            acc[channel as keyof ChannelPreference] = channels[channel as keyof ChannelPreference];

            return acc;
          }, {} as ChannelPreference);

        return { preference: el, channels: channelsToUpdate };
      })
    );
  };

  const groupedPreferences = createMemo(() => {
    const workflowPreferences = allPreferences().workflowPreferences ?? [];

    return (
      preferenceGroups()?.map((group) => {
        const { filter } = group;
        if (typeof filter === 'function') {
          const preferences = filter({ preferences: workflowPreferences });

          return { name: group.name, preferences };
        }

        if (typeof filter === 'object') {
          let filteredPreferences = workflowPreferences.filter((preference) => {
            const workflowId = preference.workflow?.id || preference.workflow?.identifier;

            return (
              filter.workflowIds?.includes(workflowId ?? '') ||
              filter.tags?.some((tag) => preference.workflow?.tags?.includes(tag)) ||
              (Array.isArray(filter.severity) &&
                filter.severity.some((severity) => preference.workflow?.severity === severity)) ||
              (!Array.isArray(filter.severity) && filter.severity === preference.workflow?.severity)
            );
          });

          if (preferencesSort()) {
            filteredPreferences = [...filteredPreferences].sort(preferencesSort());
          }

          return {
            name: group.name,
            preferences: filteredPreferences,
          };
        }

        return {
          name: group.name,
          preferences: [],
        };
      }) ?? []
    );
  });

  return (
    <div
      class={style({
        key: 'preferencesContainer',
        className:
          'nt-px-3 nt-py-4 nt-flex nt-flex-col nt-gap-2 nt-overflow-y-auto nt-h-full nt-pr-0 [scrollbar-gutter:stable]',
        context: { preferences: preferences(), groups: groupedPreferences() } satisfies Parameters<
          AppearanceCallback['preferencesContainer']
        >[0],
      })}
    >
      <Show when={allPreferences().globalPreference}>
        <PreferencesRow
          iconKey="cogs"
          preference={allPreferences().globalPreference!}
          onChange={() => updatePreference(allPreferences().globalPreference)}
        />
      </Show>
      <Show when={allPreferences().globalPreference}>
        <ScheduleRow globalPreference={allPreferences().globalPreference} />
      </Show>
      <Show
        when={groupedPreferences().length > 0}
        fallback={
          <Show
            when={allPreferences().workflowPreferences?.length}
            fallback={<PreferencesListSkeleton loading={loading()} />}
          >
            <DefaultPreferences
              workflowPreferences={allPreferences().workflowPreferences}
              loading={loading()}
              updatePreference={updatePreference}
            />
          </Show>
        }
      >
        <GroupedPreferences
          groups={groupedPreferences()}
          loading={loading()}
          updatePreference={updatePreference}
          bulkUpdatePreferences={bulkUpdatePreferences}
        />
      </Show>
    </div>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { createEffect, createMemo, Show } from 'solid-js';
import { AppearanceCallback } from 'src/ui/types';
import { Preference } from '../../../../preferences/preference';
import { ChannelPreference, PreferenceLevel } from '../../../../types';
import { usePreferences } from '../../../api';
/* This is also going to be exported as a separate component. Keep it pure. */
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/elements/Preferences/PreferencesHeader.tsx
Tamaño: 1738 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Show } from 'solid-js';
import { useLocalization } from '../../../context';
import { useStyle } from '../../../helpers';
import { ArrowLeft as DefaultArrowLeft } from '../../../icons';
import { Button } from '../../primitives';
import { IconRendererWrapper } from '../../shared/IconRendererWrapper';

type PreferencesHeaderProps = {
  navigateToNotifications?: () => void;
};

export const PreferencesHeader = (props: PreferencesHeaderProps) => {
  const style = useStyle();
  const { t } = useLocalization();
  const arrowLeftIconClass = style({
    key: 'preferencesHeader__back__button__icon',
    className: 'nt-size-4',
    iconKey: 'arrowLeft',
  });

  return (
    <div
      class={style({
        key: 'preferencesHeader',
        className:
          'nt-flex nt-bg-neutral-alpha-25 nt-shrink-0 nt-border-b nt-border-border nt-items-center nt-py-3.5 nt-px-4 nt-gap-2',
      })}
    >
      <Show when={props.navigateToNotifications}>
        {(navigateToNotifications) => (
          <Button
            appearanceKey="preferencesHeader__back__button"
            class="nt-text-foreground-alpha-600"
            variant="unstyled"
            size="none"
            onClick={navigateToNotifications()}
          >
            <IconRendererWrapper
              iconKey="arrowLeft"
              class={arrowLeftIconClass}
              fallback={<DefaultArrowLeft class={arrowLeftIconClass} />}
            />
          </Button>
        )}
      </Show>
      <div
        data-localization="preferences.title"
        class={style({
          key: 'preferencesHeader__title',
          className: 'nt-text-base nt-font-medium',
        })}
      >
        {t('preferences.title')}
      </div>
    </div>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Show } from 'solid-js';
import { useLocalization } from '../../../context';
import { useStyle } from '../../../helpers';
import { ArrowLeft as DefaultArrowLeft } from '../../../icons';
import { Button } from '../../primitives';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/elements/Preferences/PreferencesListSkeleton.tsx
Tamaño: 3972 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Show } from 'solid-js';
import { useLocalization } from '../../../context/LocalizationContext';
import { useStyle } from '../../../helpers/useStyle';
import { Chat } from '../../../icons/Chat';
import { Email } from '../../../icons/Email';
import { InApp } from '../../../icons/InApp';
import { Push } from '../../../icons/Push';
import { Sms } from '../../../icons/Sms';
import { Motion } from '../../primitives/Motion';
import { SkeletonSwitch, SkeletonText } from '../../primitives/Skeleton';

type PreferencesListSkeletonProps = {
  loading?: boolean;
};

const channelIcons = [InApp, Email, Sms, Push, Chat];

export const PreferencesListSkeleton = (props: PreferencesListSkeletonProps) => {
  const style = useStyle();
  const { t } = useLocalization();

  return (
    <div
      class={style({
        key: 'preferencesListEmptyNoticeContainer',
        className:
          'nt-flex nt-flex-col nt-items-center nt-h-fit nt-w-full nt-text-sm nt-text-foreground-alpha-400 nt-text-center',
      })}
    >
      <Motion.div
        animate={{
          scale: props.loading ? 1 : 0.7,
        }}
        transition={{ duration: 0.6, easing: [0.39, 0.24, 0.3, 1], delay: 0.3 }}
        class={style({
          key: 'preferencesList__skeleton',
          className: 'nt-flex nt-relative nt-mx-auto nt-flex-col nt-w-full nt-mb-4',
        })}
      >
        {Array.from({ length: 5 }).map((_, i) => {
          const Icon = channelIcons[i];

          return (
            <Motion.div
              animate={{
                marginBottom: props.loading ? 0 : '16px',
                borderWidth: props.loading ? 0 : '1px',
                borderRadius: props.loading ? 0 : 'var(--nv-radius-lg)',
              }}
              transition={{ duration: 0.5, delay: 0.3, easing: 'ease-in-out' }}
              class={style({
                key: 'preferencesList__skeletonContent',
                className: 'nt-flex nt-border-neutral-alpha-50 nt-items-center nt-gap-3 nt-p-3 nt-bg-neutral-alpha-25',
              })}
            >
              <Icon
                class={style({
                  key: 'preferencesList__skeletonIcon',
                  className: 'nt-size-8 nt-p-2 nt-rounded-lg nt-bg-neutral-alpha-100',
                })}
              />
              <div
                class={style({
                  key: 'preferencesList__skeletonItem',
                  className: 'nt-flex nt-flex-col nt-gap-2 nt-flex-1',
                })}
              >
                <SkeletonText
                  appearanceKey="notificationList__skeletonText"
                  class="nt-h-2 nt-w-1/3 nt-bg-neutral-alpha-50 nt-rounded"
                />
                <SkeletonText
                  appearanceKey="preferencesList__skeletonText"
                  class="nt-h-2 nt-w-2/3 nt-bg-neutral-alpha-50 nt-rounded"
                />
              </div>

              <SkeletonSwitch
                appearanceKey="preferencesList__skeletonSwitch"
                thumbAppearanceKey="preferencesList__skeletonSwitchThumb"
              />
            </Motion.div>
          );
        })}
        <div
          class={style({
            key: 'notificationListEmptyNoticeOverlay',
            className:
              'nt-absolute nt-size-full nt-z-10 nt-inset-0 nt-bg-gradient-to-b nt-from-transparent nt-to-background',
          })}
        />
      </Motion.div>
      <Show when={!props.loading}>
        <Motion.p
          initial={{ opacity: 0, y: -4, filter: 'blur(4px)' }}
          animate={{ opacity: props.loading ? 0 : 1, y: 0, filter: 'blur(0px)' }}
          transition={{ duration: 0.7, easing: [0.39, 0.24, 0.3, 1], delay: 0.6 }}
          class={style({
            key: 'preferencesListEmptyNotice',
            className: 'nt-text-center',
          })}
          data-localization="preferences.emptyNotice"
        >
          {t('preferences.emptyNotice')}
        </Motion.p>
      </Show>
    </div>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Show } from 'solid-js';
import { useLocalization } from '../../../context/LocalizationContext';
import { useStyle } from '../../../helpers/useStyle';
import { Chat } from '../../../icons/Chat';
import { Email } from '../../../icons/Email';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/elements/Preferences/PreferencesRow.tsx
Tamaño: 9023 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { createMemo, createSignal, Index, JSXElement, Show } from 'solid-js';
import { JSX } from 'solid-js/jsx-runtime';

import { RouteFill } from 'src/ui/icons/RouteFill';
import { ChannelPreference, ChannelType, Preference } from '../../../../types';
import { StringLocalizationKey, useLocalization } from '../../../context';
import { cn, useStyle } from '../../../helpers';
import { Cogs, ArrowDropDown as DefaultArrowDropDown } from '../../../icons';
import { AppearanceCallback, AppearanceKey, IconKey } from '../../../types';
import { Collapsible } from '../../primitives/Collapsible';
import { SwitchState } from '../../primitives/Switch';
import { IconRendererWrapper } from '../../shared/IconRendererWrapper';
import { ChannelRow, getLabel } from './ChannelRow';

type IconComponentType = (props?: JSX.HTMLAttributes<SVGSVGElement>) => JSXElement;

const iconKeyToComponentMap: { [key in IconKey]?: IconComponentType } = {
  cogs: Cogs,
  routeFill: RouteFill,
};

export const PreferencesRow = (props: {
  iconKey: IconKey;
  preference: Preference;
  onChange: (workflowIdentifier?: string) => (channels: ChannelPreference) => void;
}) => {
  const style = useStyle();
  const [isOpenChannels, setIsOpenChannels] = createSignal(false);
  const { t } = useLocalization();

  const channels = createMemo(() =>
    Object.keys(props.preference?.channels ?? {}).map((channel) => ({
      channel: channel as ChannelType,
      state: props.preference?.channels[channel as keyof ChannelPreference] ? 'enabled' : ('disabled' as SwitchState),
    }))
  );

  const DefaultIconComponent = iconKeyToComponentMap[props.iconKey];

  return (
    <Show when={channels().length > 0}>
      <div
        class={style({
          key: 'workflowContainer',
          className: 'nt-p-1 nt-bg-neutral-alpha-25 nt-rounded-lg nt-border nt-border-neutral-alpha-50',
          context: {
            preference: props.preference,
          } satisfies Parameters<AppearanceCallback['workflowContainer']>[0],
        })}
        data-open={isOpenChannels()}
      >
        <div
          class={style({
            key: 'workflowLabelContainer',
            className:
              'nt-flex nt-justify-between nt-p-1 nt-flex-nowrap nt-self-stretch nt-cursor-pointer nt-items-center nt-overflow-hidden',
            context: { preference: props.preference } satisfies Parameters<
              AppearanceCallback['workflowLabelContainer']
            >[0],
          })}
          onClick={() => {
            setIsOpenChannels((prev) => !prev);
          }}
        >
          <div
            class={style({
              key: 'workflowLabelHeader',
              className: 'nt-overflow-hidden',
              context: { preference: props.preference } satisfies Parameters<
                AppearanceCallback['workflowLabelHeader']
              >[0],
            })}
          >
            <div
              class={style({
                key: 'workflowLabelHeaderContainer',
                className: 'nt-flex nt-items-center nt-gap-1',
                context: { preference: props.preference } satisfies Parameters<
                  AppearanceCallback['workflowLabelHeaderContainer']
                >[0],
              })}
            >
              <IconRendererWrapper
                iconKey={props.iconKey}
                class={style({
                  key: 'workflowLabelIcon',
                  className: 'nt-text-foreground-alpha-600 nt-size-3.5',
                  iconKey: 'cogs',
                  context: { preference: props.preference } satisfies Parameters<
                    AppearanceCallback['workflowLabelIcon']
                  >[0],
                })}
                fallback={
                  DefaultIconComponent &&
                  DefaultIconComponent({
                    class: style({
                      key: 'workflowLabelIcon',
                      className: 'nt-text-foreground-alpha-600 nt-size-3.5',
                      iconKey: 'cogs',
                      context: { preference: props.preference } satisfies Parameters<
                        AppearanceCallback['workflowLabelIcon']
                      >[0],
                    }),
                  })
                }
              />
              <span
                class={style({
                  key: 'workflowLabel',
                  className: 'nt-text-sm nt-font-semibold nt-truncate nt-text-start',
                  context: { preference: props.preference } satisfies Parameters<
                    AppearanceCallback['workflowLabel']
                  >[0],
                })}
                data-localization={props.preference?.workflow?.identifier ?? 'preferences.global'}
                data-open={isOpenChannels()}
              >
                {t((props.preference?.workflow?.identifier as StringLocalizationKey) ?? 'preferences.global')}
              </span>
            </div>
            <Collapsible open={!isOpenChannels()}>
              <WorkflowDescription
                channels={props.preference?.channels ?? {}}
                appearanceKey="workflowDescription"
                class="nt-overflow-hidden"
                preference={props.preference}
              />
            </Collapsible>
          </div>
          <span
            class={style({
              key: 'workflowContainerRight__icon',
              className:
                'nt-text-foreground-alpha-600 nt-transition-all nt-duration-200 data-[open=true]:nt-transform data-[open=true]:nt-rotate-180',
              context: { preference: props.preference } satisfies Parameters<
                AppearanceCallback['workflowContainerRight__icon']
              >[0],
            })}
            data-open={isOpenChannels()}
          >
            <IconRendererWrapper
              iconKey="arrowDropDown"
              class={style({
                key: 'workflowArrow__icon',
                className: 'nt-text-foreground-alpha-600 nt-size-4',
                iconKey: 'arrowDropDown',
                context: { preference: props.preference } satisfies Parameters<
                  AppearanceCallback['workflowArrow__icon']
                >[0],
              })}
              fallback={
                <DefaultArrowDropDown
                  class={style({
                    key: 'workflowArrow__icon',
                    className: 'nt-text-foreground-alpha-600 nt-size-4',
                    iconKey: 'arrowDropDown',
                    context: { preference: props.preference } satisfies Parameters<
                      AppearanceCallback['workflowArrow__icon']
                    >[0],
                  })}
                />
              }
            />
          </span>
        </div>
        <Collapsible open={isOpenChannels()}>
          <div
            class={style({
              key: 'channelsContainer',
              className:
                'nt-flex nt-bg-background nt-border nt-border-neutral-alpha-200 nt-rounded-lg nt-p-2 nt-flex-col nt-gap-1 nt-overflow-hidden',
              context: { preference: props.preference } satisfies Parameters<
                AppearanceCallback['channelsContainer']
              >[0],
            })}
          >
            <Index each={channels()}>
              {(channel) => (
                <ChannelRow
                  channel={channel()}
                  workflowId={props.preference?.workflow?.id}
                  onChange={props.onChange(props.preference?.workflow?.identifier)}
                  preference={props.preference}
                />
              )}
            </Index>
          </div>
        </Collapsible>
      </div>
    </Show>
  );
};

type WorkflowDescriptionProps = JSX.IntrinsicElements['div'] & {
  channels: ChannelPreference;
  appearanceKey: AppearanceKey;
  preference: Preference;
};

const WorkflowDescription = (props: WorkflowDescriptionProps) => {
  const style = useStyle();

  const channelNames = () => {
    const channels = [];

    for (const key in props.channels) {
      if (props.channels[key as keyof ChannelPreference] !== undefined) {
        const isDisabled = !props.channels[key as keyof ChannelPreference];

        const element = (
          <span
            class={style({
              key: 'channelName',
              className: 'data-[disabled=true]:nt-text-foreground-alpha-400',
              context: { preference: props.preference } satisfies Parameters<AppearanceCallback['channelName']>[0],
            })}
            data-disabled={isDisabled}
          >
            {getLabel(key as ChannelType)}
          </span>
        );
        channels.push(element);
      }
    }

    return channels.map((c, index) => (
      <>
        {c}
        {index < channels.length - 1 && ', '}
      </>
    ));
  };

  return (
    <div
      class={style({
        key: props.appearanceKey,
        className: cn('nt-text-sm nt-text-foreground-alpha-600 nt-text-start', props.class),
      })}
    >
      {channelNames()}
    </div>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { createMemo, createSignal, Index, JSXElement, Show } from 'solid-js';
import { JSX } from 'solid-js/jsx-runtime';
import { RouteFill } from 'src/ui/icons/RouteFill';
import { ChannelPreference, ChannelType, Preference } from '../../../../types';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/elements/Preferences/ScheduleRow.tsx
Tamaño: 8748 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Accessor, createMemo, createSignal, JSX, Setter } from 'solid-js';
import { Schedule } from '../../../../preferences/schedule';
import { Preference, WeeklySchedule } from '../../../../types';
import { useLocalization } from '../../../context';
import { useStyle } from '../../../helpers/useStyle';
import { ArrowDropDown, CalendarSchedule } from '../../../icons';
import { Info } from '../../../icons/Info';
import { AppearanceCallback } from '../../../types';
import { Collapsible } from '../../primitives/Collapsible';
import { Switch } from '../../primitives/Switch';
import { Tooltip } from '../../primitives/Tooltip';
import { IconRenderer } from '../../shared/IconRendererWrapper';
import { ScheduleTable } from './ScheduleTable';

const ScheduleRowHeader = (props: {
  schedule: Accessor<Schedule | undefined>;
  children: JSX.Element;
  isOpened: Accessor<boolean>;
  setIsOpened: Setter<boolean>;
}) => {
  const style = useStyle();

  return (
    <button
      class={style({
        key: 'scheduleHeader',
        className:
          'nt-flex nt-w-full nt-p-1 nt-justify-between nt-flex-nowrap nt-self-stretch nt-cursor-pointer nt-items-center nt-overflow-hidden',
        context: { schedule: props.schedule() } satisfies Parameters<AppearanceCallback['scheduleHeader']>[0],
      })}
      onClick={() => props.setIsOpened((prev) => !prev)}
      aria-label="Schedule"
      aria-expanded={props.isOpened()}
      data-open={props.isOpened()}
      tabIndex={0}
    >
      {props.children}
    </button>
  );
};

const ScheduleRowLabel = (props: { schedule: Accessor<Schedule | undefined>; isOpened: Accessor<boolean> }) => {
  const style = useStyle();
  const { t } = useLocalization();

  return (
    <div
      class={style({
        key: 'scheduleLabelContainer',
        className: 'nt-overflow-hidden  nt-flex nt-items-center nt-gap-1 nt-h-3.5',
        context: { schedule: props.schedule() } satisfies Parameters<AppearanceCallback['scheduleLabelContainer']>[0],
      })}
    >
      <IconRenderer
        iconKey="calendarSchedule"
        class={style({
          key: 'scheduleLabelScheduleIcon',
          className: 'nt-text-foreground-alpha-600 nt-size-3.5',
          context: { schedule: props.schedule() } satisfies Parameters<
            AppearanceCallback['scheduleLabelScheduleIcon']
          >[0],
        })}
        fallback={CalendarSchedule}
      />
      <span
        class={style({
          key: 'scheduleLabel',
          className: 'nt-text-sm nt-font-semibold nt-truncate nt-text-start',
          context: { schedule: props.schedule() } satisfies Parameters<AppearanceCallback['scheduleLabel']>[0],
        })}
        data-open={props.isOpened()}
        data-localization="preferences.schedule.title"
      >
        {t('preferences.schedule.title')}
      </span>
      <Tooltip.Root>
        <Tooltip.Trigger>
          <IconRenderer
            iconKey="info"
            class={style({
              key: 'scheduleLabelInfoIcon',
              className: 'nt-text-foreground-alpha-600 nt-size-3.5',
              context: { schedule: props.schedule() } satisfies Parameters<
                AppearanceCallback['scheduleLabelInfoIcon']
              >[0],
            })}
            fallback={Info}
          />
        </Tooltip.Trigger>
        <Tooltip.Content data-localization="preferences.schedule.headerInfo">
          <div class="nt-max-w-56">{t('preferences.schedule.headerInfo')}</div>
        </Tooltip.Content>
      </Tooltip.Root>
    </div>
  );
};

const DEFAULT_HOURS = [{ start: '09:00 AM', end: '05:00 PM' }];
const DEFAULT_WEEKLY_SCHEDULE: WeeklySchedule = {
  monday: {
    isEnabled: true,
    hours: DEFAULT_HOURS,
  },
  tuesday: {
    isEnabled: true,
    hours: DEFAULT_HOURS,
  },
  wednesday: {
    isEnabled: true,
    hours: DEFAULT_HOURS,
  },
  thursday: {
    isEnabled: true,
    hours: DEFAULT_HOURS,
  },
  friday: {
    isEnabled: true,
    hours: DEFAULT_HOURS,
  },
};

const ScheduleRowActions = (props: {
  schedule: Accessor<Schedule | undefined>;
  isOpened: Accessor<boolean>;
  onChange: (isEnabled: boolean) => void;
}) => {
  const style = useStyle();

  return (
    <div
      class={style({
        key: 'scheduleActionsContainer',
        className: 'nt-flex nt-items-center nt-gap-1',
        context: { schedule: props.schedule() } satisfies Parameters<AppearanceCallback['scheduleActionsContainer']>[0],
      })}
    >
      <Switch
        state={props.schedule()?.isEnabled ? 'enabled' : 'disabled'}
        onChange={(state) => {
          const isEnabled = state === 'enabled';
          const hasNoWeeklySchedule = !props.schedule()?.weeklySchedule;

          props.schedule()?.update({
            isEnabled,
            ...(isEnabled && hasNoWeeklySchedule && { weeklySchedule: DEFAULT_WEEKLY_SCHEDULE }),
          });

          props.onChange(isEnabled);
        }}
      />
      <span
        class={style({
          key: 'scheduleActionsContainerRight',
          className:
            'nt-text-foreground-alpha-600 nt-transition-all nt-duration-200 data-[open=true]:nt-transform data-[open=true]:nt-rotate-180',
          context: { schedule: props.schedule() } satisfies Parameters<
            AppearanceCallback['scheduleActionsContainerRight']
          >[0],
        })}
        data-open={props.isOpened()}
      >
        <IconRenderer
          iconKey="arrowDropDown"
          class={style({
            key: 'moreTabs__icon',
            className: 'nt-size-4',
          })}
          fallback={ArrowDropDown}
        />
      </span>
    </div>
  );
};

const ScheduleRowBody = (props: { isOpened: Accessor<boolean>; globalPreference: Preference | undefined }) => {
  const style = useStyle();
  const { t } = useLocalization();
  const schedule = createMemo(() => props.globalPreference?.schedule);

  return (
    <div
      class={style({
        key: 'scheduleBody',
        className:
          'nt-flex nt-bg-background nt-border nt-border-neutral-alpha-200 nt-rounded-lg nt-p-2 nt-flex-col nt-gap-2 nt-overflow-hidden',
        context: { schedule: schedule() } satisfies Parameters<AppearanceCallback['scheduleBody']>[0],
      })}
    >
      <span
        class={style({
          key: 'scheduleDescription',
          className: 'nt-text-sm nt-truncate nt-text-start',
          context: { schedule: schedule() } satisfies Parameters<AppearanceCallback['scheduleDescription']>[0],
        })}
        data-localization="preferences.schedule.description"
      >
        {t('preferences.schedule.description')}
      </span>
      <ScheduleTable globalPreference={props.globalPreference} />
      <div
        class={style({
          key: 'scheduleInfoContainer',
          className: 'nt-flex nt-items-start nt-mt-1.5 nt-gap-1',
          context: { schedule: schedule() } satisfies Parameters<AppearanceCallback['scheduleInfoContainer']>[0],
        })}
      >
        <IconRenderer
          iconKey="info"
          class={style({
            key: 'scheduleInfoIcon',
            className: 'nt-size-4',
            context: { schedule: schedule() } satisfies Parameters<AppearanceCallback['scheduleInfoIcon']>[0],
          })}
          fallback={Info}
        />
        <span
          class={style({
            key: 'scheduleInfo',
            className: 'nt-text-sm nt-text-start',
          })}
          data-localization="preferences.schedule.info"
        >
          {t('preferences.schedule.info')}
        </span>
      </div>
    </div>
  );
};

type ScheduleRowProps = {
  globalPreference?: Preference;
};

export const ScheduleRow = (props: ScheduleRowProps) => {
  const style = useStyle();
  const schedule = createMemo(() => props.globalPreference?.schedule);
  const [isOpened, setIsOpened] = createSignal(props.globalPreference?.schedule?.isEnabled ?? false);

  return (
    <>
      <div
        class={style({
          key: 'scheduleContainer',
          className: 'nt-p-1 nt-bg-neutral-alpha-25 nt-rounded-lg nt-border nt-border-neutral-alpha-50',
          context: {
            schedule: schedule(),
          } satisfies Parameters<AppearanceCallback['scheduleContainer']>[0],
        })}
      >
        <ScheduleRowHeader schedule={schedule} isOpened={isOpened} setIsOpened={setIsOpened}>
          <ScheduleRowLabel schedule={schedule} isOpened={isOpened} />
          <ScheduleRowActions schedule={schedule} isOpened={isOpened} onChange={setIsOpened} />
        </ScheduleRowHeader>
        <Collapsible open={isOpened()}>
          <ScheduleRowBody globalPreference={props.globalPreference} isOpened={isOpened} />
        </Collapsible>
      </div>
      <div class="nt-w-full nt-border-t nt-border-neutral-alpha-100" />
    </>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Accessor, createMemo, createSignal, JSX, Setter } from 'solid-js';
import { Schedule } from '../../../../preferences/schedule';
import { Preference, WeeklySchedule } from '../../../../types';
import { useLocalization } from '../../../context';
import { useStyle } from '../../../helpers/useStyle';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/elements/Preferences/ScheduleTable.tsx
Tamaño: 8303 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { createMemo, Index, JSX } from 'solid-js';
import { Schedule } from '../../../../preferences';
import { Preference } from '../../../../preferences/preference';
import { useLocalization } from '../../../../ui/context/LocalizationContext';
import { cn } from '../../../../ui/helpers';
import { useStyle } from '../../../../ui/helpers/useStyle';
import { AppearanceCallback } from '../../../../ui/types';
import { TimeSelect } from '../../primitives';
import { Switch } from '../../primitives/Switch';
import { DayScheduleCopy } from './DayScheduleCopy';
import { weekDays } from './utils';

type ScheduleTableHeaderProps = {
  schedule?: Schedule;
  children: JSX.Element;
};

const ScheduleTableHeader = (props: ScheduleTableHeaderProps) => {
  const style = useStyle();
  return (
    <div
      class={style({
        key: 'scheduleTableHeader',
        className: 'nt-flex nt-gap-3',
        context: { schedule: props.schedule } satisfies Parameters<AppearanceCallback['scheduleTableHeader']>[0],
      })}
    >
      {props.children}
    </div>
  );
};

type ScheduleTableHeaderColumnProps = {
  schedule?: Schedule;
  children: JSX.Element;
  class?: string;
  dataLocalization?: string;
};

const ScheduleTableHeaderColumn = (props: ScheduleTableHeaderColumnProps) => {
  const style = useStyle();
  return (
    <div
      class={style({
        key: 'scheduleHeaderColumn',
        className: cn('nt-text-sm nt-truncate nt-text-start', props.class),
        context: { schedule: props.schedule } satisfies Parameters<AppearanceCallback['scheduleHeaderColumn']>[0],
      })}
      data-localization={props.dataLocalization}
    >
      {props.children}
    </div>
  );
};

type ScheduleTableBodyProps = {
  schedule?: Schedule;
  children: JSX.Element;
};

const ScheduleTableBody = (props: ScheduleTableBodyProps) => {
  const style = useStyle();
  return (
    <div
      class={style({
        key: 'scheduleTableBody',
        className: 'nt-flex nt-flex-col nt-gap-1',
        context: { schedule: props.schedule } satisfies Parameters<AppearanceCallback['scheduleTableBody']>[0],
      })}
    >
      {props.children}
    </div>
  );
};

type ScheduleTableRowProps = {
  schedule?: Schedule;
  children: JSX.Element;
};

const ScheduleTableRow = (props: ScheduleTableRowProps) => {
  const style = useStyle();
  return (
    <div
      class={style({
        key: 'scheduleBodyRow',
        className: 'nt-flex nt-gap-3',
        context: { schedule: props.schedule } satisfies Parameters<AppearanceCallback['scheduleBodyRow']>[0],
      })}
    >
      {props.children}
    </div>
  );
};

type ScheduleTableCellProps = {
  schedule?: Schedule;
  children: JSX.Element;
  class?: string;
};
const ScheduleBodyColumn = (props: ScheduleTableCellProps) => {
  const style = useStyle();
  return (
    <div
      class={style({
        key: 'scheduleBodyColumn',
        className: cn('nt-text-sm', props.class),
        context: { schedule: props.schedule } satisfies Parameters<AppearanceCallback['scheduleBodyColumn']>[0],
      })}
    >
      {props.children}
    </div>
  );
};

type ScheduleTableProps = {
  globalPreference?: Preference;
};

export const ScheduleTable = (props: ScheduleTableProps) => {
  const style = useStyle();
  const { t } = useLocalization();
  const isScheduleDisabled = createMemo(() => !props.globalPreference?.schedule?.isEnabled);
  const schedule = createMemo(() => props.globalPreference?.schedule);

  return (
    <div
      class={style({
        key: 'scheduleTable',
        className: 'nt-flex nt-flex-col nt-gap-1',
        context: { schedule: schedule() } satisfies Parameters<AppearanceCallback['scheduleTable']>[0],
      })}
    >
      <ScheduleTableHeader schedule={schedule()}>
        <ScheduleTableHeaderColumn schedule={schedule()} class="nt-flex-1" dataLocalization="preferences.schedule.days">
          {t('preferences.schedule.days')}
        </ScheduleTableHeaderColumn>
        <ScheduleTableHeaderColumn
          schedule={schedule()}
          class="nt-min-w-[74px]"
          dataLocalization="preferences.schedule.from"
        >
          {t('preferences.schedule.from')}
        </ScheduleTableHeaderColumn>
        <ScheduleTableHeaderColumn
          schedule={schedule()}
          class="nt-min-w-[74px]"
          dataLocalization="preferences.schedule.to"
        >
          {t('preferences.schedule.to')}
        </ScheduleTableHeaderColumn>
      </ScheduleTableHeader>
      <ScheduleTableBody schedule={schedule()}>
        <Index each={weekDays}>
          {(day) => {
            const isDayDisabled = createMemo(() => !schedule()?.weeklySchedule?.[day()]?.isEnabled);

            return (
              <ScheduleTableRow schedule={schedule()}>
                <ScheduleBodyColumn schedule={schedule()} class="nt-flex-1 nt-flex nt-items-center nt-gap-2">
                  <Switch
                    state={isDayDisabled() ? 'disabled' : 'enabled'}
                    onChange={(state) => {
                      const isEnabled = state === 'enabled';
                      const hasNoHours = (schedule()?.weeklySchedule?.[day()]?.hours?.length ?? 0) === 0;

                      schedule()?.update({
                        weeklySchedule: {
                          ...schedule()?.weeklySchedule,
                          [day()]: {
                            ...schedule()?.weeklySchedule?.[day()],
                            isEnabled,
                            ...(hasNoHours && { hours: [{ start: '09:00 AM', end: '05:00 PM' }] }),
                          },
                        },
                      });
                    }}
                    disabled={isScheduleDisabled()}
                  />
                  <span
                    class={cn('nt-group nt-flex nt-items-center nt-gap-1', {
                      'nt-text-neutral-alpha-500': isScheduleDisabled(),
                    })}
                    data-localization={`preferences.schedule.${day()}`}
                  >
                    {t(`preferences.schedule.${day()}`)}
                    <DayScheduleCopy day={day} schedule={schedule} disabled={isScheduleDisabled()} />
                  </span>
                </ScheduleBodyColumn>
                <ScheduleBodyColumn schedule={schedule()}>
                  <TimeSelect
                    disabled={isScheduleDisabled() || isDayDisabled()}
                    value={schedule()?.weeklySchedule?.[day()]?.hours?.[0]?.start}
                    onChange={(value) => {
                      schedule()?.update({
                        weeklySchedule: {
                          ...schedule()?.weeklySchedule,
                          [day()]: {
                            ...schedule()?.weeklySchedule?.[day()],
                            hours: [
                              {
                                start: value,
                                end: schedule()?.weeklySchedule?.[day()]?.hours?.[0]?.end,
                              },
                            ],
                          },
                        },
                      });
                    }}
                  />
                </ScheduleBodyColumn>
                <ScheduleBodyColumn schedule={schedule()}>
                  <TimeSelect
                    disabled={isScheduleDisabled() || isDayDisabled()}
                    value={schedule()?.weeklySchedule?.[day()]?.hours?.[0]?.end}
                    onChange={(value) => {
                      schedule()?.update({
                        weeklySchedule: {
                          ...schedule()?.weeklySchedule,
                          [day()]: {
                            ...schedule()?.weeklySchedule?.[day()],
                            hours: [
                              {
                                start: schedule()?.weeklySchedule?.[day()]?.hours?.[0]?.start,
                                end: value,
                              },
                            ],
                          },
                        },
                      });
                    }}
                  />
                </ScheduleBodyColumn>
              </ScheduleTableRow>
            );
          }}
        </Index>
      </ScheduleTableBody>
    </div>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { createMemo, Index, JSX } from 'solid-js';
import { Schedule } from '../../../../preferences';
import { Preference } from '../../../../preferences/preference';
import { useLocalization } from '../../../../ui/context/LocalizationContext';
import { cn } from '../../../../ui/helpers';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/elements/Preferences/index.ts
Tamaño: 31 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './Preferences';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/components/elements/Preferences/utils.ts
Tamaño: 203 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { WeeklySchedule } from '../../../../types';

export const weekDays: Array<keyof WeeklySchedule> = [
  'monday',
  'tuesday',
  'wednesday',
  'thursday',
  'friday',
  'saturday',
  'sunday',
];


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/Badge.tsx
Tamaño: 1225 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { cva, VariantProps } from 'class-variance-authority';
import { splitProps } from 'solid-js';
import { JSX } from 'solid-js/jsx-runtime';
import { cn, useStyle } from '../../helpers';
import type { AppearanceKey } from '../../types';

export const badgeVariants = cva(cn('nt-inline-flex nt-flex-row nt-gap-1 nt-items-center'), {
  variants: {
    variant: {
      secondary: 'nt-bg-neutral-alpha-50',
    },
    size: {
      default: 'nt-px-1 nt-py-px nt-rounded-sm nt-text-xs nt-px-1',
    },
  },
  defaultVariants: {
    variant: 'secondary',
    size: 'default',
  },
});

type BadgeProps = JSX.IntrinsicElements['span'] & {
  appearanceKey?: AppearanceKey;
  context?: Record<string, unknown>;
} & VariantProps<typeof badgeVariants>;
export const Badge = (props: BadgeProps) => {
  const [local, rest] = splitProps(props, ['class', 'appearanceKey', 'context']);
  const style = useStyle();

  return (
    <span
      data-variant={props.variant}
      data-size={props.size}
      class={style({
        key: local.appearanceKey || 'badge',
        className: cn(badgeVariants({ variant: props.variant, size: props.size }), local.class),
        context: local.context,
      })}
      {...rest}
    />
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { cva, VariantProps } from 'class-variance-authority';
import { splitProps } from 'solid-js';
import { JSX } from 'solid-js/jsx-runtime';
import { cn, useStyle } from '../../helpers';
import type { AppearanceKey } from '../../types';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/Button.tsx
Tamaño: 3275 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { cva, VariantProps } from 'class-variance-authority';
import { splitProps } from 'solid-js';
import { JSX } from 'solid-js/jsx-runtime';
import { cn, useStyle } from '../../helpers';
import type { AppearanceKey } from '../../types';

export const buttonVariants = cva(
  cn(
    'nt-inline-flex nt-gap-4 nt-items-center nt-justify-center nt-whitespace-nowrap nt-text-sm nt-font-medium nt-transition-colors disabled:nt-pointer-events-none disabled:nt-opacity-50 after:nt-absolute after:nt-content-[""] before:nt-content-[""] before:nt-absolute [&_svg]:nt-pointer-events-none [&_svg]:nt-shrink-0',
    `focus-visible:nt-outline-none focus-visible:nt-ring-2 focus-visible:nt-rounded-md focus-visible:nt-ring-ring focus-visible:nt-ring-offset-2`
  ),
  {
    variants: {
      variant: {
        default:
          'nt-bg-gradient-to-b nt-from-20% nt-from-primary-foreground-alpha-200 nt-to-transparent nt-bg-primary nt-text-primary-foreground nt-shadow-[0_0_0_0.5px_var(--nv-color-primary-600)] nt-relative before:nt-absolute before:nt-inset-0 before:nt-border before:nt-border-primary-foreground-alpha-100 after:nt-absolute after:nt-inset-0 after:nt-opacity-0 hover:after:nt-opacity-100 after:nt-transition-opacity after:nt-bg-gradient-to-b after:nt-from-primary-foreground-alpha-50 after:nt-to-transparent',
        secondary:
          'nt-bg-secondary nt-text-secondary-foreground nt-shadow-[0_0_0_0.5px_var(--nv-color-secondary-600)] nt-relative before:nt-absolute before:nt-inset-0 before:nt-border before:nt-border-secondary-foreground-alpha-100 after:nt-absolute after:nt-inset-0 after:nt-opacity-0 hover:after:nt-opacity-100 after:nt-transition-opacity after:nt-bg-gradient-to-b after:nt-from-secondary-foreground-alpha-50 after:nt-to-transparent',
        ghost: 'hover:nt-bg-neutral-alpha-100 nt-text-foreground-alpha-600 hover:nt-text-foreground-alpha-800',
        unstyled: '',
      },
      size: {
        none: '',
        iconSm: 'nt-p-1 nt-rounded-md after:nt-rounded-md before:nt-rounded-md focus-visible:nt-rounded-md',
        icon: 'nt-p-2.5 nt-rounded-xl before:nt-rounded-xl after:nt-rounded-xl focus-visible:nt-rounded-xl',
        default: 'nt-px-2 nt-py-1 nt-rounded-lg focus-visible:nt-rounded-lg before:nt-rounded-lg after:nt-rounded-lg',
        sm: 'nt-px-1 nt-py-px nt-rounded-md nt-text-xs nt-px-1 before:nt-rounded-md focus-visible:nt-rounded-md after:nt-rounded-md',
        lg: 'nt-px-8 nt-py-2 nt-text-base before:nt-rounded-lg after:nt-rounded-lg focus-visible:nt-rounded-lg',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
);

type ButtonProps = JSX.IntrinsicElements['button'] & {
  appearanceKey?: AppearanceKey;
  context?: Record<string, unknown>;
} & VariantProps<typeof buttonVariants>;
export const Button = (props: ButtonProps) => {
  const [local, rest] = splitProps(props, ['class', 'appearanceKey', 'context']);
  const style = useStyle();

  return (
    <button
      data-variant={props.variant}
      data-size={props.size}
      class={style({
        key: local.appearanceKey || 'button',
        className: cn(buttonVariants({ variant: props.variant, size: props.size }), local.class),
        context: local.context,
      })}
      {...rest}
    />
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { cva, VariantProps } from 'class-variance-authority';
import { splitProps } from 'solid-js';
import { JSX } from 'solid-js/jsx-runtime';
import { cn, useStyle } from '../../helpers';
import type { AppearanceKey } from '../../types';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/Checkbox.tsx
Tamaño: 2455 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import * as CheckboxPrimitive from '@kobalte/core/checkbox';
import type { PolymorphicProps } from '@kobalte/core/polymorphic';
import type { ValidComponent } from 'solid-js';
import { Match, Switch, splitProps } from 'solid-js';
import { cn } from '../../helpers/utils';

type CheckboxRootProps<T extends ValidComponent = 'div'> = CheckboxPrimitive.CheckboxRootProps<T> & {
  class?: string | undefined;
};

const Checkbox = <T extends ValidComponent = 'div'>(props: PolymorphicProps<T, CheckboxRootProps<T>>) => {
  const [local, others] = splitProps(props as CheckboxRootProps, ['class']);
  return (
    <CheckboxPrimitive.Root class={cn('nt-items-top nt-group nt-relative nt-flex', local.class)} {...others}>
      <CheckboxPrimitive.Input class="nt-peer" />
      <CheckboxPrimitive.Control class="nt-size-4 nt-shrink-0 nt-rounded-sm nt-border nt-border-primary nt-ring-offset-background data-[disabled]:nt-cursor-not-allowed data-[disabled]:nt-opacity-50 peer-focus-visible:nt-outline-none peer-focus-visible:nt-ring-2 peer-focus-visible:ntring-ring peer-focus-visible:nt-ring-offset-2 data-[checked]:nt-border-none data-[indeterminate]:nt-border-none data-[checked]:nt-bg-primary data-[indeterminate]:nt-bg-primary data-[checked]:nt-text-primary-foreground data-[indeterminate]:nt-text-primary-foreground">
        <CheckboxPrimitive.Indicator>
          <Switch>
            <Match when={!others.indeterminate}>
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
                class="size-4"
              >
                <path d="M5 12l5 5l10 -10" />
              </svg>
            </Match>
            <Match when={others.indeterminate}>
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
                class="size-4"
              >
                <path d="M5 12l14 0" />
              </svg>
            </Match>
          </Switch>
        </CheckboxPrimitive.Indicator>
      </CheckboxPrimitive.Control>
    </CheckboxPrimitive.Root>
  );
};

export { Checkbox };


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import * as CheckboxPrimitive from '@kobalte/core/checkbox';
import type { PolymorphicProps } from '@kobalte/core/polymorphic';
import type { ValidComponent } from 'solid-js';
import { Match, Switch, splitProps } from 'solid-js';
import { cn } from '../../helpers/utils';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/Collapsible.tsx
Tamaño: 1805 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { type Component, createEffect, createSignal, JSX, onCleanup } from 'solid-js';
import { useStyle } from '../../helpers';

type CollapsibleProps = JSX.IntrinsicElements['div'] & {
  class?: string;
  open: boolean;
};

const isInterpolateSizeSupported = () => {
  return CSS.supports('interpolate-size', 'allow-keywords');
};

export const Collapsible: Component<CollapsibleProps> = (props) => {
  const supportsInterpolateSize = isInterpolateSizeSupported();
  const style = useStyle();
  let contentRef: HTMLDivElement | undefined;
  const [enableTransition, setEnableTransition] = createSignal(false);
  const [scrollHeight, setScrollHeight] = createSignal(0);

  const updateScrollHeight = () => {
    setScrollHeight(contentRef?.scrollHeight || 0);
  };

  createEffect(() => {
    // Delay applying transitions until after the initial render
    requestAnimationFrame(() => setEnableTransition(true));

    const resizeObserver = new ResizeObserver(() => {
      updateScrollHeight();
    });
    if (contentRef && !supportsInterpolateSize) {
      resizeObserver.observe(contentRef);
    }

    updateScrollHeight();

    onCleanup(() => {
      resizeObserver.disconnect();
    });
  });

  const height = () => {
    if (supportsInterpolateSize) {
      return props.open ? 'max-content' : '0px';
    }

    return props.open ? `${scrollHeight()}px` : '0px';
  };

  return (
    <div
      class={style({
        key: 'collapsible',
        className: props.class,
      })}
      style={{
        overflow: 'hidden',
        opacity: props.open ? 1 : 0,
        transition: enableTransition() ? 'height 250ms ease-in-out, opacity 250ms ease-in-out' : 'none',
        height: height(),
      }}
      {...props}
    >
      <div ref={contentRef}>{props.children}</div>
    </div>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { type Component, createEffect, createSignal, JSX, onCleanup } from 'solid-js';
import { useStyle } from '../../helpers';
type CollapsibleProps = JSX.IntrinsicElements['div'] & {
class?: string;
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/CopyToClipboard.tsx
Tamaño: 1478 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { createSignal, JSX } from 'solid-js';
import { useStyle } from '../../helpers';
import { Tooltip } from './Tooltip';

type CopyToClipboardProps = {
  textToCopy: string;
  children: JSX.Element;
  tooltipText?: string;
  tooltipDuration?: number;
};

export function CopyToClipboard(props: CopyToClipboardProps) {
  const [isCopied, setIsCopied] = createSignal(false);
  const style = useStyle();
  let timeoutId: number | undefined;

  const defaultTooltipText = 'Copied!';
  const defaultTooltipDuration = 2000;

  async function handleCopy() {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }

    try {
      await navigator.clipboard.writeText(props.textToCopy);
      setIsCopied(true);
      timeoutId = window.setTimeout(() => {
        setIsCopied(false);
        timeoutId = undefined;
      }, props.tooltipDuration ?? defaultTooltipDuration);
    } catch (err) {
      console.error('Failed to copy text: ', err);
    }
  }

  return (
    <Tooltip.Root open={isCopied()} placement="top" animationDuration={0.15}>
      <Tooltip.Trigger
        asChild={(triggerProps) => (
          <button
            type="button"
            {...triggerProps}
            onClick={handleCopy}
            class={style({ key: 'button', className: 'nt-cursor-pointer' })}
          >
            {props.children}
          </button>
        )}
      />
      <Tooltip.Content>{props.tooltipText ?? defaultTooltipText}</Tooltip.Content>
    </Tooltip.Root>
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { createSignal, JSX } from 'solid-js';
import { useStyle } from '../../helpers';
import { Tooltip } from './Tooltip';
type CopyToClipboardProps = {
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/DatePicker.tsx
Tamaño: 12573 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Accessor, createContext, createSignal, JSX, splitProps, useContext } from 'solid-js';
import { useLocalization } from '../../context/LocalizationContext';
import { useStyle } from '../../helpers';
import { cn } from '../../helpers/utils';
import { ArrowLeft as DefaultArrowLeft } from '../../icons';
import { ArrowRight as DefaultArrowRight } from '../../icons/ArrowRight';
import { AppearanceKey } from '../../types';
import { IconRendererWrapper } from '../shared/IconRendererWrapper';
import { Button } from './Button';
import { Tooltip } from './Tooltip';

type DatePickerContextType = {
  currentDate: Accessor<Date>;
  setCurrentDate: (date: Date) => void;
  viewMonth: Accessor<Date>;
  setViewMonth: (date: Date) => void;
  selectedDate: Accessor<Date | null>;
  setSelectedDate: (date: Date | null) => void;
  maxDays: Accessor<number>;
};

const DatePickerContext = createContext<DatePickerContextType>({
  currentDate: () => new Date(),
  setCurrentDate: () => {},
  viewMonth: () => new Date(),
  setViewMonth: () => {},
  selectedDate: () => null,
  setSelectedDate: () => {},
  maxDays: () => 0,
});

export const useDatePicker = () => useContext(DatePickerContext);

type DatePickerProps = JSX.IntrinsicElements['div'] & {
  appearanceKey?: AppearanceKey;
  value?: Date | string;
  onDateChange?: (date: Date | null) => void;
  maxDays: number;
  children: JSX.Element;
};
export const DatePicker = (props: DatePickerProps) => {
  const [local, rest] = splitProps(props, ['children', 'value', 'onDateChange', 'class', 'maxDays']);

  const style = useStyle();
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  const [currentDate, setCurrentDate] = createSignal(today);
  const [viewMonth, setViewMonth] = createSignal(today);
  const [selectedDate, setSelectedDate] = createSignal(local.value ? new Date(local.value) : null);

  const handleDateSelect = (date: Date | null) => {
    setSelectedDate(date);
    if (local.onDateChange) {
      local.onDateChange(date);
    }
  };

  return (
    <DatePickerContext.Provider
      value={{
        currentDate,
        setCurrentDate,
        viewMonth,
        setViewMonth,
        selectedDate,
        setSelectedDate: handleDateSelect,
        maxDays: () => props.maxDays,
      }}
    >
      <div class={style({ key: 'datePicker', className: cn('nt-p-2', local.class) })} {...rest}>
        {local.children}
      </div>
    </DatePickerContext.Provider>
  );
};

type DatePickerHeaderProps = JSX.IntrinsicElements['div'] & { appearanceKey?: AppearanceKey };
export const DatePickerHeader = (props: DatePickerHeaderProps) => {
  const [local, rest] = splitProps(props, ['class', 'appearanceKey', 'children']);
  const style = useStyle();
  const { viewMonth, setViewMonth, currentDate, maxDays } = useDatePicker();

  const prevIconClass = style({
    key: 'datePickerControlPrevTrigger__icon',
    className: 'nt-size-4 nt-text-foreground-alpha-700',
    iconKey: 'arrowLeft',
  });

  const nextIconClass = style({
    key: 'datePickerControlNextTrigger__icon',
    className: 'nt-size-4 nt-text-foreground-alpha-700',
    iconKey: 'arrowRight',
  });

  const handlePrevMonth = () => {
    const date = new Date(viewMonth());
    date.setMonth(date.getMonth() - 1);

    // Don't allow navigating to months before the current month
    const currentMonth = currentDate();
    if (
      date.getFullYear() < currentMonth.getFullYear() ||
      (date.getFullYear() === currentMonth.getFullYear() && date.getMonth() < currentMonth.getMonth())
    ) {
      return;
    }

    setViewMonth(date);
  };

  const handleNextMonth = () => {
    const date = new Date(viewMonth());
    date.setMonth(date.getMonth() + 1);

    const maxDaysValue = maxDays();
    if (maxDaysValue > 0) {
      const maxDate = new Date(currentDate());
      maxDate.setDate(maxDate.getDate() + maxDaysValue);

      if (
        date.getFullYear() > maxDate.getFullYear() ||
        (date.getFullYear() === maxDate.getFullYear() && date.getMonth() > maxDate.getMonth())
      ) {
        return;
      }
    }

    setViewMonth(date);
  };

  const isPrevDisabled = () => {
    const current = currentDate();
    const view = viewMonth();

    return view.getFullYear() === current.getFullYear() && view.getMonth() === current.getMonth();
  };

  const isNextDisabled = () => {
    const maxDaysValue = maxDays();
    if (maxDaysValue === 0) return false;

    const view = viewMonth();

    const maxDate = new Date(currentDate());
    maxDate.setDate(maxDate.getDate() + maxDaysValue);

    return view.getFullYear() === maxDate.getFullYear() && view.getMonth() === maxDate.getMonth();
  };

  return (
    <div
      class={style({
        key: local.appearanceKey || 'datePickerControl',
        className: cn(
          'nt-flex nt-items-center nt-justify-between nt-gap-1.5 nt-h-7 nt-p-1 nt-mb-2 nt-rounded-lg nt-bg-background',
          local.class
        ),
      })}
      {...rest}
    >
      <Button
        appearanceKey="datePickerControlPrevTrigger"
        variant="ghost"
        onClick={(e) => {
          e.stopPropagation();
          handlePrevMonth();
        }}
        disabled={isPrevDisabled()}
        class="nt-flex nt-justify-center nt-items-center nt-gap-0.5 nt-w-5 nt-h-5 nt-p-0 nt-rounded-md nt-bg-background nt-shadow-[0px_1px_2px_0px_rgba(10,13,20,0.03)]"
      >
        <IconRendererWrapper
          iconKey="arrowLeft"
          class={prevIconClass}
          fallback={<DefaultArrowLeft class={prevIconClass} />}
        />
      </Button>
      <span
        class={style({
          key: 'datePickerHeaderMonth',
          className: 'nt-text-sm nt-font-medium nt-text-foreground-alpha-700',
        })}
      >
        {viewMonth().toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}
      </span>
      <Button
        appearanceKey="datePickerControlNextTrigger"
        variant="ghost"
        onClick={(e) => {
          e.stopPropagation();
          handleNextMonth();
        }}
        disabled={isNextDisabled()}
        class="nt-flex nt-justify-center nt-items-center nt-gap-0.5 nt-w-5 nt-h-5 nt-p-0 nt-rounded-md nt-bg-background nt-shadow-[0px_1px_2px_0px_rgba(10,13,20,0.03)]"
      >
        <IconRendererWrapper
          iconKey="arrowRight"
          class={nextIconClass}
          fallback={<DefaultArrowRight class={nextIconClass} />}
        />
      </Button>
    </div>
  );
};

type DatePickerGridProps = JSX.IntrinsicElements['div'] & { appearanceKey?: AppearanceKey };
export const DatePickerGrid = (props: DatePickerGridProps) => {
  const [local, rest] = splitProps(props, ['class', 'appearanceKey']);
  const style = useStyle();

  return (
    <div
      class={style({
        key: local.appearanceKey || 'datePickerGrid',
        className: cn('nt-w-full nt-grid nt-gap-1', local.class),
      })}
      {...rest}
    />
  );
};

type DatePickerGridRowProps = JSX.IntrinsicElements['div'] & { appearanceKey?: AppearanceKey };
export const DatePickerGridRow = (props: DatePickerGridRowProps) => {
  const [local, rest] = splitProps(props, ['class', 'appearanceKey']);
  const style = useStyle();

  return (
    <div
      class={style({
        key: local.appearanceKey || 'datePickerGridRow',
        className: cn('nt-grid nt-grid-cols-7 nt-gap-1 nt-w-full', local.class),
      })}
      {...rest}
    />
  );
};

type DatePickerGridHeaderProps = JSX.IntrinsicElements['div'] & { appearanceKey?: AppearanceKey };
export const DatePickerGridHeader = (props: DatePickerGridHeaderProps) => {
  const [local, rest] = splitProps(props, ['class', 'appearanceKey']);
  const style = useStyle();

  return (
    <div
      class={style({
        key: local.appearanceKey || 'datePickerGridHeader',
        className: cn('nt-text-muted-foreground nt-text-[0.8rem] nt-font-normal nt-text-center', local.class),
      })}
      {...rest}
    />
  );
};

type DatePickerGridCellProps = JSX.IntrinsicElements['div'] & { appearanceKey?: AppearanceKey };
export const DatePickerGridCell = (props: DatePickerGridCellProps) => {
  const [local, rest] = splitProps(props, ['class', 'appearanceKey']);
  const style = useStyle();

  return (
    <div
      class={style({
        key: local.appearanceKey || 'datePickerGridCell',
        className: cn(
          'nt-p-0 nt-text-center nt-text-sm',
          'nt-has-[[data-in-range]]:bg-accent nt-has-[[data-in-range]]:first-of-type:rounded-l-md nt-has-[[data-in-range]]:last-of-type:rounded-r-md',
          'nt-has-[[data-range-end]]:rounded-r-md nt-has-[[data-range-start]]:rounded-l-md',
          'nt-has-[[data-outside-range][data-in-range]]:bg-accent/50',
          local.class
        ),
      })}
      {...rest}
    />
  );
};

type DatePickerGridCellTriggerProps = JSX.IntrinsicElements['button'] & { appearanceKey?: AppearanceKey; date: Date };
export const DatePickerGridCellTrigger = (props: DatePickerGridCellTriggerProps) => {
  const [local, rest] = splitProps(props, ['class', 'appearanceKey', 'date']);
  const { selectedDate, viewMonth, setSelectedDate, currentDate, maxDays } = useDatePicker();
  const { t } = useLocalization();

  const isCurrentMonth = props.date.getMonth() === viewMonth().getMonth();

  const isPastDate = () => {
    const today = currentDate();

    return props.date < today;
  };

  const isFutureDate = () => {
    const maxDaysValue = maxDays();
    if (maxDaysValue === 0) return false;

    const maxDate = new Date(currentDate());
    maxDate.setDate(maxDate.getDate() + maxDaysValue);

    return props.date > maxDate;
  };

  const isDisabled = !isCurrentMonth || isPastDate() || isFutureDate();

  const isExceedingLimit = () => {
    return isCurrentMonth && isFutureDate();
  };

  const buttonElement = (
    <Button
      appearanceKey="datePickerCalendarDay__button"
      variant="ghost"
      disabled={isDisabled}
      onClick={(e) => {
        e.stopPropagation();
        setSelectedDate(local.date);
      }}
      class={cn(
        'nt-size-8 nt-w-full nt-rounded-md nt-flex nt-items-center nt-justify-center',
        {
          'nt-text-muted-foreground disabled:nt-opacity-20': !isCurrentMonth || isPastDate(),
          'nt-text-foreground-alpha-700': isCurrentMonth && !isPastDate() && !isFutureDate(),
        },
        {
          'nt-bg-primary-alpha-300 hover:nt-bg-primary-alpha-400':
            selectedDate()?.toDateString() === local.date.toDateString(),
        }
      )}
      {...rest}
    >
      {local.date.getDate()}
    </Button>
  );

  if (isExceedingLimit()) {
    return (
      <Tooltip.Root>
        <Tooltip.Trigger>{buttonElement}</Tooltip.Trigger>
        <Tooltip.Content>{t('snooze.datePicker.exceedingLimitTooltip', { days: maxDays() })}</Tooltip.Content>
      </Tooltip.Root>
    );
  }

  return buttonElement;
};

export const DatePickerWithContext = ({
  onDateChange,
  maxDays,
}: {
  onDateChange?: (date: Date | null) => void;
  maxDays: number;
}) => {
  return (
    <DatePicker onDateChange={onDateChange} maxDays={maxDays}>
      <DatePickerHeader />
      <DatePickerCalendar />
    </DatePicker>
  );
};

type DatePickerCalendarProps = JSX.IntrinsicElements['div'] & {
  appearanceKey?: AppearanceKey;
};
export const DatePickerCalendar = (props: DatePickerCalendarProps) => {
  const [local, rest] = splitProps(props, ['class', 'appearanceKey']);
  const style = useStyle();
  const { viewMonth } = useDatePicker();

  const getDaysInMonth = () => {
    const year = viewMonth().getFullYear();
    const month = viewMonth().getMonth();

    const firstDay = new Date(year, month, 1);
    const daysInMonth = new Date(year, month + 1, 0).getDate();

    const startingDay = firstDay.getDay();

    const days: Date[] = [];

    for (let i = 0; i < startingDay; i += 1) {
      const prevMonthDay = new Date(year, month, -i);
      days.unshift(prevMonthDay);
    }

    for (let i = 1; i <= daysInMonth; i += 1) {
      days.push(new Date(year, month, i));
    }

    const remainingCells = 7 - (days.length % 7);
    if (remainingCells < 7) {
      for (let i = 1; i <= remainingCells; i += 1) {
        days.push(new Date(year, month + 1, i));
      }
    }

    return days;
  };

  return (
    <div
      class={style({
        key: local.appearanceKey || 'datePickerCalendar',
        className: cn('nt-grid nt-grid-cols-7 nt-gap-1', local.class),
      })}
      onClick={(e) => e.stopPropagation()}
      {...rest}
    >
      {getDaysInMonth().map((date) => {
        return <DatePickerGridCellTrigger date={date} />;
      })}
    </div>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Accessor, createContext, createSignal, JSX, splitProps, useContext } from 'solid-js';
import { useLocalization } from '../../context/LocalizationContext';
import { useStyle } from '../../helpers';
import { cn } from '../../helpers/utils';
import { ArrowLeft as DefaultArrowLeft } from '../../icons';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/Input.tsx
Tamaño: 1346 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { cva, VariantProps } from 'class-variance-authority';
import { splitProps } from 'solid-js';
import { JSX } from 'solid-js/jsx-runtime';
import { cn, useStyle } from '../../helpers';
import type { AppearanceKey } from '../../types';

export const inputVariants = cva(
  cn(
    `focus-visible:nt-outline-none focus-visible:nt-ring-2 focus-visible:nt-rounded-md focus-visible:nt-ring-ring focus-visible:nt-ring-offset-2`
  ),
  {
    variants: {
      variant: {
        default: 'nt-border nt-border-neutral-200 nt-rounded-md nt-p-1 nt-bg-background',
      },
      size: {
        default: 'nt-h-9',
        sm: 'nt-h-8 nt-text-sm',
        xs: 'nt-h-7 nt-text-xs',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
);

type InputProps = JSX.IntrinsicElements['input'] & { appearanceKey?: AppearanceKey } & VariantProps<
    typeof inputVariants
  >;
export const Input = (props: InputProps) => {
  const [local, rest] = splitProps(props, ['class', 'appearanceKey']);
  const style = useStyle();

  return (
    <input
      data-variant={props.variant}
      data-size={props.size}
      class={style({
        key: local.appearanceKey || 'input',
        className: cn(inputVariants({ variant: props.variant, size: props.size }), local.class),
      })}
      {...rest}
    />
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { cva, VariantProps } from 'class-variance-authority';
import { splitProps } from 'solid-js';
import { JSX } from 'solid-js/jsx-runtime';
import { cn, useStyle } from '../../helpers';
import type { AppearanceKey } from '../../types';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/Motion.tsx
Tamaño: 461 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Motion as MotionPrimitive, MotionProxy, MotionProxyComponent } from 'solid-motionone';
import { useAppearance } from '../../context';

export const Motion = new Proxy(MotionPrimitive, {
  get:
    (_, tag: string): MotionProxyComponent<any> =>
    (props) => {
      const { animations } = useAppearance();

      return <MotionPrimitive {...props} tag={tag} transition={animations() ? props.transition : { duration: 0 }} />;
    },
}) as MotionProxy;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Motion as MotionPrimitive, MotionProxy, MotionProxyComponent } from 'solid-motionone';
import { useAppearance } from '../../context';
export const Motion = new Proxy(MotionPrimitive, {
get:
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/Portal.tsx
Tamaño: 859 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { ComponentProps } from 'solid-js';
import { Portal as PortalPrimitive } from 'solid-js/web';
import { useAppearance } from '../../context/AppearanceContext';

export const Portal = (props: ComponentProps<typeof PortalPrimitive>) => {
  const appearance = useAppearance();
  let currentElement!: HTMLElement;

  return (
    <>
      <div
        style={{ display: 'none' }}
        ref={(el) => {
          currentElement = el;
        }}
      />
      <PortalPrimitive mount={closestNovuRootParent(currentElement, appearance.id())} {...props} />
    </>
  );
};

const closestNovuRootParent = (el: HTMLElement, id: string) => {
  let element = el;

  while (element && element.id !== `novu-root-${id}`) {
    element = element.parentElement!;
  }

  if (element && element.id === `novu-root-${id}`) {
    return element;
  }

  return undefined;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { ComponentProps } from 'solid-js';
import { Portal as PortalPrimitive } from 'solid-js/web';
import { useAppearance } from '../../context/AppearanceContext';
export const Portal = (props: ComponentProps<typeof PortalPrimitive>) => {
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/Skeleton.tsx
Tamaño: 1840 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { ClassName, cn, useStyle } from '../../helpers';
import type { AppearanceKey } from '../../types';

type SkeletonTextProps = { appearanceKey: AppearanceKey; class?: ClassName };
export const SkeletonText = (props: SkeletonTextProps) => {
  const style = useStyle();

  return (
    <div
      class={style({
        key: props.appearanceKey,
        className: cn(
          'nt-w-full nt-h-3 nt-rounded nt-bg-gradient-to-r nt-from-foreground-alpha-50 nt-to-transparent',
          props.class
        ),
      })}
    />
  );
};

type SkeletonAvatarProps = { appearanceKey: AppearanceKey; class?: ClassName };
export const SkeletonAvatar = (props: SkeletonAvatarProps) => {
  const style = useStyle();

  return (
    <div
      class={style({
        key: props.appearanceKey,
        className: cn(
          'nt-size-8 nt-rounded-lg nt-bg-gradient-to-r nt-from-foreground-alpha-50 nt-to-transparent',
          props.class
        ),
      })}
    />
  );
};

type SkeletonSwitchProps = { appearanceKey: AppearanceKey; thumbAppearanceKey: AppearanceKey; class?: ClassName };

export const SkeletonSwitch = (props: SkeletonSwitchProps) => {
  const style = useStyle();

  return (
    <div
      class={style({
        key: props.appearanceKey,
        className: cn('nt-relative nt-inline-flex nt-items-center', props.class),
      })}
    >
      {/* The track */}
      <div
        class={style({
          key: props.appearanceKey,
          className: 'nt-h-4 nt-w-7 nt-rounded-full nt-bg-gradient-to-r nt-from-foreground-alpha-50 nt-to-transparent',
        })}
      />
      {/* The thumb */}
      <div
        class={style({
          key: props.thumbAppearanceKey,
          className: 'nt-absolute nt-top-0.5 nt-left-0.5 nt-size-3 nt-rounded-full nt-bg-background nt-shadow',
        })}
      />
    </div>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { ClassName, cn, useStyle } from '../../helpers';
import type { AppearanceKey } from '../../types';
type SkeletonTextProps = { appearanceKey: AppearanceKey; class?: ClassName };
export const SkeletonText = (props: SkeletonTextProps) => {
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/Switch.tsx
Tamaño: 2063 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { cn, useStyle } from '../../helpers';

export type SwitchState = 'enabled' | 'disabled' | 'indeterminate';

export type SwitchProps = {
  state?: SwitchState;
  onChange: (state: SwitchState) => void;
  disabled?: boolean;
};

export const Switch = (props: SwitchProps) => {
  const style = useStyle();

  const handleChange = () => {
    if (props.disabled) return;

    const nextState = getNextState(props.state ?? 'disabled');
    props.onChange(nextState);
  };

  const getNextState = (currentState: SwitchState): SwitchState => {
    switch (currentState) {
      case 'enabled':
        return 'disabled';
      case 'disabled':
        return 'enabled';
      case 'indeterminate':
        return 'enabled';
      default:
        return 'disabled';
    }
  };

  const isChecked = () => props.state === 'enabled';
  const isIndeterminate = () => props.state === 'indeterminate';
  const state = () => props.state;
  const disabled = () => props.disabled;

  return (
    <label
      class={style({
        key: 'channelSwitch',
        className: cn('nt-relative nt-inline-flex nt-cursor-pointer nt-items-center', {
          'nt-opacity-50 nt-cursor-not-allowed': disabled(),
        }),
      })}
    >
      <input type="checkbox" class="nt-sr-only" checked={isChecked()} disabled={disabled()} onChange={handleChange} />
      <div
        class={style({
          key: 'channelSwitchThumb',
          className: cn(
            `nt-h-4 nt-w-7 nt-rounded-full nt-bg-neutral-alpha-300 after:nt-absolute after:nt-top-0.5 after:nt-size-3 after:nt-left-0.5 after:nt-rounded-full after:nt-bg-background after:nt-transition-all after:nt-content-[''] nt-transition-all nt-duration-200 after:nt-duration-200 shadow-sm`,
            {
              'nt-bg-primary nt-shadow-none nt-border-neutral-alpha-400 after:nt-translate-x-full after:nt-border-background':
                isChecked(),
              'after:nt-translate-x-1/2': isIndeterminate(),
            }
          ),
        })}
        data-state={state()}
      />
    </label>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { cn, useStyle } from '../../helpers';
export type SwitchState = 'enabled' | 'disabled' | 'indeterminate';
export type SwitchProps = {
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/TimePicker.tsx
Tamaño: 4555 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Component, createSignal, splitProps } from 'solid-js';
import { useStyle } from '../../helpers';
import { cn } from '../../helpers/utils';
import { AppearanceKey } from '../../types';
import { Input, inputVariants } from './Input';

export interface TimeValue {
  hour: number;
  minute: number;
  isPM: boolean;
}

interface TimePickerProps {
  value?: TimeValue;
  onChange?: (value: TimeValue) => void;
  class?: string;
  appearanceKey?: AppearanceKey;
}

export const TimePicker: Component<TimePickerProps> = (props) => {
  const [local, rest] = splitProps(props, ['value', 'onChange', 'class', 'appearanceKey']);
  const style = useStyle();

  const initialValue = local.value || { hour: 12, minute: 0, isPM: true };
  const [hour, setHour] = createSignal(initialValue.hour);
  const [minute, setMinute] = createSignal(initialValue.minute);
  const [isPM, setIsPM] = createSignal(initialValue.isPM);

  const notifyChange = () => {
    if (local.onChange) {
      local.onChange({
        hour: hour(),
        minute: minute(),
        isPM: isPM(),
      });
    }
  };

  const handleHourChange = (newHour: number) => {
    setHour(newHour);
    notifyChange();
  };

  const handleMinuteChange = (newMinute: number) => {
    setMinute(newMinute);
    notifyChange();
  };

  const handlePeriodChange = (newIsPM: boolean) => {
    setIsPM(newIsPM);
    notifyChange();
  };

  const handleKeyDown = (e: KeyboardEvent) => {
    // Allow only: digits, arrows, backspace, delete, tab
    const allowedKeys = [
      '0',
      '1',
      '2',
      '3',
      '4',
      '5',
      '6',
      '7',
      '8',
      '9',
      'ArrowLeft',
      'ArrowRight',
      'ArrowUp',
      'ArrowDown',
      'Backspace',
      'Delete',
      'Tab',
    ];
    if (!allowedKeys.includes(e.key)) {
      e.preventDefault();
    }
  };

  return (
    <div
      class={style({
        key: local.appearanceKey || 'timePicker',
        className: cn('nt-flex nt-items-center nt-gap-1', local.class),
      })}
      onClick={(e) => e.stopPropagation()}
      {...rest}
    >
      <Input
        size="sm"
        type="number"
        min="1"
        max="12"
        onKeyDown={(e) => {
          e.stopPropagation();
          handleKeyDown(e);
        }}
        value={hour().toString()}
        onInput={(e) => {
          e.stopPropagation();
          enforceMinMax(e.currentTarget);
          handleHourChange(Number(e.currentTarget.value));
        }}
        class={style({
          key: 'timePickerHour__input',
          className:
            'nt-flex nt-font-mono nt-justify-center nt-items-center nt-text-center nt-h-7 nt-w-[calc(2ch+2rem)] nt-px-2',
        })}
      />

      <span class={style({ key: 'timePicker__separator', className: 'nt-text-xl' })}>:</span>

      <Input
        size="sm"
        type="number"
        min="0"
        max="59"
        onKeyDown={(e) => {
          e.stopPropagation();
          handleKeyDown(e);
        }}
        value={minute().toString().padStart(2, '0')}
        onInput={(e) => {
          e.stopPropagation();
          enforceMinMax(e.currentTarget);
          handleMinuteChange(Number(e.currentTarget.value));
        }}
        class={style({
          key: 'timePickerHour__input',
          className:
            'nt-flex nt-font-mono nt-justify-center nt-items-center nt-text-center nt-h-7 nt-w-[calc(2ch+2rem)] nt-px-2',
        })}
      />

      <select
        class={style({
          key: 'timePicker__periodSelect',
          className: cn(inputVariants({ size: 'sm' }), 'nt-h-7 nt-font-mono'),
        })}
        value={isPM() ? 'PM' : 'AM'}
        onClick={(e) => e.stopPropagation()}
        onChange={(e) => {
          e.stopPropagation();
          handlePeriodChange(e.target.value === 'PM');
        }}
      >
        <option value="AM">AM</option>
        <option value="PM">PM</option>
      </select>
    </div>
  );
};

const enforceMinMax = (el: HTMLInputElement) => {
  if (el.value !== '') {
    const value = parseInt(el.value, 10);
    const min = parseInt(el.min, 10);
    const max = parseInt(el.max, 10);

    if (value < min || value > max) {
      // Reject the extra digit by reverting to the previous valid value
      el.value = el.value.slice(0, -1);

      // If still invalid after removing the last digit, set to min/max
      const newValue = parseInt(el.value, 10);
      if (Number.isNaN(newValue) || newValue < min) {
        el.value = el.min;
      } else if (newValue > max) {
        el.value = el.max;
      }
    }
  }
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Component, createSignal, splitProps } from 'solid-js';
import { useStyle } from '../../helpers';
import { cn } from '../../helpers/utils';
import { AppearanceKey } from '../../types';
import { Input, inputVariants } from './Input';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/TimeSelect.tsx
Tamaño: 3156 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { createMemo, For, Show } from 'solid-js';
import { cn } from '../../../ui/helpers';
import { useStyle } from '../../../ui/helpers/useStyle';
import { Check } from '../../../ui/icons';
import { Dropdown, dropdownItemVariants } from '../primitives';
import { inputVariants } from '../primitives/Input';
import { IconRenderer } from '../shared/IconRendererWrapper';

type TimeSelectProps = {
  disabled?: boolean;
  value?: string;
  onChange?: (value: string) => void;
};

const hours = Array.from({ length: 48 }, (_, i) => {
  const hour = Math.floor(i / 2);
  const minute = i % 2 === 0 ? '00' : '30';
  const period = hour < 12 ? 'AM' : 'PM';
  const displayHour = hour === 0 ? 12 : hour > 12 ? hour - 12 : hour;
  const formattedHour = displayHour.toString().padStart(2, '0');

  return `${formattedHour}:${minute} ${period}`;
});

type TimeSelectItemProps = {
  hour: string;
  isSelected: boolean;
  onClick: () => void;
};

const TimeSelectItem = (props: TimeSelectItemProps) => {
  const style = useStyle();

  return (
    <Dropdown.Item
      class={style({
        key: 'timeSelect__dropdownItem',
        className: cn(dropdownItemVariants(), 'nt-flex nt-gap-2 nt-justify-between'),
      })}
      onClick={props.onClick}
    >
      <span class="nt-text-sm">{props.hour}</span>
      <Show when={props.isSelected}>
        <IconRenderer
          iconKey="check"
          class={style({
            key: 'timeSelect__dropdownItemCheck__icon',
            className: 'nt-size-2.5 -nt-mt-[2px]',
            iconKey: 'check',
          })}
          fallback={Check}
        />
      </Show>
    </Dropdown.Item>
  );
};

export const TimeSelect = (props: TimeSelectProps) => {
  const style = useStyle();
  const time = createMemo(() => props.value?.split(' ')[0]);
  const amPm = createMemo(() => {
    if (!time()) return '';

    return props.value?.split(' ')[1] === 'PM' ? 'PM' : 'AM';
  });

  return (
    <Dropdown.Root>
      <Dropdown.Trigger
        disabled={props.disabled}
        class={style({
          key: 'timeSelect__dropdownTrigger',
          className: 'nt-w-full',
        })}
      >
        <span
          class={style({
            key: 'timeSelect__time',
            className: cn(
              inputVariants({ size: 'xs', variant: 'default' }),
              'nt-min-w-[74px] nt-flex nt-px-2 nt-py-1.5 nt-items-center nt-justify-between nt-w-full nt-text-sm',
              {
                'nt-justify-center nt-text-neutral-alpha-500': props.disabled || !time(),
              }
            ),
          })}
        >
          <span>{time() ?? '-'}</span>
          {amPm() && <span>{amPm()}</span>}
        </span>
      </Dropdown.Trigger>
      <Dropdown.Content
        portal
        appearanceKey="timeSelect__dropdownContent"
        class="-nt-mt-2 nt-rounded-md nt-min-w-[120px] nt-max-w-[120px] nt-max-h-[160px] nt-overflow-y-auto"
      >
        <For each={hours}>
          {(hour) => (
            <TimeSelectItem hour={hour} isSelected={props.value === hour} onClick={() => props.onChange?.(hour)} />
          )}
        </For>
      </Dropdown.Content>
    </Dropdown.Root>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { createMemo, For, Show } from 'solid-js';
import { cn } from '../../../ui/helpers';
import { useStyle } from '../../../ui/helpers/useStyle';
import { Check } from '../../../ui/icons';
import { Dropdown, dropdownItemVariants } from '../primitives';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/index.ts
Tamaño: 254 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './Button';
export * from './Checkbox';
export * from './CopyToClipboard';
export * from './DatePicker';
export * from './Dropdown';
export * from './Motion';
export * from './Popover';
export * from './Tabs';
export * from './TimeSelect';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/Dropdown/DropdownContent.tsx
Tamaño: 691 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { ComponentProps, splitProps } from 'solid-js';
import { cn } from '../../../helpers';
import type { AppearanceKey } from '../../../types';
import { Popover } from '../Popover';

export const dropdownContentVariants = () =>
  'nt-p-1 nt-text-sm nt-min-w-52 nt-shadow-dropdown nt-h-fit nt-min-w-52 nt-w-max';

export const DropdownContent = (props: ComponentProps<typeof Popover.Content> & { appearanceKey?: AppearanceKey }) => {
  const [local, rest] = splitProps(props, ['appearanceKey', 'class']);

  return (
    <Popover.Content
      appearanceKey={local.appearanceKey || 'dropdownContent'}
      class={cn(dropdownContentVariants(), local.class)}
      {...rest}
    />
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { ComponentProps, splitProps } from 'solid-js';
import { cn } from '../../../helpers';
import type { AppearanceKey } from '../../../types';
import { Popover } from '../Popover';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/Dropdown/DropdownItem.tsx
Tamaño: 1396 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { splitProps } from 'solid-js';
import { JSX } from 'solid-js/jsx-runtime';
import { Dynamic } from 'solid-js/web';
import { cn } from '../../../helpers';
import type { AppearanceKey } from '../../../types';
import { Popover, usePopover } from '../Popover';

export const dropdownItemVariants = () =>
  'focus:nt-outline-none nt-flex nt-items-center nt-gap-1.5 nt-text-sm nt-rounded-lg nt-items-center hover:nt-bg-neutral-alpha-50 focus-visible:nt-bg-neutral-alpha-50 nt-py-1 nt-px-2';

type DropdownItemProps = JSX.IntrinsicElements['button'] & {
  appearanceKey?: AppearanceKey;
  asChild?: (props: any) => JSX.Element;
};
export const DropdownItem = (props: DropdownItemProps) => {
  const [local, rest] = splitProps(props, ['appearanceKey', 'onClick', 'class', 'asChild']);
  const { onClose } = usePopover();

  const handleClick = (e: MouseEvent) => {
    if (typeof local.onClick === 'function') {
      local.onClick(e as any);
    }
    onClose();
  };

  if (local.asChild) {
    return <Dynamic component={local.asChild} onClick={handleClick} {...rest} />;
  }

  return (
    <Popover.Close
      appearanceKey={local.appearanceKey || 'dropdownItem'}
      class={cn(dropdownItemVariants(), local.class)}
      onClick={(e) => {
        if (typeof local.onClick === 'function') {
          local.onClick(e);
        }
        onClose();
      }}
      {...rest}
    />
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { splitProps } from 'solid-js';
import { JSX } from 'solid-js/jsx-runtime';
import { Dynamic } from 'solid-js/web';
import { cn } from '../../../helpers';
import type { AppearanceKey } from '../../../types';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/Dropdown/DropdownRoot.tsx
Tamaño: 249 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { ComponentProps } from 'solid-js';
import { Popover } from '../Popover';

export const DropdownRoot = (props: ComponentProps<typeof Popover.Root>) => {
  return <Popover.Root placement="bottom" fallbackPlacements={['top']} {...props} />;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { ComponentProps } from 'solid-js';
import { Popover } from '../Popover';
export const DropdownRoot = (props: ComponentProps<typeof Popover.Root>) => {
return <Popover.Root placement="bottom" fallbackPlacements={['top']} {...props} />;
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/Dropdown/DropdownTrigger.tsx
Tamaño: 854 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { ComponentProps, splitProps } from 'solid-js';
import { cn, useStyle } from '../../../helpers';
import type { AppearanceKey } from '../../../types';
import { Popover } from '../Popover';

export const dropdownTriggerButtonVariants = () =>
  `nt-relative nt-transition nt-outline-none focus-visible:nt-outline-none` +
  `focus-visible:nt-ring-2 focus-visible:nt-ring-primary focus-visible:nt-ring-offset-2`;

export const DropdownTrigger = (props: ComponentProps<typeof Popover.Trigger> & { appearanceKey?: AppearanceKey }) => {
  const style = useStyle();
  const [local, rest] = splitProps(props, ['appearanceKey', 'class']);

  return (
    <Popover.Trigger
      class={style({
        key: local.appearanceKey || 'dropdownTrigger',
        className: cn(dropdownTriggerButtonVariants(), local.class),
      })}
      {...rest}
    />
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { ComponentProps, splitProps } from 'solid-js';
import { cn, useStyle } from '../../../helpers';
import type { AppearanceKey } from '../../../types';
import { Popover } from '../Popover';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/Dropdown/index.ts
Tamaño: 967 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Popover } from '../Popover';
import { DropdownContent } from './DropdownContent';
import { DropdownItem } from './DropdownItem';
import { DropdownRoot } from './DropdownRoot';
import { DropdownTrigger } from './DropdownTrigger';

export { dropdownContentVariants } from './DropdownContent';
export { dropdownItemVariants } from './DropdownItem';
export { dropdownTriggerButtonVariants } from './DropdownTrigger';

export const Dropdown = {
  Root: DropdownRoot,
  /**
   * Dropdown.Trigger renders a `button` and has no default styling.
   */
  Trigger: DropdownTrigger,
  /**
   * Dropdown.Content renders a `Popover.Content` by default.
   */
  Content: DropdownContent,
  /**
   * Dropdown.Close renders a `Popover.Close` by default.
   */
  Close: Popover.Close,
  /**
   * Dropdown.Item renders a `Popover.Close` with dropdown specific styling.
   * Closes the popover when clicked.
   * `onClick` function is propagated.
   */
  Item: DropdownItem,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/Popover/PopoverClose.tsx
Tamaño: 1007 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX, splitProps } from 'solid-js';
import { Dynamic } from 'solid-js/web';
import { useStyle } from '../../../helpers/useStyle';
import { AppearanceKey } from '../../../types';
import { usePopover } from '.';

type PopoverCloseProps = JSX.IntrinsicElements['button'] & {
  asChild?: (props: any) => JSX.Element;
  appearanceKey?: AppearanceKey;
};
export const PopoverClose = (props: PopoverCloseProps) => {
  const { onClose } = usePopover();
  const style = useStyle();
  const [local, rest] = splitProps(props, ['onClick', 'asChild', 'appearanceKey', 'class']);

  const handleClick = (e: MouseEvent) => {
    if (typeof local.onClick === 'function') {
      local.onClick(e as any);
    }
    onClose();
  };

  if (local.asChild) {
    return <Dynamic component={local.asChild} onClick={handleClick} {...rest} />;
  }

  return (
    <button
      onClick={handleClick}
      class={style({ key: local.appearanceKey || 'popoverClose', className: local.class })}
      {...rest}
    />
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX, splitProps } from 'solid-js';
import { Dynamic } from 'solid-js/web';
import { useStyle } from '../../../helpers/useStyle';
import { AppearanceKey } from '../../../types';
import { usePopover } from '.';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/Popover/PopoverContent.tsx
Tamaño: 2863 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX, onCleanup, onMount, Show, splitProps } from 'solid-js';
import { useAppearance, useFocusManager } from '../../../context';
import { cn, useStyle } from '../../../helpers';
import type { AppearanceKey } from '../../../types';
import { Portal } from '../Portal';
import { usePopover } from './PopoverRoot';

export const popoverContentVariants = () =>
  cn(
    'nt-w-[400px] nt-h-[600px] nt-rounded-xl nt-bg-background',
    'nt-shadow-popover nt-animate-in nt-slide-in-from-top-2 nt-fade-in nt-cursor-default nt-flex nt-flex-col nt-overflow-hidden nt-border nt-border-border nt-z-10'
  );

const PopoverContentBody = (props: PopoverContentProps) => {
  const { open, setFloating, floating, floatingStyles } = usePopover();
  const { setActive, removeActive } = useFocusManager();
  const [local, rest] = splitProps(props, ['class', 'appearanceKey', 'style']);
  const style = useStyle();

  onMount(() => {
    const floatingEl = floating();
    setActive(floatingEl!);

    onCleanup(() => {
      removeActive(floatingEl!);
    });
  });

  return (
    <div
      ref={setFloating}
      class={style({
        key: local.appearanceKey || 'popoverContent',
        className: cn(popoverContentVariants(), local.class),
      })}
      style={floatingStyles()}
      data-open={open()}
      {...rest}
    />
  );
};

type PopoverContentProps = JSX.IntrinsicElements['div'] & { appearanceKey?: AppearanceKey; portal?: boolean };
export const PopoverContent = (props: PopoverContentProps) => {
  const { open, onClose, reference, floating } = usePopover();
  const { active } = useFocusManager();
  const { container } = useAppearance();

  const handleClickOutside: EventListener = (e) => {
    // Don't count the trigger as outside click
    if (reference()?.contains(e.target as Node)) {
      return;
    }

    const containerElement = container();

    if (
      active() !== floating() ||
      floating()?.contains(e.target as Node) ||
      (containerElement && (e.target as Element).shadowRoot === containerElement)
    ) {
      return;
    }

    onClose();
  };

  const handleEscapeKey: EventListener = (e) => {
    if (active() !== floating()) {
      return;
    }

    if (e instanceof KeyboardEvent && e.key === 'Escape') {
      onClose();
    }
  };

  onMount(() => {
    document.body.addEventListener('click', handleClickOutside);
    container()?.addEventListener('click', handleClickOutside);
    document.body.addEventListener('keydown', handleEscapeKey);
  });

  onCleanup(() => {
    document.body.removeEventListener('click', handleClickOutside);
    container()?.removeEventListener('click', handleClickOutside);
    document.body.removeEventListener('keydown', handleEscapeKey);
  });

  return (
    <Show when={open()}>
      <Portal>
        <PopoverContentBody {...props} />
      </Portal>
    </Show>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX, onCleanup, onMount, Show, splitProps } from 'solid-js';
import { useAppearance, useFocusManager } from '../../../context';
import { cn, useStyle } from '../../../helpers';
import type { AppearanceKey } from '../../../types';
import { Portal } from '../Portal';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/Popover/PopoverRoot.tsx
Tamaño: 2669 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { autoUpdate, flip, OffsetOptions, offset, Placement, shift } from '@floating-ui/dom';
import { useFloating } from 'solid-floating-ui';
import { Accessor, createContext, createMemo, createSignal, JSX, Setter, useContext } from 'solid-js';

type PopoverRootProps = {
  open?: boolean;
  children?: JSX.Element;
  fallbackPlacements?: Placement[];
  placement?: Placement;
  onOpenChange?: (isOpen: boolean) => void;
  offset?: OffsetOptions;
};

type PopoverContextValue = {
  open: Accessor<boolean>;
  reference: Accessor<HTMLElement | null>;
  floating: Accessor<HTMLElement | null>;
  setReference: Setter<HTMLElement | null>;
  setFloating: Setter<HTMLElement | null>;
  onToggle: () => void;
  onClose: () => void;
  floatingStyles: () => Record<any, any>;
};

const PopoverContext = createContext<PopoverContextValue | undefined>(undefined);

export function PopoverRoot(props: PopoverRootProps) {
  const [uncontrolledIsOpen, setUncontrolledIsOpen] = createSignal(props.open ?? false);
  const open = () => props.open ?? uncontrolledIsOpen();
  const [reference, setReference] = createSignal<HTMLElement | null>(null);
  const [floating, setFloating] = createSignal<HTMLElement | null>(null);

  const position = useFloating(reference, floating, {
    strategy: 'absolute',
    placement: props.placement,
    whileElementsMounted: autoUpdate,
    middleware: [
      offset(10),
      flip({ fallbackPlacements: props.fallbackPlacements }),
      // Configure shift to prevent layout overflow and UI shifts
      shift({
        padding: 8,
        crossAxis: false, // Prevent horizontal shifting that causes layout gaps
        mainAxis: true, // Allow vertical shifting only
      }),
    ],
  });
  const floatingStyles = createMemo(() => ({
    position: position.strategy,
    top: `${position.y ?? 0}px`,
    left: `${position.x ?? 0}px`,
  }));

  const onClose = () => {
    if (props.onOpenChange) {
      props.onOpenChange(false);
      return;
    }

    setUncontrolledIsOpen(false);
  };

  const onToggle = () => {
    if (props.onOpenChange) {
      props.onOpenChange(!props.open);
      return;
    }

    setUncontrolledIsOpen((prev) => !prev);
  };

  return (
    <PopoverContext.Provider
      value={{
        onToggle,
        onClose,
        reference,
        setReference,
        floating,
        setFloating,
        open,
        floatingStyles,
      }}
    >
      {props.children}
    </PopoverContext.Provider>
  );
}

export function usePopover() {
  const context = useContext(PopoverContext);
  if (!context) {
    throw new Error('usePopover must be used within Popover.Root component');
  }

  return context;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { autoUpdate, flip, OffsetOptions, offset, Placement, shift } from '@floating-ui/dom';
import { useFloating } from 'solid-floating-ui';
import { Accessor, createContext, createMemo, createSignal, JSX, Setter, useContext } from 'solid-js';
type PopoverRootProps = {
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/Popover/PopoverTrigger.tsx
Tamaño: 1235 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { createMemo, JSX, splitProps } from 'solid-js';
import { Dynamic } from 'solid-js/web';
import { useStyle } from '../../../helpers';
import { mergeRefs } from '../../../helpers/mergeRefs';
import type { AppearanceKey } from '../../../types';
import { usePopover } from '.';

type PopoverTriggerProps = JSX.IntrinsicElements['button'] & {
  appearanceKey?: AppearanceKey;
  asChild?: (props: any) => JSX.Element;
};
export const PopoverTrigger = (props: PopoverTriggerProps) => {
  const { setReference, onToggle } = usePopover();

  const style = useStyle();
  const [local, rest] = splitProps(props, ['appearanceKey', 'asChild', 'onClick', 'ref']);

  const handleClick = (e: MouseEvent) => {
    if (typeof local.onClick === 'function') {
      local.onClick(e as any);
    }
    onToggle();
  };

  const ref = createMemo(() => (local.ref ? mergeRefs(setReference, local.ref) : setReference));

  if (local.asChild) {
    return <Dynamic component={local.asChild} ref={ref()} onClick={handleClick} {...rest} />;
  }

  return (
    <button
      ref={ref()}
      onClick={handleClick}
      class={style({ key: local.appearanceKey || 'dropdownTrigger' })}
      {...rest}
    >
      {props.children}
    </button>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { createMemo, JSX, splitProps } from 'solid-js';
import { Dynamic } from 'solid-js/web';
import { useStyle } from '../../../helpers';
import { mergeRefs } from '../../../helpers/mergeRefs';
import type { AppearanceKey } from '../../../types';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/Popover/index.ts
Tamaño: 735 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { PopoverClose } from './PopoverClose';
import { PopoverContent } from './PopoverContent';
import { PopoverRoot } from './PopoverRoot';
import { PopoverTrigger } from './PopoverTrigger';

export { popoverContentVariants } from './PopoverContent';
export { usePopover } from './PopoverRoot';

export const Popover = {
  Root: PopoverRoot,
  /**
   * Popover.Trigger renders a `button` and has no default styling.
   */
  Trigger: PopoverTrigger,
  /**
   * Popover.Content renders a `div` and has popover specific styling.
   */
  Content: PopoverContent,
  /**
   * Popover.Close renders a `button` and has no styling.
   * Closes the popover when clicked.
   * `onClick` function is propagated.
   */
  Close: PopoverClose,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/Tabs/TabsContent.tsx
Tamaño: 1093 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX, ParentProps, Show, splitProps } from 'solid-js';
import { cn, useStyle } from '../../../helpers';
import type { AppearanceKey } from '../../../types';
import { useTabsContext } from './TabsRoot';

type TabsContentProps = JSX.IntrinsicElements['div'] &
  ParentProps & {
    class?: string;
    value: string;
    appearanceKey?: AppearanceKey;
  };

export const TabsContent = (props: TabsContentProps) => {
  const [local, rest] = splitProps(props, ['value', 'class', 'appearanceKey', 'children']);
  const style = useStyle();
  const { activeTab } = useTabsContext();

  return (
    <Show when={activeTab() === local.value}>
      <div
        class={style({
          key: local.appearanceKey || 'tabsContent',
          className: cn(local.class, activeTab() === local.value ? 'nt-block' : 'nt-hidden'),
        })}
        id={`tabpanel-${local.value}`}
        role="tabpanel"
        aria-labelledby={local.value}
        data-state={activeTab() === local.value ? 'active' : 'inactive'}
        {...rest}
      >
        {local.children}
      </div>
    </Show>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX, ParentProps, Show, splitProps } from 'solid-js';
import { cn, useStyle } from '../../../helpers';
import type { AppearanceKey } from '../../../types';
import { useTabsContext } from './TabsRoot';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/Tabs/TabsList.tsx
Tamaño: 885 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX, ParentProps, Ref, splitProps } from 'solid-js';
import { cn, useStyle } from '../../../helpers';
import type { AppearanceKey } from '../../../types';

export const tabsListVariants = () => 'nt-flex nt-gap-6';

type TabsListProps = JSX.IntrinsicElements['div'] &
  ParentProps & { class?: string; appearanceKey?: AppearanceKey; ref?: Ref<HTMLDivElement> };

export const TabsList = (props: TabsListProps) => {
  const [local, rest] = splitProps(props, ['class', 'appearanceKey', 'ref', 'children']);
  const style = useStyle();

  return (
    <>
      <div
        ref={local.ref}
        class={style({
          key: local.appearanceKey || 'tabsList',
          className: cn(tabsListVariants(), local.class),
        })}
        role="tablist"
        {...rest}
      >
        {local.children}
      </div>
      <div class="nt-relative nt-z-[-1]" />
    </>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX, ParentProps, Ref, splitProps } from 'solid-js';
import { cn, useStyle } from '../../../helpers';
import type { AppearanceKey } from '../../../types';
export const tabsListVariants = () => 'nt-flex nt-gap-6';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/Tabs/TabsRoot.tsx
Tamaño: 2106 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import {
  Accessor,
  createContext,
  createEffect,
  createSignal,
  JSX,
  ParentProps,
  Setter,
  splitProps,
  useContext,
} from 'solid-js';
import { cn, useStyle } from '../../../helpers';
import type { AppearanceKey } from '../../../types';
import { useKeyboardNavigation } from './useKeyboardNavigation';

type TabsRootProps = Omit<JSX.IntrinsicElements['div'], 'onChange'> &
  ParentProps & {
    defaultValue?: string;
    value?: string;
    class?: string;
    appearanceKey?: AppearanceKey;
    onChange?: (value: string) => void;
  };

type TabsContextValue = {
  activeTab: Accessor<string>;
  setActiveTab: Setter<string>;
  visibleTabs: Accessor<string[]>;
  setVisibleTabs: Setter<string[]>;
};

const TabsContext = createContext<TabsContextValue>(undefined);

export const useTabsContext = () => {
  const context = useContext(TabsContext);
  if (!context) {
    throw new Error('useTabsContext must be used within an TabsContext.Provider');
  }

  return context;
};

export const tabsRootVariants = () => 'nt-flex nt-flex-col';

export const TabsRoot = (props: TabsRootProps) => {
  const [local, rest] = splitProps(props, ['defaultValue', 'value', 'class', 'appearanceKey', 'onChange', 'children']);
  const [tabsContainer, setTabsContainer] = createSignal<HTMLDivElement | undefined>();
  const [visibleTabs, setVisibleTabs] = createSignal<Array<string>>([]);
  const [activeTab, setActiveTab] = createSignal(local.defaultValue ?? '');
  const style = useStyle();

  useKeyboardNavigation({ tabsContainer, activeTab, setActiveTab });

  createEffect(() => {
    if (local.value) {
      setActiveTab(local.value);
    }
  });

  createEffect(() => {
    local.onChange?.(activeTab());
  });

  return (
    <TabsContext.Provider value={{ activeTab, setActiveTab, visibleTabs, setVisibleTabs }}>
      <div
        ref={setTabsContainer}
        class={style({
          key: local.appearanceKey || 'tabsRoot',
          className: cn(tabsRootVariants(), local.class),
        })}
        {...rest}
      >
        {local.children}
      </div>
    </TabsContext.Provider>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import {
Accessor,
createContext,
createEffect,
createSignal,
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/Tabs/TabsTrigger.tsx
Tamaño: 2134 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX, ParentProps, Ref, splitProps } from 'solid-js';
import { cn, useStyle } from '../../../helpers';
import type { AppearanceKey } from '../../../types';
import { Button } from '../Button';
import { useTabsContext } from './TabsRoot';

type TabsTriggerProps = JSX.IntrinsicElements['button'] &
  ParentProps & {
    value: string;
    class?: string;
    appearanceKey?: AppearanceKey;
    ref?: Ref<HTMLButtonElement>;
    onClick?: JSX.EventHandlerUnion<HTMLButtonElement, MouseEvent>;
  };

export const tabsTriggerVariants = () =>
  cn(
    'nt-relative nt-transition nt-outline-none nt-text-foreground-alpha-600 nt-pb-[0.625rem]',
    `after:nt-absolute after:nt-content-[''] after:nt-bottom-0 after:nt-left-0 after:nt-w-full after:nt-h-[2px]`,
    'after:nt-transition-opacity after:nt-duration-200',
    'data-[state=active]:after:nt-border-b-2 data-[state=active]:after:nt-border-primary data-[state=active]:after:nt-opacity-100',
    'data-[state=active]:nt-text-foreground after:nt-border-b-transparent after:nt-opacity-0',
    'focus-visible:nt-outline-none focus-visible:nt-rounded-lg focus-visible:nt-ring-2 focus-visible:nt-ring-ring focus-visible:nt-ring-offset-2'
  );

export const TabsTrigger = (props: TabsTriggerProps) => {
  const [local, rest] = splitProps(props, ['value', 'class', 'appearanceKey', 'ref', 'onClick', 'children']);
  const style = useStyle();
  const { activeTab, setActiveTab } = useTabsContext();
  const clickHandler = () => setActiveTab(local.value);

  return (
    <Button
      variant="unstyled"
      size="none"
      ref={local.ref}
      id={local.value}
      appearanceKey={local.appearanceKey ?? 'tabsTrigger'}
      class={style({
        key: local.appearanceKey || 'tabsTrigger',
        className: cn(tabsTriggerVariants(), local.class),
      })}
      onClick={local.onClick ?? clickHandler}
      role="tab"
      tabIndex={0}
      aria-selected={activeTab() === local.value}
      aria-controls={`tabpanel-${local.value}`}
      data-state={activeTab() === local.value ? 'active' : 'inactive'}
      {...rest}
    >
      {local.children}
    </Button>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX, ParentProps, Ref, splitProps } from 'solid-js';
import { cn, useStyle } from '../../../helpers';
import type { AppearanceKey } from '../../../types';
import { Button } from '../Button';
import { useTabsContext } from './TabsRoot';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/Tabs/index.ts
Tamaño: 278 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { TabsContent } from './TabsContent';
import { TabsList } from './TabsList';
import { TabsRoot } from './TabsRoot';
import { TabsTrigger } from './TabsTrigger';

export const Tabs = {
  Root: TabsRoot,
  List: TabsList,
  Trigger: TabsTrigger,
  Content: TabsContent,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/Tabs/useKeyboardNavigation.ts
Tamaño: 2349 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Accessor, createEffect, createSignal, onCleanup, Setter } from 'solid-js';
import { useAppearance } from '../../../context';

export const useKeyboardNavigation = ({
  activeTab,
  setActiveTab,
  tabsContainer,
}: {
  activeTab: Accessor<string>;
  setActiveTab: Setter<string>;
  tabsContainer: Accessor<HTMLDivElement | undefined>;
}) => {
  const { container } = useAppearance();
  const [keyboardNavigation, setKeyboardNavigation] = createSignal(false);

  const getRoot = () => {
    const containerElement = container();

    return containerElement instanceof ShadowRoot ? containerElement : document;
  };

  createEffect(() => {
    const root = getRoot();

    const handleTabKey: EventListener = (event) => {
      if (!(event instanceof KeyboardEvent) || event.key !== 'Tab') {
        return;
      }

      const tabs = tabsContainer()?.querySelectorAll('[role="tab"]');
      if (!tabs || !root.activeElement) {
        return;
      }

      setKeyboardNavigation(Array.from(tabs).includes(root.activeElement));
    };

    root.addEventListener('keyup', handleTabKey);

    return onCleanup(() => root.removeEventListener('keyup', handleTabKey));
  });

  createEffect(() => {
    const root = getRoot();

    const handleArrowKeys: EventListener = (event) => {
      if (
        !keyboardNavigation() ||
        !(event instanceof KeyboardEvent) ||
        (event.key !== 'ArrowLeft' && event.key !== 'ArrowRight')
      ) {
        return;
      }

      const tabElements = Array.from<HTMLButtonElement>(tabsContainer()?.querySelectorAll('[role="tab"]') ?? []);
      const tabIds = tabElements.map((tab) => tab.id);
      const currentIndex = tabIds.indexOf(activeTab());
      const { length } = tabIds;
      let activeIndex = currentIndex;
      let newTab = activeTab();
      if (event.key === 'ArrowLeft') {
        activeIndex = currentIndex === 0 ? length - 1 : currentIndex - 1;
        newTab = tabIds[activeIndex];
      } else if (event.key === 'ArrowRight') {
        activeIndex = currentIndex === length - 1 ? 0 : currentIndex + 1;
        newTab = tabIds[activeIndex];
      }

      tabElements[activeIndex].focus();
      setActiveTab(newTab);
    };

    root.addEventListener('keydown', handleArrowKeys);

    return onCleanup(() => root.removeEventListener('keydown', handleArrowKeys));
  });
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - useKeyboardNavigation({
  activeTab,
  setActiveTab,
  tabsContainer,
}: {
  activeTab: Accessor<string>;
  setActiveTab: ...)
 - getRoot())
 - containerElement(container();

    return containerElement instanceof ShadowRoot ? containerElement : document;
  };
...)
 - EventListener(event))
 - role("tab"]');
      if (!tabs || !root.activeElement) {
        return;
      }

      setKeyboardNaviga...)
 - EventListener(event))
 - tabIds(tabElements.map((tab))
 - newTab(tabIds[activeIndex];
      }

      tabElements[activeIndex].focus();
      setActiveTab(newTab);
  ...)
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/Tooltip/TooltipContent.tsx
Tamaño: 2259 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX, onCleanup, onMount, Show, splitProps } from 'solid-js';
import { Portal } from 'solid-js/web';
import { useAppearance, useFocusManager } from '../../../context';
import { useStyle } from '../../../helpers';
import type { AppearanceKey } from '../../../types';
import { Root } from '../../elements';
import { Motion } from '../Motion';
import { useTooltip } from './TooltipRoot';

export const tooltipContentVariants = () =>
  'nt-bg-foreground nt-p-2 nt-shadow-tooltip nt-rounded-lg nt-text-background nt-text-xs';

type TooltipContentProps = JSX.IntrinsicElements['div'] & {
  appearanceKey?: AppearanceKey;
};

const TooltipContentBody = (props: TooltipContentProps) => {
  const { open, setFloating, floating, floatingStyles, effectiveAnimationDuration } = useTooltip();
  const { setActive, removeActive } = useFocusManager();
  const [local, rest] = splitProps(props, ['class', 'appearanceKey', 'style']);
  const style = useStyle();

  onMount(() => {
    const floatingEl = floating();
    if (floatingEl) setActive(floatingEl);

    onCleanup(() => {
      if (floatingEl) removeActive(floatingEl);
    });
  });

  return (
    <Motion.div
      initial={{ opacity: 0, scale: 0.95 }}
      animate={open() ? { opacity: 1, scale: 1 } : { opacity: 0, scale: 0.95 }}
      transition={{ duration: effectiveAnimationDuration(), easing: 'ease-in-out' }}
      ref={setFloating}
      class={
        local.class
          ? local.class
          : style({ key: local.appearanceKey || 'tooltipContent', className: tooltipContentVariants() })
      }
      style={{ ...floatingStyles(), 'z-index': 99999 }}
      {...rest}
    >
      {props.children}
    </Motion.div>
  );
};

export const TooltipContent = (props: TooltipContentProps) => {
  const { shouldRender } = useTooltip();
  const { container } = useAppearance();
  const portalContainer = () => container() ?? document.body;

  return (
    <Show when={shouldRender()}>
      {/* we can safely use portal to document.body here as this element 
      won't be focused and close other portals (outside solid world) as a result */}
      <Portal mount={portalContainer()}>
        <Root>
          <TooltipContentBody {...props} />
        </Root>
      </Portal>
    </Show>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX, onCleanup, onMount, Show, splitProps } from 'solid-js';
import { Portal } from 'solid-js/web';
import { useAppearance, useFocusManager } from '../../../context';
import { useStyle } from '../../../helpers';
import type { AppearanceKey } from '../../../types';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/Tooltip/TooltipRoot.tsx
Tamaño: 3739 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { autoUpdate, flip, offset, Placement, shift } from '@floating-ui/dom';
import { useFloating } from 'solid-floating-ui';
import { Accessor, createContext, createEffect, createMemo, createSignal, JSX, Setter, useContext } from 'solid-js';
import { useAppearance } from '../../../context';

type TooltipRootProps = {
  open?: boolean;
  children?: JSX.Element;
  placement?: Placement;
  fallbackPlacements?: Placement[];
  animationDuration?: number;
};

type TooltipContextValue = {
  open: Accessor<boolean>;
  shouldRender: Accessor<boolean>;
  setOpen: Setter<boolean>;
  reference: Accessor<HTMLElement | null>;
  floating: Accessor<HTMLElement | null>;
  setReference: Setter<HTMLElement | null>;
  setFloating: Setter<HTMLElement | null>;
  floatingStyles: () => Record<any, any>;
  effectiveAnimationDuration: Accessor<number>;
};

const TooltipContext = createContext<TooltipContextValue | undefined>(undefined);

export function TooltipRoot(props: TooltipRootProps) {
  const [reference, setReference] = createSignal<HTMLElement | null>(null);
  const [floating, setFloating] = createSignal<HTMLElement | null>(null);
  const { animations } = useAppearance();

  const defaultAnimationDuration = 0.2;
  const actualAnimationDuration = () => props.animationDuration ?? defaultAnimationDuration;
  const effectiveAnimationDuration = createMemo(() => (animations() ? actualAnimationDuration() : 0));

  const position = useFloating(reference, floating, {
    placement: props.placement || 'top',
    strategy: 'fixed',
    whileElementsMounted: autoUpdate,
    middleware: [
      offset(10),
      flip({
        fallbackPlacements: props.fallbackPlacements || ['bottom'],
      }),
      // Configure shift to prevent layout overflow and UI shifts
      shift({
        padding: 8,
        crossAxis: false, // Prevent horizontal shifting that causes layout gaps
        mainAxis: true    // Allow vertical shifting only
      }),
    ],
  });

  const [uncontrolledOpen, setUncontrolledOpen] = createSignal(props.open ?? false);

  const openAccessor: Accessor<boolean> = createMemo(() => {
    return props.open !== undefined ? !!props.open : uncontrolledOpen();
  });

  const setOpenSetter: Setter<boolean> = (valueOrFn) => {
    if (props.open === undefined) {
      setUncontrolledOpen(valueOrFn);
    }
  };

  const [shouldRenderTooltip, setShouldRenderTooltip] = createSignal(openAccessor());
  let renderTimeoutId: number | undefined;

  createEffect(() => {
    const isOpen = openAccessor();
    if (renderTimeoutId) {
      clearTimeout(renderTimeoutId);
      renderTimeoutId = undefined;
    }

    if (isOpen) {
      setShouldRenderTooltip(true);
    } else if (effectiveAnimationDuration() > 0) {
      renderTimeoutId = window.setTimeout(() => {
        setShouldRenderTooltip(false);
      }, effectiveAnimationDuration() * 1000);
    } else {
      setShouldRenderTooltip(false);
    }
  });

  createEffect(() => {
    if (openAccessor()) {
      setShouldRenderTooltip(true);
    }
  });

  return (
    <TooltipContext.Provider
      value={{
        reference,
        setReference,
        floating,
        setFloating,
        open: openAccessor,
        shouldRender: shouldRenderTooltip,
        setOpen: setOpenSetter,
        floatingStyles: () => ({
          position: position.strategy,
          top: `${position.y ?? 0}px`,
          left: `${position.x ?? 0}px`,
        }),
        effectiveAnimationDuration,
      }}
    >
      {props.children}
    </TooltipContext.Provider>
  );
}

export function useTooltip() {
  const context = useContext(TooltipContext);
  if (!context) {
    throw new Error('useTooltip must be used within Tooltip.Root component');
  }

  return context;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { autoUpdate, flip, offset, Placement, shift } from '@floating-ui/dom';
import { useFloating } from 'solid-floating-ui';
import { Accessor, createContext, createEffect, createMemo, createSignal, JSX, Setter, useContext } from 'solid-js';
import { useAppearance } from '../../../context';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/Tooltip/TooltipTrigger.tsx
Tamaño: 1687 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { createMemo, JSX, splitProps } from 'solid-js';
import { Dynamic } from 'solid-js/web';
import { useStyle } from '../../../helpers';
import { mergeRefs } from '../../../helpers/mergeRefs';
import type { AppearanceKey } from '../../../types';
import { useTooltip } from './TooltipRoot';

type PopoverTriggerProps = JSX.IntrinsicElements['button'] & {
  appearanceKey?: AppearanceKey;
  asChild?: (props: any) => JSX.Element;
};
export const TooltipTrigger = (props: PopoverTriggerProps) => {
  const { setReference, setOpen } = useTooltip();

  const style = useStyle();
  const [local, rest] = splitProps(props, [
    'appearanceKey',
    'asChild',
    'onClick',
    'onMouseEnter',
    'onMouseLeave',
    'ref',
  ]);

  const handleMouseEnter = (e: MouseEvent) => {
    if (typeof local.onMouseEnter === 'function') {
      local.onMouseEnter(e as any);
    }
    setOpen(true);
  };

  const ref = createMemo(() => (local.ref ? mergeRefs(setReference, local.ref) : setReference));

  const handleMouseLeave = (e: MouseEvent) => {
    if (typeof local.onMouseLeave === 'function') {
      local.onMouseLeave(e as any);
    }
    setOpen(false);
  };

  if (local.asChild) {
    return (
      <Dynamic
        component={local.asChild}
        ref={ref()}
        onMouseEnter={handleMouseEnter}
        onMouseLeave={handleMouseLeave}
        {...rest}
      />
    );
  }

  return (
    <button
      ref={ref()}
      onMouseEnter={() => {
        setOpen(true);
      }}
      onMouseLeave={() => {
        setOpen(false);
      }}
      class={style({ key: local.appearanceKey || 'tooltipTrigger' })}
      {...rest}
    >
      {props.children}
    </button>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { createMemo, JSX, splitProps } from 'solid-js';
import { Dynamic } from 'solid-js/web';
import { useStyle } from '../../../helpers';
import { mergeRefs } from '../../../helpers/mergeRefs';
import type { AppearanceKey } from '../../../types';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/components/primitives/Tooltip/index.ts
Tamaño: 474 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { TooltipContent } from './TooltipContent';
import { TooltipRoot } from './TooltipRoot';
import { TooltipTrigger } from './TooltipTrigger';

export { tooltipContentVariants } from './TooltipContent';

export const Tooltip = {
  Root: TooltipRoot,
  /**
   * Tooltip.Trigger renders a `button` and has no default styling.
   */
  Trigger: TooltipTrigger,
  /**
   * Tooltip.Content renders a `div` and has popover specific styling.
   */
  Content: TooltipContent,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/components/shared/IconRendererWrapper.tsx
Tamaño: 1041 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { type JSX, Show } from 'solid-js';
import { useAppearance } from '../../context';
import type { IconKey } from '../../types';
import { ExternalElementRenderer } from '../ExternalElementRenderer';

type IconRendererWrapperProps = {
  iconKey: IconKey;
  fallback: JSX.Element;
  class?: string;
};

export const IconRendererWrapper = (props: IconRendererWrapperProps) => {
  const appearance = useAppearance();
  const customRenderer = () => appearance.icons()?.[props.iconKey];

  return (
    <Show when={customRenderer()} fallback={props.fallback}>
      <ExternalElementRenderer render={(el) => customRenderer()!(el, { class: props.class })} />
    </Show>
  );
};

type IconRendererProps = {
  iconKey: IconKey;
  class?: string;
  fallback: (props?: JSX.HTMLAttributes<SVGSVGElement>) => JSX.Element;
};

export const IconRenderer = (props: IconRendererProps) => {
  return (
    <IconRendererWrapper
      iconKey={props.iconKey}
      class={props.class}
      fallback={<props.fallback class={props.class} />}
    />
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { type JSX, Show } from 'solid-js';
import { useAppearance } from '../../context';
import type { IconKey } from '../../types';
import { ExternalElementRenderer } from '../ExternalElementRenderer';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/config/appearanceKeys.ts
Tamaño: 7676 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/*
 * The double underscore signals that entire key extends the right part of the key
 * i.e. foo__bar means that foo_bar is an extension of bar. Both keys will be applied when foo_bar is used
 * meaning you would have `bar foo__bar` in the dom
 */
export const appearanceKeys = [
  // Primitives
  'button',
  'input',
  'icon',
  'badge',
  'popoverContent',
  'popoverTrigger',
  'popoverClose',

  'dropdownContent',
  'dropdownTrigger',
  'dropdownItem',
  'dropdownItemLabel',
  'dropdownItemLabelContainer',
  'dropdownItemLeft__icon',
  'dropdownItemRight__icon',
  'dropdownItem__icon',

  'collapsible',

  'tooltipContent',
  'tooltipTrigger',

  'datePicker',
  'datePickerGrid',
  'datePickerGridRow',
  'datePickerGridCell',
  'datePickerGridCellTrigger',
  'datePickerTrigger',
  'datePickerGridHeader',
  'datePickerControl',
  'datePickerControlPrevTrigger',
  'datePickerControlNextTrigger',
  'datePickerControlPrevTrigger__icon',
  'datePickerControlNextTrigger__icon',
  'datePickerCalendar',
  'datePickerHeaderMonth',
  'datePickerCalendarDay__button',

  'timePicker',
  'timePicker__hourSelect',
  'timePicker__minuteSelect',
  'timePicker__periodSelect',
  'timePicker__separator',
  'timePickerHour__input',
  'timePickerMinute__input',

  'snoozeDatePicker',
  'snoozeDatePicker__actions',
  'snoozeDatePickerCancel__button',
  'snoozeDatePickerApply__button',
  'snoozeDatePicker__timePickerContainer',
  'snoozeDatePicker__timePickerLabel',

  'back__button',

  'skeletonText',
  'skeletonAvatar',
  'skeletonSwitch',
  'skeletonSwitchThumb',

  'tabsRoot',
  'tabsList',
  'tabsContent',
  'tabsTrigger',
  'dots',

  // General
  'root',
  'bellIcon',
  'lockIcon',
  'bellContainer',
  'severityHigh__bellContainer',
  'severityMedium__bellContainer',
  'severityLow__bellContainer',
  'bellSeverityGlow',
  'severityGlowHigh__bellSeverityGlow',
  'severityGlowMedium__bellSeverityGlow',
  'severityGlowLow__bellSeverityGlow',
  'bellDot',
  'preferences__button',
  'preferencesContainer',
  'inboxHeader',
  'loading',

  // Inbox
  'inboxContent',
  'inbox__popoverTrigger',
  'inbox__popoverContent',

  // Notifications
  'notificationListContainer',
  'notificationList',
  'notificationListEmptyNoticeContainer',
  'notificationListEmptyNoticeOverlay',
  'notificationListEmptyNoticeIcon',
  'notificationListEmptyNotice',
  'notificationList__skeleton',
  'notificationList__skeletonContent',
  'notificationList__skeletonItem',
  'notificationList__skeletonAvatar',
  'notificationList__skeletonText',
  'notificationListNewNotificationsNotice__button',

  'notification',
  'severityHigh__notification',
  'severityMedium__notification',
  'severityLow__notification',
  'notificationBar',
  'severityHigh__notificationBar',
  'severityMedium__notificationBar',
  'severityLow__notificationBar',
  'notificationContent',
  'notificationTextContainer',
  'notificationDot',
  'notificationSubject',
  'notificationSubject__strong',
  'notificationBody',
  'notificationBody__strong',
  'notificationBodyContainer',
  'notificationImage',
  'notificationImageLoadingFallback',
  'notificationDate',
  'notificationDateActionsContainer',
  'notificationDefaultActions',
  'notificationCustomActions',
  'notificationPrimaryAction__button',
  'notificationSecondaryAction__button',
  'notificationRead__button',
  'notificationUnread__button',
  'notificationArchive__button',
  'notificationUnarchive__button',
  'notificationSnooze__button',
  'notificationUnsnooze__button',
  'notificationRead__icon',
  'notificationUnread__icon',
  'notificationArchive__icon',
  'notificationUnarchive__icon',
  'notificationSnooze__icon',
  'notificationUnsnooze__icon',

  // Notifications tabs
  'notificationsTabs__tabsRoot',
  'notificationsTabs__tabsList',
  'notificationsTabs__tabsContent',
  'notificationsTabs__tabsTrigger',
  'notificationsTabsTriggerLabel',
  'notificationsTabsTriggerCount',

  // Inbox status
  'inboxStatus__title',
  'inboxStatus__dropdownTrigger',
  'inboxStatus__dropdownContent',
  'inboxStatus__dropdownItem',
  'inboxStatus__dropdownItemLabel',
  'inboxStatus__dropdownItemLabelContainer',
  'inboxStatus__dropdownItemLeft__icon',
  'inboxStatus__dropdownItemRight__icon',
  'inboxStatus__dropdownItem__icon',
  'inboxStatus__dropdownItemCheck__icon',
  // More actions
  'moreActionsContainer',
  'moreActions__dropdownTrigger',
  'moreActions__dropdownContent',
  'moreActions__dropdownItem',
  'moreActions__dropdownItemLabel',
  'moreActions__dropdownItemLeft__icon',
  'moreActions__dots',

  // More tabs
  'moreTabs__button',
  'moreTabs__icon',
  'moreTabs__dropdownTrigger',
  'moreTabs__dropdownContent',
  'moreTabs__dropdownItem',
  'moreTabs__dropdownItemLabel',
  'moreTabs__dropdownItemRight__icon',

  // workflow
  'workflowContainer',
  'workflowLabel',
  'workflowLabelHeader',
  'workflowLabelHeaderContainer',
  'workflowLabelIcon',
  'workflowLabelContainer',
  'workflowContainerDisabledNotice',
  'workflowLabelDisabled__icon',
  'workflowContainerRight__icon',
  'workflowArrow__icon',
  'workflowDescription',

  // preference groups
  'preferencesGroupContainer',
  'preferencesGroupHeader',
  'preferencesGroupLabelContainer',
  'preferencesGroupLabelIcon',
  'preferencesGroupLabel',
  'preferencesGroupActionsContainer',
  'preferencesGroupActionsContainerRight__icon',
  'preferencesGroupBody',
  'preferencesGroupChannels',
  'preferencesGroupInfo',
  'preferencesGroupInfoIcon',
  'preferencesGroupWorkflows',

  // channel
  'channelContainer',
  'channelIconContainer',
  'channel__icon',
  'channelsContainerCollapsible',
  'channelsContainer',
  'channelLabel',
  'channelLabelContainer',
  'channelName',
  'channelSwitchContainer',
  'channelSwitch',
  'channelSwitchThumb',

  // Preferences Header
  'preferencesHeader',
  'preferencesHeader__back__button',
  'preferencesHeader__back__button__icon',
  'preferencesHeader__title',
  'preferencesHeader__icon',

  // Preferences Loading
  'preferencesListEmptyNoticeContainer',
  'preferencesListEmptyNotice',
  'preferencesList__skeleton',
  'preferencesList__skeletonContent',
  'preferencesList__skeletonItem',
  'preferencesList__skeletonIcon',
  'preferencesList__skeletonSwitch',
  'preferencesList__skeletonSwitchThumb',
  'preferencesList__skeletonText',

  // Schedule
  'scheduleContainer',
  'scheduleHeader',
  'scheduleLabelContainer',
  'scheduleLabelScheduleIcon',
  'scheduleLabelInfoIcon',
  'scheduleLabel',
  'scheduleActionsContainer',
  'scheduleActionsContainerRight',
  'scheduleBody',
  'scheduleDescription',
  'scheduleTable',
  'scheduleTableHeader',
  'scheduleHeaderColumn',
  'scheduleTableBody',
  'scheduleBodyRow',
  'scheduleBodyColumn',
  'scheduleInfoContainer',
  'scheduleInfoIcon',
  'scheduleInfo',

  // Day Schedule Copy
  'dayScheduleCopyTitle',
  'dayScheduleCopyIcon',
  'dayScheduleCopySelectAll',
  'dayScheduleCopyDay',
  'dayScheduleCopyFooterContainer',
  'dayScheduleCopy__dropdownTrigger',
  'dayScheduleCopy__dropdownContent',

  // Time Select
  'timeSelect__dropdownTrigger',
  'timeSelect__time',
  'timeSelect__dropdownContent',
  'timeSelect__dropdownItem',
  'timeSelect__dropdownItemLabel',
  'timeSelect__dropdownItemLabelContainer',
  'timeSelect__dropdownItemCheck__icon',

  // Notification Snooze
  'notificationSnooze__dropdownContent',
  'notificationSnooze__dropdownItem',
  'notificationSnooze__dropdownItem__icon',
  'notificationSnoozeCustomTime_popoverContent',

  // Notification Delivered At
  'notificationDeliveredAt__badge',
  'notificationDeliveredAt__icon',
  'notificationSnoozedUntil__icon',
  // Text formatting
  'strong',
] as const;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/config/defaultLocalization.ts
Tamaño: 3618 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { createSignal } from 'solid-js';

export const defaultLocalization = {
  locale: 'en-US',
  'inbox.filters.dropdownOptions.unread': 'Unread only',
  'inbox.filters.dropdownOptions.default': 'Unread & read',
  'inbox.filters.dropdownOptions.archived': 'Archived',
  'inbox.filters.dropdownOptions.snoozed': 'Snoozed',
  'inbox.filters.labels.unread': 'Unread',
  'inbox.filters.labels.default': 'Inbox',
  'inbox.filters.labels.archived': 'Archived',
  'inbox.filters.labels.snoozed': 'Snoozed',
  'notifications.emptyNotice': 'Quiet for now. Check back later.',
  'notifications.actions.readAll': 'Mark all as read',
  'notifications.actions.archiveAll': 'Archive all',
  'notifications.actions.archiveRead': 'Archive read',
  'notifications.newNotifications': ({ notificationCount }: { notificationCount: number }) =>
    `${notificationCount > 99 ? '99+' : notificationCount} new ${
      notificationCount === 1 ? 'notification' : 'notifications'
    }`,
  'notification.actions.read.tooltip': 'Mark as read',
  'notification.actions.unread.tooltip': 'Mark as unread',
  'notification.actions.archive.tooltip': 'Archive',
  'notification.actions.unarchive.tooltip': 'Unarchive',
  'notification.actions.snooze.tooltip': 'Snooze',
  'notification.actions.unsnooze.tooltip': 'Unsnooze',
  'notification.snoozedUntil': 'Snoozed until',
  'preferences.title': 'Preferences',
  'preferences.emptyNotice': 'No notification specific preferences yet.',
  'preferences.global': 'Global Preferences',
  'preferences.schedule.title': 'Schedule',
  'preferences.schedule.description': 'Allow notifications between:',
  'preferences.schedule.headerInfo':
    'Set your schedule. Notifications to external channels will pause outside the schedule. In-app and critical notifications are always delivered.',
  'preferences.schedule.info': 'Critical and In-app notifications still reach you outside your schedule.',
  'preferences.schedule.days': 'Days',
  'preferences.schedule.from': 'From',
  'preferences.schedule.to': 'To',
  'preferences.schedule.copyTimesTo': 'Copy times to',
  'preferences.schedule.sunday': 'Sunday',
  'preferences.schedule.monday': 'Monday',
  'preferences.schedule.tuesday': 'Tuesday',
  'preferences.schedule.wednesday': 'Wednesday',
  'preferences.schedule.thursday': 'Thursday',
  'preferences.schedule.friday': 'Friday',
  'preferences.schedule.saturday': 'Saturday',
  'preferences.schedule.dayScheduleCopy.title': 'Copy times to:',
  'preferences.schedule.dayScheduleCopy.selectAll': 'Select all',
  'preferences.schedule.dayScheduleCopy.apply': 'Apply',
  'preferences.workflow.disabled.notice':
    'Contact admin to enable subscription management for this critical notification.',
  'preferences.workflow.disabled.tooltip': 'Contact admin to edit',
  'preferences.group.info': 'Applies to all notifications under this group.',
  'snooze.datePicker.timePickerLabel': 'Time',
  'snooze.datePicker.apply': 'Apply',
  'snooze.datePicker.cancel': 'Cancel',
  'snooze.options.anHourFromNow': 'An hour from now',
  'snooze.datePicker.pastDateTooltip': 'Selected time must be at least 3 minutes in the future',
  'snooze.datePicker.noDateSelectedTooltip': 'Please select a date',
  'snooze.datePicker.exceedingLimitTooltip': ({ days }: { days: number }) =>
    `Selected time cannot exceed ${days === 1 ? '24 hours' : `${days} days`} from now`,
  'snooze.options.customTime': 'Custom time...',
  'snooze.options.inOneDay': 'Tomorrow',
  'snooze.options.inOneWeek': 'Next week',
} as const;

export const [dynamicLocalization, setDynamicLocalization] = createSignal<Record<string, string>>({});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - defaultLocalization({
  locale: 'en-US',
  'inbox.filters.dropdownOptions.unread': 'Unread only',
  'inbox.filters.dropd...)
Declaraciones 'export' encontradas:
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/config/defaultVariables.ts
Tamaño: 610 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { Variables } from '../types';

export const defaultVariables: Required<Variables> = {
  colorPrimary: '#7D52F4',
  colorPrimaryForeground: 'white',
  colorSecondary: '#FFFFFF',
  colorSecondaryForeground: '#646464',
  colorCounter: '#FB3748',
  colorCounterForeground: 'white',
  colorBackground: '#FCFCFC',
  colorRing: '#E1E4EA',
  colorForeground: '#1A1523',
  colorNeutral: '#525252',
  colorShadow: 'rgb(0,0,0)',
  fontSize: '1rem',
  borderRadius: '0.375rem',
  colorStripes: '#FF9A68',
  colorSeverityHigh: '#FB3748',
  colorSeverityMedium: '#FF8447',
  colorSeverityLow: 'transparent',
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/config/index.ts
Tamaño: 109 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './appearanceKeys';
export * from './defaultLocalization';
export * from './defaultVariables';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/context/AppearanceContext.tsx
Tamaño: 4389 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import {
  Accessor,
  createContext,
  createEffect,
  createMemo,
  createSignal,
  onCleanup,
  onMount,
  ParentProps,
  useContext,
} from 'solid-js';
import { createStore } from 'solid-js/store';
import { defaultVariables } from '../config';
import { NOVU_DEFAULT_CSS_ID, parseElements, parseVariables } from '../helpers';
import type { Appearance, Elements, IconOverrides, Variables } from '../types';

type AppearanceContextType = {
  variables: Accessor<Variables>;
  elements: Accessor<Elements>;
  animations: Accessor<boolean>;
  icons: Accessor<IconOverrides>;
  appearanceKeyToCssInJsClass: Record<string, string>;
  id: Accessor<string>;
  container: Accessor<Node | null | undefined>;
};

const AppearanceContext = createContext<AppearanceContextType | undefined>(undefined);

type AppearanceProviderProps = ParentProps & { appearance?: Appearance; container?: Node | null | undefined } & {
  id: string;
};

export const AppearanceProvider = (props: AppearanceProviderProps) => {
  const [store, setStore] = createStore<{
    appearanceKeyToCssInJsClass: Record<string, string>;
  }>({ appearanceKeyToCssInJsClass: {} });
  const [styleElement, setStyleElement] = createSignal<HTMLStyleElement | null>(null);
  const [elementRules, setElementRules] = createSignal<string[]>([]);
  const [variableRules, setVariableRules] = createSignal<string[]>([]);
  const themes = createMemo(() =>
    Array.isArray(props.appearance?.baseTheme) ? props.appearance?.baseTheme || [] : [props.appearance?.baseTheme || {}]
  );

  const id = () => props.id;
  const variables = () => props.appearance?.variables || {};
  const animations = () => props.appearance?.animations ?? true;
  const icons = () => props.appearance?.icons || {};
  const allElements = createMemo(() => {
    const baseElements = themes().reduce<Elements>((acc, obj) => ({ ...acc, ...(obj.elements || {}) }), {});

    return { ...baseElements, ...(props.appearance?.elements || {}) };
  });

  const container = () => props.container;

  onMount(() => {
    const root = props.container instanceof ShadowRoot ? props.container : document;
    const el = root.getElementById(props.id);
    if (el) {
      setStyleElement(el as HTMLStyleElement);

      return;
    }

    const stylesContainer = props.container ?? document.head;
    const styleEl = document.createElement('style');
    styleEl.id = props.id;

    const defaultCssStyles = root.getElementById(NOVU_DEFAULT_CSS_ID);
    if (defaultCssStyles) {
      stylesContainer.insertBefore(styleEl, defaultCssStyles.nextSibling);
    } else {
      stylesContainer.appendChild(styleEl);
    }

    setStyleElement(styleEl);

    onCleanup(() => {
      styleEl.remove();
    });
  });

  // handle variables
  createEffect(() => {
    const styleEl = styleElement();

    if (!styleEl) {
      return;
    }

    const baseVariables = {
      ...defaultVariables,
      ...themes().reduce<Variables>((acc, obj) => ({ ...acc, ...(obj.variables || {}) }), {}),
    };

    setVariableRules(
      parseVariables({ ...baseVariables, ...(props.appearance?.variables || ({} as Variables)) }, props.id)
    );
  });

  // handle elements
  createEffect(() => {
    const styleEl = styleElement();

    if (!styleEl) {
      return;
    }

    const elementsStyleData = parseElements(allElements());
    setStore('appearanceKeyToCssInJsClass', (obj) => ({
      ...obj,
      ...elementsStyleData.reduce<Record<string, string>>((acc, item) => {
        acc[item.key] = item.className;

        return acc;
      }, {}),
    }));
    setElementRules(elementsStyleData.map((el) => el.rule));
  });

  // add rules to style element
  createEffect(() => {
    const styleEl = styleElement();
    if (!styleEl) {
      return;
    }

    styleEl.innerHTML = [...variableRules(), ...elementRules()].join(' ');
  });

  return (
    <AppearanceContext.Provider
      value={{
        elements: allElements,
        variables,
        animations,
        icons,
        appearanceKeyToCssInJsClass: store.appearanceKeyToCssInJsClass, // stores are reactive
        id,
        container,
      }}
    >
      {props.children}
    </AppearanceContext.Provider>
  );
};

export function useAppearance() {
  const context = useContext(AppearanceContext);
  if (!context) {
    throw new Error('useAppearance must be used within an AppearanceProvider');
  }

  return context;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import {
Accessor,
createContext,
createEffect,
createMemo,
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/context/CountContext.tsx
Tamaño: 8886 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Accessor, createContext, createMemo, createSignal, onMount, ParentProps, useContext } from 'solid-js';
import { Notification, NotificationFilter, SeverityLevelEnum } from '../../types';
import { checkNotificationDataFilter, checkNotificationTagFilter } from '../../utils/notification-utils';
import { getTagsFromTab } from '../helpers';
import { useNovuEvent } from '../helpers/useNovuEvent';
import { useWebSocketEvent } from '../helpers/useWebSocketEvent';
import { useInboxContext } from './InboxContext';
import { useNovu } from './NovuContext';

const MIN_AMOUNT_OF_NOTIFICATIONS = 1;

type CountContextValue = {
  unreadCount: Accessor<{ total: number; severity: Record<string, number> }>;
  unreadCounts: Accessor<Map<string, number>>;
  newNotificationCounts: Accessor<Map<string, number>>;
  resetNewNotificationCounts: (key: string) => void;
};

const CountContext = createContext<CountContextValue>(undefined);

export const CountProvider = (props: ParentProps) => {
  const novu = useNovu();
  const { isOpened, tabs, filter, limit, activeTab } = useInboxContext();
  const [unreadCount, setUnreadCount] = createSignal<{ total: number; severity: Record<string, number> }>({
    total: 0,
    severity: {
      [SeverityLevelEnum.HIGH]: 0,
      [SeverityLevelEnum.MEDIUM]: 0,
      [SeverityLevelEnum.LOW]: 0,
      [SeverityLevelEnum.NONE]: 0,
    },
  });
  const [unreadCounts, setUnreadCounts] = createSignal(new Map<string, number>());
  const [newNotificationCounts, setNewNotificationCounts] = createSignal(new Map<string, number>());

  const updateTabCounts = async () => {
    if (tabs().length === 0) {
      return;
    }
    const filters = tabs().map((tab) => ({
      tags: getTagsFromTab(tab),
      read: false,
      archived: false,
      snoozed: false,
      data: tab.filter?.data,
      severity: tab.filter?.severity,
    }));
    const { data } = await novu.notifications.count({ filters });
    if (!data) {
      return;
    }

    const newMap = new Map();
    const { counts } = data;
    for (let i = 0; i < counts.length; i += 1) {
      const tagsKey = createKey({
        tags: counts[i].filter.tags,
        data: counts[i].filter.data,
        severity: counts[i].filter.severity,
      });
      newMap.set(tagsKey, data?.counts[i].count);
    }

    setUnreadCounts(newMap);
  };

  onMount(() => {
    updateTabCounts();
  });

  useWebSocketEvent({
    event: 'notifications.unread_count_changed',
    eventHandler: (data) => {
      setUnreadCount(data.result);
      updateTabCounts();
    },
  });

  useNovuEvent({
    event: 'session.initialize.resolved',
    eventHandler: ({ data }) => {
      if (!data) {
        return;
      }

      setUnreadCount(data.unreadCount);
    },
  });

  const updateNewNotificationCountsOrCache = (
    tabLabel: string,
    notification: Notification,
    tags: NotificationFilter['tags'],
    data?: NotificationFilter['data'],
    severity?: NotificationFilter['severity']
  ) => {
    const notificationsCache = novu.notifications.cache;
    const limitValue = limit();
    // Use the global filter() as a base and override with specific tab's tags and data for cache operations
    const tabSpecificFilterForCache = { ...filter(), tags, data, severity, after: undefined, limit: limitValue };

    const hasEmptyCache = !notificationsCache.has(tabSpecificFilterForCache);
    if (hasEmptyCache && (!isOpened() || activeTab() !== tabLabel)) {
      return;
    }

    const cachedData = notificationsCache.getAll(tabSpecificFilterForCache) || {
      hasMore: false,
      filter: tabSpecificFilterForCache,
      notifications: [],
    };
    const hasLessThenMinAmount = (cachedData?.notifications.length || 0) < MIN_AMOUNT_OF_NOTIFICATIONS;

    // Auto-load notifications when:
    // 1. Cache is nearly empty
    // 2. OR inbox is closed (will be auto-loaded when opened)
    if (hasLessThenMinAmount || !isOpened()) {
      notificationsCache.update(tabSpecificFilterForCache, {
        ...cachedData,
        notifications: [notification, ...cachedData.notifications],
      });

      return;
    }

    // Only show banner when inbox is already open and new notification is received
    setNewNotificationCounts((oldMap) => {
      const key = createKey({ tags, data, severity }); // Use specific tab's tags and data for the key

      const newMap = new Map(oldMap);
      newMap.set(key, (oldMap.get(key) || 0) + 1);

      return newMap;
    });
  };

  useWebSocketEvent({
    event: 'notifications.notification_received',
    eventHandler: async ({ result: notification }) => {
      if (filter().archived || filter().snoozed) {
        return;
      }

      const currentTabs = tabs();
      const processedFilters = new Set<string>();

      if (currentTabs.length > 0) {
        for (const tab of currentTabs) {
          const tabTags = getTagsFromTab(tab);
          const tabDataFilterCriteria = tab.filter?.data;
          const tabSeverityFilterCriteria = tab.filter?.severity;

          const matchesTagFilter = checkNotificationTagFilter(notification.tags, tabTags);
          const matchesDataFilterCriteria = checkNotificationDataFilter(notification.data, tabDataFilterCriteria);

          const matchesSeverityFilterCriteria =
            !tabSeverityFilterCriteria ||
            (Array.isArray(tabSeverityFilterCriteria) && tabSeverityFilterCriteria.length === 0) ||
            (Array.isArray(tabSeverityFilterCriteria) && tabSeverityFilterCriteria.includes(notification.severity)) ||
            (!Array.isArray(tabSeverityFilterCriteria) && tabSeverityFilterCriteria === notification.severity);

          if (matchesTagFilter && matchesDataFilterCriteria && matchesSeverityFilterCriteria) {
            const filterKey = createKey({
              tags: tabTags,
              data: tabDataFilterCriteria,
              severity: tabSeverityFilterCriteria,
            });

            if (!processedFilters.has(filterKey)) {
              processedFilters.add(filterKey);
            updateNewNotificationCountsOrCache(
              tab.label,
              notification,
              tabTags,
              tabDataFilterCriteria,
              tabSeverityFilterCriteria
            );
            }
          }
        }
      } else {
        // No tabs are defined. Apply to default (no tags, no data) filter.
        updateNewNotificationCountsOrCache('', notification, [], undefined, undefined);
      }
    },
  });

  useWebSocketEvent({
    event: 'notifications.notification_received',
    eventHandler: updateTabCounts,
  });

  const resetNewNotificationCounts = (key: string) => {
    setNewNotificationCounts((oldMap) => {
      const newMap = new Map(oldMap);
      newMap.set(key, 0);

      return newMap;
    });
  };

  return (
    <CountContext.Provider value={{ unreadCount, unreadCounts, newNotificationCounts, resetNewNotificationCounts }}>
      {props.children}
    </CountContext.Provider>
  );
};

const createKey = (filter: Pick<NotificationFilter, 'tags' | 'data' | 'severity'>) => {
  return JSON.stringify({ tags: filter.tags ?? [], data: filter.data ?? {}, severity: filter.severity });
};

export const useUnreadCount = () => {
  const context = useContext(CountContext);
  if (!context) {
    throw new Error('useUnreadCount must be used within a CountProvider');
  }

  return { unreadCount: context.unreadCount };
};

type UseNewMessagesCountProps = {
  filter: Pick<NotificationFilter, 'tags' | 'data' | 'severity'>;
};

export const useNewMessagesCount = (props: UseNewMessagesCountProps) => {
  const context = useContext(CountContext);
  if (!context) {
    throw new Error('useNewMessagesCount must be used within a CountProvider');
  }

  const key = createMemo(() => createKey(props.filter));
  const count = createMemo(() => context.newNotificationCounts().get(key()) || 0);
  const reset = () => context.resetNewNotificationCounts(key());

  return { count, reset };
};

type UseFilteredUnreadCountProps = {
  filter: Pick<NotificationFilter, 'tags' | 'data' | 'severity'>;
};
export const useFilteredUnreadCount = (props: UseFilteredUnreadCountProps) => {
  const context = useContext(CountContext);
  if (!context) {
    throw new Error('useFilteredUnreadCount must be used within a CountProvider');
  }

  const count = createMemo(() => context.unreadCounts().get(createKey(props.filter)) || 0);

  return count;
};

type UseUnreadCountsProps = {
  filters: Pick<NotificationFilter, 'tags' | 'data' | 'severity'>[];
};
export const useUnreadCounts = (props: UseUnreadCountsProps) => {
  const context = useContext(CountContext);
  if (!context) {
    throw new Error('useUnreadCounts must be used within a CountProvider');
  }

  const counts = createMemo(() =>
    props.filters.map((filter) => {
      return context.unreadCounts().get(createKey(filter)) || 0;
    })
  );

  return counts;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Accessor, createContext, createMemo, createSignal, onMount, ParentProps, useContext } from 'solid-js';
import { Notification, NotificationFilter, SeverityLevelEnum } from '../../types';
import { checkNotificationDataFilter, checkNotificationTagFilter } from '../../utils/notification-utils';
import { getTagsFromTab } from '../helpers';
import { useNovuEvent } from '../helpers/useNovuEvent';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/context/FocusManagerContext.tsx
Tamaño: 1492 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { createContext, createMemo, createSignal, ParentProps, useContext } from 'solid-js';
import createFocusTrap from '../helpers/useFocusTrap';

type FocusManagerContextType = {
  active: () => HTMLElement | null;
  setActive: (element: HTMLElement) => void;
  removeActive: (element: HTMLElement) => void;
  focusTraps: () => HTMLElement[];
};

const FocusManagerContext = createContext<FocusManagerContextType | undefined>(undefined);

type FocusManagerProviderProps = ParentProps;

export const FocusManagerProvider = (props: FocusManagerProviderProps) => {
  const [focusTraps, setFocusTraps] = createSignal<HTMLElement[]>([]);

  const setActive = (element: HTMLElement) => {
    setFocusTraps((traps) => [...traps, element]);
  };

  const removeActive = (element: HTMLElement) => {
    setFocusTraps((traps) => traps.filter((item) => item !== element));
  };

  const active = createMemo(() => (focusTraps().length ? focusTraps()[focusTraps().length - 1] : null));

  createFocusTrap({
    element: () => active(),
    enabled: () => true,
  });

  return (
    <FocusManagerContext.Provider
      value={{
        focusTraps,
        active,
        setActive,
        removeActive,
      }}
    >
      {props.children}
    </FocusManagerContext.Provider>
  );
};

export function useFocusManager() {
  const context = useContext(FocusManagerContext);
  if (!context) {
    throw new Error('useFocusManager must be used within an FocusManagerProvider');
  }

  return context;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { createContext, createMemo, createSignal, ParentProps, useContext } from 'solid-js';
import createFocusTrap from '../helpers/useFocusTrap';
type FocusManagerContextType = {
active: () => HTMLElement | null;
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/context/InboxContext.tsx
Tamaño: 6755 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import {
  Accessor,
  createContext,
  createEffect,
  createMemo,
  createSignal,
  ParentProps,
  Setter,
  useContext,
} from 'solid-js';
import { NotificationFilter, Redirect } from '../../types';
import { DEFAULT_REFERRER, DEFAULT_TARGET, getTagsFromTab } from '../helpers';
import { useNovuEvent } from '../helpers/useNovuEvent';
import { NotificationStatus, PreferenceGroups, PreferencesFilter, PreferencesSort, RouterPush, Tab } from '../types';

type InboxContextType = {
  setStatus: (status: NotificationStatus) => void;
  status: Accessor<NotificationStatus>;
  filter: Accessor<NotificationFilter>;
  limit: Accessor<number>;
  setLimit: (tab: number) => void;
  tabs: Accessor<Array<Tab>>;
  preferencesFilter: Accessor<PreferencesFilter | undefined>;
  preferenceGroups: Accessor<PreferenceGroups | undefined>;
  preferencesSort: Accessor<PreferencesSort | undefined>;
  activeTab: Accessor<string>;
  setActiveTab: (tab: string) => void;
  isOpened: Accessor<boolean>;
  setIsOpened: Setter<boolean>;
  navigate: (url?: string, target?: Redirect['target']) => void;
  hideBranding: Accessor<boolean>;
  isDevelopmentMode: Accessor<boolean>;
  maxSnoozeDurationHours: Accessor<number>;
  isSnoozeEnabled: Accessor<boolean>;
  isKeyless: Accessor<boolean>;
  applicationIdentifier: Accessor<string | null>;
  contextKeys: Accessor<string[] | undefined>;
};

const InboxContext = createContext<InboxContextType | undefined>(undefined);

const STATUS_TO_FILTER: Record<NotificationStatus, NotificationFilter> = {
  [NotificationStatus.UNREAD_READ]: { archived: false, snoozed: false },
  [NotificationStatus.UNREAD]: { read: false, snoozed: false },
  [NotificationStatus.ARCHIVED]: { archived: true },
  [NotificationStatus.SNOOZED]: { snoozed: true },
};

export const DEFAULT_LIMIT = 10;

type InboxProviderProps = ParentProps<{
  tabs: Array<Tab>;
  preferencesFilter?: PreferencesFilter;
  preferenceGroups?: PreferenceGroups;
  preferencesSort?: PreferencesSort;
  routerPush?: RouterPush;
  applicationIdentifier?: string;
}>;

export const InboxProvider = (props: InboxProviderProps) => {
  const [isOpened, setIsOpened] = createSignal<boolean>(false);
  const [tabs, setTabs] = createSignal<Array<Tab>>(props.tabs);
  const [activeTab, setActiveTab] = createSignal<string>(props.tabs[0]?.label ?? '');
  const [status, setStatus] = createSignal<NotificationStatus>(NotificationStatus.UNREAD_READ);
  const [limit, setLimit] = createSignal<number>(DEFAULT_LIMIT);
  const [filter, setFilter] = createSignal<NotificationFilter>({
    ...STATUS_TO_FILTER[NotificationStatus.UNREAD_READ],
    tags: props.tabs.length > 0 ? getTagsFromTab(props.tabs[0]) : [],
    data: props.tabs.length > 0 ? props.tabs[0].filter?.data : {},
    severity: props.tabs.length > 0 ? props.tabs[0].filter?.severity : undefined,
  });
  const [hideBranding, setHideBranding] = createSignal(false);
  const [isDevelopmentMode, setIsDevelopmentMode] = createSignal(false);
  const [maxSnoozeDurationHours, setMaxSnoozeDurationHours] = createSignal(0);
  const isSnoozeEnabled = createMemo(() => maxSnoozeDurationHours() > 0);
  const [preferencesFilter, setPreferencesFilter] = createSignal<PreferencesFilter | undefined>(
    props.preferencesFilter
  );
  const [isKeyless, setIsKeyless] = createSignal(false);
  const [applicationIdentifier, setApplicationIdentifier] = createSignal<string | null>(null);
  const [contextKeys, setContextKeys] = createSignal<string[] | undefined>(undefined);
  const [preferenceGroups, setPreferenceGroups] = createSignal<PreferenceGroups | undefined>(props.preferenceGroups);
  const [preferencesSort, setPreferencesSort] = createSignal<PreferencesSort | undefined>(props.preferencesSort);

  const setNewStatus = (newStatus: NotificationStatus) => {
    setStatus(newStatus);
    setFilter((old) => ({ ...STATUS_TO_FILTER[newStatus], tags: old.tags, data: old.data, severity: old.severity }));
  };

  const setNewActiveTab = (newActiveTab: string) => {
    const tab = tabs().find((tab) => tab.label === newActiveTab);
    const tags = getTagsFromTab(tab);
    if (!tags) {
      return;
    }

    setActiveTab(newActiveTab);
    setFilter((old) => ({ ...old, tags, data: tab?.filter?.data, severity: tab?.filter?.severity }));
  };

  const navigate = (url?: string, target?: Redirect['target']) => {
    if (!url) {
      return;
    }

    const isAbsoluteUrl = !url.startsWith('/');
    if (isAbsoluteUrl) {
      window.open(url, target ?? DEFAULT_TARGET, DEFAULT_REFERRER);

      return;
    }

    if (props.routerPush) {
      props.routerPush(url);

      return;
    }

    const fullUrl = new URL(url, window.location.href);
    const pushState = window.history.pushState.bind(window.history);
    pushState({}, '', fullUrl);
  };

  createEffect(() => {
    setTabs(props.tabs);
    const firstTab = props.tabs[0];
    const tags = getTagsFromTab(firstTab);
    setActiveTab(firstTab?.label ?? '');
    setFilter((old) => ({ ...old, tags, data: firstTab?.filter?.data, severity: firstTab?.filter?.severity }));

    setPreferencesFilter(props.preferencesFilter);
    setPreferenceGroups(props.preferenceGroups);
  });

  useNovuEvent({
    event: 'session.initialize.resolved',
    eventHandler: ({ data }) => {
      if (!data) {
        return;
      }
      const identifier = window.localStorage.getItem('novu_keyless_application_identifier');

      setHideBranding(data.removeNovuBranding);
      setIsDevelopmentMode(data.isDevelopmentMode);
      setMaxSnoozeDurationHours(data.maxSnoozeDurationHours);
      setContextKeys(data.contextKeys);

      if (data.isDevelopmentMode && !props.applicationIdentifier) {
        setIsKeyless(!data.applicationIdentifier || !!identifier?.startsWith('pk_keyless_'));
        setApplicationIdentifier(data.applicationIdentifier ?? null);
      } else {
        setApplicationIdentifier(props.applicationIdentifier ?? null);
      }
    },
  });

  return (
    <InboxContext.Provider
      value={{
        status,
        setStatus: setNewStatus,
        filter,
        tabs,
        activeTab,
        setActiveTab: setNewActiveTab,
        limit,
        setLimit,
        isOpened,
        setIsOpened,
        navigate,
        hideBranding,
        preferencesFilter,
        preferenceGroups,
        preferencesSort,
        isDevelopmentMode,
        maxSnoozeDurationHours,
        isSnoozeEnabled,
        isKeyless,
        applicationIdentifier,
        contextKeys,
      }}
    >
      {props.children}
    </InboxContext.Provider>
  );
};

export const useInboxContext = () => {
  const context = useContext(InboxContext);

  if (!context) {
    throw new Error('useInboxContext must be used within a InboxProvider');
  }

  return context;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import {
Accessor,
createContext,
createEffect,
createMemo,
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/context/LocalizationContext.tsx
Tamaño: 2479 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { Accessor, createContext, createMemo, ParentProps, useContext } from 'solid-js';
import { defaultLocalization, dynamicLocalization } from '../config/defaultLocalization';

export type LocalizationKey = keyof typeof defaultLocalization;

export type StringLocalizationKey = {
  [K in LocalizationKey]: (typeof defaultLocalization)[K] extends string ? K : never;
}[LocalizationKey];

export type Localization = {
  [K in LocalizationKey]?: (typeof defaultLocalization)[K] extends (...args: infer P) => any
    ? ((...args: P) => ReturnType<(typeof defaultLocalization)[K]>) | string
    : string;
} & {
  dynamic?: Record<string, string>;
};

export type TranslateFunctionArg<K extends LocalizationKey> = K extends keyof typeof defaultLocalization
  ? (typeof defaultLocalization)[K] extends (arg: infer A) => any
    ? A
    : undefined
  : undefined;

export type TranslateFunction = <K extends LocalizationKey>(
  key: K,
  ...args: TranslateFunctionArg<K> extends undefined
    ? [undefined?] // No arguments needed if TranslateFunctionArg<K> is undefined
    : [TranslateFunctionArg<K>] // A single argument is required if TranslateFunctionArg<K> is defined
) => string;

type LocalizationContextType = {
  t: TranslateFunction;
  locale: Accessor<string>;
};

const LocalizationContext = createContext<LocalizationContextType | undefined>(undefined);

type LocalizationProviderProps = ParentProps & { localization?: Localization };

export const LocalizationProvider = (props: LocalizationProviderProps) => {
  const localization = createMemo<Record<string, string | Function>>(() => {
    const { dynamic, ...localizationObject } = props.localization || {};

    return {
      ...defaultLocalization,
      ...dynamicLocalization(),
      ...(dynamic || {}),
      ...localizationObject,
    };
  });

  const t: LocalizationContextType['t'] = (key, ...args) => {
    const value = localization()[key];
    if (typeof value === 'function') {
      return value(args[0]);
    }

    return value as string;
  };

  const locale = createMemo(() => localization().locale as string);

  return (
    <LocalizationContext.Provider
      value={{
        t,
        locale,
      }}
    >
      {props.children}
    </LocalizationContext.Provider>
  );
};

export function useLocalization() {
  const context = useContext(LocalizationContext);
  if (!context) {
    throw new Error('useLocalization must be used within an LocalizationProvider');
  }

  return context;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { Accessor, createContext, createMemo, ParentProps, useContext } from 'solid-js';
import { defaultLocalization, dynamicLocalization } from '../config/defaultLocalization';
export type LocalizationKey = keyof typeof defaultLocalization;
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/context/NovuContext.tsx
Tamaño: 716 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { createContext, createMemo, JSX, useContext } from 'solid-js';
import { Novu } from '../../novu';
import type { NovuOptions } from '../../types';

type NovuProviderProps = {
  options: NovuOptions;
  children: JSX.Element;
  novu?: Novu;
};

const NovuContext = createContext<Novu | undefined>(undefined);

export function NovuProvider(props: NovuProviderProps) {
  const novu = createMemo(() => props.novu || new Novu(props.options));

  return <NovuContext.Provider value={novu()}>{props.children}</NovuContext.Provider>;
}

export function useNovu() {
  const context = useContext(NovuContext);
  if (!context) {
    throw new Error('useNovu must be used within a NovuProvider');
  }

  return context;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { createContext, createMemo, JSX, useContext } from 'solid-js';
import { Novu } from '../../novu';
import type { NovuOptions } from '../../types';
type NovuProviderProps = {
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/context/index.ts
Tamaño: 210 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './AppearanceContext';
export * from './CountContext';
export * from './FocusManagerContext';
export * from './InboxContext';
export * from './LocalizationContext';
export * from './NovuContext';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/helpers/browser.ts
Tamaño: 398 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export function requestLock(id: string, cb: (id: string) => void) {
  let isFulfilled = false;
  let promiseResolve: () => void;

  const promise = new Promise<void>((resolve) => {
    promiseResolve = resolve;
  });

  navigator.locks.request(id, () => {
    if (!isFulfilled) {
      cb(id);
    }

    return promise;
  });

  return () => {
    isFulfilled = true;
    promiseResolve();
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - requestLock(id: string, cb: (id: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - isFulfilled(false;
  let promiseResolve: ())
 - promise(new Promise<void>((resolve))
 - promiseResolve(resolve;
  });

  navigator.locks.request(id, ())
Declaraciones 'export' encontradas:
- export function requestLock

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/helpers/constants.ts
Tamaño: 224 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export const NV_INBOX_TABS_CHANNEL = 'nv-inbox-tabs-channel';
export const NV_INBOX_WEBSOCKET_LOCK = 'nv-inbox-websocket-lock';

export const DEFAULT_TARGET = '_blank';
export const DEFAULT_REFERRER = 'noopener noreferrer';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  const
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/helpers/createDelayedLoading.ts
Tamaño: 880 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Accessor, createEffect, createMemo, createSignal, onCleanup, Setter } from 'solid-js';

export function createDelayedLoading(initialValue: boolean, delayInMs: number): [Accessor<boolean>, Setter<boolean>] {
  const [debouncedValue, setDebouncedValue] = createSignal(initialValue);
  const [valueGiven, setValueGiven] = createSignal(initialValue);
  const [initialDelayHasPassed, setInitialDelayHasPassed] = createSignal(false);

  const timeout = setTimeout(() => {
    setInitialDelayHasPassed(true);
  }, delayInMs);

  onCleanup(() => {
    clearTimeout(timeout);
  });

  createEffect(() => {
    if (initialDelayHasPassed()) {
      setDebouncedValue(valueGiven());
    }
  });

  const setValue = createMemo(() => {
    if (!initialDelayHasPassed()) {
      return setValueGiven;
    }

    return setDebouncedValue;
  });

  return [debouncedValue, setValue()];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - createDelayedLoading(initialValue: boolean, delayInMs: number)
Asignaciones con arrow functions encontradas (posibles funciones):
 - timeout(setTimeout(())
 - setValue(createMemo(())
Declaraciones 'export' encontradas:
- export function createDelayedLoading

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/helpers/createInfiniteScroll.ts
Tamaño: 3437 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Accessor, batch, createEffect, createResource, createSignal, onCleanup, onMount, Setter } from 'solid-js';

export function createInfiniteScroll<T>(
  fetcher: (after: string | undefined) => Promise<{ data: T[]; hasMore: boolean }>,
  options: {
    paginationField: string;
  }
): [
  data: Accessor<T[]>,
  options: {
    initialLoading: Accessor<boolean>;
    setEl: (el: Element) => void;
    after: Accessor<string | undefined>;
    end: Accessor<boolean>;
    reset: () => Promise<void>;
    mutate: Setter<
      | {
          data: T[];
          hasMore: boolean;
        }
      | undefined
    >;
  },
] {
  const [data, setData] = createSignal<T[]>([]);
  const [initialLoading, setInitialLoading] = createSignal(true);
  const [after, setAfter] = createSignal<string | undefined>(undefined);
  const [end, setEnd] = createSignal(false);
  const [contents, { mutate, refetch }] = createResource(
    () => ({ trigger: true, after: after() }),
    (params) => fetcher(params.after)
  );

  let observedElement: Element | null = null;
  let io: IntersectionObserver | null = null;

  onMount(() => {
    io = new IntersectionObserver(
      (entries) => {
        const entry = entries[0];
        if (entry && entry.isIntersecting && !end() && !contents.loading) {
          const data = contents.latest?.data;
          if (data) {
            // @ts-ignore
            setAfter(data[data.length - 1][options.paginationField]);
          }
        }
      },
      {
        threshold: 0.1,
      }
    );

    if (observedElement && io) {
      io.observe(observedElement);
    }

    onCleanup(() => {
      io?.disconnect();
      io = null;
    });
  });

  createEffect(() => {
    if (contents.loading) return;

    const content = contents.latest;
    if (!content) return;

    setInitialLoading(false);
    batch(() => {
      if (!content.hasMore) setEnd(true);
      setData(content.data);

      /*
       ** Wait for DOM to update before checking visibility
       ** Use requestAnimationFrame to ensure we're after the next paint
       */
      requestAnimationFrame(() => {
        checkVisibilityAndLoadMore();
      });
    });
  });

  const checkVisibilityAndLoadMore = () => {
    if (observedElement && !end() && !contents.loading) {
      const observer = new IntersectionObserver(
        (entries) => {
          const entry = entries[0];

          if (entry.isIntersecting) {
            const data = contents.latest?.data;
            if (data) {
              // @ts-ignore
              setAfter(data[data.length - 1][options.paginationField]);
            }
          }

          observer.disconnect();
        },
        {
          threshold: [0.1],
        }
      );

      observer.observe(observedElement);

      onCleanup(() => {
        observer.disconnect();
      });
    }
  };

  const setEl = (el: Element) => {
    if (io && observedElement) {
      io.unobserve(observedElement);
    }

    observedElement = el;

    if (io && el) {
      io.observe(el);
    }

    onCleanup(() => {
      if (io && el) io.unobserve(el);
    });
  };

  const reset = async () => {
    setData([]);
    setInitialLoading(true);
    setEnd(false);

    if (after() !== undefined) {
      setAfter(undefined);
    } else {
      await refetch();
    }
  };

  return [
    data,
    {
      initialLoading,
      setEl,
      after,
      end,
      mutate,
      reset,
    },
  ];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - null(null;

  onMount(())
 - io(new IntersectionObserver(
      (entries))
 - data(contents.latest?.data;
          if (data) {
            // @ts-ignore
            setAfter(data[dat...)
 - io(null;
    });
  });

  createEffect(())
 - content(contents.latest;
    if (!content) return;

    setInitialLoading(false);
    batch(())
 - checkVisibilityAndLoadMore())
 - observer(new IntersectionObserver(
        (entries))
 - data(contents.latest?.data;
            if (data) {
              // @ts-ignore
              setAfter(da...)
 - setEl(el: Element))
 - observedElement(el;

    if (io && el) {
      io.observe(el);
    }

    onCleanup(())
 - reset(async ())
Declaraciones 'export' encontradas:
- export function createInfiniteScroll

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/helpers/formatToRelativeTime.ts
Tamaño: 3275 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

const DEFAULT_LOCALE = 'en-US';

const SECONDS = {
  inMinute: 60,
  inHour: 3600,
  inDay: 86_400,
  inWeek: 604_800,
  inMonth: 2_592_000,
};

export function formatToRelativeTime({
  fromDate,
  locale = DEFAULT_LOCALE,
  toDate = new Date(),
}: {
  fromDate: Date;
  locale?: string;
  toDate?: Date;
}) {
  // time elapsed in milliseconds between the two dates
  const elapsed = toDate.getTime() - fromDate.getTime();

  const formatter = new Intl.RelativeTimeFormat(locale, { style: 'narrow' });

  const diffInSeconds = Math.floor(elapsed / 1000);

  // If the difference is less than a minute, return 'Just now'
  if (Math.abs(diffInSeconds) < SECONDS.inMinute) {
    return 'Just now';
  }
  // If the difference is less than an hour, return the difference in minutes. i.e 3 minutes ago
  else if (Math.abs(diffInSeconds) < SECONDS.inHour) {
    return formatter.format(Math.floor(-diffInSeconds / SECONDS.inMinute), 'minute');
  }
  // If the difference is less than a day, return the difference in hours. i.e 3 hours ago
  else if (Math.abs(diffInSeconds) < SECONDS.inDay) {
    return formatter.format(Math.floor(-diffInSeconds / SECONDS.inHour), 'hour');
  }
  // If the difference is less than a month, return the difference in days. i.e 3 days ago
  else if (Math.abs(diffInSeconds) < SECONDS.inMonth) {
    return formatter.format(Math.floor(-diffInSeconds / SECONDS.inDay), 'day');
  }
  // Otherwise, return the date formatted with month and day. i.e Dec 3
  else {
    return new Intl.DateTimeFormat(locale, { month: 'short', day: 'numeric' }).format(fromDate);
  }
}

/**
 * Formats a future date to indicate when a snoozed notification will appear.
 * Returns formats that pair well with "Snoozed until" label, like "2 hours" or "Mar 5"
 */
export function formatSnoozedUntil({ untilDate, locale = DEFAULT_LOCALE }: { untilDate: Date; locale?: string }) {
  // time remaining in milliseconds between the two dates
  const remaining = untilDate.getTime() - new Date().getTime();

  const diffInSeconds = Math.floor(remaining / 1000);

  /*
   * Handle past dates - this covers edge cases when socket failures or delays
   * cause notifications to appear in snoozed state after their snooze time
   * should be rare, but it can potentially happen
   */
  if (diffInSeconds < 0) {
    return 'soon';
  }

  // If returning in less than a minute
  if (diffInSeconds < SECONDS.inMinute) {
    return 'a moment';
  }
  // If returning in less than an hour, return minutes
  else if (diffInSeconds < SECONDS.inHour) {
    const minutes = Math.floor(diffInSeconds / SECONDS.inMinute);

    return `${minutes} ${minutes === 1 ? 'minute' : 'minutes'}`;
  }
  // If returning in less than a day, return hours
  else if (diffInSeconds < SECONDS.inDay) {
    const hours = Math.floor(diffInSeconds / SECONDS.inHour);

    return `${hours} ${hours === 1 ? 'hour' : 'hours'}`;
  }
  // If returning in less than a week, return days
  else if (diffInSeconds < SECONDS.inWeek) {
    const days = Math.floor(diffInSeconds / SECONDS.inDay);

    return `${days} ${days === 1 ? 'day' : 'days'}`;
  }
  // Otherwise, return the date formatted with month and day
  else {
    return new Intl.DateTimeFormat(locale, { month: 'short', day: 'numeric' }).format(untilDate);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - formatToRelativeTime({
  fromDate,
  locale = DEFAULT_LOCALE,
  toDate = new Date()
 - formatSnoozedUntil({ untilDate, locale = DEFAULT_LOCALE }: { untilDate: Date; locale?: string })
Declaraciones 'export' encontradas:
- export function formatToRelativeTime
- export function formatSnoozedUntil

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/helpers/index.ts
Tamaño: 319 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './constants';
export * from './createInfiniteScroll';
export * from './formatToRelativeTime';
export * from './useNotificationVisibility';
export * from './useStyle';
export * from './useTabsDropdown';
export * from './useUncontrolledState';
export * from './useWebSocketEvent';
export * from './utils';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/helpers/mergeRefs.ts
Tamaño: 416 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Ref } from 'solid-js';

function chain<Args extends [] | any[]>(callbacks: {
  [Symbol.iterator](): IterableIterator<((...args: Args) => any) | undefined>;
}): (...args: Args) => void {
  return (...args: Args) => {
    for (const callback of callbacks) callback && callback(...args);
  };
}

export function mergeRefs<T>(...refs: Ref<T>[]): (el: T) => void {
  return chain(refs as ((el: T) => void)[]);
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export function mergeRefs

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/helpers/types.ts
Tamaño: 173 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export type Path<T, K extends string = ''> = T extends string
  ? K
  : {
      [P in keyof T]-?: Path<T[P], `${K}${K extends '' ? '' : '.'}${P & string}`>;
    }[keyof T];


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/helpers/useBrowserTabsChannel.ts
Tamaño: 709 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { createSignal, onCleanup, onMount } from 'solid-js';

export const useBrowserTabsChannel = <T = unknown>({
  channelName,
  onMessage,
}: {
  channelName: string;
  onMessage: (args: T) => void;
}) => {
  const [tabsChannel] = createSignal(new BroadcastChannel(channelName));

  const postMessage = (args: T) => {
    const channel = tabsChannel();
    channel.postMessage(args);
  };

  onMount(() => {
    const listener = (event: MessageEvent<T>) => {
      onMessage(event.data);
    };

    const channel = tabsChannel();
    channel.addEventListener('message', listener);

    onCleanup(() => {
      channel.removeEventListener('message', listener);
    });
  });

  return { postMessage };
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - T(unknown>({
  channelName,
  onMessage,
}: {
  channelName: string;
  onMessage: (args: T))
 - postMessage(args: T))
 - channel(tabsChannel();
    channel.postMessage(args);
  };

  onMount(())
 - listener(event: MessageEvent<T>))
 - channel(tabsChannel();
    channel.addEventListener('message', listener);

    onCleanup(())
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/helpers/useFocusTrap.ts
Tamaño: 2127 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { createEffect, onCleanup } from 'solid-js';
import { useAppearance } from '../context';

interface FocusTrapOptions {
  element: () => HTMLElement | null;
  enabled: () => boolean;
}

function createFocusTrap({ element, enabled }: FocusTrapOptions) {
  const { container } = useAppearance();

  createEffect(() => {
    const trapElement = element();

    if (!trapElement || !enabled()) return;

    const focusableElementsString =
      'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, [tabindex], [contenteditable]';

    const getFocusableElements = () => {
      return Array.from(trapElement.querySelectorAll<HTMLElement>(focusableElementsString)).filter(
        (el) => el.tabIndex >= 0 && !el.hasAttribute('disabled')
      );
    };

    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key !== 'Tab') return;

      const focusableElements = getFocusableElements();
      const firstFocusableElement = focusableElements[0];
      const lastFocusableElement = focusableElements[focusableElements.length - 1];

      const containerElement = container();
      const root = containerElement instanceof ShadowRoot ? containerElement : document;
      if (event.shiftKey) {
        // If Shift + Tab is pressed, move focus to the previous focusable element
        if (root.activeElement === firstFocusableElement) {
          lastFocusableElement.focus();
          event.preventDefault();
        }
      } else {
        // If Tab is pressed, move focus to the next focusable element
        if (root.activeElement === lastFocusableElement) {
          firstFocusableElement.focus();
          event.preventDefault();
        }
      }
    };

    trapElement.addEventListener('keydown', handleKeyDown);

    // Initial focus
    const focusableElements = getFocusableElements();
    if (focusableElements.length > 0) {
      focusableElements[0].focus();
    }

    onCleanup(() => {
      trapElement.removeEventListener('keydown', handleKeyDown);
    });
  });
}

export default createFocusTrap;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - createFocusTrap({ element, enabled }: FocusTrapOptions)
Asignaciones con arrow functions encontradas (posibles funciones):
 - getFocusableElements())
 - handleKeyDown(event: KeyboardEvent))
 - focusableElements(getFocusableElements();
    if (focusableElements.length > 0) {
      focusableElements[0].focus();
...)
Declaraciones 'export' encontradas:
- export default  createFocusTrap

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/helpers/useNotificationVisibility.ts
Tamaño: 937 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { onCleanup, onMount } from 'solid-js';
import { NotificationVisibilityTracker } from '../../notifications/visibility-tracker';
import { useNovu } from '../context';

export function useNotificationVisibility() {
  const novu = useNovu();
  let tracker: NotificationVisibilityTracker | null = null;

  onMount(() => {
    // Initialize the visibility tracker with the inbox service
    tracker = new NotificationVisibilityTracker(novu.notifications.inboxService);

    onCleanup(() => {
      if (tracker) {
        tracker.destroy();
        tracker = null;
      }
    });
  });

  const observeNotification = (element: Element, notificationId: string) => {
    if (tracker) {
      tracker.observe(element, notificationId);
    }
  };

  const unobserveNotification = (element: Element) => {
    if (tracker) {
      tracker.unobserve(element);
    }
  };

  return {
    observeNotification,
    unobserveNotification,
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useNotificationVisibility()
Asignaciones con arrow functions encontradas (posibles funciones):
 - null(null;

  onMount(())
 - tracker(new NotificationVisibilityTracker(novu.notifications.inboxService);

    onCleanup(())
 - observeNotification(element: Element, notificationId: string))
 - unobserveNotification(element: Element))
Declaraciones 'export' encontradas:
- export function useNotificationVisibility

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/helpers/useNovuEvent.ts
Tamaño: 459 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { onCleanup, onMount } from 'solid-js';
import type { EventHandler, EventNames, Events } from '../../event-emitter';
import { useNovu } from '../context';

export const useNovuEvent = <E extends EventNames>({
  event,
  eventHandler,
}: {
  event: E;
  eventHandler: EventHandler<Events[E]>;
}) => {
  const novu = useNovu();

  onMount(() => {
    const cleanup = novu.on(event, eventHandler);

    onCleanup(() => {
      cleanup();
    });
  });
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - useNovuEvent(<E extends EventNames>({
  event,
  eventHandler,
}: {
  event: E;
  eventHandler: EventHandler<Even...)
 - novu(useNovu();

  onMount(())
 - cleanup(novu.on(event, eventHandler);

    onCleanup(())
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/helpers/useStyle.ts
Tamaño: 3946 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { createMemo, createSignal, onMount } from 'solid-js';
import { appearanceKeys } from '../config';
import { useAppearance } from '../context';
import type { AppearanceKey, Elements, IconKey } from '../types';
import { cn, publicFacingTwMerge } from './utils';

export const useStyle = () => {
  const appearance = useAppearance();
  const [isServer, setIsServer] = createSignal(true);

  onMount(() => {
    setIsServer(false);
  });

  const styleFuncMemo = createMemo(
    () =>
      ({
        key,
        className,
        iconKey,
        context,
      }: {
        key: AppearanceKey;
        className?: string;
        iconKey?: IconKey;
        context?: any;
      }) => {
        const appearanceKeyParts = key.split('__');
        let finalAppearanceKeys: (keyof Elements)[] = [];
        for (let i = 0; i < appearanceKeyParts.length; i += 1) {
          const accumulated = appearanceKeyParts.slice(i).join('__');
          if (appearanceKeys.includes(accumulated as keyof Elements)) {
            finalAppearanceKeys.push(accumulated as keyof Elements);
          }
        }

        // Find appearance keys in the className and utilize them as well.
        const classes = className?.split(/\s+/).map((className) => className.replace(/^nv-/, '')) || [];
        const appearanceKeysInClasses = classes.filter((className) =>
          (appearanceKeys as unknown as string[]).includes(className)
        );

        // Remove duplicates
        finalAppearanceKeys = Array.from(
          new Set([...finalAppearanceKeys, ...appearanceKeysInClasses])
        ) as (keyof Elements)[];

        // Sort appearance keys by the number of `__` occurrences
        finalAppearanceKeys.sort((a, b) => {
          const countA = (a.match(/__/g) || []).length;
          const countB = (b.match(/__/g) || []).length;

          return countB - countA;
        });

        // Remove appearance keys from the className
        const finalClassName = classes
          .filter((className) => !(finalAppearanceKeys as string[]).includes(className))
          .join(' ');

        let appearanceClassnames: string[] = [];
        const reversedFinalAppearanceKeys = finalAppearanceKeys.reverse();
        for (let i = 0; i < reversedFinalAppearanceKeys.length; i += 1) {
          const elementStyles = appearance.elements()[reversedFinalAppearanceKeys[i]];
          if (typeof elementStyles === 'string') {
            appearanceClassnames.push(elementStyles);
          } else if (typeof elementStyles === 'function') {
            appearanceClassnames.push(elementStyles(context));
          }
        }

        /*
         ** Attempt to fix any classname clashes here when a specific appearance key is changing the same
         ** css property.
         **
         ** For example:
         ** back__button: 'bg-blue-500',
         ** button: 'bg-red-500',
         **
         ** The above will clash, so we need to merge them together.
         **
         ** We do this by reversing the appearance keys (to have the more specific ones last) and merging them together.
         ** Currently only using twMerge so it won't work for other css frameworks but we can allow
         ** passing a custom merge function in the future, or just wrap with more logic to support more frameworks.
         */
        appearanceClassnames = [publicFacingTwMerge(appearanceClassnames)];

        const cssInJsClasses =
          !!finalAppearanceKeys.length && !isServer()
            ? finalAppearanceKeys.map((appKey) => appearance.appearanceKeyToCssInJsClass[appKey])
            : [];

        return cn(
          ...finalAppearanceKeys.map((key) => `nv-${key}`),
          '🔔',
          iconKey ? `nv-${iconKey} 🖼️` : '',

          finalClassName, // default styles
          appearanceClassnames, // overrides via appearance prop classes
          ...cssInJsClasses
        );
      }
  );

  return styleFuncMemo();
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - useStyle())
 - styleFuncMemo(createMemo(
    ())
 - classes(className?.split(/\s+/).map((className))
 - appearanceKeysInClasses(classes.filter((className))
 - finalAppearanceKeys(Array.from(
          new Set([...finalAppearanceKeys, ...appearanceKeysInClasses])
        ) as (ke...)
 - finalClassName(classes
          .filter((className))
 - cssInJsClasses(!!finalAppearanceKeys.length && !isServer()
            ? finalAppearanceKeys.map((appKey))
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/helpers/useTabsDropdown.ts
Tamaño: 1432 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { createSignal, onMount } from 'solid-js';
import type { Tab } from '../types';

type TabsArray = Array<Tab>;

export const useTabsDropdown = ({ tabs }: { tabs: TabsArray }) => {
  const [tabsList, setTabsList] = createSignal<HTMLDivElement>();
  const [visibleTabs, setVisibleTabs] = createSignal<TabsArray>([]);
  const [dropdownTabs, setDropdownTabs] = createSignal<TabsArray>([]);

  onMount(() => {
    const tabsListEl = tabsList();
    if (!tabsListEl) return;

    const tabsElements = [...tabsListEl.querySelectorAll('[role="tab"]')];

    const observer = new IntersectionObserver(
      (entries) => {
        let visibleTabIds = entries
          .filter((entry) => entry.isIntersecting && entry.intersectionRatio === 1)
          .map((entry) => entry.target.id);

        if (tabsElements.length === visibleTabIds.length) {
          setVisibleTabs(tabs.filter((tab) => visibleTabIds.includes(tab.label)));
          observer.disconnect();

          return;
        }

        visibleTabIds = visibleTabIds.slice(0, -1);
        setVisibleTabs(tabs.filter((tab) => visibleTabIds.includes(tab.label)));
        setDropdownTabs(tabs.filter((tab) => !visibleTabIds.includes(tab.label)));
        observer.disconnect();
      },
      { root: tabsListEl }
    );

    for (const tabElement of tabsElements) {
      observer.observe(tabElement);
    }
  });

  return { dropdownTabs, setTabsList, visibleTabs };
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - useTabsDropdown({ tabs }: { tabs: TabsArray }))
 - observer(new IntersectionObserver(
      (entries))
 - visibleTabIds(entries
          .filter((entry))
 - visibleTabIds(visibleTabIds.slice(0, -1);
        setVisibleTabs(tabs.filter((tab))
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/helpers/useUncontrolledState.ts
Tamaño: 732 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Accessor, createSignal, Setter } from 'solid-js';

type UseUncontrolledState = {
  value?: boolean;
  fallbackValue?: boolean;
};

type UseUncontrolledStateOutput = [Accessor<boolean>, Setter<boolean>];

export function useUncontrolledState(props: UseUncontrolledState): UseUncontrolledStateOutput {
  const [uncontrolledValue, setUncontrolledValue] = createSignal(!!props.fallbackValue);

  /**
   * If value is provided, return controlled state
   */
  if (props.value !== undefined) {
    const accessor: Accessor<boolean> = () => !!props.value;

    return [accessor, setUncontrolledValue];
  }

  /**
   * If value is not provided, return uncontrolled state
   */
  return [uncontrolledValue, setUncontrolledValue];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - useUncontrolledState(props: UseUncontrolledState)
Declaraciones 'export' encontradas:
- export function useUncontrolledState

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/helpers/useWebSocketEvent.ts
Tamaño: 1094 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { onCleanup, onMount } from 'solid-js';
import type { EventHandler, Events, SocketEventNames } from '../../event-emitter';
import { useNovu } from '../context';
import { requestLock } from './browser';
import { useBrowserTabsChannel } from './useBrowserTabsChannel';

export const useWebSocketEvent = <E extends SocketEventNames>({
  event: webSocketEvent,
  eventHandler: onMessage,
}: {
  event: E;
  eventHandler: (args: Events[E]) => void;
}) => {
  const novu = useNovu();
  const channelName = `nv_ws_connection:a=${novu.applicationIdentifier}:s=${novu.subscriberId}:c=${novu.contextKey}:e=${webSocketEvent}`;

  const { postMessage } = useBrowserTabsChannel({ channelName, onMessage });

  const updateReadCount: EventHandler<Events[E]> = (data) => {
    onMessage(data);
    postMessage(data);
  };

  onMount(() => {
    let cleanup: () => void;
    const resolveLock = requestLock(channelName, () => {
      cleanup = novu.on(webSocketEvent, updateReadCount);
    });

    onCleanup(() => {
      if (cleanup) {
        cleanup();
      }
      resolveLock();
    });
  });
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - useWebSocketEvent(<E extends SocketEventNames>({
  event: webSocketEvent,
  eventHandler: onMessage,
}: {
  event: E;
...)
 - resolveLock(requestLock(channelName, ())
 - cleanup(novu.on(webSocketEvent, updateReadCount);
    });

    onCleanup(())
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/helpers/utils.ts
Tamaño: 9233 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import clsx, { ClassValue } from 'clsx';
import { type ClassNameValue, extendTailwindMerge } from 'tailwind-merge';
import type { CSSProperties, Elements, Tab, Variables } from '../types';

const twMerge = extendTailwindMerge({
  prefix: 'nt-',
});

export const publicFacingTwMerge = extendTailwindMerge({});

export type ClassName = ClassNameValue;

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

export function generateRandomString(length: number): string {
  const characters = 'abcdefghijklmnopqrstuvwxyz';
  let result = '';
  const charactersLength = characters.length;
  for (let i = 0; i < length; i += 1) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }

  return result;
}

function generateUniqueRandomString(set: Set<string>, length: number): string {
  let randomString: string;
  do {
    randomString = generateRandomString(length);
  } while (set.has(randomString));

  return randomString;
}

export function cssObjectToString(styles: CSSProperties): string {
  return Object.entries(styles)
    .map(([key, value]) => {
      const kebabKey = key.replace(/([A-Z])/g, '-$1').toLowerCase();

      return `${kebabKey}: ${value};`;
    })
    .join(' ');
}

export function createClassAndRuleFromCssString(classNameSet: Set<string>, styles: string) {
  const className = `novu-css-${generateUniqueRandomString(classNameSet, 8)}`;
  const rule = `.${className} { ${styles} }`;
  classNameSet.add(className);

  return { className, rule };
}

const shades = [25, 50, 100, 200, 300, 400, 500, 600, 700, 800, 900];

export function generateDefaultColor(props: { color: string; key: string; id: string }) {
  const cssVariableDefaultRule = `.${props.id} { --nv-${props.key}: oklch(from ${props.color} l c h); }`;

  return cssVariableDefaultRule;
}

export function generateSolidShadeRulesFromColor({ color, key, id }: { color: string; key: string; id: string }) {
  const rules: string[] = [];

  const adjustLightness = (factor: number) => {
    if (factor >= 0) {
      return `min(1, calc(l + ${factor} * (1 - l)))`;
    } else {
      return `max(0, calc(l * (1 + ${factor})))`;
    }
  };

  const lightnessOffsets: Record<number, string> = {
    25: adjustLightness(0.475),
    50: adjustLightness(0.45),
    100: adjustLightness(0.4),
    200: adjustLightness(0.3),
    300: adjustLightness(0.2),
    400: adjustLightness(0.1),
    500: 'l',
    600: adjustLightness(-0.1),
    700: adjustLightness(-0.2),
    800: adjustLightness(-0.3),
    900: adjustLightness(-0.4),
  };

  shades.forEach((shade) => {
    const newLightness = lightnessOffsets[shade];
    const cssVariableRule = `.${id} { --nv-${key}-${shade}: oklch(from ${color} ${newLightness} c h); }`;
    rules.push(cssVariableRule);
  });

  return rules;
}

export function generateAlphaShadeRulesFromColor({ color, key, id }: { color: string; key: string; id: string }) {
  const rules: string[] = [];
  const alphaMap = {
    25: 0.025,
    50: 0.05,
    100: 0.1,
    200: 0.2,
    300: 0.3,
    400: 0.4,
    500: 0.5,
    600: 0.6,
    700: 0.7,
    800: 0.8,
    900: 0.9,
  };

  Object.entries(alphaMap).forEach(([shade, alpha]) => {
    const cssVariableAlphaRule = `.${id} { --nv-${key}-${shade}: oklch(from ${color} l c h / ${alpha}); }`;
    rules.push(cssVariableAlphaRule);
  });

  return rules;
}

export function generateFontSizeRules(props: { id: string; baseFontSize: string }) {
  const { id, baseFontSize } = props;

  const sizeRatios = {
    xs: 0.65625,
    sm: 0.765625,
    base: 0.875,
    lg: 0.984375,
    xl: 1.09375,
    '2xl': 1.3125,
    '3xl': 1.640625,
    '4xl': 1.96875,
  };

  const rules: string[] = [];

  Object.entries(sizeRatios).forEach(([key, ratio]) => {
    const size = `calc(${baseFontSize} * ${ratio})`;
    const lineHeight = `calc(${baseFontSize} * ${ratio} * 1.33)`;

    const cssVariableRule = `.${id} { --nv-font-size-${key}: ${size}; --nv-line-height-${key}: ${lineHeight}; }`;
    rules.push(cssVariableRule);
  });

  return rules;
}

export function generateBorderRadiusRules(props: { id: string; baseRadius: string }) {
  const { id, baseRadius } = props;

  const radiusRatios = {
    none: 0,
    xs: 0.333,
    sm: 0.667,
    md: 1,
    lg: 1.333,
    xl: 2,
    '2xl': 2.667,
    '3xl': 4,
    full: 9999,
  };

  const rules: string[] = [];

  Object.entries(radiusRatios).forEach(([key, ratio]) => {
    const value = key === 'none' ? '0px' : key === 'full' ? '9999px' : `calc(${baseRadius} * ${ratio})`;

    const cssVariableRule = `.${id} { --nv-radius-${key}: ${value}; }`;
    rules.push(cssVariableRule);
  });

  return rules;
}

export const parseVariables = (variables: Required<Variables>, id: string) => {
  const rules = [
    generateDefaultColor({ color: variables.colorBackground, key: 'color-background', id }),
    generateDefaultColor({ color: variables.colorForeground, key: 'color-foreground', id }),
    generateDefaultColor({ color: variables.colorPrimary, key: 'color-primary', id }),
    generateDefaultColor({ color: variables.colorPrimaryForeground, key: 'color-primary-foreground', id }),
    generateDefaultColor({ color: variables.colorSecondary, key: 'color-secondary', id }),
    generateDefaultColor({ color: variables.colorSecondaryForeground, key: 'color-secondary-foreground', id }),
    generateDefaultColor({ color: variables.colorCounter, key: 'color-counter', id }),
    generateDefaultColor({ color: variables.colorCounterForeground, key: 'color-counter-foreground', id }),
    generateDefaultColor({ color: variables.colorShadow, key: 'color-shadow', id }),
    generateDefaultColor({ color: variables.colorRing, key: 'color-ring', id }),
    generateDefaultColor({ color: variables.colorStripes, key: 'color-stripes', id }),
    generateDefaultColor({ color: variables.colorSeverityHigh, key: 'color-severity-high', id }),
    generateDefaultColor({ color: variables.colorSeverityMedium, key: 'color-severity-medium', id }),
    generateDefaultColor({ color: variables.colorSeverityLow, key: 'color-severity-low', id }),
    ...generateAlphaShadeRulesFromColor({ color: variables.colorSeverityHigh, key: 'color-severity-high-alpha', id }),
    ...generateAlphaShadeRulesFromColor({
      color: variables.colorSeverityMedium,
      key: 'color-severity-medium-alpha',
      id,
    }),
    ...generateAlphaShadeRulesFromColor({ color: variables.colorSeverityLow, key: 'color-severity-low-alpha', id }),
    ...generateAlphaShadeRulesFromColor({ color: variables.colorBackground, key: 'color-background-alpha', id }),
    ...generateAlphaShadeRulesFromColor({ color: variables.colorForeground, key: 'color-foreground-alpha', id }),
    ...generateSolidShadeRulesFromColor({ color: variables.colorPrimary, key: 'color-primary', id }),
    ...generateAlphaShadeRulesFromColor({ color: variables.colorPrimary, key: 'color-primary-alpha', id }),
    ...generateAlphaShadeRulesFromColor({
      color: variables.colorPrimaryForeground,
      key: 'color-primary-foreground-alpha',
      id,
    }),
    ...generateSolidShadeRulesFromColor({ color: variables.colorSecondary, key: 'color-secondary', id }),
    ...generateAlphaShadeRulesFromColor({ color: variables.colorSecondary, key: 'color-secondary-alpha', id }),
    ...generateAlphaShadeRulesFromColor({
      color: variables.colorSecondaryForeground,
      key: 'color-secondary-foreground-alpha',
      id,
    }),
    ...generateAlphaShadeRulesFromColor({ color: variables.colorNeutral, key: 'color-neutral-alpha', id }),
    ...generateFontSizeRules({ id, baseFontSize: variables.fontSize }),
    ...generateBorderRadiusRules({ id, baseRadius: variables.borderRadius }),
  ];

  return rules;
};

export const parseElements = (elements: Elements) => {
  const elementsStyleData: { key: string; rule: string; className: string }[] = [];
  const generatedClassNames = new Set<string>();
  for (const key in elements) {
    if (elements.hasOwnProperty(key)) {
      const value = elements[key as keyof Elements];
      if (typeof value === 'object') {
        // means it is css in js object
        const cssString = cssObjectToString(value);
        const { className, rule } = createClassAndRuleFromCssString(generatedClassNames, cssString);
        elementsStyleData.push({ key, rule, className });
      }
    }
  }

  /*
   ** Sort the elements by the number of __ in the className
   ** This is to ensure that the most specific elements are applied last
   ** i.e. dropdownItem__icon should be applied last so that it can override the icon class from dropdownItem
   */
  const sortedElementsStyleData = elementsStyleData.sort((a, b) => {
    const countA = (a.key.match(/__/g) || []).length;
    const countB = (b.key.match(/__/g) || []).length;

    return countA - countB;
  });

  return sortedElementsStyleData;
};

/**
 * In the next minor release we can remove the deprecated `value` field from the Tab type.
 * This function can be removed after that and the code should be updated to use the `filter` field.
 * @returns tags from the tab object
 */
export const getTagsFromTab = (tab?: Tab) => {
  return tab?.filter?.tags || tab?.value || [];
};

export const NOVU_DEFAULT_CSS_ID = 'novu-default-css';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - cn(...inputs: ClassValue[])
 - generateRandomString(length: number)
 - generateUniqueRandomString(set: Set<string>, length: number)
 - cssObjectToString(styles: CSSProperties)
 - createClassAndRuleFromCssString(classNameSet: Set<string>, styles: string)
 - generateDefaultColor(props: { color: string; key: string; id: string })
 - generateSolidShadeRulesFromColor({ color, key, id }: { color: string; key: string; id: string })
 - generateAlphaShadeRulesFromColor({ color, key, id }: { color: string; key: string; id: string })
 - generateFontSizeRules(props: { id: string; baseFontSize: string })
 - generateBorderRadiusRules(props: { id: string; baseRadius: string })
Asignaciones con arrow functions encontradas (posibles funciones):
 - randomString(generateRandomString(length);
  } while (set.has(randomString));

  return randomString;
}

export f...)
 - adjustLightness(factor: number))
 - alphaMap({
    25: 0.025,
    50: 0.05,
    100: 0.1,
    200: 0.2,
    300: 0.3,
    400: 0.4,
    500: 0.5,...)
 - parseVariables(variables: Required<Variables>, id: string))
 - parseElements(elements: Elements))
 - sortedElementsStyleData(elementsStyleData.sort((a, b))
 - getTagsFromTab(tab?: Tab))
Declaraciones 'export' encontradas:
- export  const
- export  type
- export function cn
- export function generateRandomString
- export function cssObjectToString
- export function createClassAndRuleFromCssString
- export function generateDefaultColor
- export function generateSolidShadeRulesFromColor
- export function generateAlphaShadeRulesFromColor
- export function generateFontSizeRules
- export function generateBorderRadiusRules
- export  const
- export  const
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/icons/ArrowDown.tsx
Tamaño: 387 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX } from 'solid-js';

export const ArrowDown = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
  return (
    <svg viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
      <path
        d="M10.0001 10.879L13.7126 7.1665L14.7731 8.227L10.0001 13L5.22705 8.227L6.28755 7.1665L10.0001 10.879Z"
        fill="currentColor"
      />
    </svg>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX } from 'solid-js';
export const ArrowDown = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
return (
<svg viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/icons/ArrowDropDown.tsx
Tamaño: 313 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX } from 'solid-js';

export const ArrowDropDown = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 20 20" {...props}>
      <path fill="currentColor" d="M5.833 8.333L10 12.5l4.166-4.167H5.833z"></path>
    </svg>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX } from 'solid-js';
export const ArrowDropDown = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
return (
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 20 20" {...props}>
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/icons/ArrowLeft.tsx
Tamaño: 400 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX } from 'solid-js';

export const ArrowLeft = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
  return (
    <svg viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
      <path
        d="M9.20425 9.99907L12.9168 13.7116L11.8563 14.7721L7.08325 9.99907L11.8563 5.22607L12.9168 6.28657L9.20425 9.99907Z"
        fill="currentColor"
      />
    </svg>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX } from 'solid-js';
export const ArrowLeft = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
return (
<svg viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/icons/ArrowRight.tsx
Tamaño: 399 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX } from 'solid-js';

export const ArrowRight = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
  return (
    <svg viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
      <path
        d="M10.7957 10.0009L7.08325 6.2884L8.14375 5.2279L12.9168 10.0009L8.14375 14.7739L7.08325 13.7134L10.7957 10.0009Z"
        fill="currentColor"
      />
    </svg>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX } from 'solid-js';
export const ArrowRight = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
return (
<svg viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/icons/ArrowUpRight.tsx
Tamaño: 401 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX } from 'solid-js';

export const ArrowUpRight = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
  return (
    <svg width="6" height="6" viewBox="0 0 6 6" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
      <path
        d="M5.00175 1.70402L0.705765 6L0 5.29424L4.29548 0.998253H0.509608V0H6V5.49039H5.00175V1.70402Z"
        fill="currentColor"
      />
    </svg>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX } from 'solid-js';
export const ArrowUpRight = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
return (
<svg width="6" height="6" viewBox="0 0 6 6" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/icons/Bell.tsx
Tamaño: 1081 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX } from 'solid-js';

type BellProps = JSX.HTMLAttributes<SVGSVGElement>;

export function Bell(props: BellProps) {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 12 14" {...props}>
      <path
        fill="url(#nv_bell_gradient)"
        d="M6 0c-.435 0-.786.391-.786.875V1.4C3.42 1.805 2.07 3.571 2.07 5.687v.515c0 1.285-.425 2.526-1.19 3.489l-.183.227a.957.957 0 0 0-.13.94c.126.315.408.517.717.517h9.429c.31 0 .589-.202.717-.517a.95.95 0 0 0-.13-.94l-.182-.227c-.766-.963-1.191-2.202-1.191-3.49v-.513c0-2.117-1.35-3.883-3.143-4.288V.875C6.785.391 6.434 0 6 0Zm1.112 13.489c.294-.329.459-.774.459-1.239H4.429c-.001.465.164.91.458 1.239.295.328.695.511 1.112.511.418 0 .818-.183 1.113-.511Z"
      />
      <defs>
        <linearGradient id="nv_bell_gradient" x1="6" y1="0" x2="6" y2="14" gradientUnits="userSpaceOnUse">
          <stop stop-color="var(--bell-gradient-start, currentColor)" />
          <stop offset="1" stop-color="var(--bell-gradient-end, currentColor)" />
        </linearGradient>
      </defs>
    </svg>
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX } from 'solid-js';
type BellProps = JSX.HTMLAttributes<SVGSVGElement>;
export function Bell(props: BellProps) {
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/icons/CalendarSchedule.tsx
Tamaño: 728 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX } from 'solid-js';

export const CalendarSchedule = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="none" viewBox="0 0 14 14" {...props}>
      <path
        fill="currentColor"
        d="M4.381 2.952V2h.952v.952H8.19V2h.953v.952h1.905c.263 0 .476.214.476.477v2.38h-.953V3.906H9.143v.952H8.19v-.952H5.333v.952h-.952v-.952H2.952v6.666H5.81v.953H2.476A.476.476 0 0 1 2 11.048v-7.62c0-.262.213-.476.476-.476h1.905Zm4.762 4.286a1.905 1.905 0 1 0 0 3.81 1.905 1.905 0 0 0 0-3.81ZM6.286 9.143a2.857 2.857 0 1 1 5.714 0 2.857 2.857 0 0 1-5.714 0Zm2.38-1.429V9.34l1.093 1.092.673-.673-.813-.813V7.714h-.952Z"
      />
    </svg>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX } from 'solid-js';
export const CalendarSchedule = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
return (
<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="none" viewBox="0 0 14 14" {...props}>
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/icons/Chat.tsx
Tamaño: 888 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX } from 'solid-js';

export const Chat = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
  return (
    <svg viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
      <path
        d="M0.625 9.375L2.93989 8.86059C3.5538 9.18889 4.25516 9.375 5 9.375C7.41622 9.375 9.375 7.41622 9.375 5C9.375 2.58375 7.41622 0.625 5 0.625C2.58375 0.625 0.625 2.58375 0.625 5C0.625 5.74484 0.81113 6.4462 1.13942 7.0601L0.625 9.375ZM6.50881 2.8125L6.43224 3.68761H7.1875V4.56259H6.35568L6.27912 5.43759H7.1875V6.31259H6.2026L6.12604 7.1875H5.24771L5.32423 6.31259H4.44591L4.36934 7.1875H3.49101L3.56755 6.31259H2.8125V5.43759H3.64411L3.72066 4.56259H2.8125V3.68761H3.79721L3.87377 2.8125H4.75211L4.67555 3.68761H5.55392L5.63048 2.8125H6.50881ZM4.59899 4.56259L4.52247 5.43759H5.40079L5.47736 4.56259H4.59899Z"
        fill="currentColor"
      />
    </svg>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX } from 'solid-js';
export const Chat = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
return (
<svg viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/icons/Check.tsx
Tamaño: 372 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX } from 'solid-js';

export const Check = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
  return (
    <svg viewBox="0 0 8 6" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
      <path
        d="M2.99994 4.58847L7.33298 0L8 0.705765L2.99994 6L0 2.82356L0.666549 2.11779L2.99994 4.58847Z"
        fill="currentColor"
      />
    </svg>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX } from 'solid-js';
export const Check = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
return (
<svg viewBox="0 0 8 6" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/icons/Clock.tsx
Tamaño: 534 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX } from 'solid-js';

export const Clock = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
  return (
    <svg viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
      <g clip-path="url(#clip0_3188_15050)">
        <path
          d="M6 3V6L8 7M11 6C11 8.76142 8.76142 11 6 11C3.23858 11 1 8.76142 1 6C1 3.23858 3.23858 1 6 1C8.76142 1 11 3.23858 11 6Z"
          stroke="currentColor"
          stroke-linecap="round"
          stroke-linejoin="round"
        />
      </g>
    </svg>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX } from 'solid-js';
export const Clock = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
return (
<svg viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/icons/Cogs.tsx
Tamaño: 1058 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX } from 'solid-js';

export const Cogs = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
  return (
    <svg viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
      <path
        d="M10 1.75L17.125 5.875V14.125L10 18.25L2.875 14.125V5.875L10 1.75ZM10 3.48325L4.375 6.73975V13.2603L10 16.5167L15.625 13.2603V6.73975L10 3.48325ZM10 13C9.20435 13 8.44129 12.6839 7.87868 12.1213C7.31607 11.5587 7 10.7956 7 10C7 9.20435 7.31607 8.44129 7.87868 7.87868C8.44129 7.31607 9.20435 7 10 7C10.7956 7 11.5587 7.31607 12.1213 7.87868C12.6839 8.44129 13 9.20435 13 10C13 10.7956 12.6839 11.5587 12.1213 12.1213C11.5587 12.6839 10.7956 13 10 13ZM10 11.5C10.3978 11.5 10.7794 11.342 11.0607 11.0607C11.342 10.7794 11.5 10.3978 11.5 10C11.5 9.60218 11.342 9.22064 11.0607 8.93934C10.7794 8.65804 10.3978 8.5 10 8.5C9.60218 8.5 9.22064 8.65804 8.93934 8.93934C8.65804 9.22064 8.5 9.60218 8.5 10C8.5 10.3978 8.65804 10.7794 8.93934 11.0607C9.22064 11.342 9.60218 11.5 10 11.5Z"
        fill="currentColor"
      />
    </svg>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX } from 'solid-js';
export const Cogs = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
return (
<svg viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/icons/Copy.tsx
Tamaño: 554 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX } from 'solid-js';

export const Copy = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="none" viewBox="0 0 12 12" {...props}>
      <path
        fill="currentColor"
        d="M3.75 3.3V1.95a.45.45 0 0 1 .45-.45h5.4a.45.45 0 0 1 .45.45v6.3a.45.45 0 0 1-.45.45H8.25v1.35c0 .248-.203.45-.453.45H2.403a.449.449 0 0 1-.453-.45l.001-6.3c0-.248.203-.45.453-.45H3.75Zm-.899.9L2.85 9.6h4.5V4.2H2.851Zm1.799-.9h3.6v4.5h.9V2.4h-4.5v.9Z"
      />
    </svg>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX } from 'solid-js';
export const Copy = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
return (
<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="none" viewBox="0 0 12 12" {...props}>
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/icons/Dots.tsx
Tamaño: 613 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX } from 'solid-js';

export const Dots = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 20 20" {...props}>
      <path
        fill="currentColor"
        d="M5 8.333c-.917 0-1.667.75-1.667 1.667s.75 1.667 1.667 1.667c.916 0 1.666-.75 1.666-1.667S5.916 8.333 5 8.333zm10 0c-.917 0-1.667.75-1.667 1.667s.75 1.667 1.667 1.667c.916 0 1.666-.75 1.666-1.667S15.916 8.333 15 8.333zm-5 0c-.917 0-1.667.75-1.667 1.667s.75 1.667 1.667 1.667c.916 0 1.666-.75 1.666-1.667S10.916 8.333 10 8.333z"
      ></path>
    </svg>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX } from 'solid-js';
export const Dots = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
return (
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 20 20" {...props}>
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/icons/Email.tsx
Tamaño: 1359 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX } from 'solid-js';

export const Email = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
  return (
    <svg viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
      <path
        d="M4.20703 1.875H2.8125H2.10547H1.875V2.04688V2.8125V3.60156V5.33984L0.00390625 3.95508C0.0351562 3.60156 0.216797 3.27344 0.505859 3.06055L0.9375 2.74023V1.875C0.9375 1.35742 1.35742 0.9375 1.875 0.9375H3.37109L4.3457 0.216797C4.53516 0.0761719 4.76367 0 5 0C5.23633 0 5.46484 0.0761719 5.6543 0.214844L6.62891 0.9375H8.125C8.64258 0.9375 9.0625 1.35742 9.0625 1.875V2.74023L9.49414 3.06055C9.7832 3.27344 9.96484 3.60156 9.99609 3.95508L8.125 5.33984V3.60156V2.8125V2.04688V1.875H7.89453H7.1875H5.79297H4.20508H4.20703ZM0 8.75V4.72852L4.25 7.87695C4.4668 8.03711 4.73047 8.125 5 8.125C5.26953 8.125 5.5332 8.03906 5.75 7.87695L10 4.72852V8.75C10 9.43945 9.43945 10 8.75 10H1.25C0.560547 10 0 9.43945 0 8.75ZM3.4375 3.125H6.5625C6.73438 3.125 6.875 3.26562 6.875 3.4375C6.875 3.60938 6.73438 3.75 6.5625 3.75H3.4375C3.26562 3.75 3.125 3.60938 3.125 3.4375C3.125 3.26562 3.26562 3.125 3.4375 3.125ZM3.4375 4.375H6.5625C6.73438 4.375 6.875 4.51562 6.875 4.6875C6.875 4.85938 6.73438 5 6.5625 5H3.4375C3.26562 5 3.125 4.85938 3.125 4.6875C3.125 4.51562 3.26562 4.375 3.4375 4.375Z"
        fill="currentColor"
      />
    </svg>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX } from 'solid-js';
export const Email = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
return (
<svg viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/icons/InApp.tsx
Tamaño: 1073 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX } from 'solid-js';

export const InApp = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
  return (
    <svg viewBox="0 0 10 12" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
      <path
        d="M4.99962 0.856934C4.64404 0.856934 4.35676 1.14421 4.35676 1.49979V1.88551C2.89024 2.18283 1.78533 3.48059 1.78533 5.03551V5.41318C1.78533 6.35738 1.43779 7.26943 0.810999 7.97658L0.662339 8.14332C0.493589 8.33216 0.45341 8.60336 0.555865 8.83439C0.658321 9.06542 0.889348 9.21408 1.14247 9.21408H8.85676C9.10988 9.21408 9.3389 9.06542 9.44337 8.83439C9.54783 8.60336 9.50564 8.33216 9.33689 8.14332L9.18823 7.97658C8.56145 7.26943 8.2139 6.35939 8.2139 5.41318V5.03551C8.2139 3.48059 7.10899 2.18283 5.64247 1.88551V1.49979C5.64247 1.14421 5.3552 0.856934 4.99962 0.856934ZM5.90966 10.767C6.15073 10.5259 6.28533 10.1985 6.28533 9.85693H4.99962H3.7139C3.7139 10.1985 3.8485 10.5259 4.08957 10.767C4.33064 11.008 4.6581 11.1426 4.99962 11.1426C5.34113 11.1426 5.66859 11.008 5.90966 10.767Z"
        fill="currentColor"
      />
    </svg>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX } from 'solid-js';
export const InApp = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
return (
<svg viewBox="0 0 10 12" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/icons/Info.tsx
Tamaño: 435 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX } from 'solid-js';

export const Info = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 16 16" {...props}>
      <path
        fill="currentColor"
        d="M8 13A5 5 0 1 1 8 3a5 5 0 0 1 0 10Zm0-1a4 4 0 1 0 0-8 4 4 0 0 0 0 8Zm.5-4.75V9.5H9v1H7v-1h.5V8.25H7v-1h1.5ZM8.75 6a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0Z"
      />
    </svg>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX } from 'solid-js';
export const Info = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
return (
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 16 16" {...props}>
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/icons/Key.tsx
Tamaño: 1887 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX } from 'solid-js';

export function Key(props?: JSX.HTMLAttributes<SVGSVGElement>) {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" {...props}>
      <path
        fill="currentColor"
        d="M12.1675 2.04492L11.5308 2.68164L11.1069 3.10645L12.9614 4.96094L12.7495 5.17383L10.894 3.31836L10.4692 3.74219L9.40967 4.80273L8.98486 5.22754L9.40967 5.65137L10.5747 6.81738L10.3628 7.03027L9.19775 5.86328L8.77295 5.43945L6.35889 7.85352L6.62744 8.26172C7.00257 8.83177 7.18147 9.50559 7.14111 10.1816L7.10986 10.4707C7.00656 11.1451 6.68818 11.7654 6.20557 12.2402L5.98877 12.4346C5.46027 12.8661 4.80786 13.1133 4.13135 13.1426L3.84033 13.1416C3.0614 13.1032 2.3236 12.7769 1.771 12.2266H1.77002C1.28602 11.744 0.974717 11.1186 0.877441 10.4473L0.849121 10.1572C0.814077 9.47419 1.00158 8.80051 1.38037 8.2373L1.55518 8.00293C2.04954 7.39769 2.75121 6.99767 3.52393 6.88086C4.29677 6.76406 5.0856 6.93884 5.73682 7.37109L6.146 7.64258L6.49268 7.29492L11.9546 1.83203L12.1675 2.04492ZM4.00537 7.10645C3.71967 7.11042 3.4363 7.15732 3.16553 7.24512L2.89893 7.34668C2.63748 7.46146 2.39532 7.61469 2.18018 7.80078L1.97803 7.99316C1.52375 8.46356 1.2476 9.0739 1.18994 9.71973L1.17822 9.99805C1.18392 10.6519 1.41417 11.2812 1.82568 11.7822L2.01318 11.9883C2.47551 12.4506 3.0805 12.7377 3.7251 12.8066L4.00342 12.8232C4.75062 12.8297 5.4708 12.5425 6.0083 12.0234L6.44775 11.5986L6.40186 11.5527C6.44537 11.4885 6.48869 11.4241 6.52686 11.3564L6.65479 11.1016C6.76956 10.84 6.84411 10.563 6.87646 10.2803L6.89404 9.99609C6.89801 9.71049 6.85899 9.42635 6.77881 9.15332L6.68506 8.88379C6.5776 8.61923 6.4315 8.3726 6.25146 8.15234L6.06006 7.94141C5.85804 7.73939 5.62719 7.56844 5.37549 7.43555L5.1167 7.31543C4.76396 7.17222 4.38604 7.10121 4.00537 7.10645Z"
        stroke="#525866"
        stroke-width="1.2"
      />
    </svg>
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX } from 'solid-js';
export function Key(props?: JSX.HTMLAttributes<SVGSVGElement>) {
return (
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="none" {...props}>
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/icons/Lock.tsx
Tamaño: 581 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

export const Lock = () => {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 16 16">
      <path
        fill="currentColor"
        d="M8 11.333c.733 0 1.333-.6 1.333-1.333S8.733 8.667 8 8.667s-1.333.6-1.333 1.333.6 1.333 1.333 1.333zm4-6h-.667V4a3.335 3.335 0 00-6.666 0v1.333H4c-.733 0-1.333.6-1.333 1.334v6.666c0 .734.6 1.334 1.333 1.334h8c.733 0 1.333-.6 1.333-1.334V6.667c0-.734-.6-1.334-1.333-1.334zM5.933 4c0-1.14.927-2.067 2.067-2.067 1.14 0 2.067.927 2.067 2.067v1.333H5.933V4zM12 13.333H4V6.667h8v6.666z"
      ></path>
    </svg>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

export const Lock = () => {
return (
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 16 16">
<path
fill="currentColor"
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/icons/MarkAsArchived.tsx
Tamaño: 2005 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX } from 'solid-js';

export const MarkAsArchived = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
  return (
    <svg viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
      <path
        d="M2.29671 10C1.78742 10 1.39807 9.85716 1.12864 9.57149C0.862497 9.28581 0.729426 8.86623 0.729426 8.31274V2.64594H1.69543V8.29668C1.69543 8.52163 1.74964 8.69487 1.85806 8.81624C1.96978 8.93408 2.12914 8.99301 2.33614 8.99301H7.66389C7.86764 8.99301 8.02366 8.93408 8.13209 8.81624C8.24385 8.69487 8.29965 8.52163 8.29965 8.29668V2.64594H9.27059V8.31274C9.27059 8.8627 9.13591 9.28048 8.86648 9.56608C8.59705 9.85536 8.20931 10 7.70333 10H2.29671ZM3.41056 5.34543C3.29556 5.34543 3.20028 5.30438 3.1247 5.22226C3.04913 5.14015 3.01134 5.03304 3.01134 4.90089V4.72949C3.01134 4.59737 3.04749 4.49204 3.11977 4.41348C3.19535 4.33492 3.29227 4.29564 3.41056 4.29564H6.5944C6.71271 4.29564 6.80795 4.33492 6.88026 4.41348C6.95582 4.49204 6.9936 4.59737 6.9936 4.72949V4.90089C6.9936 5.03304 6.95582 5.14015 6.88026 5.22226C6.8047 5.30438 6.70939 5.34543 6.5944 5.34543H3.41056ZM1.05964 3.16014C0.724502 3.16014 0.463285 3.05301 0.276004 2.83877C0.0920037 2.62095 0 2.33172 0 1.97107V1.18907C0 0.824846 0.0952841 0.535614 0.28586 0.321373C0.476428 0.107124 0.734358 0 1.05964 0H8.94536C9.27715 0 9.53511 0.107124 9.71911 0.321373C9.90642 0.535614 10 0.824846 10 1.18907V1.97107C10 2.33172 9.90642 2.62095 9.71911 2.83877C9.53511 3.05301 9.27715 3.16014 8.94536 3.16014H1.05964ZM1.24693 2.19067H8.75805C8.87304 2.19067 8.95516 2.16211 9.00448 2.10497C9.05372 2.04427 9.07838 1.95322 9.07838 1.83181V1.32833C9.07838 1.20335 9.05372 1.1123 9.00448 1.05517C8.95516 0.99803 8.87304 0.969462 8.75805 0.969462H1.24693C1.13193 0.969462 1.04814 0.99803 0.995567 1.05517C0.946281 1.1123 0.921638 1.20335 0.921638 1.32833V1.83181C0.921638 1.95322 0.946281 2.04427 0.995567 2.10497C1.04814 2.16211 1.13193 2.19067 1.24693 2.19067Z"
        fill="currentColor"
      />
    </svg>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX } from 'solid-js';
export const MarkAsArchived = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
return (
<svg viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/icons/MarkAsArchivedRead.tsx
Tamaño: 2432 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX } from 'solid-js';

export const MarkAsArchivedRead = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
  return (
    <svg viewBox="0 0 11 11" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
      <path
        d="M2.17256 10.999C1.69081 10.999 1.3225 10.8562 1.06763 10.5705C0.815875 10.2848 0.689997 9.86525 0.689997 9.31177V3.64497H1.60378V9.2957C1.60378 9.52066 1.65506 9.6939 1.75763 9.81526C1.8633 9.93311 2.01405 9.99203 2.20986 9.99203H7.24963C7.44236 9.99203 7.58995 9.93311 7.69252 9.81526C7.79823 9.6939 7.85102 9.52066 7.85102 9.2957V3.64497H8.76947V9.31177C8.76947 9.86173 8.64208 10.2795 8.38721 10.5651C8.13235 10.8544 7.76556 10.999 7.28693 10.999H2.17256ZM1.00236 4.15916C0.68534 4.15916 0.438242 4.05204 0.261085 3.83779C0.0870305 3.61997 0 3.33074 0 2.97009V2.18809C0 1.82387 0.0901336 1.53464 0.270408 1.3204C0.450675 1.10615 0.694663 0.999023 1.00236 0.999023H8.46182C8.77568 0.999023 9.0197 1.10615 9.19375 1.3204C9.37094 1.53464 9.45946 1.82387 9.45946 2.18809V2.97009C9.45946 3.33074 9.37094 3.61997 9.19375 3.83779C9.0197 4.05204 8.77568 4.15916 8.46182 4.15916H1.00236ZM1.17953 3.1897H8.28464C8.39342 3.1897 8.4711 3.16113 8.51775 3.10399C8.56433 3.04329 8.58765 2.95224 8.58765 2.83083V2.32735C8.58765 2.20238 8.56433 2.11132 8.51775 2.05419C8.4711 1.99705 7.51461 1.96849 7.40583 1.96849H1.17953C1.07074 1.96849 0.991485 1.99705 0.941753 2.05419C0.895131 2.11132 0.87182 2.20238 0.87182 2.32735V2.83083C0.87182 2.95224 0.895131 3.04329 0.941753 3.10399C0.991485 3.16113 1.07074 3.1897 1.17953 3.1897Z"
        fill="currentColor"
      />
      <path
        d="M9.67298 0.553711C9.84703 0.556646 10.0146 0.614475 10.1535 0.716797L10.2208 0.771484L10.2814 0.833008C10.3958 0.960612 10.4679 1.11928 10.4913 1.28711L10.4992 1.37109L10.4982 1.45605C10.4872 1.64689 10.4124 1.8301 10.2833 1.97559L10.2843 1.97656L7.55482 5.15039L7.55384 5.14941C7.40234 5.3265 7.18382 5.43557 6.94642 5.44336L6.93861 5.44434H6.92005V5.44336C6.69203 5.44397 6.47619 5.35201 6.31947 5.19141L6.31849 5.18945L5.29505 4.13184C5.08531 3.91498 5.00658 3.60427 5.08118 3.31641L5.11634 3.21094C5.2129 2.97124 5.41476 2.78187 5.67396 2.70996L5.78626 2.68652C6.01138 2.65637 6.23763 2.72008 6.41419 2.85938L6.49818 2.93555L6.8849 3.33496L9.0138 0.859375V0.860352C9.15512 0.688807 9.35911 0.576792 9.58509 0.556641L9.67298 0.553711Z"
        fill="currentColor"
        stroke="white"
      />
    </svg>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX } from 'solid-js';
export const MarkAsArchivedRead = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
return (
<svg viewBox="0 0 11 11" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/icons/MarkAsRead.tsx
Tamaño: 2110 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX } from 'solid-js';

export const MarkAsRead = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
  return (
    <svg viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
      <g clip-path="url(#clip0_3445_1172)">
        <path
          d="M9 9.99902H1C0.867383 9.99902 0.7402 9.94635 0.64645 9.85257C0.552667 9.75882 0.5 9.63164 0.5 9.49902V0.499023C0.5 0.366407 0.552669 0.239223 0.64645 0.145473C0.7402 0.0516901 0.867383 -0.000976562 1 -0.000976562H6.25C6.42865 -0.000976562 6.59368 0.0943401 6.68301 0.249023C6.77233 0.403707 6.77233 0.59434 6.68301 0.749023C6.59368 0.903707 6.42865 0.999023 6.25 0.999023H1.5V8.99902H8.5V4.49902C8.5 4.32037 8.59532 4.15534 8.75 4.06602C8.90468 3.97669 9.09532 3.97669 9.25 4.06602C9.40468 4.15534 9.5 4.32037 9.5 4.49902V9.49902C9.5 9.63164 9.44733 9.75882 9.35355 9.85257C9.2598 9.94636 9.13262 9.99902 9 9.99902Z"
          fill="currentColor"
        />
        <path
          d="M7.5 8.24902H2.5C2.32135 8.24902 2.15632 8.15371 2.06699 7.99902C1.97767 7.84434 1.97767 7.65371 2.06699 7.49902C2.15632 7.34434 2.32135 7.24902 2.5 7.24902H7.5C7.67865 7.24902 7.84368 7.34434 7.93301 7.49902C8.02233 7.65371 8.02233 7.84434 7.93301 7.99902C7.84368 8.15371 7.67865 8.24902 7.5 8.24902Z"
          fill="currentColor"
        />
        <path
          d="M4.75 6.49901C4.61709 6.49979 4.48936 6.44761 4.39498 6.35403L2.89498 4.85403C2.76816 4.72717 2.71865 4.54235 2.76507 4.36907C2.81149 4.19583 2.94681 4.06051 3.12005 4.01409C3.29332 3.96767 3.47816 4.01718 3.60501 4.14401L4.73001 5.269L8.37501 1.16901C8.46056 1.06279 8.58578 0.996155 8.72169 0.984497C8.8576 0.972843 8.99233 1.01718 9.09474 1.10728C9.19712 1.19738 9.25825 1.32541 9.26398 1.46167C9.26968 1.59796 9.21948 1.73065 9.12502 1.82902L5.12502 6.32902C5.03371 6.43306 4.90337 6.49461 4.76502 6.49901L4.75 6.49901Z"
          fill="currentColor"
        />
      </g>
      <defs>
        <clipPath id="clip0_3445_1172">
          <rect width="10" height="10" fill="white" transform="translate(0 -0.000976562)" />
        </clipPath>
      </defs>
    </svg>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX } from 'solid-js';
export const MarkAsRead = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
return (
<svg viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/icons/MarkAsUnarchived.tsx
Tamaño: 759 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX } from 'solid-js';

export const MarkAsUnarchived = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
  return (
    <svg viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
      <path
        d="M3.15789 2.99902V4.99902L0 2.49902L3.15789 -0.000976562V1.99902H5.78947C6.90618 1.99902 7.97714 2.42045 8.76677 3.1706C9.55639 3.92074 10 4.93816 10 5.99902C10 7.05989 9.55639 8.0773 8.76677 8.82745C7.97714 9.5776 6.90618 9.99902 5.78947 9.99902H1.05263V8.99902H5.78947C6.627 8.99902 7.43022 8.68295 8.02244 8.12034C8.61466 7.55773 8.94737 6.79467 8.94737 5.99902C8.94737 5.20337 8.61466 4.44031 8.02244 3.8777C7.43022 3.31509 6.627 2.99902 5.78947 2.99902H3.15789Z"
        fill="currentColor"
      />
    </svg>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX } from 'solid-js';
export const MarkAsUnarchived = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
return (
<svg viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/icons/MarkAsUnread.tsx
Tamaño: 577 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX } from 'solid-js';

export const MarkAsUnread = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
  return (
    <svg viewBox="0 0 11 11" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
      <path
        d="M6.8 1.49902H1.5C0.947715 1.49902 0.5 1.94674 0.5 2.49902V9.49902C0.5 10.0513 0.947715 10.499 1.5 10.499H8.5C9.05228 10.499 9.5 10.0513 9.5 9.49902V4.19902"
        stroke="currentColor"
        stroke-miterlimit="1"
        stroke-linecap="round"
      />
      <circle cx="9.25" cy="1.74902" r="1.25" fill="currentColor" />
    </svg>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX } from 'solid-js';
export const MarkAsUnread = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
return (
<svg viewBox="0 0 11 11" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/icons/NodeTree.tsx
Tamaño: 1629 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX } from 'solid-js';

export const NodeTree = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 14" {...props}>
      <path
        fill="currentColor"
        d="M5.95 1.75c.29 0 .525.235.525.525v2.1c0 .29-.235.525-.525.525H4.9v1.05h2.625v-.525c0-.29.235-.525.525-.525h3.15c.29 0 .525.235.525.525v2.1c0 .29-.235.525-.525.525H8.05a.525.525 0 0 1-.525-.525V7H4.9v3.15h2.625v-.525c0-.29.235-.525.525-.525h3.15c.29 0 .525.235.525.525v2.1c0 .29-.235.525-.525.525H8.05a.525.525 0 0 1-.525-.525V11.2h-3.15a.525.525 0 0 1-.525-.525V4.9H2.8a.525.525 0 0 1-.525-.525v-2.1c0-.29.235-.525.525-.525h3.15Zm4.725 8.4h-2.1v1.05h2.1v-1.05Zm0-4.2h-2.1V7h2.1V5.95ZM5.425 2.8h-2.1v1.05h2.1V2.8Z"
      />
      <path
        fill="url(#a)"
        d="M5.95 1.75c.29 0 .525.235.525.525v2.1c0 .29-.235.525-.525.525H4.9v1.05h2.625v-.525c0-.29.235-.525.525-.525h3.15c.29 0 .525.235.525.525v2.1c0 .29-.235.525-.525.525H8.05a.525.525 0 0 1-.525-.525V7H4.9v3.15h2.625v-.525c0-.29.235-.525.525-.525h3.15c.29 0 .525.235.525.525v2.1c0 .29-.235.525-.525.525H8.05a.525.525 0 0 1-.525-.525V11.2h-3.15a.525.525 0 0 1-.525-.525V4.9H2.8a.525.525 0 0 1-.525-.525v-2.1c0-.29.235-.525.525-.525h3.15Zm4.725 8.4h-2.1v1.05h2.1v-1.05Zm0-4.2h-2.1V7h2.1V5.95ZM5.425 2.8h-2.1v1.05h2.1V2.8Z"
      />
      <defs>
        <linearGradient id="a" x1="2.275" x2="11.725" y1="6.982" y2="7.018" gradientUnits="userSpaceOnUse">
          <stop stop-color="currentColor" />
          <stop offset="1" stop-color="currentColor" />
        </linearGradient>
      </defs>
    </svg>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX } from 'solid-js';
export const NodeTree = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
return (
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 14" {...props}>
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/icons/Novu.tsx
Tamaño: 825 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX } from 'solid-js';

export const Novu = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 13 12" {...props}>
      <path
        fill="currentColor"
        d="M9.787.98A5.972 5.972 0 006.5 0c-.668 0-1.31.11-1.911.31L9.187 4.94c.221.222.6.065.6-.248V.98z"
      ></path>
      <path
        fill="currentColor"
        d="M2.879 1.216A5.99 5.99 0 00.5 6c0 1.134.315 2.195.862 3.1V7.309c0-1.966 2.379-2.946 3.764-1.552l4.995 5.027A5.99 5.99 0 0012.5 6a5.972 5.972 0 00-.862-3.1v1.791c0 1.966-2.379 2.946-3.764 1.552L2.879 1.216z"
      ></path>
      <path
        fill="currentColor"
        d="M8.411 11.69L3.813 7.06a.351.351 0 00-.6.248v3.711c.944.62 2.073.98 3.287.98.668 0 1.31-.11 1.911-.31z"
      ></path>
    </svg>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX } from 'solid-js';
export const Novu = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
return (
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 13 12" {...props}>
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/icons/Push.tsx
Tamaño: 1794 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX } from 'solid-js';

export const Push = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
  return (
    <svg viewBox="0 0 10 16" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
      <path
        d="M4.12531 1.8999C3.94958 1.8999 3.80713 2.04235 3.80713 2.21808C3.80713 2.39382 3.94958 2.53627 4.12531 2.53627H6.0344C6.21013 2.53627 6.35258 2.39382 6.35258 2.21808C6.35258 2.04235 6.21013 1.8999 6.0344 1.8999H4.12531Z"
        fill="currentColor"
      />
      <path
        d="M4.12531 1.8999C3.94958 1.8999 3.80713 2.04235 3.80713 2.21808C3.80713 2.39382 3.94958 2.53627 4.12531 2.53627H6.0344C6.21013 2.53627 6.35258 2.39382 6.35258 2.21808C6.35258 2.04235 6.21013 1.8999 6.0344 1.8999H4.12531Z"
        stroke="currentColor"
      />
      <path
        d="M2.69329 1.46818H7.30693C7.75127 1.46818 8.11147 1.82839 8.11147 2.27273V13.7273C8.11147 14.1716 7.75127 14.5318 7.30693 14.5318H2.69329C2.24896 14.5318 1.88875 14.1716 1.88875 13.7273V2.27273C1.88875 1.82839 2.24896 1.46818 2.69329 1.46818ZM2.69329 0.85C1.90754 0.85 1.27057 1.48698 1.27057 2.27273V2.95695C1.17568 3.00972 1.11147 3.111 1.11147 3.22727V3.54545C1.11147 3.64155 1.15532 3.7274 1.22411 3.78409C1.15532 3.84078 1.11147 3.92663 1.11147 4.02273V4.65909C1.11147 4.75519 1.15532 4.84104 1.22411 4.89773C1.15532 4.95442 1.11147 5.04027 1.11147 5.13636V6.09091C1.11147 6.20718 1.17568 6.30846 1.27057 6.36123V13.7273C1.27057 14.513 1.90754 15.15 2.69329 15.15H7.30693C8.09268 15.15 8.72966 14.513 8.72966 13.7273V6.36123C8.82454 6.30846 8.88875 6.20718 8.88875 6.09091V4.81818C8.88875 4.70191 8.82454 4.60063 8.72966 4.54786V2.27273C8.72966 1.48698 8.09268 0.85 7.30693 0.85H2.69329Z"
        fill="currentColor"
        stroke="currentColor"
        stroke-width="0.3"
      />
    </svg>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX } from 'solid-js';
export const Push = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
return (
<svg viewBox="0 0 10 16" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/icons/RouteFill.tsx
Tamaño: 1020 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX } from 'solid-js';

export const RouteFill = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 14" {...props}>
      <path
        fill="currentColor"
        d="M2.8 8.575V5.162a2.362 2.362 0 1 1 4.725 0v3.675a1.313 1.313 0 1 0 2.625 0V5.335a1.575 1.575 0 1 1 1.05 0v3.502a2.362 2.362 0 1 1-4.725 0V5.162a1.312 1.312 0 1 0-2.625 0v3.413h1.575l-2.1 2.625-2.1-2.625H2.8Z"
      />
      <path
        fill="url(#a)"
        d="M2.8 8.575V5.162a2.362 2.362 0 1 1 4.725 0v3.675a1.313 1.313 0 1 0 2.625 0V5.335a1.575 1.575 0 1 1 1.05 0v3.502a2.362 2.362 0 1 1-4.725 0V5.162a1.312 1.312 0 1 0-2.625 0v3.413h1.575l-2.1 2.625-2.1-2.625H2.8Z"
      />
      <defs>
        <linearGradient id="a" x1="1.225" x2="12.251" y1="6.722" y2="6.779" gradientUnits="userSpaceOnUse">
          <stop stop-color="currentColor" />
          <stop offset="1" stop-color="currentColor" />
        </linearGradient>
      </defs>
    </svg>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX } from 'solid-js';
export const RouteFill = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
return (
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 14" {...props}>
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/icons/Sms.tsx
Tamaño: 2849 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX } from 'solid-js';

export const Sms = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
  return (
    <svg viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
      <path
        d="M5.00051 9.28364C7.76195 9.28364 10 7.20598 10 4.64182C10 2.07766 7.76195 0 5.00051 0C2.23907 0 0.00101462 2.07766 0.00101462 4.64182C0.00101462 5.64829 0.346683 6.57889 0.932561 7.33988C0.895455 7.88663 0.709927 8.37313 0.514634 8.74358C0.407223 8.94889 0.297859 9.11404 0.21779 9.22562C0.176778 9.28141 0.145531 9.32381 0.122096 9.35282C0.110379 9.36621 0.102567 9.37737 0.096708 9.38407L0.0908493 9.39076C0.00101462 9.49342 -0.0243734 9.64517 0.0244497 9.77907C0.0732729 9.91297 0.186543 10 0.313483 10C0.873973 10 1.43837 9.80138 1.90707 9.56929C2.35429 9.34613 2.73511 9.08056 2.96751 8.88641C3.58854 9.14305 4.27597 9.28587 5.00051 9.28587V9.28364ZM1.87582 4.03481C1.87582 3.58179 2.19806 3.21357 2.5945 3.21357H2.96946C3.14132 3.21357 3.28193 3.37425 3.28193 3.57063C3.28193 3.76702 3.14132 3.92769 2.96946 3.92769H2.5945C2.54177 3.92769 2.50076 3.97679 2.50076 4.03481C2.50076 4.07052 2.51638 4.10399 2.54373 4.12408L3.11789 4.56148C3.31904 4.71323 3.43817 4.96987 3.43817 5.2466C3.43817 5.69962 3.11593 6.06784 2.71949 6.06784L2.18829 6.07007C2.01644 6.07007 1.87582 5.9094 1.87582 5.71301C1.87582 5.51663 2.01644 5.35595 2.18829 5.35595H2.71949C2.77222 5.35595 2.81323 5.30685 2.81323 5.24883C2.81323 5.21312 2.79761 5.17965 2.77026 5.15956L2.1961 4.72216C1.99691 4.56818 1.87582 4.31154 1.87582 4.03481ZM7.28153 3.21357H7.65649C7.82834 3.21357 7.96896 3.37425 7.96896 3.57063C7.96896 3.76702 7.82834 3.92769 7.65649 3.92769H7.28153C7.2288 3.92769 7.18779 3.97679 7.18779 4.03481C7.18779 4.07052 7.20341 4.10399 7.23075 4.12408L7.80491 4.56148C8.00411 4.71323 8.12519 4.96987 8.12519 5.2466C8.12519 5.69962 7.80296 6.06784 7.40651 6.06784L6.87532 6.07007C6.70346 6.07007 6.56285 5.9094 6.56285 5.71301C6.56285 5.51663 6.70346 5.35595 6.87532 5.35595H7.40651C7.45924 5.35595 7.50025 5.30685 7.50025 5.24883C7.50025 5.21312 7.48463 5.17965 7.45729 5.15956L6.88313 4.72216C6.68393 4.57041 6.56285 4.31377 6.56285 4.03705C6.56285 3.58402 6.88508 3.2158 7.28153 3.2158V3.21357ZM4.31308 3.35639L5.00051 4.40304L5.68794 3.35639C5.76801 3.23365 5.90862 3.18233 6.03751 3.23142C6.1664 3.28052 6.25038 3.41665 6.25038 3.57063V5.71301C6.25038 5.9094 6.10977 6.07007 5.93791 6.07007C5.76605 6.07007 5.62544 5.9094 5.62544 5.71301V4.64182L5.25048 5.21312C5.19189 5.30239 5.09815 5.35595 5.00051 5.35595C4.90286 5.35595 4.80912 5.30239 4.75053 5.21312L4.37557 4.64182V5.71301C4.37557 5.9094 4.23496 6.07007 4.0631 6.07007C3.89124 6.07007 3.75063 5.9094 3.75063 5.71301V3.57063C3.75063 3.41665 3.83656 3.28052 3.9635 3.23142C4.09044 3.18233 4.23105 3.23365 4.31308 3.35639Z"
        fill="currentColor"
      />
    </svg>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX } from 'solid-js';
export const Sms = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
return (
<svg viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/icons/Unread.tsx
Tamaño: 897 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX } from 'solid-js';

export const Unread = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
  return (
    <svg viewBox="0 0 10 8" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
      <path
        d="M1.0119 0.347055C1.06274 0.143703 1.26565 -0.000976562 1.5 -0.000976562H8.5C8.73435 -0.000976562 8.93725 0.143703 8.9881 0.347055L9.9881 4.34707C9.996 4.37871 10 4.41102 10 4.44347V7.55458C10 7.80005 9.77615 7.99902 9.5 7.99902H0.5C0.22386 7.99902 0 7.80005 0 7.55458V4.44347C0 4.41102 0.00399495 4.37871 0.011905 4.34707L1.0119 0.347055ZM1.90108 0.887912L1.12331 3.99902H3.5C3.5 4.73542 4.17155 5.33236 5 5.33236C5.82845 5.33236 6.5 4.73542 6.5 3.99902H8.8767L8.0989 0.887912H1.90108ZM7.292 4.88791C6.9062 5.67276 6.02515 6.22125 5 6.22125C3.97484 6.22125 3.0938 5.67276 2.70802 4.88791H1V7.11013H9V4.88791H7.292Z"
        fill="currentColor"
      />
    </svg>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX } from 'solid-js';
export const Unread = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
return (
<svg viewBox="0 0 10 8" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/icons/Unsnooze.tsx
Tamaño: 654 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import { JSX } from 'solid-js';

export const Unsnooze = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
  return (
    <svg viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
      <path
        d="M4.99992 2.91634V4.99967M4.79992 5.39616L3.27392 6.46553M1.66659 1.66634L8.33325 8.33301M9.16658 4.99967C9.16658 7.30086 7.30111 9.16634 4.99992 9.16634C2.69873 9.16634 0.833252 7.30086 0.833252 4.99967C0.833252 2.69849 2.69873 0.833008 4.99992 0.833008C7.30111 0.833008 9.16658 2.69849 9.16658 4.99967Z"
        stroke="currentColor"
        stroke-linecap="round"
        stroke-linejoin="round"
      />
    </svg>
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import { JSX } from 'solid-js';
export const Unsnooze = (props?: JSX.HTMLAttributes<SVGSVGElement>) => {
return (
<svg viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/icons/index.ts
Tamaño: 696 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './ArrowDown';
export * from './ArrowDropDown';
export * from './ArrowLeft';
export * from './ArrowRight';
export * from './Bell';
export * from './CalendarSchedule';
export * from './Chat';
export * from './Check';
export * from './Clock';
export * from './Cogs';
export * from './Copy';
export * from './Dots';
export * from './Email';
export * from './InApp';
export * from './Lock';
export * from './MarkAsArchived';
export * from './MarkAsArchivedRead';
export * from './MarkAsRead';
export * from './MarkAsUnarchived';
export * from './MarkAsUnread';
export * from './Novu';
export * from './Push';
export * from './Sms';
export * from './Unread';
export * from './Unsnooze';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/internal/buildContextKey.ts
Tamaño: 905 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Context } from '../../types';

/**
 * Builds a compact, stable string key from context objects by extracting only type:id pairs.
 *
 * This avoids including large `data` payloads in:
 * - React dependency arrays (useMemo)
 * - Web Locks API channel names (prevents duplicate subscriptions)
 *
 * @example
 * buildContextKey({ tenant: { id: "inbox-1", data: {...} } }) // "tenant:inbox-1"
 * buildContextKey({ tenant: "inbox-1" }) // "tenant:inbox-1"
 * buildContextKey(undefined) // ""
 */
export function buildContextKey(context: Context | undefined): string {
  if (!context) {
    return '';
  }

  const keys: string[] = [];
  for (const [type, value] of Object.entries(context)) {
    if (value) {
      const id = typeof value === 'string' ? value : value.id;
      keys.push(`${type}:${id}`);
    }
  }

  // Sort for consistency (order shouldn't matter)
  return keys.sort().join(',');
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - buildContextKey(context: Context | undefined)
Declaraciones 'export' encontradas:
- export function buildContextKey

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/internal/buildSubscriber.ts
Tamaño: 550 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Subscriber } from '../../types';

export function buildSubscriber({
  subscriberId,
  subscriber,
}: {
  subscriberId: string | undefined;
  subscriber: Subscriber | string | undefined;
}): Subscriber {
  // subscriber object
  if (subscriber) {
    return typeof subscriber === 'string' ? { subscriberId: subscriber } : subscriber;
  }

  // subscriberId
  if (subscriberId) {
    return { subscriberId: subscriberId as string };
  }

  // missing - keyless subscriber, the api will generate a subscriberId
  return { subscriberId: '' };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - buildSubscriber({
  subscriberId,
  subscriber,
}: {
  subscriberId: string | undefined;
  subscriber: Subscriber | string | undefined;
})
Declaraciones 'export' encontradas:
- export function buildSubscriber

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/internal/index.ts
Tamaño: 103 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './buildContextKey';
export * from './buildSubscriber';
export * from './parseMarkdown';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/internal/parseMarkdown.tsx
Tamaño: 848 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

export interface Token {
  type: 'bold' | 'text';
  content: string;
}

export const parseMarkdownIntoTokens = (text: string): Token[] => {
  const tokens: Token[] = [];
  let buffer = '';
  let inBold = false;

  for (let i = 0; i < text.length; i += 1) {
    // Check if it's an escaped character
    if (text[i] === '\\' && text[i + 1] === '*') {
      buffer += '*';
      i += 1;
    }
    // Check for bold marker **
    else if (text[i] === '*' && text[i + 1] === '*') {
      if (buffer) {
        tokens.push({ type: inBold ? 'bold' : 'text', content: buffer });
        buffer = '';
      }
      inBold = !inBold;
      i += 1;
    } else {
      buffer += text[i];
    }
  }

  // Push any remaining buffered text as a token
  if (buffer) {
    tokens.push({ type: inBold ? 'bold' : 'text', content: buffer });
  }

  return tokens;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

export interface Token {
type: 'bold' | 'text';
content: string;
}
// Check if it's an escaped character
// Check for bold marker **
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/src/ui/themes/dark.ts
Tamaño: 1435 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { Theme } from '../types';

export const dark: Theme = {
  variables: {
    colorNeutral: 'white',
    colorBackground: '#1A1A1A',
    colorForeground: '#EDEDEF',
    colorSecondary: '#383838',
    colorSecondaryForeground: '#EDEDEF',
    colorShadow: 'black',
    colorRing: '#E1E4EA',
    colorStripes: '#FF8447',
  },
  elements: {
    severityHigh__bellContainer:
      '[--bell-gradient-start:var(--nv-color-severity-high)] [--bell-gradient-end:oklch(from_var(--nv-color-severity-high)_80%_c_h)]',
    severityMedium__bellContainer:
      '[--bell-gradient-start:var(--nv-color-severity-medium)] [--bell-gradient-end:oklch(from_var(--nv-color-severity-medium)_80%_c_h)]',
    severityLow__bellContainer:
      '[--bell-gradient-start:var(--nv-color-severity-low)] [--bell-gradient-end:oklch(from_var(--nv-color-severity-low)_80%_c_h)]',
    bellContainer:
      '[--bell-gradient-start:var(--nv-color-foreground)] [--bell-gradient-end:oklch(from_var(--nv-color-foreground)_80%_c_h)]',
    severityGlowHigh__bellSeverityGlow: 'nt-bg-severity-high-alpha-300 before:nt-bg-severity-high-alpha-300',
    severityGlowMedium__bellSeverityGlow: 'nt-bg-severity-medium-alpha-300 before:nt-bg-severity-medium-alpha-300',
    severityGlowLow__bellSeverityGlow: 'nt-bg-severity-low-alpha-300 before:nt-bg-severity-low-alpha-300',
    bellSeverityGlow: 'nt-bg-severity-none-alpha-300 before:nt-bg-severity-none-alpha-300',
  },
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ui/themes/index.ts
Tamaño: 24 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './dark';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/utils/arrays.ts
Tamaño: 301 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export const arrayValuesEqual = (arr1?: Array<unknown>, arr2?: Array<unknown>) => {
  if (arr1 === arr2) {
    return true;
  }

  if (!arr1 || !arr2) {
    return false;
  }

  if (arr1.length !== arr2.length) {
    return false;
  }

  return arr1.every((value, index) => value === arr2[index]);
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - arrayValuesEqual(arr1?: Array<unknown>, arr2?: Array<unknown>))
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/utils/errors.ts
Tamaño: 196 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export class NovuError extends Error {
  originalError: Error;

  constructor(message: string, originalError: unknown) {
    super(message);
    this.originalError = originalError as Error;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class NovuError

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/utils/is-browser.ts
Tamaño: 72 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export function isBrowser() {
  return typeof window !== 'undefined';
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - isBrowser()
Declaraciones 'export' encontradas:
- export function isBrowser

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/utils/notification-utils.ts
Tamaño: 5323 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Notification, NotificationFilter, NotificationStatus, SeverityLevelEnum } from '../types';
import { arrayValuesEqual } from './arrays';

export const SEEN_OR_UNSEEN = [NotificationStatus.SEEN, NotificationStatus.UNSEEN];
export const READ_OR_UNREAD = [NotificationStatus.READ, NotificationStatus.UNREAD];

export const areTagsEqual = (tags1?: string[], tags2?: string[]) => {
  return arrayValuesEqual(tags1, tags2) || (!tags1 && tags2?.length === 0) || (tags1?.length === 0 && !tags2);
};

export const areSeveritiesEqual = (
  el1?: SeverityLevelEnum | SeverityLevelEnum[],
  el2?: SeverityLevelEnum | SeverityLevelEnum[]
) => {
  const severity1 = Array.isArray(el1) ? el1 : el1 ? [el1] : [];
  const severity2 = Array.isArray(el2) ? el2 : el2 ? [el2] : [];

  return arrayValuesEqual(severity1, severity2);
};

export const areDataEqual = (data1?: Record<string, unknown>, data2?: Record<string, unknown>) => {
  if (!data1 && !data2) {
    return true;
  }

  if (!data1 || !data2) {
    return false;
  }

  try {
    return JSON.stringify(data1) === JSON.stringify(data2);
  } catch (e) {
    // In case of circular dependencies or other stringify errors, fall back to false
    return false;
  }
};

export const isSameFilter = (filter1: NotificationFilter, filter2: NotificationFilter) => {
  return (
    areDataEqual(filter1.data, filter2.data) &&
    areTagsEqual(filter1.tags, filter2.tags) &&
    filter1.read === filter2.read &&
    filter1.archived === filter2.archived &&
    filter1.snoozed === filter2.snoozed &&
    filter1.seen === filter2.seen &&
    areSeveritiesEqual(filter1.severity, filter2.severity)
  );
};

export function checkNotificationDataFilter(
  notificationData: Notification['data'],
  filterData: NotificationFilter['data']
): boolean {
  if (!filterData || Object.keys(filterData).length === 0) {
    // No data filter defined, so it's a match on the data aspect.
    return true;
  }
  if (!notificationData) {
    // Filter has data criteria, but the notification has no data.
    return false;
  }

  return Object.entries(filterData).every(([key, filterValue]) => {
    const notifValue = notificationData[key];

    if (notifValue === undefined && filterValue !== undefined) {
      // Key is specified in filter, but not present in notification data.
      return false;
    }

    if (Array.isArray(filterValue)) {
      if (Array.isArray(notifValue)) {
        /*
         * Both filter value and notification value are arrays.
         * Check for set equality (same elements, regardless of order).
         */
        if (filterValue.length !== notifValue.length) return false;
        /*
         * Ensure elements are of primitive types for direct sort and comparison.
         * If elements can be objects, a more sophisticated comparison is needed.
         */
        const sortedFilterValue = [...(filterValue as (string | number | boolean)[])].sort();
        const sortedNotifValue = [...(notifValue as (string | number | boolean)[])].sort();

        return sortedFilterValue.every((val, index) => val === sortedNotifValue[index]);
      } else {
        /*
         * Filter value is an array, notification value is scalar.
         * Check if the scalar notification value is present in the filter array.
         */
        return (filterValue as unknown[]).includes(notifValue);
      }
    } else {
      // Filter value is scalar. Notification value must be equal.
      return notifValue === filterValue;
    }
  });
}

/**
 * Check if notification tags match the filter tags criteria.
 */
export function checkNotificationTagFilter(
  notificationTags: string[] | undefined,
  filterTags: string[] | undefined
): boolean {
  if (!filterTags || filterTags.length === 0) {
    // No tag filter specified, so it matches
    return true;
  }

  if (!notificationTags || notificationTags.length === 0) {
    // Filter has tags but notification has none
    return false;
  }

  // Check if notification has any of the required tags
  return filterTags.some((tag) => notificationTags.includes(tag));
}

/**
 * Check if notification matches basic filter criteria (read, seen, archived, snoozed).
 */
export function checkBasicFilters(
  notification: Notification,
  filter: Pick<NotificationFilter, 'read' | 'seen' | 'archived' | 'snoozed'>
): boolean {
  // Check read status
  if (filter.read !== undefined && notification.isRead !== filter.read) {
    return false;
  }

  // Check seen status
  if (filter.seen !== undefined && notification.isSeen !== filter.seen) {
    return false;
  }

  // Check archived status
  if (filter.archived !== undefined && notification.isArchived !== filter.archived) {
    return false;
  }

  // Check snoozed status
  if (filter.snoozed !== undefined && notification.isSnoozed !== filter.snoozed) {
    return false;
  }

  return true;
}

/**
 * Complete notification filter check combining all criteria.
 * This is the main function that should be used by both React and SolidJS implementations.
 */
export function checkNotificationMatchesFilter(notification: Notification, filter: NotificationFilter): boolean {
  return (
    checkBasicFilters(notification, filter) &&
    checkNotificationTagFilter(notification.tags, filter.tags) &&
    checkNotificationDataFilter(notification.data, filter.data)
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - checkNotificationDataFilter(notificationData: Notification['data'],
  filterData: NotificationFilter['data'])
 - checkNotificationTagFilter(notificationTags: string[] | undefined,
  filterTags: string[] | undefined)
 - checkBasicFilters(notification: Notification,
  filter: Pick<NotificationFilter, 'read' | 'seen' | 'archived' | 'snoozed'>)
 - checkNotificationMatchesFilter(notification: Notification, filter: NotificationFilter)
Asignaciones con arrow functions encontradas (posibles funciones):
 - areTagsEqual(tags1?: string[], tags2?: string[]))
 - areSeveritiesEqual(el1?: SeverityLevelEnum | SeverityLevelEnum[],
  el2?: SeverityLevelEnum | SeverityLevelEnum[]
))
 - areDataEqual(data1?: Record<string, unknown>, data2?: Record<string, unknown>))
 - isSameFilter(filter1: NotificationFilter, filter2: NotificationFilter))
 - sortedNotifValue([...(notifValue as (string | number | boolean)[])].sort();

        return sortedFilterValue.every((...)
Declaraciones 'export' encontradas:
- export  const
- export  const
- export  const
- export  const
- export  const
- export  const
- export function checkNotificationDataFilter
- export function checkNotificationTagFilter
- export function checkBasicFilters
- export function checkNotificationMatchesFilter

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/utils/strings.ts
Tamaño: 101 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export const capitalize = (str: string) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - capitalize(str: string))
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ws/base-socket.ts
Tamaño: 264 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { SocketEventNames } from '../event-emitter';
import type { Result } from '../types';

export interface BaseSocketInterface {
  isSocketEvent(eventName: string): eventName is SocketEventNames;
  connect(): Result<void>;
  disconnect(): Result<void>;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  interface

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ws/index.ts
Tamaño: 123 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './base-socket';
export * from './party-socket';
export * from './socket';
export * from './socket-factory';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ws/party-socket.ts
Tamaño: 7407 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import 'event-target-polyfill';
import { WebSocket } from 'partysocket';
import { InboxService } from '../api';
import { BaseModule } from '../base-module';
import {
  NotificationReceivedEvent,
  NotificationUnreadEvent,
  NotificationUnseenEvent,
  NovuEventEmitter,
  SocketEventNames,
} from '../event-emitter';
import { Notification } from '../notifications';
import {
  ActionTypeEnum,
  InboxNotification,
  NotificationActionStatus,
  Result,
  Session,
  Subscriber,
  TODO,
  WebSocketEvent,
} from '../types';
import { NovuError } from '../utils/errors';
import type { BaseSocketInterface } from './base-socket';

export const PRODUCTION_SOCKET_URL = 'wss://socket.novu.co';
const NOTIFICATION_RECEIVED: NotificationReceivedEvent = 'notifications.notification_received';
const UNSEEN_COUNT_CHANGED: NotificationUnseenEvent = 'notifications.unseen_count_changed';
const UNREAD_COUNT_CHANGED: NotificationUnreadEvent = 'notifications.unread_count_changed';

const mapToNotification = ({
  _id,
  transactionId,
  content,
  read,
  seen,
  archived,
  snoozedUntil,
  deliveredAt,
  createdAt,
  lastReadDate,
  firstSeenDate,
  archivedAt,
  channel,
  subscriber,
  subject,
  avatar,
  cta,
  tags,
  data,
  workflow,
  severity,
}: TODO): InboxNotification => {
  const to: Subscriber = {
    id: subscriber?._id,
    subscriberId: subscriber?.subscriberId,
    firstName: subscriber?.firstName,
    lastName: subscriber?.lastName,
    avatar: subscriber?.avatar,
    locale: subscriber?.locale,
    data: subscriber?.data,
    timezone: subscriber?.timezone,
    email: subscriber?.email,
    phone: subscriber?.phone,
  };
  const primaryCta = cta.action?.buttons?.find((button: any) => button.type === ActionTypeEnum.PRIMARY);
  const secondaryCta = cta.action?.buttons?.find((button: any) => button.type === ActionTypeEnum.SECONDARY);
  const actionType = cta.action?.result?.type;
  const actionStatus = cta.action?.status;

  return {
    id: _id,
    transactionId,
    subject,
    body: content as string,
    to,
    isRead: read,
    isSeen: seen,
    isArchived: archived,
    isSnoozed: !!snoozedUntil,
    ...(deliveredAt && {
      deliveredAt,
    }),
    ...(snoozedUntil && {
      snoozedUntil,
    }),
    createdAt,
    readAt: lastReadDate,
    firstSeenAt: firstSeenDate,
    archivedAt,
    avatar,
    primaryAction: primaryCta && {
      label: primaryCta.content,
      isCompleted: actionType === ActionTypeEnum.PRIMARY && actionStatus === NotificationActionStatus.DONE,
      redirect: primaryCta.url
        ? {
            target: primaryCta.target,
            url: primaryCta.url,
          }
        : undefined,
    },
    secondaryAction: secondaryCta && {
      label: secondaryCta.content,
      isCompleted: actionType === ActionTypeEnum.SECONDARY && actionStatus === NotificationActionStatus.DONE,
      redirect: secondaryCta.url
        ? {
            target: secondaryCta.target,
            url: secondaryCta.url,
          }
        : undefined,
    },
    channelType: channel,
    tags,
    redirect: cta.data?.url
      ? {
          url: cta.data.url,
          target: cta.data.target,
        }
      : undefined,
    data,
    workflow,
    severity,
  };
};

export class PartySocketClient extends BaseModule implements BaseSocketInterface {
  #token: string;
  #emitter: NovuEventEmitter;
  #partySocket: WebSocket | undefined;
  #socketUrl: string;

  constructor({
    socketUrl,
    inboxServiceInstance,
    eventEmitterInstance,
  }: {
    socketUrl?: string;
    inboxServiceInstance: InboxService;
    eventEmitterInstance: NovuEventEmitter;
  }) {
    super({
      eventEmitterInstance,
      inboxServiceInstance,
    });
    this.#emitter = eventEmitterInstance;
    this.#socketUrl = socketUrl ?? PRODUCTION_SOCKET_URL;
  }

  protected onSessionSuccess({ token }: Session): void {
    this.#token = token;
  }

  #notificationReceived = (event: MessageEvent) => {
    try {
      const data = JSON.parse(event.data);
      if (data.event === WebSocketEvent.RECEIVED) {
        this.#emitter.emit(NOTIFICATION_RECEIVED, {
          result: new Notification(mapToNotification(data.data.message), this.#emitter, this._inboxService),
        });
      }
    } catch (error) {
      console.log('error', error);
      // Failed to parse notification received event
    }
  };

  #unseenCountChanged = (event: MessageEvent) => {
    try {
      const data = JSON.parse(event.data);
      if (data.event === WebSocketEvent.UNSEEN) {
        this.#emitter.emit(UNSEEN_COUNT_CHANGED, {
          result: data.data.unseenCount,
        });
      }
    } catch (error) {
      // Failed to parse unseen count changed event
    }
  };

  #unreadCountChanged = (event: MessageEvent) => {
    try {
      const data = JSON.parse(event.data);
      if (data.event === WebSocketEvent.UNREAD) {
        this.#emitter.emit(UNREAD_COUNT_CHANGED, {
          result: data.data.counts,
        });
      }
    } catch (error) {
      // Failed to parse unread count changed event
    }
  };

  #handleMessage = (event: MessageEvent) => {
    try {
      const data = JSON.parse(event.data);

      switch (data.event) {
        case WebSocketEvent.RECEIVED:
          this.#notificationReceived(event);
          break;
        case WebSocketEvent.UNSEEN:
          this.#unseenCountChanged(event);
          break;
        case WebSocketEvent.UNREAD:
          this.#unreadCountChanged(event);
          break;
        default:
        // Unknown WebSocket event type
      }
    } catch (error) {
      // Failed to parse WebSocket message
    }
  };

  async #initializeSocket(): Promise<void> {
    if (this.#partySocket) {
      return;
    }

    const args = { socketUrl: this.#socketUrl };
    this.#emitter.emit('socket.connect.pending', { args });

    const url = new URL(this.#socketUrl);
    url.searchParams.set('token', this.#token);

    this.#partySocket = new WebSocket(url.toString());

    this.#partySocket.addEventListener('open', () => {
      this.#emitter.emit('socket.connect.resolved', { args });
    });

    this.#partySocket.addEventListener('error', (error) => {
      this.#emitter.emit('socket.connect.resolved', { args, error });
    });

    this.#partySocket.addEventListener('message', this.#handleMessage);
  }

  async #handleConnectSocket(): Result<void> {
    try {
      await this.#initializeSocket();

      return {};
    } catch (error) {
      return { error: new NovuError('Failed to initialize the PartySocket', error) };
    }
  }

  async #handleDisconnectSocket(): Result<void> {
    try {
      this.#partySocket?.close();
      this.#partySocket = undefined;

      return {};
    } catch (error) {
      return { error: new NovuError('Failed to disconnect from the PartySocket', error) };
    }
  }

  isSocketEvent(eventName: string): eventName is SocketEventNames {
    return (
      eventName === NOTIFICATION_RECEIVED || eventName === UNSEEN_COUNT_CHANGED || eventName === UNREAD_COUNT_CHANGED
    );
  }

  async connect(): Result<void> {
    if (this.#token) {
      return this.#handleConnectSocket();
    }

    return this.callWithSession(this.#handleConnectSocket.bind(this));
  }

  async disconnect(): Result<void> {
    if (this.#partySocket) {
      return this.#handleDisconnectSocket();
    }

    return this.callWithSession(this.#handleDisconnectSocket.bind(this));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - mapToNotification({
  _id,
  transactionId,
  content,
  read,
  seen,
  archived,
  snoozedUntil,
  deliveredAt,
  cr...)
 - primaryCta(cta.action?.buttons?.find((button: any))
 - secondaryCta(cta.action?.buttons?.find((button: any))
 - notificationReceived(event: MessageEvent))
 - unseenCountChanged(event: MessageEvent))
 - unreadCountChanged(event: MessageEvent))
 - handleMessage(event: MessageEvent))
 - partySocket(new WebSocket(url.toString());

    this.#partySocket.addEventListener('open', ())
Declaraciones 'export' encontradas:
- export  const
- export class PartySocketClient

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ws/socket-factory.ts
Tamaño: 1791 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { InboxService } from '../api';
import type { NovuEventEmitter } from '../event-emitter';
import { SocketType } from '../types';
import type { BaseSocketInterface } from './base-socket';
import { PartySocketClient, PRODUCTION_SOCKET_URL } from './party-socket';
import { Socket } from './socket';

const PARTY_SOCKET_URLS = [
  'wss://eu.socket.novu.co',
  PRODUCTION_SOCKET_URL,
  'wss://socket.novu-staging.co',
  'wss://socket-worker-local.cli-shortener.workers.dev',
];

const URL_TRANSFORMATIONS: Record<string, string> = {
  'https://eu.ws.novu.co': 'wss://eu.socket.novu.co',
  'https://ws.novu.co': PRODUCTION_SOCKET_URL,
  'https://dev.ws.novu.co': 'wss://socket.novu-staging.co',
};

function transformSocketUrl(socketUrl?: string): string {
  if (!socketUrl) return PRODUCTION_SOCKET_URL;

  return URL_TRANSFORMATIONS[socketUrl] || socketUrl;
}

function shouldUsePartySocket(socketUrl?: string): boolean {
  return !socketUrl || PARTY_SOCKET_URLS.includes(socketUrl);
}

export function createSocket({
  socketUrl,
  inboxServiceInstance,
  eventEmitterInstance,
}: {
  socketUrl?: string;
  inboxServiceInstance: InboxService;
  eventEmitterInstance: NovuEventEmitter;
}): BaseSocketInterface {
  const transformedSocketUrl = transformSocketUrl(socketUrl);
  const socketType = shouldUsePartySocket(transformedSocketUrl) ? SocketType.PARTY_SOCKET : SocketType.SOCKET_IO;

  switch (socketType) {
    case SocketType.PARTY_SOCKET:
      return new PartySocketClient({
        socketUrl: transformedSocketUrl,
        inboxServiceInstance,
        eventEmitterInstance,
      });
    case SocketType.SOCKET_IO:
    default:
      return new Socket({
        socketUrl: transformedSocketUrl,
        inboxServiceInstance,
        eventEmitterInstance,
      });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - transformSocketUrl(socketUrl?: string)
 - shouldUsePartySocket(socketUrl?: string)
 - createSocket({
  socketUrl,
  inboxServiceInstance,
  eventEmitterInstance,
}: {
  socketUrl?: string;
  inboxServiceInstance: InboxService;
  eventEmitterInstance: NovuEventEmitter;
})
Declaraciones 'export' encontradas:
- export function createSocket

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/src/ws/socket.ts
Tamaño: 6359 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import io, { Socket as SocketIO } from 'socket.io-client';
import { InboxService } from '../api';
import { BaseModule } from '../base-module';
import {
  NotificationReceivedEvent,
  NotificationUnreadEvent,
  NotificationUnseenEvent,
  NovuEventEmitter,
  SocketEventNames,
} from '../event-emitter';
import { Notification } from '../notifications';
import {
  ActionTypeEnum,
  InboxNotification,
  NotificationActionStatus,
  Result,
  Session,
  Subscriber,
  TODO,
  WebSocketEvent,
} from '../types';
import { NovuError } from '../utils/errors';
import type { BaseSocketInterface } from './base-socket';

const PRODUCTION_SOCKET_URL = 'https://ws.novu.co';
const NOTIFICATION_RECEIVED: NotificationReceivedEvent = 'notifications.notification_received';
const UNSEEN_COUNT_CHANGED: NotificationUnseenEvent = 'notifications.unseen_count_changed';
const UNREAD_COUNT_CHANGED: NotificationUnreadEvent = 'notifications.unread_count_changed';

const mapToNotification = ({
  _id,
  transactionId,
  content,
  read,
  seen,
  archived,
  snoozedUntil,
  deliveredAt,
  createdAt,
  lastReadDate,
  firstSeenDate,
  archivedAt,
  channel,
  subscriber,
  subject,
  avatar,
  cta,
  tags,
  data,
  workflow,
  severity,
}: TODO): InboxNotification => {
  const to: Subscriber = {
    id: subscriber?._id,
    subscriberId: subscriber?.subscriberId,
    firstName: subscriber?.firstName,
    lastName: subscriber?.lastName,
    avatar: subscriber?.avatar,
    locale: subscriber?.locale,
    data: subscriber?.data,
    timezone: subscriber?.timezone,
    email: subscriber?.email,
    phone: subscriber?.phone,
  };
  const primaryCta = cta.action?.buttons?.find((button: any) => button.type === ActionTypeEnum.PRIMARY);
  const secondaryCta = cta.action?.buttons?.find((button: any) => button.type === ActionTypeEnum.SECONDARY);
  const actionType = cta.action?.result?.type;
  const actionStatus = cta.action?.status;

  return {
    id: _id,
    transactionId,
    subject,
    body: content as string,
    to,
    isRead: read,
    isSeen: seen,
    isArchived: archived,
    isSnoozed: !!snoozedUntil,
    ...(deliveredAt && {
      deliveredAt,
    }),
    ...(snoozedUntil && {
      snoozedUntil,
    }),
    createdAt,
    readAt: lastReadDate,
    firstSeenAt: firstSeenDate,
    archivedAt,
    avatar,
    primaryAction: primaryCta && {
      label: primaryCta.content,
      isCompleted: actionType === ActionTypeEnum.PRIMARY && actionStatus === NotificationActionStatus.DONE,
      redirect: primaryCta.url
        ? {
            target: primaryCta.target,
            url: primaryCta.url,
          }
        : undefined,
    },
    secondaryAction: secondaryCta && {
      label: secondaryCta.content,
      isCompleted: actionType === ActionTypeEnum.SECONDARY && actionStatus === NotificationActionStatus.DONE,
      redirect: secondaryCta.url
        ? {
            target: secondaryCta.target,
            url: secondaryCta.url,
          }
        : undefined,
    },
    channelType: channel,
    tags,
    redirect: cta.data?.url
      ? {
          url: cta.data.url,
          target: cta.data.target,
        }
      : undefined,
    data,
    workflow,
    severity,
  };
};

export class Socket extends BaseModule implements BaseSocketInterface {
  #token: string;
  #emitter: NovuEventEmitter;
  #socketIo: SocketIO | undefined;
  #socketUrl: string;

  constructor({
    socketUrl,
    inboxServiceInstance,
    eventEmitterInstance,
  }: {
    socketUrl?: string;
    inboxServiceInstance: InboxService;
    eventEmitterInstance: NovuEventEmitter;
  }) {
    super({
      eventEmitterInstance,
      inboxServiceInstance,
    });
    this.#emitter = eventEmitterInstance;
    this.#socketUrl = socketUrl ?? PRODUCTION_SOCKET_URL;
  }

  protected onSessionSuccess({ token }: Session): void {
    this.#token = token;
  }

  #notificationReceived = ({ message }: { message: TODO }) => {
    this.#emitter.emit(NOTIFICATION_RECEIVED, {
      result: new Notification(mapToNotification(message), this.#emitter, this._inboxService),
    });
  };

  #unseenCountChanged = ({ unseenCount }: { unseenCount: number }) => {
    this.#emitter.emit(UNSEEN_COUNT_CHANGED, {
      result: unseenCount,
    });
  };

  #unreadCountChanged = ({ counts }: { counts: { total: number; severity: Record<string, number> } }) => {
    this.#emitter.emit(UNREAD_COUNT_CHANGED, {
      result: counts,
    });
  };

  async #initializeSocket(): Promise<void> {
    if (this.#socketIo) {
      return;
    }

    const args = { socketUrl: this.#socketUrl };
    this.#emitter.emit('socket.connect.pending', { args });

    this.#socketIo = io(this.#socketUrl, {
      reconnectionDelayMax: 10000,
      transports: ['websocket'],
      query: {
        token: `${this.#token}`,
      },
    });

    this.#socketIo.on('connect', () => {
      this.#emitter.emit('socket.connect.resolved', { args });
    });

    this.#socketIo.on('connect_error', (error) => {
      this.#emitter.emit('socket.connect.resolved', { args, error });
    });

    this.#socketIo?.on(WebSocketEvent.RECEIVED, this.#notificationReceived);
    this.#socketIo?.on(WebSocketEvent.UNSEEN, this.#unseenCountChanged);
    this.#socketIo?.on(WebSocketEvent.UNREAD, this.#unreadCountChanged);
  }

  async #handleConnectSocket(): Result<void> {
    try {
      await this.#initializeSocket();

      return {};
    } catch (error) {
      return { error: new NovuError('Failed to initialize the socket', error) };
    }
  }

  async #handleDisconnectSocket(): Result<void> {
    try {
      this.#socketIo?.disconnect();
      this.#socketIo = undefined;

      return {};
    } catch (error) {
      return { error: new NovuError('Failed to disconnect from the socket', error) };
    }
  }

  isSocketEvent(eventName: string): eventName is SocketEventNames {
    return (
      eventName === NOTIFICATION_RECEIVED || eventName === UNSEEN_COUNT_CHANGED || eventName === UNREAD_COUNT_CHANGED
    );
  }

  async connect(): Result<void> {
    if (this.#token) {
      return this.#handleConnectSocket();
    }

    return this.callWithSession(this.#handleConnectSocket.bind(this));
  }

  async disconnect(): Result<void> {
    if (this.#socketIo) {
      return this.#handleDisconnectSocket();
    }

    return this.callWithSession(this.#handleDisconnectSocket.bind(this));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - mapToNotification({
  _id,
  transactionId,
  content,
  read,
  seen,
  archived,
  snoozedUntil,
  deliveredAt,
  cr...)
 - primaryCta(cta.action?.buttons?.find((button: any))
 - secondaryCta(cta.action?.buttons?.find((button: any))
 - notificationReceived({ message }: { message: TODO }))
 - unseenCountChanged({ unseenCount }: { unseenCount: number }))
 - unreadCountChanged({ counts }: { counts: { total: number; severity: Record<string, number> } }))
 - socketIo(io(this.#socketUrl, {
      reconnectionDelayMax: 10000,
      transports: ['websocket'],
      quer...)
Declaraciones 'export' encontradas:
- export class Socket

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/js/themes/package.json
Tamaño: 132 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "main": "../dist/cjs/themes/index.js",
  "module": "../dist/esm/themes/index.mjs",
  "types": "../dist/cjs/themes/index.d.ts"
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"main": "../dist/cjs/themes/index.js",
"module": "../dist/esm/themes/index.mjs",
"types": "../dist/cjs/themes/index.d.ts"
}
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/js/ui/package.json
Tamaño: 120 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "main": "../dist/cjs/ui/index.js",
  "module": "../dist/esm/ui/index.mjs",
  "types": "../dist/cjs/ui/index.d.ts"
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"main": "../dist/cjs/ui/index.js",
"module": "../dist/esm/ui/index.mjs",
"types": "../dist/cjs/ui/index.d.ts"
}
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/nextjs/.gitignore
Tamaño: 398 bytes
Lenguaje detectado: GITIGNORE

### CONTENIDO ORIGINAL ###

# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# JetBrains IDE files
.idea/

# testing
/coverage

# production
/dist

# misc
.DS_Store
*.pem
tsconfig.tsbuildinfo

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env
.env.local
.env.development.local
.env.test.local
.env.production.local


### ANALISIS AUTOMATICO (ESPAÑOL) ###

# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.
# dependencies
/node_modules
/.pnp
# JetBrains IDE files
# testing
# production
# misc
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/nextjs/CHANGELOG.md
Tamaño: 7516 bytes
Lenguaje detectado: Markdown

### CONTENIDO ORIGINAL ###

## v3.10.1 (2025-09-22)

This was a version bump only for @novu/nextjs to align it with other projects, there were no code changes.

## v3.10.0 (2025-09-22)

### 🚀 Features

- **react,js:** default schedule and useSchedule hook fixes NV-6616 ([#9110](https://github.com/novuhq/novu/pull/9110))

### ❤️ Thank You

- Paweł Tymczuk @LetItRock

## v3.9.3 (2025-09-03)

This was a version bump only for @novu/nextjs to align it with other projects, there were no code changes.

## v3.9.2 (2025-09-03)

### 🚀 Features

- **js,react,api-service:** inbox allow filtering preferences by workflow criticality fixes NV-6577 ([#9011](https://github.com/novuhq/novu/pull/9011))

### ❤️ Thank You

- Paweł Tymczuk @LetItRock

## v3.9.1 (2025-08-27)

### 🚀 Features

- **js,react,nextjs:** inbox appearance keys as a callback with the context prop fixes NV-6447 ([#8983](https://github.com/novuhq/novu/pull/8983))
- **js,react,api-service,ws:** support severity in inbox components and hooks fixes NV-6470 ([#8913](https://github.com/novuhq/novu/pull/8913))

### ❤️ Thank You

- Paweł Tymczuk @LetItRock

## v3.8.1 (2025-08-13)

### 🩹 Fixes

- **root:** nx release publish issue for syntax error fixes NV-6506 ([#8922](https://github.com/novuhq/novu/pull/8922))

### ❤️ Thank You

- Himanshu Garg @merrcury

## v3.7.0 (2025-07-22)

### 🚀 Features

- **worker,js,react:** subscriber timezone aware delivery fixes NV-6239 ([#8674](https://github.com/novuhq/novu/pull/8674))
- **root:** create keyless environment ([#8276](https://github.com/novuhq/novu/pull/8276))

### 🩹 Fixes

- **root:** bring back eslint and web app build ([#8505](https://github.com/novuhq/novu/pull/8505))
- version bump react packages ([62ff7ee154](https://github.com/novuhq/novu/commit/62ff7ee154))
- novu react rc 4 release ([b737df7335](https://github.com/novuhq/novu/commit/b737df7335))

### ❤️ Thank You

- Dima Grossman @scopsy
- George Djabarov @djabarovgeorge
- Paweł Tymczuk @LetItRock

## v3.4.0 (2025-05-16)

### 🧱 Updated Dependencies

- Updated @novu/react to 3.4.0

### ❤️ Thank You

- Paweł Tymczuk @LetItRock

# v3.3.1 (2025-05-07)

### 🧱 Updated Dependencies

- Updated @novu/react to 3.3.1

### ❤️ Thank You

- Adam Chmara @ChmaraX

## v3.3.0 (2025-05-07)

### 🧱 Updated Dependencies

- Updated @novu/react to 3.3.0

### ❤️ Thank You

- Adam Chmara @ChmaraX
- George Desipris @desiprisg
- Paweł Tymczuk @LetItRock

## v3.2.0 (2025-04-30)

### 🧱 Updated Dependencies

- Updated @novu/react to 3.2.0

### ❤️ Thank You

- George Djabarov @djabarovgeorge

## v3.1.0 (2025-04-11)

### 🧱 Updated Dependencies

- Updated @novu/react to 3.1.0

### ❤️ Thank You

- Sokratis Vidros @SokratisVidros

## v3.0.3 (2025-03-31)

### 🚀 Features

- **react,nextjs:** better dist folders structure and tsup config improvements ([#7914](https://github.com/novuhq/novu/pull/7914))
- **js:** Inbox retheme ([#7759](https://github.com/novuhq/novu/pull/7759))
- **api-service:** system limits & update pricing pages ([#7718](https://github.com/novuhq/novu/pull/7718))
- **root:** add no only github action ([#7692](https://github.com/novuhq/novu/pull/7692))

### 🩹 Fixes

- **api-service:** Remove lock from cached entity 2nd try ([#7979](https://github.com/novuhq/novu/pull/7979))
- **root:** simplify service dependencies in docker-compose.yml ([#7993](https://github.com/novuhq/novu/pull/7993))
- **root:** Stop updating lock-file when releasing new packages ([2107336ae2](https://github.com/novuhq/novu/commit/2107336ae2))
- **api-service:** remove-lock-from-cached-entity ([#7923](https://github.com/novuhq/novu/pull/7923))
- **root:** add NEW_RELIC_ENABLED to docker community ([#7943](https://github.com/novuhq/novu/pull/7943))
- **nextjs:** Fix router compat when use client is used ([#7951](https://github.com/novuhq/novu/pull/7951))
- **root:** remove healthcheck option in docker-compose.yml ([#7929](https://github.com/novuhq/novu/pull/7929))
- **react,nextjs:** Add use-client to exports ([#7934](https://github.com/novuhq/novu/pull/7934))
- **api-service:** Remove redlock ([#7845](https://github.com/novuhq/novu/pull/7845))
- **api-service:** fix idices not created in mongo-test ([#7857](https://github.com/novuhq/novu/pull/7857))
- **root:** unhandled promise reject and undefined ff kind ([#7732](https://github.com/novuhq/novu/pull/7732))
- **api-service:** remove only on e2e ([#7691](https://github.com/novuhq/novu/pull/7691))

### ❤️ Thank You

- Aaron Ritter @Aaron-Ritter
- GalTidhar @tatarco
- George Desipris @desiprisg
- George Djabarov @djabarovgeorge
- Himanshu Garg @merrcury
- Pawan Jain
- Paweł Tymczuk @LetItRock
- Sokratis Vidros @SokratisVidros

## 3.0.2 (2025-03-24)

### 🩹 Fixes

- **nextjs:** Fix router compat when use client is used ([#7951](https://github.com/novuhq/novu/pull/7951))
- **react,nextjs:** Add use-client to exports ([#7934](https://github.com/novuhq/novu/pull/7934))

### 🧱 Updated Dependencies

- Updated @novu/react to 3.0.1

### ❤️ Thank You

- Aaron Ritter @Aaron-Ritter
- GalTidhar @tatarco
- George Desipris @desiprisg
- Pawan Jain
- Sokratis Vidros @SokratisVidros

# 3.0.0 (2025-03-17)

### 🚀 Features

- **react,nextjs:** better dist folders structure and tsup config improvements ([#7914](https://github.com/novuhq/novu/pull/7914))
- **js:** Inbox retheme ([#7759](https://github.com/novuhq/novu/pull/7759))

### 🧱 Updated Dependencies

- Updated @novu/react to 3.0.0

### ❤️ Thank You

- GalTidhar @tatarco
- George Desipris @desiprisg
- Paweł Tymczuk @LetItRock

## 2.6.6 (2025-02-25)

### 🚀 Features

- **api-service:** system limits & update pricing pages ([#7718](https://github.com/novuhq/novu/pull/7718))
- **root:** add no only github action ([#7692](https://github.com/novuhq/novu/pull/7692))

### 🩹 Fixes

- **root:** unhandled promise reject and undefined ff kind ([#7732](https://github.com/novuhq/novu/pull/7732))
- **api-service:** remove only on e2e ([#7691](https://github.com/novuhq/novu/pull/7691))

### 🧱 Updated Dependencies

- Updated @novu/react to 2.6.6

### ❤️ Thank You

- GalTidhar @tatarco
- George Djabarov @djabarovgeorge

## 2.6.5 (2024-12-24)

### 🧱 Updated Dependencies

- Updated @novu/react to 2.6.3

### ❤️ Thank You

- GalTidhar @tatarco
- George Desipris @desiprisg
- George Djabarov @djabarovgeorge
- Pawan Jain

## 2.6.3 (2024-11-26)

### 🚀 Features

- **dashboard:** Codemirror liquid filter support ([#7122](https://github.com/novuhq/novu/pull/7122))
- **root:** add support chat app ID to environment variables in d… ([#7120](https://github.com/novuhq/novu/pull/7120))
- **root:** Add base Dockerfile for GHCR with Node.js and dependencies ([#7100](https://github.com/novuhq/novu/pull/7100))

### 🩹 Fixes

- **api:** Migrate subscriber global preferences before workflow preferences ([#7118](https://github.com/novuhq/novu/pull/7118))
- **api, dal, framework:** fix the uneven and unused dependencies ([#7103](https://github.com/novuhq/novu/pull/7103))

### 🧱 Updated Dependencies

- Updated @novu/react to 2.6.2

### ❤️ Thank You

- George Desipris @desiprisg
- Himanshu Garg @merrcury
- Richard Fontein @rifont

## 2.0.2 (2024-11-19)

### 🚀 Features

- **framework:** CJS/ESM for framework ([#6707](https://github.com/novuhq/novu/pull/6707))
- **js:** Com 145 introduce novunextjs ([#6647](https://github.com/novuhq/novu/pull/6647))

### ❤️ Thank You

- Biswajeet Das
- Sokratis Vidros @SokratisVidros


### ANALISIS AUTOMATICO (ESPAÑOL) ###

## v3.10.1 (2025-09-22)
This was a version bump only for @novu/nextjs to align it with other projects, there were no code changes.
## v3.10.0 (2025-09-22)
### 🚀 Features
### ❤️ Thank You
## v3.9.3 (2025-09-03)
## v3.9.2 (2025-09-03)
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/nextjs/README.md
Tamaño: 5028 bytes
Lenguaje detectado: Markdown

### CONTENIDO ORIGINAL ###

# Novu's NextJS SDK for `<Inbox />`.

Novu provides the `@novu/nextjs` library that helps to add a fully functioning `<Inbox />` to your web application in minutes.
See full documentation [here](https://docs.novu.co/inbox/react/get-started).

## Installation

- Install `@novu/nextjs` npm package in your nextjs app

```bash
npm install @novu/nextjs
```

## Getting Started

- Add the below code in the app.tsx file

```jsx
import { Inbox } from '@novu/nextjs';

function Novu() {
  return (
    <Inbox
      options={{
        subscriberId: 'SUBSCRIBER_ID',
        applicationIdentifier: 'APPLICATION_IDENTIFIER',
      }}
    />
  );
}
```

## Controlled Inbox

You can use the `open` prop to manage the Inbox popover open state.

```jsx
import { Inbox } from '@novu/nextjs';

function Novu() {
  const [open, setOpen] = useState(false);

  return (
    <div>
      <Inbox
        options={{
          subscriberId: 'SUBSCRIBER_ID',
          applicationIdentifier: 'APPLICATION_IDENTIFIER',
        }}
        open={isOpen}
      />
      <button onClick={() => setOpen(true)}>Open Inbox</button>
      <button onClick={() => setOpen(false)}>Close Inbox</button>
    </div>
  );
}
```

## Localization

You can pass the `localization` prop to the Inbox component to change the language of the Inbox.

```jsx
import { Inbox } from '@novu/nextjs';

function Novu() {
  return (
    <Inbox
      options={{
        subscriberId: 'SUBSCRIBER_ID',
        applicationIdentifier: 'APPLICATION_IDENTIFIER',
      }}
      localization={{
        'inbox.status.archived': 'Archived',
        'inbox.status.unread': 'Unread',
        'inbox.status.options.archived': 'Archived',
        'inbox.status.options.unread': 'Unread',
        'inbox.status.options.unreadRead': 'Unread/Read',
        'inbox.status.unreadRead': 'Unread/Read',
        'inbox.title': 'Inbox',
        'notifications.emptyNotice': 'No notifications',
        locale: 'en-US',
      }}
    />
  );
}
```

## HMAC Encryption

When Novu's user adds the Inbox to their application they are required to pass a `subscriberId` which identifies the user's end-customer, and the application Identifier which is acted as a public key to communicate with the notification feed API.

A malicious actor can access the user feed by accessing the API and passing another `subscriberId` using the public application identifier.

HMAC encryption will make sure that a `subscriberId` is encrypted using the secret API key, and those will prevent malicious actors from impersonating users.

### Enabling HMAC Encryption

In order to enable Hash-Based Message Authentication Codes, you need to visit the admin panel In-App settings page and enable HMAC encryption for your environment.

<Frame caption="How to enable HMAC encryption for In-App Inbox">
  <img src="/images/notification-center/client/react/get-started/hmac-encryption-enable.png" />
</Frame>

#### Subscriber HMAC

1. Generate an HMAC encrypted subscriberId on your backend:

```jsx
import { createHmac } from 'crypto';

const subscriberHash = createHmac('sha256', process.env.NOVU_API_KEY).update(subscriberId).digest('hex');
```

2. Pass the created HMAC to your client side application:

```jsx
<Inbox
  subscriberId={'SUBSCRIBER_ID_PLAIN_VALUE'}
  subscriberHash={'SUBSCRIBER_ID_HASH_VALUE'}
  applicationIdentifier={'APPLICATION_IDENTIFIER'}
/>
```

> Note: If HMAC encryption is active in In-App provider settings and `subscriberHash`
> along with `subscriberId` is not provided, then Inbox will not load

#### Context HMAC (Optional)

If you're using the `context` prop to pass additional data (e.g., tenant information, environment, etc.), you should also generate a `contextHash` to prevent context tampering:

1. Generate an HMAC for the context on your backend:

```jsx
import { createHmac } from 'crypto';
import { canonicalize } from '@tufjs/canonical-json';

const context = { tenant: 'acme', app: 'dashboard' };
const contextHash = createHmac('sha256', process.env.NOVU_API_KEY)
  .update(canonicalize(context))
  .digest('hex');
```

2. Pass both the context and contextHash to the component:

```jsx
<Inbox
  subscriberId={'SUBSCRIBER_ID_PLAIN_VALUE'}
  subscriberHash={'SUBSCRIBER_ID_HASH_VALUE'}
  context={{ tenant: 'acme', app: 'dashboard' }}
  contextHash={'CONTEXT_HASH_VALUE'}
  applicationIdentifier={'APPLICATION_IDENTIFIER'}
/>
```

> Note: When HMAC encryption is enabled and `context` is provided, the `contextHash` is required. The hash is order-independent, so `{a:1, b:2}` produces the same hash as `{b:2, a:1}`.

## Use your own backend and socket URL

By default, Novu's hosted services for API and socket are used. If you want, you can override them and configure your own.

```tsx
import { Inbox } from '@novu/nextjs';

function Novu() {
  return (
    <Inbox
      options={{
        backendUrl: 'YOUR_BACKEND_URL',
        socketUrl: 'YOUR_SOCKET_URL',
        subscriberId: 'SUBSCRIBER_ID',
        applicationIdentifier: 'APPLICATION_IDENTIFIER',
      }}
    />
  );
}
```


### ANALISIS AUTOMATICO (ESPAÑOL) ###

# Novu's NextJS SDK for `<Inbox />`.
Novu provides the `@novu/nextjs` library that helps to add a fully functioning `<Inbox />` to your web application in minutes.
See full documentation [here](https://docs.novu.co/inbox/react/get-started).
## Installation
## Getting Started
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/nextjs/package.json
Tamaño: 2823 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "name": "@novu/nextjs",
  "version": "3.10.1",
  "repository": {
    "type": "git",
    "url": "https://github.com/novuhq/novu",
    "directory": "packages/nextjs"
  },
  "homepage": "https://novu.co",
  "description": "Novu <Inbox /> Next.js SDK",
  "author": "Novu",
  "license": "ISC",
  "main": "./dist/cjs/server/index.js",
  "module": "./dist/esm/pages-router/index.js",
  "types": "./dist/types/pages-router/index.d.ts",
  "exports": {
    ".": {
      "import": {
        "types": "./dist/types/pages-router/index.d.ts",
        "react-server": "./dist/esm/app-router/index.js",
        "default": "./dist/esm/pages-router/index.js"
      },
      "require": {
        "types": "./dist/types/pages-router/index.d.ts",
        "react-server": "./dist/cjs/app-router/index.js",
        "default": "./dist/cjs/pages-router/index.js"
      }
    },
    "./hooks": {
      "import": {
        "types": "./dist/types/hooks/index.d.ts",
        "default": "./dist/esm/hooks/index.js"
      },
      "require": {
        "types": "./dist/types/hooks/index.d.ts",
        "default": "./dist/cjs/hooks/index.js"
      }
    },
    "./themes": {
      "import": {
        "types": "./dist/types/themes/index.d.ts",
        "default": "./dist/esm/themes/index.js"
      },
      "require": {
        "types": "./dist/types/themes/index.d.ts",
        "default": "./dist/cjs/themes/index.js"
      }
    }
  },
  "files": [
    "dist",
    "dist/cjs/**/*",
    "dist/esm/**/*",
    "dist/types/**/*",
    "server/**/*",
    "hooks/**/*",
    "themes/**/*"
  ],
  "sideEffects": false,
  "private": false,
  "publishConfig": {
    "access": "public"
  },
  "scripts": {
    "build:watch": "tsup --watch",
    "build": "tsup && pnpm run build:declarations && pnpm run check-exports",
    "build:declarations": "tsc -p tsconfig.declarations.json",
    "check-exports": "attw --pack . --ignore-rules unexpected-module-syntax",
    "publish:rc": "pnpm publish --tag rc"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "@arethetypeswrong/cli": "^0.17.4",
    "@types/node": "^20.14.12",
    "@types/react": "*",
    "@types/react-dom": "*",
    "esbuild-plugin-file-path-extensions": "^2.1.4",
    "tsup": "^8.2.1",
    "typescript": "5.6.2"
  },
  "peerDependencies": {
    "next": ">=13.5.2 || ^14.0.0 || ^15.0.0",
    "react": "^18.0.0 || ^19.0.0 || ^19.0.0-0",
    "react-dom": "^18.0.0 || ^19.0.0 || ^19.0.0-0"
  },
  "peerDependenciesMeta": {
    "react-dom": {
      "optional": true
    }
  },
  "dependencies": {
    "@novu/react": "workspace:*"
  },
  "nx": {
    "tags": [
      "type:package"
    ]
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"name": "@novu/nextjs",
"version": "3.10.1",
"repository": {
"type": "git",
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/nextjs/project.json
Tamaño: 323 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "name": "@novu/nextjs",
  "sourceRoot": "packages/nextjs/src",
  "projectType": "library",
  "targets": {
    "nx-release-publish": {
      "executor": "nx:run-commands",
      "options": {
        "command": "cd packages/nextjs && pnpm publish --access public --no-git-checks ${NX_PUBLISH_ARGS:-}"
      }
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"name": "@novu/nextjs",
"sourceRoot": "packages/nextjs/src",
"projectType": "library",
"targets": {
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/nextjs/tsconfig.declarations.json
Tamaño: 293 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "declaration": true,
    "declarationDir": "./dist/types",
    "declarationMap": true,
    "emitDeclarationOnly": true,
    "noEmit": false,
    "skipLibCheck": true,
    "sourceMap": false
  },
  "exclude": ["**/__tests__/**/*"]
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"extends": "./tsconfig.json",
"compilerOptions": {
"declaration": true,
"declarationDir": "./dist/types",
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/nextjs/tsconfig.json
Tamaño: 570 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "include": ["src"],
  "compilerOptions": {
    "baseUrl": ".",
    "lib": ["dom", "dom.iterable", "esnext"],
    "target": "ES2020",
    "esModuleInterop": true,
    "module": "ESNext",
    "isolatedModules": true,
    "jsx": "react-jsx",
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "Bundler",
    "emitDecoratorMetadata": false,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "outDir": "./dist/esm",
    "rootDir": "./src"
  },
  "exclude": ["src/**/*.test.*", "src/*.test.*", "node_modules", "**/node_modules/*"]
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"include": ["src"],
"compilerOptions": {
"baseUrl": ".",
"lib": ["dom", "dom.iterable", "esnext"],
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/nextjs/tsup.config.ts
Tamaño: 974 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { esbuildPluginFilePathExtensions } from 'esbuild-plugin-file-path-extensions';
import { defineConfig, Options } from 'tsup';
import { name, version } from './package.json';

const baseConfig: Options = {
  // we want to preserve the folders structure together with
  // 'use client' directives
  entry: ['src/**/*.{ts,tsx}'],
  minify: false,
  sourcemap: true,
  clean: true,
  dts: false,
  define: { PACKAGE_NAME: `"${name}"`, PACKAGE_VERSION: `"${version}"` },
};

export default defineConfig([
  {
    ...baseConfig,
    format: 'cjs',
    target: 'node14',
    platform: 'node',
    outDir: 'dist/cjs',
    esbuildPlugins: [esbuildPluginFilePathExtensions({ cjsExtension: 'js' })],
  },
  {
    ...baseConfig,
    format: 'esm',
    target: 'esnext',
    platform: 'browser',
    outDir: 'dist/esm',
    esbuildPlugins: [esbuildPluginFilePathExtensions({ esmExtension: 'js' })],
    outExtension: () => ({
      js: '.js',
      dts: '.d.ts',
    }),
  },
]);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - Options({
  // we want to preserve the folders structure together with
  // 'use client' directives
  entry:...)
Declaraciones 'export' encontradas:
- export default  defineConfig

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/nextjs/hooks/package.json
Tamaño: 130 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "main": "../dist/cjs/hooks/index.js",
  "module": "../dist/esm/hooks/index.js",
  "types": "../dist/types/hooks/index.d.ts"
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"main": "../dist/cjs/hooks/index.js",
"module": "../dist/esm/hooks/index.js",
"types": "../dist/types/hooks/index.d.ts"
}
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/nextjs/server/package.json
Tamaño: 126 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "main": "../dist/cjs/server/index.js",
  "module": "../dist/esm/server/index.js",
  "types": "../dist/types/index.d.ts"
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"main": "../dist/cjs/server/index.js",
"module": "../dist/esm/server/index.js",
"types": "../dist/types/index.d.ts"
}
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/nextjs/src/app-router/Inbox.tsx
Tamaño: 639 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

'use client';

import { type InboxProps, Inbox as RInbox } from '@novu/react';
import { buildSubscriber } from '@novu/react/internal';
import { useRouter } from 'next/navigation';

export function Inbox(props: InboxProps) {
  const router = useRouter();
  const { subscriber: subscriberProp, subscriberId: subscriberIdProp, ...restProps } = props;
  const subscriber = buildSubscriber({ subscriberId: subscriberIdProp, subscriber: subscriberProp });

  const inboxProps = {
    ...restProps,
    applicationIdentifier: props.applicationIdentifier!,
    subscriber,
    routerPush: router.push,
  };

  return <RInbox {...inboxProps} />;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

'use client';
import { type InboxProps, Inbox as RInbox } from '@novu/react';
import { buildSubscriber } from '@novu/react/internal';
import { useRouter } from 'next/navigation';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/nextjs/src/app-router/index.ts
Tamaño: 307 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

'use client';

// First export to override anything that we redeclare
export type * from '@novu/react';
export {
  Bell,
  InboxContent,
  Notifications,
  NovuProvider,
  PreferenceLevel,
  Preferences,
  SeverityLevelEnum,
  WorkflowCriticalityEnum,
} from '@novu/react';
export { Inbox } from './Inbox';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  to
- export  type
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/nextjs/src/hooks/index.ts
Tamaño: 50 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

'use client';

export * from '@novu/react/hooks';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/nextjs/src/pages-router/Inbox.tsx
Tamaño: 1295 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

'use client';

import { InboxProps, Inbox as RInbox } from '@novu/react';
import { buildSubscriber } from '@novu/react/internal';
import { useRouter } from 'next/compat/router';
import { useRouter as useAppRouter } from 'next/navigation';

function AppRouterInbox(props: InboxProps) {
  const router = useAppRouter();
  const { subscriber: subscriberProp, subscriberId: subscriberIdProp, ...restProps } = props;
  const subscriber = buildSubscriber({ subscriberId: subscriberIdProp, subscriber: subscriberProp });

  const inboxProps = {
    ...restProps,
    applicationIdentifier: props.applicationIdentifier!,
    subscriber,
    routerPush: router.push,
  };

  return <RInbox {...inboxProps} />;
}

export function Inbox(props: InboxProps) {
  const router = useRouter();
  const { subscriber: subscriberProp, subscriberId: subscriberIdProp, ...restProps } = props;
  const subscriber = buildSubscriber({ subscriberId: subscriberIdProp, subscriber: subscriberProp });

  const inboxProps = {
    ...restProps,
    applicationIdentifier: props.applicationIdentifier!,
    subscriber,
  };

  if (!router) {
    return <AppRouterInbox {...inboxProps} />;
  }

  return <RInbox {...inboxProps} />;
}

export { Bell, InboxContent, Notifications, NovuProvider, Preferences } from '@novu/react';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

'use client';
import { InboxProps, Inbox as RInbox } from '@novu/react';
import { buildSubscriber } from '@novu/react/internal';
import { useRouter } from 'next/compat/router';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/nextjs/src/pages-router/index.ts
Tamaño: 307 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

'use client';

// First export to override anything that we redeclare
export type * from '@novu/react';
export {
  Bell,
  InboxContent,
  Notifications,
  NovuProvider,
  PreferenceLevel,
  Preferences,
  SeverityLevelEnum,
  WorkflowCriticalityEnum,
} from '@novu/react';
export { Inbox } from './Inbox';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  to
- export  type
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/nextjs/src/server/index.ts
Tamaño: 298 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export type * from '@novu/react';

export {
  Bell,
  Inbox,
  InboxContent,
  Notifications,
  NovuProvider,
  PreferenceLevel,
  Preferences,
  SeverityLevelEnum,
  useCounts,
  useNotifications,
  useNovu,
  usePreferences,
  useSchedule,
  WorkflowCriticalityEnum,
} from '@novu/react/server';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/nextjs/src/themes/index.ts
Tamaño: 51 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

'use client';

export * from '@novu/react/themes';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/nextjs/themes/package.json
Tamaño: 133 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "main": "../dist/cjs/themes/index.js",
  "module": "../dist/esm/themes/index.js",
  "types": "../dist/types/themes/index.d.ts"
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"main": "../dist/cjs/themes/index.js",
"module": "../dist/esm/themes/index.js",
"types": "../dist/types/themes/index.d.ts"
}
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/novu/.gitignore
Tamaño: 2013 bytes
Lenguaje detectado: GITIGNORE

### CONTENIDO ORIGINAL ###

# Created by .ignore support plugin (hsz.mobi)
### Node template
# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.idea
.build
# Runtime data
pids
*.pid
*.seed
*.pid.lock

dist
# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage

# nyc test coverage
.nyc_output

# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# TypeScript v1 declaration files
typings/

# Optional npm cache directory
.npm

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# next.js build output
.next
### JetBrains template
# Covers JetBrains IDEs: IntelliJ, RubyMine, PhpStorm, AppCode, PyCharm, CLion, Android Studio and WebStorm
# Reference: https://intellij-support.jetbrains.com/hc/en-us/articles/206544839

# User-specific stuff
.idea/**/*/workspace.xml
.idea/**/*/tasks.xml
.idea/**/*/dictionaries
.idea/**/*/shelf

# Sensitive or high-churn files
.idea/**/dataSources/
.idea/**/dataSources.ids
.idea/**/dataSources.local.xml
.idea/**/sqlDataSources.xml
.idea/**/dynamic.xml
.idea/**/uiDesigner.xml
.idea/**/dbnavigator.xml

# Gradle
.idea/**/gradle.xml
.idea/**/libraries

# CMake
cmake-build-debug/
cmake-build-release/

# Mongo Explorer plugin
.idea/**/mongoSettings.xml

# File-based project format
*.iws

# IntelliJ
out/

# mpeltonen/sbt-idea plugin
.idea_modules/

# JIRA plugin
atlassian-ide-plugin.xml

# Cursive Clojure plugin
.idea/replstate.xml

# Crashlytics plugin (for Android Studio and IntelliJ)
com_crashlytics_export_strings.xml
crashlytics.properties
crashlytics-build.properties
fabric.properties

# Editor-based Rest Client
.idea/httpRequests

.serverless
newrelic_agent.log


### ANALISIS AUTOMATICO (ESPAÑOL) ###

# Created by .ignore support plugin (hsz.mobi)
### Node template
# Logs
*.log
npm-debug.log*
# Runtime data
# Directory for instrumented libs generated by jscoverage/JSCover
# Coverage directory used by tools like istanbul
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/novu/CHANGELOG.md
Tamaño: 4924 bytes
Lenguaje detectado: Markdown

### CONTENIDO ORIGINAL ###

## 2.6.6 (2025-02-25)

### 🚀 Features

- **api-service:** system limits & update pricing pages ([#7718](https://github.com/novuhq/novu/pull/7718))
- **root:** add no only github action ([#7692](https://github.com/novuhq/novu/pull/7692))

### 🩹 Fixes

- **root:** unhandled promise reject and undefined ff kind ([#7732](https://github.com/novuhq/novu/pull/7732))
- **api-service:** remove only on e2e ([#7691](https://github.com/novuhq/novu/pull/7691))

### 🧱 Updated Dependencies

- Updated @novu/shared to 2.6.6

### ❤️ Thank You

- GalTidhar @tatarco
- George Djabarov @djabarovgeorge


## 2.6.5 (2025-02-07)

### 🚀 Features

- Update README.md ([bb63172dd](https://github.com/novuhq/novu/commit/bb63172dd))
- **readme:** Update README.md ([955cbeab0](https://github.com/novuhq/novu/commit/955cbeab0))
- quick start updates readme ([88b3b6628](https://github.com/novuhq/novu/commit/88b3b6628))
- **readme:** update readme ([e5ea61812](https://github.com/novuhq/novu/commit/e5ea61812))
- **api-service:** add internal sdk ([#7599](https://github.com/novuhq/novu/pull/7599))
- **dashboard:** step conditions editor ui ([#7502](https://github.com/novuhq/novu/pull/7502))
- **api:** add query parser ([#7267](https://github.com/novuhq/novu/pull/7267))
- **api:** Nv 5033 additional removal cycle found unneeded elements ([#7283](https://github.com/novuhq/novu/pull/7283))
- **api:** Nv 4966 e2e testing happy path - messages ([#7248](https://github.com/novuhq/novu/pull/7248))
- **novu:** Add `--studio-host` option on dev server ([#7211](https://github.com/novuhq/novu/pull/7211))
- **dashboard:** Implement email step editor & mini preview ([#7129](https://github.com/novuhq/novu/pull/7129))
- **api:** converted bulk trigger to use SDK ([#7166](https://github.com/novuhq/novu/pull/7166))
- **application-generic:** add SUBSCRIBER_WIDGET_JWT_EXPIRATION_TIME env variable ([#7105](https://github.com/novuhq/novu/pull/7105))

### 🩹 Fixes

- **js:** Await read action in Inbox ([#7653](https://github.com/novuhq/novu/pull/7653))
- **api:** duplicated subscribers created due to race condition ([#7646](https://github.com/novuhq/novu/pull/7646))
- **api-service:** add missing environment variable ([#7553](https://github.com/novuhq/novu/pull/7553))
- **api:** Fix failing API e2e tests ([78c385ec7](https://github.com/novuhq/novu/commit/78c385ec7))
- **api-service:** E2E improvements ([#7461](https://github.com/novuhq/novu/pull/7461))
- **novu:** automatically create indexes on startup ([#7431](https://github.com/novuhq/novu/pull/7431))
- **api:** @novu/api -> @novu/api-service ([#7348](https://github.com/novuhq/novu/pull/7348))
- **novu:** Respect .env values for API URL and SECRET_KEY ([#7279](https://github.com/novuhq/novu/pull/7279))

### 🧱 Updated Dependencies

- Updated @novu/shared to 2.6.5

### ❤️ Thank You

- Aminul Islam @AminulBD
- Arthur M @4rthem
- Dima Grossman @scopsy
- GalTidhar @tatarco
- George Desipris @desiprisg
- George Djabarov @djabarovgeorge
- Lucky @L-U-C-K-Y
- Pawan Jain
- Paweł Tymczuk @LetItRock
- Sokratis Vidros @SokratisVidros


## 2.2.2 (2024-12-24)

### 🚀 Features

- **novu:** Add `--studio-host` option on dev server ([#7211](https://github.com/novuhq/novu/pull/7211))

### 🩹 Fixes

- **novu:** Respect .env values for API URL and SECRET_KEY ([#7279](https://github.com/novuhq/novu/pull/7279))

### 🧱 Updated Dependencies

- Updated @novu/shared to 2.1.5

### ❤️ Thank You

- Arthur M @4rthem
- GalTidhar @tatarco
- George Desipris @desiprisg
- George Djabarov @djabarovgeorge
- Pawan Jain
- Sokratis Vidros @SokratisVidros


## 2.2.1 (2024-11-26)

### 🚀 Features

- **dashboard:** Codemirror liquid filter support ([#7122](https://github.com/novuhq/novu/pull/7122))
- **root:** add support chat app ID to environment variables in d… ([#7120](https://github.com/novuhq/novu/pull/7120))
- **root:** Add base Dockerfile for GHCR with Node.js and dependencies ([#7100](https://github.com/novuhq/novu/pull/7100))

### 🩹 Fixes

- **api:** Migrate subscriber global preferences before workflow preferences ([#7118](https://github.com/novuhq/novu/pull/7118))
- **api, dal, framework:** fix the uneven and unused dependencies ([#7103](https://github.com/novuhq/novu/pull/7103))

### 🧱 Updated Dependencies

- Updated @novu/shared to 2.1.4

### ❤️  Thank You

- George Desipris @desiprisg
- Himanshu Garg @merrcury
- Richard Fontein @rifont

## 2.0.2 (2024-11-19)

### 🚀 Features

- **novu:** Add `--headless` flag to prevent automatic browser open with `npx novu dev` command ([#7016](https://github.com/novuhq/novu/pull/7016))
- **novu:** update novu init landing page ([#6805](https://github.com/novuhq/novu/pull/6805))

### 🩹 Fixes

- **root:** add novu cli flags and remove magicbell ([#6779](https://github.com/novuhq/novu/pull/6779))

### ❤️  Thank You

- Dima Grossman @scopsy
- Pawan Jain
- Richard Fontein @rifont

### ANALISIS AUTOMATICO (ESPAÑOL) ###

## 2.6.6 (2025-02-25)
### 🚀 Features
- **api-service:** system limits & update pricing pages ([#7718](https://github.com/novuhq/novu/pull/7718))
### 🩹 Fixes
### 🧱 Updated Dependencies
### ❤️ Thank You
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/novu/README.MD
Tamaño: 7029 bytes
Lenguaje detectado: Markdown

### CONTENIDO ORIGINAL ###

<div align="center">
  <a href="https://novu.co?utm_source=github" target="_blank">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://user-images.githubusercontent.com/2233092/213641039-220ac15f-f367-4d13-9eaf-56e79433b8c1.png">
    <img alt="Novu Logo" src="https://user-images.githubusercontent.com/2233092/213641043-3bbb3f21-3c53-4e67-afe5-755aeb222159.png" width="280"/>
  </picture>
  </a>
</div>

# Code-First Notifications Workflow Platform

  <p align="center">
    <br />
    <a href="https://docs.novu.co" rel="dofollow"><strong>Explore the docs »</strong></a>
    <br />

  <br/>
    <a href="https://github.com/novuhq/novu/issues/new?assignees=&labels=type%3A+bug&template=bug_report.yml&title=%F0%9F%90%9B+Bug+Report%3A+">Report Bug</a>
    ·
    <a href="https://github.com/novuhq/novu/issues/new?assignees=&labels=feature&template=feature_request.yml&title=%F0%9F%9A%80+Feature%3A+">Request Feature</a>
    ·
  <a href="https://discord.novu.co">Join Our Discord</a>
    ·
    <a href="https://roadmap.novu.co/">Roadmap</a>
    ·
    <a href="https://twitter.com/novuhq">X</a>
  </p>

## 🚀 Quickstart

```bash
npx novu@latest dev
```

## 🔥 Flags

| flag | long form usage example | description                 | default value             |
| ---- | ----------------------- | --------------------------- | ------------------------- |
| -p   | --port <port>           | Bridge application port     | 4000                      |
| -r   | --route <route>         | Bridge application route    | /api/novu                 |
| -o   | --origin <origin>       | Bridge application origin   | http://localhost          |
| -d   | --dashboard-url <url>   | Novu Cloud dashboard URL    | https://dashboard.novu.co |
| -sp  | --studio-port <port>    | Local Studio server port    | 2022                      |
| -sh  | --studio-host <host>    | Local Studio server host    | localhost                 |
| -t   | --tunnel <url>          | Self hosted tunnel url      | null                      |
| -H   | --headless              | Run bridge in headless mode | false                     |

Example: If bridge application is running on port `3002` and Novu account is in `EU` region.

```bash
npx novu@latest dev --port 3002 --dashboard-url https://eu.dashboard.novu.co
```

## ⭐️ Why

Building a notification system is hard, at first it seems like just sending an email but in reality it's just the beginning. In today's world users expect multichannel communication experience over email, sms, push, chat and more... An ever-growing list of providers are popping up each day, and notifications are spread around the code. Novu's goal is to simplify notifications and provide developers the tools to create meaningful communication between the system and its users.

## ✨ Features

- 🌈 Single API for all messaging provide`rs (Email, SMS, Push, Chat)
- 💅 Easily manage notification over multiple channels
- 🚀 Equipped with a CMS for advanced layouts and design management
- 🛡 Built-in protection for missing variables (Coming Soon)
- 📦 Easy to set up and integrate
- 🛡 Debug and analyze multichannel messages in a single dashboard
- 📦 Embeddable notification center with real-time updates
- 👨‍💻 Community driven

## 🚀 Getting Started

To start using Novu, run the following command. You'll be guided through the setup process.

```bash
npx novu init
```

After setting up your account using the cloud or docker version you can trigger the API using the `@novu/api` package.

```bash
npm install @novu/api
```

```ts
import { Novu } from '@novu/api';

const novu = new Novu({ secretKey: process.env.NOVU_API_KEY });

await novu.trigger('<WORKFLOW_ID>', {
  to: {
    subscriberId: '<SUBSCRIBER_ID>',
    email: 'john@doemail.com',
    firstName: 'John',
    lastName: 'Doe',
  },
  payload: {
    name: 'Hello World',
    organization: {
      logo: 'https://happycorp.com/logo.png',
    },
  },
});
```

## Inbox

Using the Novu API and admin panel you can easily add real-time notification center to your Next.js or React application without the hassle of building it yourself.

<div align="center">
<img width="762" alt="notification-center-912bb96e009fb3a69bafec23bcde00b0" src="https://github.com/iampearceman/Design-assets/blob/main/Untitled%20design%20(8).gif?raw=true">
  
  Read more about how to add a notification center to your app with the Novu API [here](https://docs.novu.co/platform/inbox/overview?utm_campaign=inapp-cli-readme)

</div>

## Providers

Novu provides a single API to manage providers across multiple channels with a simple-to-use interface.

#### 💌 Email

- [x] [Sendgrid](https://github.com/novuhq/novu/tree/main/providers/sendgrid)
- [x] [Netcore](https://github.com/novuhq/novu/tree/main/providers/netcore)
- [x] [Mailgun](https://github.com/novuhq/novu/tree/main/providers/mailgun)
- [x] [SES](https://github.com/novuhq/novu/tree/main/providers/ses)
- [x] [Postmark](https://github.com/novuhq/novu/tree/main/providers/postmark)
- [x] [NodeMailer](https://github.com/novuhq/novu/tree/main/providers/nodemailer)
- [x] [Mailjet](https://github.com/novuhq/novu/tree/main/providers/mailjet)
- [x] [Mandrill](https://github.com/novuhq/novu/tree/main/providers/mandrill)
- [x] [SendinBlue](https://github.com/novuhq/novu/tree/main/providers/sendinblue)
- [x] [EmailJS](https://github.com/novuhq/novu/tree/main/providers/emailjs)
- [ ] SparkPost

#### 📞 SMS

- [x] [Twilio](https://github.com/novuhq/novu/tree/main/providers/twilio)
- [x] [Plivo](https://github.com/novuhq/novu/tree/main/providers/plivo)
- [x] [SNS](https://github.com/novuhq/novu/tree/main/providers/sns)
- [x] [Nexmo - Vonage](https://github.com/novuhq/novu/tree/main/providers/nexmo)
- [x] [Sms77](https://github.com/novuhq/novu/tree/main/providers/sms77)
- [x] [Telnyx](https://github.com/novuhq/novu/tree/main/providers/telnyx)
- [x] [Termii](https://github.com/novuhq/novu/tree/main/providers/termii)
- [x] [Gupshup](https://github.com/novuhq/novu/tree/main/providers/gupshup)
- [ ] Bandwidth
- [ ] RingCentral

#### 📱 Push

- [x] [FCM](https://github.com/novuhq/novu/tree/main/providers/fcm)
- [x] [Expo](https://github.com/novuhq/novu/tree/main/providers/expo)
- [ ] [SNS](https://github.com/novuhq/novu/tree/main/providers/sns)
- [ ] Pushwoosh

#### 👇 Chat

- [x] [Slack](https://github.com/novuhq/novu/tree/main/providers/slack)
- [x] [Discord](https://github.com/novuhq/novu/tree/main/providers/discord)
- [ ] MS Teams
- [ ] Mattermost

#### 📱 In-App

- [x] [Novu](https://docs.novu.co/notification-center/introduction?utm_campaign=inapp-cli-readme)

#### Other (Coming Soon...)

- [ ] PagerDuty

## 💻 Need Help?

We are more than happy to help you. Don't worry if you are getting some errors or problems while working with the project. Or just want to discuss something related to the project.

Just <a href="https://discord.novu.co">Join Our Discord</a> server and ask for help.

## 🔗 Links

- [Home page](https://novu.co/)


### ANALISIS AUTOMATICO (ESPAÑOL) ###

<div align="center">
<a href="https://novu.co?utm_source=github" target="_blank">
<picture>
<source media="(prefers-color-scheme: dark)" srcset="https://user-images.githubusercontent.com/2233092/213641039-220ac15f-f367-4d13-9eaf-56e79433b8c1.png">
<img alt="Novu Logo" src="https://user-images.githubusercontent.com/2233092/213641043-3bbb3f21-3c53-4e67-afe5-755aeb222159.png" width="280"/>
# Code-First Notifications Workflow Platform
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/novu/nodemon-debug.json
Tamaño: 163 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "watch": ["src"],
  "ext": "ts",
  "ignore": ["src/**/*.spec.ts"],
  "exec": "node --inspect-brk -r ts-node/register -r tsconfig-paths/register src/main.ts"
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"watch": ["src"],
"ext": "ts",
"ignore": ["src/**/*.spec.ts"],
"exec": "node --inspect-brk -r ts-node/register -r tsconfig-paths/register src/main.ts"
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/novu/nodemon.json
Tamaño: 189 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "watch": ["src", "../core/dist"],
  "ext": "ts",
  "delay": 2,
  "ignoreRoot": [".git"],
  "ignore": ["src/**/*.spec.ts"],
  "exec": "ts-node -r tsconfig-paths/register src/index.ts"
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"watch": ["src", "../core/dist"],
"ext": "ts",
"delay": 2,
"ignoreRoot": [".git"],
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/novu/package.json
Tamaño: 3219 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "name": "novu",
  "version": "2.7.0",
  "description": "Novu CLI. Run Novu Studio and sync workflows with Novu Cloud",
  "main": "src/index.js",
  "publishConfig": {
    "access": "public"
  },
  "private": false,
  "repository": {
    "type": "git",
    "url": "git+https://github.com/novuhq/novu.git"
  },
  "files": [
    "dist",
    "package.json",
    "README.md"
  ],
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "pnpm prebuild && tsc -p tsconfig.json && cp -r src/commands/init/templates/app* dist/src/commands/init/templates && cp -r src/commands/init/templates/github dist/src/commands/init/templates",
    "build:prod": "pnpm prebuild && pnpm build",
    "precommit": "lint-staged",
    "start": "pnpm start:dev",
    "test": "vitest",
    "test:watch": "vitest --watch",
    "check": "biome check .",
    "check:fix": "biome check --write .",
    "start:dev": "cross-env NODE_ENV=dev NOVU_EMBED_PATH=http://127.0.0.1:4701/embed.umd.min.js NOVU_API_ADDRESS=http://127.0.0.1:3000 NOVU_CLIENT_LOGIN=http://127.0.0.1:4200/auth/login CLI_SEGMENT_WRITE_KEY=GdQ594CEBj4pU6RFldDOjKJwZjxZOsIj nodemon init",
    "start:mode": "cross-env NODE_ENV=dev CLI_SEGMENT_WRITE_KEY=GdQ594CEBj4pU6RFldDOjKJwZjxZOsIj nodemon",
    "start:dev:mode": "cross-env NODE_ENV=dev CLI_SEGMENT_WRITE_KEY=GdQ594CEBj4pU6RFldDOjKJwZjxZOsIj nodemon dev --dashboard-url http://localhost:4200",
    "start:init:mode": "cross-env NODE_ENV=dev nodemon init",
    "start:sync:mode": "cross-env NODE_ENV=dev CLI_SEGMENT_WRITE_KEY=GdQ594CEBj4pU6RFldDOjKJwZjxZOsIj nodemon sync",
    "start:test": "cross-env NODE_ENV=test PORT=1336 nodemon init",
    "start:debug": "cross-env nodemon --config nodemon-debug.json",
    "start:prod": "cross-env node dist/src/index.js",
    "print:project-path": "echo \"$PWD\" | sed 's|.*/novu/||'"
  },
  "keywords": [
    "novu",
    "cli",
    "novu-cli",
    "cloud",
    "sync",
    "studio"
  ],
  "author": "Novu Team <engineering@novu.co>",
  "license": "ISC",
  "bin": {
    "novu": "./dist/src/index.js"
  },
  "devDependencies": {
    "@types/configstore": "^5.0.1",
    "@types/gradient-string": "^1.1.6",
    "@types/validate-npm-package-name": "3.0.0",
    "@types/inquirer": "^8.2.0",
    "@types/mocha": "10.0.2",
    "@types/prompts": "2.4.2",
    "@types/uuid": "^8.3.4",
    "@types/ws": "^8.5.3",
    "ncp": "^2.0.0",
    "nodemon": "^3.0.1",
    "ts-node": "~10.9.1",
    "typescript": "5.6.2",
    "vitest": "^1.2.1"
  },
  "dependencies": {
    "@novu/ntfr-client": "^0.0.4",
    "@novu/shared": "workspace:*",
    "@segment/analytics-node": "^1.1.4",
    "axios": "^1.9.0",
    "chalk": "4.1.2",
    "commander": "^9.0.0",
    "configstore": "^5.0.0",
    "dotenv": "^16.4.5",
    "form-data": "^4.0.0",
    "get-port": "^5.1.1",
    "gradient-string": "^2.0.0",
    "inquirer": "^8.2.0",
    "jwt-decode": "^3.1.2",
    "open": "^8.4.0",
    "ora": "^5.4.1",
    "uuid": "^9.0.0",
    "ws": "^8.11.0",
    "picocolors": "^1.0.0",
    "validate-npm-package-name": "3.0.0",
    "prompts": "2.4.2",
    "@types/cross-spawn": "6.0.0",
    "cross-spawn": "7.0.5",
    "fast-glob": "3.3.1",
    "async-sema": "3.0.1"
  },
  "nx": {
    "tags": [
      "type:package"
    ]
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"name": "novu",
"version": "2.7.0",
"description": "Novu CLI. Run Novu Studio and sync workflows with Novu Cloud",
"main": "src/index.js",
Menciona package.json.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/novu/project.json
Tamaño: 240 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "name": "novu",
  "sourceRoot": "packages/novu/src",
  "projectType": "library",
  "targets": {
    "lint": {
      "executor": "nx:run-commands",
      "options": {
        "command": "npx biome lint packages/novu"
      }
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"name": "novu",
"sourceRoot": "packages/novu/src",
"projectType": "library",
"targets": {
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/novu/tsconfig.json
Tamaño: 564 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "allowSyntheticDefaultImports": true,
    "baseUrl": "./src",
    "declaration": false,
    "declarationMap": false,
    "emitDecoratorMetadata": true,
    "esModuleInterop": true,
    "module": "commonjs",
    "noImplicitAny": true,
    "outDir": "./dist",
    "removeComments": true,
    "resolveJsonModule": true,
    "sourceMap": false,
    "target": "es2017",
    "types": ["node"]
  },
  "include": ["src/**/*", "src/**/*.d.ts"],
  "exclude": ["node_modules", "src/commands/init/templates"]
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"extends": "../../tsconfig.json",
"compilerOptions": {
"allowSyntheticDefaultImports": true,
"baseUrl": "./src",
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/novu/src/index.ts
Tamaño: 4999 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

#!/usr/bin/env node

import { Command } from 'commander';
import { v4 as uuidv4 } from 'uuid';
import { DevCommandOptions, devCommand } from './commands';
import { IInitCommandOptions, init } from './commands/init';
import { sync } from './commands/sync';
import { pullTranslations, pushTranslations } from './commands/translations';
import { NOVU_API_URL, NOVU_SECRET_KEY } from './constants';
import { AnalyticService, ConfigService } from './services';

const analytics = new AnalyticService();
export const config = new ConfigService();
if (process.env.NODE_ENV === 'development') {
  config.clearStore();
}
const anonymousIdLocalState = config.getValue('anonymousId');
const anonymousId = anonymousIdLocalState || uuidv4();
const program = new Command();

program.name('novu').description(`A CLI tool to interact with Novu Cloud`);

program
  .command('sync')
  .description(
    `Sync your state with Novu Cloud

  Specifying the Bridge URL and Secret Key:
  (e.g., npx novu@latest sync -b https://acme.org/api/novu -s NOVU_SECRET_KEY)

  Sync with Novu Cloud in Europe:
  (e.g., npx novu@latest sync -b https://acme.org/api/novu -s NOVU_SECRET_KEY -a https://eu.api.novu.co)`
  )
  .usage('-b <url> -s <secret-key> [-a <url>]')
  .option('-a, --api-url <url>', 'The Novu Cloud API URL', NOVU_API_URL || 'https://api.novu.co')
  .requiredOption(
    '-b, --bridge-url <url>',
    'The Novu endpoint URL hosted in the Bridge application, by convention ends in /api/novu'
  )
  .requiredOption(
    '-s, --secret-key <secret-key>',
    'The Novu Secret Key. Obtainable at https://dashboard.novu.co/api-keys',
    NOVU_SECRET_KEY || ''
  )
  .action(async (options) => {
    analytics.track({
      identity: {
        anonymousId,
      },
      data: {},
      event: 'Sync Novu Endpoint State',
    });
    await sync(options.bridgeUrl, options.secretKey, options.apiUrl);
  });

program
  .command('dev')
  .description(
    `Start Novu Studio and a local tunnel

  Running the Bridge application on port 4000: 
  (e.g., npx novu@latest dev -p 4000)

  Running the Bridge application on a different route: 
  (e.g., npx novu@latest dev -r /v1/api/novu)
  
  Running with a custom tunnel:
  (e.g., npx novu@latest dev --tunnel https://my-tunnel.ngrok.app)`
  )
  .usage('[-p <port>] [-r <route>] [-o <origin>] [-d <dashboard-url>] [-sp <studio-port>] [-t <url>] [-H]')
  .option('-p, --port <port>', 'The local Bridge endpoint port', '4000')
  .option('-r, --route <route>', 'The Bridge endpoint route', '/api/novu')
  .option('-o, --origin <origin>', 'The Bridge endpoint origin')
  .option('-d, --dashboard-url <url>', 'The Novu Cloud Dashboard URL', 'https://dashboard.novu.co')
  .option('-sp, --studio-port <port>', 'The Local Studio server port', '2022')
  .option('-sh, --studio-host <host>', 'The Local Studio server host', 'localhost')
  .option('-t, --tunnel <url>', 'Self hosted tunnel. e.g. https://my-tunnel.ngrok.app')
  .option('-H, --headless', 'Run the Bridge in headless mode without opening the browser', false)
  .action(async (options: DevCommandOptions) => {
    analytics.track({
      identity: {
        anonymousId,
      },
      data: {},
      event: 'Open Dev Server',
    });

    return await devCommand(options, anonymousId);
  });

program
  .command('init')
  .description(`Create a new Novu application`)
  .option(
    '-s, --secret-key <secret-key>',
    `The Novu development environment Secret Key. Note that your Novu app won't work outside of local mode without it.`
  )
  .option('-a, --api-url <url>', 'The Novu Cloud API URL', 'https://api.novu.co')
  .action(async (options: IInitCommandOptions) => {
    return await init(options, anonymousId);
  });

const translationsCommand = program.command('translations').description('Manage Novu translations');

translationsCommand
  .command('pull')
  .description('Pull all translation files from Novu Cloud')
  .option('-s, --secret-key <secret-key>', 'The Novu Secret Key', NOVU_SECRET_KEY || '')
  .option('-a, --api-url <url>', 'The Novu Cloud API URL', NOVU_API_URL || 'https://api.novu.co')
  .option('-d, --directory <path>', 'Directory to save translation files', './translations')
  .action(async (options) => {
    analytics.track({
      identity: {
        anonymousId,
      },
      data: {},
      event: 'Pull Translations',
    });
    await pullTranslations(options);
  });

translationsCommand
  .command('push')
  .description('Push translation files to Novu Cloud')
  .option('-s, --secret-key <secret-key>', 'The Novu Secret Key', NOVU_SECRET_KEY || '')
  .option('-a, --api-url <url>', 'The Novu Cloud API URL', NOVU_API_URL || 'https://api.novu.co')
  .option('-d, --directory <path>', 'Directory containing translation files', './translations')
  .action(async (options) => {
    analytics.track({
      identity: {
        anonymousId,
      },
      data: {},
      event: 'Push Translations',
    });
    await pushTranslations(options);
  });

program.parse(process.argv);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - program(new Command();

program.name('novu').description(`A CLI tool to interact with Novu Cloud`);

program...)
 - translationsCommand(program.command('translations').description('Manage Novu translations');

translationsCommand
  .com...)
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/client/cli.client.ts
Tamaño: 205 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Answers, prompt as InquirerPrompt, ListQuestionOptions } from 'inquirer';

export async function prompt(questions: ListQuestionOptions[]): Promise<Answers> {
  return InquirerPrompt(questions);
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - prompt(questions: ListQuestionOptions[])
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/client/index.ts
Tamaño: 30 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './cli.client';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/animation.ts
Tamaño: 5649 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

// @ts-nocheck
import chalk from 'chalk';
import gradient from 'gradient-string';

/**
 * This packages is forked from 'chalk-animation' and modified to work with TypeScript.
 */

const { log } = console;
let currentAnimation = null;

const consoleFunctions = {
  log: log.bind(console),
  info: console.info.bind(console),
  warn: console.warn.bind(console),
  error: console.error.bind(console),
};

for (const func in consoleFunctions) {
  console[func] = (...args: any[]) => {
    stopLastAnimation();
    consoleFunctions[func].apply(console, args);
  };
}

const glitchChars = 'x*0987654321[]0-~@#(____!!!!\\|?????....0000\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t';
const longHsv = { interpolation: 'hsv', hsvSpin: 'long' };

const effects = {
  rainbow(str, frame) {
    const hue = 5 * frame;
    const leftColor = { h: hue % 360, s: 1, v: 1 };
    const rightColor = { h: (hue + 1) % 360, s: 1, v: 1 };

    return gradient(leftColor, rightColor)(str, longHsv);
  },
  pulse(str, frame) {
    frame = (frame % 120) + 1;
    const transition = 20;
    const duration = 15;
    const on = '#DD2476';
    const off = '#474747';

    if (frame >= 2 * transition + duration) {
      return chalk.hex(off)(str); // All white
    }
    if (frame >= transition && frame <= transition + duration) {
      return chalk.hex(on)(str); // All red
    }

    frame = frame >= transition + duration ? 2 * transition + duration - frame : frame; // Revert animation

    const g =
      frame <= transition / 2
        ? gradient([
            { color: off, pos: 0.5 - frame / transition },
            { color: on, pos: 0.5 },
            { color: off, pos: 0.5 + frame / transition },
          ])
        : gradient([
            { color: off, pos: 0 },
            { color: on, pos: 1 - frame / transition },
            { color: on, pos: frame / transition },
            { color: off, pos: 1 },
          ]);

    return g(str);
  },
  glitch(str, frame) {
    if ((frame % 2) + (frame % 3) + (frame % 11) + (frame % 29) + (frame % 37) > 52) {
      return str.replace(/[^\r\n]/g, ' ');
    }

    const chunkSize = Math.max(3, Math.round(str.length * 0.02));
    const chunks = [];

    for (let i = 0, { length } = str; i < length; i += 1) {
      const skip = Math.round(Math.max(0, (Math.random() - 0.8) * chunkSize));
      chunks.push(str.substring(i, i + skip).replace(/[^\r\n]/g, ' '));
      i += skip;
      if (str[i]) {
        if (str[i] !== '\n' && str[i] !== '\r' && Math.random() > 0.995) {
          chunks.push(glitchChars[Math.floor(Math.random() * glitchChars.length)]);
        } else if (Math.random() > 0.005) {
          chunks.push(str[i]);
        }
      }
    }

    let result = chunks.join('');
    if (Math.random() > 0.99) {
      result = result.toUpperCase();
    } else if (Math.random() < 0.01) {
      result = result.toLowerCase();
    }

    return result;
  },
  radar(str, frame) {
    const depth = Math.floor(Math.min(str.length, str.length * 0.2));
    const step = Math.floor(255 / depth);

    const globalPos = frame % (str.length + depth);

    const chars = [];
    for (let i = 0, { length } = str; i < length; i += 1) {
      const pos = -(i - globalPos);
      if (pos > 0 && pos <= depth - 1) {
        const shade = (depth - pos) * step;
        chars.push(chalk.rgb(shade, shade, shade)(str[i]));
      } else {
        chars.push(' ');
      }
    }

    return chars.join('');
  },
  neon(str, frame) {
    const color = frame % 2 === 0 ? chalk.dim.rgb(88, 80, 85) : chalk.bold.rgb(213, 70, 242);

    return color(str);
  },
  karaoke(str, frame) {
    const chars = (frame % (str.length + 20)) - 10;
    if (chars < 0) {
      return chalk.white(str);
    }

    return chalk.rgb(255, 187, 0).bold(str.substr(0, chars)) + chalk.white(str.substr(chars));
  },
};

function animateString(str, effect, delay, speed) {
  stopLastAnimation();

  speed = speed === undefined ? 1 : parseFloat(speed);
  if (!speed || speed <= 0) {
    throw new Error('Expected `speed` to be an number greater than 0');
  }

  currentAnimation = {
    text: str.split(/\r\n|\r|\n/),
    lines: str.split(/\r\n|\r|\n/).length,
    stopped: false,
    init: false,
    f: 0,
    render() {
      if (!this.init) {
        log('\n'.repeat(this.lines - 1));
        this.init = true;
      }
      log(this.frame());
      setTimeout(() => {
        if (!this.stopped) {
          this.render();
        }
      }, delay / speed);
    },
    frame() {
      this.f += 1;

      return `\u001B[${this.lines}F\u001B[G\u001B[2K${this.text.map((str) => effect(str, this.f)).join('\n')}`;
    },
    replace(str) {
      this.text = str.split(/\r\n|\r|\n/);
      this.lines = str.split(/\r\n|\r|\n/).length;

      return this;
    },
    stop() {
      this.stopped = true;

      return this;
    },
    start() {
      this.stopped = false;
      this.render();

      return this;
    },
  };
  setTimeout(() => {
    if (!currentAnimation.stopped) {
      currentAnimation.start();
    }
  }, delay / speed);

  return currentAnimation;
}

function stopLastAnimation() {
  if (currentAnimation) {
    currentAnimation.stop();
  }
}

const chalkAnimation = {
  rainbow: (str, speed) => animateString(str, effects.rainbow, 15, speed),
  pulse: (str, speed) => animateString(str, effects.pulse, 16, speed),
  glitch: (str, speed) => animateString(str, effects.glitch, 55, speed),
  radar: (str, speed) => animateString(str, effects.radar, 50, speed),
  neon: (str, speed) => animateString(str, effects.neon, 500, speed),
  karaoke: (str, speed) => animateString(str, effects.karaoke, 50, speed),
};

export default chalkAnimation;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - animateString(str, effect, delay, speed)
 - stopLastAnimation()
Asignaciones con arrow functions encontradas (posibles funciones):
 - init(true;
      }
      log(this.frame());
      setTimeout(())
 - stopped(false;
      this.render();

      return this;
    },
  };
  setTimeout(())
 - chalkAnimation({
  rainbow: (str, speed))
Declaraciones 'export' encontradas:
- export default  chalkAnimation

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/index.ts
Tamaño: 55 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './dev';
export * from './translations';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/shared.ts
Tamaño: 1307 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import chalk from 'chalk';
import gradient from 'gradient-string';
import chalkAnimation from './animation';

export async function showWelcomeScreen() {
  const textGradient = gradient('#0099F7', '#ff3432');
  const logoGradient = gradient('#DD2476', '#FF512F');
  const logo = `
                        @@@@@@@@@@@@@        
                @@@       @@@@@@@@@@@        
              @@@@@@@@       @@@@@@@@        
            @@@@@@@@@@@@       @@@@@@     @@ 
           @@@@@@@@@@@@@@@@      @@@@     @@@
          @@@@@@@@@@@@@@@@@@@       @     @@@
          @@@@@         @@@@@@@@         @@@@
           @@@     @       @@@@@@@@@@@@@@@@@@
           @@@     @@@@      @@@@@@@@@@@@@@@@
            @@     @@@@@@       @@@@@@@@@@@@ 
                   @@@@@@@@       @@@@@@@@   
                   @@@@@@@@@@@       @@@     
                   @@@@@@@@@@@@@                  
                          `;

  const items = logo.split('\n').map((row) => logoGradient(row));
  const animation = chalkAnimation.pulse(logo, 0.6);

  await new Promise<void>((resolve) => {
    setTimeout(() => {
      console.log(chalk.bold(`                      Welcome to NOVU!`));
      console.log(chalk.bold(textGradient(`         The open-source notification framework\n`)));
      resolve();
    }, 600);
  });
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - showWelcomeScreen()
Asignaciones con arrow functions encontradas (posibles funciones):
 - items(logo.split('\n').map((row))
 - animation(chalkAnimation.pulse(logo, 0.6);

  await new Promise<void>((resolve))
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/sync.spec.ts
Tamaño: 3112 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import axios from 'axios';
import { afterEach, describe, expect, it, MockedFunction, vi } from 'vitest';

import { buildSignature, sync } from './sync';

vi.mock('axios', () => {
  return {
    default: {
      post: vi.fn(),
      get: vi.fn(),
    },
  };
});

describe('sync command', () => {
  describe('sync function', () => {
    afterEach(() => {
      vi.clearAllMocks();
    });

    it('happy case of execute sync functions', async () => {
      const bridgeUrl = 'https://bridge.novu.co';
      const secretKey = 'your-api-key';
      const apiUrl = 'https://api.novu.co';
      const syncData = { someData: 'from sync' };

      const syncRestCallSpy = vi.spyOn(axios, 'post');

      (axios.post as MockedFunction<typeof axios.post>).mockResolvedValueOnce({
        data: syncData,
      });

      const response = await sync(bridgeUrl, secretKey, apiUrl);

      const expectBackendUrl = `${apiUrl}/v1/bridge/sync?source=cli`;
      expect(syncRestCallSpy).toHaveBeenCalledWith(
        expectBackendUrl,
        expect.objectContaining({ bridgeUrl }),
        expect.objectContaining({ headers: { Authorization: expect.any(String), 'Content-Type': 'application/json' } })
      );
      expect(response).toEqual(syncData);
    });

    it('syncState - network error on sync', async () => {
      const bridgeUrl = 'https://bridge.novu.co';
      const secretKey = 'your-api-key';
      const apiUrl = 'https://api.novu.co';

      (axios.post as MockedFunction<typeof axios.post>).mockRejectedValueOnce(new Error('Network error'));

      try {
        await sync(bridgeUrl, secretKey, apiUrl);
      } catch (error) {
        expect(error.message).toBe('Network error');
      }
    });

    it('syncState - unexpected error', async () => {
      const bridgeUrl = 'https://bridge.novu.co';
      const secretKey = 'your-api-key';
      const apiUrl = 'https://api.novu.co';

      (axios.get as MockedFunction<typeof axios.get>).mockResolvedValueOnce({ data: {} });
      (axios.post as MockedFunction<typeof axios.post>).mockImplementationOnce(() => {
        throw new Error('Unexpected error');
      });

      try {
        await sync(bridgeUrl, secretKey, apiUrl);
      } catch (error) {
        expect(error.message).toBe('Unexpected error');
      }
    });
  });

  describe('buildSignature function', () => {
    it('buildSignature - generates valid signature format', () => {
      const secretKey = 'your-api-key';
      const signature = buildSignature(secretKey);

      expect(signature).toMatch(/^t=\d+,v1=[0-9a-f]{64}$/); // Matches format: t=<timestamp>,v1=<hex hash>
    });

    it('buildSignature - generates different signatures for different timestamps', async () => {
      const secretKey = 'your-api-key';
      const signature1 = buildSignature(secretKey);

      // make sure we have different timestamps
      await new Promise((resolve) => {
        setTimeout(resolve, 10);
      });

      const signature2 = buildSignature(secretKey);

      expect(signature1).not.toEqual(signature2); // Check for different hashes with different timestamps
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - source(cli`;
      expect(syncRestCallSpy).toHaveBeenCalledWith(
        expectBackendUrl,
        expect.o...)
 - apiUrl('https://api.novu.co';

      (axios.post as MockedFunction<typeof axios.post>).mockRejectedValueOnc...)
 - apiUrl('https://api.novu.co';

      (axios.get as MockedFunction<typeof axios.get>).mockResolvedValueOnce(...)
 - v1(<hex hash>
    });

    it('buildSignature - generates different signatures for different timestamps...)
 - signature1(buildSignature(secretKey);

      // make sure we have different timestamps
      await new Promise(...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/sync.ts
Tamaño: 1524 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import axios from 'axios';
import { createHmac } from 'crypto';

export async function sync(bridgeUrl: string, secretKey: string, apiUrl: string) {
  if (!bridgeUrl) {
    throw new Error('A bridge URL is required for the sync command, please supply it when running the command');
  }

  if (!secretKey) {
    throw new Error('A secret key is required for the sync command, please supply it when running the command');
  }

  if (!apiUrl) {
    throw new Error(
      'An API url is required for the sync command, please omit the configuration option entirely or supply a valid API url when running the command'
    );
  }
  const syncResult = await executeSync(apiUrl, bridgeUrl, secretKey);

  if (syncResult.status >= 400) {
    console.error(new Error(JSON.stringify(syncResult.data)));
    process.exit(1);
  }

  return syncResult.data;
}

export async function executeSync(apiUrl: string, bridgeUrl: string, secretKey: string) {
  const url = `${apiUrl}/v1/bridge/sync?source=cli`;

  return await axios.post(
    url,
    {
      bridgeUrl,
    },
    {
      headers: {
        'Content-Type': 'application/json',
        Authorization: `ApiKey ${secretKey}`,
      },
    }
  );
}

export function buildSignature(secretKey: string) {
  const timestamp = Date.now();

  return `t=${timestamp},v1=${buildHmac(secretKey, timestamp)}`;
}

export function buildHmac(secretKey: string, timestamp: number) {
  return createHmac('sha256', secretKey)
    .update(`${timestamp}.${JSON.stringify({})}`)
    .digest('hex');
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - sync(bridgeUrl: string, secretKey: string, apiUrl: string)
 - executeSync(apiUrl: string, bridgeUrl: string, secretKey: string)
 - buildSignature(secretKey: string)
 - buildHmac(secretKey: string, timestamp: number)
Declaraciones 'export' encontradas:
- export  async
- export  async
- export function buildSignature
- export function buildHmac

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/dev/dev.ts
Tamaño: 4874 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { NtfrTunnel } from '@novu/ntfr-client';
import chalk from 'chalk';
import open from 'open';
import ora from 'ora';
import ws from 'ws';
import packageJson from '../../../package.json';
import { DevServer } from '../../dev-server';
import { config } from '../../index';
import { showWelcomeScreen } from '../shared';
import { DevCommandOptions, LocalTunnelResponse } from './types';
import { parseOptions, wait } from './utils';

process.on('SIGINT', () => {
  // TODO: Close the NTFR Tunnel
  process.exit();
});

let tunnelClient: NtfrTunnel | null = null;
export const TUNNEL_URL = 'https://novu.sh/api/tunnels';
const { version } = packageJson;

export async function devCommand(options: DevCommandOptions, anonymousId?: string) {
  await showWelcomeScreen();

  const parsedOptions = parseOptions(options);
  const NOVU_ENDPOINT_PATH = options.route;
  let tunnelOrigin: string;

  const devSpinner = ora('Creating a development local tunnel').start();

  if (parsedOptions.tunnel) {
    tunnelOrigin = parsedOptions.tunnel;
  } else {
    tunnelOrigin = await createTunnel(parsedOptions.origin, NOVU_ENDPOINT_PATH);
  }
  devSpinner.succeed(`🛣️  Tunnel    → ${tunnelOrigin}${NOVU_ENDPOINT_PATH}`);

  const opts = {
    ...parsedOptions,
    tunnelOrigin,
    anonymousId,
  };

  const httpServer = new DevServer(opts);

  const dashboardSpinner = ora('Opening dashboard').start();
  const studioSpinner = ora('Starting local studio server').start();
  await httpServer.listen();

  dashboardSpinner.succeed(`🖥️  Dashboard → ${parsedOptions.dashboardUrl}`);
  studioSpinner.succeed(`🎨 Studio    → ${httpServer.getStudioAddress()}`);
  if (process.env.NODE_ENV !== 'dev' && parsedOptions.headless === false) {
    await open(httpServer.getStudioAddress());
  }

  await monitorEndpointHealth(parsedOptions, NOVU_ENDPOINT_PATH);
}

async function monitorEndpointHealth(parsedOptions: DevCommandOptions, endpointRoute: string) {
  const fullEndpoint = `${parsedOptions.origin}${endpointRoute}`;
  let healthy = false;
  const endpointText = `Bridge Endpoint scan:\t${fullEndpoint}
  
  Ensure your application is configured and running locally.`;
  const endpointSpinner = ora(endpointText).start();

  let counter = 0;
  while (!healthy) {
    try {
      healthy = await tunnelHealthCheck(fullEndpoint);

      if (healthy) {
        endpointSpinner.succeed(`🌉 Endpoint  → ${fullEndpoint}`);
      } else {
        await wait(1000);
      }
    } catch (e) {
      await wait(1000);
    } finally {
      counter += 1;

      if (counter === 10) {
        endpointSpinner.text = `Bridge Endpoint scan:\t${fullEndpoint}

  Ensure your application is configured and running locally.

  Starting out? Use our starter ${chalk.bold('npx novu@latest init')}
  Running on a different route or port? Use ${chalk.bold('--route')} or ${chalk.bold('--port')}
          `;
      }
    }
  }
}

async function tunnelHealthCheck(configTunnelUrl: string): Promise<boolean> {
  try {
    const res = await (
      await fetch(`${configTunnelUrl}?action=health-check`, {
        method: 'GET',
        headers: {
          accept: 'application/json',
          'Content-Type': 'application/json',
          'User-Agent': `novu@${version}`,
        },
      })
    ).json();

    return res.status === 'ok';
  } catch (e) {
    return false;
  }
}

async function createTunnel(localOrigin: string, endpointRoute: string): Promise<string> {
  const originUrl = new URL(localOrigin);
  const configTunnelUrl = config.getValue(`tunnelUrl-${parseInt(originUrl.port, 10)}`);
  const storeUrl = configTunnelUrl ? new URL(configTunnelUrl) : null;

  if (storeUrl) {
    try {
      await connectToTunnel(storeUrl, originUrl);

      if (tunnelClient.isConnected) {
        return storeUrl.origin;
      }
    } catch (error) {
      return await connectToNewTunnel(originUrl);
    }
  }

  return await connectToNewTunnel(originUrl);
}

async function fetchNewTunnel(originUrl: URL): Promise<URL> {
  const response = await fetch(TUNNEL_URL, {
    method: 'POST',
    headers: {
      accept: 'application/json',
      'Content-Type': 'application/json',
      authorization: `Bearer 12345`,
    },
  });

  const { url } = (await response.json()) as LocalTunnelResponse;
  config.setValue(`tunnelUrl-${parseInt(originUrl.port, 10)}`, url);

  return new URL(url);
}

async function connectToTunnel(parsedUrl: URL, parsedOrigin: URL) {
  tunnelClient = new NtfrTunnel(
    parsedUrl.host,
    parsedOrigin.host,
    false,
    {
      WebSocket: ws,
      connectionTimeout: 2000,
      maxRetries: Infinity,
    },
    { verbose: false }
  );

  await tunnelClient.connect();
}

async function connectToNewTunnel(originUrl: URL) {
  const parsedUrl = await fetchNewTunnel(originUrl);
  await connectToTunnel(parsedUrl, originUrl);

  return parsedUrl.origin;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - devCommand(options: DevCommandOptions, anonymousId?: string)
 - monitorEndpointHealth(parsedOptions: DevCommandOptions, endpointRoute: string)
 - tunnelHealthCheck(configTunnelUrl: string)
 - createTunnel(localOrigin: string, endpointRoute: string)
 - fetchNewTunnel(originUrl: URL)
 - connectToTunnel(parsedUrl: URL, parsedOrigin: URL)
 - connectToNewTunnel(originUrl: URL)
Declaraciones 'export' encontradas:
- export  const
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/dev/enums.ts
Tamaño: 239 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export enum CloudRegionEnum {
  US = 'us',
  EU = 'eu',
  STAGING = 'staging',
}

export enum DashboardUrlEnum {
  US = 'https://dashboard.novu.co',
  EU = 'https://eu.dashboard.novu.co',
  STAGING = 'https://dashboard.novu-staging.co',
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  enum
- export  enum

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/dev/index.ts
Tamaño: 81 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export { devCommand } from './dev';
export { DevCommandOptions } from './types';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/dev/types.ts
Tamaño: 340 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CloudRegionEnum } from './enums';

export type DevCommandOptions = {
  port: string;
  origin: string;
  region: `${CloudRegionEnum}`;
  studioPort: string;
  studioHost: string;
  dashboardUrl: string;
  route: string;
  tunnel: string;
  headless: boolean;
};

export type LocalTunnelResponse = {
  id: string;
  url: string;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/dev/utils.ts
Tamaño: 903 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SERVER_HOST } from '../../constants';
import { CloudRegionEnum, DashboardUrlEnum } from './enums';
import { DevCommandOptions } from './types';

export function wait(ms: number) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}

function getDefaultOrigin(port: string) {
  return `http://${SERVER_HOST}:${port}`;
}

function getDefaultDashboardUrl(region: string) {
  switch (region) {
    case CloudRegionEnum.EU:
      return DashboardUrlEnum.EU;
    case CloudRegionEnum.STAGING:
      return DashboardUrlEnum.STAGING;
    case CloudRegionEnum.US:
    default:
      return DashboardUrlEnum.US;
  }
}

export function parseOptions(options: DevCommandOptions) {
  const { origin, port, region } = options || {};

  return {
    ...options,
    origin: origin || getDefaultOrigin(port),
    dashboardUrl: options.dashboardUrl || getDefaultDashboardUrl(region),
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - wait(ms: number)
 - getDefaultOrigin(port: string)
 - getDefaultDashboardUrl(region: string)
 - parseOptions(options: DevCommandOptions)
Declaraciones 'export' encontradas:
- export function wait
- export function parseOptions

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/create-app.ts
Tamaño: 2423 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import fs from 'fs';
import path from 'path';
import { cyan, green } from 'picocolors';
import type { RepoInfo } from './helpers/examples';
import type { PackageManager } from './helpers/get-pkg-manager';
import { tryGitInit } from './helpers/git';
import { isFolderEmpty } from './helpers/is-folder-empty';
import { getOnline } from './helpers/is-online';
import { isWriteable } from './helpers/is-writeable';

import type { TemplateMode, TemplateType } from './templates';
import { installTemplate } from './templates';

export class DownloadError extends Error {}

export async function createApp({
  appPath,
  packageManager,
  typescript,
  eslint,
  srcDir,
  importAlias,
  secretKey,
  applicationId,
  userId,
}: {
  appPath: string;
  packageManager: PackageManager;
  typescript: boolean;
  eslint: boolean;
  srcDir: boolean;
  importAlias: string;
  secretKey: string;
  applicationId: string;
  userId: string;
}): Promise<void> {
  let repoInfo: RepoInfo | undefined;
  const mode: TemplateMode = typescript ? 'ts' : 'js';
  const template: TemplateType = 'app-react-email';

  const root = path.resolve(appPath);

  if (!(await isWriteable(path.dirname(root)))) {
    console.error('The application path is not writable, please check folder permissions and try again.');
    console.error('It is likely you do not have write permissions for this folder.');
    process.exit(1);
  }

  const appName = path.basename(root);

  fs.mkdirSync(root, { recursive: true });
  if (!isFolderEmpty(root, appName)) {
    process.exit(1);
  }

  const useYarn = packageManager === 'yarn';
  const isOnline = !useYarn || (await getOnline());
  const originalDirectory = process.cwd();

  console.log(`Creating a new Novu app in ${green(root)}.`);
  console.log();

  process.chdir(root);

  /**
   * If an example repository is not provided for cloning, proceed
   * by installing from a template.
   */
  await installTemplate({
    appName,
    root,
    template,
    mode,
    packageManager,
    isOnline,
    eslint,
    srcDir,
    importAlias,
    secretKey,
    applicationId,
    userId,
  });

  if (tryGitInit(root)) {
    console.log('Initialized a git repository.');
    console.log();
  }

  let cdPath: string;
  if (path.join(originalDirectory, appName) === appPath) {
    cdPath = appName;
  } else {
    cdPath = appPath;
  }

  console.log(`${green('Success!')} Created ${appName} at ${appPath}`);
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - createApp({
  appPath,
  packageManager,
  typescript,
  eslint,
  srcDir,
  importAlias,
  secretKey,
  applicationId,
  userId,
}: {
  appPath: string;
  packageManager: PackageManager;
  typescript: boolean;
  eslint: boolean;
  srcDir: boolean;
  importAlias: string;
  secretKey: string;
  applicationId: string;
  userId: string;
})
Declaraciones 'export' encontradas:
- export class DownloadError
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/index.ts
Tamaño: 5338 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import fs from 'fs';
import path from 'path';
import { bold, cyan, green, red } from 'picocolors';
import type { InitialReturnValue } from 'prompts';
import prompts from 'prompts';
import { AnalyticService } from '../../services/analytics.service';
import { createApp } from './create-app';
import { isFolderEmpty } from './helpers/is-folder-empty';
import { validateNpmName } from './helpers/validate-pkg';

const analytics = new AnalyticService();

const programName = 'novu init';

const onPromptState = (state: { value: InitialReturnValue; aborted: boolean; exited: boolean }) => {
  if (state.aborted) {
    /*
     * If we don't re-enable the terminal cursor before exiting
     * the program, the cursor will remain hidden
     */
    process.stdout.write('\x1B[?25h');
    process.stdout.write('\n');
    process.exit(1);
  }
};

export interface IInitCommandOptions {
  secretKey?: string;
  projectPath?: string;
  apiUrl: string;
}

export async function init(program: IInitCommandOptions, anonymousId?: string): Promise<void> {
  if (anonymousId) {
    analytics.track({
      identity: {
        anonymousId,
      },
      data: {},
      event: 'Run Novu Init Command',
    });
  }

  let { projectPath } = program;

  if (typeof projectPath === 'string') {
    projectPath = projectPath.trim();
  }

  if (!projectPath) {
    const res = await prompts({
      onState: onPromptState,
      type: 'text',
      name: 'path',
      message: 'What is your project named?',
      initial: 'my-novu-app',
      validate: (name: string) => {
        const validation = validateNpmName(path.basename(path.resolve(name)));
        if (validation.valid) {
          return true;
        }

        return `Invalid project name: ${(validation as any).problems[0]}`;
      },
    });

    if (typeof res.path === 'string') {
      projectPath = res.path.trim();
    }
  }

  if (!projectPath) {
    console.log(
      '\nPlease specify the project directory:\n' +
        `  ${cyan(programName)} ${green('<project-directory>')}\n` +
        'For example:\n' +
        `  ${cyan(programName)} ${green('my-novu-app')}\n\n` +
        `Run ${cyan(`${programName} --help`)} to see all options.`
    );
    process.exit(1);
  }

  const resolvedProjectPath = path.resolve(projectPath);
  const projectName = path.basename(resolvedProjectPath);

  const validation = validateNpmName(projectName);
  if (!validation.valid) {
    console.error(`Could not create a project called ${red(`"${projectName}"`)} because of npm naming restrictions:`);

    (validation as any).problems.forEach((problem: string) => {
      console.error(`    ${red(bold('*'))} ${problem}`);
    });
    process.exit(1);
  }

  let applicationId: string;
  let userId: string;
  // if no secret key is supplied set to empty string
  if (!program.secretKey) {
    program.secretKey = '';
  } else {
    try {
      const response = await fetch(`${program.apiUrl}/v1/users/me`, {
        headers: {
          Authorization: `ApiKey ${program.secretKey}`,
        },
      });

      if (!response.ok) {
        throw new Error('Failed to fetch api key details');
      }

      const user = await response.json();

      userId = user.data?._id;

      const integrationsResponse = await fetch(`${program.apiUrl}/v1/environments/me`, {
        headers: {
          Authorization: `ApiKey ${program.secretKey}`,
        },
      });

      const environment = await integrationsResponse.json();
      applicationId = environment.data.identifier;

      analytics.alias({
        previousId: anonymousId,
        userId,
      });
    } catch (error) {
      console.error(
        `Failed to verify your secret key against ${program.apiUrl}. For EU instances use --api-url https://eu.api.novu.co or provide the correct secret key`
      );

      process.exit(1);
    }
  }

  /**
   * Verify the project dir is empty or doesn't exist
   */
  const root = path.resolve(resolvedProjectPath);
  const appName = path.basename(root);
  const folderExists = fs.existsSync(root);

  if (folderExists && !isFolderEmpty(root, appName)) {
    console.error("The supplied project directory isn't empty, please provide an empty or non existing directory.");
    process.exit(1);
  }

  const preferences = {} as Record<string, boolean | string>;
  /**
   * If the user does not provide the necessary flags, prompt them for whether
   * to use TS or JS.
   */
  const defaults: typeof preferences = {
    typescript: true,
    eslint: true,
    app: true,
    srcDir: false,
    importAlias: '@/*',
    customizeImportAlias: false,
  };

  if (userId || anonymousId) {
    analytics.track({
      identity: userId ? { userId } : { anonymousId },
      data: {
        name: projectName,
      },
      event: 'Creating a new project',
    });
  }

  await createApp({
    appPath: resolvedProjectPath,
    packageManager: 'npm',
    typescript: defaults.typescript as boolean,
    eslint: defaults.eslint as boolean,
    srcDir: defaults.srcDir as boolean,
    importAlias: defaults.importAlias as string,
    secretKey: program.secretKey,
    applicationId,
    userId,
  });

  if (userId || anonymousId) {
    analytics.track({
      identity: userId ? { userId } : { anonymousId },
      data: {
        name: projectName,
      },
      event: 'Project created',
    });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - init(program: IInitCommandOptions, anonymousId?: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - onPromptState(state: { value: InitialReturnValue; aborted: boolean; exited: boolean }))
 - res(await prompts({
      onState: onPromptState,
      type: 'text',
      name: 'path',
      message:...)
 - validation(validateNpmName(projectName);
  if (!validation.valid) {
    console.error(`Could not create a proje...)
Declaraciones 'export' encontradas:
- export  interface
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/helpers/copy.ts
Tamaño: 1202 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { async as glob } from 'fast-glob';
import fs from 'fs';
import path from 'path';

interface CopyOption {
  cwd?: string;
  rename?: (basename: string) => string;
  parents?: boolean;
}

const identity = (x: string) => x;

export const copy = async (
  src: string | string[],
  dest: string,
  { cwd, rename = identity, parents = true }: CopyOption = {}
) => {
  const source = typeof src === 'string' ? [src] : src;

  if (source.length === 0 || !dest) {
    throw new TypeError('`src` and `dest` are required');
  }

  const sourceFiles = await glob(source, {
    cwd,
    dot: true,
    absolute: false,
    stats: false,
  });

  const destRelativeToCwd = cwd ? path.resolve(cwd, dest) : dest;

  return Promise.all(
    sourceFiles.map(async (p) => {
      const dirname = path.dirname(p);
      const basename = rename(path.basename(p));

      const from = cwd ? path.resolve(cwd, p) : p;
      const to = parents ? path.join(destRelativeToCwd, dirname, basename) : path.join(destRelativeToCwd, basename);

      // Ensure the destination directory exists
      await fs.promises.mkdir(path.dirname(to), { recursive: true });

      return fs.promises.copyFile(from, to);
    })
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - identity(x: string))
 - CopyOption({}
))
 - destRelativeToCwd(cwd ? path.resolve(cwd, dest) : dest;

  return Promise.all(
    sourceFiles.map(async (p))
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/helpers/examples.ts
Tamaño: 3463 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Readable } from 'stream';
import { pipeline } from 'stream/promises';
import tar from 'tar';

export type RepoInfo = {
  username: string;
  name: string;
  branch: string;
  filePath: string;
};

export async function isUrlOk(url: string): Promise<boolean> {
  try {
    const res = await fetch(url, { method: 'HEAD' });
    return res.status === 200;
  } catch {
    return false;
  }
}

export async function getRepoInfo(url: URL, examplePath?: string): Promise<RepoInfo | undefined> {
  const [, username, name, t, _branch, ...file] = url.pathname.split('/');
  const filePath = examplePath ? examplePath.replace(/^\//, '') : file.join('/');

  if (
    // Support repos whose entire purpose is to be a Next.js example, e.g.
    // https://github.com/:username/:my-cool-nextjs-example-repo-name.
    t === undefined ||
    // Support GitHub URL that ends with a trailing slash, e.g.
    // https://github.com/:username/:my-cool-nextjs-example-repo-name/
    // In this case "t" will be an empty string while the next part "_branch" will be undefined
    (t === '' && _branch === undefined)
  ) {
    try {
      const infoResponse = await fetch(`https://api.github.com/repos/${username}/${name}`);
      if (infoResponse.status !== 200) {
        return;
      }

      const info = await infoResponse.json();
      return { username, name, branch: info['default_branch'], filePath };
    } catch {
      return;
    }
  }

  // If examplePath is available, the branch name takes the entire path
  const branch = examplePath ? `${_branch}/${file.join('/')}`.replace(new RegExp(`/${filePath}|/$`), '') : _branch;

  if (username && name && branch && t === 'tree') {
    return { username, name, branch, filePath };
  }
}

export function hasRepo({ username, name, branch, filePath }: RepoInfo): Promise<boolean> {
  const contentsUrl = `https://api.github.com/repos/${username}/${name}/contents`;
  const packagePath = `${filePath ? `/${filePath}` : ''}/package.json`;

  return isUrlOk(contentsUrl + packagePath + `?ref=${branch}`);
}

export function existsInRepo(nameOrUrl: string): Promise<boolean> {
  try {
    const url = new URL(nameOrUrl);
    return isUrlOk(url.href);
  } catch {
    return isUrlOk(`https://api.github.com/repos/vercel/next.js/contents/examples/${encodeURIComponent(nameOrUrl)}`);
  }
}

async function downloadTarStream(url: string) {
  const res = await fetch(url);

  if (!res.body) {
    throw new Error(`Failed to download: ${url}`);
  }

  return Readable.fromWeb(res.body as import('stream/web').ReadableStream);
}

export async function downloadAndExtractRepo(root: string, { username, name, branch, filePath }: RepoInfo) {
  await pipeline(
    await downloadTarStream(`https://codeload.github.com/${username}/${name}/tar.gz/${branch}`),
    tar.x({
      cwd: root,
      strip: filePath ? filePath.split('/').length + 1 : 1,
      filter: (p) => p.startsWith(`${name}-${branch.replace(/\//g, '-')}${filePath ? `/${filePath}/` : '/'}`),
    })
  );
}

export async function downloadAndExtractExample(root: string, name: string) {
  if (name === '__internal-testing-retry') {
    throw new Error('This is an internal example for testing the CLI.');
  }

  await pipeline(
    await downloadTarStream('https://codeload.github.com/vercel/next.js/tar.gz/canary'),
    tar.x({
      cwd: root,
      strip: 2 + name.split('/').length,
      filter: (p) => p.includes(`next.js-canary/examples/${name}/`),
    })
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - isUrlOk(url: string)
 - getRepoInfo(url: URL, examplePath?: string)
 - hasRepo({ username, name, branch, filePath }: RepoInfo)
 - existsInRepo(nameOrUrl: string)
 - downloadTarStream(url: string)
 - downloadAndExtractRepo(root: string, { username, name, branch, filePath }: RepoInfo)
 - downloadAndExtractExample(root: string, name: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - res(await fetch(url);

  if (!res.body) {
    throw new Error(`Failed to download: ${url}`);
  }

  retu...)
Declaraciones 'export' encontradas:
- export  type
- export  async
- export  async
- export function hasRepo
- export function existsInRepo
- export  async
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/helpers/get-pkg-manager.ts
Tamaño: 377 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export type PackageManager = 'npm' | 'pnpm' | 'yarn' | 'bun';

export function getPkgManager(): PackageManager {
  const userAgent = process.env.npm_config_user_agent || '';

  if (userAgent.startsWith('yarn')) {
    return 'yarn';
  }

  if (userAgent.startsWith('pnpm')) {
    return 'pnpm';
  }

  if (userAgent.startsWith('bun')) {
    return 'bun';
  }

  return 'npm';
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getPkgManager()
Declaraciones 'export' encontradas:
- export  type
- export function getPkgManager

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/helpers/git.ts
Tamaño: 1329 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';

function isInGitRepository(): boolean {
  try {
    execSync('git rev-parse --is-inside-work-tree', { stdio: 'ignore' });
    return true;
  } catch (_) {}
  return false;
}

function isInMercurialRepository(): boolean {
  try {
    execSync('hg --cwd . root', { stdio: 'ignore' });
    return true;
  } catch (_) {}
  return false;
}

function isDefaultBranchSet(): boolean {
  try {
    execSync('git config init.defaultBranch', { stdio: 'ignore' });
    return true;
  } catch (_) {}
  return false;
}

export function tryGitInit(root: string): boolean {
  let didInit = false;
  try {
    execSync('git --version', { stdio: 'ignore' });
    if (isInGitRepository() || isInMercurialRepository()) {
      return false;
    }

    execSync('git init', { stdio: 'ignore' });
    didInit = true;

    if (!isDefaultBranchSet()) {
      execSync('git checkout -b main', { stdio: 'ignore' });
    }

    execSync('git add -A', { stdio: 'ignore' });
    execSync('git commit -m "Initial commit from Create Novu App"', {
      stdio: 'ignore',
    });
    return true;
  } catch (e) {
    if (didInit) {
      try {
        fs.rmSync(path.join(root, '.git'), { recursive: true, force: true });
      } catch (_) {}
    }
    return false;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - isInGitRepository()
 - isInMercurialRepository()
 - isDefaultBranchSet()
 - tryGitInit(root: string)
Declaraciones 'export' encontradas:
- export function tryGitInit

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/helpers/install.ts
Tamaño: 1353 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import spawn from 'cross-spawn';
import { yellow } from 'picocolors';
import type { PackageManager } from './get-pkg-manager';

/**
 * Spawn a package manager installation based on user preference.
 *
 * @returns A Promise that resolves once the installation is finished.
 */
export async function install(
  /** Indicate which package manager to use. */
  packageManager: PackageManager,
  /** Indicate whether there is an active Internet connection.*/
  isOnline: boolean
): Promise<void> {
  const args: string[] = ['install'];
  if (!isOnline) {
    console.log(yellow('You appear to be offline.\nFalling back to the local cache.'));
    args.push('--offline');
  }
  /**
   * Return a Promise that resolves once the installation is finished.
   */
  return new Promise((resolve, reject) => {
    /**
     * Spawn the installation process.
     */
    const child = spawn(packageManager, args, {
      stdio: 'inherit',
      env: {
        ...process.env,
        ADBLOCK: '1',
        // we set NODE_ENV to development as pnpm skips dev
        // dependencies when production
        NODE_ENV: 'development',
        DISABLE_OPENCOLLECTIVE: '1',
      },
    });
    child.on('close', (code) => {
      if (code !== 0) {
        reject({ command: `${packageManager} ${args.join(' ')}` });
        return;
      }
      resolve();
    });
  });
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - install(/** Indicate which package manager to use. */
  packageManager: PackageManager,
  /** Indicate whether there is an active Internet connection.*/
  isOnline: boolean)
Asignaciones con arrow functions encontradas (posibles funciones):
 - child(spawn(packageManager, args, {
      stdio: 'inherit',
      env: {
        ...process.env,
        A...)
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/helpers/is-folder-empty.ts
Tamaño: 1324 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import fs from 'fs';
import path from 'path';
import { blue, green } from 'picocolors';

export function isFolderEmpty(root: string, name: string): boolean {
  const validFiles = [
    '.DS_Store',
    '.git',
    '.gitattributes',
    '.gitignore',
    '.gitlab-ci.yml',
    '.hg',
    '.hgcheck',
    '.hgignore',
    '.idea',
    '.npmignore',
    '.travis.yml',
    'LICENSE',
    'Thumbs.db',
    'docs',
    'mkdocs.yml',
    'npm-debug.log',
    'yarn-debug.log',
    'yarn-error.log',
    'yarnrc.yml',
    '.yarn',
  ];

  const conflicts = fs.readdirSync(root).filter(
    (file) =>
      !validFiles.includes(file) &&
      // Support IntelliJ IDEA-based editors
      !/\.iml$/.test(file)
  );

  if (conflicts.length > 0) {
    console.log(`The directory ${green(name)} contains files that could conflict:`);
    console.log();
    for (const file of conflicts) {
      try {
        const stats = fs.lstatSync(path.join(root, file));
        if (stats.isDirectory()) {
          console.log(`  ${blue(file)}/`);
        } else {
          console.log(`  ${file}`);
        }
      } catch {
        console.log(`  ${file}`);
      }
    }
    console.log();
    console.log('Either try using a new directory name, or remove the files listed above.');
    console.log();
    return false;
  }

  return true;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - isFolderEmpty(root: string, name: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - conflicts(fs.readdirSync(root).filter(
    (file))
Declaraciones 'export' encontradas:
- export function isFolderEmpty

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/helpers/is-online.ts
Tamaño: 1109 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { execSync } from 'child_process';
import dns from 'dns/promises';
import url from 'url';

function getProxy(): string | undefined {
  if (process.env.https_proxy) {
    return process.env.https_proxy;
  }

  try {
    const httpsProxy = execSync('npm config get https-proxy').toString().trim();
    return httpsProxy !== 'null' ? httpsProxy : undefined;
  } catch (e) {
    return;
  }
}

export async function getOnline(): Promise<boolean> {
  try {
    await dns.lookup('registry.yarnpkg.com');
    // If DNS lookup succeeds, we are online
    return true;
  } catch {
    // The DNS lookup failed, but we are still fine as long as a proxy has been set
    const proxy = getProxy();
    if (!proxy) {
      return false;
    }

    const { hostname } = url.parse(proxy);
    if (!hostname) {
      // Invalid proxy URL
      return false;
    }

    try {
      await dns.lookup(hostname);
      // If DNS lookup succeeds for the proxy server, we are online
      return true;
    } catch {
      // The DNS lookup for the proxy server also failed, so we are offline
      return false;
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getProxy()
 - getOnline()
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/helpers/is-writeable.ts
Tamaño: 239 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import fs from 'fs';

export async function isWriteable(directory: string): Promise<boolean> {
  try {
    await fs.promises.access(directory, (fs.constants || (fs as any)).W_OK);
    return true;
  } catch (err) {
    return false;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - isWriteable(directory: string)
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/helpers/validate-pkg.ts
Tamaño: 504 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import validateProjectName from 'validate-npm-package-name';

type ValidateNpmNameResult =
  | {
      valid: true;
    }
  | {
      valid: false;
      problems: string[];
    };

export function validateNpmName(name: string): ValidateNpmNameResult {
  const nameValidation = validateProjectName(name);
  if (nameValidation.validForNewPackages) {
    return { valid: true };
  }

  return {
    valid: false,
    problems: [...(nameValidation.errors || []), ...(nameValidation.warnings || [])],
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - validateNpmName(name: string)
Declaraciones 'export' encontradas:
- export function validateNpmName

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/index.ts
Tamaño: 7321 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Sema } from 'async-sema';
import { async as glob } from 'fast-glob';
import fs from 'fs/promises';
import os from 'os';
import path from 'path';
import { bold, cyan } from 'picocolors';
import { copy } from '../helpers/copy';
import { install } from '../helpers/install';

import { GetTemplateFileArgs, InstallTemplateArgs, TemplateTypeEnum } from './types';
/**
 * Get the file path for a given file in a template, e.g. "next.config.js".
 */
export const getTemplateFile = ({ template, mode, file }: GetTemplateFileArgs): string => {
  return path.join(__dirname, template, mode, file);
};

export const SRC_DIR_NAMES = ['app', 'pages', 'styles'];

/**
 * Install a Next.js internal template to a given `root` directory.
 */
export const installTemplate = async ({
  appName,
  root,
  packageManager,
  isOnline,
  template,
  mode,
  eslint,
  srcDir,
  importAlias,
  secretKey,
  applicationId,
  userId,
}: InstallTemplateArgs) => {
  console.log(bold(`Using ${packageManager}.`));

  /**
   * Copy the template files to the target directory.
   */
  console.log('\nInitializing project with template:', template, '\n');
  const templatePath = path.join(__dirname, template, mode);
  const copySource = ['**'];
  if (!eslint) copySource.push('!eslintrc.json');
  if (!template.includes('react')) {
    copySource.push(mode === 'ts' ? 'tailwind.config.ts' : '!tailwind.config.js', '!postcss.config.cjs');
  }

  await copy(copySource, root, {
    parents: true,
    cwd: templatePath,
    rename(name) {
      switch (name) {
        case 'gitignore':
        case 'eslintrc.json': {
          return `.${name}`;
        }
        /*
         * README.md is ignored by webpack-asset-relocator-loader used by ncc:
         * https://github.com/vercel/webpack-asset-relocator-loader/blob/e9308683d47ff507253e37c9bcbb99474603192b/src/asset-relocator.js#L227
         */
        case 'README-template.md': {
          return 'README.md';
        }
        default: {
          return name;
        }
      }
    },
  });

  const tsconfigFile = path.join(root, 'tsconfig.json');
  await fs.writeFile(
    tsconfigFile,
    (await fs.readFile(tsconfigFile, 'utf8'))
      .replace(`"@/*": ["./*"]`, srcDir ? `"@/*": ["./src/*"]` : `"@/*": ["./*"]`)
      .replace(`"@/*":`, `"${importAlias}":`)
  );

  // update import alias in any files if not using the default
  if (importAlias !== '@/*') {
    const files = await glob('**/*', {
      cwd: root,
      dot: true,
      stats: false,
      /*
       * We don't want to modify compiler options in [ts/js]config.json
       * and none of the files in the .git folder
       */
      ignore: ['tsconfig.json', 'jsconfig.json', '.git/**/*'],
    });
    const writeSema = new Sema(8, { capacity: files.length });
    await Promise.all(
      files.map(async (file) => {
        await writeSema.acquire();
        const filePath = path.join(root, file);
        if ((await fs.stat(filePath)).isFile()) {
          await fs.writeFile(
            filePath,
            (await fs.readFile(filePath, 'utf8')).replace(`@/`, `${importAlias.replace(/\*/g, '')}`)
          );
        }
        writeSema.release();
      })
    );
  }

  if (srcDir) {
    await fs.mkdir(path.join(root, 'src'), { recursive: true });
    await Promise.all(
      SRC_DIR_NAMES.map(async (file) => {
        await fs.rename(path.join(root, file), path.join(root, 'src', file)).catch((err) => {
          if (err.code !== 'ENOENT') {
            throw err;
          }
        });
      })
    );

    const isAppTemplate = template.startsWith('app');

    // Change the `Get started by editing pages/index` / `app/page` to include `src`
    const indexPageFile = path.join(
      'src',
      isAppTemplate ? 'app' : 'pages',
      `${isAppTemplate ? 'page' : 'index'}.${mode === 'ts' ? 'tsx' : 'js'}`
    );

    await fs.writeFile(
      indexPageFile,
      (await fs.readFile(indexPageFile, 'utf8')).replace(
        isAppTemplate ? 'app/page' : 'pages/index',
        isAppTemplate ? 'src/app/page' : 'src/pages/index'
      )
    );

    if (template === TemplateTypeEnum.APP_REACT_EMAIL) {
      const tailwindConfigFile = path.join(root, mode === 'ts' ? 'tailwind.config.ts' : 'tailwind.config.js');
      await fs.writeFile(
        tailwindConfigFile,
        (await fs.readFile(tailwindConfigFile, 'utf8')).replace(
          /\.\/(\w+)\/\*\*\/\*\.\{js,ts,jsx,tsx,mdx\}/g,
          './src/$1/**/*.{js,ts,jsx,tsx,mdx}'
        )
      );
    }
  }

  /* write .env file */
  const val = Object.entries({
    NOVU_SECRET_KEY: secretKey,
    NEXT_PUBLIC_NOVU_APPLICATION_IDENTIFIER: applicationId,
    NEXT_PUBLIC_NOVU_SUBSCRIBER_ID: userId,
  }).reduce((acc, [key, value]) => {
    return `${acc}${key}=${value}${os.EOL}`;
  }, '');

  await fs.writeFile(path.join(root, '.env.local'), val);

  /* write github action */
  await copy(copySource, `${root}/.github`, {
    parents: true,
    cwd: path.join(__dirname, `./github`),
  });

  /** Copy the version from package.json or override for tests. */
  const version = '14.2.3';

  /** Create a package.json for the new project and write it to disk. */
  const packageJson: any = {
    name: appName,
    version: '0.1.0',
    private: true,
    scripts: {
      dev: `next dev --port=4000`,
      build: 'next build',
      start: 'next start',
      lint: 'next lint',
    },
    /**
     * Default dependencies.
     */
    dependencies: {
      react: '^18',
      'react-dom': '^18',
      next: version,
      '@novu/framework': 'latest',
      '@novu/nextjs': '^2.5.0',
    },
    devDependencies: {},
  };

  /**
   * TypeScript projects will have type definitions and other devDependencies.
   */
  if (mode === 'ts') {
    packageJson.devDependencies = {
      ...packageJson.devDependencies,
      typescript: '^5',
      '@types/node': '^20',
      '@types/react': '^18',
      '@types/react-dom': '^18',
    };
  }

  /* Add Tailwind CSS dependencies. */
  if (template === TemplateTypeEnum.APP_REACT_EMAIL) {
    packageJson.devDependencies = {
      ...packageJson.devDependencies,
      postcss: '^8',
      tailwindcss: '^3.4.1',
    };

    packageJson.dependencies = {
      ...packageJson.dependencies,
      '@react-email/components': '0.0.18',
      '@react-email/tailwind': '0.0.18',
    };

    /* Zod dependencies used in react email example */
    packageJson.dependencies = {
      ...packageJson.dependencies,
      zod: '^3.23.8',
      'zod-to-json-schema': '^3.23.1',
    };
  }

  /* Default ESLint dependencies. */
  if (eslint) {
    packageJson.devDependencies = {
      ...packageJson.devDependencies,
      eslint: '^8',
      'eslint-config-next': version,
    };
  }

  const devDeps = Object.keys(packageJson.devDependencies).length;
  if (!devDeps) delete packageJson.devDependencies;

  await fs.writeFile(path.join(root, 'package.json'), JSON.stringify(packageJson, null, 2) + os.EOL);

  console.log('\nInstalling dependencies:');
  for (const dependency in packageJson.dependencies) console.log(`- ${cyan(dependency)}`);

  if (devDeps) {
    console.log('\nInstalling devDependencies:');
    for (const dependency in packageJson.devDependencies) console.log(`- ${cyan(dependency)}`);
  }

  console.log();

  await install(packageManager, isOnline);
};

export * from './types';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - getTemplateFile({ template, mode, file }: GetTemplateFileArgs): string)
 - installTemplate(async ({
  appName,
  root,
  packageManager,
  isOnline,
  template,
  mode,
  eslint,
  srcDir,
  ...)
 - writeSema(new Sema(8, { capacity: files.length });
    await Promise.all(
      files.map(async (file))
 - filePath(path.join(root, file);
        if ((await fs.stat(filePath)).isFile()) {
          await fs.writeFil...)
 - val(Object.entries({
    NOVU_SECRET_KEY: secretKey,
    NEXT_PUBLIC_NOVU_APPLICATION_IDENTIFIER: applic...)
Declaraciones 'export' encontradas:
- export  const
- export  const
- export  const
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/types.ts
Tamaño: 721 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { PackageManager } from '../helpers/get-pkg-manager';

export enum TemplateTypeEnum {
  DEFAULT = 'default',
  APP = 'app',
  DEFAULT_REACT_EMAIL = 'default-react-email',
  APP_REACT_EMAIL = 'app-react-email',
}

export type TemplateType = `${TemplateTypeEnum}`;
export type TemplateMode = 'js' | 'ts';

export interface GetTemplateFileArgs {
  template: TemplateType;
  mode: TemplateMode;
  file: string;
}

export interface InstallTemplateArgs {
  appName: string;
  root: string;
  packageManager: PackageManager;
  isOnline: boolean;
  template: TemplateType;
  mode: TemplateMode;
  eslint: boolean;
  srcDir: boolean;
  importAlias: string;
  secretKey: string;
  applicationId: string;
  userId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  enum
- export  type
- export  type
- export  interface
- export  interface

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/README-template.md
Tamaño: 891 bytes
Lenguaje detectado: Markdown

### CONTENIDO ORIGINAL ###

# Novu Bridge App

This is a [Novu](https://novu.co/) bridge application bootstrapped with [`npx novu init`](https://www.npmjs.com/package/novu)

## Getting Started

To run the development server, run:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

By default, the [Next.js](https://nextjs.org/) server will start and your state can be synchronized with Novu Cloud via the Bridge Endpoint (default is `/api/novu`). Your server will by default run on [http://localhost:4000](http://localhost:4000).

## Your first workflow

Your first email workflow can be edited in `./app/novu/workflows.ts`. You can adjust your workflow to your liking.

## Learn More

To learn more about Novu, take a look at the following resources:

- [Novu](https://novu.co/)

You can check out [Novu GitHub repository](https://github.com/novuhq/novu) - your feedback and contributions are welcome!


### ANALISIS AUTOMATICO (ESPAÑOL) ###

# Novu Bridge App
This is a [Novu](https://novu.co/) bridge application bootstrapped with [`npx novu init`](https://www.npmjs.com/package/novu)
## Getting Started
# or
# or
# or
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/eslintrc.json
Tamaño: 40 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "extends": "next/core-web-vitals"
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"extends": "next/core-web-vitals"
}
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/gitignore
Tamaño: 391 bytes
Lenguaje detectado: GITIGNORE

### CONTENIDO ORIGINAL ###

# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts


### ANALISIS AUTOMATICO (ESPAÑOL) ###

# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.
# dependencies
/node_modules
/.pnp
# testing
# next.js
# production
# misc
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/next-env.d.ts
Tamaño: 208 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

/// <reference types="next" />
/// <reference types="next/image-types/global" />

/*
 * NOTE: This file should not be edited
 * see https://nextjs.org/docs/basic-features/typescript for more information.
 */


### ANALISIS AUTOMATICO (ESPAÑOL) ###

No se detectaron funciones/exportaciones con heurística JS/TS.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/next.config.mjs
Tamaño: 92 bytes
Lenguaje detectado: MJS

### CONTENIDO ORIGINAL ###

/** @type {import('next').NextConfig} */
const nextConfig = {};

export default nextConfig;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

/** @type {import('next').NextConfig} */
const nextConfig = {};
export default nextConfig;
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/postcss.config.cjs
Tamaño: 61 bytes
Lenguaje detectado: CJS

### CONTENIDO ORIGINAL ###

module.exports = {
  plugins: {
    tailwindcss: {},
  },
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

module.exports = {
plugins: {
tailwindcss: {},
},
};
Contiene 'require' o 'module.exports' (posible Node.js).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/tailwind.config.ts
Tamaño: 488 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { Config } from 'tailwindcss';

const config: Config = {
  content: [
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      backgroundImage: {
        'gradient-radial': 'radial-gradient(var(--tw-gradient-stops))',
        'gradient-conic': 'conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))',
      },
    },
  },
  plugins: [],
};
export default config;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export default  config

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/tsconfig.json
Tamaño: 574 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"compilerOptions": {
"lib": ["dom", "dom.iterable", "esnext"],
"allowJs": true,
"skipLibCheck": true,
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/app/favicon.ico
Tamaño: 25931 bytes
Tipo: BINARIO o no legible como texto. Archivo no incluido.

################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/app/globals.css
Tamaño: 608 bytes
Lenguaje detectado: CSS

### CONTENIDO ORIGINAL ###

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

html,
body {
  max-width: 100vw;
  overflow-x: hidden;
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: Arial, Helvetica, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

a {
  color: inherit;
  text-decoration: none;
}

@media (prefers-color-scheme: dark) {
  html {
    color-scheme: dark;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

:root {
--background: #ffffff;
--foreground: #171717;
}
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/app/layout.tsx
Tamaño: 699 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import type { Metadata } from 'next';
import localFont from 'next/font/local';
import './globals.css';

const geistSans = localFont({
  src: './fonts/GeistVF.woff',
  variable: '--font-geist-sans',
  weight: '100 900',
});
const geistMono = localFont({
  src: './fonts/GeistMonoVF.woff',
  variable: '--font-geist-mono',
  weight: '100 900',
});

export const metadata: Metadata = {
  title: 'Create Next App',
  description: 'Generated by create next app',
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={`${geistSans.variable} ${geistMono.variable}`}>{children}</body>
    </html>
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import type { Metadata } from 'next';
import localFont from 'next/font/local';
import './globals.css';
const geistSans = localFont({
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/app/page.module.css
Tamaño: 6972 bytes
Lenguaje detectado: CSS

### CONTENIDO ORIGINAL ###

.container {
  min-height: 100vh;
  background: #f8fafc;
  display: flex;
  flex-direction: column;
}

.main {
  flex: 1;
  padding: 3rem 2rem;
  display: flex;
  justify-content: center;
  align-items: center;
}

.card {
  width: 100%;
  max-width: 64rem;
  background: #ffffff;
  border: 1px solid #e2e8f0;
  border-radius: 1rem;
  padding: 2rem;
  box-shadow:
    0 4px 6px -1px rgba(0, 0, 0, 0.1),
    0 2px 4px -1px rgba(0, 0, 0, 0.06);
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 2rem;
}

.header h1 {
  font-size: 1.875rem;
  font-weight: 700;
  color: #1e293b;
  letter-spacing: -0.025em;
}

.header p {
  color: #64748b;
  margin-top: 0.5rem;
  font-size: 1.1rem;
}

.content {
  display: flex;
  gap: 2rem;
}

.infoSection {
  flex: 1;
  max-width: 32rem;
}

.accordion {
  border: 1px solid #e2e8f0;
  border-radius: 8px;
  margin-bottom: 1rem;
  background: #ffffff;
  overflow: hidden;
}

.accordion:last-child {
  margin-bottom: 0;
}

.accordionHeader {
  padding: 1rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: space-between;
  font-weight: 800;
  background: #ffffff;
  border: none;
  width: 100%;
  text-align: left;
  color: #334155;
}

.accordionHeader:hover {
  background: #f8fafc;
}

.accordionContent {
  padding: 0 1rem 1rem 1rem;
  color: #64748b;
}

.stepList {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  margin-top: 1rem;
}

.step {
  display: flex;
  gap: 1rem;
  align-items: flex-start;
}

.stepNumber {
  width: 28px;
  height: 28px;
  border-radius: 50%;
  background: #f1f5f9;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  font-weight: 500;
  font-size: 0.875rem;
}

.stepContent {
  flex: 1;
  color: #334155;
}

.stepTitle {
  font-weight: 400;
  margin-bottom: 0.25rem;
  color: #1e293b;
}

.stepDescription {
  color: #64748b;
  font-size: 0.875rem;
  line-height: 1.5;
}

.codeBlock {
  background: var(--muted-background);
  padding: 1rem;
  border-radius: 6px;
  margin: 1rem 0;
  font-family: monospace;
  font-size: 0.875rem;
}

.bulletList {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  margin-top: 0.5rem;
}

.bulletItem {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.875rem;
  color: #64748b;
  margin-bottom: 0.2rem;
}

.bullet {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: var(--primary);
  flex-shrink: 0;
}

.link {
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  color: #0081f1;
  font-size: 0.875rem;
  text-decoration: none;
  margin-top: 1rem;
}

.link:hover {
  opacity: 0.8;
}

.description {
  color: var(--muted-foreground);
  font-size: 0.875rem;
  line-height: 1.5;
  margin-bottom: 1rem;
}

.description a {
  color: #0081f1;
}

.divider {
  width: 1px;
  background: #e2e8f0;
}

.buttonSection {
  display: flex;
  flex-direction: column;
  margin-top: 1rem;
  gap: 1rem;
  align-items: flex-start;
  padding: 1rem;
  position: relative;
  width: 400px;
  height: 100%;
}

.footer {
  border-top: 1px solid #e2e8f0;
  background: #eef2f5;
  padding: 4rem 2rem 2rem;
  margin-top: auto;
}

.footerContent {
  max-width: 72rem;
  margin: 0 auto;
  display: grid;
  grid-template-columns: 2fr 1fr 1fr 1fr;
  gap: 4rem;
}

.footerLogo {
  display: flex;
  flex-direction: column;
}

.footerLogo p {
  color: #64748b;
  font-size: 0.95rem;
  line-height: 1.7;
  max-width: 24rem;
}

.socialLinks {
  display: flex;
  gap: 1rem;
  margin-top: 0.5rem;
}

.socialLinks a {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 2.5rem;
  height: 2.5rem;
  border-radius: 0.5rem;
  background: #ffffff;
  border: 1px solid #e2e8f0;
  color: #64748b;
  transition: all 0.2s ease;
}

.socialLinks a:hover {
  background: #f8fafc;
  color: #334155;
  transform: translateY(-2px);
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
}

.footerSection h3 {
  font-weight: 600;
  margin-bottom: 1.5rem;
  color: #1e293b;
  font-size: 1.1rem;
  letter-spacing: -0.01em;
}

.footerSection ul {
  list-style: none;
  padding: 0;
  display: flex;
  flex-direction: column;
  gap: 0.875rem;
}

.footerSection li {
  margin: 0;
}

.footerSection a {
  color: #64748b;
  font-size: 0.95rem;
  text-decoration: none;
  transition: all 0.2s ease;
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
}

.footerSection a:hover {
  color: #334155;
}

.footerBottom {
  margin-top: 4rem;
  padding-top: 2rem;
  border-top: 1px solid #e2e8f0;
  display: flex;
  justify-content: space-between;
  align-items: center;
  color: #64748b;
  font-size: 0.875rem;
}

.footerBottom a {
  color: #64748b;
  text-decoration: none;
  transition: color 0.2s ease;
}

.footerBottom a:hover {
  color: #334155;
}

@media (max-width: 1024px) {
  .footerContent {
    grid-template-columns: 1.5fr 1fr 1fr;
    gap: 3rem;
  }
}

@media (max-width: 768px) {
  .footerContent {
    grid-template-columns: 1fr 1fr;
    gap: 2.5rem;
  }

  .footerLogo {
    grid-column: 1 / -1;
  }

  .footerBottom {
    flex-direction: column;
    gap: 1rem;
    text-align: center;
  }
}

@media (max-width: 640px) {
  .footerContent {
    grid-template-columns: 1fr;
    gap: 2rem;
  }

  .footer {
    padding: 3rem 1.5rem 1.5rem;
  }
}

.button {
  display: inline-flex;
  gap: 0.5rem;
  padding: 0.75rem 1.5rem;
  margin-top: 5rem;
  font-size: 0.95rem;
  font-weight: 500;
  color: #ffffff;
  background: #0081f1;
  border: none;
  border-radius: 0.5rem;
  cursor: pointer;
  transition: all 0.2s ease;
  margin-left: 5rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.button:hover {
  background: #0081f1;
  transform: translateY(-1px);
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
}

.button:active {
  transform: translateY(0);
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}

.button:disabled {
  background: #94a3b8;
  cursor: not-allowed;
  transform: none;
  box-shadow: none;
}

.connectionMessage {
  background: linear-gradient(135deg, #f8f9ff 0%, #f0f4ff 100%);
  border: 1px solid #e0e7ff;
  border-radius: 0.75rem;
  margin-top: 1rem;
  padding: 1rem 1.4rem;
  display: flex;
  align-items: center;
  gap: 0.75rem;
  box-shadow: 0 2px 8px rgba(79, 70, 229, 0.08);
  width: 100%;
  box-sizing: border-box;
}

.connectionText {
  color: #4b5563;
  font-size: 0.95rem;
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 0.5rem;
  width: 100%;
}

.connectionText code {
  background-color: rgba(255, 255, 255, 0.8);
  padding: 0.375rem 0.75rem;
  border-radius: 0.375rem;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  font-size: 0.9rem;
  color: #4f46e5;
  border: 1px solid rgba(224, 231, 255, 0.6);
  font-weight: 500;
}

.successMessage {
  color: #16a34a;
  margin-top: 8px;
  margin-left: 5rem;
  text-align: center;
  font-size: 0.9rem;
}

.complianceBadges {
  display: flex;
  gap: 1rem;
  align-items: center;
  margin-top: 0.5rem;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

.container {
min-height: 100vh;
background: #f8fafc;
display: flex;
flex-direction: column;
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/app/page.tsx
Tamaño: 17085 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

'use client';

import Image from 'next/image';
import { useEffect, useState } from 'react';
import NotificationToast, { NovuInbox } from './components/NotificationToast/Notifications';
import styles from './page.module.css';

export default function Home() {
  const [isNovuConnected, setIsNovuConnected] = useState(false);
  const [showSuccess, setShowSuccess] = useState(false);

  useEffect(() => {
    (async () => {
      await fetch('/api/events', {
        method: 'POST',
        body: JSON.stringify({
          event: 'Starter Page Visit - [Next.js Starter]',
          data: {},
        }),
      });
    })();
  }, []);

  useEffect(() => {
    const checkNovuConnection = async () => {
      try {
        const response = await fetch('/api/dev-studio-status');
        const data = await response.json();
        setIsNovuConnected(data.connected);

        if (!data.connected) {
          console.log('Novu connection failed:', data.error);
        }
      } catch (error) {
        console.error('Novu connection error:', error);
        setIsNovuConnected(false);
      }
    };

    checkNovuConnection();
    const interval = setInterval(checkNovuConnection, 3000);

    return () => clearInterval(interval);
  }, []);

  const triggerNotification = async () => {
    try {
      const response = await fetch('/api/trigger', {
        method: 'POST',
      });

      if (!response.ok) {
        throw new Error('Failed to trigger notification');
      }

      const data = await response.json();
      console.log('Notification triggered:', data);
      setShowSuccess(true);
      setTimeout(() => setShowSuccess(false), 3000); // Hide after 3 seconds

      await fetch('/api/events', {
        method: 'POST',
        body: JSON.stringify({
          event: 'Notification Triggered - [Next.js Starter]',
          data: {},
        }),
      });
    } catch (error) {
      console.error('Error triggering notification:', error);
    }
  };

  return (
    <div className={styles.container}>
      <NotificationToast />
      <main className={styles.main}>
        <div className={styles.card}>
          {/* Header */}
          <div className={styles.header}>
            <div>
              <h1>Novu + Next.js Starter</h1>
              <p>Trigger notifications with a single button</p>
            </div>
            <NovuInbox />
          </div>
          {/* Content */}
          <div className={styles.content}>
            {/* Info Section */}
            <div className={styles.infoSection}>
              {/* Create a workflow */}
              <details className={styles.accordion}>
                <summary className={styles.accordionHeader}>Create a workflow</summary>
                <div className={styles.accordionContent}>
                  <p className={styles.description}>
                    In Novu, all notifications are sent via a workflow. Each workflow acts as a container for the logic
                    and templates that are associated with a kind of notification in your system.
                  </p>
                  <div className={styles.stepList}>
                    <div className={styles.step}>
                      <div className={styles.stepNumber}>1</div>
                      <div className={styles.stepContent}>
                        <h5 className={styles.stepTitle}>Name and Identifier</h5>
                        <p className={styles.stepDescription}>
                          Every workflow will have a name and trigger identifier. The workflow trigger identifier is
                          used to uniquely identify each workflow.
                        </p>
                      </div>
                    </div>

                    <div className={styles.step}>
                      <div className={styles.stepNumber}>2</div>
                      <div className={styles.stepContent}>
                        <h5 className={styles.stepTitle}>Trigger</h5>
                        <p className={styles.stepDescription}>
                          The Trigger refers to an event or action that initiates the workflow. It signifies a call to
                          the Novu API with a specified workflow trigger identifier.
                        </p>
                      </div>
                    </div>

                    <div className={styles.step}>
                      <div className={styles.stepNumber}>3</div>
                      <div className={styles.stepContent}>
                        <h5 className={styles.stepTitle}>Steps</h5>
                        <p className={styles.stepDescription}>
                          Within the Novu framework, steps are categorized into various types, each of which is linked
                          with at least one corresponding action.
                        </p>
                      </div>
                    </div>
                  </div>

                  <a
                    href="https://docs.novu.co/workflows/introduction/?utm_campaign=nextjs-starter&utm_source=nextjs-starter&utm_medium=nextjs"
                    target="_blank"
                    className={styles.link}
                    rel="noopener"
                  >
                    Learn more about workflows
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                      <path d="M7 7h10v10M7 17L17 7" />
                    </svg>
                  </a>
                </div>
              </details>
              {/* Add Inbox to your app */}
              <details className={styles.accordion}>
                <summary className={styles.accordionHeader}>Add In-App notifications</summary>
                <div className={styles.accordionContent}>
                  <p className={styles.description}>
                    The Inbox component enables a rich context-aware in-app notifications center directly in your
                    application, and with minimal effort.
                  </p>
                  <pre className={styles.codeBlock}>
                    <code>{`<Inbox />`}</code>
                  </pre>
                  <div className={styles.description}>
                    <p>
                      Check out the{' '}
                      <a
                        href="https://docs.novu.co/notification-center/client/react/inbox-playground/?utm_campaign=nextjs-starter&utm_source=nextjs-starter&utm_medium=nextjs"
                        target="_blank"
                        className="text-blue-500 hover:text-blue-600"
                        rel="noopener"
                      >
                        Inbox Playground
                      </a>
                      . You can customize the Inbox component to match your application&apos;s design.
                    </p>
                  </div>
                  <a
                    href="https://docs.novu.co/inbox/introduction/?utm_campaign=nextjs-starter&utm_source=nextjs-starter&utm_medium=nextjs"
                    target="_blank"
                    className={styles.link}
                    rel="noopener"
                  >
                    Learn more about Inbox
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                      <path d="M7 7h10v10M7 17L17 7" />
                    </svg>
                  </a>
                </div>
              </details>
              {/* Digest multiple notifications */}
              <details className={styles.accordion}>
                <summary className={styles.accordionHeader}>Digest multiple notifications</summary>
                <div className={styles.accordionContent}>
                  <p className={styles.description}>
                    The digest engine collects multiple trigger events, aggregates them into a single message and
                    delivers it to the subscriber.
                  </p>
                  <div className={styles.codeBlock}>
                    <strong>Example:</strong>
                    <p>
                      A user receives 100 notifications in a short amount of time, but you only want to notify them once
                      per hour.
                    </p>
                  </div>
                  <a
                    href="https://docs.novu.co/workflows/digest/?utm_campaign=nextjs-starter&utm_source=nextjs-starter&utm_medium=nextjs"
                    target="_blank"
                    className={styles.link}
                    rel="noopener"
                  >
                    Learn more about Digest
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                      <path d="M7 7h10v10M7 17L17 7" />
                    </svg>
                  </a>
                </div>
              </details>
              {/* Schedule / Delay notifications */}
              <details className={styles.accordion}>
                <summary className={styles.accordionHeader}>Schedule / Delay notifications</summary>
                <div className={styles.accordionContent}>
                  <p className={styles.description}>
                    The <strong>schedule</strong> or <strong>delay</strong> action awaits a specified amount of time
                    before moving on to trigger the following steps of the workflow.
                  </p>

                  <h4 className={styles.stepTitle}>Common Use Cases:</h4>
                  <ul className={styles.bulletList}>
                    <li className={styles.bulletItem}>
                      <div className={styles.bullet}></div>- Send a follow-up email 24 hours after user registration
                    </li>
                    <li className={styles.bulletItem}>
                      <div className={styles.bullet}></div>- Trigger a reminder notification if user has not completed
                      an action
                    </li>
                    <li className={styles.bulletItem}>
                      <div className={styles.bullet}></div>- Schedule notifications for specific dates
                    </li>
                    <li className={styles.bulletItem}>
                      <div className={styles.bullet}></div>- Allow the user some time to cancel an action
                    </li>
                  </ul>

                  <a
                    href="https://docs.novu.co/workflow/delay/?utm_campaign=nextjs-starter&utm_source=nextjs-starter&utm_medium=nextjs"
                    target="_blank"
                    className={styles.link}
                    rel="noopener"
                  >
                    Learn more about Delay
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                      <path d="M7 7h10v10M7 17L17 7" />
                    </svg>
                  </a>
                </div>
              </details>
              {/* Preferences */}
              <details className={styles.accordion}>
                <summary className={styles.accordionHeader}>Preferences</summary>
                <div className={styles.accordionContent}>
                  <p className={styles.description}>
                    Novu provides a way to store subscriber preferences. This allows subscribers, your users, to specify
                    and manage their preferences and customize their notifications experience.
                  </p>

                  <h4 className={styles.stepTitle}>Levels of preferences:</h4>
                  <ul className={styles.bulletList}>
                    <li className={styles.bulletItem}>
                      <div className={styles.bullet}></div>- Workflow channel preferences
                    </li>
                    <li className={styles.bulletItem}>
                      <div className={styles.bullet}></div>- Subscriber channel preferences per workflow
                    </li>
                    <li className={styles.bulletItem}>
                      <div className={styles.bullet}></div>- Subscriber global preferences
                    </li>
                  </ul>

                  <a
                    href="https://docs.novu.co/concepts/preferences/?utm_campaign=nextjs-starter&utm_source=nextjs-starter&utm_medium=nextjs"
                    target="_blank"
                    className={styles.link}
                    rel="noopener"
                  >
                    Learn more about Preferences
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                      <path d="M7 7h10v10M7 17L17 7" />
                    </svg>
                  </a>
                </div>
              </details>
            </div>

            <div className={styles.divider} />

            <div className={styles.buttonSection}>
              {isNovuConnected ? (
                <>
                  <button className={styles.button} onClick={triggerNotification}>
                    Trigger a notification
                  </button>
                  {showSuccess && <p className={styles.successMessage}>✓ Notification triggered successfully!</p>}
                </>
              ) : (
                <div className={styles.connectionMessage}>
                  <div className={styles.connectionContent}></div>
                  <div className={styles.connectionText}>
                    <h4>Connection Required</h4>
                    <br />
                    <p>Run the following command to start:</p>
                    <code className={styles.commandCode}>npx novu@latest dev --port 4000</code>
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>
      </main>

      <footer className={styles.footer}>
        <div className={styles.footerContent}>
          <div className={styles.footerLogo}>
            <Image src="./novu.svg" alt="Novu Logo" width={120} height={60} />
            <p>The open-source notification infrastructure for developers.</p>
          </div>

          <div className={styles.footerSection}>
            <h3>Resources</h3>
            <ul>
              <li>
                <a
                  href="https://docs.novu.co/getting-started/introduction/?utm_campaign=nextjs-starter&utm_source=nextjs-starter&utm_medium=nextjs"
                  target="_blank"
                  rel="noopener"
                >
                  Documentation
                </a>
              </li>
              <li>
                <a
                  href="https://docs.novu.co/api-reference/overview/?utm_campaign=nextjs-starter&utm_source=nextjs-starter&utm_medium=nextjs"
                  target="_blank"
                  rel="noopener"
                >
                  API Reference
                </a>
              </li>
              <li>
                <a
                  href="https://novu.co/blog/?utm_campaign=nextjs-starter&utm_source=nextjs-starter&utm_medium=nextjs"
                  target="_blank"
                  rel="noopener"
                >
                  Blog
                </a>
              </li>
            </ul>
          </div>

          <div className={styles.footerSection}>
            <h3>Community</h3>
            <ul>
              <li>
                <a href="https://github.com/novuhq/novu" target="_blank" rel="noopener">
                  GitHub
                </a>
              </li>
              <li>
                <a href="https://discord.novu.co" target="_blank" rel="noopener">
                  Discord
                </a>
              </li>
              <li>
                <a href="https://twitter.com/novuhq" target="_blank" rel="noopener">
                  Twitter
                </a>
              </li>
            </ul>
          </div>

          <div className={styles.footerSection}>
            <h3>Company</h3>
            <ul>
              <li>
                <a
                  href="https://novu.co/contact-us/?utm_campaign=nextjs-starter&utm_source=nextjs-starter&utm_medium=nextjs"
                  target="_blank"
                  rel="noopener"
                >
                  Contact
                </a>
              </li>
              <li>
                <a
                  href="https://roadmap.novu.co/roadmap/?utm_campaign=nextjs-starter&utm_source=nextjs-starter&utm_medium=nextjs"
                  target="_blank"
                  rel="noopener"
                >
                  Roadmap
                </a>
              </li>
              <li>
                <a
                  href="https://go.novu.co/changelog/?utm_campaign=nextjs-starter&utm_source=nextjs-starter&utm_medium=nextjs"
                  target="_blank"
                  rel="noopener"
                >
                  Changelog
                </a>
              </li>
            </ul>
          </div>
        </div>
      </footer>
    </div>
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

'use client';
import Image from 'next/image';
import { useEffect, useState } from 'react';
import NotificationToast, { NovuInbox } from './components/NotificationToast/Notifications';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/app/api/dev-studio-status/route.ts
Tamaño: 787 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export async function GET() {
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 3000);

    const response = await fetch('http://localhost:2022/.well-known/novu', {
      signal: controller.signal,
      headers: {
        Accept: 'application/json',
      },
    });

    clearTimeout(timeoutId);

    if (response.ok) {
      const data = await response.json();
      if (data.port && data.route) {
        return Response.json({ connected: true, data });
      }
    }

    return Response.json({
      connected: false,
      error: await response.text(),
    });
  } catch (error) {
    return Response.json({
      connected: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - GET()
Asignaciones con arrow functions encontradas (posibles funciones):
 - timeoutId(setTimeout(())
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/app/api/events/route.ts
Tamaño: 794 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export async function POST(request: Request) {
  try {
    const body = await request.json();

    const response = await fetch('https://api.novu.co/v1/telemetry/measure', {
      headers: {
        Accept: 'application/json',
        'Content-Type': 'application/json',
        Authorization: `ApiKey ${process.env.NOVU_SECRET_KEY}`,
      },
      method: 'POST',
      body: JSON.stringify({
        event: body.event,
        data: body.data,
      }),
    });

    if (response.ok) {
      return Response.json({ success: true });
    }

    return Response.json({
      connected: false,
      error: await response.text(),
    });
  } catch (error) {
    return Response.json({
      connected: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - POST(request: Request)
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/app/api/novu/route.ts
Tamaño: 277 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { serve } from '@novu/framework/next';
import { welcomeOnboardingEmail } from '../../novu/workflows';

// the workflows collection can hold as many workflow definitions as you need
export const { GET, POST, OPTIONS } = serve({
  workflows: [welcomeOnboardingEmail],
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/app/api/trigger/route.ts
Tamaño: 680 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { NextResponse } from 'next/server';
import { welcomeOnboardingEmail } from '../../novu/workflows';

export async function POST() {
  try {
    await welcomeOnboardingEmail.trigger({
      to: process.env.NEXT_PUBLIC_NOVU_SUBSCRIBER_ID || '',
      payload: {},
    });

    return NextResponse.json({
      message: 'Notification triggered successfully',
    });
  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
    console.error('Error triggering notification:', errorMessage);

    return NextResponse.json({ message: 'Error triggering notification', error: errorMessage }, { status: 500 });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - POST()
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/app/components/NotificationToast/Notifications.module.css
Tamaño: 1563 bytes
Lenguaje detectado: CSS

### CONTENIDO ORIGINAL ###

.toast {
  position: fixed;
  background: linear-gradient(135deg, #ffffff 0%, #f8f9ff 100%);
  border-radius: 16px;
  padding: 18px 24px;
  box-shadow:
    0 10px 25px rgba(0, 0, 0, 0.1),
    0 6px 12px rgba(0, 0, 0, 0.08),
    0 0 0 1px rgba(255, 255, 255, 0.5) inset;
  z-index: 1000;
  width: 90%;
  max-width: 400px;
  right: 24px;
  top: 24px;
  border: 1px solid rgba(0, 0, 0, 0.06);
  animation: slideIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
  backdrop-filter: blur(10px);
  transform-origin: top right;
}

.toastContent {
  display: flex;
  flex-direction: column;
  gap: 10px;
  position: relative;
  overflow: hidden;
  font-weight: 600;
  background: linear-gradient(90deg, #1a1a1a 0%, #404040 100%);
  -webkit-background-clip: text;
  color: transparent;
  font-size: 1rem;
  letter-spacing: -0.02em;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
}

.toastContent::before {
  content: "";
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: linear-gradient(45deg, transparent 0%, rgba(255, 255, 255, 0.1) 50%, transparent 100%);
  animation: shimmer 2s infinite;
}

@keyframes slideIn {
  0% {
    transform: translateY(-120%) scale(0.9);
    opacity: 0;
  }

  100% {
    transform: translateY(0) scale(1);
    opacity: 1;
  }
}

@keyframes shimmer {
  0% {
    transform: translateX(-100%) rotate(45deg);
  }

  100% {
    transform: translateX(100%) rotate(45deg);
  }
}

@media (prefers-reduced-motion: reduce) {
  .toast {
    animation: none;
  }

  .toastContent::before {
    animation: none;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

.toast {
position: fixed;
background: linear-gradient(135deg, #ffffff 0%, #f8f9ff 100%);
border-radius: 16px;
padding: 18px 24px;
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/app/components/NotificationToast/Notifications.tsx
Tamaño: 1796 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

'use client';

import { Novu } from '@novu/js';
import { Inbox } from '@novu/nextjs';
import { useRouter } from 'next/navigation';
import { useEffect, useMemo, useState } from 'react';
import styles from './Notifications.module.css'; // You'll need to create this

const NotificationToast = () => {
  const novu = useMemo(
    () =>
      new Novu({
        subscriberId: process.env.NEXT_PUBLIC_NOVU_SUBSCRIBER_ID || '',
        applicationIdentifier: process.env.NEXT_PUBLIC_NOVU_APPLICATION_IDENTIFIER || '',
      }),
    []
  );

  const [showToast, setShowToast] = useState(false);

  useEffect(() => {
    const listener = ({ result: notification }: { result: any }) => {
      console.log('Received notification:', notification);
      setShowToast(true);

      setTimeout(() => {
        setShowToast(false);
      }, 2500);
    };

    console.log('Setting up Novu notification listener');
    novu.on('notifications.notification_received', listener);

    return () => {
      novu.off('notifications.notification_received', listener);
    };
  }, [novu]);

  if (!showToast) return null;

  return (
    <div className={styles.toast}>
      <div className={styles.toastContent}>New In-App Notification</div>
    </div>
  );
};

export default NotificationToast;

const novuConfig = {
  applicationIdentifier: process.env.NEXT_PUBLIC_NOVU_APPLICATION_IDENTIFIER || '',
  subscriberId: process.env.NEXT_PUBLIC_NOVU_SUBSCRIBER_ID || '',
  appearance: {
    elements: {
      bellContainer: {
        width: '30px',
        height: '30px',
      },
      bellIcon: {
        width: '30px',
        height: '30px',
      },
    },
  },
};

export function NovuInbox() {
  const router = useRouter();

  return <Inbox {...novuConfig} routerPush={(path: string) => router.push(path)} />;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

'use client';
import { Novu } from '@novu/js';
import { Inbox } from '@novu/nextjs';
import { useRouter } from 'next/navigation';
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/app/fonts/GeistMonoVF.woff
Tamaño: 67864 bytes
Tipo: BINARIO o no legible como texto. Archivo no incluido.

################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/app/fonts/GeistVF.woff
Tamaño: 66268 bytes
Tipo: BINARIO o no legible como texto. Archivo no incluido.

################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/app/novu/emails/novu-onboarding-email.tsx
Tamaño: 4345 bytes
Lenguaje detectado: TSX

### CONTENIDO ORIGINAL ###

import {
  Body,
  Button,
  CodeInline,
  Column,
  Container,
  Head,
  Heading,
  Html,
  Img,
  Preview,
  Row,
  render,
  Section,
  Tailwind,
  Text,
} from '@react-email/components';
import React from 'react';

import { ControlSchema, PayloadSchema } from '../workflows';

type NovuWelcomeEmailProps = ControlSchema & PayloadSchema;

export const NovuWelcomeEmail = ({
  components,
  userImage,
  teamImage,
  arrowImage,
  showHeader,
}: NovuWelcomeEmailProps) => {
  return (
    <Html>
      <Head />
      <Preview>Novu Welcome</Preview>
      <Tailwind
        config={{
          theme: {
            extend: {
              colors: {
                brand: '#2250f4',
                offwhite: '#fafbfb',
                blurwhite: '#f3f3f5',
              },
              spacing: {
                0: '0px',
                20: '20px',
                45: '45px',
              },
            },
          },
        }}
      >
        <Body className="bg-blurwhite text-base font-sans">
          {showHeader ? (
            <Img
              src={`https://images.spr.so/cdn-cgi/imagedelivery/j42No7y-dcokJuNgXeA0ig/dca73b36-cf39-4e28-9bc7-8a0d0cd8ac70/standalone-gradient2x_2/w=128,quality=90,fit=scale-down`}
              width="56"
              height="56"
              alt="Novu"
              className="mx-auto my-20"
            />
          ) : null}

          <Container className="bg-white p-45">
            {components?.map((component, componentIndex) => {
              return (
                <Section key={componentIndex}>
                  {component.type === 'heading' ? (
                    <Section>
                      <Heading as="h1" className={`text-${component.align}`}>
                        {component.text}
                      </Heading>
                    </Section>
                  ) : null}

                  {component.type === 'button' ? (
                    <Section className={`text-${component.align}`}>
                      <Button
                        href={'http://localhost:2022'}
                        className="bg-[#000000] rounded text-white text-[12px] font-semibold no-underline text-center px-5 py-3"
                      >
                        {component.text}
                      </Button>
                    </Section>
                  ) : null}

                  {component.type === 'text' ? (
                    <Section>
                      <Text className={`text-base text-${component.align}`}>{component.text}</Text>
                    </Section>
                  ) : null}

                  {component.type === 'users' ? (
                    <Section className={'mb-5'}>
                      <Row>
                        <Text className={`text-[#666666] text-[12px] leading-[24px] text-${component.align}`}>
                          {component.text}
                        </Text>
                      </Row>
                      <Row align={component.align}>
                        <Column align="right">
                          <Img className="rounded-full" src={userImage} width="64" height="64" />
                        </Column>
                        <Column align="center">
                          <Img src={arrowImage} width="12" height="9" alt="invited you to" />
                        </Column>
                        <Column align="left">
                          <Img className="rounded-full" src={teamImage} width="64" height="64" />
                        </Column>
                      </Row>
                    </Section>
                  ) : null}
                  {component.type === 'code' ? (
                    <Section>
                      <CodeInline>{component.text}</CodeInline>;
                    </Section>
                  ) : null}
                </Section>
              );
            })}
          </Container>

          <Container className="mt-20">
            <Text className="text-center text-gray-400 mb-45">
              Powered by Novu, the Code-First Notification Infrastructure
            </Text>
          </Container>
        </Body>
      </Tailwind>
    </Html>
  );
};

export default NovuWelcomeEmail;

export function renderEmail(controls: ControlSchema, payload: PayloadSchema) {
  return render(<NovuWelcomeEmail {...controls} {...payload} />);
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

import {
Body,
Button,
CodeInline,
Column,
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/app/novu/workflows/index.ts
Tamaño: 44 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './welcome-onboarding-email';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/app/novu/workflows/welcome-onboarding-email/index.ts
Tamaño: 80 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './schemas';
export * from './types';
export * from './workflow';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/app/novu/workflows/welcome-onboarding-email/schemas.ts
Tamaño: 2159 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { z } from 'zod';

// Learn more about zod at the official website: https://zod.dev/
export const payloadSchema = z.object({
  inAppSubject: z.string().describe('The subject of the notification').default('**Welcome to Novu!**'),
  inAppBody: z
    .string()
    .describe('The body of the notification')
    .default('This is an in-app notification powered by Novu.'),
  inAppAvatar: z
    .string()
    .describe('The avatar of the notification')
    .default('https://avatars.githubusercontent.com/u/77433905?s=200&v=4'),
  teamImage: z
    .string()
    .url()
    .default(
      'https://images.spr.so/cdn-cgi/imagedelivery/j42No7y-dcokJuNgXeA0ig/dca73b36-cf39-4e28-9bc7-8a0d0cd8ac70/standalone-gradient2x_2/w=128,quality=90,fit=scale-down'
    ),
  userImage: z.string().url().default('https://react-email-demo-48zvx380u-resend.vercel.app/static/vercel-user.png'),
  arrowImage: z.string().url().default('https://react-email-demo-bdj5iju9r-resend.vercel.app/static/vercel-arrow.png'),
});

export const emailControlSchema = z.object({
  subject: z.string().default('A Successful Test on Novu!'),
  showHeader: z.boolean().default(true),
  components: z
    .array(
      z.object({
        type: z.enum(['heading', 'text', 'button', 'code', 'users']),
        text: z.string().default(''),
        align: z.enum(['left', 'center', 'right']).default('left'),
      })
    )
    .default([
      {
        type: 'heading',
        text: 'Welcome to Novu',
        align: 'center',
      },
      {
        type: 'text',
        text: 'Congratulations on receiving your first notification email from Novu! Join the hundreds of thousands of developers worldwide who use Novu to build notification platforms for their products.',
        align: 'left',
      },
      {
        type: 'users',
        align: 'center',
        text: '',
      },
      {
        type: 'text',
        text: 'Ready to get started? Click on the button below, and you will see first-hand how easily you can edit this email content.',
        align: 'left',
      },
      {
        type: 'button',
        text: 'Edit Email',
        align: 'center',
      },
    ]),
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/app/novu/workflows/welcome-onboarding-email/types.ts
Tamaño: 212 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { z } from 'zod';
import { emailControlSchema, payloadSchema } from './schemas';

export type PayloadSchema = z.infer<typeof payloadSchema>;
export type ControlSchema = z.infer<typeof emailControlSchema>;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/app/novu/workflows/welcome-onboarding-email/workflow.ts
Tamaño: 770 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { workflow } from '@novu/framework';
import { renderEmail } from '../../emails/novu-onboarding-email';
import { emailControlSchema, payloadSchema } from './schemas';

export const welcomeOnboardingEmail = workflow(
  'welcome-onboarding-email',
  async ({ step, payload }) => {
    await step.email(
      'send-email',
      async (controls) => {
        return {
          subject: controls.subject,
          body: renderEmail(controls, payload),
        };
      },
      {
        controlSchema: emailControlSchema,
      }
    );

    await step.inApp('In-App Step', async () => {
      return {
        subject: payload.inAppSubject,
        body: payload.inAppBody,
        avatar: payload.inAppAvatar,
      };
    });
  },
  {
    payloadSchema,
  }
);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - welcomeOnboardingEmail(workflow(
  'welcome-onboarding-email',
  async ({ step, payload }))
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/public/file.svg
Tamaño: 391 bytes
Lenguaje detectado: SVG

### CONTENIDO ORIGINAL ###

<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>

### ANALISIS AUTOMATICO (ESPAÑOL) ###

<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/public/globe.svg
Tamaño: 1035 bytes
Lenguaje detectado: SVG

### CONTENIDO ORIGINAL ###

<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>

### ANALISIS AUTOMATICO (ESPAÑOL) ###

<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/public/next.svg
Tamaño: 1375 bytes
Lenguaje detectado: SVG

### CONTENIDO ORIGINAL ###

<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>

### ANALISIS AUTOMATICO (ESPAÑOL) ###

<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/public/novu.svg
Tamaño: 7622 bytes
Lenguaje detectado: SVG

### CONTENIDO ORIGINAL ###

<svg viewBox="0 0 861 270" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M435.574 190.523V128.143C435.574 117.377 432.993 109.192 427.83 103.588C422.668 97.9845 414.555 95.1826 403.493 95.1826C395.97 95.1826 389.996 95.9199 385.571 97.3947C381.146 98.7219 378.344 99.6805 377.164 100.27V190.523H354.375V85.6706C354.965 85.3757 356.588 84.7121 359.243 83.6798C361.898 82.6475 365.438 81.5414 369.863 80.3617C374.288 79.1819 379.45 78.1496 385.35 77.2647C391.25 76.3799 397.74 75.9375 404.82 75.9375C412.933 75.9375 420.308 77.0435 426.945 79.2556C433.583 81.3202 439.188 84.3434 443.76 88.3251C448.48 92.3069 452.094 97.0997 454.602 102.704C457.109 108.308 458.363 114.649 458.363 121.728V190.523H435.574Z" fill="black"/>
<path d="M606.56 135C606.56 143.406 605.085 151.222 602.135 158.448C599.332 165.674 595.35 171.942 590.187 177.251C585.025 182.412 578.83 186.541 571.602 189.638C564.374 192.588 556.409 194.063 547.707 194.063C539.004 194.063 530.966 192.588 523.591 189.638C516.363 186.541 510.168 182.412 505.005 177.251C499.843 171.942 495.787 165.674 492.837 158.448C490.034 151.222 488.633 143.406 488.633 135C488.633 126.594 490.034 118.778 492.837 111.552C495.787 104.326 499.843 98.132 505.005 92.9705C510.168 87.6615 516.363 83.5323 523.591 80.5829C530.966 77.486 539.004 75.9375 547.707 75.9375C556.409 75.9375 564.374 77.486 571.602 80.5829C578.83 83.5323 585.025 87.6615 590.187 92.9705C595.35 98.132 599.332 104.326 602.135 111.552C605.085 118.778 606.56 126.594 606.56 135ZM582.886 135C582.886 129.101 582.075 123.718 580.452 118.852C578.83 113.838 576.47 109.561 573.372 106.022C570.422 102.335 566.734 99.533 562.309 97.6159C558.032 95.5513 553.164 94.519 547.707 94.519C542.102 94.519 537.087 95.5513 532.662 97.6159C528.384 99.533 524.697 102.335 521.599 106.022C518.649 109.561 516.363 113.838 514.74 118.852C513.118 123.718 512.307 129.101 512.307 135C512.307 140.899 513.118 146.355 514.74 151.369C516.363 156.236 518.649 160.513 521.599 164.199C524.697 167.739 528.384 170.541 532.662 172.605C537.087 174.522 542.102 175.481 547.707 175.481C553.164 175.481 558.032 174.522 562.309 172.605C566.734 170.541 570.422 167.739 573.372 164.199C576.47 160.513 578.83 156.236 580.452 151.369C582.075 146.355 582.886 140.899 582.886 135Z" fill="black"/>
<path d="M738.985 84.3434C738.1 87.5878 736.552 91.9382 734.339 97.3947C732.274 102.704 729.84 108.676 727.038 115.313C724.235 121.949 721.138 128.954 717.745 136.327C714.5 143.553 711.181 150.632 707.789 157.563C704.544 164.347 701.373 170.762 698.275 176.808C695.325 182.707 692.744 187.647 690.531 191.629H666.857C664.202 186.91 661.4 181.749 658.45 176.145C655.647 170.393 652.771 164.642 649.821 158.89C647.019 152.992 644.29 147.166 641.635 141.415C638.98 135.664 636.472 130.355 634.112 125.488C631.9 120.474 629.909 116.05 628.139 112.216C626.516 108.381 625.262 105.432 624.377 103.367C623.492 101.303 622.607 99.0906 621.722 96.731C620.837 94.3715 620.395 92.1594 620.395 90.0948C620.395 87.4403 621.28 85.007 623.05 82.7949C624.82 80.5829 627.844 79.4768 632.121 79.4768C635.071 79.4768 637.357 79.7718 638.98 80.3617C640.602 80.9515 641.487 81.3202 641.635 81.4677C644.142 88.3989 647.019 95.9937 650.264 104.252C653.656 112.511 657.049 120.695 660.441 128.806C663.981 136.77 667.374 144.438 670.619 151.812C673.864 159.038 676.74 165.158 679.248 170.172C681.018 166.78 683.304 161.987 686.106 155.794C689.056 149.452 692.08 142.521 695.178 135C698.423 127.479 701.668 119.737 704.913 111.773C708.158 103.81 711.034 96.5098 713.541 89.8736C714.721 86.6292 716.196 84.1222 717.966 82.3525C719.736 80.4354 722.686 79.4768 726.816 79.4768C730.357 79.4768 733.159 80.1404 735.224 81.4677C737.437 82.7949 738.69 83.7535 738.985 84.3434Z" fill="black"/>
<path d="M837.836 89.8736C837.836 86.3343 838.869 83.7535 840.934 82.1313C842.999 80.3617 845.949 79.4768 849.784 79.4768C852.291 79.4768 854.504 79.7718 856.421 80.3617C858.486 80.9515 859.887 81.394 860.625 81.6889V190.523C859.592 190.818 857.749 191.113 855.094 191.408C852.586 191.703 849.489 191.998 845.801 192.293C842.114 192.735 838.057 193.03 833.632 193.178C829.207 193.473 824.709 193.62 820.136 193.62C806.713 193.62 795.798 191.998 787.391 188.754C779.131 185.509 772.567 180.79 767.7 174.596C761.652 166.78 758.628 156.383 758.628 143.406V89.8736C758.628 86.3343 759.661 83.7535 761.726 82.1313C763.791 80.3617 766.741 79.4768 770.576 79.4768C773.083 79.4768 775.296 79.7718 777.213 80.3617C779.278 80.9515 780.68 81.394 781.417 81.6889V140.973C781.417 152.18 784.22 160.586 789.825 166.19C795.577 171.794 805.238 174.596 818.809 174.596C823.971 174.596 828.101 174.449 831.199 174.154C834.444 173.711 836.656 173.343 837.836 173.048V89.8736Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M207.9 108.217C207.9 115.476 199.087 119.071 194.01 113.882L90.076 7.65494C104.13 2.69721 119.25 0 135 0C161.852 0 186.874 7.8399 207.9 21.3556V108.217ZM245.7 57.7105V108.217C245.7 149.352 195.759 169.719 166.992 140.317L55.2224 26.0826C21.738 50.6501 0 90.2865 0 135C0 163.747 8.98505 190.395 24.3 212.29V162.053C24.3 120.918 74.2409 100.551 103.008 129.953L214.624 244.03C248.195 219.471 270 179.782 270 135C270 106.253 261.015 79.605 245.7 57.7105ZM75.9897 156.388L179.728 262.414C165.73 267.328 150.677 270 135 270C108.148 270 83.1262 262.16 62.1 248.644V162.053C62.1 154.794 70.9131 151.199 75.9897 156.388Z" fill="url(#paint0_radial_1740_6029)"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M207.9 108.217C207.9 115.476 199.087 119.071 194.01 113.882L90.076 7.65494C104.13 2.69721 119.25 0 135 0C161.852 0 186.874 7.8399 207.9 21.3556V108.217ZM245.7 57.7105V108.217C245.7 149.352 195.759 169.719 166.992 140.317L55.2224 26.0826C21.738 50.6501 0 90.2865 0 135C0 163.747 8.98505 190.395 24.3 212.29V162.053C24.3 120.918 74.2409 100.551 103.008 129.953L214.624 244.03C248.195 219.471 270 179.782 270 135C270 106.253 261.015 79.605 245.7 57.7105ZM75.9897 156.388L179.728 262.414C165.73 267.328 150.677 270 135 270C108.148 270 83.1262 262.16 62.1 248.644V162.053C62.1 154.794 70.9131 151.199 75.9897 156.388Z" fill="url(#paint1_linear_1740_6029)"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M207.9 108.217C207.9 115.476 199.087 119.071 194.01 113.882L90.076 7.65494C104.13 2.69721 119.25 0 135 0C161.852 0 186.874 7.8399 207.9 21.3556V108.217ZM245.7 57.7105V108.217C245.7 149.352 195.759 169.719 166.992 140.317L55.2224 26.0826C21.738 50.6501 0 90.2865 0 135C0 163.747 8.98505 190.395 24.3 212.29V162.053C24.3 120.918 74.2409 100.551 103.008 129.953L214.624 244.03C248.195 219.471 270 179.782 270 135C270 106.253 261.015 79.605 245.7 57.7105ZM75.9897 156.388L179.728 262.414C165.73 267.328 150.677 270 135 270C108.148 270 83.1262 262.16 62.1 248.644V162.053C62.1 154.794 70.9131 151.199 75.9897 156.388Z" fill="url(#paint2_linear_1740_6029)"/>
<defs>
<radialGradient id="paint0_radial_1740_6029" cx="0" cy="0" r="1" gradientUnits="userSpaceOnUse" gradientTransform="translate(135 135) rotate(135) scale(190.919 190.919)">
<stop offset="0.34" stop-color="#FF006A"/>
<stop offset="0.613333" stop-color="#E300BD"/>
<stop offset="0.766667" stop-color="#FF4CE1"/>
</radialGradient>
<linearGradient id="paint1_linear_1740_6029" x1="166.5" y1="-9" x2="135" y2="270" gradientUnits="userSpaceOnUse">
<stop offset="0.0851785" stop-color="#FFBA33"/>
<stop offset="0.553333" stop-color="#FF006A" stop-opacity="0"/>
</linearGradient>
<linearGradient id="paint2_linear_1740_6029" x1="135" y1="0" x2="135" y2="270" gradientUnits="userSpaceOnUse">
<stop offset="0.546667" stop-opacity="0"/>
<stop offset="1" stop-opacity="0.6"/>
</linearGradient>
</defs>
</svg>


### ANALISIS AUTOMATICO (ESPAÑOL) ###

<svg viewBox="0 0 861 270" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M435.574 190.523V128.143C435.574 117.377 432.993 109.192 427.83 103.588C422.668 97.9845 414.555 95.1826 403.493 95.1826C395.97 95.1826 389.996 95.9199 385.571 97.3947C381.146 98.7219 378.344 99.6805 377.164 100.27V190.523H354.375V85.6706C354.965 85.3757 356.588 84.7121 359.243 83.6798C361.898 82.6475 365.438 81.5414 369.863 80.3617C374.288 79.1819 379.45 78.1496 385.35 77.2647C391.25 76.3799 397.74 75.9375 404.82 75.9375C412.933 75.9375 420.308 77.0435 426.945 79.2556C433.583 81.3202 439.188 84.3434 443.76 88.3251C448.48 92.3069 452.094 97.0997 454.602 102.704C457.109 108.308 458.363 114.649 458.363 121.728V190.523H435.574Z" fill="black"/>
<path d="M606.56 135C606.56 143.406 605.085 151.222 602.135 158.448C599.332 165.674 595.35 171.942 590.187 177.251C585.025 182.412 578.83 186.541 571.602 189.638C564.374 192.588 556.409 194.063 547.707 194.063C539.004 194.063 530.966 192.588 523.591 189.638C516.363 186.541 510.168 182.412 505.005 177.251C499.843 171.942 495.787 165.674 492.837 158.448C490.034 151.222 488.633 143.406 488.633 135C488.633 126.594 490.034 118.778 492.837 111.552C495.787 104.326 499.843 98.132 505.005 92.9705C510.168 87.6615 516.363 83.5323 523.591 80.5829C530.966 77.486 539.004 75.9375 547.707 75.9375C556.409 75.9375 564.374 77.486 571.602 80.5829C578.83 83.5323 585.025 87.6615 590.187 92.9705C595.35 98.132 599.332 104.326 602.135 111.552C605.085 118.778 606.56 126.594 606.56 135ZM582.886 135C582.886 129.101 582.075 123.718 580.452 118.852C578.83 113.838 576.47 109.561 573.372 106.022C570.422 102.335 566.734 99.533 562.309 97.6159C558.032 95.5513 553.164 94.519 547.707 94.519C542.102 94.519 537.087 95.5513 532.662 97.6159C528.384 99.533 524.697 102.335 521.599 106.022C518.649 109.561 516.363 113.838 514.74 118.852C513.118 123.718 512.307 129.101 512.307 135C512.307 140.899 513.118 146.355 514.74 151.369C516.363 156.236 518.649 160.513 521.599 164.199C524.697 167.739 528.384 170.541 532.662 172.605C537.087 174.522 542.102 175.481 547.707 175.481C553.164 175.481 558.032 174.522 562.309 172.605C566.734 170.541 570.422 167.739 573.372 164.199C576.47 160.513 578.83 156.236 580.452 151.369C582.075 146.355 582.886 140.899 582.886 135Z" fill="black"/>
<path d="M738.985 84.3434C738.1 87.5878 736.552 91.9382 734.339 97.3947C732.274 102.704 729.84 108.676 727.038 115.313C724.235 121.949 721.138 128.954 717.745 136.327C714.5 143.553 711.181 150.632 707.789 157.563C704.544 164.347 701.373 170.762 698.275 176.808C695.325 182.707 692.744 187.647 690.531 191.629H666.857C664.202 186.91 661.4 181.749 658.45 176.145C655.647 170.393 652.771 164.642 649.821 158.89C647.019 152.992 644.29 147.166 641.635 141.415C638.98 135.664 636.472 130.355 634.112 125.488C631.9 120.474 629.909 116.05 628.139 112.216C626.516 108.381 625.262 105.432 624.377 103.367C623.492 101.303 622.607 99.0906 621.722 96.731C620.837 94.3715 620.395 92.1594 620.395 90.0948C620.395 87.4403 621.28 85.007 623.05 82.7949C624.82 80.5829 627.844 79.4768 632.121 79.4768C635.071 79.4768 637.357 79.7718 638.98 80.3617C640.602 80.9515 641.487 81.3202 641.635 81.4677C644.142 88.3989 647.019 95.9937 650.264 104.252C653.656 112.511 657.049 120.695 660.441 128.806C663.981 136.77 667.374 144.438 670.619 151.812C673.864 159.038 676.74 165.158 679.248 170.172C681.018 166.78 683.304 161.987 686.106 155.794C689.056 149.452 692.08 142.521 695.178 135C698.423 127.479 701.668 119.737 704.913 111.773C708.158 103.81 711.034 96.5098 713.541 89.8736C714.721 86.6292 716.196 84.1222 717.966 82.3525C719.736 80.4354 722.686 79.4768 726.816 79.4768C730.357 79.4768 733.159 80.1404 735.224 81.4677C737.437 82.7949 738.69 83.7535 738.985 84.3434Z" fill="black"/>
<path d="M837.836 89.8736C837.836 86.3343 838.869 83.7535 840.934 82.1313C842.999 80.3617 845.949 79.4768 849.784 79.4768C852.291 79.4768 854.504 79.7718 856.421 80.3617C858.486 80.9515 859.887 81.394 860.625 81.6889V190.523C859.592 190.818 857.749 191.113 855.094 191.408C852.586 191.703 849.489 191.998 845.801 192.293C842.114 192.735 838.057 193.03 833.632 193.178C829.207 193.473 824.709 193.62 820.136 193.62C806.713 193.62 795.798 191.998 787.391 188.754C779.131 185.509 772.567 180.79 767.7 174.596C761.652 166.78 758.628 156.383 758.628 143.406V89.8736C758.628 86.3343 759.661 83.7535 761.726 82.1313C763.791 80.3617 766.741 79.4768 770.576 79.4768C773.083 79.4768 775.296 79.7718 777.213 80.3617C779.278 80.9515 780.68 81.394 781.417 81.6889V140.973C781.417 152.18 784.22 160.586 789.825 166.19C795.577 171.794 805.238 174.596 818.809 174.596C823.971 174.596 828.101 174.449 831.199 174.154C834.444 173.711 836.656 173.343 837.836 173.048V89.8736Z" fill="black"/>
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/public/vercel.svg
Tamaño: 128 bytes
Lenguaje detectado: SVG

### CONTENIDO ORIGINAL ###

<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>

### ANALISIS AUTOMATICO (ESPAÑOL) ###

<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app-react-email/ts/public/window.svg
Tamaño: 385 bytes
Lenguaje detectado: SVG

### CONTENIDO ORIGINAL ###

<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>

### ANALISIS AUTOMATICO (ESPAÑOL) ###

<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/app/ts/app/page.module.css
Tamaño: 3886 bytes
Lenguaje detectado: CSS

### CONTENIDO ORIGINAL ###

.main {
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  align-items: center;
  padding: 6rem;
  min-height: 100vh;
}

.description {
  display: inherit;
  justify-content: inherit;
  align-items: inherit;
  font-size: 0.85rem;
  max-width: var(--max-width);
  width: 100%;
  z-index: 2;
  font-family: var(--font-mono);
}

.description a {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 0.5rem;
}

.description p {
  position: relative;
  margin: 0;
  padding: 1rem;
  background-color: rgba(var(--callout-rgb), 0.5);
  border: 1px solid rgba(var(--callout-border-rgb), 0.3);
  border-radius: var(--border-radius);
}

.code {
  font-weight: 700;
  font-family: var(--font-mono);
}

.grid {
  display: grid;
  grid-template-columns: repeat(4, minmax(25%, auto));
  max-width: 100%;
  width: var(--max-width);
}

.card {
  padding: 1rem 1.2rem;
  border-radius: var(--border-radius);
  background: rgba(var(--card-rgb), 0);
  border: 1px solid rgba(var(--card-border-rgb), 0);
  transition:
    background 200ms,
    border 200ms;
}

.card span {
  display: inline-block;
  transition: transform 200ms;
}

.card h2 {
  font-weight: 600;
  margin-bottom: 0.7rem;
}

.card p {
  margin: 0;
  opacity: 0.6;
  font-size: 0.9rem;
  line-height: 1.5;
  max-width: 30ch;
  text-wrap: balance;
}

.center {
  display: flex;
  justify-content: center;
  align-items: center;
  position: relative;
  padding: 4rem 0;
}

.center::before {
  background: var(--secondary-glow);
  border-radius: 50%;
  width: 480px;
  height: 360px;
  margin-left: -400px;
}

.center::after {
  background: var(--primary-glow);
  width: 240px;
  height: 180px;
  z-index: -1;
}

.center::before,
.center::after {
  content: "";
  left: 50%;
  position: absolute;
  filter: blur(45px);
  transform: translateZ(0);
}

.logo {
  position: relative;
}
/* Enable hover only on non-touch devices */
@media (hover: hover) and (pointer: fine) {
  .card:hover {
    background: rgba(var(--card-rgb), 0.1);
    border: 1px solid rgba(var(--card-border-rgb), 0.15);
  }

  .card:hover span {
    transform: translateX(4px);
  }
}

@media (prefers-reduced-motion) {
  .card:hover span {
    transform: none;
  }
}

/* Mobile */
@media (max-width: 700px) {
  .content {
    padding: 4rem;
  }

  .grid {
    grid-template-columns: 1fr;
    margin-bottom: 120px;
    max-width: 320px;
    text-align: center;
  }

  .card {
    padding: 1rem 2.5rem;
  }

  .card h2 {
    margin-bottom: 0.5rem;
  }

  .center {
    padding: 8rem 0 6rem;
  }

  .center::before {
    transform: none;
    height: 300px;
  }

  .description {
    font-size: 0.8rem;
  }

  .description a {
    padding: 1rem;
  }

  .description p,
  .description div {
    display: flex;
    justify-content: center;
    position: fixed;
    width: 100%;
  }

  .description p {
    align-items: center;
    inset: 0 0 auto;
    padding: 2rem 1rem 1.4rem;
    border-radius: 0;
    border: none;
    border-bottom: 1px solid rgba(var(--callout-border-rgb), 0.25);
    background: linear-gradient(to bottom, rgba(var(--background-start-rgb), 1), rgba(var(--callout-rgb), 0.5));
    background-clip: padding-box;
    backdrop-filter: blur(24px);
  }

  .description div {
    align-items: flex-end;
    pointer-events: none;
    inset: auto 0 0;
    padding: 2rem;
    height: 200px;
    background: linear-gradient(to bottom, transparent 0%, rgb(var(--background-end-rgb)) 40%);
    z-index: 1;
  }
}

/* Tablet and Smaller Desktop */
@media (min-width: 701px) and (max-width: 1120px) {
  .grid {
    grid-template-columns: repeat(2, 50%);
  }
}

@media (prefers-color-scheme: dark) {
  .vercelLogo {
    filter: invert(1);
  }

  .logo {
    filter: invert(1) drop-shadow(0 0 0.3rem #ffffff70);
  }
}

@keyframes rotate {
  from {
    transform: rotate(360deg);
  }
  to {
    transform: rotate(0deg);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

.main {
display: flex;
flex-direction: column;
justify-content: space-between;
align-items: center;
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/novu/src/commands/init/templates/github/workflows/novu.yml
Tamaño: 837 bytes
Lenguaje detectado: YAML

### CONTENIDO ORIGINAL ###

name: Novu Sync

on:
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      # https://github.com/novuhq/actions-novu-sync
      - name: Sync State to Novu
        uses: novuhq/actions-novu-sync@v2
        with:
          # The secret key used to authenticate with Novu Cloud
          # To get the secret key, go to https://dashboard.novu.co/api-keys.
          # Required.
          secret-key: ${{ secrets.NOVU_SECRET_KEY }}

          # The publicly available endpoint hosting the bridge application
          # where notification entities (eg. workflows, topics) are defined.
          # Required.
          bridge-url: ${{ secrets.NOVU_BRIDGE_URL }}

          # The Novu Cloud API URL to sync with.
          # Optional.
          # Defaults to https://api.novu.co
          api-url: https://api.novu.co


### ANALISIS AUTOMATICO (ESPAÑOL) ###

name: Novu Sync
on:
workflow_dispatch:
# https://github.com/novuhq/actions-novu-sync
# The secret key used to authenticate with Novu Cloud
# To get the secret key, go to https://dashboard.novu.co/api-keys.
# Required.
# The publicly available endpoint hosting the bridge application
# where notification entities (eg. workflows, topics) are defined.
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/novu/src/commands/translations/README.md
Tamaño: 3007 bytes
Lenguaje detectado: Markdown

### CONTENIDO ORIGINAL ###

# Novu Translations CLI

The Novu CLI provides commands to manage translations for your Novu workspace.

## Commands

### `novu translations pull`

Downloads all translation files from Novu Cloud to your local directory.

```bash
# Pull translations to default directory (./translations)
npx novu translations pull -s YOUR_SECRET_KEY

# Pull to custom directory
npx novu translations pull -s YOUR_SECRET_KEY -d ./my-translations

# Use EU API endpoint
npx novu translations pull -s YOUR_SECRET_KEY -a https://eu.api.novu.co
```

**Options:**
- `-s, --secret-key <key>` - Your Novu Secret Key (required)
- `-a, --api-url <url>` - Novu API URL (default: https://api.novu.co)
- `-d, --directory <path>` - Directory to save files (default: ./translations)

### `novu translations push`

Uploads translation files from your local directory to Novu Cloud.

```bash
# Push translations from default directory (./translations)
npx novu translations push -s YOUR_SECRET_KEY

# Push from custom directory
npx novu translations push -s YOUR_SECRET_KEY -d ./my-translations

# Use EU API endpoint
npx novu translations push -s YOUR_SECRET_KEY -a https://eu.api.novu.co
```

**Options:**
- `-s, --secret-key <key>` - Your Novu Secret Key (required)
- `-a, --api-url <url>` - Novu API URL (default: https://api.novu.co)
- `-d, --directory <path>` - Directory containing files (default: ./translations)

## File Format

Translation files should be named with locale codes and contain valid JSON:

```
translations/
├── en_US.json
├── fr_FR.json
├── es_ES.json
└── de_DE.json
```

Example file content (`en_US.json`):
```json
{
  "workflows": {
    "welcome": {
      "subject": "Welcome to our platform!",
      "body": "Thank you for joining us."
    }
  }
}
```

## Environment Variables

You can set environment variables to avoid passing options repeatedly:

```bash
export NOVU_SECRET_KEY="your_secret_key_here"
export NOVU_API_URL="https://api.novu.co"  # or https://eu.api.novu.co for EU

# Now you can run commands without -s and -a flags
npx novu translations pull
npx novu translations push
```

## Supported Locales

The CLI supports standard locale codes including:
- `en_US`, `en_GB` (English)
- `es_ES` (Spanish)
- `fr_FR` (French)
- `de_DE` (German)
- `it_IT` (Italian)
- `pt_BR` (Portuguese)
- `ja_JP` (Japanese)
- `ko_KR` (Korean)
- `zh_CN`, `zh_TW` (Chinese)
- `ru_RU` (Russian)
- `ar_SA` (Arabic)
- `hi_IN` (Hindi)
- And many more...

## Error Handling

The CLI provides detailed error messages for common issues:
- Invalid API key
- Network connectivity problems
- Invalid JSON files
- Missing translation files
- File permission issues

## Tips

1. **Backup before pushing**: Always backup your existing translations before pushing new ones
2. **Validate JSON**: Ensure your JSON files are valid before pushing
3. **Use version control**: Track your translation files in git for better collaboration
4. **Test with pull**: Use `pull` command to see the expected file structure


### ANALISIS AUTOMATICO (ESPAÑOL) ###

# Novu Translations CLI
The Novu CLI provides commands to manage translations for your Novu workspace.
## Commands
### `novu translations pull`
# Pull translations to default directory (./translations)
# Pull to custom directory
# Use EU API endpoint
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/novu/src/commands/translations/client.ts
Tamaño: 4268 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import axios from 'axios';
import FormData from 'form-data';
import { createReadStream } from 'fs';
import { MasterJsonResponse, OrganizationSettingsResponse, UploadResponse } from './types';

export class TranslationClient {
  constructor(
    private apiUrl: string,
    private secretKey: string
  ) {}

  private getHeaders() {
    return {
      'Content-Type': 'application/json',
      Authorization: `ApiKey ${this.secretKey}`,
    };
  }

  async getMasterJson(locale: string): Promise<MasterJsonResponse> {
    try {
      const response = await axios.get(`${this.apiUrl}/v2/translations/master-json`, {
        params: { locale },
        headers: this.getHeaders(),
      });

      return response.data;
    } catch (error) {
      if (axios.isAxiosError(error)) {
        if (error.response?.status === 404) {
          throw new Error(`No translations found for locale: ${locale}`);
        }
        if (error.response?.status === 401) {
          throw new Error('Invalid API key. Please check your secret key.');
        }
        throw new Error(`API Error: ${error.response?.data?.message || error.message}`);
      }
      throw error;
    }
  }

  async uploadMasterJson(filePath: string): Promise<UploadResponse> {
    try {
      const formData = new FormData();
      formData.append('file', createReadStream(filePath));

      const response = await axios.post(`${this.apiUrl}/v2/translations/master-json/upload`, formData, {
        headers: {
          ...formData.getHeaders(),
          Authorization: `ApiKey ${this.secretKey}`,
        },
      });

      return response.data;
    } catch (error) {
      if (axios.isAxiosError(error)) {
        if (error.response?.status === 401) {
          throw new Error('Invalid API key. Please check your secret key.');
        }
        if (error.response?.status === 400) {
          const apiMessage = error.response?.data?.message || error.response?.data?.error || 'Invalid request format';
          throw new Error(`Bad request: ${apiMessage}`);
        }
        if (error.response?.status === 404) {
          throw new Error('Upload endpoint not found. Please check your API URL.');
        }
        if (error.response?.status >= 500) {
          throw new Error(
            `Server error (${error.response.status}): ${error.response?.data?.message || 'Internal server error'}`
          );
        }

        const apiMessage =
          error.response?.data?.message || error.response?.data?.error || error.message || 'Request failed';
        throw new Error(`Upload failed (${error.response?.status || 'unknown'}): ${apiMessage}`);
      }

      if (error instanceof Error) {
        throw new Error(`Network error: ${error.message}`);
      }

      throw new Error('Unknown upload error occurred');
    }
  }

  async validateConnection(): Promise<void> {
    try {
      await axios.get(`${this.apiUrl}/v1/users/me`, {
        headers: {
          Authorization: `ApiKey ${this.secretKey}`,
        },
      });
    } catch (error) {
      if (axios.isAxiosError(error)) {
        if (error.response?.status === 401) {
          throw new Error('Invalid API key. Please check your secret key.');
        }
        throw new Error(`Connection failed: ${error.response?.data?.message || error.message}`);
      }
      throw error;
    }
  }

  async getOrganizationSettings(): Promise<OrganizationSettingsResponse> {
    try {
      const response = await axios.get(`${this.apiUrl}/v1/organizations/settings`, {
        headers: this.getHeaders(),
      });

      return response.data;
    } catch (error) {
      if (axios.isAxiosError(error)) {
        if (error.response?.status === 401) {
          throw new Error('Invalid API key. Please check your secret key.');
        }
        if (error.response?.status === 404) {
          throw new Error('Organization settings not found. Please ensure your API key has proper permissions.');
        }
        const apiMessage =
          error.response?.data?.message || error.response?.data?.error || 'Failed to fetch organization settings';
        throw new Error(`Settings API error: ${apiMessage}`);
      }
      throw new Error(`Network error: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class TranslationClient

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/translations/index.ts
Tamaño: 157 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export { TranslationClient } from './client';
export { pullTranslations } from './pull';
export { pushTranslations } from './push';
export * from './types';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/translations/pull.ts
Tamaño: 4057 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import ora from 'ora';
import { TranslationClient } from './client';
import { TranslationCommandOptions } from './types';
import { formatFileSize, saveTranslationFile } from './utils';

export async function pullTranslations(options: TranslationCommandOptions): Promise<void> {
  if (!options.secretKey) {
    throw new Error('Secret key is required. Use -s flag or set NOVU_SECRET_KEY environment variable.');
  }

  const client = new TranslationClient(options.apiUrl, options.secretKey);

  // Validate connection first
  const connectionSpinner = ora('Validating connection to Novu Cloud...').start();
  try {
    await client.validateConnection();
    connectionSpinner.succeed('Connected to Novu Cloud');
  } catch (error) {
    connectionSpinner.fail('Connection failed');
    throw error;
  }

  // Fetch organization settings to get configured locales
  const settingsSpinner = ora('Fetching organization locale settings...').start();
  let targetLocales: string[];
  let defaultLocale: string;

  try {
    const settings = await client.getOrganizationSettings();
    defaultLocale = settings.data.defaultLocale;
    targetLocales = [defaultLocale, ...settings.data.targetLocales];

    // Remove duplicates in case defaultLocale is also in targetLocales
    targetLocales = [...new Set(targetLocales)];

    settingsSpinner.succeed(`Found ${targetLocales.length} configured locales (default: ${defaultLocale})`);
  } catch (error) {
    settingsSpinner.fail('Organization settings not available');
    console.log('\n🚫 Unable to fetch organization locale settings.');
    console.log('\n💡 To use translations, you need to:');
    console.log('  1. Go to your Novu Dashboard');
    console.log('  2. Navigate to the Translations page');
    console.log('  3. Enable translations and configure your target locales');
    console.log('  4. Set your default locale');
    console.log('\n📖 Learn more: https://docs.novu.co/platform/workflow/translations');

    throw new Error('Translations not configured. Please enable translations in your dashboard first.');
  }

  console.log(`📥 Pulling translations to: ${options.directory}`);
  console.log(`🌍 Locales: ${targetLocales.join(', ')}`);

  let successCount = 0;
  let errorCount = 0;
  const errors: string[] = [];

  for (const locale of targetLocales) {
    const spinner = ora(`Fetching ${locale}...`).start();

    try {
      const response = await client.getMasterJson(locale);

      if (response.data && Object.keys(response.data).length > 0) {
        const filePath = await saveTranslationFile(options.directory, locale, response.data);
        const stats = await import('fs').then((fs) => fs.promises.stat(filePath));

        spinner.succeed(`${locale} → ${formatFileSize(stats.size)}`);
        successCount++;
      } else {
        spinner.info(`${locale} → No translations available`);
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';

      if (errorMessage.includes('No translations found')) {
        spinner.info(`${locale} → No translations available`);
      } else {
        spinner.fail(`${locale} → ${errorMessage}`);
        errors.push(`${locale}: ${errorMessage}`);
        errorCount++;
      }
    }
  }

  console.log('\n📊 Pull Summary:');
  console.log(`✅ Successfully pulled: ${successCount} locales`);

  if (errorCount > 0) {
    console.log(`❌ Errors: ${errorCount} locales`);
    console.log('\nError details:');
    for (const error of errors) {
      console.log(`  • ${error}`);
    }
  }

  if (successCount === 0) {
    console.log('\n💡 No translation files were downloaded. This might be because:');
    console.log('  • No translations have been uploaded to your Novu workspace yet');
    console.log("  • Your API key doesn't have access to translations");
    console.log("  • You're using the wrong API URL (try -a https://eu.api.novu.co for EU)");
  } else {
    console.log(`\n🎉 Translation files saved to: ${options.directory}`);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - pullTranslations(options: TranslationCommandOptions)
Asignaciones con arrow functions encontradas (posibles funciones):
 - stats(await import('fs').then((fs))
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/translations/push.ts
Tamaño: 5479 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import ora from 'ora';
import { TranslationClient } from './client';
import { TranslationCommandOptions } from './types';
import { formatFileSize, loadTranslationFiles } from './utils';

export async function pushTranslations(options: TranslationCommandOptions): Promise<void> {
  if (!options.secretKey) {
    throw new Error('Secret key is required. Use -s flag or set NOVU_SECRET_KEY environment variable.');
  }

  const client = new TranslationClient(options.apiUrl, options.secretKey);

  // Validate connection first
  const connectionSpinner = ora('Validating connection to Novu Cloud...').start();
  try {
    await client.validateConnection();
    connectionSpinner.succeed('Connected to Novu Cloud');
  } catch (error) {
    connectionSpinner.fail('Connection failed');
    throw error;
  }

  // Fetch organization settings to get configured locales
  const settingsSpinner = ora('Fetching organization locale settings...').start();
  let targetLocales: string[];
  let defaultLocale: string;

  try {
    const settings = await client.getOrganizationSettings();
    defaultLocale = settings.data.defaultLocale;
    targetLocales = [defaultLocale, ...settings.data.targetLocales];

    // Remove duplicates in case defaultLocale is also in targetLocales
    targetLocales = [...new Set(targetLocales)];

    settingsSpinner.succeed(`Found ${targetLocales.length} configured locales (default: ${defaultLocale})`);
  } catch (error) {
    settingsSpinner.fail('Organization settings not available');
    console.log('\n🚫 Unable to fetch organization locale settings.');
    console.log('\n💡 To use translations, you need to:');
    console.log('  1. Go to your Novu Dashboard');
    console.log('  2. Navigate to the Translations page');
    console.log('  3. Enable translations and configure your target locales');
    console.log('  4. Set your default locale');
    console.log('\n📖 Learn more: https://docs.novu.co/platform/workflow/translations');

    throw new Error('Translations not configured. Please enable translations in your dashboard first.');
  }

  // Load translation files
  const loadingSpinner = ora(`Loading translation files from: ${options.directory}`).start();
  let translationFiles: Awaited<ReturnType<typeof loadTranslationFiles>>;

  try {
    translationFiles = await loadTranslationFiles(options.directory);
    loadingSpinner.succeed(`Found ${translationFiles.length} translation files`);
  } catch (error) {
    loadingSpinner.fail('Failed to load translation files');
    throw error;
  }

  // Filter files to only include configured locales
  const validFiles = translationFiles.filter((file) => targetLocales.includes(file.locale));
  const invalidFiles = translationFiles.filter((file) => !targetLocales.includes(file.locale));

  if (invalidFiles.length > 0) {
    console.log(`\n⚠️  Skipping ${invalidFiles.length} files with unconfigured locales:`);
    for (const file of invalidFiles) {
      console.log(`  • ${file.locale}.json (not in organization settings)`);
    }
    console.log(`\n🌍 Configured locales: ${targetLocales.join(', ')}`);
  }

  translationFiles = validFiles;

  if (translationFiles.length === 0) {
    console.log('\n💡 No translation files found. Expected format:');
    console.log('  • Files should be named with locale codes (e.g., en_US.json, fr_FR.json)');
    console.log('  • Files should contain valid JSON content');
    console.log(`  • Files should be located in: ${options.directory}`);

    return;
  }

  console.log(`\n📤 Pushing ${translationFiles.length} translation files to Novu Cloud...`);

  let successCount = 0;
  let errorCount = 0;
  const errors: string[] = [];
  let totalImported = 0;

  for (const file of translationFiles) {
    const spinner = ora(`Uploading ${file.locale}...`).start();

    try {
      const stats = await import('fs').then((fs) => fs.promises.stat(file.filePath));
      const response = await client.uploadMasterJson(file.filePath);

      if (response.data.success) {
        const importedCount = response.data.successful?.length || 0;
        spinner.succeed(`${file.locale} → ${formatFileSize(stats.size)} (${importedCount} resources imported)`);
        successCount++;
        totalImported += importedCount;
      } else {
        spinner.fail(`${file.locale} → ${response.data.message || 'Upload failed'}`);
        errors.push(`${file.locale}: ${response.data.message || 'Upload failed'}`);
        errorCount++;
      }
    } catch (error) {
      let errorMessage = 'Unknown error';

      if (error instanceof Error) {
        errorMessage = error.message || 'Request failed without error message';
      } else if (typeof error === 'string') {
        errorMessage = error;
      } else if (error && typeof error === 'object') {
        errorMessage = JSON.stringify(error);
      }

      spinner.fail(`${file.locale} → ${errorMessage}`);
      errors.push(`${file.locale}: ${errorMessage}`);
      errorCount++;
    }
  }

  console.log('\n📊 Push Summary:');
  console.log(`✅ Successfully pushed: ${successCount} files`);
  console.log(`📝 Total translations imported: ${totalImported}`);

  if (errorCount > 0) {
    console.log(`❌ Errors: ${errorCount} files`);
    console.log('\nError details:');
    for (const error of errors) {
      console.log(`  • ${error}`);
    }
  }

  if (successCount > 0) {
    console.log('\n🎉 Translations successfully uploaded to Novu Cloud!');
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - pushTranslations(options: TranslationCommandOptions)
Asignaciones con arrow functions encontradas (posibles funciones):
 - validFiles(translationFiles.filter((file))
 - invalidFiles(translationFiles.filter((file))
 - stats(await import('fs').then((fs))
Declaraciones 'export' encontradas:
- export  async

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/translations/types.ts
Tamaño: 709 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export interface TranslationCommandOptions {
  secretKey: string;
  apiUrl: string;
  directory: string;
}

export interface MasterJsonResponse {
  data: Record<string, unknown>;
  locale: string;
}

export interface UploadResponseData {
  success: boolean;
  message: string;
  successful?: string[];
  failed?: string[];
}

export interface UploadResponse {
  data: UploadResponseData;
}

export interface OrganizationSettings {
  removeNovuBranding: boolean;
  defaultLocale: string;
  targetLocales: string[];
}

export interface OrganizationSettingsResponse {
  data: OrganizationSettings;
}

export interface TranslationFile {
  locale: string;
  filePath: string;
  content: Record<string, unknown>;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  interface
- export  interface
- export  interface
- export  interface
- export  interface
- export  interface
- export  interface

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/commands/translations/utils.ts
Tamaño: 2386 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { promises as fs } from 'fs';
import path from 'path';
import { TranslationFile } from './types';

export async function ensureDirectoryExists(dirPath: string): Promise<void> {
  try {
    await fs.access(dirPath);
  } catch {
    await fs.mkdir(dirPath, { recursive: true });
  }
}

export function extractLocaleFromFilename(filename: string): string | null {
  const match = filename.match(/^([a-z]{2}(?:_[A-Z]{2})?)\.json$/i);

  return match ? match[1] : null;
}

export function createFilenameFromLocale(locale: string): string {
  return `${locale}.json`;
}

export async function saveTranslationFile(
  directory: string,
  locale: string,
  content: Record<string, unknown>
): Promise<string> {
  await ensureDirectoryExists(directory);
  const filename = createFilenameFromLocale(locale);
  const filePath = path.join(directory, filename);

  await fs.writeFile(filePath, JSON.stringify(content, null, 2), 'utf8');

  return filePath;
}

export async function loadTranslationFiles(directory: string): Promise<TranslationFile[]> {
  try {
    await fs.access(directory);
  } catch {
    throw new Error(`Directory not found: ${directory}`);
  }

  const files = await fs.readdir(directory);
  const translationFiles: TranslationFile[] = [];

  for (const file of files) {
    const locale = extractLocaleFromFilename(file);
    if (!locale) {
      console.warn(`Skipping file with invalid name format: ${file} (expected format: locale.json, e.g., en_US.json)`);
      continue;
    }

    const filePath = path.join(directory, file);
    try {
      const content = await fs.readFile(filePath, 'utf8');
      const parsedContent = JSON.parse(content);

      translationFiles.push({
        locale,
        filePath,
        content: parsedContent,
      });
    } catch (error) {
      console.warn(`Skipping invalid JSON file: ${file} - ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  return translationFiles;
}

export function validateTranslationContent(content: unknown): boolean {
  return typeof content === 'object' && content !== null && !Array.isArray(content);
}

export function formatFileSize(bytes: number): string {
  if (bytes === 0) return '0 B';
  const k = 1024;
  const sizes = ['B', 'KB', 'MB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));

  return `${parseFloat((bytes / k ** i).toFixed(1))} ${sizes[i]}`;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - ensureDirectoryExists(dirPath: string)
 - extractLocaleFromFilename(filename: string)
 - createFilenameFromLocale(locale: string)
 - saveTranslationFile(directory: string,
  locale: string,
  content: Record<string, unknown>)
 - loadTranslationFiles(directory: string)
 - validateTranslationContent(content: unknown)
 - formatFileSize(bytes: number)
Declaraciones 'export' encontradas:
- export  async
- export function extractLocaleFromFilename
- export function createFilenameFromLocale
- export  async
- export  async
- export function validateTranslationContent
- export function formatFileSize

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/constants/constants.ts
Tamaño: 457 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import dotenv from 'dotenv';

// see https://github.com/motdotla/dotenv#how-do-i-use-dotenv-with-import
dotenv.config();
// CLI Server
export const SERVER_HOST = 'localhost';

// Novu Cloud
export const { NOVU_API_URL, NOVU_SECRET_KEY } = process.env;

// segment analytics
export const ANALYTICS_ENABLED = process.env.ANALYTICS_ENABLED !== 'false';
export const SEGMENTS_WRITE_KEY = process.env.CLI_SEGMENT_WRITE_KEY || 'tz68K6ytWx6AUqDl30XAwiIoUfr7iWVW';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  const
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/constants/index.ts
Tamaño: 29 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './constants';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/dev-server/http-server.ts
Tamaño: 5004 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import http from 'node:http';
import getPort from 'get-port';
import { AddressInfo } from 'net';
import { DevCommandOptions } from '../commands';

export const WELL_KNOWN_ROUTE = '/.well-known/novu';
export const STUDIO_PATH = '/studio';

export type DevServerOptions = { tunnelOrigin: string; anonymousId?: string } & Partial<
  Pick<DevCommandOptions, 'origin' | 'port' | 'studioPort' | 'studioHost' | 'dashboardUrl' | 'route'>
>;

export class DevServer {
  private server: http.Server;
  public token: string;

  constructor(private options: DevServerOptions) {}

  public async listen(): Promise<void> {
    const port = await getPort({ host: this.options.studioHost, port: Number(this.options.studioPort) });
    this.server = http.createServer();
    this.server.on('request', async (req, res) => {
      try {
        if (req.url.startsWith(WELL_KNOWN_ROUTE)) {
          this.serveWellKnownPath(req, res);
        } else if (req.url.startsWith(STUDIO_PATH)) {
          this.serveStudio(req, res);
        } else {
          res
            .writeHead(301, {
              Location: STUDIO_PATH,
            })
            .end();
        }
      } catch (e) {
        console.error(e);
      }
    });

    await new Promise<void>((resolve) => {
      this.server.listen(port, this.options.studioHost, () => {
        resolve();
      });
    });
  }

  public getAddress() {
    const response = this.server.address() as AddressInfo;

    return `http://${this.options.studioHost}:${response.port}`;
  }

  public getStudioAddress() {
    return `${this.getAddress()}${STUDIO_PATH}`;
  }

  public close(): void {
    this.server.close();
  }

  private serveWellKnownPath(req: http.IncomingMessage, res: http.ServerResponse) {
    res.setHeader('Content-Type', 'application/json');
    res.setHeader('Access-Control-Allow-Origin', this.options.dashboardUrl);
    res.end(JSON.stringify(this.options));
  }

  private serveStudio(req: http.IncomingMessage, res: http.ServerResponse) {
    const studioHTML = `
    <html class="dark">
      <head>
        <link href="${this.options.dashboardUrl}/favicon.svg" rel="icon" />
        <title>Novu Studio</title>
      </head>
      <body style="padding: 0; margin: 0; overflow: hidden;">
        <script>
          const NOVU_CLOUD_STUDIO_ORIGIN = '${this.options.dashboardUrl}';

          function injectIframe(src) {
           /*
           * Updates the URL in the parent window for better navigation control.
           * Example: If the user enters 'http://localhost:PORT/studio/onboarding/preview', it remains unchanged,
           * otherwise, redirects back to 'http://localhost:PORT/studio/onboarding'.
           */
            const getWindowsUrl = (url) => {
              const studioPath = '/studio';
              const pathname = window.location.pathname;
            
              return url.includes(studioPath) ? url.replace(studioPath, pathname) : url;
            };
            
            const iframe = window.document.createElement('iframe');
            iframe.sandbox = 'allow-forms allow-scripts allow-modals allow-same-origin allow-popups allow-popups-to-escape-sandbox'
            iframe.allow = 'clipboard-read; clipboard-write'
            iframe.style = 'width: 100%; height: 100vh; border: none;';
            
            const currentUrl = getWindowsUrl(src)
            iframe.setAttribute('src', currentUrl);
            document.body.appendChild(iframe);
            
            window.addEventListener('message', (event) => {
              if (event?.data?.type === 'pathnameChange') {
                history.replaceState(null, '', event.data?.pathname);
              }
            });

            return iframe;
          }

          function redirectToCloud() {
            // Replace the local tunnel with Novu Web Dashboard on build time.
            const url = new URL('/local-studio/auth', NOVU_CLOUD_STUDIO_ORIGIN);
            url.searchParams.set('redirect_url', window.location.href);
            url.searchParams.set('application_origin', '${this.options.origin}');
            url.searchParams.set('tunnel_origin', '${this.options.tunnelOrigin}');
            url.searchParams.set('tunnel_route', '${this.options.route}');
            url.searchParams.set('anonymous_id', '${this.options.anonymousId}');

            window.location.href = url.href;
          }

          function bootstrapLocalStudio() {
            const url = new URL(window.location.href);
            const localStudioURL = url.searchParams.get('local_studio_url');

            url.searchParams.delete('local_studio_url');
            history.replaceState({}, '', url.href);

            if (!localStudioURL) {
              return redirectToCloud();
            }

            injectIframe(localStudioURL);
          }

          bootstrapLocalStudio();
        </script>
      </body>
    </html>
  `;

    res.writeHead(200, { 'Content-Type': 'text/html' });
    res.write(studioHTML);
    res.end();
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - injectIframe(src)
 - redirectToCloud()
 - bootstrapLocalStudio()
Asignaciones con arrow functions encontradas (posibles funciones):
 - server(http.createServer();
    this.server.on('request', async (req, res))
 - getWindowsUrl(url))
 - currentUrl(getWindowsUrl(src)
            iframe.setAttribute('src', currentUrl);
            document.body.app...)
Declaraciones 'export' encontradas:
- export  const
- export  const
- export  type
- export class DevServer

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/dev-server/index.ts
Tamaño: 31 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './http-server';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/services/analytics.service.ts
Tamaño: 2509 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSessionData } from '@novu/shared';
import { Analytics } from '@segment/analytics-node';
import { ANALYTICS_ENABLED, SEGMENTS_WRITE_KEY } from '../constants';

export enum AnalyticsEventEnum {
  ENVIRONMENT_SELECT_EVENT = 'Select Install Environment',
  CREATE_APP_QUESTION_EVENT = 'Create App Question',
  REGISTER_METHOD_SELECT_EVENT = 'Select Register Method',
  TERMS_AND_CONDITIONS_QUESTION = 'Terms And Conditions Question',
  PRIVATE_EMAIL_ATTEMPT = 'Private Email Register Attempt',
  ACCOUNT_CREATED = 'account_created',
  OPEN_DASHBOARD = 'open_dashboard',
  DASHBOARD_PAGE_OPENED = 'Dashboard Page Opened',
  EXIT_EXISTING_SESSION = 'exit_existing_session',
  SKIP_TUTORIAL = 'skip_tutorial',
  COPY_SNIPPET = 'copy_snippet',
  TRIGGER_BUTTON = 'trigger_button',
  CLI_LAUNCHED = 'Cli Launched',
}

export const ANALYTICS_SOURCE = '[CLI Onboarding]';

export class AnalyticService {
  private _analytics: Analytics;
  private _analyticsEnabled: boolean;

  constructor() {
    this._analyticsEnabled = ANALYTICS_ENABLED;
    if (this._analyticsEnabled) {
      this._analytics = new Analytics({
        writeKey: SEGMENTS_WRITE_KEY,
      });
    }
  }

  alias({ previousId, userId }: { previousId: string; userId: string }) {
    if (!this.isAnalyticsEnabled()) {
      return;
    }

    this._analytics.alias({
      previousId,
      userId,
    });
  }

  identify(user: UserSessionData & { createdAt: string }) {
    if (!this.isAnalyticsEnabled()) {
      return;
    }

    this._analytics.identify({
      userId: user._id,
      traits: {
        email: user.email,
        name: `${user.firstName || ''} ${user.lastName || ''}`.trim(),
        firstName: user.firstName,
        lastName: user.lastName,
        avatar: user.profilePicture,
        createdAt: user.createdAt,
      },
    });
  }

  track({
    data,
    event,
    identity,
  }: {
    data?: Record<string, unknown>;
    event: string;
    identity: { userId: string } | { anonymousId: string };
  }) {
    if (!this.isAnalyticsEnabled()) {
      return;
    }
    const payload = {
      event: `${event} - ${ANALYTICS_SOURCE}`,
      ...identity,
      properties: {},
    };

    if (data) {
      payload.properties = { ...payload.properties, ...data };
    }

    this._analytics.track(payload);
  }

  async flush() {
    if (!this.isAnalyticsEnabled()) {
      return;
    }

    await this._analytics.closeAndFlush();
  }

  private isAnalyticsEnabled() {
    return this._analyticsEnabled;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  enum
- export  const
- export class AnalyticService

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/services/config.service.ts
Tamaño: 954 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSessionData } from '@novu/shared';
import Configstore from 'configstore';
import jwt_decode from 'jwt-decode';

type OriginPort = number;
type ConfigKey = 'token' | 'anonymousId' | `tunnelUrl-${OriginPort}`;

export class ConfigService {
  private _config: Configstore;
  constructor() {
    this._config = new Configstore('novu-cli');
  }

  setValue(key: ConfigKey, value: string) {
    this._config.set(key, value);
  }

  getValue(key: ConfigKey) {
    return this._config.get(key);
  }

  async clearStore() {
    return this._config.clear();
  }

  isOrganizationIdExist(): boolean {
    return !!this.getDecodedToken().organizationId;
  }

  isEnvironmentIdExist(): boolean {
    return !!this.getDecodedToken().environmentId;
  }

  getToken(): string {
    return this.getValue('token');
  }

  getDecodedToken(): UserSessionData {
    if (!this.getToken()) {
      return null;
    }

    return jwt_decode(this.getToken());
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ConfigService

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/novu/src/services/index.ts
Tamaño: 71 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './analytics.service';
export * from './config.service';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/.czrc
Tamaño: 42 bytes
Lenguaje detectado: CZRC

### CONTENIDO ORIGINAL ###

{
  "path": "cz-conventional-changelog"
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"path": "cz-conventional-changelog"
}
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/providers/.gitignore
Tamaño: 82 bytes
Lenguaje detectado: GITIGNORE

### CONTENIDO ORIGINAL ###

.idea/*
.nyc_output
build
node_modules
src/**.js
coverage
*.log
package-lock.json


### ANALISIS AUTOMATICO (ESPAÑOL) ###

.idea/*
.nyc_output
build
node_modules
src/**.js
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/providers/CHANGELOG.md
Tamaño: 5939 bytes
Lenguaje detectado: Markdown

### CONTENIDO ORIGINAL ###

## 2.6.6 (2025-02-25)

### 🚀 Features

- **api-service:** system limits & update pricing pages ([#7718](https://github.com/novuhq/novu/pull/7718))
- **root:** add no only github action ([#7692](https://github.com/novuhq/novu/pull/7692))

### 🩹 Fixes

- **root:** unhandled promise reject and undefined ff kind ([#7732](https://github.com/novuhq/novu/pull/7732))
- **api-service:** remove only on e2e ([#7691](https://github.com/novuhq/novu/pull/7691))

### 🧱 Updated Dependencies

- Updated @novu/shared to 2.6.6
- Updated @novu/stateless to 2.6.6

### ❤️ Thank You

- GalTidhar @tatarco
- George Djabarov @djabarovgeorge


## 2.6.5 (2025-02-07)

### 🚀 Features

- Update README.md ([bb63172dd](https://github.com/novuhq/novu/commit/bb63172dd))
- **readme:** Update README.md ([955cbeab0](https://github.com/novuhq/novu/commit/955cbeab0))
- quick start updates readme ([88b3b6628](https://github.com/novuhq/novu/commit/88b3b6628))
- **readme:** update readme ([e5ea61812](https://github.com/novuhq/novu/commit/e5ea61812))
- **api-service:** add internal sdk ([#7599](https://github.com/novuhq/novu/pull/7599))
- **dashboard:** step conditions editor ui ([#7502](https://github.com/novuhq/novu/pull/7502))
- **api-service:** refactor issue error messages ([#7359](https://github.com/novuhq/novu/pull/7359))
- **api:** add query parser ([#7267](https://github.com/novuhq/novu/pull/7267))
- **api:** Nv 5033 additional removal cycle found unneeded elements ([#7283](https://github.com/novuhq/novu/pull/7283))
- **api:** Nv 4966 e2e testing happy path - messages ([#7248](https://github.com/novuhq/novu/pull/7248))
- **api:** add external id api to onesignal Based on #6976 ([#7270](https://github.com/novuhq/novu/pull/7270), [#6976](https://github.com/novuhq/novu/issues/6976))
- **dashboard:** Implement email step editor & mini preview ([#7129](https://github.com/novuhq/novu/pull/7129))
- **api:** converted bulk trigger to use SDK ([#7166](https://github.com/novuhq/novu/pull/7166))
- **application-generic:** add SUBSCRIBER_WIDGET_JWT_EXPIRATION_TIME env variable ([#7105](https://github.com/novuhq/novu/pull/7105))

### 🩹 Fixes

- **dashboard:** change sendinblue to brevo ([#7668](https://github.com/novuhq/novu/pull/7668))
- **js:** Await read action in Inbox ([#7653](https://github.com/novuhq/novu/pull/7653))
- **api:** duplicated subscribers created due to race condition ([#7646](https://github.com/novuhq/novu/pull/7646))
- **api-service:** add missing environment variable ([#7553](https://github.com/novuhq/novu/pull/7553))
- **api-service:** set check field as false by default ([#7469](https://github.com/novuhq/novu/pull/7469))
- **api:** Fix failing API e2e tests ([78c385ec7](https://github.com/novuhq/novu/commit/78c385ec7))
- **api-service:** E2E improvements ([#7461](https://github.com/novuhq/novu/pull/7461))
- **novu:** automatically create indexes on startup ([#7431](https://github.com/novuhq/novu/pull/7431))
- **api:** @novu/api -> @novu/api-service ([#7348](https://github.com/novuhq/novu/pull/7348))
- **api:** fix onesignal ios_badgeCount and ios_badgeType typos ([#7273](https://github.com/novuhq/novu/pull/7273))

### 🧱 Updated Dependencies

- Updated @novu/shared to 2.6.5
- Updated @novu/stateless to 2.6.5

### ❤️ Thank You

- Aminul Islam @AminulBD
- Dima Grossman @scopsy
- GalTidhar @tatarco
- George Desipris @desiprisg
- George Djabarov @djabarovgeorge
- Lucky @L-U-C-K-Y
- Pawan Jain
- Paweł Tymczuk @LetItRock
- Sokratis Vidros @SokratisVidros


## 2.0.4 (2024-12-24)

### 🧱 Updated Dependencies

- Updated @novu/shared to 2.1.5
- Updated @novu/stateless to 2.0.3

### ❤️ Thank You

- Dima Grossman @scopsy
- GalTidhar @tatarco
- George Desipris @desiprisg
- George Djabarov @djabarovgeorge
- Lucky @L-U-C-K-Y
- Pawan Jain


## 2.0.3 (2024-11-26)

### 🚀 Features

- **dashboard:** Codemirror liquid filter support ([#7122](https://github.com/novuhq/novu/pull/7122))
- **root:** add support chat app ID to environment variables in d… ([#7120](https://github.com/novuhq/novu/pull/7120))
- **root:** Add base Dockerfile for GHCR with Node.js and dependencies ([#7100](https://github.com/novuhq/novu/pull/7100))

### 🩹 Fixes

- **api:** Migrate subscriber global preferences before workflow preferences ([#7118](https://github.com/novuhq/novu/pull/7118))
- **api, dal, framework:** fix the uneven and unused dependencies ([#7103](https://github.com/novuhq/novu/pull/7103))

### 🧱 Updated Dependencies

- Updated @novu/shared to 2.1.4
- Updated @novu/stateless to 2.0.2

### ❤️  Thank You

- George Desipris @desiprisg
- Himanshu Garg @merrcury
- Richard Fontein @rifont

## 2.0.2 (2024-11-19)

### 🚀 Features

- **root:** release 2.0.1 for all major packages ([#6925](https://github.com/novuhq/novu/pull/6925))
- **api:** add usage of bridge provider options in send message usecases a… ([#6062](https://github.com/novuhq/novu/pull/6062))
- **framework:** add generic support for providers ([#6021](https://github.com/novuhq/novu/pull/6021))
- **providers:** Mobishastra sms provider ([#5648](https://github.com/novuhq/novu/pull/5648))

### 🩹 Fixes

- **root:** Build only public packages during preview deployments ([#6590](https://github.com/novuhq/novu/pull/6590))
- fcm error for spec files ([76f4f7680](https://github.com/novuhq/novu/commit/76f4f7680))
- **worker:** multi case method for fcm ([#6405](https://github.com/novuhq/novu/pull/6405))
- **providers:** add sendername field in mailgun config ([#6364](https://github.com/novuhq/novu/pull/6364))
- **framework:** so passthrough body is not casing transformed ([#6305](https://github.com/novuhq/novu/pull/6305))
- **echo:** Use dist for Echo artifacts ([#5590](https://github.com/novuhq/novu/pull/5590))

### ❤️  Thank You

- Amin Mahfouz
- David Söderberg @davidsoderberg
- Dima Grossman
- Himanshu Garg
- Pawan Jain
- Richard Fontein @rifont
- Sokratis Vidros @SokratisVidros

### ANALISIS AUTOMATICO (ESPAÑOL) ###

## 2.6.6 (2025-02-25)
### 🚀 Features
- **api-service:** system limits & update pricing pages ([#7718](https://github.com/novuhq/novu/pull/7718))
### 🩹 Fixes
### 🧱 Updated Dependencies
### ❤️ Thank You
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/providers/README.md
Tamaño: 1674 bytes
Lenguaje detectado: Markdown

### CONTENIDO ORIGINAL ###

<div align="center">
  <a href="https://novu.co?utm_source=github" target="_blank">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://user-images.githubusercontent.com/2233092/213641039-220ac15f-f367-4d13-9eaf-56e79433b8c1.png">
    <img alt="Novu Logo" src="https://user-images.githubusercontent.com/2233092/213641043-3bbb3f21-3c53-4e67-afe5-755aeb222159.png" width="280"/>
  </picture>
  </a>
</div>

# Novu Providers

[![Version](https://img.shields.io/npm/v/@novu/providers.svg)](https://www.npmjs.org/package/@novu/providers)
[![Downloads](https://img.shields.io/npm/dm/@novu/providers.svg)](https://www.npmjs.com/package/@novu/providers)

A collection of stateless notification delivery providers, abstracting the underlying delivery provider implementation details. Independently usable, and additionally consumed by the [Novu Platform](https://novu.co/).

## Installation

```bash
npm install @novu/providers
```

## Usage

The `@novu/providers` package contains a set of providers that can be used to send notifications to various channels.

The following example shows how to use the TwilioSmsProvider to send a message to a phone number.

```javascript
import { TwilioSmsProvider } from '@novu/providers';

const provider = new TwilioSmsProvider({
  accountSid: process.env.TWILIO_ACCOUNT_SID,
  authToken: process.env.TWILIO_AUTH_TOKEN,
  from: process.env.TWILIO_FROM_NUMBER, // a valid twilio phone number
});

await provider.sendMessage({
  to: '0123456789',
  content: 'Message to send',
});
```

For all supported providers, visit the [Novu Providers package](https://github.com/novuhq/novu/tree/next/packages/providers/src/lib).


### ANALISIS AUTOMATICO (ESPAÑOL) ###

<div align="center">
<a href="https://novu.co?utm_source=github" target="_blank">
<picture>
<source media="(prefers-color-scheme: dark)" srcset="https://user-images.githubusercontent.com/2233092/213641039-220ac15f-f367-4d13-9eaf-56e79433b8c1.png">
<img alt="Novu Logo" src="https://user-images.githubusercontent.com/2233092/213641043-3bbb3f21-3c53-4e67-afe5-755aeb222159.png" width="280"/>
# Novu Providers
## Installation
Contiene declaraciones 'import' (posible Python u otro).

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/providers/package.json
Tamaño: 2894 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "name": "@novu/providers",
  "version": "2.6.6",
  "description": "Novu Provider Wrappers",
  "main": "dist/cjs/index.js",
  "module": "dist/esm/index.js",
  "types": "dist/cjs/index.d.ts",
  "files": [
    "dist/",
    "!**/*.spec.*",
    "!**/*.json",
    "CHANGELOG.md",
    "LICENSE",
    "README.md"
  ],
  "repository": "https://github.com/novuhq/novu",
  "license": "MIT",
  "keywords": [],
  "scripts": {
    "start": "npm run watch:build",
    "prebuild": "rimraf build",
    "build": "npm run build:cjs && npm run build:esm",
    "build:esm": "tsc -p tsconfig.esm.json",
    "build:cjs": "tsc -p tsconfig.json",
    "check": "biome check .",
    "check:fix": "biome check --write .",
    "test": "vitest",
    "watch:build": "tsc -p tsconfig.json -w",
    "watch:test": "vitest",
    "reset-hard": "git clean -dfx && git reset --hard && yarn",
    "prepare-release": "run-s reset-hard test"
  },
  "publishConfig": {
    "access": "public"
  },
  "dependencies": {
    "@aws-sdk/client-ses": "3.382.0",
    "@aws-sdk/client-sns": "^3.382.0",
    "@azure/communication-sms": "^1.0.0",
    "@bandwidth/messaging": "^4.1.3",
    "@infobip-api/sdk": "^0.3.2",
    "@mailchimp/mailchimp_transactional": "^1.0.59",
    "@novu/shared": "workspace:*",
    "@novu/stateless": "workspace:*",
    "@parse/node-apn": "^5.2.3",
    "@plunk/node": "2.0.0",
    "@ringcentral/sdk": "^5.0.1",
    "@sendgrid/client": "^8.1.0",
    "@sendgrid/eventwebhook": "^8.0.0",
    "@sendgrid/mail": "^8.1.0",
    "@vonage/auth": "^1.7.0",
    "@vonage/server-sdk": "^3.10.0",
    "africastalking": "^0.6.2",
    "axios": "^1.9.0",
    "braze-api": "^2.5.6",
    "cross-fetch": "^4.0.0",
    "date-fns": "2.29.3",
    "emailjs": "^4.0.3",
    "expo-server-sdk": "^3.6.0",
    "firebase-admin": "^13.3.0",
    "form-data": "^4.0.0",
    "mailersend": "^1.3.1",
    "mailgun.js": "^8.0.1",
    "mailtrap": "^3.1.1",
    "messagebird": "^4.0.1",
    "nanoid": "^3.1.20",
    "node-fetch": "^3.2.10",
    "node-mailjet": "^6.0.8",
    "nodemailer": "^6.6.5",
    "plivo": "^4.70.0",
    "postmark": "^4.0.2",
    "proxy-agent": "^6.3.1",
    "pushpad": "1.0.0",
    "qs": "^6.11.0",
    "resend": "^6.0.3",
    "sms77-client": "^2.14.0",
    "svix": "^1.29.0",
    "telnyx": "^1.23.0",
    "twilio": "^4.19.3",
    "uuid": "^9.0.0"
  },
  "devDependencies": {
    "@babel/preset-env": "^7.23.2",
    "@babel/preset-typescript": "^7.13.0",
    "@types/node-mailjet": "^4.0.0",
    "@types/nodemailer": "^6.4.4",
    "@types/sparkpost": "^2.1.5",
    "@types/uuid": "^8.3.4",
    "codecov": "^3.5.0",
    "cspell": "~6.19.2",
    "nock": "^13.1.3",
    "npm-run-all": "^4.1.5",
    "open-cli": "^6.0.1",
    "rimraf": "~3.0.2",
    "ts-node": "~10.9.1",
    "typedoc": "^0.24.0",
    "typescript": "5.6.2",
    "uuid": "^9.0.0",
    "vitest": "2.1.9"
  },
  "nx": {
    "tags": [
      "type:package"
    ]
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"name": "@novu/providers",
"version": "2.6.6",
"description": "Novu Provider Wrappers",
"main": "dist/cjs/index.js",
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/providers/project.json
Tamaño: 261 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "name": "@novu/providers",
  "sourceRoot": "packages/providers/src",
  "projectType": "library",
  "targets": {
    "lint": {
      "executor": "nx:run-commands",
      "options": {
        "command": "npx biome lint packages/providers"
      }
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"name": "@novu/providers",
"sourceRoot": "packages/providers/src",
"projectType": "library",
"targets": {
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/providers/tsconfig.esm.json
Tamaño: 149 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "ESNext",
    "moduleResolution": "bundler",
    "outDir": "./dist/esm"
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"extends": "./tsconfig.json",
"compilerOptions": {
"module": "ESNext",
"moduleResolution": "bundler",
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/providers/tsconfig.json
Tamaño: 861 bytes
Lenguaje detectado: JSON

### CONTENIDO ORIGINAL ###

{
  "compilerOptions": {
    "allowSyntheticDefaultImports": true,
    "composite": true,
    "declaration": true,
    "declarationMap": true,
    "esModuleInterop": true,
    "isolatedModules": true,
    "lib": ["ES2021", "DOM", "DOM.Iterable"],
    "module": "nodenext",
    "moduleDetection": "force",
    "moduleResolution": "nodenext",
    "noImplicitOverride": true,
    "noUncheckedIndexedAccess": true,
    "outDir": "./dist/cjs",
    "resolveJsonModule": true,
    "rootDir": "./src",
    "skipLibCheck": true,
    "skipDefaultLibCheck": true,
    "sourceMap": true,
    // TODO: Enforce strictness across this package
    "strict": false,
    "strictPropertyInitialization": false,
    "target": "ES2021",
    "verbatimModuleSyntax": false
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "**/node_modules/**", "../../node_modules/**"]
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

{
"compilerOptions": {
"allowSyntheticDefaultImports": true,
"composite": true,
"declaration": true,
No se detectaron dependencias obvias en el texto.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Añade un README describiendo qué hace este archivo.
- Si es parte de un proyecto, indica dependencia y punto de entrada.



################################################################################
Archivo: novu-next/packages/providers/vitest.config.js
Tamaño: 223 bytes
Lenguaje detectado: JavaScript

### CONTENIDO ORIGINAL ###

import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    exclude: ['node_modules', 'dist'],
    typecheck: {
      tsconfig: './tsconfig.esm.json',
    },
  },
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export default  defineConfig

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/base.provider.ts
Tamaño: 4437 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { camelCase, constantCase, kebabCase, pascalCase, snakeCase } from './utils/change-case';
import { deepMerge } from './utils/deepmerge.utils';
import { Passthrough, WithPassthrough } from './utils/types';

export enum CasingEnum {
  CAMEL_CASE = 'camelCase',
  PASCAL_CASE = 'PascalCase',
  SNAKE_CASE = 'snake_case',
  KEBAB_CASE = 'kebab-case',
  CONSTANT_CASE = 'CONSTANT_CASE',
}

type MergedPassthrough<T> = {
  body: T;
  headers: Record<string, string>;
  query: Record<string, string>;
};

export abstract class BaseProvider {
  /**
   * The casing of the provider API. This is used to transform the @novu/framework provider data from
   * a language-preferred casing to the casing required by the provider.
   *
   * The currently supported casings are:
   * - camelCase
   * - PascalCase
   * - snake_case
   * - kebab-case
   * - CONSTANT_CASE
   */
  protected abstract casing: CasingEnum;

  /**
   * A mapping of keys to their desired casing. This mapping should be
   * defined for providers that have inconsistent casing for the API data.
   */
  protected keyCaseObject: Record<string, string> = {};

  /**
   * Transforms the provider data to the desired casing matching the casing
   * required by the provider. Depending on the provider implementation, the
   * required casing may be different the the API data if the provider implements
   * casing transformation of the SDK data to the API data. Twilio's API is an
   * example of this, where the SDK data is in camelCase but the API data is in
   * PascalCase.
   *
   * @param bridgeProviderData The provider data to transform.
   * @param triggerProviderData The trigger data to transform.
   * @returns The transformed provider data.
   */
  protected transform<
    T_Output = Record<string, unknown>,
    T_Input = Record<string, unknown>,
    T_Data = Record<string, unknown>,
  >(bridgeProviderData: WithPassthrough<T_Input>, triggerProviderData: T_Data): MergedPassthrough<T_Output> {
    const { _passthrough = {}, ...bridgeData } = bridgeProviderData;

    // Construct the trigger data passthrough object
    const triggerDataPassthrough: Passthrough = {
      body: triggerProviderData as Record<string, unknown>,
      headers: {},
      query: {},
    };

    // Transform the known provider data to the desired casing
    const brideKnownDataPassthrough: Passthrough = {
      body: this.casingTransform(bridgeData),
      headers: {},
      query: {},
    };

    // Transform the unknown provider data to the desired casing
    const bridgeUnknownDataPassthrough: Passthrough = {
      body: _passthrough.body || {},
      headers: _passthrough.headers || {},
      query: _passthrough.query || {},
    };

    /**
     * Merge the provider data with the following priority, from lowest to highest:
     * 1. Trigger provider data (provided via Events API)
     * 2. Bridge known data (provided via known schematized values)
     * 3. Unknown provider data (provided via `_passthrough`)
     */
    const mergedPassthrough = deepMerge([
      triggerDataPassthrough,
      brideKnownDataPassthrough,
      bridgeUnknownDataPassthrough,
    ]) as MergedPassthrough<T_Output>;

    return mergedPassthrough;
  }

  /**
   * Return the custom key to use for the given key, if it exists in `keyCaseObject`.
   * @param key The key to transform.
   * @returns The transformed key.
   */
  private keyCaseTransformer(key: string) {
    return this.keyCaseObject[key] ? this.keyCaseObject[key] : key;
  }

  /**
   * Transforms the keys of the data to the desired casing.
   * @param data The data to transform.
   * @returns The transformed data, with the keys transformed to the desired casing.
   */
  private casingTransform(data: Record<string, unknown>): Record<string, unknown> {
    let casing = camelCase;

    switch (this.casing) {
      case CasingEnum.PASCAL_CASE:
        casing = pascalCase;
        break;
      case CasingEnum.SNAKE_CASE:
        casing = snakeCase;
        break;
      case CasingEnum.KEBAB_CASE:
        casing = kebabCase;
        break;
      case CasingEnum.CONSTANT_CASE:
        casing = constantCase;
        break;
      case CasingEnum.CAMEL_CASE:
        casing = camelCase;
        break;
      default:
        throw new Error(`Unknown casing: ${this.casing}`);
    }

    return casing(data, {
      keyCaseTransformer: this.keyCaseTransformer.bind(this),
    }) as Record<string, unknown>;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  enum
- export  abstract

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/index.ts
Tamaño: 29 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './lib/index';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/index.ts
Tamaño: 96 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './chat';
export * from './email';
export * from './push';
export * from './sms';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/chat/index.ts
Tamaño: 536 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './chat-webhook/chat-webhook.provider';
export * from './discord/discord.provider';
export * from './getstream/getstream.provider';
export * from './grafana-on-call/grafana-on-call.provider';
export * from './mattermost/mattermost.provider';
export * from './msTeams/msTeams.provider';
export * from './rocket-chat/rocket-chat.provider';
export * from './ryver/ryver.provider';
export * from './slack/slack.provider';
export * from './whatsapp-business/whatsapp-business.provider';
export * from './zulip/zulip.provider';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/chat/chat-webhook/chat-webhook.provider.ts
Tamaño: 2266 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChatProviderIdEnum } from '@novu/shared';
import {
  ChannelTypeEnum,
  ENDPOINT_TYPES,
  IChatOptions,
  IChatProvider,
  ISendMessageSuccessResponse,
  isChannelDataOfType,
} from '@novu/stateless';
import axios from 'axios';
import crypto from 'crypto';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class ChatWebhookProvider extends BaseProvider implements IChatProvider {
  protected casing: CasingEnum = CasingEnum.CAMEL_CASE;
  readonly id = ChatProviderIdEnum.ChatWebhook;
  channelType = ChannelTypeEnum.CHAT as ChannelTypeEnum.CHAT;

  constructor(
    private config: {
      hmacSecretKey?: string;
    }
  ) {
    super();
  }

  async sendMessage(
    options: IChatOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    if (!isChannelDataOfType(options.channelData, ENDPOINT_TYPES.WEBHOOK)) {
      throw new Error('Invalid channel data for ChatWebhook provider');
    }

    const { content, channelData, phoneNumber } = options;
    const { endpoint } = channelData;

    const data = this.transform(bridgeProviderData, {
      content,
      webhookUrl: endpoint.url,
      channel: endpoint.channel,
      phoneNumber,
    });
    const body = this.createBody(data.body);

    const hmacSecretKey = (data.body.hmacSecretKey as string) || this.config.hmacSecretKey;
    const hmacValue = this.computeHmac(body, hmacSecretKey);

    if (data.body.hmacSecretKey as string) {
      delete data.body.hmacSecretKey;
    }

    const response = await axios.create().post((data?.body?.webhookUrl as string) || endpoint.url, body, {
      headers: {
        'content-type': 'application/json',
        'X-Novu-Signature': hmacValue,
        ...data.headers,
      },
    });

    return {
      id: response.data.id,
      date: new Date().toDateString(),
    };
  }

  createBody(options: object): string {
    return JSON.stringify(options);
  }

  computeHmac(payload: string, hmacSecretKey?: string): string {
    const secretKey = hmacSecretKey;
    if (!secretKey) {
      return;
    }

    return crypto.createHmac('sha256', secretKey).update(payload, 'utf-8').digest('hex');
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ChatWebhookProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/chat/discord/discord.provider.spec.ts
Tamaño: 1707 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ENDPOINT_TYPES } from '@novu/shared';
import { expect, test, vi } from 'vitest';
import { axiosSpy } from '../../../utils/test/spy-axios';
import { DiscordProvider } from './discord.provider';

test('should trigger Discord provider correctly', async () => {
  const provider = new DiscordProvider({});
  const spy = vi.spyOn(provider, 'sendMessage').mockImplementation(async () => {
    return {
      dateCreated: new Date(),
    } as any;
  });

  await provider.sendMessage({
    channelData: {
      endpoint: {
        url: 'webhookUrl',
      },
      type: ENDPOINT_TYPES.WEBHOOK,
      identifier: 'test-webhook-identifier',
    },
    content: 'chat message',
  });

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    channelData: {
      endpoint: {
        url: 'webhookUrl',
      },
      type: ENDPOINT_TYPES.WEBHOOK,
      identifier: 'test-webhook-identifier',
    },
    content: 'chat message',
  });
});

test('should trigger Discord provider correctly with _passthrough', async () => {
  const { mockPost } = axiosSpy({
    data: {
      id: 'id',
      timestamp: new Date().toISOString(),
    },
  });
  const provider = new DiscordProvider({});

  await provider.sendMessage(
    {
      channelData: {
        endpoint: {
          url: 'https://www.google.com/',
        },
        type: ENDPOINT_TYPES.WEBHOOK,
        identifier: 'test-webhook-identifier',
      },
      content: 'chat message',
    },
    {
      _passthrough: {
        body: {
          content: 'passthrough content',
        },
      },
    }
  );

  expect(mockPost).toHaveBeenCalledWith('https://www.google.com/?wait=true', {
    content: 'passthrough content',
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - spy(vi.spyOn(provider, 'sendMessage').mockImplementation(async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/chat/discord/discord.provider.ts
Tamaño: 1488 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChatProviderIdEnum } from '@novu/shared';
import {
  ChannelTypeEnum,
  ENDPOINT_TYPES,
  IChatOptions,
  IChatProvider,
  ISendMessageSuccessResponse,
  isChannelDataOfType,
} from '@novu/stateless';
import axios from 'axios';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class DiscordProvider extends BaseProvider implements IChatProvider {
  protected casing = CasingEnum.CAMEL_CASE;
  channelType = ChannelTypeEnum.CHAT as ChannelTypeEnum.CHAT;
  public id = ChatProviderIdEnum.Discord;
  private axiosInstance = axios.create();

  constructor(private config) {
    super();
  }

  async sendMessage(
    data: IChatOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    // Setting the wait parameter with the URL API to respect user parameters
    if (!isChannelDataOfType(data.channelData, ENDPOINT_TYPES.WEBHOOK)) {
      throw new Error('Invalid channel data for Discord provider');
    }

    const { endpoint } = data.channelData;

    const url = new URL(endpoint.url);

    url.searchParams.set('wait', 'true');
    const response = await this.axiosInstance.post(
      url.toString(),
      this.transform(bridgeProviderData, {
        content: data.content,
        ...(data.customData || {}),
      }).body
    );

    return {
      id: response.data.id,
      date: response.data.timestamp,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DiscordProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/chat/getstream/getstream.provider.spec.ts
Tamaño: 1879 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ENDPOINT_TYPES } from '@novu/stateless';
import { expect, test, vi } from 'vitest';
import { axiosSpy } from '../../../utils/test/spy-axios';
import { GetstreamChatProvider } from './getstream.provider';

test('should trigger getstream correctly', async () => {
  const config = { apiKey: 'test' };

  const provider = new GetstreamChatProvider(config);
  const spy = vi.spyOn(provider, 'sendMessage').mockImplementation(async () => {
    return {
      dateCreated: new Date(),
    } as any;
  });

  await provider.sendMessage({
    channelData: {
      endpoint: {
        url: 'webhookUrl',
      },
      type: ENDPOINT_TYPES.WEBHOOK,
      identifier: 'test-webhook-identifier',
    },
    content: 'chat message',
  });

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    channelData: {
      endpoint: {
        url: 'webhookUrl',
      },
      type: ENDPOINT_TYPES.WEBHOOK,
      identifier: 'test-webhook-identifier',
    },
    content: 'chat message',
  });
});

test('should trigger getstream correctly with _passthrough', async () => {
  const config = { apiKey: 'test' };

  const { mockPost } = axiosSpy({
    headers: {
      'X-WEBHOOK-ID': 'X-WEBHOOK-ID',
    },
  });

  const provider = new GetstreamChatProvider(config);

  await provider.sendMessage(
    {
      channelData: {
        endpoint: {
          url: 'https://www.google.com/',
        },
        type: ENDPOINT_TYPES.WEBHOOK,
        identifier: 'test-webhook-identifier',
      },
      content: 'chat message',
    },
    {
      _passthrough: {
        body: {
          text: 'passthrough message',
        },
        headers: {
          'X-API-KEY': 'test1',
        },
      },
    }
  );

  expect(mockPost).toHaveBeenCalledWith('https://www.google.com/', {
    headers: {
      'X-API-KEY': 'test1',
    },
    text: 'passthrough message',
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - spy(vi.spyOn(provider, 'sendMessage').mockImplementation(async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/chat/getstream/getstream.provider.ts
Tamaño: 1516 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChatProviderIdEnum } from '@novu/shared';
import {
  ChannelTypeEnum,
  ENDPOINT_TYPES,
  IChatOptions,
  IChatProvider,
  ISendMessageSuccessResponse,
  isChannelDataOfType,
} from '@novu/stateless';
import axios from 'axios';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class GetstreamChatProvider extends BaseProvider implements IChatProvider {
  id = ChatProviderIdEnum.GetStream;
  channelType = ChannelTypeEnum.CHAT as ChannelTypeEnum.CHAT;
  protected casing = CasingEnum.SNAKE_CASE;
  private axiosInstance = axios.create();

  constructor(
    private config: {
      apiKey: string;
    }
  ) {
    super();
    this.config = config;
  }

  async sendMessage(
    data: IChatOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    if (!isChannelDataOfType(data.channelData, ENDPOINT_TYPES.WEBHOOK)) {
      throw new Error('Invalid channel data for Getstream provider');
    }

    const { endpoint } = data.channelData;

    const transformedData = this.transform(bridgeProviderData, {
      text: data.content,
    });
    const response = await this.axiosInstance.post(endpoint.url, {
      ...transformedData.body,
      headers: {
        'X-API-KEY': this.config.apiKey,
        ...transformedData.headers,
      },
    });

    return {
      id: response.headers['X-WEBHOOK-ID'],
      date: new Date().toISOString(),
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetstreamChatProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/chat/grafana-on-call/grafana-on-call.provider.spec.ts
Tamaño: 2602 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ENDPOINT_TYPES } from '@novu/stateless';
import { expect, test } from 'vitest';
import { axiosSpy } from '../../../utils/test/spy-axios';
import { GrafanaOnCallChatProvider } from './grafana-on-call.provider';

test('should trigger grafana-on-call library correctly', async () => {
  const date = new Date();

  const { mockPost } = axiosSpy({
    headers: { Date: date },
  });

  const provider = new GrafanaOnCallChatProvider({
    alertUid: '123',
    externalLink: 'link',
    imageUrl: 'url',
    state: 'ok',
    title: 'title',
  });

  const testWebhookUrl = 'https://mycompany.webhook.grafana.com/';
  const testContent = 'warning!!';
  const res = await provider.sendMessage({
    channelData: {
      endpoint: {
        url: testWebhookUrl,
      },
      type: ENDPOINT_TYPES.WEBHOOK,
      identifier: 'test-webhook-identifier',
    },
    content: testContent,
  });

  expect(mockPost).toHaveBeenCalled();
  expect(mockPost).toHaveBeenCalledWith(
    testWebhookUrl,
    {
      alert_uid: '123',
      link_to_upstream_details: 'link',
      image_url: 'url',
      state: 'ok',
      title: 'title',
      message: testContent,
    },
    undefined
  );
  expect(res).toEqual({ id: expect.any(String), date: date.toISOString() });
});

test('should trigger grafana-on-call library correctly with _passthrough', async () => {
  const date = new Date();

  const { mockPost } = axiosSpy({
    headers: { Date: date },
  });

  const provider = new GrafanaOnCallChatProvider({
    alertUid: '123',
    externalLink: 'link',
    imageUrl: 'url',
    state: 'ok',
    title: 'title',
  });

  const testWebhookUrl = 'https://mycompany.webhook.grafana.com/';
  const testContent = 'warning!!';
  const res = await provider.sendMessage(
    {
      channelData: {
        endpoint: {
          url: testWebhookUrl,
        },
        type: ENDPOINT_TYPES.WEBHOOK,
        identifier: 'test-webhook-identifier',
      },
      content: testContent,
    },
    {
      _passthrough: {
        body: {
          message: 'passthrough',
        },
        headers: {
          'Content-Type': 'application/json',
        },
      },
    }
  );

  expect(mockPost).toHaveBeenCalled();
  expect(mockPost).toHaveBeenCalledWith(
    testWebhookUrl,
    {
      alert_uid: '123',
      link_to_upstream_details: 'link',
      image_url: 'url',
      state: 'ok',
      title: 'title',
      message: 'passthrough',
    },
    {
      headers: {
        'Content-Type': 'application/json',
      },
    }
  );
  expect(res).toEqual({ id: expect.any(String), date: date.toISOString() });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - res(await provider.sendMessage({
    channelData: {
      endpoint: {
        url: testWebhookUrl,
     ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/chat/grafana-on-call/grafana-on-call.provider.ts
Tamaño: 2026 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChatProviderIdEnum } from '@novu/shared';
import {
  ChannelTypeEnum,
  ENDPOINT_TYPES,
  IChatOptions,
  IChatProvider,
  ISendMessageSuccessResponse,
  isChannelDataOfType,
} from '@novu/stateless';
import axios from 'axios';
import { v4 as uuid } from 'uuid';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class GrafanaOnCallChatProvider extends BaseProvider implements IChatProvider {
  id = ChatProviderIdEnum.GrafanaOnCall;
  channelType = ChannelTypeEnum.CHAT as ChannelTypeEnum.CHAT;
  protected casing = CasingEnum.SNAKE_CASE;
  private axiosInstance = axios.create();
  constructor(
    private config: {
      alertUid?: string;
      title?: string;
      imageUrl?: string;
      state?: string;
      externalLink?: string;
    }
  ) {
    super();
  }

  async sendMessage(
    options: IChatOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    if (!isChannelDataOfType(options.channelData, ENDPOINT_TYPES.WEBHOOK)) {
      throw new Error('Invalid channel data for GrafanaOnCall provider');
    }

    const { endpoint } = options.channelData;

    const url = new URL(endpoint.url);
    const data = this.transform(bridgeProviderData, {
      alert_uid: this.config.alertUid,
      title: this.config.title,
      image_url: this.config.imageUrl,
      state: this.config.state,
      link_to_upstream_details: this.config.externalLink,
      message: options.content,
    });

    const hasHeaders = data.headers && Object.keys(data.headers).length > 0;

    // response is just string "Ok."
    const { headers } = await this.axiosInstance.post(
      url.toString(),
      data.body,
      hasHeaders
        ? {
            headers: data.headers as Record<string, string>,
          }
        : undefined
    );

    return {
      id: uuid(),
      date: (headers.Date ? new Date(headers.Date) : new Date()).toISOString(),
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GrafanaOnCallChatProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/chat/mattermost/mattermost.provider.spec.ts
Tamaño: 3360 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ENDPOINT_TYPES } from '@novu/stateless';
import axios from 'axios';
import { expect, test, vi } from 'vitest';
import { MattermostProvider } from './mattermost.provider';

test('should trigger mattermost library correctly, default channel', async () => {
  const fakePostDefaultChannel = vi.fn((webhookUrl, payload) => {
    expect(payload.channel).toBe(undefined);

    return { headers: { 'x-request-id': 'default' } };
  });
  vi.spyOn(axios, 'create').mockImplementation(() => {
    return {
      post: fakePostDefaultChannel,
    } as any;
  });

  const provider = new MattermostProvider();
  const testWebhookUrl = 'https://mattermost.dummy.webhook.com';
  const testContent = 'Dummy content message';
  const result = await provider.sendMessage({
    channelData: {
      endpoint: {
        url: testWebhookUrl,
      },
      type: ENDPOINT_TYPES.WEBHOOK,
      identifier: 'test-webhook-identifier',
    },
    content: testContent,
  });
  expect(fakePostDefaultChannel).toHaveBeenCalled();
  expect(fakePostDefaultChannel).toHaveBeenCalledWith(testWebhookUrl, {
    text: 'Dummy content message',
  });
  expect(result.id).toBe('default');
});

test('should trigger mattermost library correctly, override channel', async () => {
  const fakePostUserChannel = vi.fn((webhookUrl, payload) => {
    expect(payload.channel).toBe('@username');

    return { headers: { 'x-request-id': 'username' } };
  });
  vi.spyOn(axios, 'create').mockImplementation(() => {
    return {
      post: fakePostUserChannel,
    } as any;
  });

  const provider = new MattermostProvider();
  const testWebhookUrl = 'https://mattermost.dummy.webhook.com';
  const testContent = 'Dummy content message';
  const result = await provider.sendMessage({
    channelData: {
      endpoint: {
        url: testWebhookUrl,
        channel: '@username',
      },
      type: ENDPOINT_TYPES.WEBHOOK,
      identifier: 'test-webhook-identifier',
    },
    content: testContent,
  });
  expect(fakePostUserChannel).toHaveBeenCalled();
  expect(fakePostUserChannel).toHaveBeenCalledWith(testWebhookUrl, {
    channel: '@username',
    text: 'Dummy content message',
  });
  expect(result.id).toBe('username');
});

test('should trigger mattermost library correctly, default channel with _passthrough', async () => {
  const fakePostDefaultChannel = vi.fn((webhookUrl, payload) => {
    expect(payload.channel).toBe(undefined);

    return { headers: { 'x-request-id': 'default' } };
  });
  vi.spyOn(axios, 'create').mockImplementation(() => {
    return {
      post: fakePostDefaultChannel,
    } as any;
  });

  const provider = new MattermostProvider();
  const testWebhookUrl = 'https://mattermost.dummy.webhook.com';
  const testContent = 'Dummy content message';
  const result = await provider.sendMessage(
    {
      channelData: {
        endpoint: {
          url: testWebhookUrl,
        },
        type: ENDPOINT_TYPES.WEBHOOK,
        identifier: 'test-webhook-identifier',
      },
      content: testContent,
    },
    {
      _passthrough: {
        body: {
          text: '_passthrough content message',
        },
      },
    }
  );
  expect(fakePostDefaultChannel).toHaveBeenCalled();
  expect(fakePostDefaultChannel).toHaveBeenCalledWith(testWebhookUrl, {
    text: '_passthrough content message',
  });
  expect(result.id).toBe('default');
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - fakePostDefaultChannel(vi.fn((webhookUrl, payload))
 - result(await provider.sendMessage({
    channelData: {
      endpoint: {
        url: testWebhookUrl,
     ...)
 - fakePostUserChannel(vi.fn((webhookUrl, payload))
 - result(await provider.sendMessage({
    channelData: {
      endpoint: {
        url: testWebhookUrl,
     ...)
 - fakePostDefaultChannel(vi.fn((webhookUrl, payload))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/chat/mattermost/mattermost.provider.ts
Tamaño: 1434 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChatProviderIdEnum } from '@novu/shared';
import {
  ChannelTypeEnum,
  ENDPOINT_TYPES,
  IChatOptions,
  IChatProvider,
  ISendMessageSuccessResponse,
  isChannelDataOfType,
} from '@novu/stateless';
import axios from 'axios';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

interface IMattermostPayload {
  channel?: string;
  text: string;
}

export class MattermostProvider extends BaseProvider implements IChatProvider {
  channelType = ChannelTypeEnum.CHAT as ChannelTypeEnum.CHAT;
  public id = ChatProviderIdEnum.Mattermost;
  protected casing: CasingEnum = CasingEnum.SNAKE_CASE;
  private axiosInstance = axios.create();

  async sendMessage(
    data: IChatOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    if (!isChannelDataOfType(data.channelData, ENDPOINT_TYPES.WEBHOOK)) {
      throw new Error('Invalid channel data for Mattermost provider');
    }

    const payload: IMattermostPayload = { text: data.content };
    const { endpoint } = data.channelData;

    if (endpoint.channel) {
      payload.channel = endpoint.channel;
    }
    const response = await this.axiosInstance.post(endpoint.url, this.transform(bridgeProviderData, payload).body);

    return {
      id: response.headers['x-request-id'],
      date: response.headers.date,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class MattermostProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/chat/msTeams/msTeams.provider.spec.ts
Tamaño: 1782 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ENDPOINT_TYPES } from '@novu/stateless';
import { v4 as uuidv4 } from 'uuid';
import { expect, test } from 'vitest';
import { axiosSpy } from '../../../utils/test/spy-axios';
import { MsTeamsProvider } from './msTeams.provider';

test('should trigger msTeams webhook correctly', async () => {
  const { mockPost: fakePost } = axiosSpy({
    headers: { 'request-id': uuidv4() },
  });

  const provider = new MsTeamsProvider({});

  const testWebhookUrl = 'https://mycompany.webhook.office.com';
  const testContent = '{"title": "Message test title"}';
  await provider.sendMessage({
    channelData: {
      endpoint: {
        url: testWebhookUrl,
      },
      type: ENDPOINT_TYPES.WEBHOOK,
      identifier: 'test-webhook-identifier',
    },
    content: testContent,
  });

  expect(fakePost).toHaveBeenCalled();
  expect(fakePost).toHaveBeenCalledWith(testWebhookUrl, {
    title: 'Message test title',
  });
});

test('should trigger msTeams webhook correctly with _passthrough', async () => {
  const { mockPost: fakePost } = axiosSpy({
    headers: { 'request-id': uuidv4() },
  });

  const provider = new MsTeamsProvider({});

  const testWebhookUrl = 'https://mycompany.webhook.office.com';
  const testContent = '{"title": "Message test title"}';
  await provider.sendMessage(
    {
      channelData: {
        endpoint: {
          url: testWebhookUrl,
        },
        type: ENDPOINT_TYPES.WEBHOOK,
        identifier: 'test-webhook-identifier',
      },
      content: testContent,
    },
    {
      _passthrough: {
        body: {
          title: '_passthrough test title',
        },
      },
    }
  );

  expect(fakePost).toHaveBeenCalled();
  expect(fakePost).toHaveBeenCalledWith(testWebhookUrl, {
    title: '_passthrough test title',
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - testContent('{"title": "Message test title"}';
  await provider.sendMessage({
    channelData: {
      endpoint:...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/chat/msTeams/msTeams.provider.ts
Tamaño: 1433 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChatProviderIdEnum } from '@novu/shared';
import {
  ChannelTypeEnum,
  ENDPOINT_TYPES,
  IChatOptions,
  IChatProvider,
  ISendMessageSuccessResponse,
  isChannelDataOfType,
} from '@novu/stateless';
import axios from 'axios';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class MsTeamsProvider extends BaseProvider implements IChatProvider {
  channelType = ChannelTypeEnum.CHAT as ChannelTypeEnum.CHAT;
  public id = ChatProviderIdEnum.MsTeams;
  protected casing: CasingEnum = CasingEnum.CAMEL_CASE;
  private axiosInstance = axios.create();

  constructor(private config) {
    super();
  }

  async sendMessage(
    data: IChatOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    if (!isChannelDataOfType(data.channelData, ENDPOINT_TYPES.WEBHOOK)) {
      throw new Error('Invalid channel data for MsTeams provider');
    }

    const { endpoint } = data.channelData;
    let payload;

    try {
      payload = { ...JSON.parse(data.content) };
    } catch (err) {
      payload = { text: data.content };
    }

    payload = this.transform(bridgeProviderData, payload).body;

    const response = await this.axiosInstance.post(endpoint.url, payload);

    return {
      id: response.headers['request-id'],
      date: new Date().toISOString(),
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class MsTeamsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/chat/rocket-chat/rocket-chat.provider.spec.ts
Tamaño: 2441 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ENDPOINT_TYPES } from '@novu/stateless';
import { expect, test } from 'vitest';
import { axiosSpy } from '../../../utils/test/spy-axios';
import { RocketChatProvider } from './rocket-chat.provider';

test('should trigger rocket-chat library correctly', async () => {
  const mockConfig = {
    user: '<your-user>',
    token: '<your-auth-token>',
  };
  const { mockPost } = axiosSpy({
    data: {
      message: {
        _id: 'id',
        ts: new Date().toISOString(),
      },
    },
  });
  const provider = new RocketChatProvider(mockConfig);

  await provider.sendMessage({
    channelData: {
      endpoint: {
        url: '<your-root-url>',
        channel: '<your-channel>',
      },
      type: ENDPOINT_TYPES.WEBHOOK,
      identifier: 'test-webhook-identifier',
    },
    content: '<your-chat-message>',
  });

  expect(mockPost).toHaveBeenCalledWith(
    '<your-root-url>/api/v1/chat.sendMessage',
    {
      message: {
        msg: '<your-chat-message>',
        rid: '<your-channel>',
      },
    },
    {
      headers: {
        'Content-Type': 'application/json',
        'x-auth-token': '<your-auth-token>',
        'x-user-id': '<your-user>',
      },
    }
  );
});

test('should trigger rocket-chat library correctly with _passthrough', async () => {
  const mockConfig = {
    user: '<your-user>',
    token: '<your-auth-token>',
  };
  const { mockPost } = axiosSpy({
    data: {
      message: {
        _id: 'id',
        ts: new Date().toISOString(),
      },
    },
  });
  const provider = new RocketChatProvider(mockConfig);

  await provider.sendMessage(
    {
      channelData: {
        endpoint: {
          url: '<your-root-url>',
          channel: '<your-channel>',
        },
        type: ENDPOINT_TYPES.WEBHOOK,
        identifier: 'test-webhook-identifier',
      },
      content: '<your-chat-message>',
    },
    {
      _passthrough: {
        body: {
          message: {
            rid: '_passthrough',
          },
        },
        headers: {
          'x-auth-token': '_passthrough',
        },
      },
    }
  );

  expect(mockPost).toHaveBeenCalledWith(
    '<your-root-url>/api/v1/chat.sendMessage',
    {
      message: {
        msg: '<your-chat-message>',
        rid: '_passthrough',
      },
    },
    {
      headers: {
        'Content-Type': 'application/json',
        'x-auth-token': '_passthrough',
        'x-user-id': '<your-user>',
      },
    }
  );
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - provider(new RocketChatProvider(mockConfig);

  await provider.sendMessage({
    channelData: {
      endpoin...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/chat/rocket-chat/rocket-chat.provider.ts
Tamaño: 1784 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChatProviderIdEnum } from '@novu/shared';
import {
  ChannelTypeEnum,
  ENDPOINT_TYPES,
  IChatOptions,
  IChatProvider,
  ISendMessageSuccessResponse,
  isChannelDataOfType,
} from '@novu/stateless';
import axios from 'axios';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class RocketChatProvider extends BaseProvider implements IChatProvider {
  id = ChatProviderIdEnum.RocketChat;
  protected casing: CasingEnum = CasingEnum.SNAKE_CASE;
  channelType = ChannelTypeEnum.CHAT as ChannelTypeEnum.CHAT;
  private axiosInstance = axios.create();

  constructor(
    private config: {
      token: string;
      user: string;
    }
  ) {
    super();
  }

  async sendMessage(
    options: IChatOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const { channelData } = options;

    if (!isChannelDataOfType(channelData, ENDPOINT_TYPES.WEBHOOK)) {
      throw new Error('Invalid channel data for RocketChat provider');
    }

    const roomId = channelData.endpoint.channel;

    const payload = {
      message: {
        rid: roomId,
        msg: options.content,
      },
    };
    const transformedData = this.transform(bridgeProviderData, payload);
    const headers = {
      'x-auth-token': this.config.token,
      'x-user-id': this.config.user,
      'Content-Type': 'application/json',
      ...transformedData.headers,
    };
    const baseURL = `${channelData.endpoint.url.toString()}/api/v1/chat.sendMessage`;
    const { data } = await this.axiosInstance.post(baseURL, transformedData.body, {
      headers,
    });

    return {
      id: data.message._id,
      date: data.message.ts,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RocketChatProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/chat/ryver/ryver.provider.spec.ts
Tamaño: 1419 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ENDPOINT_TYPES } from '@novu/stateless';
import { expect, test } from 'vitest';
import { axiosSpy } from '../../../utils/test/spy-axios';
import { RyverChatProvider } from './ryver.provider';

test('Should trigger ryver correctly', async () => {
  const { mockPost } = axiosSpy({
    data: {
      status: 'test',
    },
  });

  const provider = new RyverChatProvider();

  await provider.sendMessage({
    channelData: {
      endpoint: {
        url: 'https://google.com',
      },
      type: ENDPOINT_TYPES.WEBHOOK,
      identifier: 'test-webhook-identifier',
    },
    content: 'chat message',
  });

  expect(mockPost).toHaveBeenCalledWith('https://google.com/', {
    content: 'chat message',
  });
});

test('Should trigger ryver correctly with _passthrough', async () => {
  const { mockPost } = axiosSpy({
    data: {
      status: 'test',
    },
  });

  const provider = new RyverChatProvider();

  await provider.sendMessage(
    {
      channelData: {
        endpoint: {
          url: 'https://google.com',
        },
        type: ENDPOINT_TYPES.WEBHOOK,
        identifier: 'test-webhook-identifier',
      },
      content: 'chat message',
    },
    {
      _passthrough: {
        body: {
          content: 'chat message _passthrough',
        },
      },
    }
  );

  expect(mockPost).toHaveBeenCalledWith('https://google.com/', {
    content: 'chat message _passthrough',
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - provider(new RyverChatProvider();

  await provider.sendMessage({
    channelData: {
      endpoint: {
      ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/chat/ryver/ryver.provider.ts
Tamaño: 1310 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChatProviderIdEnum } from '@novu/shared';
import {
  ChannelTypeEnum,
  ENDPOINT_TYPES,
  IChatOptions,
  IChatProvider,
  ISendMessageSuccessResponse,
  isChannelDataOfType,
} from '@novu/stateless';
import axios from 'axios';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class RyverChatProvider extends BaseProvider implements IChatProvider {
  public id = ChatProviderIdEnum.Ryver;
  protected casing: CasingEnum = CasingEnum.CAMEL_CASE;
  channelType = ChannelTypeEnum.CHAT as ChannelTypeEnum.CHAT;
  private axiosInstance = axios.create();

  async sendMessage(
    options: IChatOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    if (!isChannelDataOfType(options.channelData, ENDPOINT_TYPES.WEBHOOK)) {
      throw new Error('Invalid channel data for Ryver provider');
    }

    const { channelData } = options;
    const url = new URL(channelData.endpoint.url);
    const response = await this.axiosInstance.post(
      url.toString(),
      this.transform(bridgeProviderData, {
        content: options.content,
      }).body
    );

    return {
      id: `${response.status}`,
      date: new Date().toISOString(),
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RyverChatProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/chat/slack/slack.provider.spec.ts
Tamaño: 4724 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ENDPOINT_TYPES } from '@novu/stateless';
import { expect, test } from 'vitest';
import { axiosSpy } from '../../../utils/test/spy-axios';
import { SlackProvider } from './slack.provider';

test('should trigger Slack webhook correctly', async () => {
  const { mockPost } = axiosSpy({
    data: 'ok', // Webhooks return plain text "ok"
  });

  const provider = new SlackProvider();
  const result = await provider.sendMessage({
    channelData: {
      endpoint: {
        url: 'webhookUrl',
      },
      type: ENDPOINT_TYPES.WEBHOOK,
      identifier: 'test-webhook-identifier',
    },
    content: 'chat message',
  });

  expect(mockPost).toHaveBeenCalledWith('webhookUrl', {
    text: 'chat message',
    blocks: undefined,
  });
  expect(result.id).toBeDefined();
  expect(result.date).toBeDefined();
});

test('should trigger Slack webhook correctly with _passthrough', async () => {
  const { mockPost } = axiosSpy({
    data: 'ok',
  });

  const provider = new SlackProvider();
  const result = await provider.sendMessage(
    {
      channelData: {
        type: ENDPOINT_TYPES.WEBHOOK,
        identifier: 'test-webhook-identifier',
        endpoint: {
          url: 'webhookUrl',
        },
      },
      content: 'chat message',
    },
    {
      _passthrough: {
        body: {
          text: 'chat message _passthrough',
        },
      },
    }
  );

  expect(mockPost).toHaveBeenCalledWith('webhookUrl', {
    text: 'chat message _passthrough',
    blocks: undefined,
  });
  expect(result.id).toBeDefined();
  expect(result.date).toBeDefined();
});

test('should handle Slack API error correctly', async () => {
  const { mockPost } = axiosSpy({
    data: {
      ok: false,
      error: 'channel_not_found',
    },
  });

  const provider = new SlackProvider();

  await expect(
    provider.sendMessage({
      channelData: {
        token: 'xoxb-token-123',
        type: ENDPOINT_TYPES.SLACK_CHANNEL,
        identifier: 'test-slack-channel-identifier',
        endpoint: {
          channelId: 'C1234567890',
        },
      },
      content: 'chat message',
    })
  ).rejects.toThrow('Slack API Error: channel_not_found');

  expect(mockPost).toHaveBeenCalledWith(
    'https://slack.com/api/chat.postMessage',
    {
      text: 'chat message',
      blocks: undefined,
      channel: 'C1234567890',
    },
    {
      headers: {
        'Content-Type': 'application/json',
        Authorization: 'Bearer xoxb-token-123',
      },
    }
  );
});

test('should handle Slack webhook error response correctly', async () => {
  const { mockPost } = axiosSpy({
    data: 'invalid_payload', // Webhook returns error message instead of "ok"
  });

  const provider = new SlackProvider();

  await expect(
    provider.sendMessage({
      channelData: {
        endpoint: {
          url: 'webhookUrl',
        },
        type: ENDPOINT_TYPES.WEBHOOK,
        identifier: 'test-webhook-identifier',
      },
      content: 'chat message',
    })
  ).rejects.toThrow('Slack Webhook Error');

  expect(mockPost).toHaveBeenCalledWith('webhookUrl', {
    text: 'chat message',
    blocks: undefined,
  });
});

test('should handle Slack webhook HTTP error correctly', async () => {
  const { mockPost } = axiosSpy();

  // Simulate axios throwing for HTTP 400 (bad request)
  mockPost.mockRejectedValueOnce(new Error('Request failed with status code 400'));

  const provider = new SlackProvider();

  await expect(
    provider.sendMessage({
      channelData: {
        endpoint: {
          url: 'webhookUrl',
        },
        type: ENDPOINT_TYPES.WEBHOOK,
        identifier: 'test-webhook-identifier',
      },
      content: 'chat message',
    })
  ).rejects.toThrow('Request failed with status code 400');

  expect(mockPost).toHaveBeenCalledWith('webhookUrl', {
    text: 'chat message',
    blocks: undefined,
  });
});

test('should trigger Slack app correctly with OAuth', async () => {
  const { mockPost } = axiosSpy({
    data: {
      ok: true,
      channel: 'C1234567890',
      ts: '1234567890.123456',
    },
  });

  const provider = new SlackProvider();
  await provider.sendMessage({
    channelData: {
      token: 'xoxb-token-123',
      type: ENDPOINT_TYPES.SLACK_CHANNEL,
      identifier: 'test-slack-channel-identifier',
      endpoint: {
        channelId: 'C1234567890',
      },
    },
    content: 'chat message via app',
  });

  expect(mockPost).toHaveBeenCalledWith(
    'https://slack.com/api/chat.postMessage',
    {
      text: 'chat message via app',
      blocks: undefined,
      channel: 'C1234567890',
    },
    {
      headers: {
        'Content-Type': 'application/json',
        Authorization: 'Bearer xoxb-token-123',
      },
    }
  );
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - result(await provider.sendMessage({
    channelData: {
      endpoint: {
        url: 'webhookUrl',
      }...)
 - result(await provider.sendMessage(
    {
      channelData: {
        type: ENDPOINT_TYPES.WEBHOOK,
       ...)
 - provider(new SlackProvider();

  await expect(
    provider.sendMessage({
      channelData: {
        token:...)
 - provider(new SlackProvider();

  await expect(
    provider.sendMessage({
      channelData: {
        endpoi...)
 - provider(new SlackProvider();

  await expect(
    provider.sendMessage({
      channelData: {
        endpoi...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/chat/slack/slack.provider.ts
Tamaño: 3932 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChatProviderIdEnum } from '@novu/shared';
import {
  ChannelData,
  ChannelTypeEnum,
  ENDPOINT_TYPES,
  IChatOptions,
  IChatProvider,
  ISendMessageSuccessResponse,
  SlackChannelData,
  SlackUserData,
  WebhookData,
} from '@novu/stateless';
import axios from 'axios';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class SlackProvider extends BaseProvider implements IChatProvider {
  channelType = ChannelTypeEnum.CHAT as ChannelTypeEnum.CHAT;
  protected casing: CasingEnum = CasingEnum.SNAKE_CASE;
  public id = ChatProviderIdEnum.Slack;
  private slackAPI = 'https://slack.com/api';
  private axiosInstance = axios.create();

  async sendMessage(
    data: IChatOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const response = await this.sendMessageToEndpoint(data, data.channelData, bridgeProviderData);

    if (data.channelData.type === ENDPOINT_TYPES.WEBHOOK) {
      // Webhooks return plain text "ok" for success
      if (response.data !== 'ok') {
        throw new Error(`Slack Webhook Error`);
      }
    } else {
      if (!response.data.ok) {
        throw new Error(`Slack API Error: ${response.data.error}`);
      }
    }

    return {
      id: response.headers['x-slack-req-id'] || `webhook-id-${Date.now()}`,
      date: new Date().toISOString(),
    };
  }

  private sendMessageToEndpoint(
    data: IChatOptions,
    channelData: ChannelData,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ) {
    switch (channelData.type) {
      case ENDPOINT_TYPES.SLACK_CHANNEL:
        return this.sendAppMessageToChannel(data, channelData, bridgeProviderData);
      case ENDPOINT_TYPES.SLACK_USER:
        return this.sendAppMessageToUser(data, channelData, bridgeProviderData);
      case ENDPOINT_TYPES.WEBHOOK:
        return this.sendIncomingWebhookMessage(data, channelData, bridgeProviderData);
      default:
        throw new Error(`Unsupported endpoint format: ${channelData.type}`);
    }
  }

  private async sendAppMessageToChannel(
    data: IChatOptions,
    channelData: SlackChannelData,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ) {
    const { endpoint, token } = channelData;

    const response = await this.axiosInstance.post(
      `${this.slackAPI}/chat.postMessage`,
      this.transform(bridgeProviderData, {
        text: data.content,
        blocks: data.blocks,
        channel: endpoint.channelId,
        ...(data.customData || {}),
      }).body,
      {
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
      }
    );

    return response;
  }

  private async sendAppMessageToUser(
    data: IChatOptions,
    channelData: SlackUserData,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ) {
    const { endpoint, token } = channelData;

    const response = await this.axiosInstance.post(
      `${this.slackAPI}/chat.postMessage`,
      this.transform(bridgeProviderData, {
        text: data.content,
        blocks: data.blocks,
        channel: endpoint.userId,
        ...(data.customData || {}),
      }).body,
      {
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
      }
    );

    return response;
  }

  private async sendIncomingWebhookMessage(
    data: IChatOptions,
    channelData: WebhookData,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ) {
    const { endpoint } = channelData;

    const response = await this.axiosInstance.post(
      endpoint.url,
      this.transform(bridgeProviderData, {
        text: data.content,
        blocks: data.blocks,
        ...(data.customData || {}),
      }).body
    );

    return response;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SlackProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/chat/whatsapp-business/whatsapp-business.provider.spec.ts
Tamaño: 5921 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChannelEndpointByType, ENDPOINT_TYPES, IChatOptions } from '@novu/stateless';
import { nanoid } from 'nanoid';
import { expect, test } from 'vitest';
import { axiosSpy } from '../../../utils/test/spy-axios';
import { WhatsappBusinessChatProvider } from './whatsapp-business.provider';

const mockProviderConfig = {
  accessToken: 'my-access-token',
  phoneNumberIdentification: '1234567890',
};

const buildResponse = (messageId: string) => {
  return {
    data: {
      messaging_product: 'whatsapp',
      contacts: [{ input: 'Any input', wa_id: nanoid() }],
      messages: [{ id: messageId }],
    },
  };
};

test('should trigger whatsapp-business library correctly with simple text message', async () => {
  const messageId = nanoid();

  const { mockPost, axiosMockSpy } = axiosSpy(buildResponse(messageId));

  const provider = new WhatsappBusinessChatProvider(mockProviderConfig);

  const options: IChatOptions = {
    content: 'Simple text message',
    channelData: {
      identifier: '-',
      type: ENDPOINT_TYPES.PHONE,
      endpoint: { phoneNumber: '+111111111' },
    },
  };

  const res = await provider.sendMessage(options);

  expect(mockPost).toHaveBeenCalled();
  expect(mockPost).toHaveBeenCalledWith(baseUrl(mockProviderConfig.phoneNumberIdentification), {
    messaging_product: 'whatsapp',
    recipient_type: 'individual',
    text: {
      body: options.content,
      preview_url: false,
    },
    to: (options.channelData.endpoint as ChannelEndpointByType[typeof ENDPOINT_TYPES.PHONE]).phoneNumber,
    type: 'text',
  });

  expect(axiosMockSpy).toHaveBeenCalledWith(expectedHeaders(mockProviderConfig.accessToken));

  expect(res.id).toBe(messageId);
});

test('should trigger whatsapp-business library correctly with template message', async () => {
  const messageId = nanoid();

  const { mockPost, axiosMockSpy } = axiosSpy(buildResponse(messageId));

  const provider = new WhatsappBusinessChatProvider(mockProviderConfig);

  const options: IChatOptions = {
    content: 'Simple text message',
    channelData: {
      identifier: '-',
      type: ENDPOINT_TYPES.PHONE,
      endpoint: { phoneNumber: '+111111111' },
    },
    customData: {
      template: {
        name: 'hello_world',
        language: {
          code: 'en_US',
        },
      },
    },
  };

  const res = await provider.sendMessage(options);

  expect(mockPost).toHaveBeenCalled();
  expect(mockPost).toHaveBeenCalledWith(baseUrl(mockProviderConfig.phoneNumberIdentification), {
    messaging_product: 'whatsapp',
    recipient_type: 'individual',
    template: options.customData.template,
    to: (options.channelData.endpoint as ChannelEndpointByType[typeof ENDPOINT_TYPES.PHONE]).phoneNumber,
    type: 'template',
  });

  expect(axiosMockSpy).toHaveBeenCalledWith(expectedHeaders(mockProviderConfig.accessToken));

  expect(res.id).toBe(messageId);
});

test('should trigger whatsapp-business library correctly with simple text message with _passthrough', async () => {
  const messageId = nanoid();

  const { mockPost, axiosMockSpy } = axiosSpy(buildResponse(messageId));

  const provider = new WhatsappBusinessChatProvider(mockProviderConfig);

  const options: IChatOptions = {
    channelData: {
      identifier: '-',
      type: ENDPOINT_TYPES.PHONE,
      endpoint: { phoneNumber: '+111111111' },
    },
    content: 'Simple text message',
  };

  const res = await provider.sendMessage(options, {
    _passthrough: {
      body: {
        text: {
          body: `${options.content} _passthrough`,
        },
      },
    },
  });

  expect(mockPost).toHaveBeenCalled();
  expect(mockPost).toHaveBeenCalledWith(baseUrl(mockProviderConfig.phoneNumberIdentification), {
    messaging_product: 'whatsapp',
    recipient_type: 'individual',
    text: {
      body: `${options.content} _passthrough`,
      preview_url: false,
    },
    to: (options.channelData.endpoint as ChannelEndpointByType[typeof ENDPOINT_TYPES.PHONE]).phoneNumber,
    type: 'text',
  });

  expect(axiosMockSpy).toHaveBeenCalledWith(expectedHeaders(mockProviderConfig.accessToken));

  expect(res.id).toBe(messageId);
});

test('should trigger whatsapp-business library correctly with template message with _passthrough', async () => {
  const messageId = nanoid();

  const { mockPost, axiosMockSpy } = axiosSpy(buildResponse(messageId));

  const provider = new WhatsappBusinessChatProvider(mockProviderConfig);

  const options: IChatOptions = {
    channelData: {
      identifier: '-',
      type: ENDPOINT_TYPES.PHONE,
      endpoint: { phoneNumber: '+111111111' },
    },
    content: 'Simple text message',
    customData: {
      template: {
        name: 'hello_world',
        language: {
          code: 'en_US',
        },
      },
    },
  };

  const res = await provider.sendMessage(options, {
    _passthrough: {
      body: {
        template: {
          name: 'hello_world_passthrough',
          language: {
            code: 'en_US',
          },
        },
      },
    },
  });

  expect(mockPost).toHaveBeenCalled();
  expect(mockPost).toHaveBeenCalledWith(baseUrl(mockProviderConfig.phoneNumberIdentification), {
    messaging_product: 'whatsapp',
    recipient_type: 'individual',
    template: {
      name: 'hello_world_passthrough',
      language: {
        code: 'en_US',
      },
    },
    to: (options.channelData.endpoint as ChannelEndpointByType[typeof ENDPOINT_TYPES.PHONE]).phoneNumber,
    type: 'template',
  });

  expect(axiosMockSpy).toHaveBeenCalledWith(expectedHeaders(mockProviderConfig.accessToken));

  expect(res.id).toBe(messageId);
});

function baseUrl(phoneNumberIdentification: string) {
  return `https://graph.facebook.com/v22.0/${phoneNumberIdentification}/messages`;
}

function expectedHeaders(accessToken: string) {
  return {
    headers: {
      Authorization: `Bearer ${accessToken}`,
      'Content-Type': 'application/json',
    },
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - baseUrl(phoneNumberIdentification: string)
 - expectedHeaders(accessToken: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - buildResponse(messageId: string))
 - res(await provider.sendMessage(options);

  expect(mockPost).toHaveBeenCalled();
  expect(mockPost).toHa...)
 - res(await provider.sendMessage(options);

  expect(mockPost).toHaveBeenCalled();
  expect(mockPost).toHa...)
 - res(await provider.sendMessage(options, {
    _passthrough: {
      body: {
        text: {
          bo...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/chat/whatsapp-business/whatsapp-business.provider.ts
Tamaño: 3565 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChatProviderIdEnum, ENDPOINT_TYPES } from '@novu/shared';
import {
  ChannelTypeEnum,
  IChatOptions,
  IChatProvider,
  ISendMessageSuccessResponse,
  isChannelDataOfType,
} from '@novu/stateless';
import Axios, { AxiosInstance } from 'axios';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';
import { WhatsAppMessageTypeEnum } from './consts/whatsapp-business.enum';
import { ISendMessageRes } from './types/whatsapp-business.types';

export class WhatsappBusinessChatProvider extends BaseProvider implements IChatProvider {
  id = ChatProviderIdEnum.WhatsAppBusiness;
  protected casing: CasingEnum = CasingEnum.SNAKE_CASE;
  channelType = ChannelTypeEnum.CHAT as ChannelTypeEnum.CHAT;

  private readonly axiosClient: AxiosInstance;
  private readonly baseUrl = 'https://graph.facebook.com/v22.0/';

  constructor(
    private config: {
      accessToken: string;
      phoneNumberIdentification: string;
    }
  ) {
    super();
    this.axiosClient = Axios.create({
      headers: {
        Authorization: `Bearer ${this.config.accessToken}`,
        'Content-Type': 'application/json',
      },
    });
  }

  async sendMessage(
    options: IChatOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    if (!isChannelDataOfType(options.channelData, ENDPOINT_TYPES.PHONE)) {
      throw new Error('Invalid channel data for WhatsappBusiness provider');
    }

    const { phoneNumber } = options.channelData.endpoint;

    const payload = this.transform(bridgeProviderData, this.defineMessagePayload(options, phoneNumber)).body;

    const { data } = await this.axiosClient.post<ISendMessageRes>(
      `${this.baseUrl + this.config.phoneNumberIdentification}/messages`,
      payload
    );

    return {
      id: data.messages[0].id,
      date: new Date().toISOString(),
    };
  }

  private defineMessagePayload(options: IChatOptions, phoneNumber: string) {
    const type = this.defineMessageType(options);

    const basePayload = {
      messaging_product: 'whatsapp',
      recipient_type: 'individual',
      to: phoneNumber,
      type,
    };

    // Handle TEXT messages separately (since it's not in `customData`)
    if (type === WhatsAppMessageTypeEnum.TEXT) {
      const textData = options.customData?.text;

      return {
        ...basePayload,
        text: {
          body: textData?.body ?? options.content,
          preview_url: textData?.preview_url ?? false,
        },
      };
    }

    // For all other types, get data from customData
    const payloadData = options.customData?.[type];

    return {
      ...basePayload,
      [type]: payloadData,
    };
  }

  private defineMessageType(options: IChatOptions): WhatsAppMessageTypeEnum {
    const typeKeys: Record<string, WhatsAppMessageTypeEnum> = {
      template: WhatsAppMessageTypeEnum.TEMPLATE,
      interactive: WhatsAppMessageTypeEnum.INTERACTIVE,
      image: WhatsAppMessageTypeEnum.IMAGE,
      document: WhatsAppMessageTypeEnum.DOCUMENT,
      video: WhatsAppMessageTypeEnum.VIDEO,
      audio: WhatsAppMessageTypeEnum.AUDIO,
      location: WhatsAppMessageTypeEnum.LOCATION,
      contacts: WhatsAppMessageTypeEnum.CONTACTS,
      sticker: WhatsAppMessageTypeEnum.STICKER,
    };

    if (options.customData) {
      for (const key of Object.keys(typeKeys)) {
        if (key in options.customData) {
          return typeKeys[key];
        }
      }
    }

    return WhatsAppMessageTypeEnum.TEXT;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class WhatsappBusinessChatProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/chat/whatsapp-business/consts/whatsapp-business.enum.ts
Tamaño: 268 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export enum WhatsAppMessageTypeEnum {
  TEMPLATE = 'template',
  TEXT = 'text',
  INTERACTIVE = 'interactive',
  IMAGE = 'image',
  DOCUMENT = 'document',
  VIDEO = 'video',
  AUDIO = 'audio',
  LOCATION = 'location',
  CONTACTS = 'contacts',
  STICKER = 'sticker',
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  enum

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/chat/whatsapp-business/types/whatsapp-business.types.ts
Tamaño: 210 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export interface ISendMessageRes {
  messaging_product: string;
  contacts: IContact[];
  messages: IMessage[];
}

interface IContact {
  input: string;
  wa_id: string;
}

interface IMessage {
  id: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  interface

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/chat/zulip/zulip.provider.spec.ts
Tamaño: 638 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, test, vi } from 'vitest';
import { ZulipProvider } from './zulip.provider';

const mockMessage = {
  webhookUrl: 'https://test.zulipchat.com/api/v1/external/slack_incoming?api_key=apikey&stream=general',
  content: 'Hello world',
};

test('should trigger zulip library correctly', async () => {
  const provider = new ZulipProvider({});
  const spy = vi.spyOn(provider, 'sendMessage').mockImplementation(async () => {
    return {
      date: new Date().toISOString(),
    } as any;
  });

  await provider.sendMessage(mockMessage);

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith(mockMessage);
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - stream(general',
  content: 'Hello world',
};

test('should trigger zulip library correctly', async ())
 - spy(vi.spyOn(provider, 'sendMessage').mockImplementation(async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/chat/zulip/zulip.provider.ts
Tamaño: 1246 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChatProviderIdEnum } from '@novu/shared';
import {
  ChannelTypeEnum,
  ENDPOINT_TYPES,
  IChatOptions,
  IChatProvider,
  ISendMessageSuccessResponse,
  isChannelDataOfType,
} from '@novu/stateless';
import axios from 'axios';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class ZulipProvider extends BaseProvider implements IChatProvider {
  id = ChatProviderIdEnum.Zulip;
  channelType = ChannelTypeEnum.CHAT as ChannelTypeEnum.CHAT;
  protected casing: CasingEnum = CasingEnum.SNAKE_CASE;

  private axiosInstance = axios.create();

  constructor(private config) {
    super();
  }

  async sendMessage(
    data: IChatOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    if (!isChannelDataOfType(data.channelData, ENDPOINT_TYPES.WEBHOOK)) {
      throw new Error('Invalid channel data for Zulip provider');
    }

    const { channelData } = data;

    await this.axiosInstance.post(
      channelData.endpoint.url,
      this.transform(bridgeProviderData, {
        text: data.content,
      }).body
    );

    return {
      date: new Date().toISOString(),
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ZulipProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/index.ts
Tamaño: 1018 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './braze/braze.provider';
export * from './brevo/brevo.provider';
export * from './email-webhook/email-webhook.provider';
export * from './emailjs/emailjs.config';
export * from './emailjs/emailjs.provider';
export * from './infobip/infobip.provider';
export * from './mailersend/mailersend.provider';
export * from './mailgun/mailgun.provider';
export * from './mailjet/mailjet.provider';
export * from './mailtrap/mailtrap.provider';
export * from './mandrill/mandrill.provider';
export * from './netcore/netcore.provider';
export * from './nodemailer/nodemailer.provider';
export * from './outlook365/outlook365.provider';
export * from './plunk/plunk.interface';
export * from './plunk/plunk.provider';
export * from './postmark/postmark.provider';
export * from './resend/resend.provider';
export * from './sendgrid/sendgrid.provider';
export * from './ses/ses.config';
export * from './ses/ses.provider';
export * from './sparkpost/sparkpost.error';
export * from './sparkpost/sparkpost.provider';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/braze/braze.provider.spec.ts
Tamaño: 874 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, test, vi } from 'vitest';
import { BrazeEmailProvider } from './braze.provider';

const mockConfig = {
  apiKey: 'your-api-key',
  apiURL: 'your-api-url',
  appID: 'your-app-id',
};

const mockEmailOptions = {
  from: 'test@example.com',
  to: ['recipient1@example.com', 'recipient2@example.com'],
  subject: 'Test Subject',
  html: '<p>HTML content</p>',
};

test('should trigger sendMessage method correctly', async () => {
  const provider = new BrazeEmailProvider(mockConfig);

  const spy = vi.spyOn(provider, 'sendMessage').mockImplementation(async () => {
    return {} as any;
  });

  await provider.sendMessage(mockEmailOptions);

  expect(spy).toHaveBeenCalled();

  expect(spy).toHaveBeenCalledWith({
    from: mockEmailOptions.from,
    to: mockEmailOptions.to,
    html: mockEmailOptions.html,
    subject: mockEmailOptions.subject,
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - mockEmailOptions({
  from: 'test@example.com',
  to: ['recipient1@example.com', 'recipient2@example.com'],
  subject:...)
 - spy(vi.spyOn(provider, 'sendMessage').mockImplementation(async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/braze/braze.provider.ts
Tamaño: 3641 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EmailProviderIdEnum } from '@novu/shared';
import {
  ChannelTypeEnum,
  CheckIntegrationResponseEnum,
  ICheckIntegrationResponse,
  IEmailOptions,
  IEmailProvider,
  ISendMessageSuccessResponse,
} from '@novu/stateless';
import { Braze, MessagesSendObject, UsersExportIdsObject, UsersExportIdsResponse } from 'braze-api';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class BrazeEmailProvider extends BaseProvider implements IEmailProvider {
  id = EmailProviderIdEnum.Braze;
  protected casing: CasingEnum = CasingEnum.SNAKE_CASE;
  channelType = ChannelTypeEnum.EMAIL as ChannelTypeEnum.EMAIL;
  private braze: Braze;

  constructor(
    private config: {
      apiKey: string;
      apiURL: string;
      appID: string;
    }
  ) {
    super();
    this.braze = new Braze(this.config.apiURL, this.config.apiKey);
  }

  async sendMessage(
    options: IEmailOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const maildata = await this.createMailData(options);
    const response = await this.braze.messages.send(this.transform(bridgeProviderData, maildata).body);

    return {
      id: response.dispatch_id,
      date: new Date().toISOString(),
    };
  }
  private async mapToExternalID(options: string[]): Promise<string[]> {
    const externalIds: string[] = [];

    for (const email of options) {
      const exportObject: UsersExportIdsObject = {
        email_address: email,
      };

      const response: UsersExportIdsResponse = await this.braze.users.export.ids(exportObject);
      externalIds.push(...response.users.map((user) => user.external_id));
    }

    return externalIds;
  }

  private async createMailData(options: IEmailOptions): Promise<MessagesSendObject> {
    const messageBody: MessagesSendObject = {
      broadcast: false,
      external_user_ids: await this.mapToExternalID(options.to),
      messages: {
        email: {
          app_id: this.config.appID,
          subject: options.subject,
          from: options.from,
          body: options.html,
          reply_to: options.replyTo || null,
          bcc: options.bcc?.join(','),
          plaintext_body: options.text || null,
          extras: options.payloadDetails || {},
          headers: {},
          should_inline_css: true,
          attachments: [],
        },
      },
    };

    if (options.attachments && options.attachments.length > 0) {
      messageBody.messages.email.attachments = options.attachments.map((attachment) => {
        return {
          file_name: attachment.name || 'attachment',
          url: `data:${attachment.mime};base64,${attachment.file.toString('base64')}`,
        };
      });
    }

    return messageBody;
  }

  async checkIntegration(options: IEmailOptions): Promise<ICheckIntegrationResponse> {
    try {
      const testEmailMessage = await this.createMailData(options);

      const response = await this.braze.messages.send(testEmailMessage);

      if (response.message.includes('success')) {
        return {
          success: true,
          message: 'Integrated successfully!',
          code: CheckIntegrationResponseEnum.SUCCESS,
        };
      } else {
        return {
          success: false,
          message: 'Integration failed',
          code: CheckIntegrationResponseEnum.FAILED,
        };
      }
    } catch (error) {
      return {
        success: false,
        message: `Integration check error: ${error.message}`,
        code: CheckIntegrationResponseEnum.FAILED,
      };
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - UsersExportIdsResponse(await this.braze.users.export.ids(exportObject);
      externalIds.push(...response.users.map((user))
 - attachments(options.attachments.map((attachment))
Declaraciones 'export' encontradas:
- export class BrazeEmailProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/brevo/brevo.provider.spec.ts
Tamaño: 5572 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EmailEventStatusEnum } from '@novu/stateless';
import { describe, expect, test, vi } from 'vitest';
import { axiosSpy } from '../../../utils/test/spy-axios';
import { BrevoEmailProvider } from './brevo.provider';

const mockConfig = {
  apiKey: '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',
  from: 'test@novu.co',
  senderName: 'test',
};

const mockNovuMessage = {
  from: 'test@test.com',
  to: ['test@test.com'],
  html: '<div> Mail Content </div>',
  subject: 'Test subject',
  attachments: [{ mime: 'text/plain', file: Buffer.from('dGVzdA=='), name: 'test.txt' }],
};

const mockSendinblueMessage = {
  event: 'delivered',
  email: 'test@test.com',
  id: 26224,
  date: '2022-10-11 14:13:07',
  ts: 1598634509,
  'message-id': '<xxxxxxxxxxxx.xxxxxxxxx@domain.com>',
  ts_event: 1598034509,
  subject: 'Subject Line',
  tag: '["transactionalTag"]',
  sending_ip: '185.41.28.109',
  ts_epoch: 1598634509223,
  tags: ['test'],
};

test('should send message', async () => {
  const { mockRequest } = axiosSpy({
    data: {
      messageId: 'id',
    },
  });
  const provider = new BrevoEmailProvider(mockConfig);

  await provider.sendMessage(mockNovuMessage);

  expect(mockRequest).toHaveBeenCalled();
  expect(mockRequest).toHaveBeenCalledWith({
    data: '{"sender":{"email":"test@test.com","name":"test"},"to":[{"email":"test@test.com"}],"subject":"Test subject","htmlContent":"<div> Mail Content </div>","attachment":[{"name":"test.txt","content":"ZEdWemRBPT0="}]}',
    headers: {
      Accept: 'application/json',
      'Content-Type': 'application/json',
      'api-key': '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',
    },
    method: 'POST',
    url: '/smtp/email',
  });
});

test('should send message with _passthrough', async () => {
  const { mockRequest } = axiosSpy({
    data: {
      messageId: 'id',
    },
  });
  const provider = new BrevoEmailProvider(mockConfig);

  await provider.sendMessage(mockNovuMessage, {
    _passthrough: {
      body: {
        subject: 'Test subject _passthrough',
      },
    },
  });

  expect(mockRequest).toHaveBeenCalled();
  expect(mockRequest).toHaveBeenCalledWith({
    data: '{"sender":{"email":"test@test.com","name":"test"},"to":[{"email":"test@test.com"}],"subject":"Test subject _passthrough","htmlContent":"<div> Mail Content </div>","attachment":[{"name":"test.txt","content":"ZEdWemRBPT0="}]}',
    headers: {
      Accept: 'application/json',
      'Content-Type': 'application/json',
      'api-key': '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',
    },
    method: 'POST',
    url: '/smtp/email',
  });
});

test('should correctly use sender email and name from the config', async () => {
  const provider = new BrevoEmailProvider(mockConfig);
  const spy = vi.spyOn(provider, 'sendMessage').mockImplementation(async () => {
    return {
      id: 'id',
      date: new Date().toISOString(),
    };
  });
  const { from, ...mockNovuMessageWithoutFrom } = mockNovuMessage;

  // use config.from if message.from is not provided
  await provider.sendMessage(mockNovuMessageWithoutFrom);
  expect(spy).toHaveBeenCalled();

  // Use the message.from instead of config.from if available
  const res = await provider.sendMessage(mockNovuMessage);
  expect(spy).toHaveBeenCalled();
  expect(res.id).toBe('id');
});

describe('getMessageId', () => {
  test('should return messageId when body is valid', async () => {
    const provider = new BrevoEmailProvider(mockConfig);
    const messageId = provider.getMessageId(mockSendinblueMessage);
    expect(messageId).toEqual([mockSendinblueMessage['message-id']]);
  });

  test('should return messageId when body is array', async () => {
    const provider = new BrevoEmailProvider(mockConfig);
    const messageId = provider.getMessageId([mockSendinblueMessage]);
    expect(messageId).toEqual([mockSendinblueMessage['message-id']]);
  });

  test('should return undefined when event body is undefined', async () => {
    const provider = new BrevoEmailProvider(mockConfig);
    const messageId = provider.parseEventBody(undefined, 'test');
    expect(messageId).toBeUndefined();
  });

  test('should return undefined when event body is empty', async () => {
    const provider = new BrevoEmailProvider(mockConfig);
    const messageId = provider.parseEventBody([], 'test');
    expect(messageId).toBeUndefined();
  });
});

describe('parseEventBody', () => {
  test('should return IEmailEventBody object when body is valid', async () => {
    const provider = new BrevoEmailProvider(mockConfig);
    const eventBody = provider.parseEventBody(mockSendinblueMessage, 'test');
    const dateISO = new Date(mockSendinblueMessage.date).toISOString();
    expect(eventBody).toEqual({
      status: EmailEventStatusEnum.DELIVERED,
      date: dateISO,
      externalId: mockSendinblueMessage.id,
      attempts: undefined,
      response: undefined,
      row: mockSendinblueMessage,
    });
  });

  test('should return undefined when event body is undefined', async () => {
    const provider = new BrevoEmailProvider(mockConfig);
    const eventBody = provider.parseEventBody(undefined, 'test');
    expect(eventBody).toBeUndefined();
  });

  test('should return undefined when status is unrecognized', async () => {
    const provider = new BrevoEmailProvider(mockConfig);
    const messageId = provider.parseEventBody({ event: 'not-real-event' }, 'test');
    expect(messageId).toBeUndefined();
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - mockSendinblueMessage({
  event: 'delivered',
  email: 'test@test.com',
  id: 26224,
  date: '2022-10-11 14:13:07',
  ts: ...)
 - ZEdWemRBPT0("}]}',
    headers: {
      Accept: 'application/json',
      'Content-Type': 'application/json',
  ...)
 - ZEdWemRBPT0("}]}',
    headers: {
      Accept: 'application/json',
      'Content-Type': 'application/json',
  ...)
 - spy(vi.spyOn(provider, 'sendMessage').mockImplementation(async ())
 - res(await provider.sendMessage(mockNovuMessage);
  expect(spy).toHaveBeenCalled();
  expect(res.id).toBe...)
 - messageId(provider.getMessageId(mockSendinblueMessage);
    expect(messageId).toEqual([mockSendinblueMessage['...)
 - messageId(provider.getMessageId([mockSendinblueMessage]);
    expect(messageId).toEqual([mockSendinblueMessage...)
 - messageId(provider.parseEventBody(undefined, 'test');
    expect(messageId).toBeUndefined();
  });

  test('sh...)
 - messageId(provider.parseEventBody([], 'test');
    expect(messageId).toBeUndefined();
  });
});

describe('par...)
 - dateISO(new Date(mockSendinblueMessage.date).toISOString();
    expect(eventBody).toEqual({
      status: Em...)
 - eventBody(provider.parseEventBody(undefined, 'test');
    expect(eventBody).toBeUndefined();
  });

  test('sh...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/brevo/brevo.provider.ts
Tamaño: 4579 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EmailProviderIdEnum } from '@novu/shared';

import {
  ChannelTypeEnum,
  CheckIntegrationResponseEnum,
  EmailEventStatusEnum,
  ICheckIntegrationResponse,
  IEmailEventBody,
  IEmailOptions,
  IEmailProvider,
  ISendMessageSuccessResponse,
} from '@novu/stateless';
import axios, { AxiosInstance, AxiosRequestConfig } from 'axios';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class BrevoEmailProvider extends BaseProvider implements IEmailProvider {
  id = EmailProviderIdEnum.Sendinblue; // brevo changed name from sendinblue.
  channelType = ChannelTypeEnum.EMAIL as ChannelTypeEnum.EMAIL;
  protected casing: CasingEnum = CasingEnum.CAMEL_CASE;
  private axiosInstance: AxiosInstance;
  public readonly BASE_URL = 'https://api.brevo.com/v3';

  constructor(
    private config: {
      apiKey: string;
      from: string;
      senderName: string;
    }
  ) {
    super();
    this.axiosInstance = axios.create({
      baseURL: this.BASE_URL,
    });
  }

  async sendMessage(
    options: IEmailOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const email: any = {};
    email.sender = {
      email: options.from || this.config.from,
      name: options.senderName || this.config.senderName,
    };
    email.templateId = options.customData?.templateId;
    email.params = options.customData?.templateParams;
    email.to = getFormattedTo(options.to);
    email.subject = options.subject;
    email.htmlContent = options.html;
    email.textContent = options.text;
    email.attachment = options.attachments?.map((attachment) => ({
      name: attachment?.name,
      content: attachment?.file.toString('base64'),
    }));

    if (options.headers && Object.keys(options.headers)?.length) {
      email.headers = options.headers;
    }

    if (options.cc?.length) {
      email.cc = options.cc?.map((ccItem) => ({ email: ccItem }));
    }

    if (options?.bcc?.length) {
      email.bcc = options.bcc?.map((ccItem) => ({ email: ccItem }));
    }

    if (options.replyTo) {
      email.replyTo = {
        email: options.replyTo,
      };
    }

    const transformedData = this.transform(bridgeProviderData, email);

    const emailOptions: AxiosRequestConfig = {
      url: '/smtp/email',
      method: 'POST',
      headers: {
        'api-key': this.config.apiKey,
        'Content-Type': 'application/json',
        Accept: 'application/json',
        ...transformedData.headers,
      },
      data: JSON.stringify(transformedData.body),
    };

    const response = await this.axiosInstance.request<{ messageId: string }>(emailOptions);

    return {
      id: response?.data.messageId,
      date: new Date().toISOString(),
    };
  }

  getMessageId(body: any | any[]): string[] {
    if (Array.isArray(body)) {
      return body.map((item) => item['message-id']);
    }

    return [body['message-id']];
  }

  parseEventBody(body: any | any[], identifier: string): IEmailEventBody | undefined {
    if (Array.isArray(body)) {
      body = body.find((item) => item['message-id'] === identifier);
    }

    if (!body) {
      return undefined;
    }

    const status = this.getStatus(body.event);

    if (status === undefined) {
      return undefined;
    }

    return {
      status,
      date: new Date(body.date).toISOString(),
      externalId: body.id,
      row: body,
    };
  }

  private getStatus(event: string): EmailEventStatusEnum | undefined {
    switch (event) {
      case 'opened':
      case 'uniqueOpened':
      case 'proxy_open':
        return EmailEventStatusEnum.OPENED;
      case 'request':
      case 'delivered':
      case 'complaint':
        return EmailEventStatusEnum.DELIVERED;
      case 'hardBounce':
      case 'softBounce':
      case 'blocked':
      case 'unsubscribed':
        return EmailEventStatusEnum.BOUNCED;
      case 'click':
        return EmailEventStatusEnum.CLICKED;
      case 'invalid_email':
      case 'error':
        return EmailEventStatusEnum.DROPPED;
      default:
        return undefined;
    }
  }

  async checkIntegration(options: IEmailOptions): Promise<ICheckIntegrationResponse> {
    return {
      success: true,
      message: 'Integrated successfully!',
      code: CheckIntegrationResponseEnum.SUCCESS,
    };
  }
}

function getFormattedTo(to: string | string[]): { email: string }[] {
  if (typeof to === 'string') {
    return [{ email: to }];
  }

  return to.map((email: string) => ({ email }));
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getFormattedTo(to: string | string[])
Asignaciones con arrow functions encontradas (posibles funciones):
 - attachment(options.attachments?.map((attachment))
 - cc(options.cc?.map((ccItem))
 - bcc(options.bcc?.map((ccItem))
 - response(await this.axiosInstance.request<{ messageId: string }>(emailOptions);

    return {
      id: respo...)
 - body(body.find((item))
Declaraciones 'export' encontradas:
- export class BrevoEmailProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/email-webhook/email-webhook.provider.spec.ts
Tamaño: 2301 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import axios from 'axios';
import { expect, test } from 'vitest';
import { axiosSpy } from '../../../utils/test/spy-axios';
import { EmailWebhookProvider } from './email-webhook.provider';

test('should trigger email-webhook-provider library correctly', async () => {
  const { mockPost } = axiosSpy({
    data: true,
  });

  const provider = new EmailWebhookProvider({
    webhookUrl: 'http://127.0.0.1:8080/webhook',
    hmacSecretKey: 'super-secret-key',
    retryDelay: 1,
    retryCount: 1,
  });

  const testTo = 'johndoe@example.com';
  const testFrom = 'janedoe@example.com';

  const payload = {
    to: [testTo],
    from: testFrom,
    subject: 'test',
    html: '<h1>test</h1>',
    text: 'test',
  };

  await provider.sendMessage(payload);

  expect(mockPost).toHaveBeenCalled();
  expect(mockPost).toHaveBeenCalledWith(
    'http://127.0.0.1:8080/webhook',
    '{"to":["johndoe@example.com"],"from":"janedoe@example.com","subject":"test","html":"<h1>test</h1>","text":"test"}',
    {
      headers: {
        'content-type': 'application/json',
        'X-Novu-Signature': 'd1e94cd19eeceec2e0717e36f7edacaa93612b311bde8756ee35b89d4a994767',
      },
    }
  );
});

test('should trigger email-webhook-provider library correctly with _passthrough', async () => {
  const { mockPost } = axiosSpy({
    data: true,
  });

  const provider = new EmailWebhookProvider({
    webhookUrl: 'http://127.0.0.1:8080/webhook',
    hmacSecretKey: 'super-secret-key',
    retryDelay: 1,
    retryCount: 1,
  });

  const testTo = 'johndoe@example.com';
  const testFrom = 'janedoe@example.com';

  const payload = {
    to: [testTo],
    from: testFrom,
    subject: 'test',
    html: '<h1>test</h1>',
    text: 'test',
  };

  await provider.sendMessage(payload, {
    _passthrough: {
      body: {
        subject: 'test _passthrough',
      },
    },
  });

  expect(mockPost).toHaveBeenCalled();
  expect(mockPost).toHaveBeenCalledWith(
    'http://127.0.0.1:8080/webhook',
    '{"to":["johndoe@example.com"],"from":"janedoe@example.com","subject":"test _passthrough","html":"<h1>test</h1>","text":"test"}',
    {
      headers: {
        'content-type': 'application/json',
        'X-Novu-Signature': 'b0bfe55e55cfc925891858e6a7a77d1da5e3917321ae4f440e1e81843b2f5fa7',
      },
    }
  );
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - payload({
    to: [testTo],
    from: testFrom,
    subject: 'test',
    html: '<h1>test</h1>',
    text: 't...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/email-webhook/email-webhook.provider.ts
Tamaño: 2449 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EmailProviderIdEnum } from '@novu/shared';
import {
  ChannelTypeEnum,
  CheckIntegrationResponseEnum,
  ICheckIntegrationResponse,
  IEmailOptions,
  IEmailProvider,
  ISendMessageSuccessResponse,
} from '@novu/stateless';
import axios from 'axios';
import crypto from 'crypto';
import { setTimeout } from 'timers/promises';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class EmailWebhookProvider extends BaseProvider implements IEmailProvider {
  protected casing: CasingEnum = CasingEnum.CAMEL_CASE;
  readonly id = EmailProviderIdEnum.EmailWebhook;
  readonly channelType = ChannelTypeEnum.EMAIL as ChannelTypeEnum.EMAIL;

  constructor(
    private config: {
      hmacSecretKey?: string;
      webhookUrl: string;
      retryCount?: number;
      retryDelay?: number;
    }
  ) {
    super();
    this.config.retryDelay ??= 30 * 1000;
    this.config.retryCount ??= 3;
  }

  async checkIntegration(options: IEmailOptions): Promise<ICheckIntegrationResponse> {
    return {
      success: true,
      message: 'Integrated successfully!',
      code: CheckIntegrationResponseEnum.SUCCESS,
    };
  }

  async sendMessage(
    options: IEmailOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const transformedData = this.transform(bridgeProviderData, options);
    const bodyData = this.createBody(transformedData.body);
    const hmacValue = this.computeHmac(bodyData);
    let sent = false;

    for (let retries = 0; !sent && retries < this.config.retryCount; retries += 1) {
      try {
        await axios.create().post(this.config.webhookUrl, bodyData, {
          headers: {
            'content-type': 'application/json',
            'X-Novu-Signature': hmacValue,
            ...transformedData.headers,
          },
        });
        sent = true;
      } catch (error) {
        await setTimeout(this.config.retryDelay);
      }
    }
    if (!sent) {
      throw new Error('webhook send failed !');
    }

    return {
      id: options.id,
      date: new Date().toDateString(),
    };
  }

  createBody(options: WithPassthrough<Record<string, unknown>>): string {
    return JSON.stringify(options);
  }

  computeHmac(payload: string): string {
    return crypto.createHmac('sha256', this.config.hmacSecretKey).update(payload, 'utf-8').digest('hex');
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class EmailWebhookProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/emailjs/emailjs.config.ts
Tamaño: 142 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export interface IEmailJsConfig {
  from: string;
  host: string;
  port: number;
  secure?: boolean;
  user?: string;
  password?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  interface

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/emailjs/emailjs.provider.spec.ts
Tamaño: 2122 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CheckIntegrationResponseEnum, IEmailOptions, ISendMessageSuccessResponse } from '@novu/stateless';
import { expect, test, vi } from 'vitest';
import { IEmailJsConfig } from './emailjs.config';
import { EmailJsProvider } from './emailjs.provider';

const mockConfig = {
  from: 'test',
} as IEmailJsConfig;

const mockNovuMessage = {
  to: ['test@test1.com', 'test@test2.com'],
  subject: 'test subject',
  html: '<div> Mail Content </div>',
  text: 'Mail Content',
  from: 'test@test.com',
  attachments: [{ mime: 'text/plain', file: Buffer.from('dGVzdA=='), name: 'test.txt' }],
} as IEmailOptions;

test('should trigger emailjs with expected parameters', async () => {
  const provider = new EmailJsProvider(mockConfig);
  const spy = vi.spyOn(provider, 'sendMessage').mockImplementation(async () => {
    return {
      id: 'message-id',
      date: '12/01/2020',
    } as ISendMessageSuccessResponse;
  });

  const response = await provider.sendMessage(mockNovuMessage);

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    to: mockNovuMessage.to,
    subject: mockNovuMessage.subject,
    html: mockNovuMessage.html,
    text: mockNovuMessage.text,
    from: mockNovuMessage.from,
    attachments: [
      {
        mime: 'text/plain',
        file: Buffer.from('dGVzdA=='),
        name: 'test.txt',
      },
    ],
  });
  expect(response).not.toBeNull();
  expect(response.date).toBe('12/01/2020');
  expect(response.id).toBe('message-id');
});

test('should trigger emailjs checkIntegration correctly', async () => {
  const provider = new EmailJsProvider(mockConfig);
  const spy = vi.spyOn(provider, 'checkIntegration').mockImplementation(async () => {
    return {
      success: true,
      message: 'Integrated successfully!',
      code: CheckIntegrationResponseEnum.SUCCESS,
    };
  });

  const response = await provider.checkIntegration(mockNovuMessage);

  expect(spy).toHaveBeenCalled();
  expect(response.success).toBeTruthy();
  expect(response.message).toEqual('Integrated successfully!');
  expect(response.code).toEqual(CheckIntegrationResponseEnum.SUCCESS);
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - spy(vi.spyOn(provider, 'sendMessage').mockImplementation(async ())
 - spy(vi.spyOn(provider, 'checkIntegration').mockImplementation(async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/emailjs/emailjs.provider.ts
Tamaño: 3022 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EmailProviderIdEnum } from '@novu/shared';
import {
  ChannelTypeEnum,
  CheckIntegrationResponseEnum,
  ICheckIntegrationResponse,
  IEmailEventBody,
  IEmailOptions,
  IEmailProvider,
  ISendMessageSuccessResponse,
} from '@novu/stateless';
// @ts-ignore CJS importing an ESM module, this fails only during the CJS build
import type { Message, MessageAttachment, SMTPClient } from 'emailjs';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { IEmailJsConfig } from './emailjs.config';

export class EmailJsProvider extends BaseProvider implements IEmailProvider {
  protected casing: CasingEnum = CasingEnum.KEBAB_CASE;
  readonly id = EmailProviderIdEnum.EmailJS;
  readonly channelType = ChannelTypeEnum.EMAIL as ChannelTypeEnum.EMAIL;
  private client: SMTPClient | null = null;

  constructor(private readonly config: IEmailJsConfig) {
    super();
  }
  async sendMessage(
    emailOptions: IEmailOptions,
    bridgeProviderData: Record<string, unknown> = {}
  ): Promise<ISendMessageSuccessResponse> {
    await this.ensureClientInitialized();

    const headers: Message['header'] = {
      from: emailOptions.from || this.config.from,
      to: emailOptions.to,
      subject: emailOptions.subject,
      text: emailOptions.text,
      attachment: this.mapAttachments(emailOptions),
      cc: emailOptions.cc,
      bcc: emailOptions.bcc,
    };

    if (emailOptions.replyTo) {
      headers['reply-to'] = emailOptions.replyTo;
    }

    const { Message: EmailJsMessage } = await import('emailjs');
    const sent = await this.client?.sendAsync(
      new EmailJsMessage(this.transform(bridgeProviderData, headers).body as Message['header'])
    );

    return {
      id: sent.header['message-id']!,
      date: sent.header.date,
    };
  }
  getMessageId?: (body: any | any[]) => string[];
  parseEventBody?: (body: any | any[], identifier: string) => IEmailEventBody | undefined;

  private async ensureClientInitialized() {
    if (!this.client) {
      const { host, port, secure: ssl, user, password } = this.config;

      const { SMTPClient: EmailJsClient } = await import('emailjs');
      this.client = new EmailJsClient({
        host,
        port,
        ssl,
        user,
        password,
      });
    }
  }

  async checkIntegration(options: IEmailOptions): Promise<ICheckIntegrationResponse> {
    return {
      success: true,
      message: 'Integrated successfully!',
      code: CheckIntegrationResponseEnum.SUCCESS,
    };
  }

  private mapAttachments(emailOptions: IEmailOptions) {
    const attachmentsModel: MessageAttachment[] = emailOptions.attachments
      ? emailOptions.attachments.map((attachment) => {
          return {
            name: attachment.name,
            data: attachment.file.toString('base64'),
            type: attachment.mime,
            inline: Boolean(attachment.cid),
          };
        })
      : [];

    attachmentsModel?.push({ data: emailOptions.html, alternative: true });

    return attachmentsModel;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - sent(await this.client?.sendAsync(
      new EmailJsMessage(this.transform(bridgeProviderData, headers).b...)
Declaraciones 'export' encontradas:
- export class EmailJsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/infobip/infobip.provider.spec.ts
Tamaño: 2106 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, test, vi } from 'vitest';
import { InfobipEmailProvider } from './infobip.provider';

test('should trigger infobip library correctly - E-mail', async () => {
  const provider = new InfobipEmailProvider({
    baseUrl: 'localhost',
    apiKey: '<infobip-auth-token>',
  });

  const spy = vi

    // @ts-expect-error
    .spyOn(provider.infobipClient.channels.email, 'send')
    .mockImplementation(async () => {
      return {
        data: {
          messages: [
            {
              messageId: '<a-valid-message-id>',
            },
          ],
        },
      };
    });

  await provider.sendMessage({
    to: ['example@example.org'],
    from: 'example@example.org',
    subject: 'Hello World Test',
    text: 'Plain text',
    html: '<div>HTML</div>',
  });

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    to: ['example@example.org'],
    from: 'example@example.org',
    subject: 'Hello World Test',
    text: 'Plain text',
    html: '<div>HTML</div>',
  });
});

test('should trigger infobip library correctly - E-mail with _passthrough', async () => {
  const provider = new InfobipEmailProvider({
    baseUrl: 'localhost',
    apiKey: '<infobip-auth-token>',
  });

  const spy = vi

    // @ts-expect-error
    .spyOn(provider.infobipClient.channels.email, 'send')
    .mockImplementation(async () => {
      return {
        data: {
          messages: [
            {
              messageId: '<a-valid-message-id>',
            },
          ],
        },
      };
    });

  await provider.sendMessage(
    {
      to: ['example@example.org'],
      from: 'example@example.org',
      subject: 'Hello World Test',
      text: 'Plain text',
      html: '<div>HTML</div>',
    },
    {
      _passthrough: {
        body: {
          html: '<div>_passthrough</div>',
        },
      },
    }
  );

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    to: ['example@example.org'],
    from: 'example@example.org',
    subject: 'Hello World Test',
    text: 'Plain text',
    html: '<div>_passthrough</div>',
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - spy(vi

    // @ts-expect-error
    .spyOn(provider.infobipClient.channels.email, 'send')
    .mockImple...)
 - spy(vi

    // @ts-expect-error
    .spyOn(provider.infobipClient.channels.email, 'send')
    .mockImple...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/infobip/infobip.provider.ts
Tamaño: 2204 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { AuthType, Infobip } from '@infobip-api/sdk';
import { EmailProviderIdEnum } from '@novu/shared';
import {
  ChannelTypeEnum,
  CheckIntegrationResponseEnum,
  ICheckIntegrationResponse,
  IEmailOptions,
  IEmailProvider,
  ISendMessageSuccessResponse,
} from '@novu/stateless';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class InfobipEmailProvider extends BaseProvider implements IEmailProvider {
  protected casing: CasingEnum = CasingEnum.CAMEL_CASE;
  channelType = ChannelTypeEnum.EMAIL as ChannelTypeEnum.EMAIL;
  id = EmailProviderIdEnum.Infobip;

  private infobipClient;

  constructor(
    private config: {
      baseUrl: string;
      apiKey: string;
      from?: string;
    }
  ) {
    super();
    this.infobipClient = new Infobip({
      baseUrl: this.config.baseUrl,
      apiKey: this.config.apiKey,
      authType: AuthType.ApiKey,
    });
  }

  async checkIntegration(options: IEmailOptions): Promise<ICheckIntegrationResponse> {
    try {
      await this.infobipClient.channels.email.send({
        to: options.to,
        from: this.config.from || options.from,
        subject: options.subject,
        text: options.text,
        html: options.html,
      });

      return {
        success: true,
        message: 'Integrated successfully!',
        code: CheckIntegrationResponseEnum.SUCCESS,
      };
    } catch (error) {
      return {
        success: false,
        message: error?.message,
        code: CheckIntegrationResponseEnum.FAILED,
      };
    }
  }

  async sendMessage(
    options: IEmailOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const infobipResponse = await this.infobipClient.channels.email.send(
      this.transform(bridgeProviderData, {
        to: options.to,
        from: options.from || this.config.from,
        subject: options.subject,
        text: options.text,
        html: options.html,
      }).body
    );
    const { messageId } = infobipResponse.data.messages.pop();

    return {
      id: messageId,
      date: new Date().toISOString(),
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class InfobipEmailProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/mailersend/mailersend.provider.spec.ts
Tamaño: 4445 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CheckIntegrationResponseEnum } from '@novu/stateless';
import MailerSend, { Attachment, Recipient } from 'mailersend';
import { expect, test, vi } from 'vitest';
import { MailersendEmailProvider } from './mailersend.provider';

const mockConfig = {
  apiKey: 'SG.1234',
  senderName: 'Novu Team',
};

const mockNovuMessage = {
  to: ['test@test1.com', 'test@test2.com'],
  subject: 'test subject',
  html: '<div> Mail Content </div>',
  text: 'Mail Content',
  from: 'test@tet.com',
  attachments: [{ mime: 'text/plain', file: Buffer.from('dGVzdA=='), name: 'test.txt' }],
  customData: {
    templateId: 'template-id',
    personalization: [{ email: 'test@test1.com', data: { name: 'test1' } }],
  },
};

test('should trigger mailerSend with expected parameters', async () => {
  const provider = new MailersendEmailProvider(mockConfig);
  const spy = vi.spyOn(provider, 'sendMessage').mockImplementation(async () => {
    return {} as any;
  });

  await provider.sendMessage(mockNovuMessage);

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    to: mockNovuMessage.to,
    subject: mockNovuMessage.subject,
    html: mockNovuMessage.html,
    text: mockNovuMessage.text,
    from: mockNovuMessage.from,
    attachments: [
      {
        mime: 'text/plain',
        file: Buffer.from('dGVzdA=='),
        name: 'test.txt',
      },
    ],
    customData: mockNovuMessage.customData,
  });
});

test('should trigger mailerSend correctly', async () => {
  const provider = new MailersendEmailProvider(mockConfig);
  const spy = vi.spyOn(MailerSend.prototype, 'request').mockImplementation(async () => {
    return {} as any;
  });

  const attachment = new Attachment(Buffer.from('ZEdWemRBPT0=').toString(), 'test.txt');
  const recipient1 = new Recipient('test@test1.com', undefined);
  const recipient2 = new Recipient('test@test2.com', undefined);

  await provider.sendMessage(mockNovuMessage);

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith('/email', {
    method: 'POST',
    body: {
      from: { email: mockNovuMessage.from, name: mockConfig.senderName },
      to: [recipient1, recipient2],
      cc: undefined,
      bcc: undefined,
      reply_to: {
        email: undefined,
        name: undefined,
      },
      sendAt: undefined,
      attachments: [attachment],
      subject: mockNovuMessage.subject,
      text: mockNovuMessage.text,
      html: mockNovuMessage.html,
      template_id: mockNovuMessage.customData.templateId,
      variables: undefined,
      personalization: mockNovuMessage.customData.personalization,
      tags: undefined,
    },
  });
});

test('should check provider integration when success', async () => {
  const provider = new MailersendEmailProvider(mockConfig);
  const spy = vi.spyOn(MailerSend.prototype, 'request').mockImplementation(async () => ({
    ok: true,
    status: 200,
  }));

  const messageResponse = await provider.checkIntegration(mockNovuMessage);

  expect(spy).toHaveBeenCalled();
  expect(messageResponse).toStrictEqual({
    success: true,
    message: 'Integrated successfully!',
    code: CheckIntegrationResponseEnum.SUCCESS,
  });
});

test('should check provider integration when bad credentials', async () => {
  const provider = new MailersendEmailProvider(mockConfig);
  const serverMessage = 'Bad credentials';

  const spy = vi.spyOn(MailerSend.prototype, 'request').mockImplementation(async () => ({
    ok: false,
    json: async () => ({
      message: serverMessage,
    }),
    status: 401,
  }));

  const messageResponse = await provider.checkIntegration(mockNovuMessage);

  expect(spy).toHaveBeenCalled();
  expect(messageResponse).toStrictEqual({
    success: false,
    message: serverMessage,
    code: CheckIntegrationResponseEnum.BAD_CREDENTIALS,
  });
});

test('should check provider integration when failed', async () => {
  const provider = new MailersendEmailProvider(mockConfig);
  const serverMessage = 'Server is under maintenance';

  const spy = vi.spyOn(MailerSend.prototype, 'request').mockImplementation(async () => ({
    ok: false,
    json: async () => ({
      message: serverMessage,
    }),
    status: 500,
  }));

  const messageResponse = await provider.checkIntegration(mockNovuMessage);

  expect(spy).toHaveBeenCalled();
  expect(messageResponse).toStrictEqual({
    success: false,
    message: serverMessage,
    code: CheckIntegrationResponseEnum.FAILED,
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - spy(vi.spyOn(provider, 'sendMessage').mockImplementation(async ())
 - spy(vi.spyOn(MailerSend.prototype, 'request').mockImplementation(async ())
 - recipient2(new Recipient('test@test2.com', undefined);

  await provider.sendMessage(mockNovuMessage);

  expec...)
 - spy(vi.spyOn(MailerSend.prototype, 'request').mockImplementation(async ())
 - messageResponse(await provider.checkIntegration(mockNovuMessage);

  expect(spy).toHaveBeenCalled();
  expect(messag...)
 - spy(vi.spyOn(MailerSend.prototype, 'request').mockImplementation(async ())
 - messageResponse(await provider.checkIntegration(mockNovuMessage);

  expect(spy).toHaveBeenCalled();
  expect(messag...)
 - spy(vi.spyOn(MailerSend.prototype, 'request').mockImplementation(async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/mailersend/mailersend.provider.ts
Tamaño: 4322 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EmailProviderIdEnum } from '@novu/shared';
import {
  ChannelTypeEnum,
  CheckIntegrationResponseEnum,
  ICheckIntegrationResponse,
  IEmailOptions,
  IEmailProvider,
  ISendMessageSuccessResponse,
} from '@novu/stateless';

import MailerSend, { Attachment, EmailParams, Recipient } from 'mailersend';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class MailersendEmailProvider extends BaseProvider implements IEmailProvider {
  readonly id = EmailProviderIdEnum.MailerSend;
  protected casing: CasingEnum = CasingEnum.SNAKE_CASE;
  readonly channelType = ChannelTypeEnum.EMAIL as ChannelTypeEnum.EMAIL;
  private mailerSend: MailerSend;

  constructor(
    private config: {
      apiKey: string;
      from?: string;
      senderName?: string;
    }
  ) {
    super();
    this.mailerSend = new MailerSend({ api_key: this.config.apiKey });
  }

  private createRecipients(recipients: IEmailOptions['to']): Recipient[] {
    return Array.isArray(recipients)
      ? recipients.map((recipient) => new Recipient(recipient))
      : [new Recipient(recipients)];
  }

  private getAttachments(attachments: IEmailOptions['attachments']): Attachment[] | null {
    return attachments?.map(
      (attachment) =>
        new Attachment(
          attachment.file.toString('base64'),
          attachment.name,
          attachment.disposition ?? (attachment.cid ? 'inline' : 'attachment'),
          attachment.cid
        )
    );
  }

  private createMailData(options: IEmailOptions): EmailParams {
    const recipients = this.createRecipients(options.to);
    const attachments = this.getAttachments(options.attachments);

    const emailParams = new EmailParams()
      .setFrom(options.from ?? this.config.from)
      .setFromName(options.senderName || this.config.senderName || '')
      .setRecipients(recipients)
      .setSubject(options.subject)
      .setHtml(options.html)
      .setText(options.text)
      .setAttachments(attachments)
      .setPersonalization(options.customData.personalization)
      .setTemplateId(options.customData.templateId);

    if (options.cc && Array.isArray(options.cc)) {
      emailParams.setCc(options.cc.map((ccItem) => new Recipient(ccItem)));
    }

    if (options.bcc && Array.isArray(options.bcc)) {
      emailParams.setBcc(options.bcc.map((ccItem) => new Recipient(ccItem)));
    }

    if (options.replyTo) {
      emailParams.setReplyTo(options.replyTo);
    }

    return emailParams;
  }

  async sendMessage(
    options: IEmailOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const emailParams = this.transform(bridgeProviderData, this.createMailData(options)).body;
    const response = await this.mailerSend.send(emailParams);

    return {
      id: response[0]?.['X-Message-Id'],
      date: new Date().toISOString(),
    };
  }

  async checkIntegration(options: IEmailOptions): Promise<ICheckIntegrationResponse> {
    const emailParams = this.createMailData(options);
    const emailSendResponse = await this.mailerSend.send(emailParams);
    const code = this.mapResponse(emailSendResponse.status);

    if (emailSendResponse.ok && code === CheckIntegrationResponseEnum.SUCCESS) {
      return {
        success: true,
        message: 'Integrated successfully!',
        code,
      };
    }

    const message = await emailSendResponse
      .json()
      .then((res) => res?.message || 'Unknown error occurred')
      .catch(() => 'Unknown error occurred');

    return {
      success: false,
      message,
      code,
    };
  }

  private mapResponse(status: number) {
    switch (status) {
      case 200: // The request was accepted.
      case 201: // Resource was created.
      case 202: // The request was accepted and further actions are taken in the background.
      case 204: // The request was accepted and there is no content to return.
        return CheckIntegrationResponseEnum.SUCCESS;
      case 401: // The provided API token is invalid.
      case 403: // The action is denied for that account or a particular API token.
        return CheckIntegrationResponseEnum.BAD_CREDENTIALS;

      default:
        return CheckIntegrationResponseEnum.FAILED;
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - mailerSend(new MailerSend({ api_key: this.config.apiKey });
  }

  private createRecipients(recipients: IEmailO...)
 - emailParams(new EmailParams()
      .setFrom(options.from ?? this.config.from)
      .setFromName(options.sender...)
 - message(await emailSendResponse
      .json()
      .then((res))
Declaraciones 'export' encontradas:
- export class MailersendEmailProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/mailgun/mailgun.provider.spec.ts
Tamaño: 1530 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import nock from 'nock';
import { expect, test } from 'vitest';
import { MailgunEmailProvider } from './mailgun.provider';

const mockConfig = {
  apiKey: 'SG.1234',
  domain: 'test.com',
  username: 'api',
  from: 'test@test.com',
  senderName: 'Novu Mailgun test',
};

const mockNovuMessage = {
  to: ['test@test2.com'],
  subject: 'test subject',
  html: '<div> Mail Content </div>',
  attachments: [{ mime: 'text/plain', file: Buffer.from('dGVzdA=='), name: 'test.txt' }],
};

test('should trigger mailgun correctly', async () => {
  const provider = new MailgunEmailProvider(mockConfig);

  const api = nock('https://api.mailgun.net');

  api.post('/v3/test.com/messages').reply(200, {
    message: 'Queued. Thank you.',
    id: '<20111114174239.25659.5817@samples.mailgun.org>',
  });

  await provider.sendMessage(mockNovuMessage);

  expect(api.isDone()).toBeTruthy();
  api.done();
});

test('should trigger mailgun correctly with custom baseUrl', async () => {
  const provider = new MailgunEmailProvider({
    ...mockConfig,
    baseUrl: 'https://api.eu.mailgun.net',
  });

  const api = nock('https://api.eu.mailgun.net');

  api
    .post('/v3/test.com/messages', (body) => {
      expect(body.includes('name="o:tag"')).toBeTruthy();

      return true;
    })
    .reply(200, {
      message: 'Queued. Thank you.',
      id: '<20111114174239.25659.5817@samples.mailgun.org>',
    });

  await provider.sendMessage(mockNovuMessage, {
    oTag: ['test'],
  });

  expect(api.isDone()).toBeTruthy();
  api.done();
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - api(nock('https://api.mailgun.net');

  api.post('/v3/test.com/messages').reply(200, {
    message: 'Que...)
 - api(nock('https://api.eu.mailgun.net');

  api
    .post('/v3/test.com/messages', (body))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/mailgun/mailgun.provider.ts
Tamaño: 10029 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EmailProviderIdEnum } from '@novu/shared';
import {
  ChannelTypeEnum,
  CheckIntegrationResponseEnum,
  EmailEventStatusEnum,
  ICheckIntegrationResponse,
  IEmailEventBody,
  IEmailOptions,
  IEmailProvider,
  ISendMessageSuccessResponse,
} from '@novu/stateless';
import axios from 'axios';
import { createHmac } from 'crypto';
import formData from 'form-data';
import Mailgun from 'mailgun.js';
import { IMailgunClient } from 'mailgun.js/interfaces/IMailgunClient';
import { MailgunMessageData } from 'mailgun.js/interfaces/Messages';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

enum WebhooksIds {
  DELIVERED = 'delivered',
  OPENED = 'opened',
  CLICKED = 'clicked',
  UNSUBSCRIBED = 'unsubscribed',
  COMPLAINED = 'complained',
  PERMANENT_FAIL = 'permanent_fail',
  TEMPORARY_FAIL = 'temporary_fail',
}

export class MailgunEmailProvider extends BaseProvider implements IEmailProvider {
  id = EmailProviderIdEnum.Mailgun;

  channelType = ChannelTypeEnum.EMAIL as ChannelTypeEnum.EMAIL;

  protected casing = CasingEnum.CAMEL_CASE;
  protected override keyCaseObject: Record<string, string> = {
    ampHtml: 'amp-html',
    tVersion: 't:version',
    tText: 't:text',
    oTag: 'o:tag',
    oDkim: 'o:dkim',
    oDeliverytime: 'o:deliverytime',
    oDeliverytimeOptimizePeriod: 'o:deliverytime-optimize-period',
    oTimeZoneLocalize: 'o:time-zone-localize',
    oTestmode: 'o:testmode',
    oTracking: 'o:tracking',
    oTrackingClicks: 'o:tracking-clicks',
    oTrackingOpens: 'o:tracking-opens',
    oRequireTls: 'o:require-tls',
    oSkipVerification: 'o:skip-verification',
    recipientVariables: 'recipient-variables',
  };

  private mailgunClient: IMailgunClient;

  constructor(
    private config: {
      apiKey: string;
      baseUrl?: string;
      username: string;
      domain: string;
      from: string;
      senderName: string;
      webhookSigningKey?: string;
    }
  ) {
    super();
    const mailgun = new Mailgun(formData);

    this.mailgunClient = mailgun.client({
      username: config.username,
      key: config.apiKey,
      url: config.baseUrl || 'https://api.mailgun.net',
    });
  }

  async sendMessage(
    emailOptions: IEmailOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const senderName = emailOptions.senderName || this.config.senderName;
    const fromAddress = emailOptions.from || this.config.from;
    const data = {
      from: senderName ? `${senderName} <${fromAddress}>` : fromAddress,
      to: emailOptions.to,
      subject: emailOptions.subject,
      html: emailOptions.html,
      cc: emailOptions.cc?.join(','),
      bcc: emailOptions.bcc?.join(','),
      attachment: emailOptions.attachments
        ?.filter((attachment) => !attachment.cid)
        ?.map((attachment) => {
          return {
            data: attachment.file,
            filename: attachment.name,
          };
        }),
      inline: emailOptions.attachments
        ?.filter((attachment) => Boolean(attachment.cid))
        ?.map((attachment) => {
          return {
            data: attachment.file,
            filename: attachment.name,
          };
        }),
    };

    if (emailOptions.replyTo) {
      data['h:Reply-To'] = emailOptions.replyTo;
    }

    const mailgunMessageData: Partial<MailgunMessageData> = this.transform(bridgeProviderData, data).body;

    const response = await this.mailgunClient.messages.create(
      this.config.domain,
      mailgunMessageData as MailgunMessageData
    );

    return {
      id: response.id,
      date: new Date().toISOString(),
    };
  }
  async checkIntegration(_options: IEmailOptions): Promise<ICheckIntegrationResponse> {
    return {
      success: true,
      message: 'Integrated successfully!',
      code: CheckIntegrationResponseEnum.SUCCESS,
    };
  }

  async autoConfigureInboundWebhook(configurations: { webhookUrl: string }): Promise<{
    success: boolean;
    message?: string;
    configurations?: {
      inboundWebhookEnabled: boolean;
      inboundWebhookSigningKey: string;
    };
  }> {
    try {
      // Mailgun webhook events to configure
      const events: WebhooksIds[] = [
        WebhooksIds.DELIVERED,
        WebhooksIds.OPENED,
        WebhooksIds.CLICKED,
        WebhooksIds.PERMANENT_FAIL,
      ];
      const webhookUrl = configurations.webhookUrl;

      // Configure webhooks for each event type
      for (const event of events) {
        try {
          const response = await this.mailgunClient.webhooks.create(this.config.domain, event, webhookUrl);

          if (!response) {
            return {
              success: false,
              message: `Failed to configure webhook for event: ${event}`,
            };
          }
        } catch (error) {
          throw new Error(`Failed to configure webhook for event ${event}, ${error.details}`);
        }
      }

      // Step 2: Retrieve HTTP Webhook Signing Key from Mailgun API
      let webhookSigningKey = null;
      try {
        // Use axios to make HTTP request since mailgun client doesn't have a generic request method
        const baseUrl = this.config.baseUrl || 'https://api.mailgun.net';
        const authHeader = `Basic ${Buffer.from(`api:${this.config.apiKey}`).toString('base64')}`;

        const response = await axios.get(`${baseUrl}/v5/accounts/http_signing_key`, {
          headers: {
            Authorization: authHeader,
          },
        });

        if (response.status === 200 && response.data?.http_signing_key) {
          webhookSigningKey = response.data.http_signing_key;
        }
      } catch (_signingKeyError) {
        // If API call fails, continue without signing key but notify user
      }

      if (!webhookSigningKey) {
        return {
          success: true,
          message:
            'Mailgun webhooks configured successfully. Please add your HTTP Webhook Signing Key from Mailgun Control Panel (API Security → HTTP webhook signing key) to enable signature verification.',
          configurations: {
            inboundWebhookEnabled: true,
            inboundWebhookSigningKey: '',
          },
        };
      }

      return {
        success: true,
        message: 'Mailgun webhooks configured successfully for email events with signature verification enabled',
        configurations: {
          inboundWebhookEnabled: true,
          inboundWebhookSigningKey: webhookSigningKey,
        },
      };
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';

      return {
        success: false,
        message: `Error configuring Mailgun webhooks: ${errorMessage}`,
      };
    }
  }

  async verifySignature({
    rawBody: _rawBody,
    headers: _headers,
    body,
  }: {
    rawBody: unknown;
    headers?: Record<string, string>;
    body?: Record<string, unknown>;
  }): Promise<{
    success: boolean;
    message?: string;
  }> {
    try {
      const bodySignature = body.signature as { timestamp: string; token: string; signature: string };
      const timestamp = bodySignature.timestamp;
      const token = bodySignature.token;
      const signature = bodySignature.signature;

      const webhookSigningKey = this.config.webhookSigningKey;

      if (!webhookSigningKey) {
        return {
          success: true,
          message: 'Mailgun signature verification is not configured',
        };
      }

      if (!timestamp || !token || !signature) {
        const missingFields = [!timestamp ? 'timestamp' : '', !token ? 'token' : '', !signature ? 'signature' : '']
          .filter(Boolean)
          .join(', ');

        return { success: false, message: `Missing required fields: ${missingFields}` };
      }

      const data = timestamp + token;
      const computedSignature = createHmac('sha256', webhookSigningKey).update(data).digest('hex');

      const isValid = computedSignature === signature;

      return {
        success: isValid,
        message: isValid ? 'Mailgun signature verification successful' : 'Mailgun signature verification failed',
      };
    } catch (error) {
      return { success: false, message: `Error verifying signature: ${error.message}` };
    }
  }

  getMessageId(body: any): string[] {
    try {
      const messageId = body['event-data']?.message?.headers?.['message-id'] || body['event-data']?.id;

      if (!messageId) {
        return [];
      }

      // Mailgun send requests return message IDs wrapped in < >
      return [`<${messageId}>`];
    } catch {
      return [];
    }
  }

  parseEventBody(body: any): IEmailEventBody | undefined {
    try {
      const eventData = body['event-data'];

      if (!eventData) {
        return undefined;
      }

      const status = this.getStatus(eventData.event);

      if (status === undefined) {
        return undefined;
      }

      const messageId = eventData.message?.headers?.['message-id'] || eventData.id;

      return {
        status,
        date: new Date(eventData.timestamp * 1000).toISOString(),
        externalId: messageId,
        attempts: eventData['delivery-status']?.['attempt-no'] || 1,
        response: eventData['delivery-status']?.description || eventData.reason || '',
        row: JSON.stringify(eventData),
      };
    } catch {
      return undefined;
    }
  }

  private getStatus(event: string): EmailEventStatusEnum | undefined {
    switch (event) {
      case 'delivered':
        return EmailEventStatusEnum.DELIVERED;
      case 'opened':
        return EmailEventStatusEnum.OPENED;
      case 'clicked':
        return EmailEventStatusEnum.CLICKED;
      case 'unsubscribed':
        return EmailEventStatusEnum.UNSUBSCRIBED;
      case 'complained':
        return EmailEventStatusEnum.COMPLAINT;
      case 'permanent_fail':
      case 'failed':
        return EmailEventStatusEnum.REJECTED;
      default:
        return undefined;
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - data({
      from: senderName ? `${senderName} <${fromAddress}>` : fromAddress,
      to: emailOptions.to...)
Declaraciones 'export' encontradas:
- export class MailgunEmailProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/mailjet/mailjet.provider.spec.ts
Tamaño: 3297 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, test, vi } from 'vitest';
import { MailjetEmailProvider } from './mailjet.provider';

const response = {
  response: {
    headers: {
      'content-length': '287',
      'content-type': 'application/json; charset=UTF-8',
      'x-mj-request-guid': 'a9e7-437c-84f8-e2c2d5958014',
      date: 'Sun, 24 Oct 2021 15:56:29 GMT',
      connection: 'close',
    },
    status: 200,
  },
  body: {
    Messages: [
      {
        Status: 'success',
        To: [
          {
            Email: 'testTo@test2.com',
            MessageUUID: 'a6da-4b1b-ad92-066cfb314d66',
            MessageID: '5764607616719',
            MessageHref: 'https://api.mailjet.com/v3/REST/message/5764607616719',
          },
        ],
        Cc: [],
        Bcc: [],
      },
    ],
  },
};

const requestFn = vi.fn().mockResolvedValue(response);

vi.mock('node-mailjet', async (importOriginal) => {
  const actual = await importOriginal<typeof import('node-mailjet')>();

  return {
    ...actual,
    Client: vi.fn().mockImplementation(() => {
      return {
        post: vi.fn().mockImplementation(() => {
          return {
            request: requestFn,
          };
        }),
      };
    }),
  };
});

const mockConfig = {
  apiKey: 'testApiKey',
  apiSecret: 'testSecret',
  from: 'testFrom@test.com',
  senderName: 'testSender',
};
const mockMessageConfig = {
  to: ['testTo@test2.com'],
  subject: 'test subject',
  html: '<div> Mail Content </div>',
};

test('should trigger mailjet library correctly and return proper response', async () => {
  const provider = new MailjetEmailProvider(mockConfig);

  const messageResponse = await provider.sendMessage(mockMessageConfig, {
    textPart: 'test',
  });

  expect(requestFn).toHaveBeenCalledTimes(1);
  expect(requestFn).toHaveBeenCalledWith({
    Messages: [
      {
        From: { Email: mockConfig.from, Name: mockConfig.senderName },
        HTMLPart: mockMessageConfig.html,
        Subject: mockMessageConfig.subject,
        TextPart: 'test',
        To: [{ Email: mockMessageConfig.to[0] }],
      },
    ],
  });
  expect(messageResponse.id).toBe('a9e7-437c-84f8-e2c2d5958014');
  expect(messageResponse.date).toBeDefined();
});

test('should trigger mailjet library correctly and return proper response with _passthrough', async () => {
  const provider = new MailjetEmailProvider(mockConfig);

  const messageResponse = await provider.sendMessage(mockMessageConfig, {
    textPart: 'test',
    _passthrough: {
      body: {
        HiHello: 'test',
      },
    },
  });

  expect(requestFn).toHaveBeenCalledWith({
    Messages: [
      {
        From: { Email: mockConfig.from, Name: mockConfig.senderName },
        HTMLPart: mockMessageConfig.html,
        Subject: mockMessageConfig.subject,
        TextPart: 'test',
        HiHello: 'test',
        To: [{ Email: mockMessageConfig.to[0] }],
      },
    ],
  });
  expect(messageResponse.id).toBe('a9e7-437c-84f8-e2c2d5958014');
  expect(messageResponse.date).toBeDefined();
});

test('should check provider integration correctly', async () => {
  const provider = new MailjetEmailProvider(mockConfig);
  const messageResponse = await provider.checkIntegration(mockMessageConfig);

  expect(requestFn).toHaveBeenCalled();
  expect(messageResponse.success).toBe(true);
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - requestFn(vi.fn().mockResolvedValue(response);

vi.mock('node-mailjet', async (importOriginal))
 - actual(await importOriginal<typeof import('node-mailjet')>();

  return {
    ...actual,
    Client: vi.fn(...)
 - mockMessageConfig({
  to: ['testTo@test2.com'],
  subject: 'test subject',
  html: '<div> Mail Content </div>',
};

te...)
 - messageResponse(await provider.sendMessage(mockMessageConfig, {
    textPart: 'test',
  });

  expect(requestFn).toH...)
 - messageResponse(await provider.sendMessage(mockMessageConfig, {
    textPart: 'test',
    _passthrough: {
      body...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/mailjet/mailjet.provider.ts
Tamaño: 5210 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EmailProviderIdEnum } from '@novu/shared';
import {
  ChannelTypeEnum,
  CheckIntegrationResponseEnum,
  EmailEventStatusEnum,
  ICheckIntegrationResponse,
  IEmailEventBody,
  IEmailOptions,
  IEmailProvider,
  ISendMessageSuccessResponse,
} from '@novu/stateless';
import { Client, type SendEmailV3_1 } from 'node-mailjet';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

const MAILJET_API_VERSION = 'v3.1';

export class MailjetEmailProvider extends BaseProvider implements IEmailProvider {
  protected casing: CasingEnum = CasingEnum.PASCAL_CASE;
  id = EmailProviderIdEnum.Mailjet;
  channelType = ChannelTypeEnum.EMAIL as ChannelTypeEnum.EMAIL;

  protected override keyCaseObject: Record<string, string> = {
    contentId: 'ContentID',
    htmlPart: 'HTMLPart',
    templateId: 'TemplateID',
    customId: 'CustomID',
    urlTags: 'URLTags',
  };

  private mailjetClient: Client;
  constructor(
    private config: {
      apiKey: string;
      apiSecret: string;
      from: string;
      senderName: string;
    }
  ) {
    super();
    this.mailjetClient = new Client({
      apiKey: config.apiKey,
      apiSecret: config.apiSecret,
    });
  }

  async sendMessage(
    emailOptions: IEmailOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const response = await this.mailjetClient
      .post('send', {
        version: MAILJET_API_VERSION,
      })
      .request<SendEmailV3_1.Response>({
        ...this.createMailData(emailOptions, bridgeProviderData),
      });

    const { body, response: clientResponse } = response;

    return {
      id: clientResponse.headers['x-mj-request-guid'],
      date: new Date().toISOString(),
    };
  }

  async checkIntegration(options: IEmailOptions): Promise<ICheckIntegrationResponse> {
    const send = this.mailjetClient.post('send', {
      version: MAILJET_API_VERSION,
    });
    const requestObject = this.createMailData(options);
    try {
      await send.request(requestObject);

      return {
        success: true,
        message: 'Integrated successfully!',
        code: CheckIntegrationResponseEnum.SUCCESS,
      };
    } catch (error) {
      return {
        success: false,
        message: error.message,
        code: CheckIntegrationResponseEnum.BAD_CREDENTIALS,
      };
    }
  }

  private createMailData(
    options: IEmailOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): SendEmailV3_1.Body {
    const message: SendEmailV3_1.Message = this.transform<SendEmailV3_1.Message>(bridgeProviderData, {
      From: {
        Email: options.from || this.config.from,
        Name: options.senderName || this.config.senderName,
      },
      To: options.to.map((email) => ({
        Email: email,
      })) as SendEmailV3_1.EmailAddressTo[],
      Cc: options.cc?.map((ccItem) => ({ Email: ccItem })),
      Bcc: options.bcc?.map((ccItem) => ({ Email: ccItem })),
      Subject: options.subject,
      TextPart: options.text,
      HTMLPart: options.html,
      Attachments: options.attachments
        ?.filter((attachment) => !attachment.cid)
        ?.map((attachment) => ({
          ContentType: attachment.mime,
          Filename: attachment.name,
          Base64Content: attachment.file.toString('base64'),
        })),
      InlinedAttachments: options.attachments
        ?.filter((attachment) => attachment.cid)
        ?.map((attachment) => ({
          ContentType: attachment.mime,
          Filename: attachment.name,
          Base64Content: attachment.file.toString('base64'),
          ContentID: attachment.cid,
        })),
    }).body;

    if (options.replyTo) {
      message.ReplyTo.Email = options.replyTo;
    }

    return {
      Messages: [message],
    };
  }

  getMessageId(body: any | any[]): string[] {
    if (Array.isArray(body)) {
      return body.map((item) => item.MessageID);
    }

    return [body.MessageID];
  }

  parseEventBody(body: any | any[], identifier: string): IEmailEventBody | undefined {
    if (Array.isArray(body)) {
      body = body.find((item) => item.MessageID === identifier);
    }

    if (!body) {
      return undefined;
    }

    const status = this.getStatus(body.event);

    if (status === undefined) {
      return undefined;
    }

    return {
      status,
      date: new Date().toISOString(),
      externalId: body.MessageID,
      attempts: body.attempt ? parseInt(body.attempt, 10) : 1,
      response: body.response ?? '',
      row: body,
    };
  }

  private getStatus(event: string): EmailEventStatusEnum | undefined {
    switch (event) {
      case 'open':
        return EmailEventStatusEnum.OPENED;
      case 'bounce':
        return EmailEventStatusEnum.BOUNCED;
      case 'click':
        return EmailEventStatusEnum.CLICKED;
      case 'sent':
        return EmailEventStatusEnum.SENT;
      case 'blocked':
        return EmailEventStatusEnum.BLOCKED;
      case 'spam':
        return EmailEventStatusEnum.SPAM;
      case 'unsub':
        return EmailEventStatusEnum.UNSUBSCRIBED;
      default:
        return undefined;
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - Message(this.transform<SendEmailV3_1.Message>(bridgeProviderData, {
      From: {
        Email: options.fro...)
 - Email(options.replyTo;
    }

    return {
      Messages: [message],
    };
  }

  getMessageId(body: any...)
 - body(body.find((item))
Declaraciones 'export' encontradas:
- export class MailjetEmailProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/mailtrap/mailtrap.provider.spec.ts
Tamaño: 1611 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CheckIntegrationResponseEnum } from '@novu/stateless';
import { MailtrapClient, SendResponse } from 'mailtrap';
import { expect, test, vi } from 'vitest';
import { MailtrapEmailProvider } from './mailtrap.provider';

const mockConfig = {
  apiKey: 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',
  from: 'test@test.com',
};

const mockNovuMessage = {
  from: 'test@test.com',
  to: ['test@test.com'],
  html: '<div> Mail Content </div>',
  subject: 'Test subject',
};

const mockMailtrapResponse: SendResponse = {
  success: true,
  message_ids: ['0c7fd939-02cf-11ed-88c2-0a58a9feac02'],
};

test('should trigger mailtrap library correctly', async () => {
  const provider = new MailtrapEmailProvider(mockConfig);
  const spy = vi.spyOn(MailtrapClient.prototype, 'send').mockImplementation(async () => mockMailtrapResponse);

  await provider.sendMessage(mockNovuMessage);

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    from: { email: mockNovuMessage.from },
    to: [{ email: mockNovuMessage.to[0] }],
    html: mockNovuMessage.html,
    subject: mockNovuMessage.subject,
  });
});

test('should check integration successfully', async () => {
  const provider = new MailtrapEmailProvider(mockConfig);
  const spy = vi.spyOn(MailtrapClient.prototype, 'send').mockImplementation(async () => mockMailtrapResponse);

  const messageResponse = await provider.checkIntegration(mockNovuMessage);

  expect(spy).toHaveBeenCalled();
  expect(messageResponse).toStrictEqual({
    success: true,
    message: 'Integrated successfully!',
    code: CheckIntegrationResponseEnum.SUCCESS,
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - SendResponse({
  success: true,
  message_ids: ['0c7fd939-02cf-11ed-88c2-0a58a9feac02'],
};

test('should trigger...)
 - spy(vi.spyOn(MailtrapClient.prototype, 'send').mockImplementation(async ())
 - spy(vi.spyOn(MailtrapClient.prototype, 'send').mockImplementation(async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/mailtrap/mailtrap.provider.ts
Tamaño: 2583 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EmailProviderIdEnum } from '@novu/shared';
import {
  ChannelTypeEnum,
  CheckIntegrationResponseEnum,
  ICheckIntegrationResponse,
  IEmailOptions,
  IEmailProvider,
  ISendMessageSuccessResponse,
} from '@novu/stateless';
import { Address, Attachment, Mail, MailtrapClient } from 'mailtrap';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class MailtrapEmailProvider extends BaseProvider implements IEmailProvider {
  id = EmailProviderIdEnum.Mailtrap;
  protected casing: CasingEnum = CasingEnum.SNAKE_CASE;
  channelType = ChannelTypeEnum.EMAIL as ChannelTypeEnum.EMAIL;
  private readonly mailtrapClient: MailtrapClient;

  constructor(
    private config: {
      apiKey: string;
      from: string;
    }
  ) {
    super();
    this.mailtrapClient = new MailtrapClient({
      token: config.apiKey,
    });
  }

  async checkIntegration(options: IEmailOptions): Promise<ICheckIntegrationResponse> {
    try {
      const result = await this.sendWithMailtrap(options);

      return {
        success: result.success,
        message: 'Integrated successfully!',
        code: CheckIntegrationResponseEnum.SUCCESS,
      };
    } catch (error) {
      return {
        success: false,
        message: error?.message || 'Integration check failed.',
        code: CheckIntegrationResponseEnum.FAILED,
      };
    }
  }

  async sendMessage(
    options: IEmailOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const response = await this.sendWithMailtrap(options, bridgeProviderData);

    return {
      id: response.message_ids[0],
      date: new Date().toISOString(),
    };
  }

  private sendWithMailtrap(options: IEmailOptions, bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}) {
    return this.mailtrapClient.send(
      this.transform<Mail>(bridgeProviderData, {
        to: options.to.map(this.mapAddress),
        from: this.mapAddress(options.from || this.config.from),
        subject: options.subject,
        text: options.text,
        html: options.html,
        bcc: options.bcc?.map(this.mapAddress),
        cc: options.cc?.map(this.mapAddress),
        attachments: options.attachments?.map((attachment) => ({
          filename: attachment.name,
          content: attachment.file,
          type: attachment.mime,
          content_id: attachment.cid,
        })),
      }).body
    );
  }

  private mapAddress(email: string): Address {
    return { email };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class MailtrapEmailProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/mandrill/mandril.interface.ts
Tamaño: 1049 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export interface IMandrilInterface {
  messages: {
    send: (options: IMandrillSendOptions) => Promise<IMandrillSendResponse[]>;
    sendTemplate: (options: IMandrillTemplateSendOptions) => Promise<IMandrillSendResponse[]>;
  };
  users: {
    ping: () => Promise<string>;
  };
}

interface IMandrillSendOptionsMessage {
  from_email: string;
  from_name: string;
  subject: string;
  html: string;
  to: { email: string; type: 'to' | string }[];
  attachments: IMandrillAttachment[];
}
interface IMandrillTemplateSendOptionsMessage extends IMandrillSendOptionsMessage {
  global_merge_vars?: { name: string; content: string }[];
}

export interface IMandrillSendOptions {
  message: IMandrillSendOptionsMessage;
}

export interface IMandrillTemplateSendOptions {
  template_name: string;
  template_content: { name: string; content: string }[];
  message: IMandrillTemplateSendOptionsMessage;
}

export interface IMandrillAttachment {
  content: string;
  type: string;
  name: string;
}

export interface IMandrillSendResponse {
  _id: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  interface
- export  interface
- export  interface
- export  interface
- export  interface

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/mandrill/mandrill.provider.spec.ts
Tamaño: 3920 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, test, vi } from 'vitest';
import { MandrillProvider } from './mandrill.provider';

const mockConfig = {
  apiKey: 'API_KEY',
  from: 'test@test.com',
  senderName: 'Test Sender',
};

test('should send a standard email through Mandrill', async () => {
  const provider = new MandrillProvider(mockConfig);
  const spy = vi.spyOn(provider['transporter'].messages, 'send').mockImplementation(async () => {
    return [{}] as any;
  });

  const mockNovuMessage = {
    to: ['test2@test.com'],
    subject: 'test subject',
    html: '<div> Mail Content </div>',
    attachments: [
      {
        mime: 'text/plain',
        file: Buffer.from('test'),
        name: 'test.txt',
      },
    ],
  };

  await provider.sendMessage(mockNovuMessage);

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    message: {
      from_email: mockConfig.from,
      from_name: mockConfig.senderName,
      subject: mockNovuMessage.subject,
      html: mockNovuMessage.html,
      to: [{ email: mockNovuMessage.to[0], type: 'to' }],
      attachments: [
        {
          content: Buffer.from('test').toString('base64'),
          type: 'text/plain',
          name: 'test.txt',
        },
      ],
    },
  });
});

test('should send an email using a Mandrill template', async () => {
  const provider = new MandrillProvider(mockConfig);
  const spy = vi.spyOn(provider['transporter'].messages, 'sendTemplate').mockImplementation(async () => {
    return [{}] as any;
  });

  const mockNovuMessage = {
    to: ['test2@test.com'],
    subject: 'test subject',
    html: undefined,
    customData: {
      templateId: 'welcome-template',
      variables: {
        FIRST_NAME: 'John',
        LAST_NAME: 'Doe',
      },
    },
  };

  await provider.sendMessage(mockNovuMessage);

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    template_name: mockNovuMessage.customData.templateId,
    template_content: [],
    message: {
      from_email: mockConfig.from,
      from_name: mockConfig.senderName,
      subject: mockNovuMessage.subject,
      html: mockNovuMessage.html,
      to: [{ email: mockNovuMessage.to[0], type: 'to' }],
      global_merge_vars: [
        { name: 'FIRST_NAME', content: 'John' },
        { name: 'LAST_NAME', content: 'Doe' },
      ],
    },
  });
});

test('should trigger mandrill correctly with _passthrough', async () => {
  const provider = new MandrillProvider(mockConfig);
  const spy = vi.spyOn(provider['transporter'].messages, 'send').mockImplementation(async () => {
    return [{}] as any;
  });
  const mockNovuMessage = {
    to: ['test2@test.com'],
    subject: 'test subject',
    html: '<div> Mail Content </div>',
    attachments: [
      {
        mime: 'text/plain',
        file: Buffer.from('test'),
        name: 'test.txt',
      },
    ],
  };

  await provider.sendMessage(mockNovuMessage, {
    _passthrough: {
      body: {
        message: {
          from_email: 'hello@test.com',
        },
      },
    },
  });

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    message: {
      from_email: 'hello@test.com',
      from_name: mockConfig.senderName,
      subject: mockNovuMessage.subject,
      html: mockNovuMessage.html,
      to: [
        {
          email: mockNovuMessage.to[0],
          type: 'to',
        },
      ],
      attachments: [
        {
          content: Buffer.from('test').toString('base64'),
          type: 'text/plain',
          name: 'test.txt',
        },
      ],
    },
  });
});

test('should check provider integration correctly', async () => {
  const provider = new MandrillProvider(mockConfig);
  const spy = vi.spyOn(provider['transporter'].users, 'ping').mockImplementation(async () => {
    return 'PONG!';
  });

  const response = await provider.checkIntegration();
  expect(spy).toHaveBeenCalled();
  expect(response.success).toBe(true);
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - mockConfig({
  apiKey: 'API_KEY',
  from: 'test@test.com',
  senderName: 'Test Sender',
};

test('should send a...)
 - spy(vi.spyOn(provider['transporter'].messages, 'send').mockImplementation(async ())
 - mockNovuMessage({
    to: ['test2@test.com'],
    subject: 'test subject',
    html: '<div> Mail Content </div>',
  ...)
 - spy(vi.spyOn(provider['transporter'].messages, 'sendTemplate').mockImplementation(async ())
 - mockNovuMessage({
    to: ['test2@test.com'],
    subject: 'test subject',
    html: undefined,
    customData: {
  ...)
 - spy(vi.spyOn(provider['transporter'].messages, 'send').mockImplementation(async ())
 - mockNovuMessage({
    to: ['test2@test.com'],
    subject: 'test subject',
    html: '<div> Mail Content </div>',
  ...)
 - spy(vi.spyOn(provider['transporter'].users, 'ping').mockImplementation(async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/mandrill/mandrill.provider.ts
Tamaño: 6032 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import mailchimp from '@mailchimp/mailchimp_transactional';
import { EmailProviderIdEnum } from '@novu/shared';
import {
  ChannelTypeEnum,
  CheckIntegrationResponseEnum,
  EmailEventStatusEnum,
  ICheckIntegrationResponse,
  IEmailEventBody,
  IEmailOptions,
  IEmailProvider,
  ISendMessageSuccessResponse,
} from '@novu/stateless';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';
import { IMandrilInterface, IMandrillSendOptions, IMandrillTemplateSendOptions } from './mandril.interface';

export enum MandrillStatusEnum {
  OPENED = 'open',
  SENT = 'send',
  DEFERRED = 'deferral',
  HARD_BOUNCED = 'hard_bounce',
  SOFT_BOUNCED = 'soft_bounce',
  CLICKED = 'click',
  SPAM = 'spam',
  UNSUBSCRIBED = 'unsub',
  REJECTED = 'reject',
  DELIVERED = 'delivered',
}

export const isMandrillTemplateSendOptions = (
  options: IMandrillSendOptions | IMandrillTemplateSendOptions
): options is IMandrillTemplateSendOptions => {
  return 'template_name' in options && 'template_content' in options && Array.isArray(options.template_content);
};

export class MandrillProvider extends BaseProvider implements IEmailProvider {
  id = EmailProviderIdEnum.Mandrill;
  protected casing = CasingEnum.SNAKE_CASE;
  channelType = ChannelTypeEnum.EMAIL as ChannelTypeEnum.EMAIL;

  private transporter: IMandrilInterface;

  constructor(
    private config: {
      apiKey: string;
      from: string;
      senderName: string;
    }
  ) {
    super();
    this.transporter = mailchimp(this.config.apiKey);
  }

  async sendMessage(
    emailOptions: IEmailOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const mailData = this.createMailData(emailOptions);
    const mandrillSendOption = this.transform<IMandrillSendOptions | IMandrillTemplateSendOptions>(
      bridgeProviderData,
      mailData
    ).body;
    let response;

    if (isMandrillTemplateSendOptions(mandrillSendOption)) {
      response = await this.transporter.messages.sendTemplate(mandrillSendOption);
    } else {
      response = await this.transporter.messages.send(mandrillSendOption);
    }

    return {
      id: response[0]._id,
      date: new Date().toISOString(),
    };
  }

  private createMailData(emailOptions: IEmailOptions) {
    const message = {
      from_email: emailOptions.from || this.config.from,
      from_name: emailOptions.senderName || this.config.senderName,
      subject: emailOptions.subject,
      html: emailOptions.html,
      to: this.mapTo(emailOptions),
      attachments: emailOptions.attachments?.map((attachment) => ({
        content: attachment.file.toString('base64'),
        type: attachment.mime,
        name: attachment?.name,
      })),
    };

    const { customData } = emailOptions;

    if (customData?.templateId) {
      const templateGlobalMergeVars = customData.variables
        ? Object.keys(customData.variables)
            .map((key) => [key, customData.variables[key]])
            .map(([name, content]) => ({
              name,
              content: String(content),
            }))
        : [];

      return {
        template_name: customData?.templateId,
        template_content: [],
        message: {
          ...message,
          html: undefined,
          global_merge_vars: templateGlobalMergeVars,
        },
      };
    } else {
      return { message };
    }
  }

  private mapTo(emailOptions: IEmailOptions) {
    const ccs = (emailOptions.cc || []).map((item) => ({
      email: item,
      type: 'cc',
    }));

    const bcc = (emailOptions.bcc || []).map((item) => ({
      email: item,
      type: 'bcc',
    }));

    return [
      ...emailOptions.to.map((item) => ({
        email: item,
        type: 'to',
      })),
      ...ccs,
      ...bcc,
    ];
  }

  async checkIntegration(): Promise<ICheckIntegrationResponse> {
    try {
      await this.transporter.users.ping();

      return {
        success: true,
        message: 'Integrated successfully!',
        code: CheckIntegrationResponseEnum.SUCCESS,
      };
    } catch (error) {
      return {
        success: false,
        message: error?.message,
        code: CheckIntegrationResponseEnum.FAILED,
      };
    }
  }

  getMessageId(body: any | any[]): string[] {
    if (Array.isArray(body)) {
      return body.map((item) => item._id);
    }

    return [body._id];
  }

  parseEventBody(body: any | any[], identifier: string): IEmailEventBody | undefined {
    if (Array.isArray(body)) {
      body = body.find((item) => item._id === identifier);
    }

    if (!body) {
      return undefined;
    }

    const status = this.getStatus(body.event);

    if (status === undefined) {
      return undefined;
    }

    return {
      status,
      date: new Date().toISOString(),
      externalId: body._id,
      attempts: body.attempt ? parseInt(body.attempt, 10) : 1,
      response: body.response ? body.response : '',
      row: body,
    };
  }

  private getStatus(event: string): EmailEventStatusEnum | undefined {
    switch (event) {
      case MandrillStatusEnum.OPENED:
        return EmailEventStatusEnum.OPENED;
      case MandrillStatusEnum.HARD_BOUNCED:
        return EmailEventStatusEnum.BOUNCED;
      case MandrillStatusEnum.CLICKED:
        return EmailEventStatusEnum.CLICKED;
      case MandrillStatusEnum.SENT:
        return EmailEventStatusEnum.SENT;
      case MandrillStatusEnum.SPAM:
        return EmailEventStatusEnum.SPAM;
      case MandrillStatusEnum.REJECTED:
        return EmailEventStatusEnum.REJECTED;
      case MandrillStatusEnum.SOFT_BOUNCED:
        return EmailEventStatusEnum.BOUNCED;
      case MandrillStatusEnum.UNSUBSCRIBED:
        return EmailEventStatusEnum.UNSUBSCRIBED;
      case MandrillStatusEnum.DEFERRED:
        return EmailEventStatusEnum.DEFERRED;
      case MandrillStatusEnum.DELIVERED:
        return EmailEventStatusEnum.DELIVERED;
      default:
        return undefined;
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - isMandrillTemplateSendOptions(options: IMandrillSendOptions | IMandrillTemplateSendOptions
): options is IMandrillTemplateSendOpti...)
 - message({
      from_email: emailOptions.from || this.config.from,
      from_name: emailOptions.senderName ...)
 - templateGlobalMergeVars(customData.variables
        ? Object.keys(customData.variables)
            .map((key))
 - ccs(emailOptions.cc || []).map((item))
 - bcc(emailOptions.bcc || []).map((item))
 - body(body.find((item))
Declaraciones 'export' encontradas:
- export  enum
- export  const
- export class MandrillProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/netcore/netcore-types.ts
Tamaño: 1049 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export interface IRecipient {
  name?: string;
  email: string;
}

export interface IContent {
  type: 'html' | 'amp';
  value: string;
}

export interface IAttachment {
  name: string;
  content: string;
}

export interface IPersonalizations {
  attributes?: Record<string, string>;
  to?: IRecipient[];
  cc?: Pick<IRecipient, 'email'>[];
  bcc?: Pick<IRecipient, 'email'>[];
  token_to?: string;
  token_cc?: string;
  attachments?: IAttachment[];
  headers?: Record<string, unknown>;
}

export interface ISettings {
  open_track?: boolean;
  click_track?: boolean;
  unsubscribe_track?: boolean;
  ip_pool?: string;
}

export interface IEmailBody {
  from: IRecipient;
  reply_to?: string;
  subject: string;
  template_id?: number;
  tags?: string[];
  content: IContent[];
  attachments?: IAttachment[];
  personalizations?: IPersonalizations[];
  settings?: ISettings;
  bcc?: Pick<IRecipient, 'email'>[];
  schedule?: number;
}

export interface IEmailResponse {
  data: {
    message_id: string;
  };
  message: string;
  status: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  interface
- export  interface
- export  interface
- export  interface
- export  interface
- export  interface
- export  interface

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/netcore/netcore.provider.spec.ts
Tamaño: 3411 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IEmailOptions } from '@novu/stateless';
import axios from 'axios';
import { beforeEach, describe, expect, Mocked, test, vi } from 'vitest';
import { NetCoreProvider } from './netcore.provider';
import { IEmailBody } from './netcore-types';

vi.mock('axios');

const mockConfig = {
  apiKey: 'test-key',
  from: 'netcore',
  senderName: "Novu's Team",
};

const mockEmailOptions: IEmailOptions = {
  html: '<div> Mail Content </div>',
  subject: 'test subject',
  from: 'test@test1.com',
  to: ['test@to.com'],
  cc: ['test@cc.com'],
  bcc: ['test@bcc.com'],
  attachments: [{ mime: 'text/plain', file: Buffer.from('dGVzdA=='), name: 'test.txt' }],
};

const mockNovuMessage: IEmailBody = {
  from: { email: mockEmailOptions.from },
  subject: mockEmailOptions.subject,
  content: [{ type: 'html', value: mockEmailOptions.html }],
  personalizations: [
    {
      bcc: mockEmailOptions.bcc.map((email) => ({ email })),
      to: mockEmailOptions.to.map((email) => ({ email })),
      cc: mockEmailOptions.cc.map((email) => ({ email })),
      attachments: mockEmailOptions.attachments.map((attachment) => {
        return {
          content: attachment.file.toString('base64'),
          name: attachment.name,
        };
      }),
    },
  ],
};

describe('test netcore email send api', () => {
  const mockedAxios = axios as Mocked<typeof axios>;

  beforeEach(() => {
    mockedAxios.create.mockReturnThis();
  });

  test('should trigger email correctly', async () => {
    const response = {
      data: {
        data: {
          message_id: 'fa6cb2977cdfd457b3ac98be710ad763',
        },
        message: 'OK',
        status: 'success',
      },
    };

    mockedAxios.request.mockResolvedValue(response);

    const netCoreProvider = new NetCoreProvider(mockConfig);

    const spy = vi.spyOn(netCoreProvider, 'sendMessage');

    const res = await netCoreProvider.sendMessage(mockEmailOptions);

    expect(mockedAxios.request).toHaveBeenCalled();
    expect(spy).toHaveBeenCalled();
    expect(spy).toHaveBeenCalledWith(mockEmailOptions);
    expect(res.id).toEqual(response.data.data.message_id);
  });

  test('should trigger email correctly with _passthrough', async () => {
    const response = {
      data: {
        data: {
          message_id: 'fa6cb2977cdfd457b3ac98be710ad763',
        },
        message: 'OK',
        status: 'success',
      },
    };

    mockedAxios.request.mockResolvedValue(response);

    const netCoreProvider = new NetCoreProvider(mockConfig);

    const res = await netCoreProvider.sendMessage(mockEmailOptions, {
      _passthrough: {
        body: {
          subject: 'test subject _passthrough',
        },
      },
    });

    expect(mockedAxios.request).toHaveBeenCalled();
    expect(mockedAxios.request).toHaveBeenCalledWith({
      data: '{"from":{"email":"test@test1.com","name":"Novu\'s Team"},"subject":"test subject _passthrough","content":[{"type":"html","value":"<div> Mail Content </div>"}],"personalizations":[{"to":[{"email":"test@to.com"}],"cc":[{"email":"test@cc.com"}],"bcc":[{"email":"test@bcc.com"}],"attachments":[{"name":"test.txt","content":"ZEdWemRBPT0="}]}]}',
      headers: {
        Accept: 'application/json',
        'Content-Type': 'application/json',
        api_key: 'test-key',
      },
      method: 'POST',
      url: '/mail/send',
    });
    expect(res.id).toEqual(response.data.data.message_id);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - IEmailBody({
  from: { email: mockEmailOptions.from },
  subject: mockEmailOptions.subject,
  content: [{ type:...)
 - mockedAxios(axios as Mocked<typeof axios>;

  beforeEach(())
 - res(await netCoreProvider.sendMessage(mockEmailOptions);

    expect(mockedAxios.request).toHaveBeenCall...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/netcore/netcore.provider.ts
Tamaño: 4653 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EmailProviderIdEnum } from '@novu/shared';
import {
  ChannelTypeEnum,
  CheckIntegrationResponseEnum,
  EmailEventStatusEnum,
  ICheckIntegrationResponse,
  IEmailEventBody,
  IEmailOptions,
  IEmailProvider,
  ISendMessageSuccessResponse,
} from '@novu/stateless';
import axios, { AxiosInstance } from 'axios';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';
import { IEmailBody, IEmailResponse } from './netcore-types';

export enum NetCoreStatusEnum {
  OPENED = 'open',
  SENT = 'send',
  BOUNCED = 'bounce',
  INVALID = 'invalid',
  DROPPED = 'drop',
  CLICKED = 'click',
  SPAM = 'spam',
  UNSUBSCRIBED = 'unsub',
}

export class NetCoreProvider extends BaseProvider implements IEmailProvider {
  id = EmailProviderIdEnum.NetCore;
  protected casing: CasingEnum = CasingEnum.SNAKE_CASE;
  channelType = ChannelTypeEnum.EMAIL as ChannelTypeEnum.EMAIL;
  public readonly BASE_URL = 'https://emailapi.netcorecloud.net/v5.1';
  private axiosInstance: AxiosInstance;

  constructor(
    private config: {
      apiKey: string;
      from: string;
      senderName: string;
    }
  ) {
    super();
    this.axiosInstance = axios.create({
      baseURL: this.BASE_URL,
    });
  }

  async sendMessage(
    options: IEmailOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const data: IEmailBody = this.transform<IEmailBody>(bridgeProviderData, {
      from: {
        email: options.from || this.config.from,
        name: options.senderName || this.config.senderName,
      },
      subject: options.subject,
      content: [
        {
          type: 'html',
          value: options.html,
        },
      ],
      personalizations: [
        {
          to: options.to.map((email) => ({ email })),
        },
      ],
    }).body;

    if (options.replyTo) {
      data.reply_to = options.replyTo;
    }

    if (options.cc) {
      data.personalizations[0].cc = options.cc.map((email) => ({
        email,
      }));
    }

    if (options.bcc) {
      data.personalizations[0].bcc = options.bcc.map((email) => ({
        email,
      }));
    }

    if (options.attachments) {
      data.personalizations[0].attachments = options.attachments?.map((attachment) => {
        return {
          name: attachment.name,
          content: attachment.file.toString('base64'),
        };
      });
    }

    const emailOptions = {
      method: 'POST',
      url: '/mail/send',
      headers: {
        api_key: this.config.apiKey,
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
      data: JSON.stringify(data),
    };

    const response = await this.axiosInstance.request<IEmailResponse>(emailOptions);

    return {
      id: response?.data.data?.message_id,
      date: new Date().toISOString(),
    };
  }

  async checkIntegration(options: IEmailOptions): Promise<ICheckIntegrationResponse> {
    return {
      success: true,
      message: 'Integrated successfully!',
      code: CheckIntegrationResponseEnum.SUCCESS,
    };
  }

  getMessageId(body: any | any[]): string[] {
    if (Array.isArray(body)) {
      return body.map((item) => item.TRANSID);
    }

    return [body.TRANSID];
  }

  parseEventBody(body: any | any[], identifier: string): IEmailEventBody | undefined {
    if (Array.isArray(body)) {
      body = body.find((item) => item.TRANSID === identifier);
    }

    if (!body) {
      return undefined;
    }

    const status = this.getStatus(body.EVENT);

    if (status === undefined) {
      return undefined;
    }

    return {
      status,
      date: new Date(body.TIMESTAMP).toISOString(),
      externalId: body.TRANSID,
      attempts: body.attempt ? parseInt(body.attempt, 10) : 1,
      response: body.response ?? '',
      row: body,
    };
  }

  private getStatus(event: string): EmailEventStatusEnum | undefined {
    switch (event) {
      case NetCoreStatusEnum.OPENED:
        return EmailEventStatusEnum.OPENED;
      case NetCoreStatusEnum.INVALID:
      case NetCoreStatusEnum.BOUNCED:
        return EmailEventStatusEnum.BOUNCED;
      case NetCoreStatusEnum.CLICKED:
        return EmailEventStatusEnum.CLICKED;
      case NetCoreStatusEnum.SENT:
        return EmailEventStatusEnum.SENT;
      case NetCoreStatusEnum.SPAM:
        return EmailEventStatusEnum.SPAM;
      case NetCoreStatusEnum.UNSUBSCRIBED:
        return EmailEventStatusEnum.UNSUBSCRIBED;
      case NetCoreStatusEnum.DROPPED:
        return EmailEventStatusEnum.DROPPED;
      default:
        return undefined;
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - IEmailBody(this.transform<IEmailBody>(bridgeProviderData, {
      from: {
        email: options.from || this.c...)
 - cc(options.cc.map((email))
 - bcc(options.bcc.map((email))
 - attachments(options.attachments?.map((attachment))
 - response(await this.axiosInstance.request<IEmailResponse>(emailOptions);

    return {
      id: response?.da...)
 - body(body.find((item))
Declaraciones 'export' encontradas:
- export  enum
- export class NetCoreProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/nodemailer/nodemailer.provider.spec.ts
Tamaño: 6022 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { fail } from 'assert';

import nodemailer from 'nodemailer';
import { ConnectionOptions } from 'tls';
import { afterEach, describe, expect, test, vi } from 'vitest';
import { NodemailerProvider } from './nodemailer.provider';

const sendMailMock = vi.fn().mockReturnValue(() => {
  return {} as any;
});

vi.mock(import('nodemailer'), async (importOriginal) => {
  const actual = await importOriginal();

  return {
    ...actual,
    createTransport: vi.fn().mockImplementation(() => {
      return {
        sendMail: sendMailMock,
      };
    }),
  };
});

const buffer = Buffer.from('test');
const mockNovuMessage = {
  to: ['test@test2.com'],
  subject: 'test subject',
  html: '<div> Mail Content </div>',
  attachments: [{ mime: 'text/plain', file: buffer, name: 'test.txt' }],
  from: 'test@test.com',
};

describe.skip('NodemailerProvider', () => {
  afterEach(() => {
    sendMailMock.mockReset();
  });

  describe('Config is set to secure=false but not user and password set', () => {
    test('should trigger nodemailer without auth with rejectUnauthorized as false', async () => {
      const config = {
        host: 'test.test.email',
        port: 587,
        secure: false,
        from: 'test@test.com',
        user: undefined,
        password: undefined,
      };
      const provider = new NodemailerProvider(config);
      await provider.sendMessage(mockNovuMessage);

      expect(nodemailer.createTransport).toHaveBeenCalled();
      expect(nodemailer.createTransport).toHaveBeenCalledWith({
        name: config.host,
        host: config.host,
        port: config.port,
        secure: config.secure,
        auth: undefined,
        dkim: undefined,
        ignoreTls: undefined,
        requireTls: undefined,
      });
    });
  });

  describe('Config is set to secure=false (default; TLS used if server supports STARTTLS extension', () => {
    const mockConfig = {
      host: 'test.test.email',
      port: 587,
      secure: false,
      from: 'test@test.com',
      senderName: 'John Doe',
      user: 'test@test.com',
      password: 'test123',
    };

    test('should trigger nodemailer correctly', async () => {
      const provider = new NodemailerProvider(mockConfig);
      await provider.sendMessage(mockNovuMessage);

      expect(sendMailMock).toHaveBeenCalled();
      expect(sendMailMock).toHaveBeenCalledWith({
        from: { address: mockNovuMessage.from, name: mockConfig.senderName },
        html: mockNovuMessage.html,
        subject: mockNovuMessage.subject,
        to: mockNovuMessage.to,
        attachments: [
          {
            contentType: 'text/plain',
            content: buffer,
            filename: 'test.txt',
          },
        ],
      });
    });

    test('should check provider integration correctly', async () => {
      const provider = new NodemailerProvider(mockConfig);
      const response = await provider.checkIntegration(mockNovuMessage);

      expect(sendMailMock).toHaveBeenCalled();
      expect(response.success).toBe(true);

      expect(nodemailer.createTransport).toHaveBeenCalled();
      expect(nodemailer.createTransport).toHaveBeenCalledWith({
        name: mockConfig.host,
        host: mockConfig.host,
        port: mockConfig.port,
        secure: mockConfig.secure,
        auth: {
          user: mockConfig.user,
          pass: mockConfig.password,
        },
        dkim: undefined,
        tls: undefined,
      });
    });
  });

  describe('Config is set to secure=true and TLS options are provided', () => {
    const mockConfig = {
      host: 'test.test.email',
      port: 587,
      secure: true,
      from: 'test@test.com',
      senderName: 'John Doe',
      user: 'test@test.com',
      password: 'test123',
      tlsOptions: {
        rejectUnauthorized: false,
      },
    };

    test('should trigger nodemailer correctly', async () => {
      const provider = new NodemailerProvider(mockConfig);
      await provider.sendMessage(mockNovuMessage);

      expect(sendMailMock).toHaveBeenCalled();
      expect(sendMailMock).toHaveBeenCalledWith({
        from: { address: mockNovuMessage.from, name: mockConfig.senderName },
        html: mockNovuMessage.html,
        subject: mockNovuMessage.subject,
        to: mockNovuMessage.to,
        attachments: [
          {
            contentType: 'text/plain',
            content: buffer,
            filename: 'test.txt',
          },
        ],
      });
    });

    test('should trigger nodemailer correctly with _passthrough', async () => {
      const provider = new NodemailerProvider(mockConfig);
      await provider.sendMessage(mockNovuMessage, {
        _passthrough: {
          body: {
            subject: 'test subject _passthrough',
          },
        },
      });

      expect(sendMailMock).toHaveBeenCalled();
      expect(sendMailMock).toHaveBeenCalledWith({
        from: { address: mockNovuMessage.from, name: mockConfig.senderName },
        html: mockNovuMessage.html,
        subject: 'test subject _passthrough',
        to: mockNovuMessage.to,
        attachments: [
          {
            contentType: 'text/plain',
            content: buffer,
            filename: 'test.txt',
          },
        ],
      });
    });

    test('should check provider integration correctly', async () => {
      const provider = new NodemailerProvider(mockConfig);
      const response = await provider.checkIntegration(mockNovuMessage);

      expect(sendMailMock).toHaveBeenCalled();
      expect(response.success).toBe(true);
    });

    test('should throw an error if TLS options are not a valid JSON', () => {
      try {
        const provider = new NodemailerProvider({
          ...mockConfig,
          tlsOptions: (() => {}) as unknown as ConnectionOptions,
        });
        fail('Should not reach here');
      } catch (error) {
        expect(error.message).toBe(
          'TLS options is not a valid JSON. Check again the value set for NODEMAILER_TLS_OPTIONS'
        );
      }
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - sendMailMock(vi.fn().mockReturnValue(())
 - actual(await importOriginal();

  return {
    ...actual,
    createTransport: vi.fn().mockImplementation((...)
 - mockNovuMessage({
  to: ['test@test2.com'],
  subject: 'test subject',
  html: '<div> Mail Content </div>',
  attach...)
 - secure(false but not user and password set', ())
 - secure(false (default; TLS used if server supports STARTTLS extension', ())
 - mockConfig({
      host: 'test.test.email',
      port: 587,
      secure: false,
      from: 'test@test.com',
...)
 - provider(new NodemailerProvider(mockConfig);
      await provider.sendMessage(mockNovuMessage);

      expect...)
 - secure(true and TLS options are provided', ())
 - mockConfig({
      host: 'test.test.email',
      port: 587,
      secure: true,
      from: 'test@test.com',
 ...)
 - provider(new NodemailerProvider(mockConfig);
      await provider.sendMessage(mockNovuMessage);

      expect...)
 - provider(new NodemailerProvider(mockConfig);
      await provider.sendMessage(mockNovuMessage, {
        _pas...)
 - response(await provider.checkIntegration(mockNovuMessage);

      expect(sendMailMock).toHaveBeenCalled();
  ...)
 - provider(new NodemailerProvider({
          ...mockConfig,
          tlsOptions: (())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/nodemailer/nodemailer.provider.ts
Tamaño: 4443 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EmailProviderIdEnum } from '@novu/shared';
import {
  ChannelTypeEnum,
  CheckIntegrationResponseEnum,
  ICheckIntegrationResponse,
  IEmailOptions,
  IEmailProvider,
  ISendMessageSuccessResponse,
} from '@novu/stateless';
import nodemailer, { SendMailOptions, Transporter } from 'nodemailer';
import DKIM from 'nodemailer/lib/dkim';
import SMTPTransport from 'nodemailer/lib/smtp-transport';
import { ConnectionOptions } from 'tls';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

interface INodemailerConfig {
  from: string;
  host: string;
  port: number;
  secure?: boolean;
  user?: string;
  password?: string;
  dkim?: DKIM.SingleKeyOptions;
  ignoreTls?: boolean;
  requireTls?: boolean;
  tlsOptions?: ConnectionOptions;
  senderName?: string;
}

export class NodemailerProvider extends BaseProvider implements IEmailProvider {
  id = EmailProviderIdEnum.CustomSMTP; // nodemailer
  protected casing: CasingEnum = CasingEnum.CAMEL_CASE;

  channelType = ChannelTypeEnum.EMAIL as ChannelTypeEnum.EMAIL;

  private transports: Transporter;

  constructor(private config: INodemailerConfig) {
    super();
    let { dkim } = this.config;

    if (!dkim?.domainName || !dkim?.privateKey || !dkim?.keySelector) {
      dkim = undefined;
    }

    const authEnabled = this.config.user && this.config.password;

    const tls: ConnectionOptions = this.getTlsOptions();

    const smtpTransportOptions: SMTPTransport.Options = {
      name: this.config.host,
      host: this.config.host,
      port: this.config.port,
      secure: this.config.secure,
      auth: authEnabled
        ? {
            user: this.config.user,
            pass: this.config.password,
          }
        : undefined,
      dkim,
      ignoreTLS: this.config.ignoreTls,
      requireTLS: this.config.requireTls,
      ...(tls && { tls }),
    };

    this.transports = nodemailer.createTransport(smtpTransportOptions);
  }

  getTlsOptions(): ConnectionOptions | undefined {
    /**
     * Only render TLS options if secure is enabled to true.
     * Reference: https://nodemailer.com/smtp/#tls-options
     *
     */
    if (this.config.secure && !!this.config.tlsOptions) {
      this.validateTlsOptions();

      return this.config.tlsOptions;
    }

    return undefined;
  }

  validateTlsOptions(): void {
    try {
      JSON.parse(JSON.stringify(this.config.tlsOptions));
    } catch {
      throw new Error('TLS options is not a valid JSON. Check again the value set for NODEMAILER_TLS_OPTIONS');
    }
  }

  async sendMessage(
    options: IEmailOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const mailData = this.createMailData(options);
    const info = await this.transports.sendMail(this.transform(bridgeProviderData, mailData).body);

    return {
      id: info?.messageId,
      date: new Date().toISOString(),
    };
  }

  async checkIntegration(options: IEmailOptions): Promise<ICheckIntegrationResponse> {
    try {
      const mailData = this.createMailData(options);
      await this.transports.sendMail(mailData);

      return {
        success: true,
        message: 'Integrated successfully!',
        code: CheckIntegrationResponseEnum.SUCCESS,
      };
    } catch (error) {
      return {
        success: false,
        message: error?.message,
        // nodemailer does not provide a way to distinguish errors
        code: CheckIntegrationResponseEnum.FAILED,
      };
    }
  }

  private createMailData(options: IEmailOptions): SendMailOptions {
    const sendMailOptions: SendMailOptions = {
      from: {
        address: options.from || this.config.from,
        name: options.senderName || this.config.senderName || '',
      },
      to: options.to,
      subject: options.subject,
      html: options.html,
      text: options.text,
      cc: options.cc,
      attachments: options.attachments?.map((attachment) => ({
        filename: attachment?.name,
        content: attachment.file,
        contentType: attachment.mime,
        cid: attachment.cid,
        contentDisposition:
          (attachment.disposition as 'inline' | 'attachment') ?? (attachment.cid ? 'inline' : undefined),
      })),
      bcc: options.bcc,
    };

    if (options.replyTo) {
      sendMailOptions.replyTo = options.replyTo;
    }

    return sendMailOptions;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - SendMailOptions({
      from: {
        address: options.from || this.config.from,
        name: options.senderName ...)
Declaraciones 'export' encontradas:
- export class NodemailerProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/outlook365/outlook365.provider.spec.ts
Tamaño: 2631 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CheckIntegrationResponseEnum, ICheckIntegrationResponse } from '@novu/stateless';
import nodemailer from 'nodemailer';
import { expect, test, vi } from 'vitest';
import { Outlook365Provider } from './outlook365.provider';

const sendMailMock = vi.fn().mockReturnValue(() => {
  return {
    messageId: 'message-id',
  } as any;
});

vi.spyOn(nodemailer, 'createTransport').mockImplementation(() => {
  return {
    sendMail: sendMailMock,
  } as any;
});

const mockConfig = {
  from: 'test@test.com',
  senderName: 'test@test.com',
  password: 'test123',
};

const mockNovuMessage = {
  to: ['test@test2.com'],
  subject: 'test subject',
  html: '<div> Mail Content </div>',
};

test('should trigger outlook365 library correctly', async () => {
  const provider = new Outlook365Provider(mockConfig);

  const response = await provider.sendMessage(mockNovuMessage);

  expect(response).not.toBeNull();
  expect(sendMailMock).toHaveBeenCalled();
  expect(sendMailMock).toHaveBeenCalledWith({
    attachments: undefined,
    from: {
      address: 'test@test.com',
      name: 'test@test.com',
    },
    html: '<div> Mail Content </div>',
    subject: 'test subject',
    text: undefined,
    to: ['test@test2.com'],
  });
});

test('should trigger outlook365 library correctly with _passthrough', async () => {
  const provider = new Outlook365Provider(mockConfig);

  const response = await provider.sendMessage(mockNovuMessage, {
    _passthrough: {
      body: {
        html: '<div> Mail Content _passthrough </div>',
      },
    },
  });

  expect(response).not.toBeNull();
  expect(sendMailMock).toHaveBeenCalled();
  expect(sendMailMock).toHaveBeenCalledWith({
    attachments: undefined,
    from: {
      address: 'test@test.com',
      name: 'test@test.com',
    },
    html: '<div> Mail Content _passthrough </div>',
    subject: 'test subject',
    text: undefined,
    to: ['test@test2.com'],
  });
});

test('should check provider integration correctly', async () => {
  const provider = new Outlook365Provider(mockConfig);

  const spy = vi.spyOn(provider, 'checkIntegration').mockImplementation(async () => {
    return {
      success: true,
      message: 'test',
      code: CheckIntegrationResponseEnum.SUCCESS,
    } as ICheckIntegrationResponse;
  });

  const response = await provider.checkIntegration(mockNovuMessage);

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith(mockNovuMessage);
  expect(response).not.toBeNull();
  expect(response.success).toBeTruthy();
  expect(response.message).toBe('test');
  expect(response.code).toBe(CheckIntegrationResponseEnum.SUCCESS);
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - sendMailMock(vi.fn().mockReturnValue(())
 - mockNovuMessage({
  to: ['test@test2.com'],
  subject: 'test subject',
  html: '<div> Mail Content </div>',
};

test...)
 - response(await provider.sendMessage(mockNovuMessage);

  expect(response).not.toBeNull();
  expect(sendMailMo...)
 - response(await provider.sendMessage(mockNovuMessage, {
    _passthrough: {
      body: {
        html: '<div>...)
 - spy(vi.spyOn(provider, 'checkIntegration').mockImplementation(async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/outlook365/outlook365.provider.ts
Tamaño: 2883 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EmailProviderIdEnum } from '@novu/shared';
import {
  ChannelTypeEnum,
  CheckIntegrationResponseEnum,
  ICheckIntegrationResponse,
  IEmailOptions,
  IEmailProvider,
  ISendMessageSuccessResponse,
} from '@novu/stateless';
import nodemailer, { SendMailOptions, Transporter } from 'nodemailer';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class Outlook365Provider extends BaseProvider implements IEmailProvider {
  id = EmailProviderIdEnum.Outlook365;
  protected casing: CasingEnum = CasingEnum.CAMEL_CASE;
  channelType = ChannelTypeEnum.EMAIL as ChannelTypeEnum.EMAIL;
  private transports: Transporter;

  constructor(
    private config: {
      from: string;
      senderName: string;
      password: string;
    }
  ) {
    super();
    this.transports = nodemailer.createTransport({
      host: 'smtp.office365.com',
      port: 587,
      requireTLS: true,
      connectionTimeout: 30000,
      auth: {
        user: this.config.from,
        pass: this.config.password,
      },
      tls: {
        ciphers: 'SSLv3',
      },
    });
  }

  async sendMessage(
    options: IEmailOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const mailData = this.createMailData(options);
    const info = await this.transports.sendMail(this.transform(bridgeProviderData, mailData).body);

    return {
      id: info?.messageId,
      date: new Date().toISOString(),
    };
  }

  async checkIntegration(options: IEmailOptions): Promise<ICheckIntegrationResponse> {
    try {
      const mailData = this.createMailData(options);
      await this.transports.sendMail(mailData);

      return {
        success: true,
        message: 'Integrated successfully!',
        code: CheckIntegrationResponseEnum.SUCCESS,
      };
    } catch (error) {
      return {
        success: false,
        message: error?.message,
        code: CheckIntegrationResponseEnum.FAILED,
      };
    }
  }

  private createMailData(options: IEmailOptions): SendMailOptions {
    const sendMailOptions: SendMailOptions = {
      from: {
        address: options.from || this.config.from,
        name: options.senderName || this.config.senderName,
      },
      to: options.to,
      subject: options.subject,
      html: options.html,
      text: options.text,
      attachments: options.attachments?.map((attachment) => ({
        filename: attachment.name,
        content: attachment.file,
        contentType: attachment.mime,
        cid: attachment.cid,
        contentDisposition:
          (attachment.disposition as 'inline' | 'attachment') ?? (attachment.cid ? 'inline' : undefined),
      })),
    };

    if (options.replyTo) {
      sendMailOptions.replyTo = options.replyTo;
    }

    return sendMailOptions;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - SendMailOptions({
      from: {
        address: options.from || this.config.from,
        name: options.senderName ...)
Declaraciones 'export' encontradas:
- export class Outlook365Provider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/plunk/plunk.interface.ts
Tamaño: 159 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export interface IPlunkResponse {
  success: boolean;
  emails?: {
    contact: {
      id: string;
      email: string;
    };
  }[];
  timestamp?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  interface

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/plunk/plunk.provider.spec.ts
Tamaño: 807 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, test, vi } from 'vitest';
import { PlunkEmailProvider } from './plunk.provider';

const mockConfig = {
  apiKey: 'sample-api-key',
  senderName: "Novu's Team",
};

const mockNovuMessage = {
  from: 'test@nomail.com',
  to: ['test@nomail.com'],
  html: '<div> Mail Content </div>',
  subject: 'Test subject',
};

test('should trigger plunk library correctly', async () => {
  const provider = new PlunkEmailProvider(mockConfig);
  const spy = vi.spyOn(provider, 'sendMessage').mockImplementation(async () => {
    return {};
  });

  await provider.sendMessage(mockNovuMessage);

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    from: mockNovuMessage.from,
    to: mockNovuMessage.to,
    html: mockNovuMessage.html,
    subject: mockNovuMessage.subject,
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - mockNovuMessage({
  from: 'test@nomail.com',
  to: ['test@nomail.com'],
  html: '<div> Mail Content </div>',
  subje...)
 - spy(vi.spyOn(provider, 'sendMessage').mockImplementation(async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/plunk/plunk.provider.ts
Tamaño: 2252 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EmailProviderIdEnum } from '@novu/shared';
import {
  ChannelTypeEnum,
  CheckIntegrationResponseEnum,
  ICheckIntegrationResponse,
  IEmailEventBody,
  IEmailOptions,
  IEmailProvider,
  ISendMessageSuccessResponse,
} from '@novu/stateless';

import Plunk from '@plunk/node';
import { SendParams } from '@plunk/node/dist/types/emails';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';
import { IPlunkResponse } from './plunk.interface';

export class PlunkEmailProvider extends BaseProvider implements IEmailProvider {
  id = EmailProviderIdEnum.Plunk;
  protected casing: CasingEnum = CasingEnum.CAMEL_CASE;
  channelType = ChannelTypeEnum.EMAIL as ChannelTypeEnum.EMAIL;

  private plunk: Plunk;

  constructor(
    private config: {
      apiKey: string;
      senderName: string;
    }
  ) {
    super();
    this.plunk = new Plunk(this.config.apiKey);
  }
  async checkIntegration(
    options: IEmailOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ICheckIntegrationResponse> {
    try {
      const response: IPlunkResponse = await this.plunk.emails.send({
        to: options.to,
        subject: options.subject,
        body: options.html || options.text,
        ...bridgeProviderData,
      });

      return {
        success: response.success,
        message: 'Integrated successfully!',
        code: CheckIntegrationResponseEnum.SUCCESS,
      };
    } catch (error) {
      return {
        success: false,
        message: error?.message,
        code: CheckIntegrationResponseEnum.FAILED,
      };
    }
  }

  async sendMessage(
    options: IEmailOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const response: IPlunkResponse = await this.plunk.emails.send(
      this.transform<SendParams>(bridgeProviderData, {
        from: options.from,
        name: options.senderName || this.config.senderName,
        to: options.to,
        subject: options.subject,
        body: options.html || options.text,
      }).body
    );

    return {
      id: response.emails[0].contact.id,
      date: response.timestamp,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class PlunkEmailProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/postmark/postmark.provider.spec.ts
Tamaño: 3737 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, test, vi } from 'vitest';
import { PostmarkEmailProvider } from './postmark.provider';

const mockConfig = {
  apiKey: '<postmark-id>',
  from: 'test@test.com',
};

const mockNovuMessage = {
  to: ['test2@test.com'],
  subject: 'test subject',
  html: '<div> Mail Content </div>',
  attachments: [{ mime: 'text/plain', file: Buffer.from('test'), name: 'test.txt' }],
};

const mockMessage = {
  To: 'receiver@example.com',
  SubmittedAt: '2014-02-17T07:25:01.4178645-05:00',
  MessageID: '883953f4-6105-42a2-a16a-77a8eac79483',
  ErrorCode: 0,
  Message: 'OK',
};

const mockWebHook = {
  MessageID: '883953f4-6105-42a2-a16a-77a8eac79483',
  Recipient: 'john@example.com',
  DeliveredAt: '2019-11-05T16:33:54.9070259Z',
  Details: 'Test delivery webhook details',
  Tag: 'welcome-email',
  ServerID: 23,
  Metadata: {
    a_key: 'a_value',
    b_key: 'b_value',
  },
  RecordType: 'Delivery',
  MessageStream: 'outbound',
};

test('should trigger postmark correctly', async () => {
  const provider = new PostmarkEmailProvider(mockConfig);
  const spy = vi.spyOn((provider as any).client, 'sendEmail').mockImplementation(async () => {
    return {};
  });

  await provider.sendMessage(mockNovuMessage);

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    From: mockConfig.from,
    To: mockNovuMessage.to[0],
    HtmlBody: mockNovuMessage.html,
    TextBody: mockNovuMessage.html,
    Subject: mockNovuMessage.subject,
    Attachments: [
      {
        Name: 'test.txt',
        Content: Buffer.from('test').toString('base64'),
        ContentID: null,
        ContentType: 'text/plain',
      },
    ],
  });
});

test('should trigger postmark correctly with _passthrough', async () => {
  const provider = new PostmarkEmailProvider(mockConfig);
  const spy = vi.spyOn((provider as any).client, 'sendEmail').mockImplementation(async () => {
    return {};
  });

  await provider.sendMessage(mockNovuMessage, {
    _passthrough: {
      body: {
        From: 'hello@test.com',
      },
    },
  });

  expect(spy).toHaveBeenCalledWith({
    From: 'hello@test.com',
    To: mockNovuMessage.to[0],
    HtmlBody: mockNovuMessage.html,
    TextBody: mockNovuMessage.html,
    Subject: mockNovuMessage.subject,
    Attachments: [
      {
        Name: 'test.txt',
        Content: Buffer.from('test').toString('base64'),
        ContentID: null,
        ContentType: 'text/plain',
      },
    ],
  });
});

test('should get message ID', () => {
  const provider = new PostmarkEmailProvider(mockConfig);
  expect(provider.getMessageId(mockMessage)).toEqual(['883953f4-6105-42a2-a16a-77a8eac79483']);
});

test('should parse postmark webhook', () => {
  const provider = new PostmarkEmailProvider(mockConfig);
  const identifier = '883953f4-6105-42a2-a16a-77a8eac79483';
  const currentDateTimestamp = new Date().getTime();
  const { date, ...result } = provider.parseEventBody(mockWebHook, identifier);

  /*
   * Checking difference between current timestamp and timestamp received from result,
   * to be less than 5 seconds
   */
  expect(Math.abs(currentDateTimestamp - new Date(date).getTime())).toBeLessThanOrEqual(5000);

  expect(result).toStrictEqual({
    status: 'delivered',
    externalId: '883953f4-6105-42a2-a16a-77a8eac79483',
    attempts: 1,
    response: '',
    row: mockWebHook,
  });
});

test('should check provider integration correctly', async () => {
  const provider = new PostmarkEmailProvider(mockConfig);
  const spy = vi.spyOn((provider as any).client, 'sendEmail').mockImplementation(async () => {
    return {};
  });

  const response = await provider.checkIntegration(mockNovuMessage);
  expect(spy).toHaveBeenCalled();
  expect(response.success).toBe(true);
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - mockWebHook({
  MessageID: '883953f4-6105-42a2-a16a-77a8eac79483',
  Recipient: 'john@example.com',
  DeliveredA...)
 - spy(vi.spyOn((provider as any).client, 'sendEmail').mockImplementation(async ())
 - spy(vi.spyOn((provider as any).client, 'sendEmail').mockImplementation(async ())
 - provider(new PostmarkEmailProvider(mockConfig);
  expect(provider.getMessageId(mockMessage)).toEqual(['883953...)
 - spy(vi.spyOn((provider as any).client, 'sendEmail').mockImplementation(async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/postmark/postmark.provider.ts
Tamaño: 4786 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EmailProviderIdEnum } from '@novu/shared';
import {
  ChannelTypeEnum,
  CheckIntegrationResponseEnum,
  EmailEventStatusEnum,
  ICheckIntegrationResponse,
  IEmailEventBody,
  IEmailOptions,
  IEmailProvider,
  ISendMessageSuccessResponse,
} from '@novu/stateless';
import { Errors, Message, Models, ServerClient } from 'postmark';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class PostmarkEmailProvider extends BaseProvider implements IEmailProvider {
  id = EmailProviderIdEnum.Postmark;
  protected casing = CasingEnum.PASCAL_CASE;
  channelType = ChannelTypeEnum.EMAIL as ChannelTypeEnum.EMAIL;
  private client: ServerClient;

  constructor(
    private config: {
      apiKey: string;
      from: string;
    }
  ) {
    super();
    this.client = new ServerClient(this.config.apiKey);
  }

  async sendMessage(
    options: IEmailOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const mailData = this.createMailData(options);
    const response = await this.client.sendEmail(
      this.transform<Message>(bridgeProviderData, mailData as unknown as Record<string, unknown>).body
    );

    return {
      id: response.MessageID,
      date: response.SubmittedAt,
    };
  }

  async checkIntegration(options: IEmailOptions): Promise<ICheckIntegrationResponse> {
    try {
      const mailData = this.createMailData(options);
      await this.client.sendEmail(mailData);

      return {
        success: true,
        message: 'Integrated successfully!',
        code: CheckIntegrationResponseEnum.SUCCESS,
      };
    } catch (error) {
      if (error instanceof Errors.PostmarkError) {
        return {
          success: false,
          message: error?.message,
          code: mapError(error),
        };
      } else {
        return {
          success: false,
          message: error?.message,
          code: CheckIntegrationResponseEnum.FAILED,
        };
      }
    }
  }

  private createMailData(options: IEmailOptions): Message {
    const mailData: Message = {
      From: options.from || this.config.from,
      To: getFormattedTo(options.to),
      HtmlBody: options.html,
      TextBody: options.html,
      Subject: options.subject,
      Cc: getFormattedTo(options.cc),
      Bcc: getFormattedTo(options.bcc),
      Attachments: options.attachments?.map(
        (attachment) =>
          new Models.Attachment(attachment.name, attachment.file.toString('base64'), attachment.mime, attachment.cid)
      ),
    };

    if (options.replyTo) {
      mailData.ReplyTo = options.replyTo;
    }

    return mailData;
  }

  getMessageId(body: any | any[]): string[] {
    if (Array.isArray(body)) {
      return body.map((item) => item.MessageID);
    }

    return [body.MessageID];
  }

  parseEventBody(body: any | any[], identifier: string): IEmailEventBody | undefined {
    if (Array.isArray(body)) {
      body = body.find((item) => item.MessageID === identifier);
    }

    if (!body) {
      return undefined;
    }

    const status = this.getStatus(body.RecordType);

    if (status === undefined) {
      return undefined;
    }

    return {
      status,
      date: new Date().toISOString(),
      externalId: body.MessageID,
      attempts: body.attempt ? parseInt(body.attempt, 10) : 1,
      response: body.response ? body.response : '',
      row: body,
    };
  }

  private getStatus(event: string): EmailEventStatusEnum | undefined {
    switch (event) {
      case 'Open':
        return EmailEventStatusEnum.OPENED;
      case 'Click':
        return EmailEventStatusEnum.CLICKED;
      case 'Delivery':
        return EmailEventStatusEnum.DELIVERED;
      case 'Bounce':
        return EmailEventStatusEnum.BOUNCED;
      case 'SpamComplaint':
        return EmailEventStatusEnum.SPAM;
      case 'SubscriptionChange':
        return EmailEventStatusEnum.UNSUBSCRIBED;
      default:
        return undefined;
    }
  }
}

const getFormattedTo = (to: string | string[]): string => {
  if (Array.isArray(to)) return to.join(', ');

  return to;
};

const mapError = (error: Errors.PostmarkError) => {
  if (error instanceof Errors.InvalidAPIKeyError) {
    return CheckIntegrationResponseEnum.BAD_CREDENTIALS;
  } else if (error instanceof Errors.ApiInputError) {
    // https://postmarkapp.com/developer/api/overview#error-codes
    switch (error.code) {
      case 10:
        return CheckIntegrationResponseEnum.BAD_CREDENTIALS;
      case 400:
      case 401:
        return CheckIntegrationResponseEnum.INVALID_EMAIL;
      default:
        return CheckIntegrationResponseEnum.FAILED;
    }
  } else {
    return CheckIntegrationResponseEnum.FAILED;
  }
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - Message({
      From: options.from || this.config.from,
      To: getFormattedTo(options.to),
      HtmlBody...)
 - ReplyTo(options.replyTo;
    }

    return mailData;
  }

  getMessageId(body: any | any[]): string[] {
    ...)
 - body(body.find((item))
 - getFormattedTo(to: string | string[]): string)
 - mapError(error: Errors.PostmarkError))
Declaraciones 'export' encontradas:
- export class PostmarkEmailProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/resend/resend.provider.spec.ts
Tamaño: 3727 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IEmailOptions } from '@novu/stateless';
import { expect, test, vi } from 'vitest';
import { ResendEmailProvider } from './resend.provider';

const mockConfig = {
  apiKey: 'this-api-key-from-resend',
  from: 'test@test.com',
};

const mockNovuMessage: IEmailOptions = {
  from: 'test@test.com',
  to: ['test@test.com'],
  html: '<div> Mail Content </div>',
  subject: 'Test subject',
  replyTo: 'no-reply@novu.co',
  attachments: [
    {
      mime: 'text/plain',
      file: Buffer.from('test'),
      name: 'test.txt',
    },
  ],
};
const mockNovuMessageWithContentId: IEmailOptions = {
  from: 'test@test.com',
  to: ['test@test.com'],
  html: '<img src="cid:test" alt="test" />',
  subject: 'Test subject',
  replyTo: 'no-reply@novu.co',
  attachments: [
    {
      mime: 'image/png',
      file: Buffer.from('test'),
      name: 'test.png',
      cid: 'test',
    },
  ],
};

test('should trigger resend library correctly', async () => {
  const provider = new ResendEmailProvider(mockConfig);
  const spy = vi.spyOn(provider, 'sendMessage').mockImplementation(async () => {
    return {};
  });

  await provider.sendMessage(mockNovuMessage);

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    from: mockNovuMessage.from,
    to: mockNovuMessage.to,
    html: mockNovuMessage.html,
    subject: mockNovuMessage.subject,
    attachments: mockNovuMessage.attachments,
    replyTo: mockNovuMessage.replyTo,
  });
});

test('should trigger resend email with From Name', async () => {
  const mockConfigWithSenderName = {
    ...mockConfig,
    senderName: 'Test User',
  };

  const provider = new ResendEmailProvider(mockConfigWithSenderName);
  const spy = vi.spyOn((provider as any).resendClient.emails, 'send').mockImplementation(async () => {
    return {};
  });

  await provider.sendMessage(mockNovuMessageWithContentId);

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    from: `${mockConfigWithSenderName.senderName} <${mockNovuMessageWithContentId.from}>`,
    to: mockNovuMessageWithContentId.to,
    html: mockNovuMessageWithContentId.html,
    subject: mockNovuMessageWithContentId.subject,
    attachments: mockNovuMessageWithContentId.attachments.map((attachment) => ({
      filename: attachment?.name,
      content: attachment.file,
      contentId: attachment.cid,
    })),
    replyTo: mockNovuMessageWithContentId.replyTo,
    headers: mockNovuMessageWithContentId.headers,
    cc: mockNovuMessageWithContentId.cc,
    bcc: mockNovuMessageWithContentId.bcc,
    text: mockNovuMessageWithContentId.text,
  });
});

test('should trigger resend email correctly with _passthrough', async () => {
  const mockConfigWithSenderName = {
    ...mockConfig,
    senderName: 'Test User',
  };

  const provider = new ResendEmailProvider(mockConfigWithSenderName);
  const spy = vi.spyOn((provider as any).resendClient.emails, 'send').mockImplementation(async () => {
    return {};
  });

  await provider.sendMessage(mockNovuMessage, {
    _passthrough: {
      body: {
        subject: 'Test subject with _passthrough',
      },
    },
  });

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    from: `${mockConfigWithSenderName.senderName} <${mockNovuMessage.from}>`,
    to: mockNovuMessage.to,
    html: mockNovuMessage.html,
    subject: 'Test subject with _passthrough',
    attachments: mockNovuMessage.attachments.map((attachment) => ({
      filename: attachment?.name,
      content: attachment.file,
      contentId: attachment.cid,
    })),
    replyTo: mockNovuMessage.replyTo,
    headers: mockNovuMessage.headers,
    cc: mockNovuMessage.cc,
    bcc: mockNovuMessage.bcc,
    text: mockNovuMessage.text,
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - alt("test" />',
  subject: 'Test subject',
  replyTo: 'no-reply@novu.co',
  attachments: [
    {
      m...)
 - spy(vi.spyOn(provider, 'sendMessage').mockImplementation(async ())
 - spy(vi.spyOn((provider as any).resendClient.emails, 'send').mockImplementation(async ())
 - spy(vi.spyOn((provider as any).resendClient.emails, 'send').mockImplementation(async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/resend/resend.provider.ts
Tamaño: 7350 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EmailProviderIdEnum } from '@novu/shared';
import {
  ChannelTypeEnum,
  CheckIntegrationResponseEnum,
  EmailEventStatusEnum,
  ICheckIntegrationResponse,
  IEmailEventBody,
  IEmailOptions,
  IEmailProvider,
  ISendMessageSuccessResponse,
} from '@novu/stateless';
import { CreateEmailOptions, Resend } from 'resend';
import { Webhook } from 'svix';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export type EmailSentWebhook = {
  type:
    | 'email.sent'
    | 'email.failed'
    | 'email.delivered'
    | 'email.delivery_delayed'
    | 'email.bounced'
    | 'email.opened'
    | 'email.clicked'
    | 'email.complained'
    | 'email.scheduled';
  created_at: string;
  data: {
    created_at: string;
    email_id: string;
    from: string;
    subject: string;
    to: string[];
  };
};

interface ResendErrorResponse {
  statusCode: number;
  error: string;
  name: string;
}

interface ResendSuccessResponse {
  data: { id: string };
  error: null;
}

interface ResendResponseWithError {
  data: null;
  error: ResendErrorResponse;
}

type ResendResponse = ResendSuccessResponse | ResendResponseWithError;

/**
 * Validate (type-guard) that an error response matches our ResendErrorResponse interface.
 * this is needed because of this issue https://github.com/resend/resend-node/issues/538
 */
function isResendError(response: ResendResponse | unknown): response is ResendResponseWithError {
  return (
    response !== null &&
    typeof response === 'object' &&
    'error' in response &&
    response.error !== null &&
    typeof response.error === 'object' &&
    'error' in response.error &&
    typeof response.error.error === 'string'
  );
}

export class ResendEmailProvider extends BaseProvider implements IEmailProvider {
  protected casing: CasingEnum = CasingEnum.CAMEL_CASE;
  id = EmailProviderIdEnum.Resend;
  channelType = ChannelTypeEnum.EMAIL as ChannelTypeEnum.EMAIL;
  private resendClient: Resend;

  constructor(
    private config: {
      apiKey: string;
      from: string;
      senderName?: string;
      webhookSigningKey?: string;
    }
  ) {
    super();
    this.resendClient = new Resend(this.config.apiKey);
  }

  async sendMessage(
    options: IEmailOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const senderName = options.senderName || this.config?.senderName;
    const fromAddress = options.from || this.config.from;

    const response = await this.resendClient.emails.send(
      this.transform<CreateEmailOptions>(bridgeProviderData, {
        from: senderName ? `${senderName} <${fromAddress}>` : fromAddress,
        to: options.to,
        subject: options.subject,
        text: options.text,
        html: options.html,
        cc: options.cc,
        replyTo: options.replyTo || null,
        attachments: options.attachments?.map((attachment) => ({
          filename: attachment?.name,
          content: attachment.file,
          contentId: attachment.cid,
        })),
        bcc: options.bcc,
        headers: options.headers,
      } satisfies CreateEmailOptions).body
    );

    if (isResendError(response)) {
      throw new Error(response.error.error);
    } else if (response.error) {
      throw new Error(response.error.message);
    }

    return {
      id: response.data?.id,
      date: new Date().toISOString(),
    };
  }

  async checkIntegration(options: IEmailOptions): Promise<ICheckIntegrationResponse> {
    try {
      await this.resendClient.emails.send({
        from: options.from || this.config.from,
        to: options.to,
        subject: options.subject,
        text: options.text,
        html: options.html,
        cc: options.cc,
        attachments: options.attachments?.map((attachment) => ({
          filename: attachment?.name,
          content: attachment.file,
          contentId: attachment.cid,
        })),
        bcc: options.bcc,
      });

      return {
        success: true,
        message: 'Integrated successfully!',
        code: CheckIntegrationResponseEnum.SUCCESS,
      };
    } catch (error) {
      return {
        success: false,
        message: error?.message,
        code: CheckIntegrationResponseEnum.FAILED,
      };
    }
  }

  getMessageId(body: EmailSentWebhook): string[] {
    return [body.data.email_id];
  }

  parseEventBody(body: EmailSentWebhook): IEmailEventBody | undefined {
    return {
      status: this.getStatus(body.type),
      date: new Date().toISOString(),
      externalId: body.data.email_id,
      row: JSON.stringify(body),
    };
  }

  private getStatus(event: EmailSentWebhook['type']): EmailEventStatusEnum | undefined {
    switch (event) {
      case 'email.sent':
        return EmailEventStatusEnum.SENT;
      case 'email.failed':
        return EmailEventStatusEnum.REJECTED;
      case 'email.delivered':
        return EmailEventStatusEnum.DELIVERED;
      case 'email.delivery_delayed':
        return EmailEventStatusEnum.DELAYED;
      case 'email.bounced':
        return EmailEventStatusEnum.BOUNCED;
      case 'email.opened':
        return EmailEventStatusEnum.OPENED;
      case 'email.clicked':
        return EmailEventStatusEnum.CLICKED;
      case 'email.complained':
        return EmailEventStatusEnum.COMPLAINT;
      default:
        return undefined;
    }
  }

  async verifySignature({
    rawBody,
    headers = {},
    body: _body,
  }: {
    rawBody: any;
    headers?: Record<string, string>;
    body?: Record<string, unknown>;
  }): Promise<{ success: boolean; message?: string }> {
    try {
      const svixId = this.getHeaderValue(headers, 'svix-id');
      const svixTimestamp = this.getHeaderValue(headers, 'svix-timestamp');
      const svixSignature = this.getHeaderValue(headers, 'svix-signature');

      const webhookSigningKey = this.config.webhookSigningKey;

      if (!webhookSigningKey) {
        return {
          success: true,
          message: 'Resend signature verification is not configured',
        };
      }

      if (rawBody === undefined) {
        return { success: false, message: 'Body is undefined' };
      }

      const webhook = new Webhook(webhookSigningKey);
      const svixHeaders = {
        'svix-id': svixId,
        'svix-timestamp': svixTimestamp,
        'svix-signature': svixSignature,
      };

      webhook.verify(rawBody, svixHeaders);

      return { success: true, message: 'Resend signature verification successful' };
    } catch (error) {
      return { success: false, message: `Error verifying signature: ${error.message}` };
    }
  }

  private getHeaderValue(headers: Record<string, string>, headerName: string): string | undefined {
    // Case-insensitive header lookup
    const lowerHeaderName = headerName.toLowerCase();
    const key = Object.keys(headers).find((k) => k.toLowerCase() === lowerHeaderName);

    return key ? headers[key] : undefined;
  }

  async autoConfigureInboundWebhook(_configurations: { webhookUrl: string }): Promise<{
    success: boolean;
    message?: string;
    configurations?: unknown;
  }> {
    return {
      success: false,
      message:
        'Resend does not currently offer automatic inbound webhook configuration. Please configure your webhook manually.',
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - isResendError(response: ResendResponse | unknown)
Asignaciones con arrow functions encontradas (posibles funciones):
 - response(await this.resendClient.emails.send(
      this.transform<CreateEmailOptions>(bridgeProviderData, {
...)
 - key(Object.keys(headers).find((k))
Declaraciones 'export' encontradas:
- export  type
- export class ResendEmailProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/sendgrid/sendgrid.provider.spec.ts
Tamaño: 4621 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { MailService } from '@sendgrid/mail';
import { expect, test, vi } from 'vitest';
import { SendgridEmailProvider } from './sendgrid.provider';

const mockConfig = {
  apiKey: 'SG.1234',
  from: 'test@tet.com',
  senderName: 'test',
};

const mockNovuMessage = {
  to: ['test@test2.com'],
  subject: 'test subject',
  html: '<div> Mail Content </div>',
  from: 'test@tet.com',
  attachments: [{ mime: 'text/plain', file: Buffer.from('dGVzdA=='), name: 'test.txt' }],
  id: 'message_id',
};

test('should trigger sendgrid correctly', async () => {
  const provider = new SendgridEmailProvider(mockConfig);
  const spy = vi.spyOn(MailService.prototype, 'send').mockImplementation(async () => {
    return {} as any;
  });

  await provider.sendMessage(mockNovuMessage);

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    to: [
      {
        email: mockNovuMessage.to[0],
      },
    ],
    bcc: undefined,
    category: undefined,
    cc: undefined,
    subject: mockNovuMessage.subject,
    html: mockNovuMessage.html,
    ipPoolName: undefined,
    from: { email: mockNovuMessage.from, name: mockConfig.senderName },
    substitutions: {},
    attachments: [
      {
        type: 'text/plain',
        content: Buffer.from('ZEdWemRBPT0=').toString(),
        filename: 'test.txt',
      },
    ],
    customArgs: {
      id: 'message_id',
      novuMessageId: 'message_id',
      novuSubscriberId: undefined,
      novuTransactionId: undefined,
      novuWorkflowIdentifier: undefined,
    },
    personalizations: [
      {
        to: [
          {
            email: mockNovuMessage.to[0],
          },
        ],
        cc: undefined,
        bcc: undefined,
        dynamicTemplateData: undefined,
      },
    ],
    templateId: undefined,
  });
});

test('should trigger sendgrid correctly with _passthrough', async () => {
  const provider = new SendgridEmailProvider(mockConfig);
  const spy = vi.spyOn(MailService.prototype, 'send').mockImplementation(async () => {
    return {} as any;
  });

  await provider.sendMessage(mockNovuMessage, {
    _passthrough: {
      body: {
        subject: 'test subject _passthrough',
      },
    },
  });

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    to: [
      {
        email: mockNovuMessage.to[0],
      },
    ],
    bcc: undefined,
    category: undefined,
    cc: undefined,
    subject: 'test subject _passthrough',
    html: mockNovuMessage.html,
    ipPoolName: undefined,
    from: { email: mockNovuMessage.from, name: mockConfig.senderName },
    substitutions: {},
    attachments: [
      {
        type: 'text/plain',
        content: Buffer.from('ZEdWemRBPT0=').toString(),
        filename: 'test.txt',
      },
    ],
    customArgs: {
      id: 'message_id',
      novuMessageId: 'message_id',
      novuSubscriberId: undefined,
      novuTransactionId: undefined,
      novuWorkflowIdentifier: undefined,
    },
    personalizations: [
      {
        to: [
          {
            email: mockNovuMessage.to[0],
          },
        ],
        cc: undefined,
        bcc: undefined,
        dynamicTemplateData: undefined,
      },
    ],
    templateId: undefined,
  });
});

test('should check provider integration correctly', async () => {
  const provider = new SendgridEmailProvider(mockConfig);
  const spy = vi.spyOn(MailService.prototype, 'send').mockImplementation(async () => {
    return [{ statusCode: 202 }] as any;
  });

  const response = await provider.checkIntegration(mockNovuMessage);
  expect(spy).toHaveBeenCalled();
  expect(response.success).toBe(true);
});

test('should get ip pool name from credentials', async () => {
  const provider = new SendgridEmailProvider({
    ...mockConfig,
    ...{ ipPoolName: 'config_ip' },
  });
  const sendMock = vi.fn().mockResolvedValue([{ statusCode: 202 }]);
  vi.spyOn(MailService.prototype, 'send').mockImplementation(sendMock);

  await provider.sendMessage({
    ...mockNovuMessage,
  });
  expect(sendMock).toHaveBeenCalledWith(expect.objectContaining({ ipPoolName: 'config_ip' }));
});

test('should override credentials with mail data', async () => {
  const provider = new SendgridEmailProvider({
    ...mockConfig,
    ...{ ipPoolName: 'config_ip' },
  });
  const sendMock = vi.fn().mockResolvedValue([{ statusCode: 202 }]);
  vi.spyOn(MailService.prototype, 'send').mockImplementation(sendMock);

  await provider.sendMessage({
    ...mockNovuMessage,
    ...{ ipPoolName: 'ip_from_mail_data' },
  });
  expect(sendMock).toHaveBeenCalledWith(expect.objectContaining({ ipPoolName: 'ip_from_mail_data' }));
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - spy(vi.spyOn(MailService.prototype, 'send').mockImplementation(async ())
 - ZEdWemRBPT0(').toString(),
        filename: 'test.txt',
      },
    ],
    customArgs: {
      id: 'message_id...)
 - spy(vi.spyOn(MailService.prototype, 'send').mockImplementation(async ())
 - ZEdWemRBPT0(').toString(),
        filename: 'test.txt',
      },
    ],
    customArgs: {
      id: 'message_id...)
 - spy(vi.spyOn(MailService.prototype, 'send').mockImplementation(async ())
 - response(await provider.checkIntegration(mockNovuMessage);
  expect(spy).toHaveBeenCalled();
  expect(respons...)
 - sendMock(vi.fn().mockResolvedValue([{ statusCode: 202 }]);
  vi.spyOn(MailService.prototype, 'send').mockImpl...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/sendgrid/sendgrid.provider.ts
Tamaño: 10914 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EmailProviderIdEnum, IEmailOptions } from '@novu/shared';
import {
  ChannelTypeEnum,
  CheckIntegrationResponseEnum,
  EmailEventStatusEnum,
  IAttachmentOptions,
  ICheckIntegrationResponse,
  IEmailEventBody,
  IEmailProvider,
  ISendMessageSuccessResponse,
} from '@novu/stateless';
import sgClient from '@sendgrid/client';
// cspell:disable-next-line
import { EventWebhook } from '@sendgrid/eventwebhook';
import { MailDataRequired, MailService } from '@sendgrid/mail';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

type AttachmentJSON = MailDataRequired['attachments'][0];

export class SendgridEmailProvider extends BaseProvider implements IEmailProvider {
  id = EmailProviderIdEnum.SendGrid;
  protected casing: CasingEnum = CasingEnum.CAMEL_CASE;
  channelType = ChannelTypeEnum.EMAIL as ChannelTypeEnum.EMAIL;
  private sendgridMail: MailService;
  private sendgridClient: typeof sgClient;

  constructor(
    private config: {
      apiKey: string;
      from: string;
      senderName: string;
      ipPoolName?: string;
      webhookPublicKey?: string;
    }
  ) {
    super();
    this.sendgridMail = new MailService();
    this.sendgridMail.setApiKey(this.config.apiKey);
    this.sendgridClient = sgClient;
    this.sendgridClient.setApiKey(this.config.apiKey);
  }

  async sendMessage(
    options: IEmailOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const mailData = this.createMailData(options);
    const response = await this.sendgridMail.send(
      this.transform<MailDataRequired>(bridgeProviderData, mailData as unknown as Record<string, unknown>).body
    );

    return {
      id: options.id || response[0]?.headers['x-message-id'],
      date: response[0]?.headers?.date,
    };
  }

  async checkIntegration(options: IEmailOptions): Promise<ICheckIntegrationResponse> {
    try {
      const mailData = this.createMailData(options);

      const response = await this.sendgridMail.send(mailData);

      if (response[0]?.statusCode === 202) {
        return {
          success: true,
          message: 'Integration Successful',
          code: CheckIntegrationResponseEnum.SUCCESS,
        };
      }
    } catch (error) {
      return {
        success: false,
        message: error?.response?.body?.errors[0]?.message,
        code: mapResponse(error?.code),
      };
    }
  }

  private createMailData(options: IEmailOptions) {
    const dynamicTemplateData = options.customData?.dynamicTemplateData;
    const templateId = options.customData?.templateId as unknown as string;
    /*
     * deleted below values from customData to avoid passing them
     * in customArgs because customArgs has max limit of 10,000 bytes
     */
    delete options.customData?.dynamicTemplateData;
    delete options.customData?.templateId;

    const attachments = options.attachments?.map((attachment: IAttachmentOptions) => {
      const attachmentJson: AttachmentJSON = {
        content: attachment.file.toString('base64'),
        filename: attachment.name,
        type: attachment.mime,
      };

      if (attachment?.cid) {
        attachmentJson.contentId = attachment?.cid;
      }

      if (attachment?.disposition) {
        attachmentJson.disposition = attachment?.disposition;
      } else if (attachment?.cid) {
        attachmentJson.disposition = 'inline';
      }

      return attachmentJson;
    });

    const mailData: Partial<MailDataRequired> = {
      from: {
        email: options.from || this.config.from,
        name: options.senderName || this.config.senderName,
      },
      ...this.getIpPoolObject(options),
      to: options.to.map((email) => ({ email })),
      cc: options.cc?.map((ccItem) => ({ email: ccItem })),
      bcc: options.bcc?.map((ccItem) => ({ email: ccItem })),
      html: options.html,
      subject: options.subject,
      substitutions: {},
      category: options.notificationDetails?.workflowIdentifier,
      customArgs: {
        id: options.id,
        novuTransactionId: options.notificationDetails?.transactionId,
        novuMessageId: options.id,
        novuWorkflowIdentifier: options.notificationDetails?.workflowIdentifier,
        novuSubscriberId: options.notificationDetails?.subscriberId,
        ...options.customData,
      },
      attachments,
      personalizations: [
        {
          to: options.to.map((email) => ({ email })),
          cc: options.cc?.map((ccItem) => ({ email: ccItem })),
          bcc: options.bcc?.map((bccItem) => ({ email: bccItem })),
          dynamicTemplateData,
        },
      ],
      templateId,
      headers: options.headers,
    };

    if (options.replyTo) {
      mailData.replyTo = options.replyTo;
    }

    return mailData as MailDataRequired;
  }

  private getIpPoolObject(options: IEmailOptions) {
    const ipPoolNameValue = options.ipPoolName || this.config.ipPoolName;

    return ipPoolNameValue ? { ipPoolName: ipPoolNameValue } : {};
  }

  getMessageId(body: unknown | unknown[]): string[] {
    if (Array.isArray(body)) {
      return body.map((item: any) => item.id);
    }

    return [(body as any).id];
  }

  async verifySignature({
    rawBody,
    headers = {},
    body: _body,
  }: {
    rawBody: any;
    headers?: Record<string, string>;
    body?: Record<string, unknown>;
  }): Promise<{ success: boolean; message?: string }> {
    try {
      const signature = this.getHeaderValue(headers, 'x-twilio-email-event-webhook-signature');
      const timestamp = this.getHeaderValue(headers, 'x-twilio-email-event-webhook-timestamp');
      const isSignatureVerificationEnabled = signature && timestamp;

      if (!isSignatureVerificationEnabled) {
        return { success: true, message: 'SendGrid signature verification is disabled for this request' };
      }
      const publicKey = this.config.webhookPublicKey;

      if (!publicKey || rawBody === undefined) {
        const message = [!publicKey ? 'Public key is undefined' : '', !rawBody ? 'Body is undefined' : '']
          .filter(Boolean)
          .join(',');
        return { success: false, message };
      }

      const eventWebhook = new EventWebhook();
      const ecdsaPublicKey = eventWebhook.convertPublicKeyToECDSA(publicKey);

      const result = eventWebhook.verifySignature(ecdsaPublicKey, rawBody, signature, timestamp);

      return { success: result, message: 'Provider signature verification result' };
    } catch (error) {
      return { success: false, message: `Error verifying signature: ${error.message}` };
    }
  }

  async autoConfigureInboundWebhook(configurations: { webhookUrl: string }): Promise<{
    success: boolean;
    message?: string;
    configurations?: {
      inboundWebhookEnabled: boolean;
      inboundWebhookSigningKey: string;
    };
  }> {
    try {
      // Step 1: Create a new Event Webhook
      const [createResponse, createBody] = await this.sendgridClient.request({
        url: '/v3/user/webhooks/event/settings',
        method: 'POST' as const,
        body: {
          url: configurations.webhookUrl,
          enabled: true,
          delivery_logs: true,
          engagement_data: true,
          friendly_name: 'Novu Inbound Webhook',
          open: true,
          click: true,
          bounce: true,
          dropped: true,
          delivered: true,
        },
      });

      if (createResponse.statusCode !== 201) {
        return {
          success: false,
          message: `Failed to create webhook: ${createBody?.errors?.[0]?.message || 'Unknown error'}`,
        };
      }

      const webhookId = createBody.id;

      // Step 2: Enable Signature Verification
      const [enableSignatureResponse, enableSignatureBody] = await this.sendgridClient.request({
        url: `/v3/user/webhooks/event/settings/signed/${webhookId}`,
        method: 'PATCH' as const,
        body: {
          enabled: true,
        },
      });

      if (enableSignatureResponse.statusCode !== 200) {
        return {
          success: false,
          message: `Failed to enable signature verification: ${enableSignatureBody?.errors?.[0]?.message || 'Unknown error'}`,
        };
      }

      const publicKey = enableSignatureBody.public_key;

      if (!publicKey) {
        return {
          success: false,
          message: 'Failed to retrieve signature verification key',
        };
      }

      return {
        success: true,
        message: 'SendGrid webhook configured successfully with signature verification enabled',
        configurations: {
          inboundWebhookEnabled: true,
          inboundWebhookSigningKey: publicKey,
        },
      };
    } catch (error: any) {
      return {
        success: false,
        message: `Error configuring SendGrid webhook: ${error?.response?.body?.errors?.[0]?.message ? error?.response?.body?.errors?.[0]?.message : 'Unknown error'}`,
      };
    }
  }

  private getHeaderValue(headers: Record<string, string>, headerName: string): string | undefined {
    // Case-insensitive header lookup
    const lowerHeaderName = headerName.toLowerCase();
    const key = Object.keys(headers).find((k) => k.toLowerCase() === lowerHeaderName);

    return key ? headers[key] : undefined;
  }

  parseEventBody(body: unknown | unknown[], identifier: string): IEmailEventBody | undefined {
    let eventBody: Record<string, unknown>;
    if (Array.isArray(body)) {
      eventBody = body.find((item: Record<string, unknown>) => item.id === identifier);
    } else {
      eventBody = body as Record<string, unknown>;
    }

    if (!eventBody) {
      return undefined;
    }

    const status = this.getStatus(eventBody.event as string);

    if (status === undefined) {
      return undefined;
    }

    return {
      status,
      date: new Date().toISOString(),
      externalId: eventBody.id as string,
      attempts: eventBody.attempt ? parseInt(eventBody.attempt as string, 10) : 1,
      response: eventBody.response ? (eventBody.response as string) : '',
      row: JSON.stringify(eventBody),
    };
  }

  private getStatus(event: string): EmailEventStatusEnum | undefined {
    switch (event) {
      case 'open':
        return EmailEventStatusEnum.OPENED;
      case 'bounce':
        return EmailEventStatusEnum.BOUNCED;
      case 'click':
        return EmailEventStatusEnum.CLICKED;
      case 'dropped':
        return EmailEventStatusEnum.DROPPED;
      case 'delivered':
        return EmailEventStatusEnum.DELIVERED;
      default:
        return undefined;
    }
  }
}

const mapResponse = (statusCode: number) => {
  switch (statusCode) {
    case 400:
    case 401:
      return CheckIntegrationResponseEnum.BAD_CREDENTIALS;
    case 403:
      return CheckIntegrationResponseEnum.INVALID_EMAIL;
    default:
      return CheckIntegrationResponseEnum.FAILED;
  }
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - attachments(options.attachments?.map((attachment: IAttachmentOptions))
 - ipPoolNameValue(options.ipPoolName || this.config.ipPoolName;

    return ipPoolNameValue ? { ipPoolName: ipPoolName...)
 - key(Object.keys(headers).find((k))
 - eventBody(body.find((item: Record<string, unknown>))
 - mapResponse(statusCode: number))
Declaraciones 'export' encontradas:
- export class SendgridEmailProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/ses/ses.config.ts
Tamaño: 170 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export interface SESConfig {
  from: string;
  region: string;
  senderName: string;
  accessKeyId: string;
  secretAccessKey: string;
  configurationSetName?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  interface

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/ses/ses.provider.spec.ts
Tamaño: 11780 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SESClient } from '@aws-sdk/client-ses';
import { EmailEventStatusEnum } from '@novu/stateless';
import { describe, expect, test, vi } from 'vitest';
import { SESEmailProvider } from './ses.provider';

const mockConfig = {
  region: 'us-east-1',
  senderName: 'Test',
  accessKeyId: 'TEST',
  from: 'test@test.com',
  secretAccessKey: 'TEST',
};

const mockNovuMessage = {
  to: ['test@test2.com'],
  replyTo: 'test@test1.com',
  subject: 'test subject',
  html: '<div> Mail Content </div>',
  attachments: [{ mime: 'text/plain', file: Buffer.from('test'), name: 'test.txt' }],
};

const mockSESMessage = {
  eventType: 'Delivery',
  Message: JSON.stringify({
    eventType: 'Delivery',
    mail: {
      timestamp: '2016-10-19T23:20:52.240Z',
      messageId: 'EXAMPLE7c191be45-e9aedb9a-02f9-4d12-a87d-dd0099a07f8a-000000',
      sourceArn: 'arn:aws:ses:us-east-1:123456789012:identity/sender@example.com',
    },
  }),
  Type: 'Notification',
  mail: {
    timestamp: '2016-10-19T23:20:52.240Z',
    source: 'sender@example.com',
    sourceArn: 'arn:aws:ses:us-east-1:123456789012:identity/sender@example.com',
    sendingAccountId: '123456789012',
    messageId: 'EXAMPLE7c191be45-e9aedb9a-02f9-4d12-a87d-dd0099a07f8a-000000',
    destination: ['recipient@example.com'],
    headersTruncated: false,
    headers: [
      {
        name: 'From',
        value: 'sender@example.com',
      },
      {
        name: 'To',
        value: 'recipient@example.com',
      },
      {
        name: 'Subject',
        value: 'Message sent from Amazon SES',
      },
      {
        name: 'MIME-Version',
        value: '1.0',
      },
      {
        name: 'Content-Type',
        value: 'text/html; charset=UTF-8',
      },
      {
        name: 'Content-Transfer-Encoding',
        value: '7bit',
      },
    ],
    commonHeaders: {
      from: ['sender@example.com'],
      to: ['recipient@example.com'],
      messageId: 'EXAMPLE7c191be45-e9aedb9a-02f9-4d12-a87d-dd0099a07f8a-000000',
      subject: 'Message sent from Amazon SES',
    },
    tags: {
      'ses:configuration-set': ['ConfigSet'],
      'ses:source-ip': ['192.0.2.0'],
      'ses:from-domain': ['example.com'],
      'ses:caller-identity': ['ses_user'],
      'ses:outgoing-ip': ['192.0.2.0'],
      myCustomTag1: ['myCustomTagValue1'],
      myCustomTag2: ['myCustomTagValue2'],
    },
  },
  delivery: {
    timestamp: '2016-10-19T23:21:04.133Z',
    processingTimeMillis: 11893,
    recipients: ['recipient@example.com'],
    smtpResponse: '250 2.6.0 Message received',
    reportingMTA: 'mta.example.com',
  },
};

test('should trigger ses library correctly', async () => {
  const mockResponse = { MessageId: 'mock-message-id' };
  const spy = vi.spyOn(SESClient.prototype, 'send').mockImplementation(async () => {
    return mockResponse as any;
  });

  const provider = new SESEmailProvider(mockConfig);
  const response = await provider.sendMessage(mockNovuMessage);

  const bufferArray = spy.mock.calls[0][0].input['RawMessage']['Data'];
  const buffer = Buffer.from(bufferArray);
  const emailContent = buffer.toString();

  expect(spy).toHaveBeenCalled();
  expect(emailContent.includes('Reply-To: test@test1.com')).toBe(true);
  expect(response.id).toEqual('<mock-message-id@email.amazonses.com>');
});

test('should trigger ses library correctly with _passthrough', async () => {
  const mockResponse = { MessageId: 'mock-message-id' };
  const spy = vi.spyOn(SESClient.prototype, 'send').mockImplementation(async () => {
    return mockResponse as any;
  });

  const provider = new SESEmailProvider(mockConfig);
  const response = await provider.sendMessage(mockNovuMessage, {
    _passthrough: {
      body: {
        subject: 'test subject _passthrough',
      },
    },
  });

  const bufferArray = spy.mock.calls[0][0].input['RawMessage']['Data'];
  const buffer = Buffer.from(bufferArray);
  const emailContent = buffer.toString();

  expect(spy).toHaveBeenCalled();
  expect(emailContent.includes('Subject: test subject _passthrough')).toBe(true);
  expect(response.id).toEqual('<mock-message-id@email.amazonses.com>');
});

describe('getMessageId', () => {
  test('should return messageId when body is valid', async () => {
    const provider = new SESEmailProvider(mockConfig);
    const messageId = provider.getMessageId(mockSESMessage);
    expect(messageId).toEqual([`<${mockSESMessage.mail.messageId}@${mockConfig.region}.amazonses.com>`]);
  });

  test('should return undefined when event body is undefined', async () => {
    const provider = new SESEmailProvider(mockConfig);
    const messageId = provider.parseEventBody(undefined, 'test');
    expect(messageId).toBeUndefined();
  });

  test('should return undefined when event body is empty', async () => {
    const provider = new SESEmailProvider(mockConfig);
    const messageId = provider.parseEventBody([], 'test');
    expect(messageId).toBeUndefined();
  });
});

describe('parseEventBody', () => {
  test('should return IEmailEventBody object when body is valid', async () => {
    const provider = new SESEmailProvider(mockConfig);
    const eventBody = provider.parseEventBody(mockSESMessage, 'test');
    const dateISO = new Date(mockSESMessage.mail.timestamp).toISOString();
    expect(eventBody).toEqual({
      status: EmailEventStatusEnum.DELIVERED,
      date: dateISO,
      externalId: mockSESMessage.mail.messageId,
      attempts: undefined,
      response: undefined,
      row: JSON.stringify(mockSESMessage),
    });
  });

  test('should return undefined when event body is undefined', async () => {
    const provider = new SESEmailProvider(mockConfig);
    const eventBody = provider.parseEventBody(undefined, 'test');
    expect(eventBody).toBeUndefined();
  });

  test('should return undefined when status is unrecognized', async () => {
    const provider = new SESEmailProvider(mockConfig);
    const messageId = provider.parseEventBody({ event: 'not-real-event' }, 'test');
    expect(messageId).toBeUndefined();
  });
});

describe('Certificate URL Security Validation', () => {
  const createMockSnsMessage = (signingCertUrl: string) => ({
    Type: 'Notification',
    MessageId: 'test-message-id',
    TopicArn: 'arn:aws:sns:us-east-1:123456789012:test-topic',
    Timestamp: new Date().toISOString(),
    SignatureVersion: '1',
    Signature: 'mock-signature',
    SigningCertURL: signingCertUrl,
    Message: 'mock-message',
  });

  test('should accept valid AWS SNS certificate URLs', async () => {
    // Mock fetch to prevent actual HTTP requests
    const mockFetch = vi.fn().mockResolvedValue({
      ok: false,
      text: async () => 'mock-certificate',
    });
    vi.stubGlobal('fetch', mockFetch);

    const provider = new SESEmailProvider(mockConfig);
    const validUrls = [
      'https://sns.amazonaws.com/SimpleNotificationService.pem',
      'https://sns.us-east-1.amazonaws.com/cert.pem',
      'https://sns.eu-west-1.amazonaws.com/cert.pem',
      'https://sns.ap-southeast-2.amazonaws.com/cert.pem',
      'https://sns.us-gov-west-1.amazonaws.com/cert.pem',
      'https://s3.amazonaws.com/sns-certificates/cert.pem',
    ];

    for (const url of validUrls) {
      const result = await provider.verifySignature({
        rawBody: null,
        body: createMockSnsMessage(url),
        headers: { 'x-amz-sns-message-type': 'Notification' },
      });

      expect(result.success).toBe(false);
      expect(result.message).not.toContain('Invalid AWS certificate URL');
    }

    vi.unstubAllGlobals();
  });

  test('should reject malicious certificate URLs with subdomain injection', async () => {
    const provider = new SESEmailProvider(mockConfig);
    const maliciousUrls = [
      'https://sns.evil.amazonaws.com/cert.pem', // Subdomain injection
      'https://sns.malicious-site.amazonaws.com/cert.pem', // Subdomain injection
      'https://sns.attacker.amazonaws.com/cert.pem', // Subdomain injection
      'https://sns.amazonaws.com.evil.com/cert.pem', // Domain spoofing
      'https://evil.sns.amazonaws.com/cert.pem', // Prefix injection
      'https://amazonaws.com.evil.com/cert.pem', // Domain spoofing
    ];

    for (const url of maliciousUrls) {
      const result = await provider.verifySignature({
        rawBody: null,
        body: createMockSnsMessage(url),
        headers: { 'x-amz-sns-message-type': 'Notification' },
      });

      expect(result.success).toBe(false);
      expect(result.message).toContain('Invalid AWS certificate URL');
    }
  });

  test('should reject non-HTTPS certificate URLs', async () => {
    const provider = new SESEmailProvider(mockConfig);
    const insecureUrls = [
      'http://sns.amazonaws.com/cert.pem',
      'ftp://sns.amazonaws.com/cert.pem',
      'sns.amazonaws.com/cert.pem',
    ];

    for (const url of insecureUrls) {
      const result = await provider.verifySignature({
        rawBody: null,
        body: createMockSnsMessage(url),
        headers: { 'x-amz-sns-message-type': 'Notification' },
      });

      expect(result.success).toBe(false);
      expect(result.message).toContain('Invalid AWS certificate URL');
    }
  });

  test('should reject certificate URLs from non-AWS domains', async () => {
    const provider = new SESEmailProvider(mockConfig);
    const nonAwsUrls = [
      'https://evil.com/sns.amazonaws.com/cert.pem',
      'https://example.com/cert.pem',
      'https://sns.fake-aws.com/cert.pem',
      'https://amazonaws.evil.com/cert.pem',
    ];

    for (const url of nonAwsUrls) {
      const result = await provider.verifySignature({
        rawBody: null,
        body: createMockSnsMessage(url),
        headers: { 'x-amz-sns-message-type': 'Notification' },
      });

      expect(result.success).toBe(false);
      expect(result.message).toContain('Invalid AWS certificate URL');
    }
  });

  test('should validate regional SNS endpoints correctly', async () => {
    // Mock fetch to prevent actual HTTP requests
    const mockFetch = vi.fn().mockResolvedValue({
      ok: false,
      text: async () => 'mock-certificate',
    });
    vi.stubGlobal('fetch', mockFetch);

    const provider = new SESEmailProvider(mockConfig);
    const regionalUrls = [
      'https://sns.us-east-1.amazonaws.com/cert.pem',
      'https://sns.us-west-2.amazonaws.com/cert.pem',
      'https://sns.eu-central-1.amazonaws.com/cert.pem',
      'https://sns.ap-northeast-1.amazonaws.com/cert.pem',
      'https://sns.ca-central-1.amazonaws.com/cert.pem',
      'https://sns.us-gov-east-1.amazonaws.com/cert.pem',
    ];

    for (const url of regionalUrls) {
      const result = await provider.verifySignature({
        rawBody: null,
        body: createMockSnsMessage(url),
        headers: { 'x-amz-sns-message-type': 'Notification' },
      });

      expect(result.success).toBe(false);
      expect(result.message).not.toContain('Invalid AWS certificate URL');
    }

    vi.unstubAllGlobals();
  });

  test('should reject invalid regional patterns', async () => {
    const provider = new SESEmailProvider(mockConfig);
    const invalidRegionalUrls = [
      'https://sns.invalid-region.amazonaws.com/cert.pem',
      'https://sns.us-east-99.amazonaws.com/cert.pem',
      'https://sns.evil-central-1.amazonaws.com/cert.pem',
      'https://sns..amazonaws.com/cert.pem',
      'https://sns.us-.amazonaws.com/cert.pem',
      'https://sns.-east-1.amazonaws.com/cert.pem',
    ];

    for (const url of invalidRegionalUrls) {
      const result = await provider.verifySignature({
        rawBody: null,
        body: createMockSnsMessage(url),
        headers: { 'x-amz-sns-message-type': 'Notification' },
      });

      expect(result.success).toBe(false);
      expect(result.message).toContain('Invalid AWS certificate URL');
    }
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - charset(UTF-8',
      },
      {
        name: 'Content-Transfer-Encoding',
        value: '7bit',
      },
...)
 - spy(vi.spyOn(SESClient.prototype, 'send').mockImplementation(async ())
 - emailContent(buffer.toString();

  expect(spy).toHaveBeenCalled();
  expect(emailContent.includes('Reply-To: test...)
 - spy(vi.spyOn(SESClient.prototype, 'send').mockImplementation(async ())
 - emailContent(buffer.toString();

  expect(spy).toHaveBeenCalled();
  expect(emailContent.includes('Subject: test ...)
 - messageId(provider.getMessageId(mockSESMessage);
    expect(messageId).toEqual([`<${mockSESMessage.mail.messag...)
 - messageId(provider.parseEventBody(undefined, 'test');
    expect(messageId).toBeUndefined();
  });

  test('sh...)
 - messageId(provider.parseEventBody([], 'test');
    expect(messageId).toBeUndefined();
  });
});

describe('par...)
 - dateISO(new Date(mockSESMessage.mail.timestamp).toISOString();
    expect(eventBody).toEqual({
      status:...)
 - eventBody(provider.parseEventBody(undefined, 'test');
    expect(eventBody).toBeUndefined();
  });

  test('sh...)
 - messageId(provider.parseEventBody({ event: 'not-real-event' }, 'test');
    expect(messageId).toBeUndefined();...)
 - createMockSnsMessage(signingCertUrl: string))
 - mockFetch(vi.fn().mockResolvedValue({
      ok: false,
      text: async ())
 - result(await provider.verifySignature({
        rawBody: null,
        body: createMockSnsMessage(url),
   ...)
 - result(await provider.verifySignature({
        rawBody: null,
        body: createMockSnsMessage(url),
   ...)
 - result(await provider.verifySignature({
        rawBody: null,
        body: createMockSnsMessage(url),
   ...)
 - result(await provider.verifySignature({
        rawBody: null,
        body: createMockSnsMessage(url),
   ...)
 - mockFetch(vi.fn().mockResolvedValue({
      ok: false,
      text: async ())
 - result(await provider.verifySignature({
        rawBody: null,
        body: createMockSnsMessage(url),
   ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/ses/ses.provider.ts
Tamaño: 15045 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SESClient, SendRawEmailCommand } from '@aws-sdk/client-ses';
import { EmailProviderIdEnum } from '@novu/shared';
import {
  ChannelTypeEnum,
  CheckIntegrationResponseEnum,
  EmailEventStatusEnum,
  ICheckIntegrationResponse,
  IEmailEventBody,
  IEmailOptions,
  IEmailProvider,
  ISendMessageSuccessResponse,
} from '@novu/stateless';
import { createVerify } from 'crypto';
import nodemailer from 'nodemailer';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';
import { SESConfig } from './ses.config';

export class SESEmailProvider extends BaseProvider implements IEmailProvider {
  id = EmailProviderIdEnum.SES;
  protected casing: CasingEnum = CasingEnum.CAMEL_CASE;
  channelType = ChannelTypeEnum.EMAIL as ChannelTypeEnum.EMAIL;
  private readonly ses: SESClient;

  constructor(private readonly config: SESConfig) {
    super();
    this.ses = new SESClient({
      region: this.config.region,
      credentials: {
        accessKeyId: this.config.accessKeyId,
        secretAccessKey: this.config.secretAccessKey,
      },
    });
  }

  private async sendMail(
    { html, text, to, from, senderName, subject, attachments, cc, bcc, replyTo },
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ) {
    const transporter = nodemailer.createTransport({
      SES: { ses: this.ses, aws: { SendRawEmailCommand } },
    });

    return await transporter.sendMail(
      this.transform(bridgeProviderData, {
        to,
        html,
        text,
        subject,
        attachments,
        from: {
          address: from,
          name: senderName,
        },
        cc,
        bcc,
        replyTo,
        ...(this.config.configurationSetName && {
          ses: { ConfigurationSetName: this.config.configurationSetName },
        }),
      }).body
    );
  }

  async sendMessage(
    { html, text, to, from, subject, attachments, cc, bcc, replyTo, senderName }: IEmailOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const info = await this.sendMail(
      {
        from: from || this.config.from,
        senderName: senderName || this.config.senderName,
        to,
        subject,
        html,
        text,
        attachments: attachments?.map((attachment) => ({
          filename: attachment?.name,
          content: attachment.file,
          contentType: attachment.mime,
          cid: attachment.cid,
          contentDisposition: attachment.disposition ?? (attachment.cid ? 'inline' : undefined),
        })),
        cc,
        bcc,
        replyTo,
      },
      bridgeProviderData
    );

    return {
      id: info?.messageId,
      date: new Date().toISOString(),
    };
  }

  getMessageId(body: unknown | unknown[]): string[] {
    const parsedBody = this.jsonParseBody(body);

    if (Array.isArray(parsedBody)) {
      return parsedBody.map((item) => this.buildMessageId(item)).filter((item) => item !== undefined);
    }

    return [this.buildMessageId(parsedBody)].filter((item) => item !== undefined);
  }

  private jsonParseBody(body: unknown) {
    // Extract actual webhook data from SNS notification wrapper if present
    let extractedMessage = null;

    // Check if this is an SNS notification containing webhook data
    if (this.isSnsNotificationWithMessage(body)) {
      try {
        // Parse the nested Message field which contains the actual SES webhook data
        extractedMessage = JSON.parse((body as Record<string, unknown>).Message as string);
      } catch {
        throw new Error('Failed to parse SNS Message field');
      }
    }

    return { ...(body as Record<string, unknown>), ...(extractedMessage && { Message: extractedMessage }) };
  }

  parseEventBody(body: unknown | unknown[], _identifier: string): IEmailEventBody | undefined {
    if (!body) {
      return undefined;
    }

    const parsedBody = this.jsonParseBody(body);

    if (!parsedBody || !parsedBody.Message) {
      return undefined;
    }

    const message = parsedBody as Record<string, unknown>;
    const messageData = message.Message as Record<string, unknown>;
    const status = this.getStatus(messageData.eventType as string);

    if (status === undefined) {
      return undefined;
    }

    const mailData = messageData.mail as Record<string, unknown>;

    return {
      status,
      date: new Date(mailData.timestamp as string).toISOString(),
      externalId: mailData.messageId as string,
      row: JSON.stringify(body),
      attempts: undefined,
      response: undefined,
    };
  }

  /**
   * Checks if this is an SNS notification containing a Message field with webhook data
   */
  private isSnsNotificationWithMessage(body: unknown): boolean {
    const snsBody = body as Record<string, unknown>;
    return (
      snsBody?.Type === 'Notification' && typeof snsBody?.Message === 'string' && (snsBody.Message as string).length > 0
    );
  }

  /**
   * The `Subscription` event status is not considered since it is not an action
   * or outcome of the event but the state of the subscriber preferences.
   */
  private getStatus(event: string): EmailEventStatusEnum | undefined {
    switch (event) {
      case 'Bounce':
        return EmailEventStatusEnum.BOUNCED;
      case 'Complaint':
        return EmailEventStatusEnum.COMPLAINT;
      case 'Delivery':
        return EmailEventStatusEnum.DELIVERED;
      case 'Send':
        return EmailEventStatusEnum.SENT;
      case 'Reject':
        return EmailEventStatusEnum.REJECTED;
      case 'Open':
        return EmailEventStatusEnum.OPENED;
      case 'Click':
        return EmailEventStatusEnum.CLICKED;
      case 'DeliveryDelay':
        return EmailEventStatusEnum.DELAYED;
      default:
        return undefined;
    }
  }

  async checkIntegration(): Promise<ICheckIntegrationResponse> {
    try {
      await this.sendMail({
        html: '',
        text: 'This is a Test mail to test your Amazon SES integration',
        to: 'no-reply@novu.co',
        from: this.config.from,
        subject: 'Test SES integration',
        attachments: {},
        bcc: [],
        cc: [],
        replyTo: this.config.from,
        senderName: this.config.senderName,
      });

      return {
        success: true,
        message: 'Integrated Successfully',
        code: CheckIntegrationResponseEnum.SUCCESS,
      };
    } catch (error) {
      return {
        success: false,
        message: error?.message,
        code: CheckIntegrationResponseEnum.FAILED,
      };
    }
  }

  async verifySignature({
    rawBody: _rawBody,
    headers = {},
    body,
  }: {
    rawBody: unknown;
    headers?: Record<string, string>;
    body?: Record<string, unknown>;
  }): Promise<{ success: boolean; message?: string }> {
    try {
      // Parse the raw body if it's a string
      const snsMessage = typeof body === 'string' ? JSON.parse(body) : body;

      // Validate that this looks like an SNS message
      if (!this.isValidSnsMessage(snsMessage)) {
        return {
          success: false,
          message: 'Invalid SNS message structure',
        };
      }

      // Check if this is a subscription confirmation or notification
      const messageType = headers['x-amz-sns-message-type'] || (snsMessage as Record<string, unknown>).Type;

      if (!messageType || !['SubscriptionConfirmation', 'Notification'].includes(messageType as string)) {
        return {
          success: false,
          message: `Unsupported SNS message type: ${messageType}`,
        };
      }

      const additionalValidation = this.performAdditionalSecurityChecks(snsMessage as Record<string, unknown>);
      if (!additionalValidation.success) {
        return additionalValidation;
      }

      return await this.verifyCryptographicSignature(snsMessage as Record<string, unknown>);
    } catch (error) {
      return {
        success: false,
        message: `SNS signature verification error: ${error instanceof Error ? error.message : 'Unknown error'}`,
      };
    }
  }

  /**
   * Validates that the message has the required SNS structure
   */
  private isValidSnsMessage(message: unknown): boolean {
    if (!message || typeof message !== 'object') {
      return false;
    }

    // Required fields for all SNS messages
    const requiredFields = [
      'Type',
      'MessageId',
      'TopicArn',
      'Timestamp',
      'SignatureVersion',
      'Signature',
      'SigningCertURL',
    ];

    return requiredFields.every((field) => message.hasOwnProperty(field));
  }

  /**
   * Performs additional security validation beyond basic signature verification
   * to reduce attack vectors and minimize latency by avoiding AWS SigningCert API calls
   */
  private performAdditionalSecurityChecks(snsMessage: Record<string, unknown>): { success: boolean; message?: string } {
    // Validate timestamp to prevent replay attacks (within 15 minutes)
    const messageTime = new Date(snsMessage.Timestamp as string).getTime();
    const currentTime = Date.now();
    const fifteenMinutes = 15 * 60 * 1000;

    if (currentTime - messageTime > fifteenMinutes) {
      return {
        success: false,
        message: 'SNS message timestamp is too old (replay attack prevention)',
      };
    }

    // Validate the SigningCertURL is from AWS
    const certUrl = snsMessage.SigningCertURL as string;
    if (!this.isValidAwsCertificateUrl(certUrl)) {
      return {
        success: false,
        message: 'Invalid AWS certificate URL',
      };
    }

    // Validate signature version
    if (snsMessage.SignatureVersion !== '1') {
      return {
        success: false,
        message: `Unsupported signature version: ${snsMessage.SignatureVersion}`,
      };
    }

    // Validate region matches if configured
    if (this.config.region) {
      const topicRegion = this.extractRegionFromTopicArn(snsMessage.TopicArn as string);
      if (topicRegion && topicRegion !== this.config.region) {
        return {
          success: false,
          message: `Topic region ${topicRegion} does not match configured region ${this.config.region}`,
        };
      }
    }

    return {
      success: true,
      message: 'SNS signature verification successful',
    };
  }

  /**
   * Validates that the certificate URL is from AWS
   */
  private isValidAwsCertificateUrl(url: string): boolean {
    if (!url) return false;

    try {
      const parsedUrl = new URL(url);

      // Must be HTTPS
      if (parsedUrl.protocol !== 'https:') {
        return false;
      }

      // Must be from AWS SNS certificate domains - exact matches only to prevent subdomain injection
      const validExactDomains = [
        'sns.amazonaws.com',
        's3.amazonaws.com', // SNS certificates are also served from S3
      ];

      return validExactDomains.includes(parsedUrl.hostname) || this.isValidSnsRegionalEndpoint(parsedUrl.hostname);
    } catch {
      return false;
    }
  }

  /**
   * Validates SNS regional endpoints to prevent subdomain injection attacks
   * Uses comprehensive regex pattern that supports all current and future AWS regions
   * while maintaining security by validating the complete hostname structure
   */
  private isValidSnsRegionalEndpoint(hostname: string): boolean {
    // AWS region patterns:
    const validSnsHostnamePattern =
      /^sns\.((?:[a-z]{2}(?:-gov)?-(?:central|north|south|east|west|northeast|northwest|southeast|southwest)-[1-9])|(?:cn-(?:north|northwest)-1))\.amazonaws\.com$/;

    const match = hostname.match(validSnsHostnamePattern);
    if (!match) {
      return false;
    }

    const region = match[1];

    // Reconstruct expected hostname from validated components and compare exactly
    // This prevents bypass attacks by ensuring exact match
    const expectedHostname = `sns.${region}.amazonaws.com`;
    return hostname === expectedHostname;
  }

  /**
   * Extracts region from SNS Topic ARN
   */
  private extractRegionFromTopicArn(topicArn: string): string | null {
    if (!topicArn) return null;

    // ARN format: arn:aws:sns:region:account-id:topic-name
    const arnParts = topicArn.split(':');
    if (arnParts.length >= 4 && arnParts[0] === 'arn' && arnParts[1] === 'aws' && arnParts[2] === 'sns') {
      return arnParts[3];
    }

    return null;
  }

  private async verifyCryptographicSignature(
    snsMessage: Record<string, unknown>
  ): Promise<{ success: boolean; message?: string }> {
    try {
      const { SigningCertURL, Signature, Type } = snsMessage;

      // Download the certificate
      const response = await fetch(SigningCertURL as string);
      if (!response.ok) {
        return { success: false, message: 'Failed to download certificate' };
      }
      const certificate = await response.text();

      // Build the string to sign based on message type
      const stringToSign =
        Type === 'SubscriptionConfirmation'
          ? this.buildSubscriptionStringToSign(snsMessage)
          : this.buildNotificationStringToSign(snsMessage);

      // Verify the signature
      const verify = createVerify('sha1WithRSAEncryption');
      verify.update(stringToSign, 'utf8');
      const isValid = verify.verify(certificate, Signature as string, 'base64');

      return isValid
        ? { success: true, message: 'Cryptographic signature verification successful' }
        : { success: false, message: 'Invalid signature' };
    } catch (error) {
      return {
        success: false,
        message: `Signature verification failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
      };
    }
  }

  private buildNotificationStringToSign(msg: Record<string, unknown>): string {
    const { Message, MessageId, Subject, Timestamp, TopicArn, Type } = msg;
    let str = `Message\n${Message}\nMessageId\n${MessageId}\n`;
    if (Subject) str += `Subject\n${Subject}\n`;
    str += `Timestamp\n${Timestamp}\nTopicArn\n${TopicArn}\nType\n${Type}\n`;
    return str;
  }

  private buildSubscriptionStringToSign(msg: Record<string, unknown>): string {
    const { Message, MessageId, SubscribeURL, Timestamp, Token, TopicArn, Type } = msg;
    return `Message\n${Message}\nMessageId\n${MessageId}\nSubscribeURL\n${SubscribeURL}\nTimestamp\n${Timestamp}\nToken\n${Token}\nTopicArn\n${TopicArn}\nType\n${Type}\n`;
  }

  private buildMessageId(body: Record<string, unknown>): string | undefined {
    // biome-ignore lint/suspicious/noExplicitAny: <explanation> x
    if (!(body?.Message as any)?.mail?.messageId) {
      return undefined;
    }

    const message = body.Message as Record<string, unknown>;
    const mailData = message.mail as Record<string, unknown>;

    if (mailData.messageId) {
      const messageId = mailData.messageId as string;
      // this is the format of the messageId generated by AWS SES SendEmail API
      return `<${messageId}@${this.config.region}.amazonses.com>`;
    }

    throw new Error('Unable to extract message ID from webhook body');
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - info(await this.sendMail(
      {
        from: from || this.config.from,
        senderName: senderName ...)
 - parsedBody(this.jsonParseBody(body);

    if (Array.isArray(parsedBody)) {
      return parsedBody.map((item))
 - requiredFields([
      'Type',
      'MessageId',
      'TopicArn',
      'Timestamp',
      'SignatureVersion',
  ...)
Declaraciones 'export' encontradas:
- export class SESEmailProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/sparkpost/sparkpost.error.ts
Tamaño: 414 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export interface ISparkPostErrorResponse {
  errors: Array<{
    description: string;
    code: string;
    message: string;
  }>;
}

export class SparkPostError extends Error implements ISparkPostErrorResponse {
  readonly errors: ISparkPostErrorResponse['errors'];

  constructor(
    response: ISparkPostErrorResponse,
    readonly statusCode: number
  ) {
    super();
    this.errors = response.errors;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  interface
- export class SparkPostError

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/sparkpost/sparkpost.provider.spec.ts
Tamaño: 2636 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, test } from 'vitest';
import { axiosSpy } from '../../../utils/test/spy-axios';
import { SparkPostEmailProvider } from './sparkpost.provider';

const mockConfig = {
  apiKey: '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',
  region: undefined,
  from: 'test@test.com',
  senderName: 'test',
};

const mockNovuMessage = {
  from: 'test@test.com',
  to: ['test@test.com'],
  html: '<div> Mail Content </div>',
  subject: 'Test subject',
  attachments: [{ mime: 'text/plain', file: Buffer.from('dGVzdA=='), name: 'test.txt' }],
};

test('should trigger sparkpost library correctly', async () => {
  const { mockPost: spy } = axiosSpy({
    data: {
      results: {
        id: 'id',
      },
    },
  });
  const provider = new SparkPostEmailProvider(mockConfig);

  await provider.sendMessage(mockNovuMessage);

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith(
    '/transmissions',
    {
      content: {
        attachments: [{ data: 'ZEdWemRBPT0=', name: 'test.txt', type: 'text/plain' }],
        from: 'test@test.com',
        html: '<div> Mail Content </div>',
        subject: 'Test subject',
        text: undefined,
      },
      recipients: [{ address: 'test@test.com' }],
    },
    {
      baseURL: 'https://api.sparkpost.com/api/v1',
      headers: {
        Authorization: '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',
        'Content-Type': 'application/json',
      },
    }
  );
});

test('should trigger sparkpost library correctly with _passthrough', async () => {
  const { mockPost: spy } = axiosSpy({
    data: {
      results: {
        id: 'id',
      },
    },
  });
  const provider = new SparkPostEmailProvider(mockConfig);

  await provider.sendMessage(mockNovuMessage, {
    _passthrough: {
      body: {
        content: {
          subject: 'Test subject _passthrough',
        },
      },
    },
  });

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith(
    '/transmissions',
    {
      content: {
        attachments: [{ data: 'ZEdWemRBPT0=', name: 'test.txt', type: 'text/plain' }],
        from: 'test@test.com',
        html: '<div> Mail Content </div>',
        subject: 'Test subject _passthrough',
        text: undefined,
      },
      recipients: [{ address: 'test@test.com' }],
    },
    {
      baseURL: 'https://api.sparkpost.com/api/v1',
      headers: {
        Authorization: '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',
        'Content-Type': 'application/json',
      },
    }
  );
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - ZEdWemRBPT0(', name: 'test.txt', type: 'text/plain' }],
        from: 'test@test.com',
        html: '<div> Mail...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/email/sparkpost/sparkpost.provider.ts
Tamaño: 3783 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EmailProviderIdEnum } from '@novu/shared';
import {
  ChannelTypeEnum,
  CheckIntegrationResponseEnum,
  ICheckIntegrationResponse,
  IEmailOptions,
  IEmailProvider,
  ISendMessageSuccessResponse,
} from '@novu/stateless';
import axios, { AxiosError } from 'axios';
import { randomUUID } from 'crypto';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';
import { ISparkPostErrorResponse, SparkPostError } from './sparkpost.error';

interface ISparkPostResponse {
  results: {
    total_rejected_recipients: number;
    total_accepted_recipients: number;
    id: string;
  };
}

export class SparkPostEmailProvider extends BaseProvider implements IEmailProvider {
  protected casing: CasingEnum = CasingEnum.SNAKE_CASE;
  readonly id = EmailProviderIdEnum.SparkPost;
  readonly channelType = ChannelTypeEnum.EMAIL;
  private readonly endpoint: string;

  constructor(
    private config: {
      apiKey: string;
      region: string;
      from: string;
      senderName: string;
    }
  ) {
    super();
    this.endpoint = this.getEndpoint(config.region);
  }

  async sendMessage(
    { from, to, subject, text, html, attachments }: IEmailOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const recipients: { address: string }[] = to.map((recipient) => {
      return { address: recipient };
    });

    const files: Array<{ name: string; type: string; data: string }> = [];

    attachments?.forEach((attachment) => {
      files.push({
        name: attachment.name || randomUUID(),
        type: attachment.mime,
        data: attachment.file.toString('base64'),
      });
    });

    const data = this.transform(bridgeProviderData, {
      recipients,
      content: {
        from: from || this.config.from,
        subject,
        text,
        html,
        attachments: files,
      },
    });

    try {
      const sent = await axios.create().post<ISparkPostResponse>('/transmissions', data.body, {
        headers: {
          'Content-Type': 'application/json',
          Authorization: this.config.apiKey,
          ...data.headers,
        },
        baseURL: this.endpoint,
      });

      return {
        id: sent.data.results.id,
        date: new Date().toISOString(),
      };
    } catch (err) {
      this.createSparkPostError(err);
      throw err;
    }
  }

  async checkIntegration(options: IEmailOptions): Promise<ICheckIntegrationResponse> {
    try {
      await this.sendMessage({
        to: ['no-reply@novu.co'],
        from: this.config.from || options.from,
        subject: options.subject,
        text: options.text,
        html: options.html,
      });

      return {
        success: true,
        message: 'Integrated successfully!',
        code: CheckIntegrationResponseEnum.SUCCESS,
      };
    } catch (error) {
      return {
        success: false,
        message: error?.message,
        code: CheckIntegrationResponseEnum.FAILED,
      };
    }
  }

  private createSparkPostError(err: unknown) {
    if (axios.isAxiosError(err)) {
      const { response } = err as AxiosError<ISparkPostErrorResponse>;

      if (response && response.data && response.data.errors) {
        throw new SparkPostError(response.data, response.status);
      }
    }
  }

  private transformLegacyRegion(region: string | boolean) {
    if (region === 'true' || region === true) return 'eu';

    return region;
  }

  private getEndpoint(_region: string) {
    const region = this.transformLegacyRegion(_region);

    switch (region) {
      case 'eu':
        return 'https://api.eu.sparkpost.com/api/v1';
      default:
        return 'https://api.sparkpost.com/api/v1';
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SparkPostEmailProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/push/index.ts
Tamaño: 314 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './apns/apns.provider';
export * from './expo/expo.provider';
export * from './fcm/fcm.provider';
export * from './one-signal/one-signal.provider';
export * from './push-webhook/push-webhook.provider';
export * from './pusher-beams/pusher-beams.provider';
export * from './pushpad/pushpad.provider';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/push/push.base-provider.ts
Tamaño: 597 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChannelTypeEnum, IPushEventBody } from '@novu/stateless';
import { BaseProvider } from '../../base.provider';

export abstract class PushBaseProvider extends BaseProvider {
  channelType = ChannelTypeEnum.PUSH as ChannelTypeEnum.PUSH;

  getMessageId(body: any): string[] {
    if (body?.eventId) {
      return [body?.eventId];
    }

    return [];
  }

  parseEventBody(body: unknown | unknown[], _identifier: string): IPushEventBody | undefined {
    return {
      status: (body as any)?.eventType,
      row: JSON.stringify(body),
      date: new Date().toISOString(),
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  abstract

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/push/apns/apns.provider.spec.ts
Tamaño: 2527 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import apn from '@parse/node-apn';
import { expect, test, vi } from 'vitest';
import { APNSPushProvider } from './apns.provider';

test('should trigger apns library correctly', async () => {
  const mockSend = vi.fn(() => {
    return {
      failed: [],
      sent: [
        {
          device: 'device',
        },
      ],
    };
  });

  vi.spyOn(apn as any, 'Provider').mockImplementation(() => {
    return {
      send: mockSend,
      shutdown: () => {},
    };
  });

  const provider = new APNSPushProvider({
    key: 'key',
    keyId: 'keyId',
    teamId: 'teamId',
    bundleId: 'bundleId',
    production: true,
  });

  await provider.sendMessage({
    target: ['target'],
    title: 'title',
    content: 'content',
    payload: {
      data: 'data',
    },
    step: {
      digest: false,
      events: undefined,
      total_count: undefined,
    },
    subscriber: {},
  });

  expect(mockSend).toHaveBeenCalledWith(
    {
      encoding: 'utf8',
      payload: { data: 'data' },
      compiled: false,
      aps: {
        alert: {
          body: 'content',
          title: 'title',
        },
      },
      expiry: -1,
      priority: 10,
      topic: 'bundleId',
    },
    ['target']
  );
});

test('should trigger apns library correctly with _passthrough', async () => {
  const mockSend = vi.fn(() => {
    return {
      failed: [],
      sent: [
        {
          device: 'device',
        },
      ],
    };
  });

  vi.spyOn(apn as any, 'Provider').mockImplementation(() => {
    return {
      send: mockSend,
      shutdown: () => {},
    };
  });

  const provider = new APNSPushProvider({
    key: 'key',
    keyId: 'keyId',
    teamId: 'teamId',
    bundleId: 'bundleId',
    production: true,
  });

  await provider.sendMessage(
    {
      target: ['target'],
      title: 'title',
      content: 'content',
      payload: {
        data: 'data',
      },
      step: {
        digest: false,
        events: undefined,
        total_count: undefined,
      },
      subscriber: {},
    },
    {
      urlArgs: ['target'],
      _passthrough: {
        body: {
          topic: '_passthrough',
        },
      },
    }
  );

  expect(mockSend).toHaveBeenCalledWith(
    {
      encoding: 'utf8',
      payload: { data: 'data' },
      compiled: false,
      aps: {
        alert: {
          body: 'content',
          title: 'title',
        },
      },
      expiry: -1,
      priority: 10,
      topic: '_passthrough',
      'url-args': ['target'],
    },
    ['target']
  );
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - mockSend(vi.fn(())
 - provider(new APNSPushProvider({
    key: 'key',
    keyId: 'keyId',
    teamId: 'teamId',
    bundleId: 'bund...)
 - mockSend(vi.fn(())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/push/apns/apns.provider.ts
Tamaño: 2250 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { PushProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, IPushOptions, IPushProvider, ISendMessageSuccessResponse } from '@novu/stateless';
import apn from '@parse/node-apn';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class APNSPushProvider extends BaseProvider implements IPushProvider {
  id = PushProviderIdEnum.APNS;
  protected casing: CasingEnum = CasingEnum.CAMEL_CASE;
  channelType = ChannelTypeEnum.PUSH as ChannelTypeEnum.PUSH;

  protected override keyCaseObject: Record<string, string> = {
    contentAvailable: 'content-available',
    launchImage: 'launch-image',
    mutableContent: 'mutable-content',
    urlArgs: 'url-args',
    titleLocKey: 'title-loc-key',
    titleLocArgs: 'title-loc-args',
    actionLocKey: 'action-loc-key',
    locKey: 'loc-key',
    locArgs: 'loc-args',
  };

  private provider: apn.Provider;
  constructor(
    private config: {
      key: string;
      keyId: string;
      teamId: string;
      bundleId: string;
      production: boolean;
    }
  ) {
    super();
    this.config = config;
    this.provider = new apn.Provider({
      token: {
        key: config.key,
        keyId: config.keyId,
        teamId: config.teamId,
      },
      production: config.production,
    });
  }

  async sendMessage(
    options: IPushOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    delete (options.overrides as any)?.notificationIdentifiers;
    const notification = new apn.Notification(
      this.transform(bridgeProviderData, {
        body: options.content,
        title: options.title,
        payload: options.payload,
        topic: this.config.bundleId,
        ...options.overrides,
      }).body
    );
    const res = await this.provider.send(notification, options.target);

    if (res.failed.length > 0) {
      throw new Error(
        res.failed.map((failed) => `${failed.device} failed for reason: ${failed.response.reason}`).join(',')
      );
    }

    this.provider.shutdown();

    return {
      ids: res.sent?.map((response) => response.device),
      date: new Date().toISOString(),
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - res(await this.provider.send(notification, options.target);

    if (res.failed.length > 0) {
      thro...)
Declaraciones 'export' encontradas:
- export class APNSPushProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/push/expo/expo.provider.spec.ts
Tamaño: 5250 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ExpoPushTicket } from 'expo-server-sdk';
import { describe, expect, test, vi } from 'vitest';
import { ExpoPushProvider } from './expo.provider';

describe('Expo', () => {
  test('should trigger expo correctly', async () => {
    const provider = new ExpoPushProvider({
      accessToken: 'access-token',
    });

    const spy = vi

      // @ts-expect-error
      .spyOn(provider.expo, 'sendPushNotificationsAsync')
      .mockImplementation(async () => {
        return [{ status: 'ok', id: '501b1c08-292a-41d7-a36e-461c223e4744' }];
      });

    const result = await provider.sendMessage({
      title: 'Test',
      content: 'Test push',
      target: ['tester'],
      payload: {
        sound: 'test_sound',
      },
      subscriber: {},
      step: {
        digest: false,
        events: [{}],
        total_count: 1,
      },
    });

    // @ts-expect-error
    expect(provider.expo).toBeDefined();
    expect(spy).toHaveBeenCalled();
    expect(spy).toHaveBeenCalledWith([
      {
        badge: undefined,
        body: 'Test push',
        data: {
          sound: 'test_sound',
        },
        sound: null,
        title: 'Test',
        to: ['tester'],
      },
    ]);

    expect(result.id).toEqual('501b1c08-292a-41d7-a36e-461c223e4744');
  });

  test('should throw an error if expo returns an error', async () => {
    const provider = new ExpoPushProvider({
      accessToken: 'access-token',
    });

    const spy = vi

      // @ts-expect-error
      .spyOn(provider.expo, 'sendPushNotificationsAsync')
      .mockImplementation(async () => {
        return [
          {
            status: 'error',
            message: '"invalidDeviceToken" is not a registered push notification recipient',
          },
        ];
      });

    try {
      await provider.sendMessage({
        title: 'Test',
        content: 'Test push',
        target: ['invalidDeviceToken'],
        payload: {
          sound: 'test_sound',
        },
        subscriber: {},
        step: {
          digest: false,
          events: [{}],
          total_count: 1,
        },
      });
      throw new Error('Should not reach here');
    } catch (error) {
      expect(error.message).toEqual('"invalidDeviceToken" is not a registered push notification recipient');
    }

    // @ts-expect-error
    expect(provider.expo).toBeDefined();
    expect(spy).toHaveBeenCalled();
    expect(spy).toHaveBeenCalledWith([
      {
        badge: undefined,
        body: 'Test push',
        data: {
          sound: 'test_sound',
        },
        sound: null,
        title: 'Test',
        to: ['invalidDeviceToken'],
      },
    ]);
  });

  test('should throw an error if expo returns an unexpected status code', async () => {
    const provider = new ExpoPushProvider({
      accessToken: 'access-token',
    });

    const spy = vi

      // @ts-expect-error
      .spyOn(provider.expo, 'sendPushNotificationsAsync')
      .mockImplementation(async () => {
        return [
          {
            status: 'unknown-status',
            message: 'We changed our API',
          } as any as ExpoPushTicket,
        ];
      });

    try {
      await provider.sendMessage({
        title: 'Test',
        content: 'Test push',
        target: ['deviceToken'],
        payload: {
          sound: 'test_sound',
        },
        subscriber: {},
        step: {
          digest: false,
          events: [{}],
          total_count: 1,
        },
      });
      throw new Error('Should not reach here');
    } catch (error) {
      expect(error.message).toEqual('Unexpected Expo status');
    }

    // @ts-expect-error
    expect(provider.expo).toBeDefined();
    expect(spy).toHaveBeenCalled();
    expect(spy).toHaveBeenCalledWith([
      {
        badge: undefined,
        body: 'Test push',
        data: {
          sound: 'test_sound',
        },
        sound: null,
        title: 'Test',
        to: ['deviceToken'],
      },
    ]);
  });

  test('should trigger expo correctly with _passthrough', async () => {
    const provider = new ExpoPushProvider({
      accessToken: 'access-token',
    });

    const spy = vi

      // @ts-expect-error
      .spyOn(provider.expo, 'sendPushNotificationsAsync')
      .mockImplementation(async () => {
        return [{ status: 'ok', id: '501b1c08-292a-41d7-a36e-461c223e4744' }];
      });

    const result = await provider.sendMessage(
      {
        title: 'Test',
        content: 'Test push',
        target: ['tester'],
        payload: {
          sound: 'test_sound',
        },
        subscriber: {},
        step: {
          digest: false,
          events: [{}],
          total_count: 1,
        },
      },
      {
        _passthrough: {
          body: {
            badge: '_passthrough',
          },
        },
      }
    );

    // @ts-expect-error
    expect(provider.expo).toBeDefined();
    expect(spy).toHaveBeenCalled();
    expect(spy).toHaveBeenCalledWith([
      {
        badge: '_passthrough',
        body: 'Test push',
        data: {
          sound: 'test_sound',
        },
        sound: null,
        title: 'Test',
        to: ['tester'],
      },
    ]);

    expect(result.id).toEqual('501b1c08-292a-41d7-a36e-461c223e4744');
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - spy(vi

      // @ts-expect-error
      .spyOn(provider.expo, 'sendPushNotificationsAsync')
      .mockI...)
 - result(await provider.sendMessage({
      title: 'Test',
      content: 'Test push',
      target: ['tester...)
 - spy(vi

      // @ts-expect-error
      .spyOn(provider.expo, 'sendPushNotificationsAsync')
      .mockI...)
 - spy(vi

      // @ts-expect-error
      .spyOn(provider.expo, 'sendPushNotificationsAsync')
      .mockI...)
 - spy(vi

      // @ts-expect-error
      .spyOn(provider.expo, 'sendPushNotificationsAsync')
      .mockI...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/push/expo/expo.provider.ts
Tamaño: 1895 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { PushProviderIdEnum } from '@novu/shared';
import { IPushOptions, IPushProvider, ISendMessageSuccessResponse } from '@novu/stateless';
import { Expo, ExpoPushMessage, ExpoPushTicket } from 'expo-server-sdk';
import { CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';
import { PushBaseProvider } from '../push.base-provider';

export class ExpoPushProvider extends PushBaseProvider implements IPushProvider {
  id = PushProviderIdEnum.EXPO;
  protected casing: CasingEnum = CasingEnum.CAMEL_CASE;

  private expo: Expo;
  constructor(
    private config: {
      accessToken: string;
    }
  ) {
    super();
    this.expo = new Expo({ accessToken: this.config.accessToken });
  }

  async sendMessage(
    options: IPushOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const { sound, badge, ...overrides } = options.overrides ?? {};

    const tickets: ExpoPushTicket[] = await this.expo.sendPushNotificationsAsync([
      this.transform<ExpoPushMessage>(bridgeProviderData, {
        to: options.target,
        title: options.title,
        body: options.content,
        data: options.payload,
        badge: badge as unknown as number,
        sound: typeof sound === 'string' ? (sound as ExpoPushMessage['sound']) : null,
        ...overrides,
      }).body,
    ]);

    /*
     * TODO: We now just send one device token from Novu.
     * We need a different method to handle multiple ones.
     */
    const [ticket] = tickets;

    if (ticket.status === 'error') {
      throw new Error(ticket.message);
    }

    if (ticket.status === 'ok') {
      return {
        id: ticket.id,
        // Expo doesn't return a timestamp in the response
        date: new Date().toISOString(),
      };
    }

    throw new Error('Unexpected Expo status');
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ExpoPushProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/push/fcm/fcm.provider.spec.ts
Tamaño: 11158 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IPushOptions } from '@novu/stateless';
import app from 'firebase-admin/app';
import { beforeEach, describe, expect, test, vi } from 'vitest';

import { FcmPushProvider } from './fcm.provider';

const sendEachForMulticast = vi.fn().mockResolvedValue({ successCount: 1 });
const mockApp = {
  appCheck: vi.fn() as any,
  auth: vi.fn() as any,
  database: vi.fn() as any,
  firestore: vi.fn() as any,
  installations: vi.fn() as any,
  instanceId: vi.fn() as any,
  machineLearning: vi.fn() as any,
  projectManagement: vi.fn() as any,
  remoteConfig: vi.fn() as any,
  securityRules: vi.fn() as any,
  storage: vi.fn() as any,
  delete: vi.fn() as any,
};

vi.mock('firebase-admin/messaging', async (importOriginal) => {
  const actual = await importOriginal<typeof import('firebase-admin/messaging')>();

  return {
    ...actual,
    getMessaging: vi.fn(() => ({
      send: vi.fn(),
      sendEach: vi.fn(),
      sendAll: vi.fn(),
      sendEachForMulticast,
      sendToDevice: vi.fn(),
      sendToDeviceGroup: vi.fn(),
      sendToTopic: vi.fn(),
      sendToCondition: vi.fn(),
      subscribeToTopic: vi.fn(),
      unsubscribeFromTopic: vi.fn(),
      app: mockApp,
    })),
  };
});

vi.mock('firebase-admin/app', async (importOriginal) => {
  const actual = await importOriginal<typeof import('firebase-admin/app')>();

  return {
    ...actual,
    getApp: vi.fn(() => mockApp),
    deleteApp: vi.fn(),
    cert: vi.fn(),
    initializeApp: vi.fn(() => mockApp),
  };
});

vi.mock('firebase-admin', async (importOriginal) => {
  const actual = await importOriginal<typeof import('firebase-admin')>();

  return {
    ...actual,
    initializeApp: vi.fn(() => mockApp),
  };
});

describe.skip('FcmPushProvider', () => {
  let provider: FcmPushProvider;
  let spy: ReturnType<typeof vi.spyOn>;
  const subscriber = {};
  const step: IPushOptions['step'] = {
    digest: false,
    events: [{}],
    total_count: 1,
  };

  beforeEach(() => {
    vi.clearAllMocks();

    provider = new FcmPushProvider({
      secretKey: '--BEGIN PRIVATE KEY--abc',
      projectId: 'test',
      email: 'test@iam.firebase.google.com',
    });

    spy = vi

      // @ts-expect-error
      .spyOn(provider.messaging, 'sendEachForMulticast')
      .mockImplementation(async () => {
        return {} as any;
      });
  });

  test('should trigger fcm correctly', async () => {
    await provider.sendMessage(
      {
        title: 'Test',
        content: 'Test push',
        target: ['tester'],
        payload: {
          sound: 'test_sound',
        },
        subscriber,
        step,
      },
      {
        registrationIds: ['test'],
        notification: {
          title: 'Test 1',
        },
      }
    );
    expect(app.initializeApp).toHaveBeenCalledTimes(1);
    expect(app.cert).toHaveBeenCalledTimes(1);
    expect(spy).toHaveBeenCalled();
    expect(spy).toHaveBeenCalledWith({
      notification: {
        title: 'Test 1',
        body: 'Test push',
      },
      tokens: ['tester'],
      registration_ids: ['test'],
    });
  });

  test('should trigger fcm with fcm options override', async () => {
    await provider.sendMessage({
      title: 'Test',
      content: 'Test push',
      target: ['tester'],
      payload: {
        sound: 'test_sound',
      },
      overrides: {
        data: { foo: 'bar' },
        fcmOptions: {
          analyticsLabel: 'my-label',
        },
      },
      subscriber,
      step,
    });
    expect(app.initializeApp).toHaveBeenCalledTimes(1);
    expect(app.cert).toHaveBeenCalledTimes(1);
    expect(spy).toHaveBeenCalled();
    expect(spy).toHaveBeenCalledWith({
      notification: {
        title: 'Test',
        body: 'Test push',
      },
      tokens: ['tester'],
      data: { foo: 'bar' },
      fcmOptions: {
        analyticsLabel: 'my-label',
      },
    });
  });

  test('should trigger fcm with android override', async () => {
    await provider.sendMessage({
      title: 'Test',
      content: 'Test push',
      target: ['tester'],
      payload: {
        sound: 'test_sound',
      },
      overrides: {
        data: { foo: 'bar' },
        android: {
          notification: {
            title: 'Test',
            body: 'Test push',
          },
          data: {
            foo: 'bar',
          },
        },
      },
      subscriber,
      step,
    });
    expect(app.initializeApp).toHaveBeenCalledTimes(1);
    expect(app.cert).toHaveBeenCalledTimes(1);
    expect(spy).toHaveBeenCalled();
    expect(spy).toHaveBeenCalledWith({
      notification: {
        title: 'Test',
        body: 'Test push',
      },
      tokens: ['tester'],
      data: { foo: 'bar' },
      android: {
        notification: {
          title: 'Test',
          body: 'Test push',
        },
        data: {
          foo: 'bar',
        },
      },
    });
  });

  test('should trigger fcm with apns (ios) override', async () => {
    await provider.sendMessage({
      title: 'Test',
      content: 'Test push',
      target: ['tester'],
      payload: {
        sound: 'test_sound',
      },
      overrides: {
        apns: {
          payload: {
            aps: {
              notification: {
                title: 'Test',
                body: 'Test push',
              },
              data: {
                foo: 'bar',
              },
            },
          },
        },
      },
      subscriber,
      step,
    });
    expect(app.initializeApp).toHaveBeenCalledTimes(1);
    expect(app.cert).toHaveBeenCalledTimes(1);
    expect(spy).toHaveBeenCalled();
    expect(spy).toHaveBeenCalledWith({
      notification: {
        title: 'Test',
        body: 'Test push',
      },
      tokens: ['tester'],
      apns: {
        payload: {
          aps: {
            notification: {
              title: 'Test',
              body: 'Test push',
            },
            data: {
              foo: 'bar',
            },
          },
        },
      },
    });
  });

  test('should trigger fcm data for ios with headers options', async () => {
    await provider.sendMessage({
      title: 'Test',
      content: 'Test push',
      target: ['tester'],
      payload: {
        key_1: 'val_1',
        key_2: 'val_2',
      },
      overrides: {
        type: 'data',
        apns: {
          headers: {
            'apns-priority': '5',
          },
          payload: {
            aps: {
              alert: {
                'loc-key': 'some_body',
                'title-loc-key': 'some_title',
              },
              sound: 'demo.wav',
            },
          },
        },
      },
      subscriber,
      step,
    });
    expect(app.initializeApp).toHaveBeenCalledTimes(1);
    expect(app.cert).toHaveBeenCalledTimes(1);
    expect(spy).toHaveBeenCalled();
    expect(spy).toHaveBeenCalledWith({
      tokens: ['tester'],
      apns: {
        headers: {
          'apns-priority': '5',
        },
        payload: {
          aps: {
            alert: {
              'loc-key': 'some_body',
              'title-loc-key': 'some_title',
            },
            sound: 'demo.wav',
          },
        },
      },
      data: {
        key_1: 'val_1',
        key_2: 'val_2',
        title: 'Test',
        body: 'Test push',
        message: 'Test push',
      },
    });
  });

  test('should trigger fcm data for android with priority option', async () => {
    await provider.sendMessage({
      title: 'Test',
      content: 'Test push',
      target: ['tester'],
      payload: {
        key_1: 'val_1',
        key_2: 'val_2',
      },
      overrides: {
        type: 'data',
        android: {
          data: {
            for_android: 'only',
          },
          priority: 'high',
        },
      },
      subscriber,
      step,
    });
    expect(app.initializeApp).toHaveBeenCalledTimes(1);
    expect(app.cert).toHaveBeenCalledTimes(1);
    expect(spy).toHaveBeenCalled();
    expect(spy).toHaveBeenCalledWith({
      tokens: ['tester'],
      android: {
        data: {
          for_android: 'only',
        },
        priority: 'high',
      },
      data: {
        key_1: 'val_1',
        key_2: 'val_2',
        title: 'Test',
        body: 'Test push',
        message: 'Test push',
      },
    });
  });

  test('should clean the payload for the FCM data message', async () => {
    const payload = {
      foo: 'bar',
      one: 1,
      isActive: true,
      object: { asd: 'asd' },
    };
    const cleanPayload = {
      foo: 'bar',
      one: '1',
      isActive: 'true',
      object: '{"asd":"asd"}',
      title: 'Test',
      body: 'Test push',
      message: 'Test push',
    };

    await provider.sendMessage({
      title: 'Test',
      content: 'Test push',
      target: ['tester'],
      payload,
      overrides: {
        type: 'data',
        android: {
          data: {
            for_android: 'only',
          },
          priority: 'high',
        },
      },
      subscriber,
      step,
    });
    expect(app.initializeApp).toHaveBeenCalledTimes(1);
    expect(app.cert).toHaveBeenCalledTimes(1);
    expect(spy).toHaveBeenCalled();
    expect(spy).toHaveBeenCalledWith({
      tokens: ['tester'],
      android: {
        data: {
          for_android: 'only',
        },
        priority: 'high',
      },
      data: cleanPayload,
    });
  });

  test('should trigger fcm multiple times with the same overrides', async () => {
    const tokens = ['tester1', 'tester2'];
    const overrides: IPushOptions['overrides'] = {
      type: 'data',
      data: { foo: 'bar' },
    };

    await Promise.all(
      tokens.map(async (token) => {
        await provider.sendMessage({
          title: 'Test',
          content: 'Test push',
          target: [token],
          payload: {
            sound: 'test_sound',
          },
          overrides,
          subscriber,
          step,
        });
        expect(app.initializeApp).toHaveBeenCalledTimes(1);
        expect(app.cert).toHaveBeenCalledTimes(1);
        expect(spy).toHaveBeenCalled();
        expect(spy).toHaveBeenCalledWith({
          tokens: [token],
          data: {
            title: 'Test',
            body: 'Test push',
            message: 'Test push',
            sound: 'test_sound',
          },
        });
      })
    );
  });

  test('should trigger fcm correctly with _passthrough', async () => {
    await provider.sendMessage(
      {
        title: 'Test',
        content: 'Test push',
        target: ['tester'],
        payload: {
          sound: 'test_sound',
        },
        subscriber,
        step,
      },
      {
        registrationIds: ['test'],
        notification: {
          title: 'Test 1',
        },
        _passthrough: {
          body: {
            tokens: ['tokens'],
          },
        },
      }
    );
    expect(app.initializeApp).toHaveBeenCalledTimes(1);
    expect(app.cert).toHaveBeenCalledTimes(1);
    expect(spy).toHaveBeenCalled();
    expect(spy).toHaveBeenCalledWith({
      notification: {
        title: 'Test 1',
        body: 'Test push',
      },
      tokens: ['tester', 'tokens'],
      registration_ids: ['test'],
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - mockApp({
  appCheck: vi.fn() as any,
  auth: vi.fn() as any,
  database: vi.fn() as any,
  firestore: vi.fn...)
 - actual(await importOriginal<typeof import('firebase-admin/messaging')>();

  return {
    ...actual,
    ge...)
 - actual(await importOriginal<typeof import('firebase-admin/app')>();

  return {
    ...actual,
    getApp: ...)
 - actual(await importOriginal<typeof import('firebase-admin')>();

  return {
    ...actual,
    initializeAp...)
 - spy(vi

      // @ts-expect-error
      .spyOn(provider.messaging, 'sendEachForMulticast')
      .mockIm...)
 - cleanPayload({
      foo: 'bar',
      one: '1',
      isActive: 'true',
      object: '{"asd":"asd"}',
      tit...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/push/fcm/fcm.provider.ts
Tamaño: 4295 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { PushProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, IPushOptions, IPushProvider, ISendMessageSuccessResponse } from '@novu/stateless';
import crypto from 'crypto';
import { cert, deleteApp, getApp, initializeApp } from 'firebase-admin/app';
import { getMessaging, Messaging, MulticastMessage, TopicMessage } from 'firebase-admin/messaging';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class FcmPushProvider extends BaseProvider implements IPushProvider {
  id = PushProviderIdEnum.FCM;
  channelType = ChannelTypeEnum.PUSH as ChannelTypeEnum.PUSH;
  protected casing: CasingEnum = CasingEnum.SNAKE_CASE;

  private appName: string;
  private messaging: Messaging;
  constructor(
    private config: {
      projectId: string;
      email: string;
      secretKey: string;
    }
  ) {
    super();
    this.config = config;
    this.appName = crypto.randomBytes(32).toString();
    const firebase = initializeApp(
      {
        credential: cert({
          projectId: this.config.projectId,
          clientEmail: this.config.email,
          privateKey: this.config.secretKey,
        }),
      },
      this.appName
    );
    this.messaging = getMessaging(firebase);
  }

  async sendMessage(
    options: IPushOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const {
      deviceTokens: _,
      type,
      android,
      apns,
      fcmOptions,
      webPush: webpush,
      data,
      ...overridesData
    } = (options.overrides as IPushOptions['overrides'] & {
      deviceTokens?: string[];
      webPush: { [key: string]: { [key: string]: string } | string };
    }) || {};

    const payload = this.cleanPayload(options.payload);
    const transformedBase = this.transform<MulticastMessage | TopicMessage>(bridgeProviderData, {});

    const commonProps: Partial<MulticastMessage & TopicMessage> = {
      android,
      apns,
      fcmOptions,
      webpush,
    };

    let res;

    if ((transformedBase?.body as TopicMessage).topic) {
      const topicMessage = this.transform<TopicMessage>(bridgeProviderData, {
        topic: (transformedBase.body as TopicMessage).topic,
        notification: {
          title: options.title,
          body: options.content,
        },
        data,
        ...commonProps,
      }).body;

      res = await this.messaging.send(topicMessage);
    } else {
      const multicastConfig: Partial<MulticastMessage> = {
        tokens: options.target,
        ...commonProps,
      };

      // Add either data or notification based on type
      if (type === 'data') {
        multicastConfig.data = {
          ...payload,
          title: options.title,
          body: options.content,
          message: options.content,
        };
      } else {
        multicastConfig.notification = {
          title: options.title,
          body: options.content,
          ...overridesData,
        };
        multicastConfig.data = data;
      }

      const multicastMessage = this.transform<MulticastMessage>(
        bridgeProviderData,
        multicastConfig as Record<string, unknown>
      ).body;

      res = await this.messaging.sendEachForMulticast(multicastMessage);
    }

    const app = getApp(this.appName);
    await deleteApp(app);

    if (res.successCount === 0) {
      throw new Error(
        `Sending message failed due to "${res.responses.find((i) => i.success === false).error.message}"`
      );
    }

    return {
      ids:
        typeof res === 'string'
          ? [res]
          : res?.responses?.map((response, index) =>
              response.success
                ? response.messageId
                : `${response.error.message}. Invalid token:- ${options.target[index]}`
            ),
      date: new Date().toISOString(),
    };
  }

  private cleanPayload(payload: object): Record<string, string> {
    const cleanedPayload: Record<string, string> = {};

    Object.keys(payload).forEach((key) => {
      if (typeof payload[key] === 'string') {
        cleanedPayload[key] = payload[key];
      } else {
        cleanedPayload[key] = JSON.stringify(payload[key]);
      }
    });

    return cleanedPayload;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class FcmPushProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/push/one-signal/one-signal.provider.spec.ts
Tamaño: 3230 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IPushOptions } from '@novu/stateless';
import axios from 'axios';
import { beforeEach, describe, expect, Mocked, test, vi } from 'vitest';
import { OneSignalPushProvider } from './one-signal.provider';

vi.mock('axios');

const mockNotificationOptions: IPushOptions = {
  title: 'Test',
  content: 'Test push',
  target: ['tester'],
  payload: {
    sound: 'test_sound',
  },
  subscriber: {},
  step: {
    digest: false,
    events: [{}],
    total_count: 1,
  },
};

describe('test onesignal notification api', () => {
  const mockedAxios = axios as Mocked<typeof axios>;

  beforeEach(() => {
    mockedAxios.create.mockReturnThis();
  });

  test('should trigger OneSignal library correctly', async () => {
    const provider = new OneSignalPushProvider({
      appId: 'test-app-id',
      apiKey: 'test-key',
    });

    const response = {
      data: {
        id: 'result',
      },
    };

    mockedAxios.request.mockResolvedValue(response);

    const spy = vi.spyOn(provider, 'sendMessage');

    const res = await provider.sendMessage(mockNotificationOptions, {
      iosBadgeCount: 1,
      includeExternalUserIds: ['test'],
    });
    expect(mockedAxios.request).toHaveBeenCalled();
    const data = JSON.parse((mockedAxios.request.mock.calls[0][0].data as string) || '{}');

    expect(data).toEqual({
      include_player_ids: ['tester'],
      app_id: 'test-app-id',
      headings: { en: 'Test' },
      contents: { en: 'Test push' },
      subtitle: {},
      data: { sound: 'test_sound' },
      ios_badgeType: 'Increase',
      ios_badgeCount: 1,
      include_external_user_ids: ['test'],
    });

    expect(spy).toHaveBeenCalledWith(mockNotificationOptions, {
      iosBadgeCount: 1,
      includeExternalUserIds: ['test'],
    });
    expect(res.id).toEqual(response.data.id);
  });

  test('should trigger OneSignal library correctly with _passthrough', async () => {
    const provider = new OneSignalPushProvider({
      appId: 'test-app-id',
      apiKey: 'test-key',
    });

    const response = {
      data: {
        id: 'result',
      },
    };

    mockedAxios.request.mockResolvedValue(response);

    const spy = vi.spyOn(provider, 'sendMessage');

    const res = await provider.sendMessage(mockNotificationOptions, {
      iosBadgeCount: 1,
      includeExternalUserIds: ['test'],
      _passthrough: {
        body: {
          include_external_user_ids: ['test1'],
        },
      },
    });
    expect(mockedAxios.request).toHaveBeenCalled();
    const data = JSON.parse((mockedAxios.request.mock.calls[1][0].data as string) || '{}');

    expect(data).toEqual({
      include_player_ids: ['tester'],
      app_id: 'test-app-id',
      headings: { en: 'Test' },
      contents: { en: 'Test push' },
      subtitle: {},
      data: { sound: 'test_sound' },
      ios_badgeType: 'Increase',
      ios_badgeCount: 1,
      include_external_user_ids: ['test', 'test1'],
    });

    expect(spy).toHaveBeenCalledWith(mockNotificationOptions, {
      iosBadgeCount: 1,
      includeExternalUserIds: ['test'],
      _passthrough: {
        body: {
          include_external_user_ids: ['test1'],
        },
      },
    });
    expect(res.id).toEqual(response.data.id);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - IPushOptions({
  title: 'Test',
  content: 'Test push',
  target: ['tester'],
  payload: {
    sound: 'test_sound...)
 - mockedAxios(axios as Mocked<typeof axios>;

  beforeEach(())
 - data(JSON.parse((mockedAxios.request.mock.calls[0][0].data as string) || '{}');

    expect(data).toEqual...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/push/one-signal/one-signal.provider.ts
Tamaño: 3219 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { PushProviderIdEnum } from '@novu/shared';

import { ChannelTypeEnum, IPushOptions, IPushProvider, ISendMessageSuccessResponse } from '@novu/stateless';
import axios, { AxiosInstance, AxiosRequestConfig } from 'axios';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class OneSignalPushProvider extends BaseProvider implements IPushProvider {
  id = PushProviderIdEnum.OneSignal;
  channelType = ChannelTypeEnum.PUSH as ChannelTypeEnum.PUSH;
  private axiosInstance: AxiosInstance;
  private apiVersion: string | null = null;
  protected casing: CasingEnum = CasingEnum.SNAKE_CASE;
  public readonly BASE_URL_PLAYER_MODEL = 'https://onesignal.com/api/v1';
  public readonly BASE_URL_USER_MODEL = 'https://api.onesignal.com';

  constructor(
    private config: {
      appId: string;
      apiKey: string;
      apiVersion?: 'externalId' | 'playerModel' | null;
    }
  ) {
    super();
    this.apiVersion = config.apiVersion;

    this.axiosInstance = axios.create({
      baseURL: config.apiVersion === 'externalId' ? this.BASE_URL_USER_MODEL : this.BASE_URL_PLAYER_MODEL,
    });
  }

  async sendMessage(
    options: IPushOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const { sound, badge, ...overrides } = options.overrides ?? {};

    const targetSegment =
      this.apiVersion === 'externalId'
        ? {
            include_aliases: {
              external_id: options.target,
            },
            target_channel: 'push',
          }
        : { include_player_ids: options.target };

    const notification = this.transform(bridgeProviderData, {
      ...targetSegment,
      app_id: this.config.appId,
      headings: { en: options.title },
      contents: { en: options.content },
      subtitle: { en: overrides.subtitle },
      data: options.payload,
      ios_badgeType: 'Increase',
      ios_badgeCount: 1,
      ios_sound: sound,
      android_sound: sound,
      mutable_content: overrides.mutableContent,
      android_channel_id: overrides.channelId,
      small_icon: overrides.icon,
      large_icon: overrides.icon,
      chrome_icon: overrides.icon,
      firefox_icon: overrides.icon,
      ios_category: overrides.categoryId,
    }).body;

    const notificationOptions: AxiosRequestConfig = {
      url: '/notifications',
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Basic ${this.config.apiKey}`,
      },
      data: JSON.stringify(notification),
    };

    const res = await this.axiosInstance.request<{ id: string }>(notificationOptions);

    return {
      id: res?.data.id,
      date: new Date().toISOString(),
    };
  }

  protected override keyCaseObject: Record<string, string> = {
    is_ios: 'isIos',
    is_android: 'isAndroid',
    is_huawei: 'isHuawei',
    is_any_web: 'isAnyWeb',
    is_chrome_web: 'isChromeWeb',
    is_firefox: 'isFirefox',
    is_safari: 'isSafari',
    is_wp_wns: 'isWP_WNS',
    is_adm: 'isAdm',
    is_chrome: 'isChrome',
    ios_badge_type: 'ios_badgeType',
    ios_badge_count: 'ios_badgeCount',
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class OneSignalPushProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/push/one-signal/one-signal.providerV2.spec.ts
Tamaño: 1721 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IPushOptions } from '@novu/stateless';
import axios from 'axios';
import { beforeEach, describe, expect, Mocked, test, vi } from 'vitest';
import { OneSignalPushProvider } from './one-signal.provider';

vi.mock('axios');

const mockNotificationOptions: IPushOptions = {
  title: 'Test',
  content: 'Test push',
  target: ['userId'],
  payload: {
    sound: 'test_sound',
  },
  subscriber: {},
  step: {
    digest: false,
    events: [{}],
    total_count: 1,
  },
};

describe('test onesignal notification user api', () => {
  const mockedAxios = axios as Mocked<typeof axios>;

  beforeEach(() => {
    mockedAxios.create.mockReturnThis();
  });

  test('should trigger OneSignal library correctly with select version', async () => {
    const provider = new OneSignalPushProvider({
      appId: 'test-app-id',
      apiKey: 'test-key',
      apiVersion: 'externalId',
    });

    const response = {
      data: {
        id: 'result',
      },
    };

    mockedAxios.request.mockResolvedValue(response);

    const spy = vi.spyOn(provider, 'sendMessage');

    const res = await provider.sendMessage(mockNotificationOptions, {
      iosBadgeCount: 1,
    });
    expect(mockedAxios.request).toHaveBeenCalled();
    const data = JSON.parse((mockedAxios.request.mock.calls[0][0].data as string) || '{}');

    expect(data).toEqual({
      include_aliases: {
        external_id: ['userId'],
      },
      target_channel: 'push',
      app_id: 'test-app-id',
      headings: { en: 'Test' },
      contents: { en: 'Test push' },
      subtitle: {},
      data: { sound: 'test_sound' },
      ios_badgeType: 'Increase',
      ios_badgeCount: 1,
    });

    expect(res.id).toEqual(response.data.id);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - IPushOptions({
  title: 'Test',
  content: 'Test push',
  target: ['userId'],
  payload: {
    sound: 'test_sound...)
 - mockedAxios(axios as Mocked<typeof axios>;

  beforeEach(())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/push/push-webhook/push-webhook.provider.spec.ts
Tamaño: 2465 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, test } from 'vitest';
import { axiosSpy } from '../../../utils/test/spy-axios';
import { PushWebhookPushProvider } from './push-webhook.provider';

test('should trigger push-webhook library correctly', async () => {
  const { mockPost: fakePost } = axiosSpy({
    data: {
      id: '123',
    },
  });

  const provider = new PushWebhookPushProvider({
    webhookUrl: 'http://127.0.0.1:8080/webhook',
    hmacSecretKey: 'super-secret-key',
  });

  const subscriber = {};
  const step = { digest: false, events: [{}], total_count: 1 };

  await provider.sendMessage({
    title: 'Test',
    content: 'Test push',
    target: ['tester'],
    payload: {
      sound: 'test_sound',
    },
    subscriber,
    step,
  });

  expect(fakePost).toHaveBeenCalled();
  expect(fakePost).toHaveBeenCalledWith(
    'http://127.0.0.1:8080/webhook',
    JSON.stringify({
      title: 'Test',
      content: 'Test push',
      target: ['tester'],
      payload: {
        sound: 'test_sound',
        subscriber,
        step,
      },
    }),
    {
      headers: {
        'content-type': 'application/json',
        'X-Novu-Signature': 'ebb2ff6420df59a863a6ddfa64ca8721cbbce038d5432c441cde83dee43b70d9',
      },
    }
  );
});

test('should trigger push-webhook library correctly with _passthrough', async () => {
  const { mockPost: fakePost } = axiosSpy({
    data: {
      id: '123',
    },
  });

  const provider = new PushWebhookPushProvider({
    webhookUrl: 'http://127.0.0.1:8080/webhook',
    hmacSecretKey: 'super-secret-key',
  });

  const subscriber = {};
  const step = { digest: false, events: [{}], total_count: 1 };

  await provider.sendMessage(
    {
      title: 'Test',
      content: 'Test push',
      target: ['tester'],
      payload: {
        sound: 'test_sound',
      },
      subscriber,
      step,
    },
    {
      _passthrough: {
        body: {
          content: 'test _passthrough',
        },
      },
    }
  );

  expect(fakePost).toHaveBeenCalled();
  expect(fakePost).toHaveBeenCalledWith(
    'http://127.0.0.1:8080/webhook',
    JSON.stringify({
      title: 'Test',
      content: 'test _passthrough',
      target: ['tester'],
      payload: {
        sound: 'test_sound',
        subscriber,
        step,
      },
    }),
    {
      headers: {
        'content-type': 'application/json',
        'X-Novu-Signature': '5147e1613526bad56a1c0e318ebbdd7d312c7760dcb8230f3f4c80c07d9ebdd0',
      },
    }
  );
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - step({ digest: false, events: [{}], total_count: 1 };

  await provider.sendMessage({
    title: 'Test',
...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/push/push-webhook/push-webhook.provider.ts
Tamaño: 2173 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { PushProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, IPushOptions, IPushProvider, ISendMessageSuccessResponse } from '@novu/stateless';
import axios from 'axios';
import crypto from 'crypto';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class PushWebhookPushProvider extends BaseProvider implements IPushProvider {
  protected casing: CasingEnum = CasingEnum.CAMEL_CASE;
  readonly id = PushProviderIdEnum.PushWebhook;
  channelType = ChannelTypeEnum.PUSH as ChannelTypeEnum.PUSH;

  constructor(
    private config: {
      hmacSecretKey?: string;
      webhookUrl: string;
    }
  ) {
    super();
  }

  async sendMessage(
    options: IPushOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const { subscriber, step, payload, ...rest } = options;
    const data = this.transform(bridgeProviderData, {
      ...rest,
      payload: {
        ...payload,
        subscriber,
        step,
      },
    });

    const hmacSecretKey = (data.body.hmacSecretKey as string) || this.config.hmacSecretKey;
    const webhookUrl = (data.body.webhookUrl as string) || this.config.webhookUrl;

    // Clean up override fields from the body before sending
    if (data.body.hmacSecretKey) {
      delete data.body.hmacSecretKey;
    }
    if (data.body.webhookUrl) {
      delete data.body.webhookUrl;
    }

    const body = this.createBody(data.body);
    const hmacValue = this.computeHmac(body, hmacSecretKey);

    const response = await axios.create().post(webhookUrl, body, {
      headers: {
        'content-type': 'application/json',
        'X-Novu-Signature': hmacValue,
        ...data.headers,
      },
    });

    return {
      id: response.data.id,
      date: new Date().toDateString(),
    };
  }

  createBody(options: object): string {
    return JSON.stringify(options);
  }

  computeHmac(payload: string, hmacSecretKey: string): string {
    const secretKey = hmacSecretKey;

    return crypto.createHmac('sha256', secretKey).update(payload, 'utf-8').digest('hex');
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class PushWebhookPushProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/push/pusher-beams/pusher-beams.provider.spec.ts
Tamaño: 3252 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, test } from 'vitest';
import { axiosSpy } from '../../../utils/test/spy-axios';
import { PusherBeamsPushProvider } from './pusher-beams.provider';

test('should trigger pusher-beams library correctly', async () => {
  const { mockPost: spy } = axiosSpy({
    data: { publishId: 'pubid-3a7e97ee-a4bc-4d8f-a40b-74915ce808ae' },
  });

  const provider = new PusherBeamsPushProvider({
    instanceId: '<instance-id>',
    secretKey: '<secret-key',
  });

  const result = await provider.sendMessage({
    target: ['tester'],
    title: 'Hello',
    content: 'Hello, world!',
    subscriber: {},
    step: {
      digest: false,
      events: [{}],
      total_count: 1,
    },
    payload: {
      custom_payload_1: 'custom_payload_1',
    },
    overrides: {
      sound: 'custom_sound',
    },
  });

  // @ts-expect-error
  expect(provider.axiosInstance).toBeDefined();
  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith(`/publishes/users`, {
    users: ['tester'],
    apns: {
      aps: {
        alert: {
          title: 'Hello',
          body: 'Hello, world!',
        },
        sound: 'custom_sound',
      },
    },
    fcm: {
      notification: {
        title: 'Hello',
        body: 'Hello, world!',
        sound: 'custom_sound',
      },
      data: {
        custom_payload_1: 'custom_payload_1',
      },
    },
    web: {
      notification: {
        title: 'Hello',
        body: 'Hello, world!',
      },
      data: {
        custom_payload_1: 'custom_payload_1',
      },
    },
  });

  expect(result.id).toEqual('pubid-3a7e97ee-a4bc-4d8f-a40b-74915ce808ae');
});

test('should trigger pusher-beams library correctly with _passthrough', async () => {
  const { mockPost: spy } = axiosSpy({
    data: { publishId: 'pubid-3a7e97ee-a4bc-4d8f-a40b-74915ce808ae' },
  });

  const provider = new PusherBeamsPushProvider({
    instanceId: '<instance-id>',
    secretKey: '<secret-key',
  });

  const result = await provider.sendMessage(
    {
      target: ['tester'],
      title: 'Hello',
      content: 'Hello, world!',
      subscriber: {},
      step: {
        digest: false,
        events: [{}],
        total_count: 1,
      },
      payload: {
        custom_payload_1: 'custom_payload_1',
      },
      overrides: {
        sound: 'custom_sound',
      },
    },
    {
      _passthrough: {
        body: {
          users: ['tester1'],
        },
      },
    }
  );

  // @ts-expect-error
  expect(provider.axiosInstance).toBeDefined();
  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith(`/publishes/users`, {
    users: ['tester', 'tester1'],
    apns: {
      aps: {
        alert: {
          title: 'Hello',
          body: 'Hello, world!',
        },
        sound: 'custom_sound',
      },
    },
    fcm: {
      notification: {
        title: 'Hello',
        body: 'Hello, world!',
        sound: 'custom_sound',
      },
      data: {
        custom_payload_1: 'custom_payload_1',
      },
    },
    web: {
      notification: {
        title: 'Hello',
        body: 'Hello, world!',
      },
      data: {
        custom_payload_1: 'custom_payload_1',
      },
    },
  });

  expect(result.id).toEqual('pubid-3a7e97ee-a4bc-4d8f-a40b-74915ce808ae');
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - result(await provider.sendMessage({
    target: ['tester'],
    title: 'Hello',
    content: 'Hello, world!...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/push/pusher-beams/pusher-beams.provider.ts
Tamaño: 2400 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { PushProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, IPushOptions, IPushProvider, ISendMessageSuccessResponse } from '@novu/stateless';
import axios, { AxiosInstance } from 'axios';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class PusherBeamsPushProvider extends BaseProvider implements IPushProvider {
  protected casing: CasingEnum = CasingEnum.SNAKE_CASE;
  id = PushProviderIdEnum.PusherBeams;
  channelType = ChannelTypeEnum.PUSH as ChannelTypeEnum.PUSH;

  private axiosInstance: AxiosInstance;

  constructor(
    private config: {
      instanceId: string;
      secretKey: string;
    }
  ) {
    super();
    this.axiosInstance = axios.create({
      baseURL: `https://${this.config.instanceId}.pushnotifications.pusher.com/publish_api/v1/instances/${this.config.instanceId}`,
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${this.config.secretKey}`,
      },
    });
  }

  async sendMessage(
    options: IPushOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const { sound, badge, ...overrides } = options.overrides ?? {};
    const payload = this.transform(bridgeProviderData, {
      users: options.target,
      apns: {
        aps: {
          alert: {
            title: options.title,
            body: options.content,
          },
          badge,
          category: overrides.categoryId,
          sound,
        },
      },
      fcm: {
        notification: {
          title: options.title,
          body: options.content,
          android_channel_id: overrides.channelId,
          click_action: overrides.clickAction,
          color: overrides.color,
          icon: overrides.icon,
          sound,
          tag: overrides.tag,
        },
        data: options.payload,
        time_to_live: overrides.ttl,
      },
      web: {
        notification: {
          title: options.title,
          body: options.content,
          icon: overrides.icon,
        },
        data: options.payload,
        time_to_live: overrides.ttl,
      },
    }).body;

    const response = await this.axiosInstance.post(`/publishes/users`, payload);

    return {
      id: response.data.publishId,
      date: new Date().toISOString(),
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class PusherBeamsPushProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/push/pushpad/pushpad.provider.spec.ts
Tamaño: 1870 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import Pushpad from 'pushpad';
import { expect, test, vi } from 'vitest';
import { PushpadPushProvider } from './pushpad.provider';

test('should trigger pushpad library correctly', async () => {
  const spy = vi.spyOn(Pushpad, 'Notification').mockImplementation(() => {
    return {
      deliverTo: vi.fn((target, callback) => {
        callback(null, { id: 12345 });
      }),
    };
  });

  const provider = new PushpadPushProvider({
    apiKey: 'api-key-123',
    appId: '841',
  });

  const result = await provider.sendMessage({
    title: 'Test',
    content: 'Test push',
    target: ['tester'],
    payload: {},
    subscriber: {},
    step: {
      digest: false,
      events: [{}],
      total_count: 1,
    },
  });

  expect(result.id).toBe('12345');
  expect(spy).toHaveBeenCalledWith({
    project: { authToken: 'api-key-123', projectId: '841' },
    body: 'Test push',
    title: 'Test',
  });
});

test('should trigger pushpad library correctly with _passthrough', async () => {
  const spy = vi.spyOn(Pushpad, 'Notification').mockImplementation(() => {
    return {
      deliverTo: vi.fn((target, callback) => {
        callback(null, { id: 12345 });
      }),
    };
  });

  const provider = new PushpadPushProvider({
    apiKey: 'api-key-123',
    appId: '841',
  });

  const result = await provider.sendMessage(
    {
      title: 'Test',
      content: 'Test push',
      target: ['tester'],
      payload: {},
      subscriber: {},
      step: {
        digest: false,
        events: [{}],
        total_count: 1,
      },
    },
    {
      _passthrough: {
        body: {
          title: 'Test passthrough',
        },
      },
    }
  );

  expect(result.id).toBe('12345');
  expect(spy).toHaveBeenCalledWith({
    project: { authToken: 'api-key-123', projectId: '841' },
    body: 'Test push',
    title: 'Test passthrough',
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - spy(vi.spyOn(Pushpad, 'Notification').mockImplementation(())
 - result(await provider.sendMessage({
    title: 'Test',
    content: 'Test push',
    target: ['tester'],
  ...)
 - spy(vi.spyOn(Pushpad, 'Notification').mockImplementation(())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/push/pushpad/pushpad.provider.ts
Tamaño: 1761 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { PushProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, IPushOptions, IPushProvider, ISendMessageSuccessResponse } from '@novu/stateless';
import Pushpad from 'pushpad';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class PushpadPushProvider extends BaseProvider implements IPushProvider {
  id = PushProviderIdEnum.Pushpad;
  protected casing: CasingEnum = CasingEnum.CAMEL_CASE;
  channelType = ChannelTypeEnum.PUSH as ChannelTypeEnum.PUSH;

  private pushpad: Pushpad.Pushpad;

  constructor(
    private config: {
      apiKey: string;
      appId: string;
    }
  ) {
    super();
    this.pushpad = new Pushpad.Pushpad({
      authToken: this.config.apiKey,
      projectId: this.config.appId,
    });
  }

  async sendMessage(
    options: IPushOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const notification = this.buildNotification(options, bridgeProviderData);

    const notificationId = await new Promise((resolve, reject) => {
      notification.deliverTo(options.target, (err, result) => {
        if (err) {
          return reject(err);
        }

        return resolve(result.id);
      });
    });

    return {
      id: String(notificationId as string),
      date: new Date().toISOString(),
    };
  }

  private buildNotification(
    options: IPushOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>>
  ): Pushpad.Notification {
    return new Pushpad.Notification(
      this.transform(bridgeProviderData, {
        project: this.pushpad,
        body: options.content,
        title: options.title,
      }).body
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - notificationId(await new Promise((resolve, reject))
Declaraciones 'export' encontradas:
- export class PushpadPushProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/index.ts
Tamaño: 1709 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './africas-talking/africas-talking.provider';
export * from './afro-sms/afro-sms.provider';
export * from './azure-sms/azure-sms.provider';
export * from './bandwidth/bandwidth.provider';
export * from './brevo-sms/brevo-sms.provider';
export * from './bulk-sms/bulk-sms.provider';
export * from './burst-sms/burst-sms.provider';
export * from './clickatell/clickatell.provider';
export * from './clicksend/clicksend.provider';
export * from './eazy-sms/eazy-sms.provider';
export * from './firetext/firetext.provider';
export * from './forty-six-elks/forty-six-elks.provider';
export * from './generic-sms/generic-sms.provider';
export * from './gupshup/gupshup.provider';
export * from './imedia/imedia.provider';
export * from './infobip/infobip.provider';
export * from './isend-sms/isend-sms.provider';
export * from './kannel/kannel.provider';
export * from './maqsam/maqsam.provider';
export * from './messagebird/messagebird.provider';
export * from './mobishastra/mobishastra.provider';
export * from './nexmo/nexmo.provider';
export * from './plivo/plivo.provider';
export * from './ring-central/ring-central.provider';
export * from './sendchamp/sendchamp.provider';
export * from './simpletexting/simpletexting.provider';
export * from './sinch/sinch.provider';
export * from './sms-central/sms-central.provider';
export * from './sms77/sms77.provider';
export * from './smsmode/smsmode.provider';
export * from './sns/sns.config';
export * from './sns/sns.provider';
export * from './telnyx/telnyx.interface';
export * from './telnyx/telnyx.provider';
export * from './termii/termii.provider';
export * from './twilio/twilio.provider';
export * from './unifonic/unifonic.provider';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/africas-talking/africas-talking.provider.spec.ts
Tamaño: 1670 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, test, vi } from 'vitest';
import { AfricasTalkingSmsProvider } from './africas-talking.provider';

test(`should trigger Africa's Talking library correctly`, async () => {
  const provider = new AfricasTalkingSmsProvider({
    apiKey: 'b664b089f04b72c56ac3b0a8ffbb6f3d18a82eb40c29d17b49b84433439fb127',
    username: 'sandbox',
    from: '1234',
  });

  const spy = vi.spyOn((provider as any).africasTalkingClient, 'send').mockImplementation(async () => {
    return {
      date: new Date().toISOString(),
      id: Math.ceil(Math.random() * 100),
    };
  });

  await provider.sendMessage({
    to: '+2347063317344',
    content: 'SMS Content',
  });

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    to: '+2347063317344',
    from: '1234',
    message: 'SMS Content',
  });
});

test(`should trigger Africa's Talking library correctly with _passthrough`, async () => {
  const provider = new AfricasTalkingSmsProvider({
    apiKey: 'b664b089f04b72c56ac3b0a8ffbb6f3d18a82eb40c29d17b49b84433439fb127',
    username: 'sandbox',
    from: '1234',
  });

  const spy = vi.spyOn((provider as any).africasTalkingClient, 'send').mockImplementation(async () => {
    return {
      date: new Date().toISOString(),
      id: Math.ceil(Math.random() * 100),
    };
  });

  await provider.sendMessage(
    {
      to: '+2347063317344',
      content: 'SMS Content',
    },
    {
      _passthrough: {
        body: {
          to: '+3347063317344',
        },
      },
    }
  );

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    to: '+3347063317344',
    from: '1234',
    message: 'SMS Content',
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - spy(vi.spyOn((provider as any).africasTalkingClient, 'send').mockImplementation(async ())
 - spy(vi.spyOn((provider as any).africasTalkingClient, 'send').mockImplementation(async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/africas-talking/africas-talking.provider.ts
Tamaño: 1383 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SmsProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, ISendMessageSuccessResponse, ISmsOptions, ISmsProvider } from '@novu/stateless';
import AfricasTalking from 'africastalking';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class AfricasTalkingSmsProvider extends BaseProvider implements ISmsProvider {
  protected casing = CasingEnum.CAMEL_CASE;
  id: SmsProviderIdEnum.AfricasTalking;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;
  private africasTalkingClient: AfricasTalking;

  constructor(
    private config: {
      apiKey: string;
      username: string;
      from?: string;
    }
  ) {
    super();
    this.africasTalkingClient = new AfricasTalking({
      apiKey: config.apiKey,
      username: config.username,
    }).SMS;
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const response = await this.africasTalkingClient.send(
      this.transform(bridgeProviderData, {
        from: options.from || this.config.from,
        to: options.to,
        message: options.content,
      }).body
    );

    return {
      id: response?.SMSMessageData?.Recipients[0]?.messageId,
      date: new Date().toISOString(),
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class AfricasTalkingSmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/afro-sms/afro-sms.provider.ts
Tamaño: 1615 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SmsProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, ISendMessageSuccessResponse, ISmsOptions, ISmsProvider } from '@novu/stateless';

import axios from 'axios';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class AfroSmsProvider extends BaseProvider implements ISmsProvider {
  id = SmsProviderIdEnum.AfroSms;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;
  protected casing = CasingEnum.SNAKE_CASE;
  private readonly BASE_URL = 'https://api.afromessage.com';
  private readonly ENDPOINT = '/api/send';

  constructor(
    private config: {
      apiKey?: string;
      senderName?: string;
      from?: string;
    }
  ) {
    super();
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const url = `${this.BASE_URL}${this.ENDPOINT}`;

    const queryParams = {
      from: this.config.from || options.from,
      sender: this.config.senderName,
      to: options.to,
      message: options.content,
    };

    const { data } = await axios.get(url, {
      params: this.transform(bridgeProviderData, queryParams).body,
      headers: {
        Authorization: `Bearer ${this.config.apiKey}`,
      },
    });

    if (data.acknowledge !== 'success') {
      throw new Error(`AfroSMS error: ${data.response || 'Unknown error'}`);
    }

    return {
      id: data.response?.message_id || data.response?.id || 'unknown',
      date: new Date().toISOString(),
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class AfroSmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/azure-sms/azure-sms.provider.spec.ts
Tamaño: 1931 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

// azure-sms.provider.spec.ts

import { SmsClient } from '@azure/communication-sms';
import { expect, MockedClass, test, vi } from 'vitest';
import { AzureSmsProvider } from './azure-sms.provider';

vi.mock('@azure/communication-sms');
test('should trigger AzureSmsProvider library correctly', async () => {
  const mockSend = vi.fn().mockResolvedValue([
    {
      messageId: '12345-67a8',
      httpStatusCode: 202,
      successful: true,
      to: '+12345678902',
    },
  ]);

  (SmsClient as MockedClass<typeof SmsClient>).mockImplementation(() => {
    return {
      send: mockSend,
    } as unknown as SmsClient;
  });

  const provider = new AzureSmsProvider({
    connectionString: 'MOCK-CONNECTION-STRING',
  });

  await provider.sendMessage({
    from: '+1234567890',
    to: '+12345678902',
    content: 'Test message',
  });

  expect(mockSend).toHaveBeenCalled();

  expect(mockSend).toHaveBeenCalledWith({
    from: '+1234567890',
    to: ['+12345678902'],
    message: 'Test message',
  });
});

test('should trigger AzureSmsProvider library correctly with _passthrough', async () => {
  const mockSend = vi.fn().mockResolvedValue([
    {
      messageId: '12345-67a8',
      httpStatusCode: 202,
      successful: true,
      to: '+12345678902',
    },
  ]);

  (SmsClient as MockedClass<typeof SmsClient>).mockImplementation(() => {
    return {
      send: mockSend,
    } as unknown as SmsClient;
  });

  const provider = new AzureSmsProvider({
    connectionString: 'MOCK-CONNECTION-STRING',
  });

  await provider.sendMessage(
    {
      from: '+1234567890',
      to: '+12345678902',
      content: 'Test message',
    },
    {
      _passthrough: {
        body: {
          from: '+2234567890',
        },
      },
    }
  );

  expect(mockSend).toHaveBeenCalled();

  expect(mockSend).toHaveBeenCalledWith({
    from: '+2234567890',
    to: ['+12345678902'],
    message: 'Test message',
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - mockSend(vi.fn().mockResolvedValue([
    {
      messageId: '12345-67a8',
      httpStatusCode: 202,
      su...)
 - provider(new AzureSmsProvider({
    connectionString: 'MOCK-CONNECTION-STRING',
  });

  await provider.sendM...)
 - mockSend(vi.fn().mockResolvedValue([
    {
      messageId: '12345-67a8',
      httpStatusCode: 202,
      su...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/azure-sms/azure-sms.provider.ts
Tamaño: 1390 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SmsClient, SmsSendRequest } from '@azure/communication-sms';
import { SmsProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, ISendMessageSuccessResponse, ISmsOptions, ISmsProvider } from '@novu/stateless';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class AzureSmsProvider extends BaseProvider implements ISmsProvider {
  id = SmsProviderIdEnum.AzureSms;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;
  protected casing = CasingEnum.CAMEL_CASE;

  private smsClient: SmsClient;
  constructor(
    private config: {
      connectionString: string;
    }
  ) {
    super();
    this.smsClient = new SmsClient(this.config.connectionString);
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const sendResults = await this.smsClient.send(
      this.transform<SmsSendRequest>(bridgeProviderData, {
        from: options.from,
        to: [options.to],
        message: options.content,
      }).body
    );

    const sendResult = sendResults[0];

    if (sendResult.successful) {
      return {
        id: sendResult.messageId,
        date: new Date().toISOString(),
      };
    } else {
      throw new Error(sendResult.errorMessage);
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class AzureSmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/bandwidth/bandwidth.provider.spec.ts
Tamaño: 1912 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, test, vi } from 'vitest';
import { BandwidthSmsProvider } from './bandwidth.provider';

test('should trigger BandwidthSmsProvider library correctly', async () => {
  const provider = new BandwidthSmsProvider({
    username: '<your-bandwidth-username>',
    password: '<your-bandwidth-password>',
    accountId: '<your-bandwidth-accountId>',
  });

  const spy = vi.spyOn((provider as any).controller, 'createMessage').mockImplementation(async () => {
    return {
      result: {
        id: '12345-67a8',
        time: new Date().toISOString(),
      },
    };
  });

  await provider.sendMessage({
    to: '+12345678902',
    content: 'test message',
    from: '+1234567890',
  });

  expect(spy).toHaveBeenCalled();

  expect(spy).toHaveBeenCalledWith('<your-bandwidth-accountId>', {
    applicationId: '<your-bandwidth-accountId>',
    to: ['+12345678902'],
    from: '+1234567890',
    text: 'test message',
  });
});

test('should trigger BandwidthSmsProvider library correctly with _passthrough', async () => {
  const provider = new BandwidthSmsProvider({
    username: '<your-bandwidth-username>',
    password: '<your-bandwidth-password>',
    accountId: '<your-bandwidth-accountId>',
  });

  const spy = vi.spyOn((provider as any).controller, 'createMessage').mockImplementation(async () => {
    return {
      result: {
        id: '12345-67a8',
        time: new Date().toISOString(),
      },
    };
  });

  await provider.sendMessage(
    {
      to: '+12345678902',
      content: 'test message',
      from: '+1234567890',
    },
    {
      _passthrough: {
        body: {
          from: '+2234567890',
        },
      },
    }
  );

  expect(spy).toHaveBeenCalled();

  expect(spy).toHaveBeenCalledWith('<your-bandwidth-accountId>', {
    applicationId: '<your-bandwidth-accountId>',
    to: ['+12345678902'],
    from: '+2234567890',
    text: 'test message',
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - spy(vi.spyOn((provider as any).controller, 'createMessage').mockImplementation(async ())
 - spy(vi.spyOn((provider as any).controller, 'createMessage').mockImplementation(async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/bandwidth/bandwidth.provider.ts
Tamaño: 1515 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiController, Client, MessageRequest } from '@bandwidth/messaging';
import { SmsProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, ISendMessageSuccessResponse, ISmsOptions, ISmsProvider } from '@novu/stateless';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class BandwidthSmsProvider extends BaseProvider implements ISmsProvider {
  id = SmsProviderIdEnum.Bandwidth;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;
  protected casing = CasingEnum.CAMEL_CASE;
  public controller: ApiController;

  constructor(
    private config: {
      username: string;
      password: string;
      accountId: string;
    }
  ) {
    super();
    const client = new Client({
      basicAuthUserName: config.username,
      basicAuthPassword: config.password,
    });
    this.controller = new ApiController(client);
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const body = this.transform<MessageRequest>(bridgeProviderData, {
      applicationId: this.config.accountId,
      to: [options.to],
      from: options.from,
      text: options.content,
    });

    const createMessageResponse = await this.controller.createMessage(this.config.accountId, body.body);

    return {
      id: createMessageResponse.result.id,
      date: createMessageResponse.result.time,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class BandwidthSmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/brevo-sms/brevo-sms.provider.spec.ts
Tamaño: 5855 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ISmsOptions } from '@novu/stateless';
import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
import { BrevoSmsProvider } from './brevo-sms.provider';

const mockConfig = {
  apiKey: 'ABCDE',
  from: 'My Company',
};

const mockNovuMessage: ISmsOptions = {
  from: 'My Company',
  to: '+33623456789',
  content: 'SMS content',
};

const mockBrevoResponse = {
  reference: 'brevo-reference',
  messageId: 1511882900176220,
  smsCount: 2,
  usedCredits: 0.7,
  remainingCredits: 82.85,
};

beforeEach(() => {
  vi.restoreAllMocks();
});

afterEach(() => {
  vi.restoreAllMocks();
});

describe('sendMessage method', () => {
  test('should call brevo API transactional sms endpoint once', async () => {
    const provider = new BrevoSmsProvider(mockConfig);

    const fetchMock = vi.fn().mockResolvedValue({
      json: () => Promise.resolve(mockBrevoResponse),
      status: 201,
    });
    global.fetch = fetchMock;

    await provider.sendMessage(mockNovuMessage);

    expect(fetchMock).toHaveBeenCalled();
  });

  test('should call brevo API transactional sms endpoint with right URL', async () => {
    const provider = new BrevoSmsProvider(mockConfig);

    const fetchMock = vi.fn().mockResolvedValue({
      json: () => Promise.resolve(mockBrevoResponse),
      status: 201,
    });
    global.fetch = fetchMock;

    await provider.sendMessage(mockNovuMessage);

    expect(fetchMock.mock.calls[0][0]).toEqual('https://api.brevo.com/v3/transactionalSMS/sms');
  });

  test('should call brevo API transactional sms endpoint using POST method', async () => {
    const provider = new BrevoSmsProvider(mockConfig);

    const fetchMock = vi.fn().mockResolvedValue({
      json: () => Promise.resolve(mockBrevoResponse),
      status: 201,
    });
    global.fetch = fetchMock;

    await provider.sendMessage(mockNovuMessage);

    expect(fetchMock.mock.calls[0][1]).toMatchObject({
      method: 'POST',
    });
  });

  test('should call brevo API using config apiKey', async () => {
    const provider = new BrevoSmsProvider(mockConfig);

    const fetchMock = vi.fn().mockResolvedValue({
      json: () => Promise.resolve(mockBrevoResponse),
      status: 201,
    });
    global.fetch = fetchMock;

    await provider.sendMessage(mockNovuMessage);

    expect(fetchMock.mock.calls[0][1]).toMatchObject({
      headers: {
        'api-key': mockConfig.apiKey,
      },
    });
  });

  test('should send message with provided config from', async () => {
    const provider = new BrevoSmsProvider(mockConfig);

    const fetchMock = vi.fn().mockResolvedValue({
      json: () => Promise.resolve(mockBrevoResponse),
      status: 201,
    });
    global.fetch = fetchMock;

    const { from, ...mockNovuMessageWithoutFrom } = mockNovuMessage;

    await provider.sendMessage(mockNovuMessageWithoutFrom);

    const body = JSON.parse(fetchMock.mock.calls[0][1].body);
    expect(body.sender).toEqual(mockConfig.from);
  });

  test('should send message with provided option from overriding config from', async () => {
    const provider = new BrevoSmsProvider(mockConfig);

    const fetchMock = vi.fn().mockResolvedValue({
      json: () => Promise.resolve(mockBrevoResponse),
      status: 201,
    });
    global.fetch = fetchMock;

    await provider.sendMessage(mockNovuMessage);

    const body = JSON.parse(fetchMock.mock.calls[0][1].body);
    expect(body.sender).toEqual(mockNovuMessage.from);
  });

  test('should send message with provided option to', async () => {
    const provider = new BrevoSmsProvider(mockConfig);

    const fetchMock = vi.fn().mockResolvedValue({
      json: () => Promise.resolve(mockBrevoResponse),
      status: 201,
    });
    global.fetch = fetchMock;

    await provider.sendMessage(mockNovuMessage);

    const body = JSON.parse(fetchMock.mock.calls[0][1].body);
    expect(body.recipient).toEqual(mockNovuMessage.to);
  });

  test('should send message with provided option content', async () => {
    const provider = new BrevoSmsProvider(mockConfig);

    const fetchMock = vi.fn().mockResolvedValue({
      json: () => Promise.resolve(mockBrevoResponse),
      status: 201,
    });
    global.fetch = fetchMock;

    await provider.sendMessage(mockNovuMessage);

    const body = JSON.parse(fetchMock.mock.calls[0][1].body);
    expect(body.content).toEqual(mockNovuMessage.content);
  });

  test('should send message with provided option content with _passthrough', async () => {
    const provider = new BrevoSmsProvider(mockConfig);

    const fetchMock = vi.fn().mockResolvedValue({
      json: () => Promise.resolve(mockBrevoResponse),
      status: 201,
    });
    global.fetch = fetchMock;

    await provider.sendMessage(mockNovuMessage, {
      _passthrough: {
        body: {
          content: '_passthrough content',
        },
      },
    });

    const body = JSON.parse(fetchMock.mock.calls[0][1].body);
    expect(body.content).toEqual('_passthrough content');
  });

  test('should return id returned in request response', async () => {
    const provider = new BrevoSmsProvider(mockConfig);

    const fetchMock = vi.fn().mockResolvedValue({
      json: () => Promise.resolve(mockBrevoResponse),
      status: 201,
    });
    global.fetch = fetchMock;

    const result = await provider.sendMessage(mockNovuMessage);

    expect(result).toMatchObject({
      id: mockBrevoResponse.messageId,
    });
  });

  test('should return date returned in request response', async () => {
    const provider = new BrevoSmsProvider(mockConfig);

    const fetchMock = vi.fn().mockResolvedValue({
      json: () => Promise.resolve(mockBrevoResponse),
      status: 201,
    });
    global.fetch = fetchMock;

    const result = await provider.sendMessage(mockNovuMessage);

    expect(new Date(result.date).toString()).not.toEqual('Invalid Date');
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - mockBrevoResponse({
  reference: 'brevo-reference',
  messageId: 1511882900176220,
  smsCount: 2,
  usedCredits: 0.7,
...)
 - fetchMock(vi.fn().mockResolvedValue({
      json: ())
 - fetch(fetchMock;

    await provider.sendMessage(mockNovuMessage);

    expect(fetchMock).toHaveBeenCalled...)
 - fetchMock(vi.fn().mockResolvedValue({
      json: ())
 - fetch(fetchMock;

    await provider.sendMessage(mockNovuMessage);

    expect(fetchMock.mock.calls[0][0])...)
 - fetchMock(vi.fn().mockResolvedValue({
      json: ())
 - fetch(fetchMock;

    await provider.sendMessage(mockNovuMessage);

    expect(fetchMock.mock.calls[0][1])...)
 - fetchMock(vi.fn().mockResolvedValue({
      json: ())
 - fetch(fetchMock;

    await provider.sendMessage(mockNovuMessage);

    expect(fetchMock.mock.calls[0][1])...)
 - fetchMock(vi.fn().mockResolvedValue({
      json: ())
 - body(JSON.parse(fetchMock.mock.calls[0][1].body);
    expect(body.sender).toEqual(mockConfig.from);
  });...)
 - fetchMock(vi.fn().mockResolvedValue({
      json: ())
 - body(JSON.parse(fetchMock.mock.calls[0][1].body);
    expect(body.sender).toEqual(mockNovuMessage.from);
...)
 - fetchMock(vi.fn().mockResolvedValue({
      json: ())
 - body(JSON.parse(fetchMock.mock.calls[0][1].body);
    expect(body.recipient).toEqual(mockNovuMessage.to);...)
 - fetchMock(vi.fn().mockResolvedValue({
      json: ())
 - body(JSON.parse(fetchMock.mock.calls[0][1].body);
    expect(body.content).toEqual(mockNovuMessage.conten...)
 - fetchMock(vi.fn().mockResolvedValue({
      json: ())
 - body(JSON.parse(fetchMock.mock.calls[0][1].body);
    expect(body.content).toEqual('_passthrough content'...)
 - fetchMock(vi.fn().mockResolvedValue({
      json: ())
 - result(await provider.sendMessage(mockNovuMessage);

    expect(result).toMatchObject({
      id: mockBrevo...)
 - fetchMock(vi.fn().mockResolvedValue({
      json: ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/brevo-sms/brevo-sms.provider.ts
Tamaño: 1632 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChannelTypeEnum, ISendMessageSuccessResponse, ISmsOptions, ISmsProvider } from '@novu/stateless';
import { ProxyAgent } from 'proxy-agent';
import 'cross-fetch';
import { SmsProviderIdEnum } from '@novu/shared';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

declare global {
  interface RequestInit {
    agent: ProxyAgent;
  }
}

export class BrevoSmsProvider extends BaseProvider implements ISmsProvider {
  id = SmsProviderIdEnum.BrevoSms;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;
  public readonly BASE_URL = 'https://api.brevo.com/v3';
  protected casing = CasingEnum.CAMEL_CASE;

  constructor(
    private config: {
      apiKey: string;
      from: string;
    }
  ) {
    super();
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const sms = this.transform(bridgeProviderData, {
      sender: options.from || this.config.from,
      recipient: options.to,
      content: options.content,
    });

    const response = await fetch(`${this.BASE_URL}/transactionalSMS/sms`, {
      method: 'POST',
      headers: {
        'api-key': this.config.apiKey,
        'Content-Type': 'application/json',
        Accept: 'application/json',
        ...sms.headers,
      },
      agent: new ProxyAgent(),
      body: JSON.stringify(sms.body),
    });

    const body: { messageId: string } = await response.json();

    return {
      id: body.messageId,
      date: new Date().toISOString(),
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class BrevoSmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/bulk-sms/bulk-sms.provider.spec.ts
Tamaño: 1853 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, test } from 'vitest';
import { axiosSpy } from '../../../utils/test/spy-axios';
import { BulkSmsProvider } from './bulk-sms.provider';

const mockConfig = {
  apiToken: 'test-key',
  from: '45482346',
};

const mockBulkSMSMessage = {
  to: '2348055372961',
  content: 'sms content',
  from: '45483533',
};

test('should trigger bulk-sms library correctly', async () => {
  const { mockPost: spy } = axiosSpy({
    data: [
      {
        id: '67890-90q8',
        date: new Date().toISOString(),
      },
    ],
  });
  const smsProvider = new BulkSmsProvider(mockConfig);

  await smsProvider.sendMessage(mockBulkSMSMessage);
  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith(
    'https://api.bulksms.com/v1/messages',
    '{"to":"2348055372961","body":"sms content","from":{"type":"INTERNATIONAL","address":"45483533"},"userSuppliedId":"BLKTM.NOVU.01.00.00"}',
    {
      headers: {
        Authorization: 'Basic dGVzdC1rZXk=',
        'Content-Type': 'application/json',
      },
    }
  );
});

test('should trigger bulk-sms library correctly with _passthrough', async () => {
  const { mockPost: spy } = axiosSpy({
    data: [
      {
        id: '67890-90q8',
        date: new Date().toISOString(),
      },
    ],
  });
  const smsProvider = new BulkSmsProvider(mockConfig);

  await smsProvider.sendMessage(mockBulkSMSMessage, {
    _passthrough: {
      body: {
        to: '3348055372961',
      },
    },
  });
  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith(
    'https://api.bulksms.com/v1/messages',
    '{"to":"3348055372961","body":"sms content","from":{"type":"INTERNATIONAL","address":"45483533"},"userSuppliedId":"BLKTM.NOVU.01.00.00"}',
    {
      headers: {
        Authorization: 'Basic dGVzdC1rZXk=',
        'Content-Type': 'application/json',
      },
    }
  );
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - mockBulkSMSMessage({
  to: '2348055372961',
  content: 'sms content',
  from: '45483533',
};

test('should trigger bulk...)
 - dGVzdC1rZXk(',
        'Content-Type': 'application/json',
      },
    }
  );
});

test('should trigger bulk-sm...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/bulk-sms/bulk-sms.provider.ts
Tamaño: 2284 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SmsProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, ISendMessageSuccessResponse, ISmsOptions, ISmsProvider } from '@novu/stateless';
import axios from 'axios';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class BulkSmsProvider extends BaseProvider implements ISmsProvider {
  id = SmsProviderIdEnum.BulkSms;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;
  public readonly DEFAULT_BASE_URL = 'https://api.bulksms.com/v1/messages';
  protected casing = CasingEnum.CAMEL_CASE;

  constructor(
    private config: {
      apiToken: string;
      from: string;
    }
  ) {
    super();
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const from = options.from || this.config.from;

    const payload = this.transform(bridgeProviderData, {
      to: options.to,
      body: options.content,
      ...(this.createFormField(from) && { from: this.createFormField(from) }),
      // this userSuppliedId helps bulk-sms to identify the message source as Novuand helps in debugging
      userSuppliedId: 'BLKTM.NOVU.01.00.00',
    });

    const url = this.DEFAULT_BASE_URL;

    const encodedToken = Buffer.from(this.config.apiToken).toString('base64');
    const response = await axios.create().post(url, JSON.stringify(payload.body), {
      headers: {
        Authorization: `Basic ${encodedToken}`,
        'Content-Type': 'application/json',
        ...payload.headers,
      },
    });

    return {
      id: response.data[0].id,
      date: new Date().toISOString(),
    };
  }

  createFormField(senderId: string | null) {
    // check if senderId is null or empty string
    if (!senderId || senderId.trim() === '') {
      return null;
    }

    // check if senderId string contains only numbers
    if (/^\d+$/.test(senderId)) {
      return {
        type: 'INTERNATIONAL',
        address: senderId,
      };
    }

    // check if senderId string contains alphanumeric characters
    if (/^[a-zA-Z0-9]+$/.test(senderId)) {
      return {
        type: 'ALPHANUMERIC',
        address: senderId,
      };
    }

    return null;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class BulkSmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/burst-sms/burst-sms.provider.spec.ts
Tamaño: 1603 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { v4 as uuidv4 } from 'uuid';
import { expect, test } from 'vitest';
import { axiosSpy } from '../../../utils/test/spy-axios';
import { BurstSmsProvider } from './burst-sms.provider';

test('should trigger Burst SMS axios request correctly', async () => {
  const { mockPost: fakePost } = axiosSpy({
    data: { message_id: uuidv4, send_at: new Date().toISOString() },
  });

  const provider = new BurstSmsProvider({ apiKey: '', secretKey: '' });

  const testTo = '+15555555';
  const testContent = 'Welcome. This is a test message';
  await provider.sendMessage({
    content: testContent,
    to: testTo,
  });

  expect(fakePost).toHaveBeenCalled();
  expect(fakePost).toHaveBeenCalledWith(
    'https://api.transmitsms.com/send-sms.json',
    'message=Welcome.%20This%20is%20a%20test%20message&to=%2B15555555'
  );
});

test('should trigger Burst SMS axios request correctly with _passthrough', async () => {
  const { mockPost: fakePost } = axiosSpy({
    data: { message_id: uuidv4, send_at: new Date().toISOString() },
  });

  const provider = new BurstSmsProvider({ apiKey: '', secretKey: '' });

  const testTo = '+15555555';
  const testContent = 'Welcome. This is a test message';
  await provider.sendMessage(
    {
      content: testContent,
      to: testTo,
    },
    {
      _passthrough: {
        body: {
          to: '+25555555',
        },
      },
    }
  );

  expect(fakePost).toHaveBeenCalled();
  expect(fakePost).toHaveBeenCalledWith(
    'https://api.transmitsms.com/send-sms.json',
    'message=Welcome.%20This%20is%20a%20test%20message&to=%2B25555555'
  );
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - to(%2B15555555'
  );
});

test('should trigger Burst SMS axios request correctly with _passthrough', as...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/burst-sms/burst-sms.provider.ts
Tamaño: 1405 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SmsProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, ISendMessageSuccessResponse, ISmsOptions, ISmsProvider } from '@novu/stateless';
import axios, { AxiosInstance } from 'axios';
import qs from 'qs';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class BurstSmsProvider extends BaseProvider implements ISmsProvider {
  id = SmsProviderIdEnum.BurstSms;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;
  protected casing = CasingEnum.SNAKE_CASE;
  private axiosInstance: AxiosInstance;

  constructor(
    private config: {
      apiKey?: string;
      secretKey?: string;
    }
  ) {
    super();
    this.axiosInstance = axios.create({
      auth: {
        username: config.apiKey,
        password: config.secretKey,
      },
    });
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const data = qs.stringify(
      this.transform(bridgeProviderData, {
        message: options.content,
        to: options.to,
        from: options.from,
      }).body
    );

    const response = await this.axiosInstance.post('https://api.transmitsms.com/send-sms.json', data);

    return {
      id: response.data.message_id,
      date: response.data.send_at,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class BurstSmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/clickatell/clickatell.provider.spec.ts
Tamaño: 1525 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, test } from 'vitest';
import { axiosSpy } from '../../../utils/test/spy-axios';
import { ClickatellSmsProvider } from './clickatell.provider';

test('should trigger clickatellSmsProvider library correctly', async () => {
  const { mockPost: spy } = axiosSpy({
    data: {
      messages: [{ apiMessageId: '67890-90q8' }],
    },
  });

  const provider = new ClickatellSmsProvider({
    apiKey: '<clickatell-api-key>',
  });

  await provider.sendMessage({
    to: '+2347089736898',
    content: 'Test',
  });

  expect(spy).toHaveBeenCalled();

  expect(spy).toHaveBeenCalledWith(
    'https://platform.clickatell.com/messages',
    { binary: true, content: 'Test', to: ['+2347089736898'] },
    { headers: { Authorization: '<clickatell-api-key>' } }
  );
});

test('should trigger clickatellSmsProvider library correctly with _passthrough', async () => {
  const { mockPost: spy } = axiosSpy({
    data: {
      messages: [{ apiMessageId: '67890-90q8' }],
    },
  });

  const provider = new ClickatellSmsProvider({
    apiKey: '<clickatell-api-key>',
  });

  await provider.sendMessage(
    {
      to: '+2347089736898',
      content: 'Test',
    },
    {
      _passthrough: {
        body: {
          binary: false,
        },
      },
    }
  );

  expect(spy).toHaveBeenCalled();

  expect(spy).toHaveBeenCalledWith(
    'https://platform.clickatell.com/messages',
    { binary: false, content: 'Test', to: ['+2347089736898'] },
    { headers: { Authorization: '<clickatell-api-key>' } }
  );
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - provider(new ClickatellSmsProvider({
    apiKey: '<clickatell-api-key>',
  });

  await provider.sendMessage(...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/clickatell/clickatell.provider.ts
Tamaño: 1375 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SmsProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, ISendMessageSuccessResponse, ISmsOptions, ISmsProvider } from '@novu/stateless';

import axios from 'axios';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class ClickatellSmsProvider extends BaseProvider implements ISmsProvider {
  id = SmsProviderIdEnum.Clickatell;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;
  protected casing = CasingEnum.CAMEL_CASE;

  constructor(
    private config: {
      apiKey?: string;
      isTwoWayIntegration?: boolean;
    }
  ) {
    super();
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const url = 'https://platform.clickatell.com/messages';

    const data = this.transform(bridgeProviderData, {
      to: [options.to],
      ...(this.config.isTwoWayIntegration && { from: options.from }),
      content: options.content,
      binary: true,
    });

    const response = await axios.create().post(url, data.body, {
      headers: {
        Authorization: this.config.apiKey,
        ...data.headers,
      },
    });

    return {
      id: response.data?.messages[0]?.apiMessageId,
      date: new Date().toISOString(),
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ClickatellSmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/clicksend/clicksend.provider.spec.ts
Tamaño: 1992 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, test } from 'vitest';
import { axiosSpy } from '../../../utils/test/spy-axios';
import { ClicksendSmsProvider } from './clicksend.provider';

test('should trigger ClicksendSmsProvider library correctly', async () => {
  const { mockPost: spy } = axiosSpy({
    data: {
      data: {
        messages: [
          {
            message_id: '12345-67a8',
            date: new Date().toISOString(),
          },
        ],
      },
    },
  });

  const provider = new ClicksendSmsProvider({
    username: '<your-clicksend-username>',
    apiKey: '<your-clicksend-API>',
  });

  await provider.sendMessage({
    to: '+0451111111',
    content: 'test message',
  });

  expect(spy).toHaveBeenCalled();

  expect(spy).toHaveBeenCalledWith(
    'https://rest.clicksend.com/v3/sms/send',
    { messages: [{ body: 'test message', to: '+0451111111' }] },
    {
      headers: {
        Authorization: 'Basic PHlvdXItY2xpY2tzZW5kLXVzZXJuYW1lPjo8eW91ci1jbGlja3NlbmQtQVBJPg==',
      },
    }
  );
});

test('should trigger ClicksendSmsProvider library correctly with _passthrough', async () => {
  const { mockPost: spy } = axiosSpy({
    data: {
      data: {
        messages: [
          {
            message_id: '12345-67a8',
            date: new Date().toISOString(),
          },
        ],
      },
    },
  });

  const provider = new ClicksendSmsProvider({
    username: '<your-clicksend-username>',
    apiKey: '<your-clicksend-API>',
  });

  await provider.sendMessage(
    {
      to: '+0451111111',
      content: 'test message',
    },
    {
      _passthrough: {
        body: {
          to: '+1451111111',
        },
      },
    }
  );

  expect(spy).toHaveBeenCalled();

  expect(spy).toHaveBeenCalledWith(
    'https://rest.clicksend.com/v3/sms/send',
    { messages: [{ body: 'test message', to: '+1451111111' }] },
    {
      headers: {
        Authorization: 'Basic PHlvdXItY2xpY2tzZW5kLXVzZXJuYW1lPjo8eW91ci1jbGlja3NlbmQtQVBJPg==',
      },
    }
  );
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

No se detectaron funciones/exportaciones con heurística JS/TS.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/clicksend/clicksend.provider.ts
Tamaño: 1387 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SmsProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, ISendMessageSuccessResponse, ISmsOptions, ISmsProvider } from '@novu/stateless';
import axios from 'axios';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class ClicksendSmsProvider extends BaseProvider implements ISmsProvider {
  id = SmsProviderIdEnum.Clicksend;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;
  protected casing = CasingEnum.SNAKE_CASE;

  constructor(
    private config: {
      username: string;
      apiKey: string;
    }
  ) {
    super();
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const data = this.transform(bridgeProviderData, {
      to: options.to,
      body: options.content,
    });
    const response = await axios.create().post(
      'https://rest.clicksend.com/v3/sms/send',
      {
        messages: [data.body],
      },
      {
        headers: {
          Authorization: `Basic ${Buffer.from(`${this.config.username}:${this.config.apiKey}`).toString('base64')}`,
          ...data.headers,
        },
      }
    );

    return {
      id: response.data.data.messages[0].message_id,
      date: response.data.data.messages[0].date,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ClicksendSmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/eazy-sms/eazy-sms.provider.spec.ts
Tamaño: 1678 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, test } from 'vitest';
import { axiosSpy } from '../../../utils/test/spy-axios';
import { EazySmsProvider } from './eazy-sms.provider';

const mockConfig = {
  apiKey: 'test-key',
  channelId: 'test-key@sms.eazy.im',
};

const mockSMSMessage = {
  to: '1234567890',
  content: 'sms content',
};

test('should trigger eazy-sms library correctly', async () => {
  const { mockPost: spy } = axiosSpy({
    data: {
      id: '2574a339-86ff',
    },
  });
  const smsProvider = new EazySmsProvider(mockConfig);

  await smsProvider.sendMessage(mockSMSMessage);
  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith(
    'https://api.eazy.im/v3/channels/test-key@sms.eazy.im/messages/1234567890@sms.eazy.im',
    { message: { text: 'sms content', type: 'text' } },
    {
      headers: {
        Authorization: 'Bearer test-key',
        'Content-Type': 'application/json',
      },
    }
  );
});

test('should trigger eazy-sms library correctly with _passthrough', async () => {
  const { mockPost: spy } = axiosSpy({
    data: {
      id: '2574a339-86ff',
    },
  });
  const smsProvider = new EazySmsProvider(mockConfig);

  await smsProvider.sendMessage(mockSMSMessage, {
    _passthrough: {
      body: {
        message: { text: 'sms content _passthrough' },
      },
    },
  });
  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith(
    'https://api.eazy.im/v3/channels/test-key@sms.eazy.im/messages/1234567890@sms.eazy.im',
    { message: { text: 'sms content _passthrough', type: 'text' } },
    {
      headers: {
        Authorization: 'Bearer test-key',
        'Content-Type': 'application/json',
      },
    }
  );
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - mockSMSMessage({
  to: '1234567890',
  content: 'sms content',
};

test('should trigger eazy-sms library correctly'...)
 - smsProvider(new EazySmsProvider(mockConfig);

  await smsProvider.sendMessage(mockSMSMessage);
  expect(spy).toH...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/eazy-sms/eazy-sms.provider.ts
Tamaño: 1554 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SmsProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, ISendMessageSuccessResponse, ISmsOptions, ISmsProvider } from '@novu/stateless';
import axios from 'axios';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class EazySmsProvider extends BaseProvider implements ISmsProvider {
  id = SmsProviderIdEnum.EazySms;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;
  protected casing = CasingEnum.CAMEL_CASE;
  public readonly DEFAULT_BASE_URL = 'https://api.eazy.im/v3';
  public readonly EAZY_SMS_CHANNEL = '@sms.eazy.im';
  constructor(
    private config: {
      apiKey: string;
      channelId: string;
    }
  ) {
    super();
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const payload = this.transform(bridgeProviderData, {
      message: {
        text: options.content,
        type: 'text',
      },
    });

    const response = await axios
      .create()
      .post(
        `${this.DEFAULT_BASE_URL}/channels/${this.config.channelId}/messages/${options.to}${this.EAZY_SMS_CHANNEL}`,
        payload.body,
        {
          headers: {
            Authorization: `Bearer ${this.config.apiKey}`,
            'Content-Type': 'application/json',
            ...payload.headers,
          },
        }
      );

    return {
      id: response.data.id,
      date: new Date().toISOString(),
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class EazySmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/firetext/firetext.provider.spec.ts
Tamaño: 3600 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { afterEach, describe, expect, test, vi } from 'vitest';
import { FiretextSmsProvider } from './firetext.provider';

describe('FiretextSmsProvider', () => {
  const date = new Date('2022-01-01T00:00:00.000Z');

  const provider = new FiretextSmsProvider({
    apiKey: 'apiKey',
    from: 'testFrom',
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  test('should trigger firetext library correctly', async () => {
    const fetchMock = vi.fn().mockResolvedValue({
      headers: {
        get: (header) => {
          if (header === 'X-Message') return 'ID';
          if (header === 'Content-Type') return 'text/plain';
          if (header === 'Date') return date.toString();
        },
      },
      text: () => Promise.resolve('0:12 SMS successfully queued'),
    });
    global.fetch = fetchMock;

    const result = await provider.sendMessage({
      content: 'content',
      to: '+44123456789',
    });

    expect(result).toMatchObject({ id: 'ID', date: date.toISOString() });
  });

  test('should call fetch correctly', async () => {
    const fetchMock = vi.fn().mockResolvedValue({
      headers: {
        get: (header) => {
          if (header === 'X-Message') return 'ID';
          if (header === 'Content-Type') return 'text/plain';
        },
      },
      text: () => Promise.resolve('0:12 SMS successfully queued'),
    });
    global.fetch = fetchMock;

    const result = await provider.sendMessage({
      content: 'content',
      to: '+44123456789',
    });

    expect(fetchMock).toHaveBeenCalledWith(
      'https://www.firetext.co.uk/api/sendsms?apiKey=apiKey&to=%2B44123456789&from=testFrom&message=content'
    );
  });

  test('should call fetch correctly with _passthrough', async () => {
    const fetchMock = vi.fn().mockResolvedValue({
      headers: {
        get: (header) => {
          if (header === 'X-Message') return 'ID';
          if (header === 'Content-Type') return 'text/plain';
        },
      },
      text: () => Promise.resolve('0:12 SMS successfully queued'),
    });
    global.fetch = fetchMock;

    await provider.sendMessage(
      {
        content: 'content',
        to: '+44123456789',
      },
      {
        _passthrough: {
          body: {
            to: '+24123456789',
          },
        },
      }
    );

    expect(fetchMock).toHaveBeenCalledWith(
      'https://www.firetext.co.uk/api/sendsms?apiKey=apiKey&to=%2B24123456789&from=testFrom&message=content'
    );
  });

  test('should throw error', async () => {
    const fetchMock = vi.fn().mockResolvedValue({
      headers: {
        get: (header) => {
          if (header === 'X-Message') return 'ID';
          if (header === 'Content-Type') return 'text/plain';
        },
      },
      text: () => Promise.resolve('1:0 Authentication error'),
    });
    global.fetch = fetchMock;

    const result = provider.sendMessage({
      content: 'content',
      to: '+44123456789',
    });

    await expect(result).rejects.toThrow('1: Authentication error');
  });

  test('should handle unknown return codes', async () => {
    const fetchMock = vi.fn().mockResolvedValue({
      headers: {
        get: (header) => {
          if (header === 'X-Message') return 'ID';
          if (header === 'Content-Type') return 'text/plain';
        },
      },
      text: () => Promise.resolve('gobbledygook'),
    });
    global.fetch = fetchMock;

    const result = provider.sendMessage({
      content: 'content',
      to: '+44123456789',
    });

    await expect(result).rejects.toThrow('Unknown status code: Unknown status message');
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - provider(new FiretextSmsProvider({
    apiKey: 'apiKey',
    from: 'testFrom',
  });

  afterEach(())
 - fetchMock(vi.fn().mockResolvedValue({
      headers: {
        get: (header))
 - result(await provider.sendMessage({
      content: 'content',
      to: '+44123456789',
    });

    expect...)
 - fetchMock(vi.fn().mockResolvedValue({
      headers: {
        get: (header))
 - message(content'
    );
  });

  test('should call fetch correctly with _passthrough', async ())
 - fetchMock(vi.fn().mockResolvedValue({
      headers: {
        get: (header))
 - message(content'
    );
  });

  test('should throw error', async ())
 - fetchMock(vi.fn().mockResolvedValue({
      headers: {
        get: (header))
 - result(provider.sendMessage({
      content: 'content',
      to: '+44123456789',
    });

    await expect...)
 - fetchMock(vi.fn().mockResolvedValue({
      headers: {
        get: (header))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/firetext/firetext.provider.ts
Tamaño: 2136 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SmsProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, ISendMessageSuccessResponse, ISmsOptions, ISmsProvider } from '@novu/stateless';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class FiretextSmsProvider extends BaseProvider implements ISmsProvider {
  id = SmsProviderIdEnum.Firetext;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;
  protected casing = CasingEnum.CAMEL_CASE;
  private BASE_URL = 'https://www.firetext.co.uk/api/sendsms';

  constructor(
    private config: {
      apiKey?: string;
      from?: string;
    }
  ) {
    super();
  }

  private parseResponse(body: string) {
    const re = /^(\d+):(\d+)\s(.*)$/i;
    const found = body.match(re);
    const code = found?.[1] ?? 'Unknown status code';
    const message = found?.[3] ?? 'Unknown status message';

    return [code, message];
  }

  private parseHeaderId(headers: Headers) {
    return headers.get('X-Message');
  }

  private parseHeaderDate(headers: Headers): string {
    const date = headers.get('Date');

    return date ? new Date(date).toISOString() : new Date().toISOString();
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const baseMessage = this.transform<Record<string, string>>(bridgeProviderData, {
      apiKey: this.config.apiKey,
      to: options.to,
      from: options.from || this.config.from,
      message: options.content,
    });

    const urlSearchParams = new URLSearchParams(baseMessage.body);
    const url = new URL(this.BASE_URL);
    url.search = urlSearchParams.toString();

    const response = await fetch(url.toString());
    const body = await response.text();
    const [code, message] = this.parseResponse(body);

    if (code !== '0') {
      throw new Error(`${code}: ${message}`);
    }

    const messageId = this.parseHeaderId(response.headers);
    const date = this.parseHeaderDate(response.headers);

    return {
      id: messageId,
      date,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class FiretextSmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/forty-six-elks/forty-six-elks.provider.spec.ts
Tamaño: 1771 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, test } from 'vitest';
import { axiosSpy } from '../../../utils/test/spy-axios';
import { FortySixElksSmsProvider } from './forty-six-elks.provider';

test('should trigger 46elks api correctly', async () => {
  const { mockPost: spy } = axiosSpy({
    data: {
      id: 'test_id',
      created: new Date().toISOString(),
    },
  });

  const to = '+467777777777';
  const from = 'Company';
  const content = 'Test';

  const provider = new FortySixElksSmsProvider({
    user: 'test_account',
    password: '123456',
    from,
  });

  const response = await provider.sendMessage({
    to,
    from,
    content,
  });

  expect(response?.id).toEqual('test_id');
  expect(spy).toHaveBeenCalledWith(
    'https://api.46elks.com/a1/sms',
    `from=${from}&to=${to.replace('+', '%2B')}&message=${content}`,
    { headers: { Authorization: 'Basic dGVzdF9hY2NvdW50OjEyMzQ1Ng==' } }
  );
});

test('should trigger 46elks api correctly', async () => {
  const { mockPost: spy } = axiosSpy({
    data: {
      id: 'test_id',
      created: new Date().toISOString(),
    },
  });

  const to = '+467777777777';
  const from = 'Company';
  const content = 'Test';

  const provider = new FortySixElksSmsProvider({
    user: 'test_account',
    password: '123456',
    from,
  });

  const response = await provider.sendMessage(
    {
      to,
      from,
      content,
    },
    {
      _passthrough: {
        body: {
          to: '+767777777777',
        },
      },
    }
  );

  expect(response?.id).toEqual('test_id');
  expect(spy).toHaveBeenCalledWith(
    'https://api.46elks.com/a1/sms',
    `from=${from}&to=${'+767777777777'.replace('+', '%2B')}&message=${content}`,
    { headers: { Authorization: 'Basic dGVzdF9hY2NvdW50OjEyMzQ1Ng==' } }
  );
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

No se detectaron funciones/exportaciones con heurística JS/TS.

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/forty-six-elks/forty-six-elks.provider.ts
Tamaño: 1783 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SmsProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, ISendMessageSuccessResponse, ISmsOptions, ISmsProvider } from '@novu/stateless';
import axios from 'axios';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

interface IFortySixElksSuccessObject {
  status: string;
  direction: string;
  from: string;
  created: string;
  parts: number;
  to: string;
  cost: number;
  message: string;
  id: string;
}

interface IFortySixElksRequestResponse {
  data: IFortySixElksSuccessObject;
}

export class FortySixElksSmsProvider extends BaseProvider implements ISmsProvider {
  id = SmsProviderIdEnum.FortySixElks;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;
  protected casing = CasingEnum.SNAKE_CASE;

  constructor(
    private config: {
      user?: string;
      password?: string;
      from?: string;
    }
  ) {
    super();
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const authKey = Buffer.from(`${this.config.user}:${this.config.password}`).toString('base64');

    const transformedData = this.transform<Record<string, string>>(bridgeProviderData, {
      from: options.from || this.config.from,
      to: options.to,
      message: options.content,
    });

    const data = new URLSearchParams(transformedData.body).toString();

    const res: IFortySixElksRequestResponse = await axios.create().post('https://api.46elks.com/a1/sms', data, {
      headers: {
        Authorization: `Basic ${authKey}`,
        ...transformedData.headers,
      },
    });

    return {
      id: res.data.id,
      date: res.data.created,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class FortySixElksSmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/generic-sms/generic-sms.provider.spec.ts
Tamaño: 1955 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import crypto from 'crypto';
import { expect, test } from 'vitest';
import { axiosSpy } from '../../../utils/test/spy-axios';
import { GenericSmsProvider } from './generic-sms.provider';

test('should trigger generic-sms library correctly', async () => {
  const { mockRequest: spy } = axiosSpy({
    data: {
      message: {
        id: crypto.randomUUID(),
        date: new Date().toISOString(),
      },
    },
  });

  const provider = new GenericSmsProvider({
    baseUrl: 'https://api.generic-sms-provider.com',
    apiKeyRequestHeader: 'apiKey',
    apiKey: '123456',
    from: 'sender-id',
    idPath: 'message.id',
    datePath: 'message.date',
  });

  await provider.sendMessage({
    to: '+1234567890',
    content: 'SMS Content form Generic SMS Provider',
  });

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    method: 'POST',
    data: {
      to: '+1234567890',
      content: 'SMS Content form Generic SMS Provider',
      sender: 'sender-id',
    },
  });
});

test('should trigger generic-sms library correctly with _passthrough', async () => {
  const { mockRequest: spy } = axiosSpy({
    data: {
      message: {
        id: crypto.randomUUID(),
        date: new Date().toISOString(),
      },
    },
  });

  const provider = new GenericSmsProvider({
    baseUrl: 'https://api.generic-sms-provider.com',
    apiKeyRequestHeader: 'apiKey',
    apiKey: '123456',
    from: 'sender-id',
    idPath: 'message.id',
    datePath: 'message.date',
  });

  await provider.sendMessage(
    {
      to: '+1234567890',
      content: 'SMS Content form Generic SMS Provider',
    },
    {
      _passthrough: {
        body: {
          to: '+2234567890',
        },
      },
    }
  );

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    method: 'POST',
    data: {
      to: '+2234567890',
      content: 'SMS Content form Generic SMS Provider',
      sender: 'sender-id',
    },
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - provider(new GenericSmsProvider({
    baseUrl: 'https://api.generic-sms-provider.com',
    apiKeyRequestHeade...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/generic-sms/generic-sms.provider.ts
Tamaño: 2712 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SmsProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, ISendMessageSuccessResponse, ISmsOptions, ISmsProvider } from '@novu/stateless';

import axios, { AxiosInstance } from 'axios';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class GenericSmsProvider extends BaseProvider implements ISmsProvider {
  id = SmsProviderIdEnum.GenericSms;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;
  protected casing = CasingEnum.CAMEL_CASE;
  axiosInstance: AxiosInstance;
  headers: Record<string, string>;

  constructor(
    private config: {
      baseUrl: string;
      apiKeyRequestHeader: string;
      apiKey: string;
      secretKeyRequestHeader?: string;
      secretKey?: string;
      from: string;
      idPath?: string;
      datePath?: string;
      authenticateByToken?: boolean;
      domain?: string;
      authenticationTokenKey?: string;
    }
  ) {
    super();
    this.headers = {
      [this.config?.apiKeyRequestHeader]: config.apiKey,
    };

    if (this.config?.secretKeyRequestHeader && this.config?.secretKey) {
      this.headers[this.config?.secretKeyRequestHeader] = config.secretKey;
    }

    if (!this.config?.authenticateByToken) {
      this.axiosInstance = axios.create({
        baseURL: config.baseUrl,
        headers: this.headers,
      });
    }
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const data = this.transform(bridgeProviderData, {
      ...options,
      sender: options.from || this.config.from,
    });
    if (this.config?.authenticateByToken) {
      const tokenAxiosInstance = await axios.request({
        method: 'POST',
        baseURL: this.config.domain,
        headers: this.headers,
      });

      const token = tokenAxiosInstance.data.data[this.config.authenticationTokenKey];

      this.axiosInstance = axios.create({
        baseURL: this.config.baseUrl,
        headers: {
          [this.config.authenticationTokenKey]: token,
          ...data.headers,
        },
      });
    }

    const response = await this.axiosInstance.request({
      method: 'POST',
      data: data.body,
    });

    const responseData = response.data;

    return {
      id: this.getResponseValue(this.config.idPath || 'id', responseData),
      date: this.getResponseValue(this.config.datePath || 'date', responseData) || new Date().toISOString(),
    };
  }

  private getResponseValue(path: string, data: any) {
    const pathArray = path.split('.');

    return pathArray.reduce((acc, curr) => acc[curr], data);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - pathArray(path.split('.');

    return pathArray.reduce((acc, curr))
Declaraciones 'export' encontradas:
- export class GenericSmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/gupshup/gupshup.provider.spec.ts
Tamaño: 1792 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, test } from 'vitest';
import { axiosSpy } from '../../../utils/test/spy-axios';
import { GupshupSmsProvider } from './gupshup.provider';

test('should trigger gupshup library correctly', async () => {
  const { mockPost: spy } = axiosSpy({
    data: `success | sent | ${Math.ceil(Math.random() * 100)}`,
  });

  const provider = new GupshupSmsProvider({
    userId: '1',
    password: 'password',
  });

  await provider.sendMessage({
    content: 'Your otp code is 32901',
    from: 'GupshupTest',
    to: '+2347063317344',
  });

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith('https://enterprise.smsgupshup.com/GatewayAPI/rest', {
    auth_scheme: 'plain',
    format: 'text',
    method: 'sendMessage',
    msg: 'Your otp code is 32901',
    msg_type: 'text',
    password: 'password',
    send_to: '+2347063317344',
    userid: '1',
    v: '1.1',
  });
});

test('should trigger gupshup library correctly with _passthrough', async () => {
  const { mockPost: spy } = axiosSpy({
    data: `success | sent | ${Math.ceil(Math.random() * 100)}`,
  });

  const provider = new GupshupSmsProvider({
    userId: '1',
    password: 'password',
  });

  await provider.sendMessage(
    {
      content: 'Your otp code is 32901',
      from: 'GupshupTest',
      to: '+2347063317344',
    },
    {
      _passthrough: {
        body: {
          send_to: '+3347063317344',
        },
      },
    }
  );

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith('https://enterprise.smsgupshup.com/GatewayAPI/rest', {
    auth_scheme: 'plain',
    format: 'text',
    method: 'sendMessage',
    msg: 'Your otp code is 32901',
    msg_type: 'text',
    password: 'password',
    send_to: '+3347063317344',
    userid: '1',
    v: '1.1',
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - provider(new GupshupSmsProvider({
    userId: '1',
    password: 'password',
  });

  await provider.sendMess...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/gupshup/gupshup.provider.ts
Tamaño: 1778 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SmsProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, ISendMessageSuccessResponse, ISmsOptions, ISmsProvider } from '@novu/stateless';
import axios from 'axios';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class GupshupSmsProvider extends BaseProvider implements ISmsProvider {
  id = SmsProviderIdEnum.Gupshup;
  protected casing = CasingEnum.SNAKE_CASE;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;
  public static BASE_URL = 'https://enterprise.smsgupshup.com/GatewayAPI/rest';

  constructor(
    private config: {
      userId?: string;
      password?: string;
    }
  ) {
    super();
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const params = this.transform(bridgeProviderData, {
      send_to: options.to,
      msg: options.content,
      msg_type: 'text',
      auth_scheme: 'plain',
      method: 'sendMessage',
      format: 'text',
      v: '1.1',
      userid: this.config.userId,
      password: this.config.password,
      ...(options.customData?.principalEntityId && {
        principalEntityId: options.customData?.principalEntityId,
      }),
      ...(options.customData?.dltTemplateId && {
        dltTemplateId: options.customData?.dltTemplateId,
      }),
    }).body;

    const response = await axios.create().post(GupshupSmsProvider.BASE_URL, params);

    const body = response.data;
    const result = body.split(' | ');

    if (result[0] === 'error') {
      throw new Error(`${result[1]} ${result[2]}`);
    }

    return {
      id: result[2],
      date: new Date().toISOString(),
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GupshupSmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/imedia/imedia.provider.ts
Tamaño: 3843 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SmsProviderIdEnum } from '@novu/shared';
import {
  ChannelTypeEnum,
  type ISendMessageSuccessResponse,
  type ISMSEventBody,
  type ISmsOptions,
  type ISmsProvider,
  SmsEventStatusEnum,
} from '@novu/stateless';
import axios, { type AxiosInstance } from 'axios';

import { BaseProvider, CasingEnum } from '../../../base.provider';
import type { WithPassthrough } from '../../../utils/types';

interface IMediaSmsConfig {
  token: string;
  from?: string;
}

interface IMediaSendRequest {
  to: string;
  from: string;
  message: string;
  scheduled?: string;
  requestId?: string;
  useUnicode: number;
  type: number;
  telco?: string;
  priority?: number;
  isEncrypt?: number;
  ext?: Record<string, unknown>;
}

interface IMediaSendResponse {
  sendMessage: IMediaSendRequest;
  msgLength: number;
  mtCount: number;
  account: string;
  errorCode: string;
  errorMessage: string;
  referentId: string;
}

export class IMediaSmsProvider extends BaseProvider implements ISmsProvider {
  id = SmsProviderIdEnum.IMedia;
  protected casing = CasingEnum.CAMEL_CASE;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;
  private axiosInstance: AxiosInstance;
  private static readonly BASE_URL = 'https://api.mobilebranding.vn';

  constructor(private config: IMediaSmsConfig) {
    super();

    this.axiosInstance = axios.create({
      baseURL: IMediaSmsProvider.BASE_URL,
      headers: {
        'Content-Type': 'application/json',
        token: this.config.token,
      },
    });
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const payload = this.transform(bridgeProviderData, {
      to: options.to,
      from: options.from || this.config.from,
      message: options.content,
      scheduled: '',
      requestId: options.id || '',
      useUnicode: 1,
      type: 1,
    }).body;

    const response = await this.axiosInstance.request<IMediaSendResponse>({
      url: '/api/SMSBrandname/SendSMS',
      data: JSON.stringify(payload),
      method: 'POST',
    });

    if (response.data.errorCode !== '000') {
      throw new Error(`iMedia API error: ${response.data.errorCode} - ${response.data.errorMessage}`);
    }

    return {
      id: response.data.referentId,
      date: new Date().toISOString(),
    };
  }

  getMessageId(body: any | any[]): string[] {
    if (Array.isArray(body)) {
      return body.map((item) => item.referentId || item.MessageSid);
    }

    return [body.referentId || body.MessageSid];
  }

  parseEventBody(body: any | any[], identifier: string): ISMSEventBody | undefined {
    if (Array.isArray(body)) {
      body = body.find((item) => (item.referentId || item.MessageSid) === identifier);
    }

    if (!body) {
      return undefined;
    }

    const status = this.getStatus(body.status || body.MessageStatus);

    if (status === undefined) {
      return undefined;
    }

    return {
      status,
      date: new Date().toISOString(),
      externalId: body.referentId || body.MessageSid,
      attempts: body.attempt ? parseInt(body.attempt, 10) : 1,
      response: body.response ? body.response : '',
      row: body,
    };
  }

  private getStatus(event: string): SmsEventStatusEnum | undefined {
    switch (event?.toLowerCase()) {
      case 'accepted':
      case 'queued':
        return SmsEventStatusEnum.QUEUED;
      case 'sending':
        return SmsEventStatusEnum.SENDING;
      case 'sent':
        return SmsEventStatusEnum.SENT;
      case 'failed':
      case 'error':
        return SmsEventStatusEnum.FAILED;
      case 'delivered':
        return SmsEventStatusEnum.DELIVERED;
      case 'undelivered':
        return SmsEventStatusEnum.UNDELIVERED;
      default:
        return SmsEventStatusEnum.SENT;
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - body(body.find((item))
Declaraciones 'export' encontradas:
- export class IMediaSmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/imedia/index.ts
Tamaño: 35 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './imedia.provider';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/infobip/infobip.provider.spec.ts
Tamaño: 1782 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, test, vi } from 'vitest';
import { InfobipSmsProvider } from './infobip.provider';

test('should trigger infobip library correctly - SMS', async () => {
  const provider = new InfobipSmsProvider({
    baseUrl: 'localhost',
    apiKey: '<infobip-auth-token>',
  });

  const spy = vi.spyOn((provider as any).infobipClient.channels.sms, 'send').mockImplementation(async () => {
    return {
      data: {
        messages: [
          {
            messageId: '<a-valid-message-id>',
          },
        ],
      },
    };
  });

  await provider.sendMessage({
    to: '44123456',
    content: 'Hello World',
  });

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    messages: [
      {
        destinations: [
          {
            to: '44123456',
          },
        ],
        text: 'Hello World',
      },
    ],
  });
});

test('should trigger infobip library correctly - SMS', async () => {
  const provider = new InfobipSmsProvider({
    baseUrl: 'localhost',
    apiKey: '<infobip-auth-token>',
  });

  const spy = vi.spyOn((provider as any).infobipClient.channels.sms, 'send').mockImplementation(async () => {
    return {
      data: {
        messages: [
          {
            messageId: '<a-valid-message-id>',
          },
        ],
      },
    };
  });

  await provider.sendMessage(
    {
      to: '44123456',
      content: 'Hello World',
    },
    {
      _passthrough: {
        body: {
          text: 'Hello World _passthrough',
        },
      },
    }
  );

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    messages: [
      {
        destinations: [
          {
            to: '44123456',
          },
        ],
        text: 'Hello World _passthrough',
      },
    ],
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - spy(vi.spyOn((provider as any).infobipClient.channels.sms, 'send').mockImplementation(async ())
 - spy(vi.spyOn((provider as any).infobipClient.channels.sms, 'send').mockImplementation(async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/infobip/infobip.provider.ts
Tamaño: 1525 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { AuthType, Infobip } from '@infobip-api/sdk';
import { SmsProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, ISendMessageSuccessResponse, ISmsOptions, ISmsProvider } from '@novu/stateless';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class InfobipSmsProvider extends BaseProvider implements ISmsProvider {
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;
  id = SmsProviderIdEnum.Infobip;
  protected casing = CasingEnum.CAMEL_CASE;

  private infobipClient;

  constructor(
    private config: {
      baseUrl?: string;
      apiKey?: string;
      from?: string;
    }
  ) {
    super();
    this.infobipClient = new Infobip({
      baseUrl: this.config.baseUrl,
      apiKey: this.config.apiKey,
      authType: AuthType.ApiKey,
    });
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const infobipResponse = await this.infobipClient.channels.sms.send({
      messages: [
        this.transform(bridgeProviderData, {
          text: options.content,
          destinations: [
            {
              to: options.to,
            },
          ],
          from: options.from || this.config.from,
        }).body,
      ],
    });
    const { messageId } = infobipResponse.data.messages.pop();

    return {
      id: messageId,
      date: new Date().toISOString(),
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class InfobipSmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/isend-sms/isend-sms.provider.spec.ts
Tamaño: 1429 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, test } from 'vitest';
import { axiosSpy } from '../../../utils/test/spy-axios';
import { ISendSmsProvider } from './isend-sms.provider';

const mockConfig = {
  apiToken: 'test-key',
};

const mockBulkSMSMessage = {
  to: '2348055372961',
  content: 'sms content',
  from: '45483533',
};

test('should trigger isend-sms library correctly', async () => {
  const { mockPost: spy } = axiosSpy({
    data: {
      status: 'success',
      data: {
        uid: '67890-90q8',
      },
    },
  });
  const smsProvider = new ISendSmsProvider(mockConfig);

  await smsProvider.sendMessage(mockBulkSMSMessage);
  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith(
    '/api/v3/sms/send',
    '{"sender_id":"45483533","recipient":"2348055372961","type":"unicode","message":"sms content"}'
  );
});

test('should trigger isend-sms library correctly', async () => {
  const { mockPost: spy } = axiosSpy({
    data: {
      status: 'success',
      data: {
        uid: '67890-90q8',
      },
    },
  });
  const smsProvider = new ISendSmsProvider(mockConfig);

  await smsProvider.sendMessage(mockBulkSMSMessage, {
    _passthrough: {
      body: {
        sender_id: '55483533',
      },
    },
  });
  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith(
    '/api/v3/sms/send',
    '{"sender_id":"55483533","recipient":"2348055372961","type":"unicode","message":"sms content"}'
  );
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - mockBulkSMSMessage({
  to: '2348055372961',
  content: 'sms content',
  from: '45483533',
};

test('should trigger isen...)
 - smsProvider(new ISendSmsProvider(mockConfig);

  await smsProvider.sendMessage(mockBulkSMSMessage);
  expect(spy...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/isend-sms/isend-sms.provider.ts
Tamaño: 2352 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SmsProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, ISendMessageSuccessResponse, ISmsOptions, ISmsProvider } from '@novu/stateless';
import axios, { AxiosInstance } from 'axios';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export interface ISendSmsData {
  user_id: number;
  to: string;
  message: string;
  sms_type: 'unicode' | 'plain';
  status: string;
  sms_count: number;
  cost: number;
  sending_server_id: number;
  from: string;
  api_key: string;
  send_by: string;
  uid: string;
  updated_at: string;
  created_at: string;
  id: number;
}

export interface ISendSmsResponse {
  status: 'success' | 'error';
  message: string;
  data?: ISendSmsData;
}

export class ISendSmsProvider extends BaseProvider implements ISmsProvider {
  id = SmsProviderIdEnum.ISendSms;
  protected casing = CasingEnum.SNAKE_CASE;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;

  protected Instance: AxiosInstance;

  constructor(
    private config: {
      apiToken: string;
      from?: string;
      contentType?: ISendSmsData['sms_type'];
    }
  ) {
    super();
    this.Instance = axios.create({
      baseURL: 'https://send.com.ly',
      headers: {
        Accept: 'application/json',
        'Content-Type': 'application/json',
        Authorization: `Bearer ${this.config.apiToken}`,
      },
    });
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const payload = this.transform(bridgeProviderData, {
      sender_id: options.from ?? this.config.from,
      recipient: options.to.replace(/^\+|^00/, ''),
      type: this.config.contentType ?? 'unicode',
      message: options.content,
    }).body;

    const response = await this.Instance.post<ISendSmsResponse>('/api/v3/sms/send', JSON.stringify(payload));

    if (['success', 'error'].includes(response.data.status)) {
      if (response.data.status === 'success')
        return {
          id: response.data.data.uid,
          date: new Date().toISOString(),
        };
      else throw new Error(response.data.message ?? 'Unexpected response while sending the SMS!');
    } else throw new Error('Something went wrong while sending the SMS!');
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  interface
- export  interface
- export class ISendSmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/kannel/kannel.provider.spec.ts
Tamaño: 1645 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, test } from 'vitest';
import { axiosSpy } from '../../../utils/test/spy-axios';
import { KannelSmsProvider } from './kannel.provider';

test('should trigger Kannel SMS axios request correctly', async () => {
  const { mockGet: fakeGet } = axiosSpy({
    data: '0: Accepted for delivery',
  });

  const provider = new KannelSmsProvider({
    host: '0.0.0.0',
    port: '13000',
    from: '0000',
  });

  const testTo = '+7777';
  const testContent = 'This is a test';

  const testQueryParams = {
    from: '0000',
    text: testContent,
    to: testTo,
  };

  await provider.sendMessage({
    content: testContent,
    to: testTo,
  });

  expect(fakeGet).toHaveBeenCalled();
  expect(fakeGet).toHaveBeenCalledWith('http://0.0.0.0:13000/cgi-bin/sendsms', {
    params: testQueryParams,
  });
});

test('should trigger Kannel SMS axios request correctly with _passthrough', async () => {
  const { mockGet: fakeGet } = axiosSpy({
    data: '0: Accepted for delivery',
  });

  const provider = new KannelSmsProvider({
    host: '0.0.0.0',
    port: '13000',
    from: '0000',
  });

  const testTo = '+7777';
  const testContent = 'This is a test';

  const testQueryParams = {
    from: '0000',
    text: testContent,
    to: testTo,
  };

  await provider.sendMessage(
    {
      content: testContent,
      to: testTo,
    },
    {
      _passthrough: {
        body: {
          from: '1000',
        },
      },
    }
  );

  expect(fakeGet).toHaveBeenCalled();
  expect(fakeGet).toHaveBeenCalledWith('http://0.0.0.0:13000/cgi-bin/sendsms', {
    params: {
      ...testQueryParams,
      from: '1000',
    },
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - testQueryParams({
    from: '0000',
    text: testContent,
    to: testTo,
  };

  await provider.sendMessage({
    ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/kannel/kannel.provider.ts
Tamaño: 1430 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SmsProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, ISendMessageSuccessResponse, ISmsOptions, ISmsProvider } from '@novu/stateless';
import axios from 'axios';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class KannelSmsProvider extends BaseProvider implements ISmsProvider {
  id = SmsProviderIdEnum.Kannel;
  apiBaseUrl: string;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;
  protected casing = CasingEnum.SNAKE_CASE;

  constructor(
    private config: {
      host: string;
      port: string;
      from: string;
      username?: string;
      password?: string;
    }
  ) {
    super();
    this.apiBaseUrl = `http://${config.host}:${config.port}/cgi-bin`;
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const url = `${this.apiBaseUrl}/sendsms`;
    const queryParameters = this.transform(bridgeProviderData, {
      username: this.config.username,
      password: this.config.password,
      from: options.from || this.config.from,
      to: options.to,
      text: options.content,
    }).body;

    const result = await axios.create().get(url, {
      params: queryParameters,
    });

    return {
      id: options.id,
      date: new Date().toDateString(),
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class KannelSmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/maqsam/maqsam.provider.spec.ts
Tamaño: 1636 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, test } from 'vitest';
import { axiosSpy } from '../../../utils/test/spy-axios';
import { MaqsamSmsProvider } from './maqsam.provider';

test('should trigger Maqsam correctly', async () => {
  const { mockRequest: spy } = axiosSpy({
    data: {
      message: {
        identifier: '23937e6e6ea74726b659aba17d4d73aa',
        timestamp: 1679313103,
      },
    },
  });
  const provider = new MaqsamSmsProvider({
    accessKeyId: '<maqsam-access-key-id>',
    accessSecret: '<maqsam-access-secret>',
    from: 'sender-id',
  });

  await provider.sendMessage({
    to: '+176543',
    content: 'SMS Content',
  });

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    method: 'POST',
    data: {
      to: '+176543',
      message: 'SMS Content',
      sender: 'sender-id',
    },
  });
});

test('should trigger Maqsam correctly with _passthrough', async () => {
  const { mockRequest: spy } = axiosSpy({
    data: {
      message: {
        identifier: '23937e6e6ea74726b659aba17d4d73aa',
        timestamp: 1679313103,
      },
    },
  });
  const provider = new MaqsamSmsProvider({
    accessKeyId: '<maqsam-access-key-id>',
    accessSecret: '<maqsam-access-secret>',
    from: 'sender-id',
  });

  await provider.sendMessage(
    {
      to: '+176543',
      content: 'SMS Content',
    },
    {
      _passthrough: {
        body: {
          to: '+276543',
        },
      },
    }
  );

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    method: 'POST',
    data: {
      to: '+276543',
      message: 'SMS Content',
      sender: 'sender-id',
    },
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - provider(new MaqsamSmsProvider({
    accessKeyId: '<maqsam-access-key-id>',
    accessSecret: '<maqsam-access...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/maqsam/maqsam.provider.ts
Tamaño: 1547 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SmsProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, ISendMessageSuccessResponse, ISmsOptions, ISmsProvider } from '@novu/stateless';

import axios, { AxiosInstance } from 'axios';
import { fromUnixTime } from 'date-fns';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class MaqsamSmsProvider extends BaseProvider implements ISmsProvider {
  id = SmsProviderIdEnum.Maqsam;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;
  protected casing = CasingEnum.CAMEL_CASE;
  private axiosInstance: AxiosInstance;

  constructor(
    private config: {
      accessKeyId?: string;
      accessSecret?: string;
      from?: string;
    }
  ) {
    super();
    this.axiosInstance = axios.create({
      baseURL: 'https://api.maqsam.com/v2/sms',
      auth: {
        username: config.accessKeyId,
        password: config.accessSecret,
      },
    });
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const maqsamResponse = await this.axiosInstance.request({
      method: 'POST',
      data: this.transform(bridgeProviderData, {
        to: options.to,
        message: options.content,
        sender: options.from || this.config.from,
      }).body,
    });

    return {
      id: maqsamResponse.data.message.identifier,
      date: fromUnixTime(maqsamResponse.data.message.timestamp).toISOString(),
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class MaqsamSmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/messagebird/messagebird.provider.spec.ts
Tamaño: 1786 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, test, vi } from 'vitest';
import { MessageBirdSmsProvider } from './messagebird.provider';

test('should trigger MessageBird correctly', async () => {
  const provider = new MessageBirdSmsProvider({
    access_key: 'your-access-key',
  });

  const mockResponse = {
    id: 'messagebird-message-id',
    date: new Date(),
  };

  const spy = vi
    .spyOn((provider as any).messageBirdClient.messages, 'create')
    .mockImplementation(async (params, callback) => {
      (callback as any)(null, mockResponse);
    });

  const testOptions = {
    from: '+123456',
    to: '+176543',
    content: 'Test SMS Content',
  };

  await provider.sendMessage(testOptions);

  expect(spy).toHaveBeenCalled();

  expect(spy).toHaveBeenCalledWith(
    {
      originator: '+123456',
      recipients: ['+176543'],
      body: 'Test SMS Content',
    },
    expect.any(Function)
  );
});

test('should trigger MessageBird correctly with _passthrough', async () => {
  const provider = new MessageBirdSmsProvider({
    access_key: 'your-access-key',
  });

  const mockResponse = {
    id: 'messagebird-message-id',
    date: new Date(),
  };

  const spy = vi
    .spyOn((provider as any).messageBirdClient.messages, 'create')
    .mockImplementation(async (params, callback) => {
      (callback as any)(null, mockResponse);
    });

  const testOptions = {
    from: '+123456',
    to: '+176543',
    content: 'Test SMS Content',
  };

  await provider.sendMessage(testOptions, {
    _passthrough: {
      body: {
        originator: '+223456',
      },
    },
  });

  expect(spy).toHaveBeenCalled();

  expect(spy).toHaveBeenCalledWith(
    {
      originator: '+223456',
      recipients: ['+176543'],
      body: 'Test SMS Content',
    },
    expect.any(Function)
  );
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - spy(vi
    .spyOn((provider as any).messageBirdClient.messages, 'create')
    .mockImplementation(async ...)
 - testOptions({
    from: '+123456',
    to: '+176543',
    content: 'Test SMS Content',
  };

  await provider.se...)
 - spy(vi
    .spyOn((provider as any).messageBirdClient.messages, 'create')
    .mockImplementation(async ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/messagebird/messagebird.provider.ts
Tamaño: 1517 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SmsProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, ISendMessageSuccessResponse, ISmsOptions, ISmsProvider } from '@novu/stateless';
import { initClient } from 'messagebird';
import { Message, MessageParameters } from 'messagebird/types/messages';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class MessageBirdSmsProvider extends BaseProvider implements ISmsProvider {
  id = SmsProviderIdEnum.MessageBird;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;
  protected casing = CasingEnum.CAMEL_CASE;
  private messageBirdClient: ReturnType<typeof initClient>;
  constructor(
    private config: {
      access_key?: string;
    }
  ) {
    super();
    this.messageBirdClient = initClient(config.access_key);
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const params = this.transform<MessageParameters>(bridgeProviderData, {
      originator: options.from,
      recipients: [options.to],
      body: options.content,
    }).body;

    const response = await new Promise<Message>((resolve, reject) => {
      this.messageBirdClient.messages.create(params, (err, res) => {
        if (err) {
          reject(err);
        } else {
          resolve(res);
        }
      });
    });

    return {
      id: response.id,
      date: response.createdDatetime,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - response(await new Promise<Message>((resolve, reject))
Declaraciones 'export' encontradas:
- export class MessageBirdSmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/mobishastra/mobishastra.provider.spec.ts
Tamaño: 1976 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, test } from 'vitest';
import { axiosSpy } from '../../../utils/test/spy-axios';
import { MobishastraProvider } from './mobishastra.provider';

const baseUrl = 'https://mshastra.com/sendsms_api_json.aspx';
const senderName = 'sender-name';
const testMobileNumber = '+123456789';
const smsMessageContent = 'SMS Content form Mobishastra SMS Provider';
const username = 'profile-username';
const password = 'profile-password';

const providerOptions = {
  baseUrl,
  from: senderName,
  username,
  password,
};

const options = {
  to: testMobileNumber,
  from: senderName,
  content: smsMessageContent,
};

test('should trigger Mobishastra library correctly', async () => {
  const { mockRequest: spy } = axiosSpy({
    data: [
      {
        msg_id: '123',
        str_response: 'Message Sent',
      },
    ],
  });

  const provider = new MobishastraProvider(providerOptions);

  await provider.sendMessage(options);

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    method: 'POST',
    data: JSON.stringify([
      {
        Sender: senderName,
        number: testMobileNumber,
        msg: smsMessageContent,
        user: username,
        pwd: password,
      },
    ]),
    headers: {},
  });
});

test('should trigger Mobishastra library correctly with _passthrough', async () => {
  const { mockRequest: spy } = axiosSpy({
    data: [
      {
        msg_id: '123',
        str_response: 'Message Sent',
      },
    ],
  });

  const provider = new MobishastraProvider(providerOptions);

  await provider.sendMessage(options, {
    _passthrough: {
      body: {
        number: '+223456789',
      },
    },
  });

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    method: 'POST',
    data: JSON.stringify([
      {
        Sender: senderName,
        number: '+223456789',
        msg: smsMessageContent,
        user: username,
        pwd: password,
      },
    ]),
    headers: {},
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - options({
  to: testMobileNumber,
  from: senderName,
  content: smsMessageContent,
};

test('should trigger...)
 - provider(new MobishastraProvider(providerOptions);

  await provider.sendMessage(options);

  expect(spy).toH...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/mobishastra/mobishastra.provider.ts
Tamaño: 1863 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SmsProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, ISendMessageSuccessResponse, ISmsOptions, ISmsProvider } from '@novu/stateless';
import axios, { AxiosInstance } from 'axios';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class MobishastraProvider extends BaseProvider implements ISmsProvider {
  id = SmsProviderIdEnum.Mobishastra;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;
  protected casing = CasingEnum.CAMEL_CASE;
  axiosInstance: AxiosInstance;
  headers: Record<string, string>;

  constructor(
    private config: {
      baseUrl: string;
      username: string;
      password: string;
      language?: string;
      from: string;
    }
  ) {
    super();
    this.axiosInstance = axios.create({
      baseURL: config.baseUrl,
      headers: {
        'Content-Type': 'application/json',
      },
    });
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const transformedData = this.transform(bridgeProviderData, {
      Sender: options.from || this.config.from,
      number: options.to,
      msg: options.content,
      user: this.config.username,
      pwd: this.config.password,
    });
    const response = await this.axiosInstance.request({
      method: 'POST',
      data: JSON.stringify([transformedData.body]),
      headers: transformedData.headers,
    });

    const responseData = response.data?.[0];
    const messageId = responseData?.msg_id?.trim();

    if (!messageId) {
      const errorMessage = responseData?.str_response || 'Failed to send message';
      throw new Error(errorMessage);
    }

    return {
      id: messageId,
      date: new Date().toISOString(),
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class MobishastraProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/nexmo/nexmo.provider.spec.ts
Tamaño: 2028 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, test, vi } from 'vitest';
import { NexmoSmsProvider } from './nexmo.provider';

test('should trigger nexmo library correctly', async () => {
  const provider = new NexmoSmsProvider({
    apiKey: '<vonage-api-key>',
    apiSecret: '<vonage-api-secret>',
    from: '+112345',
  });

  const spy = vi

    // @ts-expect-error
    .spyOn(provider.vonageClient.sms, 'send')
    .mockImplementation(async () => {
      return {
        'message-count': 1,
        messages: [
          {
            'message-id': '123',
            to: '1',
            'message-price': '1',
            'remaining-balance': '1',
            status: '0' as never,
            'account-ref': '1',
            network: '1',
          },
        ],
      } as any;
    });

  await provider.sendMessage({
    to: '+176543',
    content: 'SMS Content',
  });

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    from: '+112345',
    text: 'SMS Content',
    to: '+176543',
  });
});

test('should trigger nexmo library correctly with _passthrough', async () => {
  const provider = new NexmoSmsProvider({
    apiKey: '<vonage-api-key>',
    apiSecret: '<vonage-api-secret>',
    from: '+112345',
  });

  const spy = vi

    // @ts-expect-error
    .spyOn(provider.vonageClient.sms, 'send')
    .mockImplementation(async () => {
      return {
        'message-count': 1,
        messages: [
          {
            'message-id': '123',
            to: '1',
            'message-price': '1',
            'remaining-balance': '1',
            status: '0' as never,
            'account-ref': '1',
            network: '1',
          },
        ],
      } as any;
    });

  await provider.sendMessage(
    {
      to: '+176543',
      content: 'SMS Content',
    },
    {
      _passthrough: {
        body: {
          from: '+212345',
        },
      },
    }
  );

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    from: '+212345',
    text: 'SMS Content',
    to: '+176543',
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - spy(vi

    // @ts-expect-error
    .spyOn(provider.vonageClient.sms, 'send')
    .mockImplementation(as...)
 - spy(vi

    // @ts-expect-error
    .spyOn(provider.vonageClient.sms, 'send')
    .mockImplementation(as...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/nexmo/nexmo.provider.ts
Tamaño: 1363 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SmsProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, ISendMessageSuccessResponse, ISmsOptions, ISmsProvider } from '@novu/stateless';
import { Auth } from '@vonage/auth';
import { Vonage } from '@vonage/server-sdk';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class NexmoSmsProvider extends BaseProvider implements ISmsProvider {
  id = SmsProviderIdEnum.Nexmo;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;
  private vonageClient: Vonage;
  protected casing = CasingEnum.CAMEL_CASE;

  constructor(
    private config: {
      apiKey: string;
      apiSecret: string;
      from: string;
    }
  ) {
    super();
    this.vonageClient = new Vonage(
      new Auth({
        apiKey: config.apiKey,
        apiSecret: config.apiSecret,
      })
    );
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const response = await this.vonageClient.sms.send(
      this.transform<any>(bridgeProviderData, {
        to: options.to,
        from: this.config.from,
        text: options.content,
      }).body
    );

    return {
      id: response.messages[0]['message-id'],
      date: new Date().toISOString(),
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class NexmoSmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/plivo/plivo.provider.spec.ts
Tamaño: 1576 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { beforeEach, describe, expect, test, vi } from 'vitest';
// Mock the external modules
import { PlivoSmsProvider } from './plivo.provider';

const createMock = vi.fn().mockResolvedValue({ messageUuid: 'mockedUUID' });

vi.mock(import('plivo'), async (importOriginal) => {
  const actual = await importOriginal();

  return {
    ...actual,
    Client: vi.fn().mockImplementation(() => ({
      messages: {
        create: createMock,
      },
    })),
  };
});

describe('PlivoSmsProvider', () => {
  beforeEach(() => {
    createMock.mockClear();
  });

  test('should trigger plivo correctly', async () => {
    const provider = new PlivoSmsProvider({
      accountSid: '<plivo-id>',
      authToken: '<plivo-token>',
      from: '+1145678',
    });

    await provider.sendMessage({
      to: '+187654',
      content: 'Test',
    });

    expect(createMock).toHaveBeenCalled();
    expect(createMock).toHaveBeenCalledWith('+1145678', '+187654', 'Test', undefined, undefined);
  });

  test('should trigger plivo correctly with _passthrough', async () => {
    const provider = new PlivoSmsProvider({
      accountSid: '<plivo-id>',
      authToken: '<plivo-token>',
      from: '+1145678',
    });

    await provider.sendMessage(
      {
        to: '+187654',
        content: 'Test',
      },
      {
        _passthrough: {
          body: {
            dst: '+287654',
          },
        },
      }
    );

    expect(createMock).toHaveBeenCalled();
    expect(createMock).toHaveBeenCalledWith('+1145678', '+287654', 'Test', undefined, undefined);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - createMock(vi.fn().mockResolvedValue({ messageUuid: 'mockedUUID' });

vi.mock(import('plivo'), async (importOri...)
 - actual(await importOriginal();

  return {
    ...actual,
    Client: vi.fn().mockImplementation(())
 - provider(new PlivoSmsProvider({
      accountSid: '<plivo-id>',
      authToken: '<plivo-token>',
      from:...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/plivo/plivo.provider.ts
Tamaño: 2850 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SmsProviderIdEnum } from '@novu/shared';
import {
  ChannelTypeEnum,
  ISendMessageSuccessResponse,
  ISMSEventBody,
  ISmsOptions,
  ISmsProvider,
  SmsEventStatusEnum,
} from '@novu/stateless';

import { Client as PlivoClient } from 'plivo';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class PlivoSmsProvider extends BaseProvider implements ISmsProvider {
  id = SmsProviderIdEnum.Plivo;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;
  protected casing = CasingEnum.CAMEL_CASE;
  private plivoClient: PlivoClient;

  constructor(
    private config: {
      accountSid?: string;
      authToken?: string;
      from?: string;
    }
  ) {
    super();
    this.plivoClient = new PlivoClient(config.accountSid, config.authToken);
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const transformedData = this.transform(bridgeProviderData, {
      src: options.from || this.config.from,
      dst: options.to,
      text: options.content,
    });
    const plivoResponse = await this.plivoClient.messages.create(
      transformedData.body.src,
      transformedData.body.dst,
      transformedData.body.text as string,
      transformedData.body.optionalParams as object,
      transformedData.body.powerpackUUID as string
    );

    return {
      ids: plivoResponse.messageUuid,
      date: new Date().toISOString(),
    };
  }

  getMessageId(body: any | any[]): string[] {
    if (Array.isArray(body)) {
      return body.map((item) => item.messageUuid);
    }

    return [body.messageUuid];
  }

  parseEventBody(body: any | any[], identifier: string): ISMSEventBody | undefined {
    if (Array.isArray(body)) {
      body = body.find((item) => item.messageUuid === identifier);
    }

    if (!body) {
      return undefined;
    }

    const status = this.getStatus(body.status);

    if (status === undefined) {
      return undefined;
    }

    return {
      status,
      date: new Date().toISOString(),
      externalId: body.messageUuid,
      attempts: body.attempt ? parseInt(body.attempt, 10) : 1,
      response: body.response ?? '',
      row: body,
    };
  }

  private getStatus(event: string): SmsEventStatusEnum | undefined {
    switch (event) {
      case 'queued':
        return SmsEventStatusEnum.QUEUED;
      case 'sent':
        return SmsEventStatusEnum.SENT;
      case 'failed':
        return SmsEventStatusEnum.FAILED;
      case 'undelivered':
        return SmsEventStatusEnum.UNDELIVERED;
      case 'delivered':
        return SmsEventStatusEnum.DELIVERED;
      case 'rejected':
        return SmsEventStatusEnum.REJECTED;
      default:
        return undefined;
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - plivoResponse(await this.plivoClient.messages.create(
      transformedData.body.src,
      transformedData.body.d...)
 - body(body.find((item))
Declaraciones 'export' encontradas:
- export class PlivoSmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/ring-central/ring-central.provider.spec.ts
Tamaño: 5594 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, test, vi } from 'vitest';
import { RingCentralSmsProvider } from './ring-central.provider';

test('should trigger ring-central library correctly', async () => {
  const provider = new RingCentralSmsProvider({
    clientId: '<clientId>',
    clientSecret: '<clientSecret>',
    isSandBox: true,
    jwtToken: '<jwtToken>',
    from: '<fromNumber>',
  });

  const spyonLoggedIn = vi

    // @ts-expect-error
    .spyOn(provider.rcClient, 'loggedIn')
    .mockImplementation(async () => {
      return false;
    });

  const spyOnLogin = vi

    // @ts-expect-error
    .spyOn(provider.rcClient, 'login')
    .mockImplementation(async () => {
      return {
        headers: {},
        ok: true,
        redirected: false,
        status: 200,
      } as Response;
    });

  const spyOnPost = vi

    // @ts-expect-error
    .spyOn(provider.rcClient, 'post')
    .mockImplementation(async () => {
      return {
        headers: {},
        ok: true,
        redirected: false,
        status: 200,
        json: async () => {
          return {
            id: '1',
            creationTime: new Date(),
          };
        },
      } as Response;
    });

  await provider.sendMessage({
    to: '+176543',
    content: 'SMS Content',
    from: '+112345',
  });

  expect(spyonLoggedIn).toHaveBeenCalledTimes(1);
  expect(spyOnLogin).toHaveBeenCalledTimes(1);
  expect(spyOnPost).toHaveBeenCalled();
  expect(spyOnPost).toHaveBeenCalledWith('/restapi/v1.0/account/~/extension/~/sms', {
    from: { phoneNumber: '+112345' },
    to: [{ phoneNumber: '+176543' }],
    text: 'SMS Content',
  });
});

test('should not login if already logged in', async () => {
  const provider = new RingCentralSmsProvider({
    clientId: '<clientId>',
    clientSecret: '<clientSecret>',
    isSandBox: true,
    jwtToken: '<jwtToken>',
    from: '+112345',
  });

  const spyonLoggedIn = vi

    // @ts-expect-error
    .spyOn(provider.rcClient, 'loggedIn')
    .mockImplementation(async () => {
      return true;
    });

  const spyOnLogin = vi

    // @ts-expect-error
    .spyOn(provider.rcClient, 'login')
    .mockImplementation(async () => {
      return {
        headers: {},
        ok: true,
        redirected: false,
        status: 200,
      } as Response;
    });

  const spyOnPost = vi

    // @ts-expect-error
    .spyOn(provider.rcClient, 'post')
    .mockImplementation(async () => {
      return {
        headers: {},
        ok: true,
        redirected: false,
        status: 200,
        json: async () => {
          return {
            id: '1',
            creationTime: new Date(),
          };
        },
      } as Response;
    });

  await provider.sendMessage({
    to: '+176543',
    content: 'SMS Content',
  });

  expect(spyonLoggedIn).toHaveBeenCalledTimes(1);
  expect(spyOnLogin).toHaveBeenCalledTimes(0);
  expect(spyOnPost).toHaveBeenCalled();
  expect(spyOnPost).toHaveBeenCalledWith('/restapi/v1.0/account/~/extension/~/sms', {
    from: { phoneNumber: '+112345' },
    to: [{ phoneNumber: '+176543' }],
    text: 'SMS Content',
  });
});

test('should only use config.from if options.from is not provided', async () => {
  const provider = new RingCentralSmsProvider({
    clientId: '<clientId>',
    clientSecret: '<clientSecret>',
    isSandBox: true,
    jwtToken: '<jwtToken>',
    from: '+112345',
  });

  const spyonLoggedIn = vi

    // @ts-expect-error
    .spyOn(provider.rcClient, 'loggedIn')
    .mockImplementation(async () => {
      return true;
    });

  const spyOnPost = vi

    // @ts-expect-error
    .spyOn(provider.rcClient, 'post')
    .mockImplementation(async () => {
      return {
        headers: {},
        ok: true,
        redirected: false,
        status: 200,
        json: async () => {
          return {
            id: '1',
            creationTime: new Date(),
          };
        },
      } as Response;
    });

  await provider.sendMessage({
    to: '+176543',
    content: 'SMS Content',
  });

  expect(spyOnPost).toHaveBeenCalled();
  expect(spyOnPost).toHaveBeenCalledWith('/restapi/v1.0/account/~/extension/~/sms', {
    from: { phoneNumber: '+112345' },
    to: [{ phoneNumber: '+176543' }],
    text: 'SMS Content',
  });
});

test('should trigger ring-central library correctly with _passthrough', async () => {
  const provider = new RingCentralSmsProvider({
    clientId: '<clientId>',
    clientSecret: '<clientSecret>',
    isSandBox: true,
    jwtToken: '<jwtToken>',
    from: '<fromNumber>',
  });

  const spyonLoggedIn = vi

    // @ts-expect-error
    .spyOn(provider.rcClient, 'loggedIn')
    .mockImplementation(async () => {
      return true;
    });

  const spyOnPost = vi

    // @ts-expect-error
    .spyOn(provider.rcClient, 'post')
    .mockImplementation(async () => {
      return {
        headers: {},
        ok: true,
        redirected: false,
        status: 200,
        json: async () => {
          return {
            id: '1',
            creationTime: new Date(),
          };
        },
      } as Response;
    });

  await provider.sendMessage(
    {
      to: '+176543',
      content: 'SMS Content',
      from: '+112345',
    },
    {
      _passthrough: {
        body: {
          text: 'SMS Content _passthrough',
        },
      },
    }
  );

  expect(spyonLoggedIn).toHaveBeenCalledTimes(1);
  expect(spyOnPost).toHaveBeenCalled();
  expect(spyOnPost).toHaveBeenCalledWith('/restapi/v1.0/account/~/extension/~/sms', {
    from: { phoneNumber: '+112345' },
    to: [{ phoneNumber: '+176543' }],
    text: 'SMS Content _passthrough',
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - spyonLoggedIn(vi

    // @ts-expect-error
    .spyOn(provider.rcClient, 'loggedIn')
    .mockImplementation(async ...)
 - spyOnLogin(vi

    // @ts-expect-error
    .spyOn(provider.rcClient, 'login')
    .mockImplementation(async ())
 - spyOnPost(vi

    // @ts-expect-error
    .spyOn(provider.rcClient, 'post')
    .mockImplementation(async ())
 - spyonLoggedIn(vi

    // @ts-expect-error
    .spyOn(provider.rcClient, 'loggedIn')
    .mockImplementation(async ...)
 - spyOnLogin(vi

    // @ts-expect-error
    .spyOn(provider.rcClient, 'login')
    .mockImplementation(async ())
 - spyOnPost(vi

    // @ts-expect-error
    .spyOn(provider.rcClient, 'post')
    .mockImplementation(async ())
 - spyonLoggedIn(vi

    // @ts-expect-error
    .spyOn(provider.rcClient, 'loggedIn')
    .mockImplementation(async ...)
 - spyOnPost(vi

    // @ts-expect-error
    .spyOn(provider.rcClient, 'post')
    .mockImplementation(async ())
 - spyonLoggedIn(vi

    // @ts-expect-error
    .spyOn(provider.rcClient, 'loggedIn')
    .mockImplementation(async ...)
 - spyOnPost(vi

    // @ts-expect-error
    .spyOn(provider.rcClient, 'post')
    .mockImplementation(async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/ring-central/ring-central.provider.ts
Tamaño: 3136 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SmsProviderIdEnum } from '@novu/shared';
import {
  ChannelTypeEnum,
  ISendMessageSuccessResponse,
  ISMSEventBody,
  ISmsOptions,
  ISmsProvider,
  SmsEventStatusEnum,
} from '@novu/stateless';
import { SDK } from '@ringcentral/sdk';
import Platform from '@ringcentral/sdk/lib/platform/Platform';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class RingCentralSmsProvider extends BaseProvider implements ISmsProvider {
  id = SmsProviderIdEnum.RingCentral;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;
  protected casing = CasingEnum.CAMEL_CASE;
  sendSMSEndpoint = '/restapi/v1.0/account/~/extension/~/sms';
  private rcClient: Platform;

  constructor(
    private config: {
      clientId?: string;
      clientSecret?: string;
      isSandBox?: boolean;
      jwtToken?: string;
      from?: string;
    }
  ) {
    super();
    const rcSdk = new SDK({
      server: config.isSandBox ? SDK.server.sandbox : SDK.server.production,
      clientId: config.clientId,
      clientSecret: config.clientSecret,
    });
    this.rcClient = rcSdk.platform();
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const bodyParams = this.transform(bridgeProviderData, {
      from: { phoneNumber: options.from || this.config.from },
      to: [{ phoneNumber: options.to }],
      text: options.content,
    }).body;

    if (!(await this.rcClient.loggedIn())) {
      await this.rcClient.login({ jwt: this.config.jwtToken });
    }

    const resp = await this.rcClient.post(this.sendSMSEndpoint, bodyParams);
    const jsonObj = await resp.json();

    return {
      id: jsonObj.id,
      date: jsonObj.creationTime,
    };
  }

  getMessageId(body: any | any[]): string[] {
    if (Array.isArray(body)) {
      return body.map((item) => item.id);
    }

    return [body.id];
  }

  parseEventBody(body: any | any[], identifier: string): ISMSEventBody | undefined {
    if (Array.isArray(body)) {
      body = body.find((item) => item.id === identifier);
    }

    if (!body) {
      return undefined;
    }

    const status = this.getStatus(body.messageStatus);

    if (status === undefined) {
      return undefined;
    }

    return {
      status,
      date: new Date(body.creationTime).toISOString(),
      externalId: body.id,
      attempts: body.smsSendingAttemptsCount ? parseInt(body.smsSendingAttemptsCount, 10) : 1,
      response: body.subject ? body.subject : '',
      row: body,
    };
  }

  private getStatus(event: string): SmsEventStatusEnum | undefined {
    switch (event) {
      case 'Received':
        return SmsEventStatusEnum.ACCEPTED;
      case 'Queued':
        return SmsEventStatusEnum.QUEUED;
      case 'Sent':
        return SmsEventStatusEnum.SENT;
      case 'DeliveryFailed':
      case 'SendingFailed':
        return SmsEventStatusEnum.FAILED;
      case 'Delivered':
        return SmsEventStatusEnum.DELIVERED;
      default:
        return undefined;
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - jsonObj(await resp.json();

    return {
      id: jsonObj.id,
      date: jsonObj.creationTime,
    };
  }
...)
 - body(body.find((item))
Declaraciones 'export' encontradas:
- export class RingCentralSmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/sendchamp/sendchamp.provider.spec.ts
Tamaño: 1633 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, test } from 'vitest';
import { axiosSpy } from '../../../utils/test/spy-axios';
import { SendchampSmsProvider } from './sendchamp.provider';

const mockConfig = {
  apiKey: 'test-key',
  from: 'sendchamp',
};

const mockNovuMessage = {
  to: '2348055372961',
  content: 'sms content',
};

test('should trigger sendchamp library correctly', async () => {
  const { mockPost: spy } = axiosSpy({
    data: {
      data: {
        business_id: '67890-90q8',
        created_at: new Date().toISOString(),
      },
    },
  });

  const smsProvider = new SendchampSmsProvider(mockConfig);

  await smsProvider.sendMessage(mockNovuMessage);

  expect(spy).toHaveBeenCalled();

  expect(spy).toHaveBeenCalledWith('/sms/send', {
    body: {
      message: 'sms content',
      route: 'international',
      sender_name: 'sendchamp',
      to: '2348055372961',
    },
    headers: {},
    query: {},
  });
});

test('should trigger sendchamp library correctly with _passthrough', async () => {
  const { mockPost: spy } = axiosSpy({
    data: {
      data: {
        business_id: '67890-90q8',
        created_at: new Date().toISOString(),
      },
    },
  });

  const smsProvider = new SendchampSmsProvider(mockConfig);

  await smsProvider.sendMessage(mockNovuMessage, {
    _passthrough: {
      body: {
        to: '3348055372961',
      },
    },
  });

  expect(spy).toHaveBeenCalled();

  expect(spy).toHaveBeenCalledWith('/sms/send', {
    body: {
      message: 'sms content',
      route: 'international',
      sender_name: 'sendchamp',
      to: '3348055372961',
    },
    headers: {},
    query: {},
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - mockNovuMessage({
  to: '2348055372961',
  content: 'sms content',
};

test('should trigger sendchamp library correc...)
 - smsProvider(new SendchampSmsProvider(mockConfig);

  await smsProvider.sendMessage(mockNovuMessage);

  expect(s...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/sendchamp/sendchamp.provider.ts
Tamaño: 1513 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SmsProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, ISendMessageSuccessResponse, ISmsOptions, ISmsProvider } from '@novu/stateless';
import axios, { AxiosInstance } from 'axios';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class SendchampSmsProvider extends BaseProvider implements ISmsProvider {
  id = SmsProviderIdEnum.Sendchamp;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;
  protected casing = CasingEnum.SNAKE_CASE;
  public readonly BASE_URL = 'https://api.sendchamp.com/v1';
  private axiosInstance: AxiosInstance;

  constructor(
    private config: {
      apiKey: string;
      from?: string;
    }
  ) {
    super();
    this.axiosInstance = axios.create({
      baseURL: this.BASE_URL,
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${this.config.apiKey}`,
      },
    });
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const payload = this.transform(bridgeProviderData, {
      sender_name: options.from || this.config.from,
      to: options.to,
      message: options.content,
      route: 'international',
    });

    const response = await this.axiosInstance.post(`/sms/send`, payload);

    return {
      id: response.data.data.business_id,
      date: response.data.data.created_at,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SendchampSmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/simpletexting/simpletexting.provider.spec.ts
Tamaño: 2091 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, test } from 'vitest';
import { axiosSpy } from '../../../utils/test/spy-axios';
import { SimpletextingSmsProvider } from './simpletexting.provider';

test('should trigger SimpletextingSmsProvider library correctly', async () => {
  const { mockPost } = axiosSpy({
    data: {
      id: '12345-67a8',
    },
  });
  const provider = new SimpletextingSmsProvider({
    apiKey: '<YOUR_SIMPLETEXTING_APIKEY>',
    accountPhone: '<SENDER_PHONE>',
  });

  const response = await provider.sendMessage({
    to: '+12345678902',
    content: 'test message',
  });

  expect(mockPost).toHaveBeenCalled();

  expect(mockPost).toHaveBeenCalledWith(
    'https://api-app2.simpletexting.com/v2/api/messages',
    {
      contactPhone: '+12345678902',
      accountPhone: '<SENDER_PHONE>',
      mode: 'SINGLE_SMS_STRICTLY',
      text: 'test message',
    },
    {
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer <YOUR_SIMPLETEXTING_APIKEY>`,
      },
    }
  );

  expect(response).toHaveProperty('id');
});

test('should trigger SimpletextingSmsProvider library correctly with _passthrough', async () => {
  const { mockPost } = axiosSpy({
    data: {
      id: '12345-67a8',
    },
  });
  const provider = new SimpletextingSmsProvider({
    apiKey: '<YOUR_SIMPLETEXTING_APIKEY>',
    accountPhone: '<SENDER_PHONE>',
  });

  const response = await provider.sendMessage(
    {
      to: '+12345678902',
      content: 'test message',
    },
    {
      _passthrough: {
        body: {
          contactPhone: '+22345678902',
        },
      },
    }
  );

  expect(mockPost).toHaveBeenCalled();

  expect(mockPost).toHaveBeenCalledWith(
    'https://api-app2.simpletexting.com/v2/api/messages',
    {
      contactPhone: '+22345678902',
      accountPhone: '<SENDER_PHONE>',
      mode: 'SINGLE_SMS_STRICTLY',
      text: 'test message',
    },
    {
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer <YOUR_SIMPLETEXTING_APIKEY>`,
      },
    }
  );

  expect(response).toHaveProperty('id');
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - response(await provider.sendMessage({
    to: '+12345678902',
    content: 'test message',
  });

  expect(mo...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/simpletexting/simpletexting.provider.ts
Tamaño: 1386 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SmsProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, ISendMessageSuccessResponse, ISmsOptions, ISmsProvider } from '@novu/stateless';

import axios from 'axios';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class SimpletextingSmsProvider extends BaseProvider implements ISmsProvider {
  id = SmsProviderIdEnum.Simpletexting;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;
  protected casing = CasingEnum.CAMEL_CASE;

  constructor(
    private config: {
      apiKey: string;
      accountPhone: string;
    }
  ) {
    super();
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const data = this.transform(bridgeProviderData, {
      contactPhone: options.to,
      accountPhone: this.config.accountPhone,
      mode: 'SINGLE_SMS_STRICTLY',
      text: options.content,
    });
    const response = await axios.create().post('https://api-app2.simpletexting.com/v2/api/messages', data.body, {
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${this.config.apiKey}`,
        ...data.headers,
      },
    });

    return {
      id: response.data.id,
      date: new Date().toISOString(),
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SimpletextingSmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/sinch/sinch.provider.spec.ts
Tamaño: 2701 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import axios from 'axios';
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { SinchSmsProvider } from './sinch.provider';

vi.mock('axios');

describe('SinchSmsProvider', () => {
  const mockConfig = {
    servicePlanId: 'test-service-plan-id',
    apiToken: 'test-api-token',
    from: '+1234567890',
    region: 'eu',
  };

  let provider: SinchSmsProvider;

  beforeEach(() => {
    provider = new SinchSmsProvider(mockConfig);
    vi.clearAllMocks();
  });

  describe('sendMessage', () => {
    it('should send an SMS message successfully', async () => {
      const mockResponse = {
        data: {
          id: 'batch-123',
          created_at: '2023-01-01T00:00:00Z',
        },
      };

      vi.mocked(axios.post).mockResolvedValue(mockResponse);

      const result = await provider.sendMessage({
        to: '+9876543210',
        content: 'Test message',
      });

      expect(axios.post).toHaveBeenCalledWith(
        'https://eu.sms.api.sinch.com/xms/v1/test-service-plan-id/batches',
        {
          from: '+1234567890',
          to: ['+9876543210'],
          body: 'Test message',
        },
        {
          headers: {
            'Content-Type': 'application/json',
            Authorization: 'Bearer test-api-token',
          },
        }
      );

      expect(result).toEqual({
        id: 'batch-123',
        date: '2023-01-01T00:00:00Z',
      });
    });

    it('should use custom from number if provided', async () => {
      const mockResponse = {
        data: {
          id: 'batch-456',
          created_at: '2023-01-02T00:00:00Z',
        },
      };

      vi.mocked(axios.post).mockResolvedValue(mockResponse);

      await provider.sendMessage({
        to: '+9876543210',
        content: 'Test message',
        from: '+1111111111',
      });

      expect(axios.post).toHaveBeenCalledWith(
        expect.any(String),
        expect.objectContaining({
          from: '+1111111111',
        }),
        expect.any(Object)
      );
    });

    it('should use different region if configured', async () => {
      const caProvider = new SinchSmsProvider({
        ...mockConfig,
        region: 'ca',
      });

      const mockResponse = {
        data: {
          id: 'batch-789',
          created_at: '2023-01-03T00:00:00Z',
        },
      };

      vi.mocked(axios.post).mockResolvedValue(mockResponse);

      await caProvider.sendMessage({
        to: '+9876543210',
        content: 'Test message',
      });

      expect(axios.post).toHaveBeenCalledWith(
        'https://ca.sms.api.sinch.com/xms/v1/test-service-plan-id/batches',
        expect.any(Object),
        expect.any(Object)
      );
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - mockConfig({
    servicePlanId: 'test-service-plan-id',
    apiToken: 'test-api-token',
    from: '+1234567890'...)
 - provider(new SinchSmsProvider(mockConfig);
    vi.clearAllMocks();
  });

  describe('sendMessage', ())
 - result(await provider.sendMessage({
        to: '+9876543210',
        content: 'Test message',
      });

...)
 - mockResponse({
        data: {
          id: 'batch-456',
          created_at: '2023-01-02T00:00:00Z',
        }...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/sinch/sinch.provider.ts
Tamaño: 1502 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SmsProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, ISendMessageSuccessResponse, ISmsOptions, ISmsProvider } from '@novu/stateless';

import axios from 'axios';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class SinchSmsProvider extends BaseProvider implements ISmsProvider {
  id = SmsProviderIdEnum.Sinch;
  protected casing = CasingEnum.CAMEL_CASE;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;

  constructor(
    private config: {
      servicePlanId?: string;
      apiToken?: string;
      from?: string;
      region?: string;
    }
  ) {
    super();
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const region = this.config.region || 'eu';
    const url = `https://${region}.sms.api.sinch.com/xms/v1/${this.config.servicePlanId}/batches`;

    const payload = this.transform<Record<string, unknown>>(bridgeProviderData, {
      from: options.from || this.config.from,
      to: [options.to],
      body: options.content,
    }).body;

    const response = await axios.post(url, payload, {
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${this.config.apiToken}`,
      },
    });

    return {
      id: response.data.id,
      date: response.data.created_at || new Date().toISOString(),
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SinchSmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/sms-central/sms-central.provider.spec.ts
Tamaño: 1591 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, test } from 'vitest';
import { axiosSpy } from '../../../utils/test/spy-axios';
import { SmsCentralSmsProvider } from './sms-central.provider';

const mockConfig = {
  username: 'username',
  password: 'password',
  from: '123456789',
  baseUrl: 'http://foo.bar',
};

const mockNovuMessage = {
  to: '987654321',
  content: 'sms content',
};

test('should trigger sms-central library correctly', async () => {
  const { mockPost: fakePost } = axiosSpy({
    data: '0',
  });

  const provider = new SmsCentralSmsProvider(mockConfig);

  await provider.sendMessage(mockNovuMessage);

  const data = {
    ACTION: 'send',
    ORIGINATOR: mockConfig.from,
    USERNAME: mockConfig.username,
    PASSWORD: mockConfig.password,
    RECIPIENT: mockNovuMessage.to,
    MESSAGE_TEXT: mockNovuMessage.content,
  };

  expect(fakePost).toHaveBeenCalled();
  expect(fakePost).toHaveBeenCalledWith(mockConfig.baseUrl, data);
});

test('should trigger sms-central library correctly', async () => {
  const { mockPost: fakePost } = axiosSpy({
    data: '0',
  });

  const provider = new SmsCentralSmsProvider(mockConfig);

  await provider.sendMessage(mockNovuMessage, {
    _passthrough: {
      body: {
        RECIPIENT: '787654321',
      },
    },
  });

  const data = {
    ACTION: 'send',
    ORIGINATOR: mockConfig.from,
    USERNAME: mockConfig.username,
    PASSWORD: mockConfig.password,
    RECIPIENT: '787654321',
    MESSAGE_TEXT: mockNovuMessage.content,
  };

  expect(fakePost).toHaveBeenCalled();
  expect(fakePost).toHaveBeenCalledWith(mockConfig.baseUrl, data);
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - mockNovuMessage({
  to: '987654321',
  content: 'sms content',
};

test('should trigger sms-central library correctl...)
 - data({
    ACTION: 'send',
    ORIGINATOR: mockConfig.from,
    USERNAME: mockConfig.username,
    PASSWO...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/sms-central/sms-central.provider.ts
Tamaño: 1408 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SmsProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, ISendMessageSuccessResponse, ISmsOptions, ISmsProvider } from '@novu/stateless';
import axios from 'axios';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class SmsCentralSmsProvider extends BaseProvider implements ISmsProvider {
  public readonly DEFAULT_BASE_URL = 'https://my.smscentral.com.au/api/v3.2';
  id = SmsProviderIdEnum.SmsCentral;
  protected casing = CasingEnum.CONSTANT_CASE;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;

  constructor(
    private config: {
      username: string;
      password: string;
      from: string;
      baseUrl?: string;
    }
  ) {
    super();
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const data = this.transform(bridgeProviderData, {
      ACTION: 'send',
      ORIGINATOR: options.from || this.config.from,
      USERNAME: this.config.username,
      PASSWORD: this.config.password,
      RECIPIENT: options.to,
      MESSAGE_TEXT: options.content,
    }).body;

    const url = this.config.baseUrl || this.DEFAULT_BASE_URL;
    await axios.create().post(url, data);

    return {
      id: options.id,
      date: new Date().toISOString(),
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SmsCentralSmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/sms77/sms77.provider.spec.ts
Tamaño: 1309 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, test, vi } from 'vitest';
import { Sms77SmsProvider } from './sms77.provider';

test('should trigger sms77 correctly', async () => {
  const provider = new Sms77SmsProvider({
    apiKey: '<sms77-api-key>',
    from: '+1145678',
  });

  const spy = vi.spyOn((provider as any).sms77Client, 'sms').mockImplementation(async () => {
    return {
      messages: [{ id: null }],
    };
  });

  await provider.sendMessage({
    to: '+187654',
    content: 'Test',
  });

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    from: '+1145678',
    json: true,
    text: 'Test',
    to: '+187654',
  });
});

test('should trigger sms77 correctly with _passthrough', async () => {
  const provider = new Sms77SmsProvider({
    apiKey: '<sms77-api-key>',
    from: '+1145678',
  });

  const spy = vi.spyOn((provider as any).sms77Client, 'sms').mockImplementation(async () => {
    return {
      messages: [{ id: null }],
    };
  });

  await provider.sendMessage(
    {
      to: '+187654',
      content: 'Test',
    },
    {
      _passthrough: {
        body: {
          json: false,
        },
      },
    }
  );

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    from: '+1145678',
    json: false,
    text: 'Test',
    to: '+187654',
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - spy(vi.spyOn((provider as any).sms77Client, 'sms').mockImplementation(async ())
 - spy(vi.spyOn((provider as any).sms77Client, 'sms').mockImplementation(async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/sms77/sms77.provider.ts
Tamaño: 1330 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SmsProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, ISendMessageSuccessResponse, ISmsOptions, ISmsProvider } from '@novu/stateless';

import Sms77Client, { SmsJsonResponse, SmsParams } from 'sms77-client';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class Sms77SmsProvider extends BaseProvider implements ISmsProvider {
  id = SmsProviderIdEnum.Sms77;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;
  protected casing = CasingEnum.SNAKE_CASE;
  private sms77Client: Sms77Client;

  constructor(
    private config: {
      apiKey?: string;
      from?: string;
    }
  ) {
    super();
    this.sms77Client = new Sms77Client(config.apiKey, 'Novu');
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const params: SmsParams = this.transform<SmsParams>(bridgeProviderData, {
      from: options.from || this.config.from,
      json: true,
      text: options.content,
      to: options.to,
    }).body;

    const sms77Response = <SmsJsonResponse>await this.sms77Client.sms(params);

    return {
      id: sms77Response.messages[0].id,
      date: new Date().toISOString(),
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class Sms77SmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/smsmode/smsmode.provider.ts
Tamaño: 2598 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SmsProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, ISendMessageSuccessResponse, ISmsOptions, ISmsProvider } from '@novu/stateless';
import axios from 'axios';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export interface ISmsmodeApiResponse {
  [key: string]: unknown;

  messageId: string;
  originMessageId?: string;
  campaignId?: string;
  acceptedAt: string;
  sentDate?: string;
  channel: {
    channelId: string;
    name: string;
    type: 'SMS' | 'WHATSAPP' | 'RCS';
    flow: 'MARKETING' | 'TRANSACTIONAL' | 'OTP';
  };
  type: 'SMS' | 'WHATSAPP' | 'RCS';
  direction: 'MT' | 'MO';
  recipient: {
    to: string;
  };
  from: string;
  body: {
    text: string;
    stop?: boolean;
    encoding: 'GSM7' | 'UNICODE';
    messagePartCount: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10;
    length: number;
  };
  price?: {
    amount: string;
    currency: 'EUR';
  };
  status: {
    deliveryDate: string;
    value: 'SCHEDULED' | 'ENROUTE' | 'DELIVERED' | 'UNDELIVERABLE' | 'UNDELIVERED';
    detail?:
      | 'INSUFFICIENT_CREDIT'
      | 'ORGANISATION_MONTHLY_LIMIT_EXCEEDED'
      | 'DAILY_LIMIT_EXCEEDED'
      | 'SPAM'
      | 'INVALID_PHONE_NUMBER'
      | 'BLACKLISTED';
    lookup?: {};
  };
  refClient?: string;
  callbackUrlStatus?: string;
  callbackUrlMo?: string;
  href: string;
}

export class SmsmodeSmsProvider extends BaseProvider implements ISmsProvider {
  id = SmsProviderIdEnum.Smsmode;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;
  public readonly BASE_URL = 'https://rest.smsmode.com/sms/v1';
  protected casing: CasingEnum = CasingEnum.CAMEL_CASE;

  constructor(
    private config: {
      apiKey: string;
      from: string;
    }
  ) {
    super();
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const sms = this.transform(bridgeProviderData, {
      from: options.from || this.config.from,
      recipient: {
        to: options.to,
      },
      body: {
        text: options.content,
      },
    });

    const response = await axios.create().post<ISmsmodeApiResponse>(`${this.BASE_URL}/messages`, sms.body, {
      headers: {
        'X-Api-Key': this.config.apiKey,
        'Content-Type': 'application/json',
        Accept: 'application/json',
        ...sms.headers,
      },
    });

    const { messageId, acceptedAt } = response.data;

    return {
      id: messageId,
      date: acceptedAt,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  interface
- export class SmsmodeSmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/smsmode/smsmode.test.provider.spec.ts
Tamaño: 5203 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ISmsOptions } from '@novu/stateless';
import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
import { axiosSpy } from '../../../utils/test/spy-axios';
import { ISmsmodeApiResponse, SmsmodeSmsProvider } from './smsmode.provider';

test('should trigger smsmode library correctly', async () => {});

const mockConfig = {
  apiKey: 'ABCDE',
  from: 'My Company',
};

const mockNovuMessage: ISmsOptions = {
  from: 'My Company',
  to: '+33623456789',
  content: 'SMS content',
};

const mockSmsmodeApiResponse: ISmsmodeApiResponse = {
  messageId: '67c15045-1067-4588-ba3c-737cc5051438',
  acceptedAt: '2021-10-14T12:00:00',
  channel: {
    channelId: 'cbc76dcd-72a8-43ee-a39f-acba2157e81c',
    name: 'marketing_channel',
    type: 'SMS',
    flow: 'MARKETING',
  },
  type: 'SMS',
  direction: 'MT',
  recipient: {
    to: '3600000000',
  },
  from: '36034',
  body: {
    text: 'message',
    encoding: 'GSM7',
    messagePartCount: 1,
    length: 7,
  },
  status: {
    deliveryDate: '2021-10-14T12:00:00',
    value: 'ENROUTE',
  },
  href: 'https://rest.smsmode.com/sms/v1/messages/67c15045-1067-4588-ba3c-737cc5051438',
};

beforeEach(() => {
  vi.restoreAllMocks();
});

afterEach(() => {
  vi.restoreAllMocks();
});

describe('sendMessage method', () => {
  test('should call smsmode API sms endpoint once with POST method', async () => {
    const provider = new SmsmodeSmsProvider(mockConfig);

    const { mockPost: fakePost } = axiosSpy({
      data: '0',
    });

    await provider.sendMessage(mockNovuMessage);

    expect(fakePost).toHaveBeenCalled();
  });

  test('should call smsmode API endpoint with right URL', async () => {
    const provider = new SmsmodeSmsProvider(mockConfig);

    const { mockPost: fakePost } = axiosSpy({
      data: '0',
    });

    await provider.sendMessage(mockNovuMessage);

    expect(fakePost.mock.calls[0][0]).toEqual('https://rest.smsmode.com/sms/v1/messages');
  });

  test('should call smsmode API using config apiKey', async () => {
    const provider = new SmsmodeSmsProvider(mockConfig);

    const { mockPost: fakePost } = axiosSpy({
      data: '0',
    });

    await provider.sendMessage(mockNovuMessage);

    expect(fakePost.mock.calls[0][2]).toMatchObject({
      headers: {
        'X-Api-Key': mockConfig.apiKey,
      },
    });
  });

  test('should send message with provided config from', async () => {
    const provider = new SmsmodeSmsProvider(mockConfig);

    const { mockPost: fakePost } = axiosSpy({
      data: '0',
    });

    const { from, ...mockNovuMessageWithoutFrom } = mockNovuMessage;

    await provider.sendMessage(mockNovuMessageWithoutFrom);

    console.log(fakePost.mock.calls);
    const requestBody = fakePost.mock.calls[0][1];

    expect(requestBody.from).toEqual(mockConfig.from);
  });

  test('should send message with provided option from overriding config from', async () => {
    const provider = new SmsmodeSmsProvider(mockConfig);

    const { mockPost: fakePost } = axiosSpy({
      data: '0',
    });

    await provider.sendMessage(mockNovuMessage);

    const requestBody = fakePost.mock.calls[0][1];

    expect(requestBody.from).toEqual(mockNovuMessage.from);
  });

  test('should send message with provided option to', async () => {
    const provider = new SmsmodeSmsProvider(mockConfig);

    const { mockPost: fakePost } = axiosSpy({
      data: '0',
    });

    await provider.sendMessage(mockNovuMessage);

    const requestBody = fakePost.mock.calls[0][1];

    expect(requestBody.recipient.to).toEqual(mockNovuMessage.to);
  });

  test('should send message with provided option content', async () => {
    const provider = new SmsmodeSmsProvider(mockConfig);

    const { mockPost: fakePost } = axiosSpy({
      data: '0',
    });

    await provider.sendMessage(mockNovuMessage);

    const requestBody = fakePost.mock.calls[0][1];

    expect(requestBody.body.text).toEqual(mockNovuMessage.content);
  });

  test('should send message with provided option content with _passthrough', async () => {
    const provider = new SmsmodeSmsProvider(mockConfig);

    const { mockPost: fakePost } = axiosSpy({
      data: '0',
    });

    await provider.sendMessage(mockNovuMessage, {
      _passthrough: {
        body: {
          body: {
            text: '_passthrough content',
          },
        },
      },
    });

    const requestBody = fakePost.mock.calls[0][1];

    expect(requestBody.body.text).toEqual('_passthrough content');
  });

  test('should return id returned in request response', async () => {
    const provider = new SmsmodeSmsProvider(mockConfig);

    axiosSpy({
      data: mockSmsmodeApiResponse,
    });

    const result = await provider.sendMessage(mockNovuMessage);

    expect(result).toMatchObject({
      id: mockSmsmodeApiResponse.messageId,
    });
  });

  test('should return date returned in request response', async () => {
    const provider = new SmsmodeSmsProvider(mockConfig);

    axiosSpy({
      data: mockSmsmodeApiResponse,
    });

    const result = await provider.sendMessage(mockNovuMessage);

    expect(result).toMatchObject({
      date: mockSmsmodeApiResponse.acceptedAt,
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - ISmsmodeApiResponse({
  messageId: '67c15045-1067-4588-ba3c-737cc5051438',
  acceptedAt: '2021-10-14T12:00:00',
  channe...)
 - requestBody(fakePost.mock.calls[0][1];

    expect(requestBody.from).toEqual(mockConfig.from);
  });

  test('sh...)
 - requestBody(fakePost.mock.calls[0][1];

    expect(requestBody.from).toEqual(mockNovuMessage.from);
  });

  tes...)
 - requestBody(fakePost.mock.calls[0][1];

    expect(requestBody.recipient.to).toEqual(mockNovuMessage.to);
  });
...)
 - requestBody(fakePost.mock.calls[0][1];

    expect(requestBody.body.text).toEqual(mockNovuMessage.content);
  })...)
 - requestBody(fakePost.mock.calls[0][1];

    expect(requestBody.body.text).toEqual('_passthrough content');
  });...)
 - result(await provider.sendMessage(mockNovuMessage);

    expect(result).toMatchObject({
      id: mockSmsmo...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/sns/sns.config.ts
Tamaño: 174 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SNSClientConfig } from '@aws-sdk/client-sns';

export type SNSConfig = SNSClientConfig & {
  accessKeyId?: string;
  secretAccessKey?: string;
  region?: string;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/sns/sns.provider.spec.ts
Tamaño: 1826 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SNSClient } from '@aws-sdk/client-sns';
import { expect, test, vi } from 'vitest';

import { SNSSmsProvider } from './sns.provider';

test('should trigger sns library correctly', async () => {
  const mockResponse = { MessageId: 'mock-message-id' };
  const spy = vi.spyOn(SNSClient.prototype, 'send').mockImplementation(async () => mockResponse);

  const mockConfig = {
    accessKeyId: 'TEST',
    secretAccessKey: 'TEST',
    region: 'test-1',
  };
  const provider = new SNSSmsProvider(mockConfig);

  const mockNovuMessage = {
    to: '0123456789',
    content: 'hello',
  };
  const response = await provider.sendMessage(mockNovuMessage);

  const publishInput = {
    input: {
      PhoneNumber: mockNovuMessage.to,
      Message: mockNovuMessage.content,
    },
  };

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith(expect.objectContaining(publishInput));
  expect(response.id).toBe(mockResponse.MessageId);
});

test('should trigger sns library correctly with _passthrough', async () => {
  const mockResponse = { MessageId: 'mock-message-id' };
  const spy = vi.spyOn(SNSClient.prototype, 'send').mockImplementation(async () => mockResponse);

  const mockConfig = {
    accessKeyId: 'TEST',
    secretAccessKey: 'TEST',
    region: 'test-1',
  };
  const provider = new SNSSmsProvider(mockConfig);

  const mockNovuMessage = {
    to: '0123456789',
    content: 'hello',
  };
  const response = await provider.sendMessage(mockNovuMessage, {
    _passthrough: {
      body: {
        PhoneNumber: '1123456789',
      },
    },
  });

  const publishInput = {
    PhoneNumber: '1123456789',
    Message: mockNovuMessage.content,
  };

  expect(spy).toHaveBeenCalled();
  expect(spy.mock.calls[0][0]?.input).toEqual(publishInput);
  expect(response.id).toBe(mockResponse.MessageId);
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - spy(vi.spyOn(SNSClient.prototype, 'send').mockImplementation(async ())
 - publishInput({
    input: {
      PhoneNumber: mockNovuMessage.to,
      Message: mockNovuMessage.content,
    },...)
 - spy(vi.spyOn(SNSClient.prototype, 'send').mockImplementation(async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/sns/sns.provider.ts
Tamaño: 1468 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { PublishCommand, PublishCommandInput, SNSClient } from '@aws-sdk/client-sns';
import { SmsProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, ISendMessageSuccessResponse, ISmsOptions, ISmsProvider } from '@novu/stateless';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';
import { SNSConfig } from './sns.config';

export class SNSSmsProvider extends BaseProvider implements ISmsProvider {
  id = SmsProviderIdEnum.SNS;
  protected casing: CasingEnum = CasingEnum.PASCAL_CASE;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;
  private client: SNSClient;

  constructor(private readonly config: SNSConfig) {
    super();
    this.client = new SNSClient({
      region: this.config.region,
      credentials: {
        accessKeyId: this.config.accessKeyId,
        secretAccessKey: this.config.secretAccessKey,
      },
    });
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const { to, content } = options;

    const publish = new PublishCommand(
      this.transform<PublishCommandInput>(bridgeProviderData, {
        PhoneNumber: to,
        Message: content,
      }).body
    );

    const snsResponse = await this.client.send(publish);

    return {
      id: snsResponse.MessageId,
      date: new Date().toISOString(),
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SNSSmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/telnyx/telnyx.interface.ts
Tamaño: 924 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export interface ITelnyxCLient {
  messages: {
    create: (options: ITelnyxSmsOptions) => Promise<ITelnyxMessageResponse>;
  };
}

export interface ITelnyxSmsOptions {
  to: string;
  text: string;
  from?: string;
  messaging_profile_id?: string;
}

interface From {
  phone_number: string;
  carrier: string;
  line_type: string;
}

interface To {
  phone_number: string;
  status: string;
  carrier: string;
  line_type: string;
}

interface Data {
  record_type: string;
  direction: string;
  id: string;
  type: string;
  organization_id: string;
  messaging_profile_id: string;
  from: From;
  to: To[];
  text: string;
  media: any[];
  webhook_url: string;
  webhook_failover_url: string;
  encoding: string;
  parts: number;
  tags: any[];
  cost?: any;
  received_at: Date;
  sent_at?: any;
  completed_at?: any;
  valid_until: Date;
  errors: any[];
}

export interface ITelnyxMessageResponse {
  data: Data;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  interface
- export  interface
- export  interface

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/telnyx/telnyx.provider.spec.ts
Tamaño: 1733 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, test, vi } from 'vitest';
import { TelnyxSmsProvider } from './telnyx.provider';

test('should trigger Telnyx correctly', async () => {
  const provider = new TelnyxSmsProvider({
    apiKey: 'API-KEY-MOCK1023893INAPP',
    from: 'TelynxTest',
    messageProfileId: 'jap-ops-pkd-pn-pair',
  });

  const spy = vi.spyOn((provider as any).telnyxClient.messages, 'create').mockImplementation(async () => {
    return {
      data: {
        id: Math.ceil(Math.random() * 100),
        received_at: new Date(),
      },
    };
  });
  await provider.sendMessage({
    content: 'We are testing',
    to: '+2347069652019',
  });

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    from: 'TelynxTest',
    text: 'We are testing',
    to: '+2347069652019',
    messaging_profile_id: 'jap-ops-pkd-pn-pair',
  });
});

test('should trigger Telnyx correctly with _passthrough', async () => {
  const provider = new TelnyxSmsProvider({
    apiKey: 'API-KEY-MOCK1023893INAPP',
    from: 'TelynxTest',
    messageProfileId: 'jap-ops-pkd-pn-pair',
  });

  const spy = vi.spyOn((provider as any).telnyxClient.messages, 'create').mockImplementation(async () => {
    return {
      data: {
        id: Math.ceil(Math.random() * 100),
        received_at: new Date(),
      },
    };
  });
  await provider.sendMessage(
    {
      content: 'We are testing',
      to: '+2347069652019',
    },
    {
      _passthrough: {
        body: {
          from: 'TelynxTest1',
        },
      },
    }
  );

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    from: 'TelynxTest1',
    text: 'We are testing',
    to: '+2347069652019',
    messaging_profile_id: 'jap-ops-pkd-pn-pair',
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - spy(vi.spyOn((provider as any).telnyxClient.messages, 'create').mockImplementation(async ())
 - spy(vi.spyOn((provider as any).telnyxClient.messages, 'create').mockImplementation(async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/telnyx/telnyx.provider.ts
Tamaño: 2785 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SmsProviderIdEnum } from '@novu/shared';
import {
  ChannelTypeEnum,
  ISendMessageSuccessResponse,
  ISMSEventBody,
  ISmsOptions,
  ISmsProvider,
  SmsEventStatusEnum,
} from '@novu/stateless';

import Telnyx from 'telnyx';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';
import { ITelnyxCLient } from './telnyx.interface';

export class TelnyxSmsProvider extends BaseProvider implements ISmsProvider {
  id = SmsProviderIdEnum.Telnyx;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;
  protected casing = CasingEnum.SNAKE_CASE;
  private telnyxClient: ITelnyxCLient;

  constructor(
    private config: {
      apiKey?: string;
      from?: string;
      messageProfileId?: string;
    }
  ) {
    super();
    this.telnyxClient = Telnyx(config.apiKey);
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const telynxResponse = await this.telnyxClient.messages.create(
      this.transform<any>(bridgeProviderData, {
        to: options.to,
        text: options.content,
        from: options.from || this.config.from,
        messaging_profile_id: this.config.messageProfileId,
      }).body
    );

    return {
      id: telynxResponse.data.id,
      date: telynxResponse.data.received_at.toString(),
    };
  }

  getMessageId(body: any | any[]): string[] {
    if (Array.isArray(body)) {
      return body.map((item) => item.data.id);
    }

    return [body.data.id];
  }

  parseEventBody(body: any | any[], identifier: string): ISMSEventBody | undefined {
    if (Array.isArray(body)) {
      body = body.find((item) => item.data.id === identifier);
    }

    if (!body) {
      return undefined;
    }

    const status = this.getStatus(body.data.payload.to[0].status);

    if (status === undefined) {
      return undefined;
    }

    return {
      status,
      date: new Date().toISOString(),
      externalId: body.data.id,
      attempts: body.attempt ? parseInt(body.attempt, 10) : 1,
      response: body.response ? body.response : '',
      row: body,
    };
  }

  private getStatus(event: string): SmsEventStatusEnum | undefined {
    switch (event) {
      case 'queued':
        return SmsEventStatusEnum.QUEUED;
      case 'sending':
        return SmsEventStatusEnum.SENDING;
      case 'sent':
        return SmsEventStatusEnum.SENT;
      case 'sending_failed':
      case 'delivery_failed':
        return SmsEventStatusEnum.FAILED;
      case 'delivered':
        return SmsEventStatusEnum.DELIVERED;
      case 'delivery_unconfirmed':
        return SmsEventStatusEnum.UNDELIVERED;
      default:
        return undefined;
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - telynxResponse(await this.telnyxClient.messages.create(
      this.transform<any>(bridgeProviderData, {
        to:...)
 - body(body.find((item))
Declaraciones 'export' encontradas:
- export class TelnyxSmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/termii/sms.ts
Tamaño: 469 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export enum MessageChannel {
  DND = 'dnd',
  WHATSAPP = 'whatsapp',
  GENERIC = 'generic',
}

export type Media = {
  url: string;
  caption: string;
};

export type SmsParams = {
  to: string;
  from: string;
  sms: string;
  type: string;
  api_key: string;
  channel: MessageChannel;
  media?: Media;
};

export type SmsJsonResponse = {
  message_id: string;
  message: string;
  balance: number;
  user: string;
};

export type AnyObject = { [key: string]: any };


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  enum
- export  type
- export  type
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/termii/termii.provider.spec.ts
Tamaño: 1639 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { afterEach, expect, test, vi } from 'vitest';
import { TermiiSmsProvider } from './termii.provider';

afterEach(() => {
  vi.restoreAllMocks();
});

test('should trigger termii library correctly', async () => {
  const provider = new TermiiSmsProvider({
    apiKey: 'SG.',
    from: 'TermiiTest',
  });

  const fetchMock = vi.fn().mockResolvedValue({
    json: () => Promise.resolve({ message_id: '1' }),
  });
  global.fetch = fetchMock;

  await provider.sendMessage({
    content: 'Your otp code is 32901',
    from: 'TermiiTest',
    to: '+2347063317344',
  });

  expect(fetchMock).toHaveBeenCalledWith(
    expect.any(String),
    expect.objectContaining({
      body: '{"to":"+2347063317344","from":"TermiiTest","sms":"Your otp code is 32901","type":"plain","channel":"generic","api_key":"SG."}',
    })
  );
});

test('should trigger termii library correctly with _passthrough', async () => {
  const provider = new TermiiSmsProvider({
    apiKey: 'SG.',
    from: 'TermiiTest',
  });

  const fetchMock = vi.fn().mockResolvedValue({
    json: () => Promise.resolve({ message_id: '1' }),
  });
  global.fetch = fetchMock;

  await provider.sendMessage(
    {
      content: 'Your otp code is 32901',
      from: 'TermiiTest',
      to: '+2347063317344',
    },
    {
      _passthrough: {
        body: {
          to: '+3347063317344',
        },
      },
    }
  );

  expect(fetchMock).toHaveBeenCalledWith(
    expect.any(String),
    expect.objectContaining({
      body: '{"to":"+3347063317344","from":"TermiiTest","sms":"Your otp code is 32901","type":"plain","channel":"generic","api_key":"SG."}',
    })
  );
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - fetchMock(vi.fn().mockResolvedValue({
    json: ())
 - fetch(fetchMock;

  await provider.sendMessage({
    content: 'Your otp code is 32901',
    from: 'TermiiT...)
 - fetchMock(vi.fn().mockResolvedValue({
    json: ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/termii/termii.provider.ts
Tamaño: 2997 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SmsProviderIdEnum } from '@novu/shared';
import {
  ChannelTypeEnum,
  ISendMessageSuccessResponse,
  ISMSEventBody,
  ISmsOptions,
  ISmsProvider,
  SmsEventStatusEnum,
} from '@novu/stateless';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';
import { MessageChannel, SmsJsonResponse, SmsParams } from './sms';

export class TermiiSmsProvider extends BaseProvider implements ISmsProvider {
  public static readonly BASE_URL = 'https://api.ng.termii.com/api/sms/send';
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;
  protected casing = CasingEnum.SNAKE_CASE;
  id = SmsProviderIdEnum.Termii;

  constructor(
    private config: {
      apiKey?: string;
      from?: string;
    }
  ) {
    super();
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const params = this.transform<SmsParams>(bridgeProviderData, {
      to: options.to,
      from: options.from || this.config.from,
      sms: options.content,
      type: 'plain',
      channel: MessageChannel.GENERIC,
      api_key: this.config.apiKey,
    });

    const headers: HeadersInit = {
      'Content-Type': 'application/json',
      ...params.headers,
    };
    const opts: RequestInit = {
      agent: undefined,
      cache: undefined,
      credentials: undefined,
      mode: undefined,
      redirect: undefined,
      referrerPolicy: undefined,
      signal: undefined,
      method: 'POST',
      headers,
      body: JSON.stringify(params.body),
    };

    const response = await fetch(TermiiSmsProvider.BASE_URL, opts);
    const body = (await response.json()) as SmsJsonResponse;

    return {
      id: body.message_id,
      date: new Date().toISOString(),
    };
  }
  getMessageId(body: any | any[]): string[] {
    if (Array.isArray(body)) {
      return body.map((item) => item.message_id);
    }

    return [body.message_id];
  }

  parseEventBody(body: any | any[], identifier: string): ISMSEventBody | undefined {
    if (Array.isArray(body)) {
      body = body.find((item) => item.message_id === identifier);
    }

    if (!body) {
      return undefined;
    }

    const status = this.getStatus(body.status);

    if (status === undefined) {
      return undefined;
    }

    return {
      status,
      date: new Date().toISOString(),
      externalId: body.message_id,
      attempts: body.attempt ? parseInt(body.attempt, 10) : 1,
      response: body.response ? body.response : '',
      row: body,
    };
  }

  private getStatus(event: string): SmsEventStatusEnum | undefined {
    switch (event) {
      case 'Message sent':
        return SmsEventStatusEnum.SENT;
      case 'Message failed':
      case 'Rejected':
        return SmsEventStatusEnum.FAILED;
      case 'Delivered':
        return SmsEventStatusEnum.DELIVERED;
      default:
        return undefined;
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - body(await response.json()) as SmsJsonResponse;

    return {
      id: body.message_id,
      date: new ...)
 - body(body.find((item))
Declaraciones 'export' encontradas:
- export class TermiiSmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/twilio/twilio.provider.spec.ts
Tamaño: 1603 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { expect, test, vi } from 'vitest';
import { TwilioSmsProvider } from './twilio.provider';

test('should trigger Twilio correctly', async () => {
  const provider = new TwilioSmsProvider({
    accountSid: 'AC<twilio-account-Sid>',
    authToken: '<twilio-auth-Token>',
    from: '+112345',
  });
  const spy = vi.spyOn((provider as any).twilioClient.messages, 'create').mockImplementation(async () => {
    return {
      dateCreated: new Date(),
    };
  });

  await provider.sendMessage(
    {
      to: '+176543',
      content: 'SMS Content',
    },
    {
      ApplicationSid: 'test',
    }
  );

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    from: '+112345',
    body: 'SMS Content',
    to: '+176543',
    applicationSid: 'test',
  });
});

test('should trigger Twilio correctly with _passthrough', async () => {
  const provider = new TwilioSmsProvider({
    accountSid: 'AC<twilio-account-Sid>',
    authToken: '<twilio-auth-Token>',
    from: '+112345',
  });
  const spy = vi.spyOn((provider as any).twilioClient.messages, 'create').mockImplementation(async () => {
    return {
      dateCreated: new Date(),
    };
  });

  await provider.sendMessage(
    {
      to: '+176543',
      content: 'SMS Content',
    },
    {
      ApplicationSid: 'test',
      _passthrough: {
        body: {
          body: 'SMS Content _passthrough',
        },
      },
    }
  );

  expect(spy).toHaveBeenCalled();
  expect(spy).toHaveBeenCalledWith({
    from: '+112345',
    body: 'SMS Content _passthrough',
    to: '+176543',
    applicationSid: 'test',
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - spy(vi.spyOn((provider as any).twilioClient.messages, 'create').mockImplementation(async ())
 - spy(vi.spyOn((provider as any).twilioClient.messages, 'create').mockImplementation(async ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/twilio/twilio.provider.ts
Tamaño: 2830 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SmsProviderIdEnum } from '@novu/shared';
import {
  ChannelTypeEnum,
  ISendMessageSuccessResponse,
  ISMSEventBody,
  ISmsOptions,
  ISmsProvider,
  SmsEventStatusEnum,
} from '@novu/stateless';

import { Twilio } from 'twilio';
import { MessageListInstanceCreateOptions } from 'twilio/lib/rest/api/v2010/account/message';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

export class TwilioSmsProvider extends BaseProvider implements ISmsProvider {
  id = SmsProviderIdEnum.Twilio;
  protected casing = CasingEnum.CAMEL_CASE;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;
  private twilioClient: Twilio;

  constructor(
    private config: {
      accountSid?: string;
      authToken?: string;
      from?: string;
    }
  ) {
    super();
    this.twilioClient = new Twilio(config.accountSid, config.authToken);
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const twilioResponse = await this.twilioClient.messages.create(
      this.transform<MessageListInstanceCreateOptions>(bridgeProviderData, {
        body: options.content,
        to: options.to,
        from: options.from || this.config.from,
      }).body
    );

    return {
      id: twilioResponse.sid,
      date: twilioResponse.dateCreated.toISOString(),
    };
  }

  getMessageId(body: any | any[]): string[] {
    if (Array.isArray(body)) {
      return body.map((item) => item.MessageSid);
    }

    return [body.MessageSid];
  }

  parseEventBody(body: any | any[], identifier: string): ISMSEventBody | undefined {
    if (Array.isArray(body)) {
      body = body.find((item) => item.MessageSid === identifier);
    }

    if (!body) {
      return undefined;
    }

    const status = this.getStatus(body.MessageStatus);

    if (status === undefined) {
      return undefined;
    }

    return {
      status,
      date: new Date().toISOString(),
      externalId: body.MessageSid,
      attempts: body.attempt ? parseInt(body.attempt, 10) : 1,
      response: body.response ? body.response : '',
      row: body,
    };
  }

  private getStatus(event: string): SmsEventStatusEnum | undefined {
    switch (event) {
      case 'accepted':
        return SmsEventStatusEnum.ACCEPTED;
      case 'queued':
        return SmsEventStatusEnum.QUEUED;
      case 'sending':
        return SmsEventStatusEnum.SENDING;
      case 'sent':
        return SmsEventStatusEnum.SENT;
      case 'failed':
        return SmsEventStatusEnum.FAILED;
      case 'delivered':
        return SmsEventStatusEnum.DELIVERED;
      case 'undelivered':
        return SmsEventStatusEnum.UNDELIVERED;
      default:
        return undefined;
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - twilioResponse(await this.twilioClient.messages.create(
      this.transform<MessageListInstanceCreateOptions>(brid...)
 - body(body.find((item))
Declaraciones 'export' encontradas:
- export class TwilioSmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/unifonic/unifonic.provider.spec.ts
Tamaño: 1479 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import axios from 'axios';
import { beforeEach, describe, expect, test, vi } from 'vitest';
import { UnifonicSmsProvider } from './unifonic.provider';

// Mock axios
vi.mock('axios');
const mockedAxios = axios as unknown as {
  post: ReturnType<typeof vi.fn>;
};

beforeEach(() => {
  mockedAxios.post = vi.fn(); // Reset mock before each test
});

describe('UnifonicSmsProvider', () => {
  test('should trigger Unifonic SMS API correctly', async () => {
    const provider = new UnifonicSmsProvider({
      appSid: 'testSender',
      senderId: 'testSender',
    });

    mockedAxios.post.mockResolvedValue({
      data: {
        messageID: '123456789',
      },
    });

    await provider.sendMessage({
      to: '966123456789',
      content: 'Hi there',
    });

    expect(mockedAxios.post).toHaveBeenCalledWith(
      'https://el.cloud.unifonic.com/rest/SMS/messages',
      expect.stringContaining('AppSid=testSender'),
      expect.objectContaining({
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
      })
    );
  });

  test('should throw error if messageID is missing', async () => {
    const provider = new UnifonicSmsProvider({
      appSid: 'dummy',
      senderId: 'dummy',
    });

    mockedAxios.post.mockResolvedValue({
      data: {},
    });

    await expect(
      provider.sendMessage({
        to: '966123456789',
        content: 'Test',
      })
    ).rejects.toThrow('Unifonic SMS failed');
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - mockedAxios(axios as unknown as {
  post: ReturnType<typeof vi.fn>;
};

beforeEach(())
 - post(vi.fn(); // Reset mock before each test
});

describe('UnifonicSmsProvider', ())
 - AppSid(testSender'),
      expect.objectContaining({
        headers: {
          'Content-Type': 'applicat...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/lib/sms/unifonic/unifonic.provider.ts
Tamaño: 1543 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SmsProviderIdEnum } from '@novu/shared';
import { ChannelTypeEnum, ISendMessageSuccessResponse, ISmsOptions, ISmsProvider } from '@novu/stateless';
import axios from 'axios';
import qs from 'qs';
import { BaseProvider, CasingEnum } from '../../../base.provider';
import { WithPassthrough } from '../../../utils/types';

interface IUnifonicConfig {
  appSid: string;
  senderId: string;
}

export class UnifonicSmsProvider extends BaseProvider implements ISmsProvider {
  id = SmsProviderIdEnum.Unifonic;
  channelType = ChannelTypeEnum.SMS as ChannelTypeEnum.SMS;
  protected casing = CasingEnum.CAMEL_CASE;

  constructor(private config: IUnifonicConfig) {
    super();
  }

  async sendMessage(
    options: ISmsOptions,
    bridgeProviderData: WithPassthrough<Record<string, unknown>> = {}
  ): Promise<ISendMessageSuccessResponse> {
    const payload = this.transform(bridgeProviderData, {
      AppSid: this.config.appSid,
      SenderID: this.config.senderId,
      Recipient: options.to,
      Body: options.content,
      responseType: 'JSON',
      baseEncode: true,
    });

    const response = await axios.post('https://el.cloud.unifonic.com/rest/SMS/messages', qs.stringify(payload.body), {
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
    });

    if (response.data?.messageID) {
      return {
        id: response.data.messageID,
        date: new Date().toISOString(),
      };
    }

    throw new Error(`Unifonic SMS failed: ${JSON.stringify(response.data || {})}`);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UnifonicSmsProvider

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/utils/deepmerge.utils.spec.ts
Tamaño: 900 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { describe, expect, it } from 'vitest';
import { deepMerge } from './deepmerge.utils';

describe('deepmerge', () => {
  it('should merge two objects', () => {
    const obj1 = {
      a: {
        b: 1,
        d: {
          a: 1,
        },
        x: [1, 2, 3],
      },
    };

    const obj2 = {
      a: {
        c: 2,
        d: {
          a: 1,
        },
        x: [3, 4, 5],
      },
    };

    const result = deepMerge([obj1, obj2]);

    expect(result).toEqual({
      a: {
        b: 1,
        c: 2,
        d: {
          a: 1,
        },
        x: [1, 2, 3, 3, 4, 5],
      },
    });
  });

  it('should merge an array of objects with the last object taking precedence', () => {
    const obj1 = { a: 1 };
    const obj2 = { a: 2 };
    const obj3 = { a: 3 };

    const result = deepMerge([obj1, obj2, obj3]);

    expect(result).toEqual({
      a: 3,
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - result(deepMerge([obj1, obj2]);

    expect(result).toEqual({
      a: {
        b: 1,
        c: 2,
      ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/utils/deepmerge.utils.ts
Tamaño: 6451 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

// from: https://github.com/TehShrike/deepmerge/tree/master

function isMergeableObject(value: unknown) {
  return isNonNullObject(value) && !isSpecial(value as Record<string, unknown>);
}

function isNonNullObject(value: unknown) {
  return !!value && typeof value === 'object';
}

function isSpecial(value: Record<string, unknown>) {
  const stringValue = Object.prototype.toString.call(value);

  return stringValue === '[object RegExp]' || stringValue === '[object Date]' || stringValue === '[object Uint8Array]';
}

function emptyTarget(val: unknown) {
  return Array.isArray(val) ? [] : {};
}

function cloneUnlessOtherwiseSpecified(
  value: Record<string, unknown>,
  options: IOptions
): Record<string, unknown> | Record<string, unknown>[] {
  return options.clone !== false && options.isMergeableObject(value)
    ? deepMergeObjects(emptyTarget(value), value, options)
    : value;
}

function defaultArrayMerge(
  target: Record<string, unknown>[],
  source: Record<string, unknown>[],
  options: IOptions
): Record<string, unknown>[] {
  return target
    .concat(source)
    .map((element) => cloneUnlessOtherwiseSpecified(element, options) as Record<string, unknown>);
}

function getMergeFunction(key: string, options: IOptions) {
  if (!options.customMerge) {
    return deepMergeObjects;
  }
  const customMerge = options.customMerge(key);

  return typeof customMerge === 'function' ? customMerge : deepMergeObjects;
}

function getKeys(target: Record<string, unknown>): unknown[] {
  return Object.keys(target);
}

function propertyIsOnObject(object: Record<string, unknown>, property: string) {
  try {
    return property in object;
  } catch (_) {
    return false;
  }
}

// Protects from prototype poisoning and unexpected merging up the prototype chain.
function propertyIsUnsafe(target: Record<string, unknown>, key: string) {
  return (
    propertyIsOnObject(target, key) && // Properties are safe to merge if they don't exist in the target yet,
    !(
      Object.hasOwnProperty.call(target, key) && // unsafe if they exist up the prototype chain,
      Object.propertyIsEnumerable.call(target, key)
    )
  ); // and also unsafe if they're nonenumerable.
}

function mergeObject(
  target: Record<string, unknown>,
  source: Record<string, unknown>,
  options: IOptions
): Record<string, unknown> {
  const destination = {};
  if (options.isMergeableObject(target)) {
    getKeys(target).forEach((key: string) => {
      destination[key] = cloneUnlessOtherwiseSpecified(target[key] as Record<string, unknown>, options);
    });
  }
  getKeys(source).forEach((key: string) => {
    if (propertyIsUnsafe(target, key as string)) {
      return;
    }

    if (propertyIsOnObject(target, key as string) && options.isMergeableObject(source[key])) {
      destination[key] = getMergeFunction(key as string, options)(
        target[key] as Record<string, unknown>,
        source[key] as Record<string, unknown>,
        options
      );
    } else {
      destination[key] = cloneUnlessOtherwiseSpecified(source[key] as Record<string, unknown>, options);
    }
  });

  return destination;
}

interface IOptions {
  customMerge: (
    key: string
  ) => (target: Record<string, unknown>, source: Record<string, unknown>, options: IOptions) => Record<string, unknown>;
  arrayMerge: (
    target: Record<string, unknown>[],
    source: Record<string, unknown>[],
    options: IOptions
  ) => Record<string, unknown>[];
  isMergeableObject: (value: unknown) => boolean;
  cloneUnlessOtherwiseSpecified: (
    value: Record<string, unknown>,
    options: IOptions
  ) => Record<string, unknown> | Record<string, unknown>[];
  clone?: boolean;
}

interface IDeepMergeOptions {
  customMerge?: (
    key: string
  ) => (target: Record<string, unknown>, source: Record<string, unknown>, options: IOptions) => Record<string, unknown>;
  arrayMerge?: (
    target: Record<string, unknown>[],
    source: Record<string, unknown>[],
    options: IOptions
  ) => Record<string, unknown>[];
  isMergeableObject?: (value: unknown) => boolean;
  cloneUnlessOtherwiseSpecified?: (
    value: Record<string, unknown>,
    options: IOptions
  ) => Record<string, unknown> | Record<string, unknown>[];
  clone?: boolean;
}

/**
 * Merges two objects or arrays of objects using deepMerge. The second object
 * takes precedence for any keys that are present in both objects.
 * @param source - The source object or array of objects to merge from.
 * @param target - The target object or array of objects to merge into.
 * @param options - The options to pass to deepMerge.
 * @returns The merged object or array of objects.
 */
function deepMergeObjects<T extends Record<string, unknown> | Record<string, unknown>[]>(
  target: Record<string, unknown> | Record<string, unknown>[],
  source: Record<string, unknown> | Record<string, unknown>[],
  options?: IDeepMergeOptions
): T {
  options = options || {};
  options.arrayMerge = options.arrayMerge || defaultArrayMerge;
  options.isMergeableObject = options.isMergeableObject || isMergeableObject;
  /*
   * cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
   * implementations can use it. The caller may not replace it.
   */
  options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

  const sourceIsArray = Array.isArray(source);
  const targetIsArray = Array.isArray(target);
  const sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

  if (!sourceAndTargetTypesMatch) {
    return cloneUnlessOtherwiseSpecified(source as Record<string, unknown>, options as IOptions) as T;
  }
  if (sourceIsArray) {
    return options.arrayMerge(
      target as Record<string, unknown>[],
      source as Record<string, unknown>[],
      options as IOptions
    ) as T;
  }

  return mergeObject(target as Record<string, unknown>, source, options as IOptions) as T;
}

/**
 * Merges an array of objects using deepMerge. Items later in the array take
 * precedence for any keys that are present in multiple objects.
 *
 * @param array - The array of objects to merge.
 * @param options - The options to pass to deepMerge.
 * @returns The merged object.
 */
export function deepMerge<T extends Record<string, unknown>>(array: T[], options?: IDeepMergeOptions): T {
  if (!Array.isArray(array)) {
    throw new Error('first argument should be an array');
  }

  return array.reduce((prev, next) => deepMergeObjects(prev, next, options), {} as T);
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - isMergeableObject(value: unknown)
 - isNonNullObject(value: unknown)
 - isSpecial(value: Record<string, unknown>)
 - emptyTarget(val: unknown)
 - cloneUnlessOtherwiseSpecified(value: Record<string, unknown>,
  options: IOptions)
 - defaultArrayMerge(target: Record<string, unknown>[],
  source: Record<string, unknown>[],
  options: IOptions)
 - getMergeFunction(key: string, options: IOptions)
 - getKeys(target: Record<string, unknown>)
 - propertyIsOnObject(object: Record<string, unknown>, property: string)
 - propertyIsUnsafe(target: Record<string, unknown>, key: string)
 - mergeObject(target: Record<string, unknown>,
  source: Record<string, unknown>,
  options: IOptions)
Asignaciones con arrow functions encontradas (posibles funciones):
 - destination({};
  if (options.isMergeableObject(target)) {
    getKeys(target).forEach((key: string))
Declaraciones 'export' encontradas:
- export function deepMerge

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/utils/types.ts
Tamaño: 205 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export type Passthrough = {
  body?: Record<string, unknown>;
  headers?: Record<string, string>;
  query?: Record<string, string>;
};

export type WithPassthrough<T> = T & { _passthrough?: Passthrough };


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/utils/change-case/change-case.spec.ts
Tamaño: 10929 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { describe, expect, it } from 'vitest';
import { constantCase, dotCase, kebabCase, pascalCase, pathCase, sentenceCase, snakeCase, trainCase } from './index';

const stubPrimitiveObject = {
  primitiveString: 'string',
  primitiveNumber: 1,
  primitiveBoolean: true,
};

const stub = {
  ...stubPrimitiveObject,
  listOfObjects: [stubPrimitiveObject, stubPrimitiveObject],
  nestedObject: {
    ...stubPrimitiveObject,
    listOfObjects: [stubPrimitiveObject, stubPrimitiveObject],
  },
  listOfListOfObjects: [[stubPrimitiveObject], [stubPrimitiveObject]],
};

describe('change case', () => {
  it('should change case to constant case', () => {
    expect(constantCase(stub)).toEqual({
      LIST_OF_LIST_OF_OBJECTS: [
        [
          {
            PRIMITIVE_BOOLEAN: true,
            PRIMITIVE_NUMBER: 1,
            PRIMITIVE_STRING: 'string',
          },
        ],
        [
          {
            PRIMITIVE_BOOLEAN: true,
            PRIMITIVE_NUMBER: 1,
            PRIMITIVE_STRING: 'string',
          },
        ],
      ],
      LIST_OF_OBJECTS: [
        {
          PRIMITIVE_BOOLEAN: true,
          PRIMITIVE_NUMBER: 1,
          PRIMITIVE_STRING: 'string',
        },
        {
          PRIMITIVE_BOOLEAN: true,
          PRIMITIVE_NUMBER: 1,
          PRIMITIVE_STRING: 'string',
        },
      ],
      NESTED_OBJECT: {
        LIST_OF_OBJECTS: [
          {
            PRIMITIVE_BOOLEAN: true,
            PRIMITIVE_NUMBER: 1,
            PRIMITIVE_STRING: 'string',
          },
          {
            PRIMITIVE_BOOLEAN: true,
            PRIMITIVE_NUMBER: 1,
            PRIMITIVE_STRING: 'string',
          },
        ],
        PRIMITIVE_BOOLEAN: true,
        PRIMITIVE_NUMBER: 1,
        PRIMITIVE_STRING: 'string',
      },
      PRIMITIVE_BOOLEAN: true,
      PRIMITIVE_NUMBER: 1,
      PRIMITIVE_STRING: 'string',
    });
  });

  it('should change case to dot case', () => {
    expect(dotCase(stub)).toEqual({
      'list.of.list.of.objects': [
        [
          {
            'primitive.boolean': true,
            'primitive.number': 1,
            'primitive.string': 'string',
          },
        ],
        [
          {
            'primitive.boolean': true,
            'primitive.number': 1,
            'primitive.string': 'string',
          },
        ],
      ],
      'list.of.objects': [
        {
          'primitive.boolean': true,
          'primitive.number': 1,
          'primitive.string': 'string',
        },
        {
          'primitive.boolean': true,
          'primitive.number': 1,
          'primitive.string': 'string',
        },
      ],
      'nested.object': {
        'list.of.objects': [
          {
            'primitive.boolean': true,
            'primitive.number': 1,
            'primitive.string': 'string',
          },
          {
            'primitive.boolean': true,
            'primitive.number': 1,
            'primitive.string': 'string',
          },
        ],
        'primitive.boolean': true,
        'primitive.number': 1,
        'primitive.string': 'string',
      },
      'primitive.boolean': true,
      'primitive.number': 1,
      'primitive.string': 'string',
    });
  });

  it('should change case to train case', () => {
    expect(trainCase(stub)).toEqual({
      'List-Of-List-Of-Objects': [
        [
          {
            'Primitive-Boolean': true,
            'Primitive-Number': 1,
            'Primitive-String': 'string',
          },
        ],
        [
          {
            'Primitive-Boolean': true,
            'Primitive-Number': 1,
            'Primitive-String': 'string',
          },
        ],
      ],
      'List-Of-Objects': [
        {
          'Primitive-Boolean': true,
          'Primitive-Number': 1,
          'Primitive-String': 'string',
        },
        {
          'Primitive-Boolean': true,
          'Primitive-Number': 1,
          'Primitive-String': 'string',
        },
      ],
      'Nested-Object': {
        'List-Of-Objects': [
          {
            'Primitive-Boolean': true,
            'Primitive-Number': 1,
            'Primitive-String': 'string',
          },
          {
            'Primitive-Boolean': true,
            'Primitive-Number': 1,
            'Primitive-String': 'string',
          },
        ],
        'Primitive-Boolean': true,
        'Primitive-Number': 1,
        'Primitive-String': 'string',
      },
      'Primitive-Boolean': true,
      'Primitive-Number': 1,
      'Primitive-String': 'string',
    });
  });

  it('should change case to kebab case', () => {
    expect(kebabCase(stub)).toEqual({
      'list-of-list-of-objects': [
        [
          {
            'primitive-boolean': true,
            'primitive-number': 1,
            'primitive-string': 'string',
          },
        ],
        [
          {
            'primitive-boolean': true,
            'primitive-number': 1,
            'primitive-string': 'string',
          },
        ],
      ],
      'list-of-objects': [
        {
          'primitive-boolean': true,
          'primitive-number': 1,
          'primitive-string': 'string',
        },
        {
          'primitive-boolean': true,
          'primitive-number': 1,
          'primitive-string': 'string',
        },
      ],
      'nested-object': {
        'list-of-objects': [
          {
            'primitive-boolean': true,
            'primitive-number': 1,
            'primitive-string': 'string',
          },
          {
            'primitive-boolean': true,
            'primitive-number': 1,
            'primitive-string': 'string',
          },
        ],
        'primitive-boolean': true,
        'primitive-number': 1,
        'primitive-string': 'string',
      },
      'primitive-boolean': true,
      'primitive-number': 1,
      'primitive-string': 'string',
    });
  });

  it('should change case to pascal case', () => {
    expect(pascalCase(stub)).toEqual({
      ListOfListOfObjects: [
        [
          {
            PrimitiveBoolean: true,
            PrimitiveNumber: 1,
            PrimitiveString: 'string',
          },
        ],
        [
          {
            PrimitiveBoolean: true,
            PrimitiveNumber: 1,
            PrimitiveString: 'string',
          },
        ],
      ],
      ListOfObjects: [
        {
          PrimitiveBoolean: true,
          PrimitiveNumber: 1,
          PrimitiveString: 'string',
        },
        {
          PrimitiveBoolean: true,
          PrimitiveNumber: 1,
          PrimitiveString: 'string',
        },
      ],
      NestedObject: {
        ListOfObjects: [
          {
            PrimitiveBoolean: true,
            PrimitiveNumber: 1,
            PrimitiveString: 'string',
          },
          {
            PrimitiveBoolean: true,
            PrimitiveNumber: 1,
            PrimitiveString: 'string',
          },
        ],
        PrimitiveBoolean: true,
        PrimitiveNumber: 1,
        PrimitiveString: 'string',
      },
      PrimitiveBoolean: true,
      PrimitiveNumber: 1,
      PrimitiveString: 'string',
    });
  });

  it('should change case to path case', () => {
    expect(pathCase(stub)).toEqual({
      'list/of/list/of/objects': [
        [
          {
            'primitive/boolean': true,
            'primitive/number': 1,
            'primitive/string': 'string',
          },
        ],
        [
          {
            'primitive/boolean': true,
            'primitive/number': 1,
            'primitive/string': 'string',
          },
        ],
      ],
      'list/of/objects': [
        {
          'primitive/boolean': true,
          'primitive/number': 1,
          'primitive/string': 'string',
        },
        {
          'primitive/boolean': true,
          'primitive/number': 1,
          'primitive/string': 'string',
        },
      ],
      'nested/object': {
        'list/of/objects': [
          {
            'primitive/boolean': true,
            'primitive/number': 1,
            'primitive/string': 'string',
          },
          {
            'primitive/boolean': true,
            'primitive/number': 1,
            'primitive/string': 'string',
          },
        ],
        'primitive/boolean': true,
        'primitive/number': 1,
        'primitive/string': 'string',
      },
      'primitive/boolean': true,
      'primitive/number': 1,
      'primitive/string': 'string',
    });
  });

  it('should change case to sentence case', () => {
    expect(sentenceCase(stub)).toEqual({
      Listoflistofobjects: [
        [
          {
            Primitiveboolean: true,
            Primitivenumber: 1,
            Primitivestring: 'string',
          },
        ],
        [
          {
            Primitiveboolean: true,
            Primitivenumber: 1,
            Primitivestring: 'string',
          },
        ],
      ],
      Listofobjects: [
        {
          Primitiveboolean: true,
          Primitivenumber: 1,
          Primitivestring: 'string',
        },
        {
          Primitiveboolean: true,
          Primitivenumber: 1,
          Primitivestring: 'string',
        },
      ],
      Nestedobject: {
        Listofobjects: [
          {
            Primitiveboolean: true,
            Primitivenumber: 1,
            Primitivestring: 'string',
          },
          {
            Primitiveboolean: true,
            Primitivenumber: 1,
            Primitivestring: 'string',
          },
        ],
        Primitiveboolean: true,
        Primitivenumber: 1,
        Primitivestring: 'string',
      },
      Primitiveboolean: true,
      Primitivenumber: 1,
      Primitivestring: 'string',
    });
  });

  it('should change case to snake case', () => {
    expect(snakeCase(stub)).toEqual({
      list_of_list_of_objects: [
        [
          {
            primitive_boolean: true,
            primitive_number: 1,
            primitive_string: 'string',
          },
        ],
        [
          {
            primitive_boolean: true,
            primitive_number: 1,
            primitive_string: 'string',
          },
        ],
      ],
      list_of_objects: [
        {
          primitive_boolean: true,
          primitive_number: 1,
          primitive_string: 'string',
        },
        {
          primitive_boolean: true,
          primitive_number: 1,
          primitive_string: 'string',
        },
      ],
      nested_object: {
        list_of_objects: [
          {
            primitive_boolean: true,
            primitive_number: 1,
            primitive_string: 'string',
          },
          {
            primitive_boolean: true,
            primitive_number: 1,
            primitive_string: 'string',
          },
        ],
        primitive_boolean: true,
        primitive_number: 1,
        primitive_string: 'string',
      },
      primitive_boolean: true,
      primitive_number: 1,
      primitive_string: 'string',
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - stub({
  ...stubPrimitiveObject,
  listOfObjects: [stubPrimitiveObject, stubPrimitiveObject],
  nestedObj...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/packages/providers/src/utils/change-case/functions.ts
Tamaño: 7778 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

// Regexps involved with splitting words in various case formats.
const SPLIT_LOWER_UPPER_REGEXP = /([\p{Ll}\d])(\p{Lu})/gu;
const SPLIT_UPPER_UPPER_REGEXP = /(\p{Lu})([\p{Lu}][\p{Ll}])/gu;

// Regexp involved with stripping non-word characters from the result.
const DEFAULT_STRIP_REGEXP = /[^\p{L}\d]+/giu;

// The replacement value for splits.
const SPLIT_REPLACE_VALUE = '$1\0$2';

// The default characters to keep after transforming case.
const DEFAULT_PREFIX_SUFFIX_CHARACTERS = '';

/**
 * Supported locale values. Use `false` to ignore locale.
 * Defaults to `undefined`, which uses the host environment.
 */
export type Locale = string[] | string | false | undefined;

/**
 * Options used for converting strings to any case.
 */
export interface IOptions {
  locale?: Locale;
  split?: (value: string) => string[];
  delimiter?: string;
  prefixCharacters?: string;
  suffixCharacters?: string;
  keyCaseTransformer?: (key: string) => string;
  depth?: number;
}

/**
 * Options used for converting strings to pascal/camel case.
 */
export interface IPascalCaseOptions extends IOptions {
  mergeAmbiguousCharacters?: boolean;
}

/**
 * Split any cased input strings into an array of words.
 */
export function split(value: string): string[] {
  let result = value.trim();

  result = result
    .replace(SPLIT_LOWER_UPPER_REGEXP, SPLIT_REPLACE_VALUE)
    .replace(SPLIT_UPPER_UPPER_REGEXP, SPLIT_REPLACE_VALUE);

  result = result.replace(DEFAULT_STRIP_REGEXP, '\0');

  let start = 0;
  let end = result.length;

  // Trim the delimiter from around the output string.
  while (result.charAt(start) === '\0') start += 1;
  if (start === end) return [];
  while (result.charAt(end - 1) === '\0') end -= 1;

  return result.slice(start, end).split(/\0/g);
}

/**
 * Convert a string to space separated lower case (`foo bar`).
 */
export function noCaseTransformer(input: string, options?: IOptions): string {
  const { prefix, words, suffix } = splitPrefixSuffix(input, options);

  return prefix + words.map(lowerFactory(options?.locale)).join(options?.delimiter ?? ' ') + suffix;
}

/**
 * Convert a string to camel case (`fooBar`).
 */
export function camelCaseTransformer(input: string, options?: IPascalCaseOptions): string {
  const { prefix, words, suffix } = splitPrefixSuffix(input, options);
  const lower = lowerFactory(options?.locale);
  const upper = upperFactory(options?.locale);
  const transform = options?.mergeAmbiguousCharacters
    ? capitalCaseTransformFactory(lower, upper)
    : pascalCaseTransformFactory(lower, upper);

  return (
    prefix +
    words
      .map((word, index) => {
        if (index === 0) return lower(word);

        return transform(word, index);
      })
      .join(options?.delimiter ?? '') +
    suffix
  );
}

/**
 * Convert a string to pascal case (`FooBar`).
 */
export function pascalCaseTransformer(input: string, options?: IPascalCaseOptions): string {
  const { prefix, words, suffix } = splitPrefixSuffix(input, options);
  const lower = lowerFactory(options?.locale);
  const upper = upperFactory(options?.locale);
  const transform = options?.mergeAmbiguousCharacters
    ? capitalCaseTransformFactory(lower, upper)
    : pascalCaseTransformFactory(lower, upper);

  return prefix + words.map(transform).join(options?.delimiter ?? '') + suffix;
}

/**
 * Convert a string to pascal snake case (`Foo_Bar`).
 */
export function pascalSnakeCaseTransformer(input: string, options?: IOptions): string {
  return capitalCaseTransformer(input, { delimiter: '_', ...options });
}

/**
 * Convert a string to capital case (`Foo Bar`).
 */
export function capitalCaseTransformer(input: string, options?: IOptions): string {
  const { prefix, words, suffix } = splitPrefixSuffix(input, options);
  const lower = lowerFactory(options?.locale);
  const upper = upperFactory(options?.locale);

  return prefix + words.map(capitalCaseTransformFactory(lower, upper)).join(options?.delimiter ?? '') + suffix;
}

/**
 * Convert a string to constant case (`FOO_BAR`).
 */
export function constantCaseTransformer(input: string, options?: IOptions): string {
  const { prefix, words, suffix } = splitPrefixSuffix(input, options);

  return prefix + words.map(upperFactory(options?.locale)).join(options?.delimiter ?? '_') + suffix;
}

/**
 * Convert a string to dot case (`foo.bar`).
 */
export function dotCaseTransformer(input: string, options?: IOptions): string {
  return noCaseTransformer(input, { delimiter: '.', ...options });
}

/**
 * Convert a string to kebab case (`foo-bar`).
 */
export function kebabCaseTransformer(input: string, options?: IOptions): string {
  return noCaseTransformer(input, { delimiter: '-', ...options });
}

/**
 * Convert a string to path case (`foo/bar`).
 */
export function pathCaseTransformer(input: string, options?: IOptions): string {
  return noCaseTransformer(input, { delimiter: '/', ...options });
}

/**
 * Convert a string to path case (`Foo bar`).
 */
export function sentenceCaseTransformer(input: string, options?: IOptions): string {
  const { prefix, words, suffix } = splitPrefixSuffix(input, options);
  const lower = lowerFactory(options?.locale);
  const upper = upperFactory(options?.locale);
  const transform = capitalCaseTransformFactory(lower, upper);

  return (
    prefix +
    words
      .map((word, index) => {
        if (index === 0) return transform(word);

        return lower(word);
      })
      .join(options?.delimiter ?? '') +
    suffix
  );
}

/**
 * Convert a string to snake case (`foo_bar`).
 */
export function snakeCaseTransformer(input: string, options?: IOptions): string {
  return noCaseTransformer(input, { delimiter: '_', ...options });
}

/**
 * Convert a string to header case (`Foo-Bar`).
 */
export function trainCaseTransformer(input: string, options?: IOptions): string {
  return capitalCaseTransformer(input, { delimiter: '-', ...options });
}

function lowerFactory(locale: Locale): (input: string) => string {
  return locale === false ? (input: string) => input.toLowerCase() : (input: string) => input.toLocaleLowerCase(locale);
}

function upperFactory(locale: Locale): (input: string) => string {
  return locale === false ? (input: string) => input.toUpperCase() : (input: string) => input.toLocaleUpperCase(locale);
}

function capitalCaseTransformFactory(
  lower: (input: string) => string,
  upper: (input: string) => string
): (word: string) => string {
  return (word: string) => `${upper(word[0])}${lower(word.slice(1))}`;
}

function pascalCaseTransformFactory(
  lower: (input: string) => string,
  upper: (input: string) => string
): (word: string, index: number) => string {
  return (word: string, index: number) => {
    const char0 = word[0];
    const initial = index > 0 && char0 >= '0' && char0 <= '9' ? `_${char0}` : upper(char0);

    return initial + lower(word.slice(1));
  };
}

function splitPrefixSuffix(
  input: string,
  options: IOptions = {}
): {
  prefix: string;
  words: string[];
  suffix: string;
} {
  const splitFn = options.split ?? split;
  const prefixCharacters = options.prefixCharacters ?? DEFAULT_PREFIX_SUFFIX_CHARACTERS;
  const suffixCharacters = options.suffixCharacters ?? DEFAULT_PREFIX_SUFFIX_CHARACTERS;
  let prefixIndex = 0;
  let suffixIndex = input.length;

  while (prefixIndex < input.length) {
    const char = input.charAt(prefixIndex);
    if (!prefixCharacters.includes(char)) break;
    prefixIndex += 1;
  }

  while (suffixIndex > prefixIndex) {
    const index = suffixIndex - 1;
    const char = input.charAt(index);
    if (!suffixCharacters.includes(char)) break;
    suffixIndex = index;
  }

  return {
    prefix: input.slice(0, prefixIndex),
    words: splitFn(input.slice(prefixIndex, suffixIndex)),
    suffix: input.slice(suffixIndex),
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

