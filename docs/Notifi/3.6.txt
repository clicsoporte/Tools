### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/snooze-notification/snooze-notification.usecase.ts
Tamaño: 6822 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { HttpException, HttpStatus, Injectable, InternalServerErrorException, NotFoundException } from '@nestjs/common';
import {
  AnalyticsService,
  CreateExecutionDetails,
  CreateExecutionDetailsCommand,
  DetailEnum,
  PinoLogger,
  StandardQueueService,
} from '@novu/application-generic';
import {
  CommunityOrganizationRepository,
  JobEntity,
  JobRepository,
  MessageEntity,
  MessageRepository,
  OrganizationEntity,
} from '@novu/dal';
import {
  ApiServiceLevelEnum,
  ChannelTypeEnum,
  ExecutionDetailsSourceEnum,
  ExecutionDetailsStatusEnum,
  FeatureNameEnum,
  getFeatureForTierAsNumber,
  JobStatusEnum,
} from '@novu/shared';
import { v4 as uuidv4 } from 'uuid';
import { AnalyticsEventsEnum } from '../../utils';
import { InboxNotification } from '../../utils/types';
import { MarkNotificationAsCommand } from '../mark-notification-as/mark-notification-as.command';
import { MarkNotificationAs } from '../mark-notification-as/mark-notification-as.usecase';
import { SnoozeNotificationCommand } from './snooze-notification.command';

@Injectable()
export class SnoozeNotification {
  private readonly RETRY_ATTEMPTS = 3;

  constructor(
    private readonly logger: PinoLogger,
    private messageRepository: MessageRepository,
    private jobRepository: JobRepository,
    private standardQueueService: StandardQueueService,
    private organizationRepository: CommunityOrganizationRepository,
    private createExecutionDetails: CreateExecutionDetails,
    private markNotificationAs: MarkNotificationAs,
    private analyticsService: AnalyticsService
  ) {}

  public async execute(command: SnoozeNotificationCommand): Promise<InboxNotification> {
    const snoozeDurationMs = this.calculateDelayInMs(command.snoozeUntil);
    await this.validateSnoozeDuration(command, snoozeDurationMs);
    const notification = await this.findNotification(command);

    try {
      let scheduledJob = {} as JobEntity;
      let snoozedNotification = {} as InboxNotification;

      await this.messageRepository.withTransaction(async () => {
        scheduledJob = await this.createScheduledUnsnoozeJob(notification, snoozeDurationMs);
        snoozedNotification = await this.markNotificationAsSnoozed(command);
        await this.enqueueJob(scheduledJob, snoozeDurationMs);
      });

      // fire and forget
      this.createExecutionDetails
        .execute(
          CreateExecutionDetailsCommand.create({
            ...CreateExecutionDetailsCommand.getDetailsFromJob(scheduledJob),
            detail: DetailEnum.MESSAGE_SNOOZED,
            source: ExecutionDetailsSourceEnum.INTERNAL,
            status: ExecutionDetailsStatusEnum.PENDING,
            isTest: false,
            isRetry: false,
          })
        )
        .catch((error) => {
          this.logger.error({ err: error }, 'Failed to create execution details');
        });

      this.analyticsService.mixpanelTrack(AnalyticsEventsEnum.SNOOZE_NOTIFICATION, '', {
        _organization: command.organizationId,
        _notification: command.notificationId,
        _subscriber: notification._subscriberId,
        snoozeUntil: command.snoozeUntil,
      });

      return snoozedNotification;
    } catch (error) {
      this.logger.error({ error }, 'Failed to snooze notification');
      throw new InternalServerErrorException(`Failed to snooze notification: ${error.message}`);
    }
  }

  public async enqueueJob(job: JobEntity, delay: number) {
    this.logger.info({ jobId: job._id, delay }, 'Adding snooze job to Standard Queue');

    const jobData = {
      _environmentId: job._environmentId,
      _id: job._id,
      _organizationId: job._organizationId,
      _userId: job._userId,
    };

    await this.standardQueueService.add({
      name: job._id,
      data: jobData,
      groupId: job._organizationId,
      options: { delay, attempts: this.RETRY_ATTEMPTS, backoff: { type: 'exponential', delay: 5000 } },
    });
  }

  private async validateSnoozeDuration(command: SnoozeNotificationCommand, snoozeDurationMs: number) {
    const organization = await this.getOrganization(command.organizationId);

    const tierLimitMs = getFeatureForTierAsNumber(
      FeatureNameEnum.PLATFORM_MAX_SNOOZE_DURATION,
      organization?.apiServiceLevel || ApiServiceLevelEnum.FREE,
      true
    );

    if (snoozeDurationMs > tierLimitMs) {
      throw new HttpException(
        {
          message: 'Snooze Duration Limit Exceeded',
          reason:
            'The snooze duration you selected exceeds your current plan limit. ' +
            'Please upgrade your plan for extended snooze durations.',
        },
        HttpStatus.PAYMENT_REQUIRED
      );
    }
  }

  private calculateDelayInMs(snoozeUntil: Date): number {
    return snoozeUntil.getTime() - new Date().getTime();
  }

  private async getOrganization(organizationId: string): Promise<OrganizationEntity> {
    const organization = await this.organizationRepository.findOne({
      _id: organizationId,
    });

    if (!organization) {
      throw new NotFoundException(`Organization id: '${organizationId}' not found`);
    }

    return organization;
  }

  private async findNotification(command: SnoozeNotificationCommand): Promise<MessageEntity> {
    const message = await this.messageRepository.findOne({
      _environmentId: command.environmentId,
      channel: ChannelTypeEnum.IN_APP,
      _id: command.notificationId,
      contextKeys: command.contextKeys,
    });

    if (!message) {
      throw new NotFoundException(`Notification id: '${command.notificationId}' not found`);
    }

    return message;
  }

  private async createScheduledUnsnoozeJob(notification: MessageEntity, delay: number): Promise<JobEntity> {
    const originalJob = await this.jobRepository.findOne({
      _id: notification._jobId,
      _environmentId: notification._environmentId,
    });

    if (!originalJob) {
      throw new InternalServerErrorException(`Job id: '${notification._jobId}' not found`);
    }

    const newJobData = {
      ...originalJob,
      transactionId: uuidv4(),
      status: JobStatusEnum.PENDING,
      delay,
      createdAt: Date.now().toString(),
      id: JobRepository.createObjectId(),
      _parentId: null,
      payload: {
        ...originalJob.payload,
        unsnooze: true,
      },
    };

    return this.jobRepository.create(newJobData);
  }

  private async markNotificationAsSnoozed(command: SnoozeNotificationCommand) {
    return this.markNotificationAs.execute(
      MarkNotificationAsCommand.create({
        environmentId: command.environmentId,
        organizationId: command.organizationId,
        subscriberId: command.subscriberId,
        notificationId: command.notificationId,
        snoozedUntil: command.snoozeUntil,
        contextKeys: command.contextKeys,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - snoozedNotification({} as InboxNotification;

      await this.messageRepository.withTransaction(async ())
 - snoozedNotification(await this.markNotificationAsSnoozed(command);
        await this.enqueueJob(scheduledJob, snoozeDur...)
Declaraciones 'export' encontradas:
- export class SnoozeNotification

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/unsnooze-notification/unsnooze-notification.command.ts
Tamaño: 287 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsMongoId } from 'class-validator';
import { EnvironmentWithSubscriber } from '../../../shared/commands/project.command';

export class UnsnoozeNotificationCommand extends EnvironmentWithSubscriber {
  @IsDefined()
  @IsMongoId()
  readonly notificationId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UnsnoozeNotificationCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/unsnooze-notification/unsnooze-notification.spec.ts
Tamaño: 6506 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { NotFoundException } from '@nestjs/common';
import { CreateExecutionDetails, CreateExecutionDetailsCommand, PinoLogger } from '@novu/application-generic';
import { JobEntity, JobRepository, MessageEntity, MessageRepository } from '@novu/dal';
import { ChannelTypeEnum, JobStatusEnum, SeverityLevelEnum } from '@novu/shared';
import { expect } from 'chai';
import sinon from 'sinon';
import { InboxNotification } from '../../utils/types';
import { MarkNotificationAsCommand } from '../mark-notification-as/mark-notification-as.command';
import { MarkNotificationAs } from '../mark-notification-as/mark-notification-as.usecase';
import { UnsnoozeNotificationCommand } from './unsnooze-notification.command';
import { UnsnoozeNotification } from './unsnooze-notification.usecase';

describe('UnsnoozeNotification', () => {
  const validNotificationId = '507f1f77bcf86cd799439011';
  const validEnvId = '507f1f77bcf86cd799439012';
  const validOrgId = '507f1f77bcf86cd799439013';
  const validJobId = '507f1f77bcf86cd799439014';
  const validSubscriberId = '507f1f77bcf86cd799439015';
  const validNotificationId2 = '507f1f77bcf86cd799439016';

  let unsnoozeNotification: UnsnoozeNotification;
  let loggerMock: sinon.SinonStubbedInstance<PinoLogger>;
  let messageRepositoryMock: sinon.SinonStubbedInstance<MessageRepository>;
  let jobRepositoryMock: sinon.SinonStubbedInstance<JobRepository>;
  let createExecutionDetailsMock: sinon.SinonStubbedInstance<CreateExecutionDetails>;
  let markNotificationAsMock: sinon.SinonStubbedInstance<MarkNotificationAs>;

  const snoozedUntil = new Date();
  snoozedUntil.setHours(snoozedUntil.getHours() + 1);

  const mockMessage = {
    _id: validNotificationId,
    _jobId: validJobId,
    _environmentId: validEnvId,
    channel: ChannelTypeEnum.IN_APP,
    _subscriberId: validSubscriberId,
    _notificationId: validNotificationId2,
    snoozedUntil,
  } as unknown as MessageEntity;

  const mockJob: JobEntity = {
    _id: validJobId,
    _environmentId: validEnvId,
    _organizationId: validOrgId,
    _userId: validSubscriberId,
    _notificationId: validNotificationId2,
    payload: {
      subscriberId: validSubscriberId,
      unsnooze: true,
    },
    transactionId: 'transaction-id',
    status: JobStatusEnum.PENDING,
    delay: 3600000,
  } as JobEntity;

  const mockNotification: InboxNotification = {
    id: validNotificationId,
    transactionId: 'transaction-id',
    body: 'Test notification content',
    to: {
      subscriberId: validSubscriberId,
      id: validSubscriberId,
    },
    isSeen: false,
    isRead: false,
    isArchived: false,
    isSnoozed: false,
    snoozedUntil: null,
    createdAt: new Date().toISOString(),
    channelType: ChannelTypeEnum.IN_APP,
    severity: SeverityLevelEnum.NONE,
  };

  beforeEach(() => {
    loggerMock = sinon.createStubInstance(PinoLogger);
    messageRepositoryMock = sinon.createStubInstance(MessageRepository);
    jobRepositoryMock = sinon.createStubInstance(JobRepository);
    createExecutionDetailsMock = sinon.createStubInstance(CreateExecutionDetails);
    markNotificationAsMock = sinon.createStubInstance(MarkNotificationAs);

    sinon.stub(MarkNotificationAsCommand, 'create').returns({
      environmentId: validEnvId,
      organizationId: validOrgId,
      subscriberId: validSubscriberId,
      notificationId: validNotificationId,
      snoozedUntil: null,
    } as MarkNotificationAsCommand);

    sinon.stub(CreateExecutionDetailsCommand, 'create').returns({} as any);
    sinon.stub(CreateExecutionDetailsCommand, 'getDetailsFromJob').returns({} as any);

    // @ts-expect-error Mocking the withTransaction method
    messageRepositoryMock.withTransaction = sinon.stub().callsFake((callback) => callback());

    unsnoozeNotification = new UnsnoozeNotification(
      loggerMock as any,
      messageRepositoryMock as any,
      jobRepositoryMock as any,
      markNotificationAsMock as any,
      createExecutionDetailsMock as any
    );

    jobRepositoryMock.findOneAndDelete.resolves(mockJob);
    markNotificationAsMock.execute.resolves(mockNotification);
    createExecutionDetailsMock.execute.resolves();
    messageRepositoryMock.findOne.resolves(mockMessage);
  });

  afterEach(() => {
    sinon.restore();
  });

  it('should throw NotFoundException when snoozed notification is not found', async () => {
    const command = createCommand();
    messageRepositoryMock.findOne.resolves(null);

    try {
      await unsnoozeNotification.execute(command);
      expect.fail('Should have thrown NotFoundException');
    } catch (err) {
      expect(err).to.be.instanceOf(NotFoundException);
    }
  });

  it('should successfully unsnooze a notification', async () => {
    const command = createCommand();

    const result = await unsnoozeNotification.execute(command);

    expect(result).to.deep.equal(mockNotification);
    expect(jobRepositoryMock.findOneAndDelete.calledOnce).to.be.true;
    expect(markNotificationAsMock.execute.calledOnce).to.be.true;

    // Verify that markNotificationAs was called with the correct args
    const markNotificationAsArgs = markNotificationAsMock.execute.firstCall.args[0];
    expect(markNotificationAsArgs).to.have.property('environmentId', validEnvId);
    expect(markNotificationAsArgs).to.have.property('subscriberId', validSubscriberId);
    expect(markNotificationAsArgs).to.have.property('notificationId', validNotificationId);
    expect(markNotificationAsArgs).to.have.property('snoozedUntil', null);

    // Verify that createExecutionDetails was called
    expect(createExecutionDetailsMock.execute.calledOnce).to.be.true;
  });

  it('should handle missing scheduled job gracefully', async () => {
    const command = createCommand();
    jobRepositoryMock.findOneAndDelete.resolves(null);

    const result = await unsnoozeNotification.execute(command);

    // Verify we still get a result even without a job
    expect(result).to.deep.equal(mockNotification);
    expect(jobRepositoryMock.findOneAndDelete.calledOnce).to.be.true;
    expect(markNotificationAsMock.execute.calledOnce).to.be.true;
    expect(createExecutionDetailsMock.execute.called).to.be.false;
    expect(loggerMock.error.calledOnce).to.be.true;
  });

  function createCommand(): UnsnoozeNotificationCommand {
    return {
      environmentId: validEnvId,
      organizationId: validOrgId,
      subscriberId: validSubscriberId,
      notificationId: validNotificationId,
    } as UnsnoozeNotificationCommand;
  }
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - createCommand()
Asignaciones con arrow functions encontradas (posibles funciones):
 - InboxNotification({
    id: validNotificationId,
    transactionId: 'transaction-id',
    body: 'Test notification con...)
 - withTransaction(sinon.stub().callsFake((callback))
 - unsnoozeNotification(new UnsnoozeNotification(
      loggerMock as any,
      messageRepositoryMock as any,
      jobRepo...)
 - command(createCommand();
    messageRepositoryMock.findOne.resolves(null);

    try {
      await unsnoozeNo...)
 - markNotificationAsArgs(markNotificationAsMock.execute.firstCall.args[0];
    expect(markNotificationAsArgs).to.have.propert...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/unsnooze-notification/unsnooze-notification.usecase.ts
Tamaño: 3865 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, InternalServerErrorException, NotFoundException } from '@nestjs/common';
import {
  CreateExecutionDetails,
  CreateExecutionDetailsCommand,
  DetailEnum,
  PinoLogger,
} from '@novu/application-generic';
import { ChannelTypeEnum, JobEntity, JobRepository, JobStatusEnum, MessageRepository } from '@novu/dal';
import { ExecutionDetailsSourceEnum, ExecutionDetailsStatusEnum } from '@novu/shared';
import { InboxNotification } from '../../utils/types';
import { MarkNotificationAsCommand } from '../mark-notification-as/mark-notification-as.command';
import { MarkNotificationAs } from '../mark-notification-as/mark-notification-as.usecase';
import { UnsnoozeNotificationCommand } from './unsnooze-notification.command';

@Injectable()
export class UnsnoozeNotification {
  constructor(
    private readonly logger: PinoLogger,
    private messageRepository: MessageRepository,
    private jobRepository: JobRepository,
    private markNotificationAs: MarkNotificationAs,
    private createExecutionDetails: CreateExecutionDetails
  ) {}

  async execute(command: UnsnoozeNotificationCommand): Promise<InboxNotification> {
    const snoozedNotification = await this.messageRepository.findOne({
      _id: command.notificationId,
      _environmentId: command.environmentId,
      channel: ChannelTypeEnum.IN_APP,
      snoozedUntil: { $exists: true, $ne: null },
      contextKeys: command.contextKeys,
    });

    if (!snoozedNotification) {
      throw new NotFoundException(
        `Could not find a snoozed notification with id '${command.notificationId}'. ` +
          'The notification may not exist or may not be in a snoozed state.'
      );
    }

    try {
      return this.unsnoozeNotification(command, snoozedNotification._notificationId);
    } catch (error) {
      this.logger.error({ err: error }, `Failed to unsnooze notification: ${command.notificationId}`);
      throw new InternalServerErrorException(`Failed to unsnooze notification: ${error.message}`);
    }
  }

  private async unsnoozeNotification(
    command: UnsnoozeNotificationCommand,
    notificationId: string
  ): Promise<InboxNotification> {
    let scheduledJob: JobEntity | null = null;
    let unsnoozedNotification!: InboxNotification;

    await this.messageRepository.withTransaction(async () => {
      scheduledJob = await this.jobRepository.findOneAndDelete({
        _notificationId: notificationId,
        _environmentId: command.environmentId,
        delay: { $exists: true },
        status: JobStatusEnum.PENDING,
        'payload.unsnooze': true,
      });

      unsnoozedNotification = await this.markNotificationAs.execute(
        MarkNotificationAsCommand.create({
          environmentId: command.environmentId,
          organizationId: command.organizationId,
          subscriberId: command.subscriberId,
          notificationId: command.notificationId,
          snoozedUntil: null,
          contextKeys: command.contextKeys,
        })
      );
    });

    if (scheduledJob) {
      // fire and forget
      this.createExecutionDetails
        .execute(
          CreateExecutionDetailsCommand.create({
            ...CreateExecutionDetailsCommand.getDetailsFromJob(scheduledJob),
            detail: DetailEnum.MESSAGE_UNSNOOZED,
            source: ExecutionDetailsSourceEnum.INTERNAL,
            status: ExecutionDetailsStatusEnum.SUCCESS,
            isTest: false,
            isRetry: false,
          })
        )
        .catch((error) => {
          this.logger.error({ err: error }, 'Failed to create execution details');
        });
    } else {
      this.logger.error(
        `Could not find a scheduled job for snoozed notification '${notificationId}'. ` +
          'The notification may have already been unsnoozed or the scheduled job was deleted.'
      );
    }

    return unsnoozedNotification;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - null(null;
    let unsnoozedNotification!: InboxNotification;

    await this.messageRepository.withTrans...)
 - unsnoozedNotification(await this.markNotificationAs.execute(
        MarkNotificationAsCommand.create({
          environm...)
Declaraciones 'export' encontradas:
- export class UnsnoozeNotification

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/update-all-notifications/update-all-notifications.command.ts
Tamaño: 809 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Type } from 'class-transformer';
import { IsArray, IsBoolean, IsDefined, IsOptional, IsString, ValidateNested } from 'class-validator';

import { EnvironmentWithSubscriber } from '../../../shared/commands/project.command';
import { NotificationFilter } from '../../utils/types';

class Filter implements NotificationFilter {
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  tags?: string[];

  @IsOptional()
  @IsBoolean()
  read?: boolean;

  @IsOptional()
  @IsBoolean()
  archived?: boolean;

  @IsOptional()
  @IsString()
  data?: string;
}

export class UpdateAllNotificationsCommand extends EnvironmentWithSubscriber {
  @IsDefined()
  @ValidateNested()
  @Type(() => Filter)
  readonly from: Filter;

  @IsDefined()
  @ValidateNested()
  @Type(() => Filter)
  readonly to: Filter;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateAllNotificationsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/update-all-notifications/update-all-notifications.spec.ts
Tamaño: 6794 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException } from '@nestjs/common';
import {
  AnalyticsService,
  buildFeedKey,
  buildMessageCountKey,
  InvalidateCacheService,
  SendWebhookMessage,
  WebSocketsQueueService,
} from '@novu/application-generic';
import { EnvironmentRepository, MessageRepository } from '@novu/dal';
import { ChannelCTATypeEnum, ChannelTypeEnum, WebSocketEventEnum } from '@novu/shared';
import { expect } from 'chai';
import sinon from 'sinon';
import { GetSubscriber } from '../../../subscribers/usecases/get-subscriber';
import { AnalyticsEventsEnum } from '../../utils';
import type { UpdateAllNotificationsCommand } from './update-all-notifications.command';
import { UpdateAllNotifications } from './update-all-notifications.usecase';

const mockSubscriber: any = { _id: '6447aff5d89122e250412c79', subscriberId: '6447aff5d89122e250412c79' };
const mockEnvironment: any = {
  _id: '6447aff3d89122e250412c23',
  webhookAppId: 'webhook-app-id',
  identifier: 'test-env',
};

describe('UpdateAllNotifications', () => {
  let updateAllNotifications: UpdateAllNotifications;
  let invalidateCacheMock: sinon.SinonStubbedInstance<InvalidateCacheService>;
  let getSubscriberMock: sinon.SinonStubbedInstance<GetSubscriber>;
  let analyticsServiceMock: sinon.SinonStubbedInstance<AnalyticsService>;
  let messageRepositoryMock: sinon.SinonStubbedInstance<MessageRepository>;
  let webSocketsQueueServiceMock: sinon.SinonStubbedInstance<WebSocketsQueueService>;
  let sendWebhookMessageMock: sinon.SinonStubbedInstance<SendWebhookMessage>;
  let environmentRepositoryMock: sinon.SinonStubbedInstance<EnvironmentRepository>;
  const mockMessage: any = [
    {
      _id: '_id',
      content: '',
      read: false,
      archived: false,
      createdAt: new Date(),
      lastReadAt: new Date(),
      channel: ChannelTypeEnum.IN_APP,
      subscriber: mockSubscriber,
      actorSubscriber: mockSubscriber,
      cta: {
        type: ChannelCTATypeEnum.REDIRECT,
        data: {},
      },
    },
  ];

  beforeEach(() => {
    invalidateCacheMock = sinon.createStubInstance(InvalidateCacheService);
    getSubscriberMock = sinon.createStubInstance(GetSubscriber);
    analyticsServiceMock = sinon.createStubInstance(AnalyticsService);
    messageRepositoryMock = sinon.createStubInstance(MessageRepository);
    webSocketsQueueServiceMock = sinon.createStubInstance(WebSocketsQueueService);
    sendWebhookMessageMock = sinon.createStubInstance(SendWebhookMessage);
    environmentRepositoryMock = sinon.createStubInstance(EnvironmentRepository);
    updateAllNotifications = new UpdateAllNotifications(
      invalidateCacheMock as any,
      getSubscriberMock as any,
      analyticsServiceMock as any,
      messageRepositoryMock as any,
      webSocketsQueueServiceMock as any,
      sendWebhookMessageMock as any,
      environmentRepositoryMock as any
    );
  });

  afterEach(() => {
    sinon.restore();
  });

  it('should throw exception when subscriber is not found', async () => {
    const command: UpdateAllNotificationsCommand = {
      environmentId: '6447aff3d89122e250412c23',
      organizationId: '6447aff3d89122e250412c1d',
      subscriberId: '6447aff5d89122e250412c79',
      from: { read: true },
      to: { archived: true },
    };

    getSubscriberMock.execute.resolves(undefined);

    try {
      await updateAllNotifications.execute(command);
    } catch (error) {
      expect(error).to.be.instanceOf(BadRequestException);
      expect(error.message).to.equal(`Subscriber with id: ${command.subscriberId} is not found.`);
    }
  });

  it('should update all read to archived', async () => {
    const command: UpdateAllNotificationsCommand = {
      environmentId: '6447aff3d89122e250412c23',
      organizationId: '6447aff3d89122e250412c1d',
      subscriberId: '6447aff5d89122e250412c79',
      from: { read: true },
      to: { archived: true },
    };

    getSubscriberMock.execute.resolves(mockSubscriber);
    messageRepositoryMock.updateMessagesFromToStatus.resolves(mockMessage);
    environmentRepositoryMock.findOne.resolves(mockEnvironment);
    invalidateCacheMock.invalidateQuery.resolves();
    analyticsServiceMock.track.resolves();
    webSocketsQueueServiceMock.add.resolves();

    await updateAllNotifications.execute(command);

    expect(messageRepositoryMock.updateMessagesFromToStatus.calledOnce).to.be.true;
    expect(messageRepositoryMock.updateMessagesFromToStatus.firstCall.args).to.deep.equal([
      {
        environmentId: command.environmentId,
        subscriberId: mockSubscriber._id,
        from: command.from,
        to: command.to,
        contextKeys: undefined,
      },
    ]);
  });

  it('should invalidate cache, send the analytics, send ws event', async () => {
    const command: UpdateAllNotificationsCommand = {
      environmentId: '6447aff3d89122e250412c23',
      organizationId: '6447aff3d89122e250412c1d',
      subscriberId: '6447aff5d89122e250412c79',
      from: { read: true },
      to: { archived: true },
    };

    getSubscriberMock.execute.resolves(mockSubscriber);
    messageRepositoryMock.updateMessagesFromToStatus.resolves(mockMessage);
    environmentRepositoryMock.findOne.resolves(mockEnvironment);
    invalidateCacheMock.invalidateQuery.resolves();
    analyticsServiceMock.track.resolves();
    webSocketsQueueServiceMock.add.resolves();

    await updateAllNotifications.execute(command);

    expect(invalidateCacheMock.invalidateQuery.calledTwice).to.be.true;
    expect(invalidateCacheMock.invalidateQuery.firstCall.args).to.deep.equal([
      {
        key: buildFeedKey().invalidate({
          subscriberId: command.subscriberId,
          _environmentId: command.environmentId,
        }),
      },
    ]);
    expect(invalidateCacheMock.invalidateQuery.secondCall.args).to.deep.equal([
      {
        key: buildMessageCountKey().invalidate({
          subscriberId: command.subscriberId,
          _environmentId: command.environmentId,
        }),
      },
    ]);
    expect(analyticsServiceMock.track.calledOnce).to.be.true;
    expect(analyticsServiceMock.track.firstCall.args).to.deep.equal([
      AnalyticsEventsEnum.UPDATE_ALL_NOTIFICATIONS,
      '',
      {
        _organization: command.organizationId,
        _subscriberId: mockSubscriber._id,
        from: command.from,
        to: command.to,
        contextKeys: undefined,
      },
    ]);
    expect(webSocketsQueueServiceMock.add.calledOnce).to.be.true;
    expect(webSocketsQueueServiceMock.add.firstCall.args).to.deep.equal([
      {
        name: 'sendMessage',
        data: {
          event: WebSocketEventEnum.UNREAD,
          userId: mockSubscriber._id,
          _environmentId: command.environmentId,
        },
        groupId: mockSubscriber._organizationId,
      },
    ]);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - any({
  _id: '6447aff3d89122e250412c23',
  webhookAppId: 'webhook-app-id',
  identifier: 'test-env',
};
...)
 - any([
    {
      _id: '_id',
      content: '',
      read: false,
      archived: false,
      created...)
 - updateAllNotifications(new UpdateAllNotifications(
      invalidateCacheMock as any,
      getSubscriberMock as any,
      ...)
 - UpdateAllNotificationsCommand({
      environmentId: '6447aff3d89122e250412c23',
      organizationId: '6447aff3d89122e250412c1d',...)
 - UpdateAllNotificationsCommand({
      environmentId: '6447aff3d89122e250412c23',
      organizationId: '6447aff3d89122e250412c1d',...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/update-all-notifications/update-all-notifications.usecase.ts
Tamaño: 5874 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable } from '@nestjs/common';
import {
  AnalyticsService,
  buildFeedKey,
  buildMessageCountKey,
  InvalidateCacheService,
  messageWebhookMapper,
  SendWebhookMessage,
  WebSocketsQueueService,
} from '@novu/application-generic';
import { EnvironmentEntity, EnvironmentRepository, MessageEntity, MessageRepository } from '@novu/dal';
import { WebhookEventEnum, WebhookObjectTypeEnum, WebSocketEventEnum } from '@novu/shared';

import { GetSubscriber } from '../../../subscribers/usecases/get-subscriber';
import { AnalyticsEventsEnum } from '../../utils';
import { validateDataStructure } from '../../utils/validate-data';
import { UpdateAllNotificationsCommand } from './update-all-notifications.command';

@Injectable()
export class UpdateAllNotifications {
  constructor(
    private invalidateCache: InvalidateCacheService,
    private getSubscriber: GetSubscriber,
    private analyticsService: AnalyticsService,
    private messageRepository: MessageRepository,
    private webSocketsQueueService: WebSocketsQueueService,
    private sendWebhookMessage: SendWebhookMessage,
    private environmentRepository: EnvironmentRepository
  ) {}

  async execute(command: UpdateAllNotificationsCommand): Promise<void> {
    const subscriber = await this.getSubscriber.execute({
      environmentId: command.environmentId,
      organizationId: command.organizationId,
      subscriberId: command.subscriberId,
    });

    if (!subscriber) {
      throw new BadRequestException(`Subscriber with id: ${command.subscriberId} is not found.`);
    }

    let parsedData: unknown;
    if (command.from.data) {
      try {
        parsedData = JSON.parse(command.from.data);
        validateDataStructure(parsedData);
      } catch (error) {
        if (error instanceof BadRequestException) {
          throw error;
        }

        throw new BadRequestException('Invalid JSON format for data parameter');
      }
    }

    const fromField: Record<string, unknown> = {
      ...command.from,
    };

    if (parsedData) {
      fromField.data = parsedData;
    }

    const updatedMessages = await this.messageRepository.updateMessagesFromToStatus({
      environmentId: command.environmentId,
      subscriberId: subscriber._id,
      from: fromField,
      to: command.to,
      contextKeys: command.contextKeys,
    });

    await this.sendWebhookEvents(command, updatedMessages);

    await this.invalidateCache.invalidateQuery({
      key: buildFeedKey().invalidate({
        subscriberId: command.subscriberId,
        _environmentId: command.environmentId,
      }),
    });

    await this.invalidateCache.invalidateQuery({
      key: buildMessageCountKey().invalidate({
        subscriberId: command.subscriberId,
        _environmentId: command.environmentId,
      }),
    });

    this.analyticsService.track(AnalyticsEventsEnum.UPDATE_ALL_NOTIFICATIONS, '', {
      _organization: command.organizationId,
      _subscriberId: subscriber._id,
      from: command.from,
      to: command.to,
      contextKeys: command.contextKeys,
    });

    this.webSocketsQueueService.add({
      name: 'sendMessage',
      data: {
        event: WebSocketEventEnum.UNREAD,
        userId: subscriber._id,
        _environmentId: command.environmentId,
        ...(command.contextKeys && { contextKeys: command.contextKeys }),
      },
      groupId: subscriber._organizationId,
    });
  }

  private async sendWebhookEvents(command: UpdateAllNotificationsCommand, updatedMessages: MessageEntity[]) {
    const environment = await this.environmentRepository.findOne(
      {
        _id: command.environmentId,
      },
      'webhookAppId identifier'
    );
    if (!environment) {
      throw new Error(`Environment not found for id ${command.environmentId}`);
    }

    if (!environment.webhookAppId) return;

    const eventTypes: WebhookEventEnum[] = [];

    if (command.to.read !== undefined) {
      const eventType = command.to.read ? WebhookEventEnum.MESSAGE_READ : WebhookEventEnum.MESSAGE_UNREAD;
      eventTypes.push(eventType);
    }

    if (command.to.archived !== undefined) {
      const eventType = command.to.archived ? WebhookEventEnum.MESSAGE_ARCHIVED : WebhookEventEnum.MESSAGE_UNARCHIVED;
      eventTypes.push(eventType);
    }

    await this.processWebhooksInBatches(eventTypes, updatedMessages, command, environment);
  }

  private async processWebhooksInBatches(
    eventTypes: WebhookEventEnum[],
    messages: MessageEntity[],
    command: UpdateAllNotificationsCommand,
    environment: EnvironmentEntity
  ): Promise<void> {
    const BATCH_SIZE = 100;
    const messageChunks = this.chunkArray(messages, BATCH_SIZE);

    for (const messageChunk of messageChunks) {
      const webhookPromises: Promise<{ eventId: string } | undefined>[] = [];

      for (const eventType of eventTypes) {
        webhookPromises.push(...this.createWebhookPromises(eventType, messageChunk, command, environment));
      }

      await Promise.all(webhookPromises);
    }
  }

  private chunkArray<T>(array: T[], chunkSize: number): T[][] {
    const chunks: T[][] = [];
    for (let i = 0; i < array.length; i += chunkSize) {
      chunks.push(array.slice(i, i + chunkSize));
    }

    return chunks;
  }

  private createWebhookPromises(
    eventType: WebhookEventEnum,
    messages: MessageEntity[],
    command: UpdateAllNotificationsCommand,
    environment: EnvironmentEntity
  ): Promise<{ eventId: string } | undefined>[] {
    return messages.map((message) =>
      this.sendWebhookMessage.execute({
        eventType,
        objectType: WebhookObjectTypeEnum.MESSAGE,
        payload: {
          object: messageWebhookMapper(message, command.subscriberId),
        },
        organizationId: command.organizationId,
        environmentId: command.environmentId,
        environment,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateAllNotifications

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/update-notification-action/update-notification-action.command.ts
Tamaño: 554 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ButtonTypeEnum, MessageActionStatusEnum } from '@novu/shared';
import { IsDefined, IsEnum, IsMongoId } from 'class-validator';

import { EnvironmentWithSubscriber } from '../../../shared/commands/project.command';

export class UpdateNotificationActionCommand extends EnvironmentWithSubscriber {
  @IsDefined()
  @IsMongoId()
  readonly notificationId: string;

  @IsEnum(MessageActionStatusEnum)
  @IsDefined()
  readonly actionStatus: MessageActionStatusEnum;

  @IsEnum(ButtonTypeEnum)
  @IsDefined()
  readonly actionType: ButtonTypeEnum;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateNotificationActionCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/update-notification-action/update-notification-action.spec.ts
Tamaño: 9240 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, NotFoundException } from '@nestjs/common';
import { AnalyticsService, buildFeedKey, InvalidateCacheService } from '@novu/application-generic';
import { ChannelTypeEnum, MessageRepository } from '@novu/dal';
import { ButtonTypeEnum, ChannelCTATypeEnum, MessageActionStatusEnum } from '@novu/shared';
import { expect } from 'chai';
import sinon from 'sinon';

import { GetSubscriber } from '../../../subscribers/usecases/get-subscriber';
import { AnalyticsEventsEnum } from '../../utils';
import { mapToDto } from '../../utils/notification-mapper';
import type { UpdateNotificationActionCommand } from './update-notification-action.command';
import { UpdateNotificationAction } from './update-notification-action.usecase';

const mockSubscriber: any = { _id: '123', subscriberId: 'test-mockSubscriber' };
const mockMessage: any = {
  _id: '_id',
  content: '',
  read: false,
  archived: false,
  createdAt: new Date(),
  lastReadAt: new Date(),
  channel: ChannelTypeEnum.IN_APP,
  subscriber: mockSubscriber,
  actorSubscriber: mockSubscriber,
  cta: {
    type: ChannelCTATypeEnum.REDIRECT,
    data: {},
  },
};
const mockMessageWithButtons: any = {
  _id: '_id',
  content: '',
  read: false,
  archived: false,
  createdAt: new Date(),
  lastReadAt: new Date(),
  channel: ChannelTypeEnum.IN_APP,
  subscriber: mockSubscriber,
  actorSubscriber: mockSubscriber,
  cta: {
    type: ChannelCTATypeEnum.REDIRECT,
    data: {},
    action: {
      buttons: [
        { type: ButtonTypeEnum.PRIMARY, content: '' },
        { type: ButtonTypeEnum.SECONDARY, content: '' },
      ],
    },
  },
};

describe('UpdateNotificationAction', () => {
  let updateNotificationAction: UpdateNotificationAction;
  let invalidateCacheMock: sinon.SinonStubbedInstance<InvalidateCacheService>;
  let getSubscriberMock: sinon.SinonStubbedInstance<GetSubscriber>;
  let analyticsServiceMock: sinon.SinonStubbedInstance<AnalyticsService>;
  let messageRepositoryMock: sinon.SinonStubbedInstance<MessageRepository>;

  beforeEach(() => {
    invalidateCacheMock = sinon.createStubInstance(InvalidateCacheService);
    getSubscriberMock = sinon.createStubInstance(GetSubscriber);
    analyticsServiceMock = sinon.createStubInstance(AnalyticsService);
    messageRepositoryMock = sinon.createStubInstance(MessageRepository);

    updateNotificationAction = new UpdateNotificationAction(
      invalidateCacheMock as any,
      getSubscriberMock as any,
      analyticsServiceMock as any,
      messageRepositoryMock as any
    );
  });

  afterEach(() => {
    sinon.restore();
  });

  it('should throw exception when subscriber is not found', async () => {
    const command: UpdateNotificationActionCommand = {
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'not-found',
      notificationId: 'notification-id',
      actionType: ButtonTypeEnum.PRIMARY,
      actionStatus: MessageActionStatusEnum.DONE,
    };

    getSubscriberMock.execute.resolves(undefined);

    try {
      await updateNotificationAction.execute(command);
    } catch (error) {
      expect(error).to.be.instanceOf(BadRequestException);
      expect(error.message).to.equal(`Subscriber with id: ${command.subscriberId} is not found.`);
    }
  });

  it('should throw exception when the notification is not found', async () => {
    const command: UpdateNotificationActionCommand = {
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'not-found',
      notificationId: 'notification-id',
      actionType: ButtonTypeEnum.PRIMARY,
      actionStatus: MessageActionStatusEnum.DONE,
    };

    getSubscriberMock.execute.resolves(mockSubscriber);
    messageRepositoryMock.findOne.resolves(undefined);

    try {
      await updateNotificationAction.execute(command);
    } catch (error) {
      expect(error).to.be.instanceOf(NotFoundException);
      expect(error.message).to.equal(`Notification with id: ${command.notificationId} is not found.`);
    }
  });

  it("should throw exception when the notification doesn't have the primary button", async () => {
    const command: UpdateNotificationActionCommand = {
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'not-found',
      notificationId: mockMessage._id,
      actionType: ButtonTypeEnum.PRIMARY,
      actionStatus: MessageActionStatusEnum.DONE,
    };

    getSubscriberMock.execute.resolves(mockSubscriber);
    messageRepositoryMock.findOne.resolves(mockMessage);

    try {
      await updateNotificationAction.execute(command);
    } catch (error) {
      expect(error).to.be.instanceOf(BadRequestException);
      expect(error.message).to.equal(`Could not perform action on the primary button because it does not exist.`);
    }
  });

  it("should throw exception when the notification doesn't have the secondary button", async () => {
    const command: UpdateNotificationActionCommand = {
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'not-found',
      notificationId: mockMessage._id,
      actionType: ButtonTypeEnum.SECONDARY,
      actionStatus: MessageActionStatusEnum.DONE,
    };

    getSubscriberMock.execute.resolves(mockSubscriber);
    messageRepositoryMock.findOne.resolves(mockMessage);

    try {
      await updateNotificationAction.execute(command);
    } catch (error) {
      expect(error).to.be.instanceOf(BadRequestException);
      expect(error.message).to.equal(`Could not perform action on the secondary button because it does not exist.`);
    }
  });

  it('should update the notification action status', async () => {
    const command: UpdateNotificationActionCommand = {
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'not-found',
      notificationId: mockMessageWithButtons._id,
      actionType: ButtonTypeEnum.PRIMARY,
      actionStatus: MessageActionStatusEnum.DONE,
    };
    const updatedMessageWithButtonsMock = {
      ...mockMessageWithButtons,
      cta: {
        ...mockMessageWithButtons.cta,
        action: {
          ...mockMessageWithButtons.cta.action,
          status: MessageActionStatusEnum.DONE,
          result: { ...mockMessageWithButtons.cta.action.result, type: ButtonTypeEnum.PRIMARY },
        },
      },
    };

    getSubscriberMock.execute.resolves(mockSubscriber);
    messageRepositoryMock.findOne.onFirstCall().resolves(mockMessageWithButtons);
    messageRepositoryMock.findOne.onSecondCall().resolves(updatedMessageWithButtonsMock);
    messageRepositoryMock.updateActionStatus.resolves();

    const updatedMessage = await updateNotificationAction.execute(command);

    expect(messageRepositoryMock.updateActionStatus.calledOnce).to.be.true;
    expect(messageRepositoryMock.updateActionStatus.firstCall.args).to.deep.equal([
      {
        environmentId: command.environmentId,
        subscriberId: mockSubscriber._id,
        id: command.notificationId,
        actionType: command.actionType,
        actionStatus: command.actionStatus,
      },
    ]);
    expect(mapToDto(updatedMessageWithButtonsMock)).to.deep.equal(updatedMessage);
    expect(updatedMessage.primaryAction?.isCompleted).to.be.true;
    expect(updatedMessage.secondaryAction?.isCompleted).to.be.false;
  });

  it('should invalidate the cache', async () => {
    const command: UpdateNotificationActionCommand = {
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'not-found',
      notificationId: mockMessage._id,
      actionType: ButtonTypeEnum.PRIMARY,
      actionStatus: MessageActionStatusEnum.DONE,
    };

    getSubscriberMock.execute.resolves(mockSubscriber);
    messageRepositoryMock.findOne.resolves(mockMessageWithButtons);
    messageRepositoryMock.updateActionStatus.resolves();

    await updateNotificationAction.execute(command);

    expect(invalidateCacheMock.invalidateQuery.calledOnce).to.be.true;
    expect(invalidateCacheMock.invalidateQuery.firstCall.args).to.deep.equal([
      {
        key: buildFeedKey().invalidate({
          subscriberId: mockSubscriber.subscriberId,
          _environmentId: command.environmentId,
        }),
      },
    ]);
  });

  it('should send the analytics', async () => {
    const command: UpdateNotificationActionCommand = {
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'not-found',
      notificationId: mockMessage._id,
      actionType: ButtonTypeEnum.PRIMARY,
      actionStatus: MessageActionStatusEnum.DONE,
    };

    getSubscriberMock.execute.resolves(mockSubscriber);
    messageRepositoryMock.findOne.resolves(mockMessageWithButtons);
    messageRepositoryMock.updateActionStatus.resolves();

    await updateNotificationAction.execute(command);

    expect(analyticsServiceMock.mixpanelTrack.calledOnce).to.be.true;
    expect(analyticsServiceMock.mixpanelTrack.firstCall.args).to.deep.equal([
      AnalyticsEventsEnum.UPDATE_NOTIFICATION_ACTION,
      '',
      {
        _organization: command.organizationId,
        _subscriber: mockSubscriber._id,
        _notification: command.notificationId,
        actionType: ButtonTypeEnum.PRIMARY,
        actionStatus: MessageActionStatusEnum.DONE,
      },
    ]);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - any({
  _id: '_id',
  content: '',
  read: false,
  archived: false,
  createdAt: new Date(),
  lastRead...)
 - updateNotificationAction(new UpdateNotificationAction(
      invalidateCacheMock as any,
      getSubscriberMock as any,
    ...)
 - UpdateNotificationActionCommand({
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'not-found',
    ...)
 - UpdateNotificationActionCommand({
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'not-found',
    ...)
 - UpdateNotificationActionCommand({
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'not-found',
    ...)
 - UpdateNotificationActionCommand({
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'not-found',
    ...)
 - updatedMessage(await updateNotificationAction.execute(command);

    expect(messageRepositoryMock.updateActionStatu...)
 - UpdateNotificationActionCommand({
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'not-found',
    ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/update-notification-action/update-notification-action.usecase.ts
Tamaño: 3320 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import { AnalyticsService, buildFeedKey, InvalidateCacheService } from '@novu/application-generic';
import { MessageEntity, MessageRepository } from '@novu/dal';
import { ButtonTypeEnum } from '@novu/shared';

import { GetSubscriber } from '../../../subscribers/usecases/get-subscriber';
import { AnalyticsEventsEnum } from '../../utils';
import { mapToDto } from '../../utils/notification-mapper';
import { InboxNotification } from '../../utils/types';
import type { UpdateNotificationActionCommand } from './update-notification-action.command';

@Injectable()
export class UpdateNotificationAction {
  constructor(
    private invalidateCache: InvalidateCacheService,
    private getSubscriber: GetSubscriber,
    private analyticsService: AnalyticsService,
    private messageRepository: MessageRepository
  ) {}

  async execute(command: UpdateNotificationActionCommand): Promise<InboxNotification> {
    const subscriber = await this.getSubscriber.execute({
      environmentId: command.environmentId,
      organizationId: command.organizationId,
      subscriberId: command.subscriberId,
    });
    if (!subscriber) {
      throw new BadRequestException(`Subscriber with id: ${command.subscriberId} is not found.`);
    }

    const message = await this.messageRepository.findOne({
      _environmentId: command.environmentId,
      _subscriberId: subscriber._id,
      _id: command.notificationId,
      contextKeys: command.contextKeys,
    });
    if (!message) {
      throw new NotFoundException(`Notification with id: ${command.notificationId} is not found.`);
    }

    const isUpdatingPrimaryCta = command.actionType === ButtonTypeEnum.PRIMARY;
    const isUpdatingSecondaryCta = command.actionType === ButtonTypeEnum.SECONDARY;
    const primaryCta = message.cta.action?.buttons?.find((button) => button.type === ButtonTypeEnum.PRIMARY);
    const secondaryCta = message.cta.action?.buttons?.find((button) => button.type === ButtonTypeEnum.SECONDARY);
    if ((isUpdatingPrimaryCta && !primaryCta) || (isUpdatingSecondaryCta && !secondaryCta)) {
      throw new BadRequestException(
        `Could not perform action on the ${
          isUpdatingPrimaryCta && !primaryCta ? 'primary' : 'secondary'
        } button because it does not exist.`
      );
    }

    await this.messageRepository.updateActionStatus({
      environmentId: command.environmentId,
      subscriberId: subscriber._id,
      id: command.notificationId,
      actionType: command.actionType,
      actionStatus: command.actionStatus,
    });

    await this.invalidateCache.invalidateQuery({
      key: buildFeedKey().invalidate({
        subscriberId: subscriber.subscriberId,
        _environmentId: command.environmentId,
      }),
    });

    this.analyticsService.mixpanelTrack(AnalyticsEventsEnum.UPDATE_NOTIFICATION_ACTION, '', {
      _organization: command.organizationId,
      _subscriber: subscriber._id,
      _notification: command.notificationId,
      actionType: command.actionType,
      actionStatus: command.actionStatus,
    });

    return mapToDto(
      (await this.messageRepository.findOne({
        _environmentId: command.environmentId,
        _id: command.notificationId,
      })) as MessageEntity
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - primaryCta(message.cta.action?.buttons?.find((button))
 - secondaryCta(message.cta.action?.buttons?.find((button))
Declaraciones 'export' encontradas:
- export class UpdateNotificationAction

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/update-preferences/update-preferences.command.ts
Tamaño: 1234 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentEntity, NotificationTemplateEntity, SubscriberEntity } from '@novu/dal';
import { PreferenceLevelEnum, Schedule } from '@novu/shared';
import { IsBoolean, IsDefined, IsEnum, IsOptional, ValidateIf } from 'class-validator';
import { EnvironmentWithSubscriber } from '../../../shared/commands/project.command';

export class UpdatePreferencesCommand extends EnvironmentWithSubscriber {
  @IsOptional()
  @ValidateIf((object) => object.level === PreferenceLevelEnum.TEMPLATE)
  readonly workflowIdOrIdentifier?: string;

  @IsOptional()
  @IsBoolean()
  readonly email?: boolean;

  @IsOptional()
  @IsBoolean()
  readonly sms?: boolean;

  @IsOptional()
  @IsBoolean()
  readonly in_app?: boolean;

  @IsOptional()
  @IsBoolean()
  readonly chat?: boolean;

  @IsOptional()
  @IsBoolean()
  readonly push?: boolean;

  @IsDefined()
  @IsEnum(PreferenceLevelEnum)
  readonly level: PreferenceLevelEnum;

  @IsDefined()
  @IsBoolean()
  readonly includeInactiveChannels: boolean;

  @IsOptional()
  readonly subscriber?: SubscriberEntity;

  @IsOptional()
  readonly workflow?: NotificationTemplateEntity;

  @IsOptional()
  readonly environment?: EnvironmentEntity;

  @IsOptional()
  readonly schedule?: Schedule;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdatePreferencesCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/update-preferences/update-preferences.spec.ts
Tamaño: 8132 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  AnalyticsService,
  GetSubscriberTemplatePreference,
  GetWorkflowByIdsUseCase,
  SendWebhookMessage,
  UpsertPreferences,
} from '@novu/application-generic';
import { SubscriberRepository } from '@novu/dal';
import { PreferenceLevelEnum, SeverityLevelEnum } from '@novu/shared';
import { expect } from 'chai';
import sinon from 'sinon';
import {
  GetSubscriberGlobalPreference,
  GetSubscriberGlobalPreferenceCommand,
} from '../../../subscribers/usecases/get-subscriber-global-preference';
import { AnalyticsEventsEnum } from '../../utils';
import { UpdatePreferences } from './update-preferences.usecase';

const mockedSubscriber: any = {
  _id: '6447aff3d89122e250412c29',
  subscriberId: 'test-mockSubscriber',
  firstName: 'test',
  lastName: 'test',
};

const mockedGlobalPreference: any = {
  preference: {
    enabled: true,
    channels: {
      email: true,
      in_app: true,
      sms: false,
      push: false,
      chat: true,
    },
  },
};

const mockedWorkflow: any = {
  _id: '6447aff3d89122e250412c28',
  name: 'test-workflow',
  critical: false,
  triggers: [{ identifier: 'test-trigger' }],
  tags: [],
  data: undefined,
  severity: SeverityLevelEnum.NONE,
};

describe('UpdatePreferences', () => {
  let updatePreferences: UpdatePreferences;
  let subscriberRepositoryMock: sinon.SinonStubbedInstance<SubscriberRepository>;
  let analyticsServiceMock: sinon.SinonStubbedInstance<AnalyticsService>;
  let getSubscriberGlobalPreferenceMock: sinon.SinonStubbedInstance<GetSubscriberGlobalPreference>;
  let getSubscriberTemplatePreferenceUsecase: sinon.SinonStubbedInstance<GetSubscriberTemplatePreference>;
  let upsertPreferencesMock: sinon.SinonStubbedInstance<UpsertPreferences>;
  let getWorkflowByIdsUsecase: sinon.SinonStubbedInstance<GetWorkflowByIdsUseCase>;
  let sendWebhookMessageMock: sinon.SinonStubbedInstance<SendWebhookMessage>;

  beforeEach(() => {
    subscriberRepositoryMock = sinon.createStubInstance(SubscriberRepository);
    analyticsServiceMock = sinon.createStubInstance(AnalyticsService);
    getSubscriberGlobalPreferenceMock = sinon.createStubInstance(GetSubscriberGlobalPreference);
    getSubscriberTemplatePreferenceUsecase = sinon.createStubInstance(GetSubscriberTemplatePreference);
    upsertPreferencesMock = sinon.createStubInstance(UpsertPreferences);
    getWorkflowByIdsUsecase = sinon.createStubInstance(GetWorkflowByIdsUseCase);
    sendWebhookMessageMock = sinon.createStubInstance(SendWebhookMessage);

    updatePreferences = new UpdatePreferences(
      subscriberRepositoryMock as any,
      analyticsServiceMock as any,
      getSubscriberGlobalPreferenceMock as any,
      getSubscriberTemplatePreferenceUsecase as any,
      upsertPreferencesMock as any,
      getWorkflowByIdsUsecase as any,
      sendWebhookMessageMock as any
    );
  });

  afterEach(() => {
    sinon.restore();
  });

  it('should throw exception when subscriber is not found', async () => {
    const command = {
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'not-found',
      level: PreferenceLevelEnum.GLOBAL,
      chat: true,
      includeInactiveChannels: false,
    };

    subscriberRepositoryMock.findBySubscriberId.resolves(undefined);

    try {
      await updatePreferences.execute(command);
    } catch (error) {
      expect(error).to.be.instanceOf(Error);
      expect(error.message).to.equal(`Subscriber with id: ${command.subscriberId} is not found`);
    }
  });

  it('should update subscriber preference', async () => {
    const command = {
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'test-mockSubscriber',
      level: PreferenceLevelEnum.GLOBAL,
      chat: true,
      includeInactiveChannels: false,
    };

    subscriberRepositoryMock.findBySubscriberId.resolves(mockedSubscriber);
    getSubscriberGlobalPreferenceMock.execute.resolves(mockedGlobalPreference);

    const result = await updatePreferences.execute(command);

    expect(getSubscriberGlobalPreferenceMock.execute.called).to.be.true;
    expect(getSubscriberGlobalPreferenceMock.execute.lastCall.args).to.deep.equal([
      GetSubscriberGlobalPreferenceCommand.create({
        environmentId: command.environmentId,
        organizationId: command.organizationId,
        subscriberId: mockedSubscriber.subscriberId,
        includeInactiveChannels: false,
      }),
    ]);

    expect(analyticsServiceMock.mixpanelTrack.firstCall.args).to.deep.equal([
      AnalyticsEventsEnum.UPDATE_PREFERENCES,
      '',
      {
        _organization: command.organizationId,
        _subscriber: mockedSubscriber._id,
        level: command.level,
        _workflowId: undefined,
        channels: {
          chat: true,
        },
      },
    ]);

    expect(result).to.deep.equal({
      level: command.level,
      ...mockedGlobalPreference.preference,
    });
  });

  it('should update subscriber preference if preference exists and level is template', async () => {
    const command = {
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'test-mockSubscriber',
      level: PreferenceLevelEnum.TEMPLATE,
      workflowIdOrIdentifier: '6447aff3d89122e250412c28',
      chat: true,
      email: false,
      includeInactiveChannels: false,
    };

    subscriberRepositoryMock.findBySubscriberId.resolves(mockedSubscriber);
    getSubscriberTemplatePreferenceUsecase.execute.resolves({ ...mockedGlobalPreference });
    getWorkflowByIdsUsecase.execute.resolves(mockedWorkflow);

    const result = await updatePreferences.execute(command);

    expect(analyticsServiceMock.mixpanelTrack.calledOnce).to.be.true;
    expect(analyticsServiceMock.mixpanelTrack.firstCall.args).to.deep.equal([
      AnalyticsEventsEnum.UPDATE_PREFERENCES,
      '',
      {
        _organization: command.organizationId,
        _subscriber: mockedSubscriber._id,
        _workflowId: command.workflowIdOrIdentifier,
        level: command.level,
        channels: {
          chat: true,
          email: false,
        },
      },
    ]);

    expect(result).to.deep.equal({
      level: command.level,
      ...mockedGlobalPreference.preference,
      workflow: {
        id: mockedWorkflow._id,
        identifier: mockedWorkflow.triggers[0].identifier,
        name: mockedWorkflow.name,
        critical: mockedWorkflow.critical,
        tags: mockedWorkflow.tags,
        data: mockedWorkflow.data,
        severity: mockedWorkflow.severity,
      },
    });
  });

  it('should update subscriber preference when using workflow identifier', async () => {
    const command = {
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'test-mockSubscriber',
      level: PreferenceLevelEnum.TEMPLATE,
      workflowIdOrIdentifier: 'test-trigger', // Using the trigger identifier
      chat: true,
      email: false,
      includeInactiveChannels: false,
    };

    subscriberRepositoryMock.findBySubscriberId.resolves(mockedSubscriber);
    getSubscriberTemplatePreferenceUsecase.execute.resolves({ ...mockedGlobalPreference });
    getWorkflowByIdsUsecase.execute.resolves(mockedWorkflow);

    const result = await updatePreferences.execute(command);

    expect(analyticsServiceMock.mixpanelTrack.calledOnce).to.be.true;
    expect(analyticsServiceMock.mixpanelTrack.firstCall.args).to.deep.equal([
      AnalyticsEventsEnum.UPDATE_PREFERENCES,
      '',
      {
        _organization: command.organizationId,
        _subscriber: mockedSubscriber._id,
        _workflowId: command.workflowIdOrIdentifier,
        level: command.level,
        channels: {
          chat: true,
          email: false,
        },
      },
    ]);

    expect(result).to.deep.equal({
      level: command.level,
      ...mockedGlobalPreference.preference,
      workflow: {
        id: mockedWorkflow._id,
        identifier: mockedWorkflow.triggers[0].identifier,
        name: mockedWorkflow.name,
        critical: mockedWorkflow.critical,
        tags: mockedWorkflow.tags,
        data: mockedWorkflow.data,
        severity: mockedWorkflow.severity,
      },
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - any({
  _id: '6447aff3d89122e250412c28',
  name: 'test-workflow',
  critical: false,
  triggers: [{ iden...)
 - updatePreferences(new UpdatePreferences(
      subscriberRepositoryMock as any,
      analyticsServiceMock as any,
   ...)
 - command({
      environmentId: 'env-1',
      organizationId: 'org-1',
      subscriberId: 'not-found',
    ...)
 - result(await updatePreferences.execute(command);

    expect(getSubscriberGlobalPreferenceMock.execute.call...)
 - result(await updatePreferences.execute(command);

    expect(analyticsServiceMock.mixpanelTrack.calledOnce)...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/usecases/update-preferences/update-preferences.usecase.ts
Tamaño: 7756 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import {
  AnalyticsService,
  GetSubscriberTemplatePreference,
  GetSubscriberTemplatePreferenceCommand,
  GetWorkflowByIdsCommand,
  GetWorkflowByIdsUseCase,
  Instrument,
  InstrumentUsecase,
  SendWebhookMessage,
  UpsertPreferences,
  UpsertSubscriberGlobalPreferencesCommand,
  UpsertSubscriberWorkflowPreferencesCommand,
} from '@novu/application-generic';
import { SubscriberEntity, SubscriberRepository } from '@novu/dal';
import {
  IPreferenceChannels,
  PreferenceLevelEnum,
  Schedule,
  SeverityLevelEnum,
  WebhookEventEnum,
  WebhookObjectTypeEnum,
  WorkflowPreferences,
  WorkflowPreferencesPartial,
} from '@novu/shared';
import {
  GetSubscriberGlobalPreference,
  GetSubscriberGlobalPreferenceCommand,
} from '../../../subscribers/usecases/get-subscriber-global-preference';
import { AnalyticsEventsEnum } from '../../utils';
import { InboxPreference } from '../../utils/types';
import { UpdatePreferencesCommand } from './update-preferences.command';

@Injectable()
export class UpdatePreferences {
  constructor(
    private subscriberRepository: SubscriberRepository,
    private analyticsService: AnalyticsService,
    private getSubscriberGlobalPreference: GetSubscriberGlobalPreference,
    private getSubscriberTemplatePreferenceUsecase: GetSubscriberTemplatePreference,
    private upsertPreferences: UpsertPreferences,
    private getWorkflowByIdsUsecase: GetWorkflowByIdsUseCase,
    private sendWebhookMessage: SendWebhookMessage
  ) {}

  @InstrumentUsecase()
  async execute(command: UpdatePreferencesCommand): Promise<InboxPreference> {
    const subscriber =
      command.subscriber ??
      (await this.subscriberRepository.findBySubscriberId(command.environmentId, command.subscriberId));
    if (!subscriber) throw new NotFoundException(`Subscriber with id: ${command.subscriberId} is not found`);

    let workflowId: string | undefined;

    if (command.level === PreferenceLevelEnum.TEMPLATE && command.workflowIdOrIdentifier) {
      const workflow =
        command.workflow ??
        (await this.getWorkflowByIdsUsecase.execute(
          GetWorkflowByIdsCommand.create({
            environmentId: command.environmentId,
            organizationId: command.organizationId,
            workflowIdOrInternalId: command.workflowIdOrIdentifier,
          })
        ));

      if (workflow.critical) {
        throw new BadRequestException(
          `Critical workflow with id: ${command.workflowIdOrIdentifier} can not be updated`
        );
      }

      workflowId = workflow._id;
    }

    let newPreference: InboxPreference | null = null;

    await this.updateSubscriberPreference(command, subscriber, workflowId);

    newPreference = await this.findPreference(command, subscriber);

    await this.sendWebhookMessage.execute({
      eventType: WebhookEventEnum.PREFERENCE_UPDATED,
      objectType: WebhookObjectTypeEnum.PREFERENCE,
      payload: {
        object: newPreference,
      },
      organizationId: command.organizationId,
      environmentId: command.environmentId,
      environment: command.environment,
    });

    return newPreference;
  }

  @Instrument()
  private async updateSubscriberPreference(
    command: UpdatePreferencesCommand,
    subscriber: SubscriberEntity,
    workflowId: string | undefined
  ): Promise<void> {
    const channelPreferences: IPreferenceChannels = this.buildPreferenceChannels(command);

    await this.storePreferences({
      channels: channelPreferences,
      organizationId: command.organizationId,
      environmentId: command.environmentId,
      _subscriberId: subscriber._id,
      workflowId,
      schedule: command.schedule,
    });

    this.analyticsService.mixpanelTrack(AnalyticsEventsEnum.UPDATE_PREFERENCES, '', {
      _organization: command.organizationId,
      _subscriber: subscriber._id,
      _workflowId: command.workflowIdOrIdentifier,
      level: command.level,
      channels: channelPreferences,
    });
  }

  private buildPreferenceChannels(command: UpdatePreferencesCommand): IPreferenceChannels {
    return {
      ...(command.chat !== undefined && { chat: command.chat }),
      ...(command.email !== undefined && { email: command.email }),
      ...(command.in_app !== undefined && { in_app: command.in_app }),
      ...(command.push !== undefined && { push: command.push }),
      ...(command.sms !== undefined && { sms: command.sms }),
    };
  }

  @Instrument()
  private async findPreference(
    command: UpdatePreferencesCommand,
    subscriber: SubscriberEntity
  ): Promise<InboxPreference> {
    if (command.level === PreferenceLevelEnum.TEMPLATE && command.workflowIdOrIdentifier) {
      const workflow =
        command.workflow ??
        (await this.getWorkflowByIdsUsecase.execute(
          GetWorkflowByIdsCommand.create({
            environmentId: command.environmentId,
            organizationId: command.organizationId,
            workflowIdOrInternalId: command.workflowIdOrIdentifier,
          })
        ));

      const { preference } = await this.getSubscriberTemplatePreferenceUsecase.execute(
        GetSubscriberTemplatePreferenceCommand.create({
          organizationId: command.organizationId,
          subscriberId: command.subscriberId,
          environmentId: command.environmentId,
          template: workflow,
          subscriber,
          includeInactiveChannels: command.includeInactiveChannels,
        })
      );

      return {
        level: PreferenceLevelEnum.TEMPLATE,
        enabled: preference.enabled,
        channels: preference.channels,
        workflow: {
          id: workflow._id,
          identifier: workflow.triggers[0].identifier,
          name: workflow.name,
          critical: workflow.critical,
          tags: workflow.tags,
          data: workflow.data,
          severity: workflow.severity ?? SeverityLevelEnum.NONE,
        },
      };
    }

    const { preference } = await this.getSubscriberGlobalPreference.execute(
      GetSubscriberGlobalPreferenceCommand.create({
        organizationId: command.organizationId,
        environmentId: command.environmentId,
        subscriberId: command.subscriberId,
        includeInactiveChannels: command.includeInactiveChannels,
      })
    );

    return {
      ...preference,
      level: PreferenceLevelEnum.GLOBAL,
    };
  }

  @Instrument()
  private async storePreferences(item: {
    channels: IPreferenceChannels;
    organizationId: string;
    _subscriberId: string;
    environmentId: string;
    workflowId?: string;
    schedule?: Schedule;
  }): Promise<void> {
    const preferences: WorkflowPreferencesPartial = {
      channels: Object.entries(item.channels).reduce(
        (outputChannels, [channel, enabled]) => ({
          ...outputChannels,
          [channel]: { enabled },
        }),
        {} as WorkflowPreferences['channels']
      ),
    };

    if (item.workflowId) {
      await this.upsertPreferences.upsertSubscriberWorkflowPreferences(
        UpsertSubscriberWorkflowPreferencesCommand.create({
          environmentId: item.environmentId,
          organizationId: item.organizationId,
          _subscriberId: item._subscriberId,
          templateId: item.workflowId,
          preferences,
          returnPreference: false,
        })
      );
    } else {
      await this.upsertPreferences.upsertSubscriberGlobalPreferences(
        UpsertSubscriberGlobalPreferencesCommand.create({
          preferences,
          environmentId: item.environmentId,
          organizationId: item.organizationId,
          _subscriberId: item._subscriberId,
          returnPreference: false,
          schedule: item.schedule,
        })
      );
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - WorkflowPreferencesPartial({
      channels: Object.entries(item.channels).reduce(
        (outputChannels, [channel, enabled]))
Declaraciones 'export' encontradas:
- export class UpdatePreferences

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/utils/analytics.ts
Tamaño: 821 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export enum AnalyticsEventsEnum {
  SESSION_INITIALIZED = 'Session Initialized - [Inbox]',
  INBOX_CONNECTED = 'Inbox Connected - [Inbox]',
  FETCH_NOTIFICATIONS = 'Fetch Notifications - [Inbox]',
  MARK_NOTIFICATION_AS = 'Mark Notification As - [Inbox]',
  UPDATE_NOTIFICATION_ACTION = 'Update Notification Action - [Inbox]',
  UPDATE_ALL_NOTIFICATIONS = 'Update All Notifications - [Inbox]',
  FETCH_PREFERENCES = 'Fetch Preferences - [Inbox]',
  UPDATE_PREFERENCES = 'Update Preferences - [Inbox]',
  UPDATE_PREFERENCES_BULK = 'Update Preferences Bulk - [Inbox]',
  SNOOZE_NOTIFICATION = 'Snooze Notification - [Inbox]',
  MARK_NOTIFICATIONS_AS_SEEN = 'Mark Notifications As Seen - [Inbox]',
  DELETE_NOTIFICATION = 'Delete Notification - [Inbox]',
  DELETE_ALL_NOTIFICATIONS = 'Delete All Notifications - [Inbox]',
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  enum

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/utils/encryption.ts
Tamaño: 797 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException } from '@nestjs/common';
import { ContextPayload } from '@novu/shared';
import { isContextHmacValid, isHmacValid } from '../../shared/helpers/is-valid-hmac';

export function validateHmacEncryption({
  apiKey,
  subscriberId,
  subscriberHash,
}: {
  apiKey: string;
  subscriberId: string;
  subscriberHash?: string;
}) {
  if (!isHmacValid(apiKey, subscriberId, subscriberHash)) {
    throw new BadRequestException('Please provide a valid HMAC hash');
  }
}

export function validateContextHmacEncryption({
  apiKey,
  context,
  contextHash,
}: {
  apiKey: string;
  context: ContextPayload;
  contextHash?: string;
}) {
  if (!isContextHmacValid(apiKey, context, contextHash)) {
    throw new BadRequestException('Please provide a valid context HMAC hash');
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - validateHmacEncryption({
  apiKey,
  subscriberId,
  subscriberHash,
}: {
  apiKey: string;
  subscriberId: string;
  subscriberHash?: string;
})
 - validateContextHmacEncryption({
  apiKey,
  context,
  contextHash,
}: {
  apiKey: string;
  context: ContextPayload;
  contextHash?: string;
})
Declaraciones 'export' encontradas:
- export function validateHmacEncryption
- export function validateContextHmacEncryption

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/utils/index.ts
Tamaño: 29 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './analytics';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/utils/notification-mapper.ts
Tamaño: 3246 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type { MessageEntity } from '@novu/dal';
import { ButtonTypeEnum, MessageActionStatusEnum, SeverityLevelEnum } from '@novu/shared';

import type { InboxNotification, Subscriber } from './types';

const mapSingleItem = ({
  _id,
  content,
  read,
  seen,
  archived,
  snoozedUntil,
  deliveredAt,
  createdAt,
  lastReadDate,
  firstSeenDate,
  archivedAt,
  channel,
  subscriber,
  subject,
  avatar,
  cta,
  tags,
  severity,
  data,
  template,
  transactionId,
}: MessageEntity): InboxNotification => {
  const to: Subscriber = {
    id: subscriber?._id ?? '',
    firstName: subscriber?.firstName,
    lastName: subscriber?.lastName,
    avatar: subscriber?.avatar,
    subscriberId: subscriber?.subscriberId ?? '',
  };
  const primaryCta = cta.action?.buttons?.find((button) => button.type === ButtonTypeEnum.PRIMARY);
  const secondaryCta = cta.action?.buttons?.find((button) => button.type === ButtonTypeEnum.SECONDARY);
  const actionType = cta.action?.result?.type;
  const actionStatus = cta.action?.status;

  return {
    id: _id,
    transactionId,
    subject,
    body: content as string,
    to,
    isRead: read,
    isSeen: seen,
    isArchived: archived,
    isSnoozed: !!snoozedUntil,
    ...(deliveredAt && {
      deliveredAt,
    }),
    ...(snoozedUntil && {
      snoozedUntil,
    }),
    createdAt,
    readAt: lastReadDate,
    firstSeenAt: firstSeenDate,
    archivedAt,
    avatar,
    primaryAction: primaryCta && {
      label: primaryCta.content,
      isCompleted: actionType === ButtonTypeEnum.PRIMARY && actionStatus === MessageActionStatusEnum.DONE,
      redirect: primaryCta.url
        ? {
            url: primaryCta.url,
            target: primaryCta.target,
          }
        : undefined,
    },
    secondaryAction: secondaryCta && {
      label: secondaryCta.content,
      isCompleted: actionType === ButtonTypeEnum.SECONDARY && actionStatus === MessageActionStatusEnum.DONE,
      redirect: secondaryCta.url
        ? {
            url: secondaryCta.url,
            target: secondaryCta.target,
          }
        : undefined,
    },
    channelType: channel,
    tags,
    severity: severity ?? SeverityLevelEnum.NONE,
    redirect: cta.data?.url
      ? {
          url: cta.data.url,
          target: cta.data.target,
        }
      : undefined,
    data,
    workflow: template
      ? {
          critical: template.critical,
          id: template._id,
          identifier: template.triggers?.[0]?.identifier,
          name: template.name,
          tags: template.tags,
          severity: template.severity ?? SeverityLevelEnum.NONE,
        }
      : undefined,
  };
};

/**
 * Currently the message entity has a generic interface for the messages from the different channels,
 * so we need to map it to a Notification DTO that is specific message interface for the in-app channel.
 */
export function mapToDto(notification: MessageEntity): InboxNotification;
export function mapToDto(notification: MessageEntity[]): InboxNotification[];
export function mapToDto(notification: MessageEntity | MessageEntity[]): InboxNotification | InboxNotification[] {
  return Array.isArray(notification) ? notification.map((el) => mapSingleItem(el)) : mapSingleItem(notification);
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - mapToDto(notification: MessageEntity)
 - mapToDto(notification: MessageEntity[])
 - mapToDto(notification: MessageEntity | MessageEntity[])
Asignaciones con arrow functions encontradas (posibles funciones):
 - mapSingleItem({
  _id,
  content,
  read,
  seen,
  archived,
  snoozedUntil,
  deliveredAt,
  createdAt,
  lastRe...)
 - primaryCta(cta.action?.buttons?.find((button))
 - secondaryCta(cta.action?.buttons?.find((button))
Declaraciones 'export' encontradas:
- export function mapToDto
- export function mapToDto
- export function mapToDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/utils/types.ts
Tamaño: 1686 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import type {
  ChannelTypeEnum,
  CustomDataType,
  IPreferenceChannels,
  PreferenceLevelEnum,
  Redirect,
  Schedule,
  SeverityLevelEnum,
} from '@novu/shared';

export type Subscriber = {
  id: string;
  firstName?: string;
  lastName?: string;
  avatar?: string;
  subscriberId: string;
};

type Action = {
  label: string;
  isCompleted: boolean;
  redirect?: Redirect;
};

export type InboxNotification = {
  id: string;
  transactionId: string;
  subject?: string;
  body: string;
  to: Subscriber;
  isRead: boolean;
  isSeen: boolean;
  isArchived: boolean;
  isSnoozed: boolean;
  snoozedUntil?: string | null;
  deliveredAt?: string[];
  createdAt: string;
  readAt?: string | null;
  firstSeenAt?: string | null;
  archivedAt?: string | null;
  avatar?: string;
  primaryAction?: Action;
  secondaryAction?: Action;
  channelType: ChannelTypeEnum;
  tags?: string[];
  data?: Record<string, unknown>;
  redirect?: Redirect;
  workflow?: {
    id: string;
    identifier: string;
    name: string;
    critical: boolean;
    tags?: string[];
    data?: CustomDataType;
    severity: SeverityLevelEnum;
  };
  severity: SeverityLevelEnum;
};

export type NotificationFilter = {
  tags?: string[];
  read?: boolean;
  archived?: boolean;
  snoozed?: boolean;
  seen?: boolean;
  data?: string;
  severity?: SeverityLevelEnum | SeverityLevelEnum[];
};

export type InboxPreference = {
  level: PreferenceLevelEnum;
  enabled: boolean;
  channels: IPreferenceChannels;
  workflow?: {
    id: string;
    identifier: string;
    name: string;
    critical: boolean;
    tags?: string[];
    data?: CustomDataType;
    severity: SeverityLevelEnum;
  };
  schedule?: Schedule;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/inbox/utils/validate-data.ts
Tamaño: 1650 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException } from '@nestjs/common';

/**
 * Validates the data structure for the data parameter.
 * Ensures:
 * - Maximum nesting level of 2
 * - Only scalar values are allowed (string, number, boolean, null)
 * - String values are limited to 256 characters
 */
export function validateDataStructure(data: unknown): void {
  if (!data || typeof data !== 'object' || Array.isArray(data)) {
    throw new BadRequestException('Data must be an object');
  }
  for (const [key, value] of Object.entries(data)) {
    if (typeof value === 'object' && value !== null) {
      if (Array.isArray(value)) {
        throw new BadRequestException('Arrays are not supported in data filter');
      }
      for (const [subKey, subValue] of Object.entries(value)) {
        if (typeof subValue === 'object' && subValue !== null) {
          throw new BadRequestException('Maximum nesting level exceeded (2 levels max)');
        }
        validateScalarValue(subKey, subValue);
      }
    } else {
      validateScalarValue(key, value);
    }
  }
}

/**
 * Validates a scalar value.
 * Ensures:
 * - Value is a scalar (string, number, boolean, null)
 * - String values are limited to 256 characters
 */
export function validateScalarValue(key: string, value: unknown): void {
  if (typeof value === 'string' && value.length > 256) {
    throw new BadRequestException(`String value for ${key} exceeds 256 characters`);
  }
  if (typeof value !== 'string' && typeof value !== 'number' && typeof value !== 'boolean' && value !== null) {
    throw new BadRequestException(`Value for ${key} must be a scalar (string, number, boolean, or null)`);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - validateDataStructure(data: unknown)
 - validateScalarValue(key: string, value: unknown)
Declaraciones 'export' encontradas:
- export function validateDataStructure
- export function validateScalarValue

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/integrations.controller.ts
Tamaño: 16145 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  BadRequestException,
  Body,
  ClassSerializerInterceptor,
  Controller,
  Delete,
  Get,
  Param,
  Post,
  Put,
  UseInterceptors,
} from '@nestjs/common';
import { ApiExcludeEndpoint, ApiOperation, ApiTags } from '@nestjs/swagger';
import {
  CalculateLimitNovuIntegration,
  CalculateLimitNovuIntegrationCommand,
  FeatureFlagsService,
  GetDecryptedIntegrations,
  OtelSpan,
  RequirePermissions,
} from '@novu/application-generic';
import { CommunityOrganizationRepository } from '@novu/dal';
import {
  ApiServiceLevelEnum,
  ChannelTypeEnum,
  FeatureFlagsKeysEnum,
  FeatureNameEnum,
  getFeatureForTierAsBoolean,
  PermissionsEnum,
  UserSessionData,
} from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { ExternalApiAccessible } from '../auth/framework/external-api.decorator';
import {
  ApiCommonResponses,
  ApiNotFoundResponse,
  ApiOkResponse,
  ApiResponse,
} from '../shared/framework/response.decorator';
import { SdkGroupName, SdkMethodName } from '../shared/framework/swagger/sdk.decorators';
import { UserSession } from '../shared/framework/user.decorator';
import { AutoConfigureIntegrationRequestDto } from './dtos/auto-configure-integration-request.dto';
import { AutoConfigureIntegrationResponseDto } from './dtos/auto-configure-integration-response.dto';
import { CreateIntegrationRequestDto } from './dtos/create-integration-request.dto';
import { ChannelTypeLimitDto } from './dtos/get-channel-type-limit.sto';
import { IntegrationResponseDto } from './dtos/integration-response.dto';
import { UpdateIntegrationRequestDto } from './dtos/update-integration.dto';
import { AutoConfigureIntegrationCommand } from './usecases/auto-configure-integration/auto-configure-integration.command';
import { AutoConfigureIntegration } from './usecases/auto-configure-integration/auto-configure-integration.usecase';
import { CreateIntegrationCommand } from './usecases/create-integration/create-integration.command';
import { CreateIntegration } from './usecases/create-integration/create-integration.usecase';
import { GetActiveIntegrationsCommand } from './usecases/get-active-integration/get-active-integration.command';
import { GetActiveIntegrations } from './usecases/get-active-integration/get-active-integration.usecase';
import { GetInAppActivatedCommand } from './usecases/get-in-app-activated/get-in-app-activated.command';
import { GetInAppActivated } from './usecases/get-in-app-activated/get-in-app-activated.usecase';
import { GetIntegrationsCommand } from './usecases/get-integrations/get-integrations.command';
import { GetIntegrations } from './usecases/get-integrations/get-integrations.usecase';
import { GetWebhookSupportStatusCommand } from './usecases/get-webhook-support-status/get-webhook-support-status.command';
import { GetWebhookSupportStatus } from './usecases/get-webhook-support-status/get-webhook-support-status.usecase';
import { RemoveIntegrationCommand } from './usecases/remove-integration/remove-integration.command';
import { RemoveIntegration } from './usecases/remove-integration/remove-integration.usecase';
import { SetIntegrationAsPrimaryCommand } from './usecases/set-integration-as-primary/set-integration-as-primary.command';
import { SetIntegrationAsPrimary } from './usecases/set-integration-as-primary/set-integration-as-primary.usecase';
import { UpdateIntegrationCommand } from './usecases/update-integration/update-integration.command';
import { UpdateIntegration } from './usecases/update-integration/update-integration.usecase';

@ApiCommonResponses()
@Controller('/integrations')
@UseInterceptors(ClassSerializerInterceptor)
@RequireAuthentication()
@ApiTags('Integrations')
export class IntegrationsController {
  constructor(
    private getInAppActivatedUsecase: GetInAppActivated,
    private getIntegrationsUsecase: GetIntegrations,
    private getActiveIntegrationsUsecase: GetActiveIntegrations,
    private getWebhookSupportStatusUsecase: GetWebhookSupportStatus,
    private createIntegrationUsecase: CreateIntegration,
    private updateIntegrationUsecase: UpdateIntegration,
    private autoConfigureIntegrationUsecase: AutoConfigureIntegration,
    private setIntegrationAsPrimaryUsecase: SetIntegrationAsPrimary,
    private removeIntegrationUsecase: RemoveIntegration,
    private calculateLimitNovuIntegration: CalculateLimitNovuIntegration,
    private organizationRepository: CommunityOrganizationRepository,
    private featureFlagService: FeatureFlagsService
  ) {}

  @Get('/')
  @ApiOkResponse({
    type: [IntegrationResponseDto],
    description: 'The list of integrations belonging to the organization that are successfully returned.',
  })
  @ApiOperation({
    summary: 'List all integrations',
    description: 'List all the channels integrations created in the organization',
  })
  @ExternalApiAccessible()
  @RequirePermissions(PermissionsEnum.INTEGRATION_READ)
  async listIntegrations(@UserSession() user: UserSessionData): Promise<IntegrationResponseDto[]> {
    const canAccessCredentials = await this.canUserAccessCredentials(user);

    return await this.getIntegrationsUsecase.execute(
      GetIntegrationsCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
        returnCredentials: canAccessCredentials,
      })
    );
  }

  @Get('/active')
  @ApiOkResponse({
    type: [IntegrationResponseDto],
    description: 'The list of active integrations belonging to the organization that are successfully returned.',
  })
  @ApiOperation({
    summary: 'List active integrations',
    description: 'List all the active integrations created in the organization',
  })
  @ExternalApiAccessible()
  @SdkMethodName('listActive')
  @RequirePermissions(PermissionsEnum.INTEGRATION_READ)
  async getActiveIntegrations(@UserSession() user: UserSessionData): Promise<IntegrationResponseDto[]> {
    const canAccessCredentials = await this.canUserAccessCredentials(user);

    return await this.getActiveIntegrationsUsecase.execute(
      GetActiveIntegrationsCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
        returnCredentials: canAccessCredentials,
      })
    );
  }

  @Get('/webhook/provider/:providerOrIntegrationId/status')
  @ApiOkResponse({
    type: Boolean,
    description: 'The status of the webhook for the provider requested',
  })
  @ApiExcludeEndpoint()
  @ApiOperation({
    summary: 'Retrieve webhook status',
    description: `Retrieve the status of the webhook for integration specified in query param **providerOrIntegrationId**. 
    This API returns a boolean value.`,
  })
  @SdkGroupName('Integrations.Webhooks')
  @ExternalApiAccessible()
  @RequirePermissions(PermissionsEnum.INTEGRATION_READ)
  async getWebhookSupportStatus(
    @UserSession() user: UserSessionData,
    @Param('providerOrIntegrationId') providerOrIntegrationId: string
  ): Promise<boolean> {
    return await this.getWebhookSupportStatusUsecase.execute(
      GetWebhookSupportStatusCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        providerOrIntegrationId,
        userId: user._id,
      })
    );
  }

  @Post('/')
  @ApiResponse(IntegrationResponseDto, 201)
  @ApiOperation({
    summary: 'Create an integration',
    description: `Create an integration for the current environment the user is based on the API key provided. 
    Each provider supports different credentials, check the provider documentation for more details.`,
  })
  @ExternalApiAccessible()
  @RequirePermissions(PermissionsEnum.INTEGRATION_WRITE)
  async createIntegration(
    @UserSession() user: UserSessionData,
    @Body() body: CreateIntegrationRequestDto
  ): Promise<IntegrationResponseDto> {
    try {
      const canAccessCredentials = await this.canUserAccessCredentials(user);
      const integration = await this.createIntegrationUsecase.execute(
        CreateIntegrationCommand.create({
          userId: user._id,
          name: body.name,
          identifier: body.identifier,
          environmentId: body._environmentId ?? user.environmentId,
          organizationId: user.organizationId,
          providerId: body.providerId,
          channel: body.channel,
          credentials: body.credentials,
          active: body.active ?? false,
          check: body.check ?? false,
          conditions: body.conditions,
          configurations: body.configurations,
        })
      );

      if (canAccessCredentials) {
        return GetDecryptedIntegrations.getDecryptedCredentials(integration);
      }

      const { credentials, ...integrationWithoutCredentials } = integration;

      return integrationWithoutCredentials as unknown as IntegrationResponseDto;
    } catch (e) {
      if (e.message.includes('Integration validation failed') || e.message.includes('Cast to embedded')) {
        throw new BadRequestException(e.message);
      }

      throw e;
    }
  }

  @Put('/:integrationId')
  @ApiResponse(IntegrationResponseDto)
  @ApiNotFoundResponse({
    description: 'The integration with the integrationId provided does not exist in the database.',
  })
  @ApiOperation({
    summary: 'Update an integration',
    description: `Update an integration by its unique key identifier **integrationId**. 
    Each provider supports different credentials, check the provider documentation for more details.`,
  })
  @ExternalApiAccessible()
  @RequirePermissions(PermissionsEnum.INTEGRATION_WRITE)
  async updateIntegrationById(
    @UserSession() user: UserSessionData,
    @Param('integrationId') integrationId: string,
    @Body() body: UpdateIntegrationRequestDto
  ): Promise<IntegrationResponseDto> {
    try {
      const canAccessCredentials = await this.canUserAccessCredentials(user);
      const integration = await this.updateIntegrationUsecase.execute(
        UpdateIntegrationCommand.create({
          userId: user._id,
          name: body.name,
          identifier: body.identifier,
          environmentId: body._environmentId,
          userEnvironmentId: user.environmentId,
          organizationId: user.organizationId,
          integrationId,
          credentials: body.credentials,
          active: body.active,
          check: body.check ?? false,
          conditions: body.conditions,
          configurations: body.configurations,
        })
      );

      if (canAccessCredentials) {
        return GetDecryptedIntegrations.getDecryptedCredentials(integration);
      }

      const { credentials, ...integrationWithoutCredentials } = integration;

      return integrationWithoutCredentials as unknown as IntegrationResponseDto;
    } catch (e) {
      if (e.message.includes('Integration validation failed') || e.message.includes('Cast to embedded')) {
        throw new BadRequestException(e.message);
      }

      throw e;
    }
  }

  @Post('/:integrationId/auto-configure')
  @ApiResponse(AutoConfigureIntegrationResponseDto, 200)
  @ApiNotFoundResponse({
    description: 'The integration with the integrationId provided does not exist in the database.',
  })
  @ApiOperation({
    summary: 'Auto-configure an integration for inbound webhooks',
    description: `Auto-configure an integration by its unique key identifier **integrationId** for inbound webhook support. 
    This will automatically generate required webhook signing keys and configure webhook endpoints.`,
  })
  @ExternalApiAccessible()
  @RequirePermissions(PermissionsEnum.INTEGRATION_WRITE)
  async autoConfigureIntegration(
    @UserSession() user: UserSessionData,
    @Param('integrationId') integrationId: string
  ): Promise<AutoConfigureIntegrationResponseDto> {
    const result = await this.autoConfigureIntegrationUsecase.execute(
      AutoConfigureIntegrationCommand.create({
        userId: user._id,
        organizationId: user.organizationId,
        integrationId,
      })
    );

    return result;
  }

  @Post('/:integrationId/set-primary')
  @ApiResponse(IntegrationResponseDto)
  @ApiNotFoundResponse({
    description: 'The integration with the integrationId provided does not exist in the database.',
  })
  @ApiOperation({
    summary: 'Update integration as primary',
    description: `Update an integration as **primary** by its unique key identifier **integrationId**. 
    This API will set the integration as primary for that channel in the current environment. 
    Primary integration is used to deliver notification for sms and email channels in the workflow.`,
  })
  @ExternalApiAccessible()
  @RequirePermissions(PermissionsEnum.INTEGRATION_WRITE)
  @SdkMethodName('setAsPrimary')
  async setIntegrationAsPrimary(
    @UserSession() user: UserSessionData,
    @Param('integrationId') integrationId: string
  ): Promise<IntegrationResponseDto> {
    const canAccessCredentials = await this.canUserAccessCredentials(user);
    const integration = await this.setIntegrationAsPrimaryUsecase.execute(
      SetIntegrationAsPrimaryCommand.create({
        userId: user._id,
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        integrationId,
      })
    );

    if (canAccessCredentials) {
      return GetDecryptedIntegrations.getDecryptedCredentials(integration);
    }

    const { credentials, ...integrationWithoutCredentials } = integration;

    return integrationWithoutCredentials as unknown as IntegrationResponseDto;
  }

  @Delete('/:integrationId')
  @ApiResponse(IntegrationResponseDto, 200, true)
  @ApiOperation({
    summary: 'Delete an integration',
    description: `Delete an integration by its unique key identifier **integrationId**. 
    This action is irreversible.`,
  })
  @ExternalApiAccessible()
  @RequirePermissions(PermissionsEnum.INTEGRATION_WRITE)
  async removeIntegration(
    @UserSession() user: UserSessionData,
    @Param('integrationId') integrationId: string
  ): Promise<IntegrationResponseDto[]> {
    return await this.removeIntegrationUsecase.execute(
      RemoveIntegrationCommand.create({
        userId: user._id,
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        integrationId,
      })
    );
  }

  @Get('/:channelType/limit')
  @ApiExcludeEndpoint()
  @OtelSpan()
  @RequirePermissions(PermissionsEnum.INTEGRATION_READ)
  async getProviderLimit(
    @UserSession() user: UserSessionData,
    @Param('channelType') channelType: ChannelTypeEnum
  ): Promise<ChannelTypeLimitDto> {
    const result = await this.calculateLimitNovuIntegration.execute(
      CalculateLimitNovuIntegrationCommand.create({
        channelType,
        organizationId: user.organizationId,
        environmentId: user.environmentId,
      })
    );

    if (!result) {
      return { limit: 0, count: 0 };
    }

    return result;
  }

  @Get('/in-app/status')
  @ApiExcludeEndpoint()
  @RequirePermissions(PermissionsEnum.INTEGRATION_READ)
  async getInAppActivated(@UserSession() user: UserSessionData) {
    return await this.getInAppActivatedUsecase.execute(
      GetInAppActivatedCommand.create({
        organizationId: user.organizationId,
        environmentId: user.environmentId,
      })
    );
  }

  private async canUserAccessCredentials(user: UserSessionData): Promise<boolean> {
    const organization = await this.organizationRepository.findOne({
      _id: user.organizationId,
    });

    const [isRbacFlagEnabled, isRbacFeatureEnabled] = await Promise.all([
      this.featureFlagService.getFlag({
        organization: { _id: user.organizationId },
        user: { _id: user._id },
        key: FeatureFlagsKeysEnum.IS_RBAC_ENABLED,
        defaultValue: false,
      }),
      getFeatureForTierAsBoolean(
        FeatureNameEnum.ACCOUNT_ROLE_BASED_ACCESS_CONTROL_BOOLEAN,
        organization?.apiServiceLevel || ApiServiceLevelEnum.FREE
      ),
    ]);

    const isRbacEnabled = isRbacFlagEnabled && isRbacFeatureEnabled;

    if (!isRbacEnabled) {
      return true;
    }

    return user.permissions.includes(PermissionsEnum.INTEGRATION_WRITE);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class IntegrationsController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/integrations.module.ts
Tamaño: 756 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { forwardRef, Module } from '@nestjs/common';
import { ChannelFactory, CompileTemplate, CreateExecutionDetails } from '@novu/application-generic';
import { CommunityOrganizationRepository } from '@novu/dal';
import { AuthModule } from '../auth/auth.module';
import { SharedModule } from '../shared/shared.module';
import { IntegrationsController } from './integrations.controller';
import { USE_CASES } from './usecases';

const PROVIDERS = [ChannelFactory, CompileTemplate];

@Module({
  imports: [SharedModule, forwardRef(() => AuthModule)],
  controllers: [IntegrationsController],
  providers: [...USE_CASES, CreateExecutionDetails, CommunityOrganizationRepository, ...PROVIDERS],
  exports: [...USE_CASES],
})
export class IntegrationModule {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - PROVIDERS([ChannelFactory, CompileTemplate];

@Module({
  imports: [SharedModule, forwardRef(())
Declaraciones 'export' encontradas:
- export class IntegrationModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/dtos/auto-configure-integration-request.dto.ts
Tamaño: 51 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export class AutoConfigureIntegrationRequestDto {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class AutoConfigureIntegrationRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/dtos/auto-configure-integration-response.dto.ts
Tamaño: 645 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IntegrationResponseDto } from './integration-response.dto';

export class AutoConfigureIntegrationResponseDto {
  @ApiProperty({
    description: 'Indicates whether the auto-configuration was successful',
    type: Boolean,
  })
  success: boolean;

  @ApiPropertyOptional({
    description: 'Optional message describing the result or any errors that occurred',
    type: String,
  })
  message?: string;

  @ApiPropertyOptional({
    description: 'The updated configurations after auto-configuration',
    type: Object,
  })
  integration?: IntegrationResponseDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class AutoConfigureIntegrationResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/dtos/configurations.dto.ts
Tamaño: 405 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional } from '@nestjs/swagger';
import { IConfigurations } from '@novu/shared';
import { IsOptional, IsString } from 'class-validator';

export class ConfigurationsDto implements IConfigurations {
  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  inboundWebhookEnabled?: boolean;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  inboundWebhookSigningKey?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ConfigurationsDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/dtos/create-integration-request.dto.ts
Tamaño: 2244 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { ChannelTypeEnum, ICreateIntegrationBodyDto } from '@novu/shared';
import { Type } from 'class-transformer';
import {
  IsArray,
  IsBoolean,
  IsDefined,
  IsEnum,
  IsMongoId,
  IsObject,
  IsOptional,
  IsString,
  ValidateNested,
} from 'class-validator';
import { StepFilterDto } from '../../shared/dtos/step-filter-dto';
import { CredentialsDto } from './credentials.dto';

export class CreateIntegrationRequestDto implements ICreateIntegrationBodyDto {
  @ApiPropertyOptional({ type: String, description: 'The name of the integration' })
  @IsOptional()
  @IsString()
  name?: string;

  @ApiPropertyOptional({ type: String, description: 'The unique identifier for the integration' })
  @IsOptional()
  @IsString()
  identifier?: string;

  @ApiPropertyOptional({ type: String, description: 'The ID of the associated environment', format: 'uuid' })
  @IsOptional()
  @IsMongoId()
  _environmentId?: string;

  @ApiProperty({ type: String, description: 'The provider ID for the integration' })
  @IsDefined()
  @IsString()
  providerId: string;

  @ApiProperty({
    enum: ChannelTypeEnum,
    description: 'The channel type for the integration',
  })
  @IsDefined()
  @IsEnum(ChannelTypeEnum)
  channel: ChannelTypeEnum;

  @ApiPropertyOptional({
    type: CredentialsDto,
    description: 'The credentials for the integration',
  })
  @IsOptional()
  @Type(() => CredentialsDto)
  @ValidateNested()
  credentials?: CredentialsDto;

  @ApiPropertyOptional({
    type: Boolean,
    description: 'If the integration is active, the validation on the credentials field will run',
  })
  @IsOptional()
  @IsBoolean()
  active?: boolean;

  @ApiPropertyOptional({ type: Boolean, description: 'Flag to check the integration status' })
  @IsOptional()
  @IsBoolean()
  check?: boolean;

  @ApiPropertyOptional({
    type: [StepFilterDto],
    description: 'Conditions for the integration',
  })
  @IsArray()
  @IsOptional()
  @ValidateNested({ each: true })
  conditions?: StepFilterDto[];

  @ApiPropertyOptional({
    type: Object,
    description: 'Configurations for the integration',
  })
  @IsOptional()
  @IsObject()
  configurations?: Record<string, string>;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateIntegrationRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/dtos/credentials.dto.ts
Tamaño: 3867 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional } from '@nestjs/swagger';
import { ICredentials } from '@novu/shared';
import { IsBoolean, IsObject, IsOptional, IsString } from 'class-validator';
import { TransformToBoolean } from '../../shared/transformers/to-boolean';

export class CredentialsDto implements ICredentials {
  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  apiKey?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  user?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  secretKey?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  domain?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  password?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  host?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  port?: string;

  @ApiPropertyOptional()
  @TransformToBoolean()
  @IsBoolean()
  @IsOptional()
  secure?: boolean;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  region?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  accountSid?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  messageProfileId?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  token?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  from?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  senderName?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  projectName?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  applicationId?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  clientId?: string;

  @ApiPropertyOptional()
  @TransformToBoolean()
  @IsBoolean()
  @IsOptional()
  requireTls?: boolean;

  @ApiPropertyOptional()
  @TransformToBoolean()
  @IsBoolean()
  @IsOptional()
  ignoreTls?: boolean;

  @ApiPropertyOptional()
  @IsObject()
  @IsOptional()
  tlsOptions?: Record<string, unknown>;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  baseUrl?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  webhookUrl?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  redirectUrl?: string;

  @ApiPropertyOptional()
  @IsBoolean()
  @IsOptional()
  hmac?: boolean;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  serviceAccount?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  ipPoolName?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  apiKeyRequestHeader?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  secretKeyRequestHeader?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  idPath?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  datePath?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  apiToken?: string;

  @ApiPropertyOptional()
  @IsBoolean()
  @IsOptional()
  authenticateByToken?: boolean;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  authenticationTokenKey?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  instanceId?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  alertUid?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  title?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  imageUrl?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  state?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  externalLink?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  channelId?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  phoneNumberIdentification?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  accessKey?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  appSid?: string;

  @ApiPropertyOptional()
  @IsString()
  @IsOptional()
  senderId?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CredentialsDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/dtos/get-channel-type-limit.sto.ts
Tamaño: 186 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';

export class ChannelTypeLimitDto {
  @ApiProperty({ type: Number })
  limit: number;

  @ApiProperty({ type: Number })
  count: number;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ChannelTypeLimitDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/dtos/integration-response.dto.ts
Tamaño: 3262 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { ChannelTypeEnum } from '@novu/shared';
import { StepFilterDto } from '../../shared/dtos/step-filter-dto';
import { ConfigurationsDto } from './configurations.dto';
import { CredentialsDto } from './credentials.dto';

export class IntegrationResponseDto {
  @ApiPropertyOptional({
    description: 'The unique identifier of the integration record in the database. This is automatically generated.',
    type: String,
  })
  _id?: string;

  @ApiProperty({
    description:
      'The unique identifier for the environment associated with this integration. This links to the Environment collection.',
    type: String,
  })
  _environmentId: string;

  @ApiProperty({
    description:
      'The unique identifier for the organization that owns this integration. This links to the Organization collection.',
    type: String,
  })
  _organizationId: string;

  @ApiProperty({
    description: 'The name of the integration, which is used to identify it in the user interface.',
    type: String,
  })
  name: string;

  @ApiProperty({
    description: 'A unique string identifier for the integration, often used for API calls or internal references.',
    type: String,
  })
  identifier: string;

  @ApiProperty({
    description: 'The identifier for the provider of the integration (e.g., "mailgun", "twilio").',
    type: String,
  })
  providerId: string;

  @ApiProperty({
    description:
      'The channel type for the integration, which defines how the integration communicates (e.g., email, SMS).',
    enum: ChannelTypeEnum,
  })
  channel: ChannelTypeEnum;

  @ApiProperty({
    description:
      'The credentials required for the integration to function, including API keys and other sensitive information.',
    type: () => CredentialsDto,
  })
  credentials: CredentialsDto;

  @ApiProperty({
    description: 'The configurations required for enabling the additional configurations of the integration.',
    type: () => ConfigurationsDto,
  })
  configurations?: ConfigurationsDto;

  @ApiProperty({
    description:
      'Indicates whether the integration is currently active. An active integration will process events and messages.',
    type: Boolean,
  })
  active: boolean;

  @ApiProperty({
    description: 'Indicates whether the integration has been marked as deleted (soft delete).',
    type: Boolean,
  })
  deleted: boolean;

  @ApiPropertyOptional({
    description:
      'The timestamp indicating when the integration was deleted. This is set when the integration is soft deleted.',
    type: String,
  })
  deletedAt?: string;

  @ApiPropertyOptional({
    description: 'The identifier of the user who performed the deletion of this integration. Useful for audit trails.',
    type: String,
  })
  deletedBy?: string;

  @ApiProperty({
    description:
      'Indicates whether this integration is marked as primary. A primary integration is often the default choice for processing.',
    type: Boolean,
  })
  primary: boolean;

  @ApiPropertyOptional({
    description:
      'An array of conditions associated with the integration that may influence its behavior or processing logic.',
    type: [StepFilterDto],
  })
  conditions?: StepFilterDto[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class IntegrationResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/dtos/update-integration.dto.ts
Tamaño: 1530 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional } from '@nestjs/swagger';
import { IUpdateIntegrationBodyDto } from '@novu/shared';
import { Type } from 'class-transformer';
import { IsArray, IsBoolean, IsMongoId, IsObject, IsOptional, IsString, ValidateNested } from 'class-validator';
import { StepFilterDto } from '../../shared/dtos/step-filter-dto';
import { CredentialsDto } from './credentials.dto';

export class UpdateIntegrationRequestDto implements IUpdateIntegrationBodyDto {
  @ApiPropertyOptional({ type: String })
  @IsOptional()
  @IsString()
  name?: string;

  @ApiPropertyOptional({ type: String })
  @IsOptional()
  @IsString()
  identifier?: string;

  @ApiPropertyOptional({ type: String })
  @IsOptional()
  @IsMongoId()
  _environmentId?: string;

  @ApiPropertyOptional({
    type: Boolean,
    description: 'If the integration is active the validation on the credentials field will run',
  })
  @IsOptional()
  @IsBoolean()
  active?: boolean;

  @ApiPropertyOptional({
    type: CredentialsDto,
  })
  @IsOptional()
  @Type(() => CredentialsDto)
  @ValidateNested()
  credentials?: CredentialsDto;

  @ApiPropertyOptional({ type: Boolean })
  @IsOptional()
  @IsBoolean()
  check?: boolean;

  @ApiPropertyOptional({
    type: [StepFilterDto],
  })
  @IsArray()
  @IsOptional()
  @ValidateNested({ each: true })
  conditions?: StepFilterDto[];

  @ApiPropertyOptional({
    type: Object,
    description: 'Configurations for the integration',
  })
  @IsOptional()
  @IsObject()
  configurations?: Record<string, string>;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateIntegrationRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/e2e/create-integration.e2e.ts
Tamaño: 21503 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentRepository, IntegrationRepository } from '@novu/dal';
import {
  ChannelTypeEnum,
  ChatProviderIdEnum,
  EmailProviderIdEnum,
  FieldOperatorEnum,
  InAppProviderIdEnum,
  PushProviderIdEnum,
  SmsProviderIdEnum,
} from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Create Integration - /integration (POST) #novu-v2', () => {
  let session: UserSession;
  const integrationRepository = new IntegrationRepository();
  const envRepository = new EnvironmentRepository();

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should get the email integration successfully', async () => {
    const integrations = (await session.testAgent.get(`/v1/integrations`)).body.data;

    const emailIntegrations: any[] = integrations.filter(
      (searchIntegration) =>
        searchIntegration.channel === ChannelTypeEnum.EMAIL && searchIntegration.providerId !== EmailProviderIdEnum.Novu
    );

    expect(emailIntegrations.length).to.eql(2);

    for (const emailIntegration of emailIntegrations) {
      expect(emailIntegration.providerId).to.equal(EmailProviderIdEnum.SendGrid);
      expect(emailIntegration.channel).to.equal(ChannelTypeEnum.EMAIL);
      expect(emailIntegration.credentials.apiKey).to.equal('SG.123');
      expect(emailIntegration.credentials.secretKey).to.equal('abc');
      expect(emailIntegration.active).to.equal(true);
    }
  });

  it('should get the sms integration successfully', async () => {
    const integrations = (await session.testAgent.get(`/v1/integrations`)).body.data;

    const smsIntegrations: any[] = integrations.filter(
      (searchIntegration) =>
        searchIntegration.channel === ChannelTypeEnum.SMS && searchIntegration.providerId !== SmsProviderIdEnum.Novu
    );

    expect(smsIntegrations.length).to.eql(2);

    for (const smsIntegration of smsIntegrations) {
      expect(smsIntegration.providerId).to.equal(SmsProviderIdEnum.Twilio);
      expect(smsIntegration.channel).to.equal(ChannelTypeEnum.SMS);
      expect(smsIntegration.credentials.accountSid).to.equal('AC123');
      expect(smsIntegration.credentials.token).to.equal('123');
      expect(smsIntegration.active).to.equal(true);
    }
  });

  it('should allow creating the same provider on same environment twice', async () => {
    await integrationRepository.deleteMany({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const payload = {
      name: EmailProviderIdEnum.SendGrid,
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      credentials: { apiKey: '123', secretKey: 'abc' },
      active: true,
      check: false,
    };

    await insertIntegrationTwice(session, payload, false);

    const integrations = (await session.testAgent.get(`/v1/integrations`)).body.data;

    const sendgridIntegrations = integrations.filter(
      (integration) =>
        integration.channel === payload.channel &&
        integration._environmentId === session.environment._id &&
        integration.providerId === EmailProviderIdEnum.SendGrid
    );

    expect(sendgridIntegrations.length).to.eql(2);

    for (const integration of sendgridIntegrations) {
      expect(integration.name).to.equal(payload.name);
      expect(integration.identifier).to.exist;
      expect(integration.providerId).to.equal(EmailProviderIdEnum.SendGrid);
      expect(integration.channel).to.equal(ChannelTypeEnum.EMAIL);
      expect(integration.credentials.apiKey).to.equal(payload.credentials.apiKey);
      expect(integration.credentials.secretKey).to.equal(payload.credentials.secretKey);
      expect(integration.active).to.equal(payload.active);
    }
  });

  it('should create integration with conditions', async () => {
    const payload = {
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      identifier: 'identifier-conditions',
      active: false,
      check: false,
      conditions: [
        {
          children: [{ field: 'identifier', value: 'test', operator: FieldOperatorEnum.EQUAL, on: 'tenant' }],
        },
      ],
    };

    const { body } = await session.testAgent.post('/v1/integrations').send(payload);

    expect(body.data.conditions.length).to.equal(1);
    expect(body.data.conditions[0].children.length).to.equal(1);
    expect(body.data.conditions[0].children[0].on).to.equal('tenant');
    expect(body.data.conditions[0].children[0].field).to.equal('identifier');
    expect(body.data.conditions[0].children[0].value).to.equal('test');
    expect(body.data.conditions[0].children[0].operator).to.equal('EQUAL');
  });

  it('should return error with malformed conditions', async () => {
    const payload = {
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      identifier: 'identifier-conditions',
      active: false,
      check: false,
      conditions: [
        {
          children: 'test',
        },
      ],
    };

    const { body } = await session.testAgent.post('/v1/integrations').send(payload);

    expect(body.statusCode).to.equal(400);
    expect(body.error).to.equal('Bad Request');
  });

  it('should not allow to create integration with same identifier', async () => {
    const payload = {
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      identifier: 'identifier',
      active: false,
      check: false,
    };
    await integrationRepository.create({
      name: 'Test',
      identifier: payload.identifier,
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: false,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const { body } = await session.testAgent.post('/v1/integrations').send(payload);

    expect(body.statusCode).to.equal(409);
    expect(body.message).to.equal('Integration with identifier already exists');
  });

  it('should allow creating the integration with minimal data', async () => {
    const payload = {
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      check: false,
    };

    const {
      body: { data },
    } = await session.testAgent.post('/v1/integrations').send(payload);

    expect(data.name).to.equal('SendGrid');
    expect(data.identifier).to.exist;
    expect(data.providerId).to.equal(EmailProviderIdEnum.SendGrid);
    expect(data.channel).to.equal(ChannelTypeEnum.EMAIL);
    expect(data.active).to.equal(false);
  });

  it('should allow creating the integration in the chosen environment', async () => {
    const prodEnv = await envRepository.findOne({ name: 'Production', _organizationId: session.organization._id });
    const payload = {
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      _environmentId: prodEnv?._id,
      check: false,
    };

    const {
      body: { data },
    } = await session.testAgent.post('/v1/integrations').send(payload);

    expect(data.name).to.equal('SendGrid');
    expect(data._environmentId).to.equal(prodEnv?._id);
    expect(data.identifier).to.exist;
    expect(data.providerId).to.equal(EmailProviderIdEnum.SendGrid);
    expect(data.channel).to.equal(ChannelTypeEnum.EMAIL);
    expect(data.active).to.equal(false);
  });

  it('should create custom SMTP integration with TLS options successfully', async () => {
    const payload = {
      providerId: EmailProviderIdEnum.CustomSMTP,
      channel: ChannelTypeEnum.EMAIL,
      credentials: {
        host: 'smtp.example.com',
        port: '587',
        secure: true,
        requireTls: true,
        tlsOptions: { rejectUnauthorized: false },
      },
      active: true,
      check: false,
    };

    const {
      body: { data },
    } = await session.testAgent.post('/v1/integrations').send(payload);

    expect(data.credentials?.host).to.equal(payload.credentials.host);
    expect(data.credentials?.port).to.equal(payload.credentials.port);
    expect(data.credentials?.secure).to.equal(payload.credentials.secure);
    expect(data.credentials?.requireTls).to.equal(payload.credentials.requireTls);
    expect(data.credentials?.tlsOptions).to.instanceOf(Object);
    expect(data.credentials?.tlsOptions).to.eql(payload.credentials.tlsOptions);
    expect(data.active).to.equal(true);
  });

  it('should not calculate primary and priority fields when is not active', async () => {
    const payload = {
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: false,
      check: false,
    };

    const {
      body: { data },
    } = await session.testAgent.post('/v1/integrations').send(payload);

    expect(data.priority).to.equal(0);
    expect(data.primary).to.equal(false);
    expect(data.active).to.equal(false);
  });

  it('should not calculate primary and priority fields for in-app channel', async () => {
    await integrationRepository.deleteMany({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const payload = {
      providerId: InAppProviderIdEnum.Novu,
      channel: ChannelTypeEnum.IN_APP,
      active: true,
      check: false,
    };

    const {
      body: { data },
    } = await session.testAgent.post('/v1/integrations').send(payload);

    expect(data.priority).to.equal(0);
    expect(data.primary).to.equal(false);
    expect(data.active).to.equal(true);
  });

  it('should not calculate primary and priority fields for push channel', async () => {
    const payload = {
      providerId: PushProviderIdEnum.FCM,
      channel: ChannelTypeEnum.PUSH,
      active: true,
      check: false,
    };

    const {
      body: { data },
    } = await session.testAgent.post('/v1/integrations').send(payload);

    expect(data.priority).to.equal(0);
    expect(data.primary).to.equal(false);
    expect(data.active).to.equal(true);
  });

  it('should not calculate primary and priority fields for chat channel', async () => {
    const payload = {
      providerId: ChatProviderIdEnum.Slack,
      channel: ChannelTypeEnum.CHAT,
      active: true,
      check: false,
    };

    const {
      body: { data },
    } = await session.testAgent.post('/v1/integrations').send(payload);

    expect(data.priority).to.equal(0);
    expect(data.primary).to.equal(false);
    expect(data.active).to.equal(true);
  });

  it('should set the integration as primary when its active and there are no other active integrations', async () => {
    await integrationRepository.deleteMany({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const payload = {
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      check: false,
    };

    const {
      body: { data },
    } = await session.testAgent.post('/v1/integrations').send(payload);

    expect(data.priority).to.equal(1);
    expect(data.primary).to.equal(true);
    expect(data.active).to.equal(true);
  });

  it(
    'should not set the integration as primary when its active ' +
      'and there are no other active integrations other than Novu',
    async () => {
      await integrationRepository.deleteMany({
        _organizationId: session.organization._id,
        _environmentId: session.environment._id,
      });

      const novuEmail = await integrationRepository.create({
        name: 'novuEmail',
        identifier: 'novuEmail',
        providerId: EmailProviderIdEnum.Novu,
        channel: ChannelTypeEnum.EMAIL,
        active: true,
        primary: true,
        priority: 1,
        _organizationId: session.organization._id,
        _environmentId: session.environment._id,
      });

      const payload = {
        providerId: EmailProviderIdEnum.SendGrid,
        channel: ChannelTypeEnum.EMAIL,
        active: true,
        check: false,
      };

      const {
        body: { data },
      } = await session.testAgent.post('/v1/integrations').send(payload);

      expect(data.priority).to.equal(1);
      expect(data.primary).to.equal(false);
      expect(data.active).to.equal(true);

      const [first, second] = await integrationRepository.find(
        {
          _organizationId: session.organization._id,
          _environmentId: session.environment._id,
          channel: ChannelTypeEnum.EMAIL,
        },
        undefined,
        { sort: { priority: -1 } }
      );

      expect(first._id).to.equal(novuEmail._id);
      expect(first.primary).to.equal(true);
      expect(first.active).to.equal(true);
      expect(first.priority).to.equal(2);

      expect(second._id).to.equal(data._id);
      expect(second.primary).to.equal(false);
      expect(second.active).to.equal(true);
      expect(second.priority).to.equal(1);
    }
  );

  it('should not set the integration as primary when there is primary integration', async () => {
    await integrationRepository.deleteMany({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const primaryIntegration = await integrationRepository.create({
      name: 'primaryIntegration',
      identifier: 'primaryIntegration',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      primary: true,
      priority: 1,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const payload = {
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      check: false,
    };

    const {
      body: { data },
    } = await session.testAgent.post('/v1/integrations').send(payload);

    expect(data.priority).to.equal(1);
    expect(data.primary).to.equal(false);
    expect(data.active).to.equal(true);

    const [first, second] = await await integrationRepository.find(
      {
        _organizationId: session.organization._id,
        _environmentId: session.environment._id,
        channel: ChannelTypeEnum.EMAIL,
      },
      undefined,
      { sort: { priority: -1 } }
    );

    expect(first._id).to.equal(primaryIntegration._id);
    expect(first.primary).to.equal(true);
    expect(first.active).to.equal(true);
    expect(first.priority).to.equal(2);

    expect(second._id).to.equal(data._id);
    expect(second.primary).to.equal(false);
    expect(second.active).to.equal(true);
    expect(second.priority).to.equal(1);
  });

  it('should calculate the highest priority but not set primary if there is another active integration', async () => {
    await integrationRepository.deleteMany({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const activeIntegration = await integrationRepository.create({
      name: 'activeIntegration',
      identifier: 'activeIntegration',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      primary: true,
      priority: 1,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const payload = {
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      check: false,
    };

    const {
      body: { data },
    } = await session.testAgent.post('/v1/integrations').send(payload);

    expect(data.priority).to.equal(1);
    expect(data.primary).to.equal(false);
    expect(data.active).to.equal(true);

    const [first, second] = await await integrationRepository.find(
      {
        _organizationId: session.organization._id,
        _environmentId: session.environment._id,
        channel: ChannelTypeEnum.EMAIL,
      },
      undefined,
      { sort: { priority: -1 } }
    );

    expect(first._id).to.equal(activeIntegration._id);
    expect(first.primary).to.equal(true);
    expect(first.active).to.equal(true);
    expect(first.priority).to.equal(2);

    expect(second._id).to.equal(data._id);
    expect(second.primary).to.equal(false);
    expect(second.active).to.equal(true);
    expect(second.priority).to.equal(1);
  });

  it('should not disable the novu integration and clear the primary flag if the new integration is created', async () => {
    await integrationRepository.deleteMany({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const novuIntegration = await integrationRepository.create({
      name: 'Novu Integration',
      identifier: 'novuIntegration',
      providerId: EmailProviderIdEnum.Novu,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      primary: true,
      priority: 1,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const payload = {
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      check: false,
    };

    const {
      body: { data },
    } = await session.testAgent.post('/v1/integrations').send(payload);

    const [first, second] = await integrationRepository.find(
      {
        _organizationId: session.organization._id,
        _environmentId: session.environment._id,
        channel: ChannelTypeEnum.EMAIL,
      },
      undefined,
      { sort: { priority: -1 } }
    );

    expect(first._id).to.equal(novuIntegration._id);
    expect(first.primary).to.equal(true);
    expect(first.active).to.equal(true);
    expect(first.priority).to.equal(2);

    expect(second._id).to.equal(data._id);
    expect(second.primary).to.equal(false);
    expect(second.active).to.equal(true);
    expect(second.priority).to.equal(1);
  });

  it('should not allow creating the same novu provider on same environment twice', async () => {
    const inAppPayload = {
      name: InAppProviderIdEnum.Novu,
      providerId: InAppProviderIdEnum.Novu,
      channel: ChannelTypeEnum.IN_APP,
      credentials: {},
      active: true,
      check: false,
    };

    const inAppResult = await session.testAgent.post('/v1/integrations').send(inAppPayload);

    expect(inAppResult.body.statusCode).to.equal(400);
    expect(inAppResult.body.message).to.equal('One environment can only have one In app provider');

    const emailPayload = {
      name: EmailProviderIdEnum.Novu,
      providerId: EmailProviderIdEnum.Novu,
      channel: ChannelTypeEnum.EMAIL,
      credentials: {},
      active: true,
      check: false,
    };

    const emailResult = await session.testAgent.post('/v1/integrations').send(emailPayload);

    expect(emailResult.body.statusCode).to.equal(409);
    expect(emailResult.body.message).to.equal('Integration with novu provider for email channel already exists');

    const smsPayload = {
      name: SmsProviderIdEnum.Novu,
      providerId: SmsProviderIdEnum.Novu,
      channel: ChannelTypeEnum.SMS,
      credentials: {},
      active: true,
      check: false,
    };

    const smsResult = await session.testAgent.post('/v1/integrations').send(smsPayload);

    expect(smsResult.body.statusCode).to.equal(409);
    expect(smsResult.body.message).to.equal('Integration with novu provider for sms channel already exists');
  });

  it('should not allow creating Novu Email integration when credentials are not set', async () => {
    const oldNovuEmailIntegrationApiKey = process.env.NOVU_EMAIL_INTEGRATION_API_KEY;
    process.env.NOVU_EMAIL_INTEGRATION_API_KEY = '';

    const novuEmailIntegrationPayload = {
      name: EmailProviderIdEnum.Novu,
      providerId: EmailProviderIdEnum.Novu,
      channel: ChannelTypeEnum.EMAIL,
      credentials: {},
      active: true,
      check: false,
    };

    const { body } = await session.testAgent.post('/v1/integrations').send(novuEmailIntegrationPayload);

    expect(body.statusCode).to.equal(400);
    expect(body.message).to.equal(
      `Creating Novu integration for ${novuEmailIntegrationPayload.providerId} provider is not allowed`
    );
    process.env.NOVU_EMAIL_INTEGRATION_API_KEY = oldNovuEmailIntegrationApiKey;
  });

  it('should not allow creating Novu SMS integration when credentials are not set', async () => {
    const oldNovuSmsIntegrationAccountSid = process.env.NOVU_SMS_INTEGRATION_ACCOUNT_SID;
    process.env.NOVU_SMS_INTEGRATION_ACCOUNT_SID = '';

    const novuSmsIntegrationPayload = {
      name: SmsProviderIdEnum.Novu,
      providerId: SmsProviderIdEnum.Novu,
      channel: ChannelTypeEnum.SMS,
      credentials: {},
      active: true,
      check: false,
    };

    const { body } = await session.testAgent.post('/v1/integrations').send(novuSmsIntegrationPayload);

    expect(body.statusCode).to.equal(400);
    expect(body.message).to.equal(
      `Creating Novu integration for ${novuSmsIntegrationPayload.providerId} provider is not allowed`
    );
    process.env.NOVU_SMS_INTEGRATION_ACCOUNT_SID = oldNovuSmsIntegrationAccountSid;
  });
});

async function insertIntegrationTwice(
  session: UserSession,
  payload: { credentials: { apiKey: string; secretKey: string }; providerId: string; channel: string; active: boolean },
  createDiffChannels: boolean
) {
  await session.testAgent.post('/v1/integrations').send(payload);

  if (createDiffChannels) {
    payload.channel = ChannelTypeEnum.SMS;
  }

  return await session.testAgent.post('/v1/integrations').send(payload);
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - insertIntegrationTwice(session: UserSession,
  payload: { credentials: { apiKey: string; secretKey: string }; providerId: string; channel: string; active: boolean },
  createDiffChannels: boolean)
Asignaciones con arrow functions encontradas (posibles funciones):
 - envRepository(new EnvironmentRepository();

  beforeEach(async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('should get the email integration suc...)
 - sendgridIntegrations(integrations.filter(
      (integration))
 - smsResult(await session.testAgent.post('/v1/integrations').send(smsPayload);

    expect(smsResult.body.status...)
 - NOVU_EMAIL_INTEGRATION_API_KEY(oldNovuEmailIntegrationApiKey;
  });

  it('should not allow creating Novu SMS integration when cred...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/e2e/deactivate-integration.e2e.ts
Tamaño: 1210 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IntegrationRepository } from '@novu/dal';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Deactivate Integration #novu-v2', () => {
  let session: UserSession;
  const integrationRepository = new IntegrationRepository();

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should not deactivate old providers when a new provider is created', async () => {
    const payload = {
      providerId: 'mailgun',
      channel: 'email',
      credentials: { apiKey: '123', secretKey: 'abc' },
      active: true,
      check: false,
    };

    const environmentId = (await session.testAgent.get(`/v1/integrations`)).body.data[0]._environmentId;

    await session.testAgent.post('/v1/integrations').send(payload);

    const integrations = await integrationRepository.findByEnvironmentId(environmentId);

    const firstIntegration = integrations.find((i) => i.providerId.toString() === 'sendgrid');
    const secondIntegration = integrations.find((i) => i.providerId.toString() === 'mailgun');

    expect(firstIntegration?.active).to.equal(true);
    expect(secondIntegration?.active).to.equal(true);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - integrationRepository(new IntegrationRepository();

  beforeEach(async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('should not deactivate old providers ...)
 - firstIntegration(integrations.find((i))
 - secondIntegration(integrations.find((i))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/e2e/get-active-integration.e2e.ts
Tamaño: 6036 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IntegrationEntity } from '@novu/dal';
import { ChannelTypeEnum, EmailProviderIdEnum, SmsProviderIdEnum } from '@novu/shared';
import { IntegrationService, UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Get Active Integrations - Multi-Provider Configuration - /integrations/active (GET) #novu-v2', () => {
  let session: UserSession;
  const integrationService = new IntegrationService();

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should get active integrations', async () => {
    await integrationService.createIntegration({
      environmentId: session.environment._id,
      organizationId: session.organization._id,
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
    });
    await integrationService.createIntegration({
      environmentId: session.environment._id,
      organizationId: session.organization._id,
      providerId: SmsProviderIdEnum.Twilio,
      channel: ChannelTypeEnum.SMS,
    });

    const activeIntegrations: IntegrationEntity[] = (await session.testAgent.get(`/v1/integrations/active`)).body.data;

    const { inAppIntegration, emailIntegration, smsIntegration, chatIntegration, pushIntegration } =
      splitByChannels(activeIntegrations);

    expect(inAppIntegration.length).to.equal(2);
    expect(emailIntegration.length).to.equal(3);
    expect(smsIntegration.length).to.equal(3);
    expect(pushIntegration.length).to.equal(2);
    expect(chatIntegration.length).to.equal(4);

    const selectedInAppIntegrations = filterEnvIntegrations(inAppIntegration, session.environment._id);
    expect(selectedInAppIntegrations.length).to.equal(0);

    const selectedEmailIntegrations = filterEnvIntegrations(emailIntegration, session.environment._id);
    expect(selectedEmailIntegrations.length).to.equal(1);

    const selectedSmsIntegrations = filterEnvIntegrations(smsIntegration, session.environment._id);
    expect(selectedSmsIntegrations.length).to.equal(1);

    const selectedPushIntegrations = filterEnvIntegrations(pushIntegration, session.environment._id);
    expect(selectedPushIntegrations.length).to.equal(0);

    const selectedChatIntegrations = filterEnvIntegrations(chatIntegration, session.environment._id);
    expect(selectedChatIntegrations.length).to.equal(0);

    for (const integration of activeIntegrations) {
      expect(integration.active).to.equal(true);
    }
  });

  it('should have return empty array if no active integration are exist', async () => {
    await integrationService.deleteAllForOrganization(session.organization._id);
    const response = await session.testAgent.get(`/v1/integrations/active`);

    const normalizeIntegration = response.body.data.filter((integration) => !integration.providerId.includes('novu'));

    expect(normalizeIntegration.length).to.equal(0);
  });

  it('should have additional unselected integration after creating a new one', async () => {
    const initialActiveIntegrations: IntegrationEntity[] = (await session.testAgent.get(`/v1/integrations/active`)).body
      .data;
    const { emailIntegration: initialEmailIntegrations } = splitByChannels(initialActiveIntegrations);

    let allOrgSelectedIntegrations = initialEmailIntegrations.filter((integration) => integration.primary);
    let allEnvSelectedIntegrations = filterEnvIntegrations(initialEmailIntegrations, session.environment._id);
    let allEnvNotSelectedIntegrations = filterEnvIntegrations(initialEmailIntegrations, session.environment._id, false);

    expect(allOrgSelectedIntegrations.length).to.equal(2);
    expect(allEnvSelectedIntegrations.length).to.equal(1);
    expect(allEnvNotSelectedIntegrations.length).to.equal(0);

    await integrationService.createIntegration({
      environmentId: session.environment._id,
      organizationId: session.organization._id,
      providerId: EmailProviderIdEnum.SES,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
    });

    const activeIntegrations: IntegrationEntity[] = (await session.testAgent.get(`/v1/integrations/active`)).body.data;
    const { emailIntegration } = splitByChannels(activeIntegrations);

    allOrgSelectedIntegrations = emailIntegration.filter((integration) => integration.primary);
    allEnvSelectedIntegrations = filterEnvIntegrations(emailIntegration, session.environment._id);
    allEnvNotSelectedIntegrations = filterEnvIntegrations(emailIntegration, session.environment._id, false);

    expect(allOrgSelectedIntegrations.length).to.equal(2);
    expect(allEnvSelectedIntegrations.length).to.equal(1);
    expect(allEnvNotSelectedIntegrations.length).to.equal(1);
  });
});

function filterEnvIntegrations(integrations: IntegrationEntity[], environmentId: string, primary = true) {
  return integrations.filter(
    (integration) => integration.primary === primary && integration._environmentId === environmentId
  );
}

function splitByChannels(activeIntegrations: IntegrationEntity[]) {
  return activeIntegrations.reduce<{
    inAppIntegration: IntegrationEntity[];
    emailIntegration: IntegrationEntity[];
    smsIntegration: IntegrationEntity[];
    chatIntegration: IntegrationEntity[];
    pushIntegration: IntegrationEntity[];
  }>(
    (acc, integration) => {
      if (integration.channel === ChannelTypeEnum.IN_APP) {
        acc.inAppIntegration.push(integration);
      } else if (integration.channel === ChannelTypeEnum.EMAIL) {
        acc.emailIntegration.push(integration);
      } else if (integration.channel === ChannelTypeEnum.SMS) {
        acc.smsIntegration.push(integration);
      } else if (integration.channel === ChannelTypeEnum.CHAT) {
        acc.chatIntegration.push(integration);
      } else if (integration.channel === ChannelTypeEnum.PUSH) {
        acc.pushIntegration.push(integration);
      }

      return acc;
    },
    {
      inAppIntegration: [],
      emailIntegration: [],
      smsIntegration: [],
      chatIntegration: [],
      pushIntegration: [],
    }
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - filterEnvIntegrations(integrations: IntegrationEntity[], environmentId: string, primary = true)
 - splitByChannels(activeIntegrations: IntegrationEntity[])
Asignaciones con arrow functions encontradas (posibles funciones):
 - integrationService(new IntegrationService();

  beforeEach(async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('should get active integrations', asy...)
 - selectedChatIntegrations(filterEnvIntegrations(chatIntegration, session.environment._id);
    expect(selectedChatIntegrations...)
 - normalizeIntegration(response.body.data.filter((integration))
 - allOrgSelectedIntegrations(initialEmailIntegrations.filter((integration))
 - allOrgSelectedIntegrations(emailIntegration.filter((integration))
 - primary(true) {
  return integrations.filter(
    (integration))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/e2e/get-decrypted-integrations.e2e.ts
Tamaño: 2436 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IntegrationRepository } from '@novu/dal';
import { ChannelTypeEnum, EmailProviderIdEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Get Decrypted Integrations - /integrations (GET) #novu-v2', () => {
  let session: UserSession;
  const integrationRepository = new IntegrationRepository();

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should get active decrypted integration', async () => {
    const payload = {
      providerId: EmailProviderIdEnum.Mailgun,
      channel: ChannelTypeEnum.EMAIL,
      credentials: { apiKey: '123', secretKey: 'abc' },
      active: true,
      check: false,
    };

    await session.testAgent.post('/v1/integrations').send(payload);

    const result = (await session.testAgent.get(`/v1/integrations/active`)).body.data;

    // We expect to find the test data 13 with the email one
    expect(result.length).to.eq(13);

    const activeEmailIntegrations = result.filter(
      (integration) =>
        integration.channel === ChannelTypeEnum.EMAIL && integration._environmentId === session.environment._id
    );

    expect(activeEmailIntegrations.length).to.eq(2);

    const mailgun = activeEmailIntegrations.find((el) => el.providerId === EmailProviderIdEnum.Mailgun);

    expect(mailgun.providerId).to.equal('mailgun');
    expect(mailgun.credentials.apiKey).to.equal('123');
    expect(mailgun.credentials.secretKey).to.equal('abc');
    expect(mailgun.active).to.equal(true);

    const environmentIntegrations = await integrationRepository.findByEnvironmentId(session.environment._id);

    // We expect to find the test data 8 with novu provider integrations plus the one created
    expect(environmentIntegrations.length).to.eq(9);

    const encryptedStoredIntegration = environmentIntegrations.find(
      (i) => i.providerId.toString() === EmailProviderIdEnum.Mailgun
    );

    expect(encryptedStoredIntegration?.providerId).to.equal('mailgun');
    expect(encryptedStoredIntegration?.credentials.apiKey).to.contains('nvsk.');
    expect(encryptedStoredIntegration?.credentials.apiKey).to.not.equal('123');
    expect(encryptedStoredIntegration?.credentials.secretKey).to.contains('nvsk.');
    expect(encryptedStoredIntegration?.credentials.secretKey).to.not.equal('abc');
    expect(encryptedStoredIntegration?.active).to.equal(true);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - integrationRepository(new IntegrationRepository();

  beforeEach(async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('should get active decrypted integrat...)
 - activeEmailIntegrations(result.filter(
      (integration))
 - mailgun(activeEmailIntegrations.find((el))
 - encryptedStoredIntegration(environmentIntegrations.find(
      (i))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/e2e/get-in-app-activated.e2e.ts
Tamaño: 1271 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SubscriberRepository } from '@novu/dal';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Get in-app activated - /integrations/in-app/activated (GET) #novu-v2', async () => {
  let session: UserSession;
  let otherSession: UserSession;

  const subscriberRepository = new SubscriberRepository();

  before(async () => {
    session = new UserSession();
    await session.initialize();

    otherSession = new UserSession();
    await otherSession.initialize({
      noOrganization: true,
    });
  });

  it('should get in app activated falsy on organization set up', async () => {
    const { body } = await session.testAgent.get('/v1/integrations/in-app/status').expect(200);

    expect(body.data.active).to.equal(false);
  });

  it('should get in app activated truthy on in-app set up', async () => {
    await subscriberRepository.create({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      subscriberId: 'on-boarding-subscriber-id-123',
      isOnline: true,
      lastOnlineAt: new Date().toISOString(),
    });

    const { body } = await session.testAgent.get('/v1/integrations/in-app/status').expect(200);

    expect(body.data.active).to.equal(true);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - subscriberRepository(new SubscriberRepository();

  before(async ())
 - otherSession(new UserSession();
    await otherSession.initialize({
      noOrganization: true,
    });
  });

  ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/e2e/get-integration.e2e.ts
Tamaño: 3951 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IntegrationEntity } from '@novu/dal';
import { ChannelTypeEnum, EmailProviderIdEnum, SmsProviderIdEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Get Integrations - /integrations (GET) #novu-v2', () => {
  let session: UserSession;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should retrieve all the integrations of all environments from an organization from the prefilled test data', async () => {
    const integrations: IntegrationEntity[] = (await session.testAgent.get(`/v1/integrations`)).body.data;

    expect(integrations.length).to.eq(16);

    const emailIntegrations = integrations
      .filter((integration) => integration.channel === ChannelTypeEnum.EMAIL)
      .filter((integration) => integration.providerId !== EmailProviderIdEnum.Novu);
    expect(emailIntegrations.length).to.eql(2);

    for (const emailIntegration of emailIntegrations) {
      expect(emailIntegration.providerId).to.equal(EmailProviderIdEnum.SendGrid);
      expect(emailIntegration.credentials.apiKey).to.equal('SG.123');
      expect(emailIntegration.credentials.secretKey).to.equal('abc');
      expect(emailIntegration.active).to.equal(true);
    }

    const smsIntegrations = integrations
      .filter((integration) => integration.channel === ChannelTypeEnum.SMS)
      .filter((integration) => integration.providerId !== SmsProviderIdEnum.Novu);
    expect(smsIntegrations.length).to.eql(2);

    const pushIntegrations = integrations.filter((integration) => integration.channel === ChannelTypeEnum.PUSH);
    expect(pushIntegrations.length).to.eql(2);

    const chatIntegrations = integrations.filter((integration) => integration.channel === ChannelTypeEnum.CHAT);
    expect(chatIntegrations.length).to.eql(4);

    const inAppIntegrations = integrations.filter((integration) => integration.channel === ChannelTypeEnum.IN_APP);
    expect(inAppIntegrations.length).to.eql(2);
  });

  it('should get custom SMTP integration details with TLS options', async () => {
    const nodeMailerProviderPayload = {
      providerId: EmailProviderIdEnum.CustomSMTP,
      channel: ChannelTypeEnum.EMAIL,
      credentials: {
        host: 'smtp.example.com',
        port: '587',
        secure: true,
        requireTls: true,
        tlsOptions: { rejectUnauthorized: false },
      },
      active: true,
      check: false,
    };

    // create nodemailer integration added to the existing sendgrid integration
    await session.testAgent.post('/v1/integrations').send(nodeMailerProviderPayload);

    const activeIntegrations: IntegrationEntity[] = (await session.testAgent.get(`/v1/integrations/active`)).body.data;

    expect(activeIntegrations.length).to.eq(13);

    const activeEmailIntegrations = activeIntegrations
      .filter(
        (integration) =>
          integration.channel === ChannelTypeEnum.EMAIL && integration._environmentId === session.environment._id
      )
      .filter((integration) => integration.providerId !== EmailProviderIdEnum.Novu);

    expect(activeEmailIntegrations.length).to.eq(2);

    const customSmtp = activeEmailIntegrations.find((el) => el.providerId === EmailProviderIdEnum.CustomSMTP);

    expect(customSmtp?.active).to.eql(true);
    expect(customSmtp?.credentials?.host).to.equal(nodeMailerProviderPayload.credentials.host);
    expect(customSmtp?.credentials?.port).to.equal(nodeMailerProviderPayload.credentials.port);
    expect(customSmtp?.credentials?.secure).to.equal(nodeMailerProviderPayload.credentials.secure);
    expect(customSmtp?.credentials?.requireTls).to.equal(nodeMailerProviderPayload.credentials.requireTls);
    expect(customSmtp?.credentials?.tlsOptions).to.instanceOf(Object);
    expect(customSmtp?.credentials?.tlsOptions).to.eql(nodeMailerProviderPayload.credentials.tlsOptions);
    expect(customSmtp?.active).to.equal(true);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
    await session.initialize();
  });

  it('should retrieve all the integrations...)
 - emailIntegrations(integrations
      .filter((integration))
 - smsIntegrations(integrations
      .filter((integration))
 - pushIntegrations(integrations.filter((integration))
 - chatIntegrations(integrations.filter((integration))
 - inAppIntegrations(integrations.filter((integration))
 - activeEmailIntegrations(activeIntegrations
      .filter(
        (integration))
 - customSmtp(activeEmailIntegrations.find((el))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/e2e/get-webhook-support-status.e2e.ts
Tamaño: 5252 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IntegrationEntity, IntegrationRepository } from '@novu/dal';
import {
  ChannelTypeEnum,
  ChatProviderIdEnum,
  EmailProviderIdEnum,
  InAppProviderIdEnum,
  PushProviderIdEnum,
  SmsProviderIdEnum,
} from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Get Webhook Support Status - /webhook/provider/:providerOrIntegrationId/status (GET) #novu-v0', () => {
  let session: UserSession;
  const integrationRepository = new IntegrationRepository();

  const checkBadRequestIntegration = async (integration: IntegrationEntity, message: string) => {
    const { body } = await session.testAgent.get(`/v1/integrations/webhook/provider/${integration._id}/status`);
    expect(body.statusCode).to.equal(400);
    expect(body.error).to.equal('Bad Request');
    expect(body.message).to.equal(message);
  };

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    await integrationRepository.deleteMany({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });
  });

  it("should throw not found error when integration doesn't exist", async () => {
    const notExistingIntegrationId = IntegrationRepository.createObjectId();

    const { body } = await session.testAgent.get(
      `/v1/integrations/webhook/provider/${notExistingIntegrationId}/status`
    );
    expect(body.statusCode).to.equal(404);
    expect(body.error).to.equal('Not Found');
    expect(body.message).to.equal(`Integration for ${notExistingIntegrationId} was not found`);
  });

  it("should throw bad request error when integration doesn't have credentials", async () => {
    const integration = await integrationRepository.create({
      name: 'Test',
      identifier: 'sendgrid',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: false,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    await checkBadRequestIntegration(integration, `Integration ${integration._id} doesn't have credentials set up`);
  });

  it('should throw bad request error for chat, push, in-app integrations', async () => {
    const slackIntegration = await integrationRepository.create({
      name: 'Slack',
      identifier: 'slack',
      providerId: ChatProviderIdEnum.Slack,
      channel: ChannelTypeEnum.CHAT,
      active: true,
      credentials: {
        apiKey: '',
      },
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });
    await checkBadRequestIntegration(
      slackIntegration,
      `Webhook for ${slackIntegration.providerId}-${slackIntegration.channel} is not supported yet`
    );

    const fcmIntegration = await integrationRepository.create({
      name: 'FCM',
      identifier: 'push',
      providerId: PushProviderIdEnum.FCM,
      channel: ChannelTypeEnum.PUSH,
      active: true,
      credentials: {
        apiKey: '',
      },
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });
    await checkBadRequestIntegration(
      fcmIntegration,
      `Webhook for ${fcmIntegration.providerId}-${fcmIntegration.channel} is not supported yet`
    );

    const novuIntegration = await integrationRepository.create({
      name: 'Novu',
      identifier: 'novu',
      providerId: InAppProviderIdEnum.Novu,
      channel: ChannelTypeEnum.IN_APP,
      active: true,
      credentials: {
        apiKey: '',
      },
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });
    await checkBadRequestIntegration(
      novuIntegration,
      `Webhook for ${novuIntegration.providerId}-${novuIntegration.channel} is not supported yet`
    );
  });

  it('should return true if provider supports parsing events', async () => {
    const integration = await integrationRepository.create({
      name: 'Test',
      identifier: 'sendgrid',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      credentials: {
        apiKey: '',
      },
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const { body, statusCode } = await session.testAgent.get(
      `/v1/integrations/webhook/provider/${integration._id}/status`
    );
    expect(statusCode).to.equal(200);
    expect(body.data).to.equal(true);
  });

  it("should return false if provider doesn't support parsing events", async () => {
    const integration = await integrationRepository.create({
      name: 'AfricasTalking',
      identifier: 'africastalking',
      providerId: SmsProviderIdEnum.AfricasTalking,
      channel: ChannelTypeEnum.SMS,
      active: true,
      credentials: {
        apiKey: 'asdf',
        user: 'asdf',
        from: 'asdf',
      },
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const { body, statusCode } = await session.testAgent.get(
      `/v1/integrations/webhook/provider/${integration._id}/status`
    );
    expect(statusCode).to.equal(200);
    expect(body.data).to.equal(false);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - checkBadRequestIntegration(async (integration: IntegrationEntity, message: string))
 - session(new UserSession();
    await session.initialize();
    await integrationRepository.deleteMany({
    ...)
 - integration(await integrationRepository.create({
      name: 'Test',
      identifier: 'sendgrid',
      provide...)
 - novuIntegration(await integrationRepository.create({
      name: 'Novu',
      identifier: 'novu',
      providerId:...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/e2e/remove-integration.e2e.ts
Tamaño: 8384 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { HttpStatus } from '@nestjs/common';
import { IntegrationRepository } from '@novu/dal';
import { ChannelTypeEnum, ChatProviderIdEnum, EmailProviderIdEnum, PushProviderIdEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Delete Integration - /integration/:integrationId (DELETE) #novu-v2', () => {
  let session: UserSession;
  const integrationRepository = new IntegrationRepository();

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should throw not found exception when integration is not found', async () => {
    const integrationId = IntegrationRepository.createObjectId();
    const { body } = await session.testAgent.delete(`/v1/integrations/${integrationId}`).send();

    expect(body.statusCode).to.equal(404);
    expect(body.message).to.equal(`Entity with id ${integrationId} not found`);
  });

  it('should not recalculate primary and priority fields for push channel', async () => {
    await integrationRepository.deleteMany({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const primaryIntegration = await integrationRepository.create({
      name: 'primaryIntegration',
      identifier: 'primaryIntegration',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      primary: true,
      priority: 2,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const integration = await integrationRepository.create({
      name: 'integration',
      identifier: 'integration',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      primary: false,
      priority: 1,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const pushIntegration = await integrationRepository.create({
      name: 'FCM',
      identifier: 'identifier1',
      providerId: PushProviderIdEnum.FCM,
      channel: ChannelTypeEnum.PUSH,
      active: false,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const { statusCode } = await session.testAgent.delete(`/v1/integrations/${pushIntegration._id}`).send();
    expect(statusCode).to.equal(200);

    const [first, second] = await integrationRepository.find(
      {
        _organizationId: session.organization._id,
        _environmentId: session.environment._id,
        channel: ChannelTypeEnum.EMAIL,
      },
      undefined,
      { sort: { priority: -1 } }
    );

    expect(first._id).to.equal(primaryIntegration._id);
    expect(first.primary).to.equal(true);
    expect(first.active).to.equal(true);
    expect(first.priority).to.equal(2);

    expect(second._id).to.equal(integration._id);
    expect(second.primary).to.equal(false);
    expect(second.active).to.equal(true);
    expect(second.priority).to.equal(1);
  });

  it('should not recalculate primary and priority fields for chat channel', async () => {
    await integrationRepository.deleteMany({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const primaryIntegration = await integrationRepository.create({
      name: 'primaryIntegration',
      identifier: 'primaryIntegration',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      primary: true,
      priority: 2,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const integration = await integrationRepository.create({
      name: 'integration',
      identifier: 'integration',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      primary: false,
      priority: 1,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const chatIntegration = await integrationRepository.create({
      name: 'Slack',
      identifier: 'identifier1',
      providerId: ChatProviderIdEnum.Slack,
      channel: ChannelTypeEnum.CHAT,
      active: false,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const { statusCode } = await session.testAgent.delete(`/v1/integrations/${chatIntegration._id}`).send();
    expect(statusCode).to.equal(200);

    const [first, second] = await integrationRepository.find(
      {
        _organizationId: session.organization._id,
        _environmentId: session.environment._id,
        channel: ChannelTypeEnum.EMAIL,
      },
      undefined,
      { sort: { priority: -1 } }
    );

    expect(first._id).to.equal(primaryIntegration._id);
    expect(first.primary).to.equal(true);
    expect(first.active).to.equal(true);
    expect(first.priority).to.equal(2);

    expect(second._id).to.equal(integration._id);
    expect(second.primary).to.equal(false);
    expect(second.active).to.equal(true);
    expect(second.priority).to.equal(1);
  });

  it('should recalculate primary and priority fields for email channel', async () => {
    await integrationRepository.deleteMany({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const primaryIntegration = await integrationRepository.create({
      name: 'primaryIntegration',
      identifier: 'primaryIntegration',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      primary: true,
      priority: 3,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const integrationOne = await integrationRepository.create({
      name: 'integrationOne',
      identifier: 'integrationOne',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      primary: false,
      priority: 2,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const integrationTwo = await integrationRepository.create({
      name: 'integrationTwo',
      identifier: 'integrationTwo',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      primary: false,
      priority: 2,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const { statusCode } = await session.testAgent.delete(`/v1/integrations/${integrationOne._id}`).send();
    expect(statusCode).to.equal(200);

    const [first, second] = await integrationRepository.find(
      {
        _organizationId: session.organization._id,
        _environmentId: session.environment._id,
        channel: ChannelTypeEnum.EMAIL,
      },
      undefined,
      { sort: { priority: -1 } }
    );

    expect(first._id).to.equal(primaryIntegration._id);
    expect(first.primary).to.equal(true);
    expect(first.active).to.equal(true);
    expect(first.priority).to.equal(2);

    expect(second._id).to.equal(integrationTwo._id);
    expect(second.primary).to.equal(false);
    expect(second.active).to.equal(true);
    expect(second.priority).to.equal(1);
  });

  it('should remove a newly created integration', async () => {
    const payload = {
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      credentials: { apiKey: '123', secretKey: 'abc' },
      active: true,
      check: false,
    };

    const integration = await session.testAgent.post('/v1/integrations').send(payload);
    expect(integration.status).to.equal(HttpStatus.CREATED);
    const integrationId = integration.body.data._id;

    const res = await session.testAgent.delete(`/v1/integrations/${integrationId}`).send();
    expect(res.status).to.equal(HttpStatus.OK);

    const isDeleted = !(await integrationRepository.findOne({
      _environmentId: session.environment._id,
      _id: integrationId,
    }));

    expect(isDeleted).to.equal(true);

    const deletedIntegration = (
      await integrationRepository.findDeleted({ _environmentId: session.environment._id, _id: integrationId })
    )[0];

    expect(deletedIntegration.deleted).to.equal(true);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - integrationRepository(new IntegrationRepository();

  beforeEach(async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('should throw not found exception whe...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/e2e/set-itegration-as-primary.e2e.ts
Tamaño: 16511 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IntegrationEntity, IntegrationRepository } from '@novu/dal';
import {
  ChannelTypeEnum,
  ChatProviderIdEnum,
  EmailProviderIdEnum,
  InAppProviderIdEnum,
  PushProviderIdEnum,
} from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Set Integration As Primary - /integrations/:integrationId/set-primary (POST) #novu-v2', () => {
  let session: UserSession;
  const integrationRepository = new IntegrationRepository();

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('when integration id is not valid should throw bad request exception', async () => {
    const fakeIntegrationId = 'fakeIntegrationId';

    const { body } = await session.testAgent.post(`/v1/integrations/${fakeIntegrationId}/set-primary`).send({});
    expect(body.statusCode).to.equal(422);
    expect(body.errors.integrationId.messages[0]).to.equal(`integrationId must be a mongodb id`);
  });

  it('when integration does not exist should throw not found exception', async () => {
    const fakeIntegrationId = IntegrationRepository.createObjectId();

    const { body } = await session.testAgent.post(`/v1/integrations/${fakeIntegrationId}/set-primary`).send({});

    expect(body.statusCode).to.equal(404);
    expect(body.message).to.equal(`Integration with id ${fakeIntegrationId} not found`);
  });

  it('in-app channel does not support primary flag, then for integration it should throw bad request exception', async () => {
    await integrationRepository.deleteMany({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const inAppIntegration = await integrationRepository.create({
      name: 'Novu In-App',
      identifier: 'identifier1',
      providerId: InAppProviderIdEnum.Novu,
      channel: ChannelTypeEnum.IN_APP,
      active: false,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const { body } = await session.testAgent.post(`/v1/integrations/${inAppIntegration._id}/set-primary`).send({});

    expect(body.statusCode).to.equal(400);
    expect(body.message).to.equal(`Channel ${inAppIntegration.channel} does not support primary`);
  });

  it('clears conditions when set as primary', async () => {
    await integrationRepository.deleteMany({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const integration = await integrationRepository.create({
      name: 'Email with conditions',
      identifier: 'identifier1',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: false,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
      conditions: [{}],
    });

    await session.testAgent.post(`/v1/integrations/${integration._id}/set-primary`).send({});

    const found = await integrationRepository.findOne({
      _id: integration._id,
      _organizationId: session.organization._id,
    });

    expect(found?.conditions).to.deep.equal([]);
    expect(found?.primary).to.equal(true);
  });

  it('push channel does not support primary flag, then for integration it should throw bad request exception', async () => {
    await integrationRepository.deleteMany({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const pushIntegration = await integrationRepository.create({
      name: 'FCM',
      identifier: 'identifier1',
      providerId: PushProviderIdEnum.FCM,
      channel: ChannelTypeEnum.PUSH,
      active: false,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const { body } = await session.testAgent.post(`/v1/integrations/${pushIntegration._id}/set-primary`).send({});

    expect(body.statusCode).to.equal(400);
    expect(body.message).to.equal(`Channel ${pushIntegration.channel} does not support primary`);
  });

  it('chat channel does not support primary flag, then for integration it should throw bad request exception', async () => {
    await integrationRepository.deleteMany({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const chatIntegration = await integrationRepository.create({
      name: 'Slack',
      identifier: 'identifier1',
      providerId: ChatProviderIdEnum.Slack,
      channel: ChannelTypeEnum.CHAT,
      active: false,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const { body } = await session.testAgent.post(`/v1/integrations/${chatIntegration._id}/set-primary`).send({});

    expect(body.statusCode).to.equal(400);
    expect(body.message).to.equal(`Channel ${chatIntegration.channel} does not support primary`);
  });

  it('should not update the primary integration if already is primary', async () => {
    await integrationRepository.deleteMany({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const integrationOne = await integrationRepository.create({
      name: 'Test1',
      identifier: 'identifier1',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: false,
      primary: true,
      priority: 1,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const {
      body: { data },
    } = await session.testAgent.post(`/v1/integrations/${integrationOne._id}/set-primary`).send({});

    expect(data.primary).to.equal(true);
    expect(data.priority).to.equal(1);
  });

  it('should set primary and active when there are no other active integrations', async () => {
    await integrationRepository.deleteMany({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const integrationOne = await integrationRepository.create({
      name: 'Test1',
      identifier: 'identifier1',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: false,
      primary: false,
      priority: 0,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const {
      body: { data },
    } = await session.testAgent.post(`/v1/integrations/${integrationOne._id}/set-primary`).send({});

    expect(data.primary).to.equal(true);
    expect(data.active).to.equal(true);
    expect(data.priority).to.equal(1);
  });

  it('should set primary and active and update old primary', async () => {
    await integrationRepository.deleteMany({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const oldPrimaryIntegration = await integrationRepository.create({
      name: 'Test1',
      identifier: 'primaryIdentifier',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      primary: true,
      priority: 1,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const integrationOne = await integrationRepository.create({
      name: 'Test1',
      identifier: 'identifier1',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: false,
      primary: false,
      priority: 0,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const {
      body: { data },
    } = await session.testAgent.post(`/v1/integrations/${integrationOne._id}/set-primary`).send({});

    expect(data.primary).to.equal(true);
    expect(data.active).to.equal(true);
    expect(data.priority).to.equal(2);

    const updatedOldPrimary = (await integrationRepository.findOne({
      _id: oldPrimaryIntegration._id,
      _environmentId: oldPrimaryIntegration._environmentId,
    })) as IntegrationEntity;

    expect(updatedOldPrimary.primary).to.equal(false);
    expect(updatedOldPrimary.active).to.equal(true);
    expect(updatedOldPrimary.priority).to.equal(1);
  });

  it('should set primary and active and update priority for other active integrations', async () => {
    await integrationRepository.deleteMany({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const oldPrimaryIntegration = await integrationRepository.create({
      name: 'oldPrimaryIntegration',
      identifier: 'oldPrimaryIntegration',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      primary: true,
      priority: 2,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const activeIntegration = await integrationRepository.create({
      name: 'activeIntegration',
      identifier: 'activeIntegration',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      primary: false,
      priority: 1,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const inactiveIntegration = await integrationRepository.create({
      name: 'inactiveIntegration',
      identifier: 'inactiveIntegration',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: false,
      primary: false,
      priority: 0,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const integrationToSetPrimary = await integrationRepository.create({
      name: 'integrationToSetPrimary',
      identifier: 'identifier1',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: false,
      primary: false,
      priority: 0,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const {
      body: { data },
    } = await session.testAgent.post(`/v1/integrations/${integrationToSetPrimary._id}/set-primary`).send({});

    expect(data.primary).to.equal(true);
    expect(data.active).to.equal(true);
    expect(data.priority).to.equal(3);

    const [first, second, third, fourth] = await await integrationRepository.find(
      {
        _organizationId: session.organization._id,
        _environmentId: session.environment._id,
        channel: ChannelTypeEnum.EMAIL,
      },
      undefined,
      { sort: { priority: -1 } }
    );

    expect(first._id).to.equal(data._id);
    expect(first.primary).to.equal(true);
    expect(first.active).to.equal(true);
    expect(first.priority).to.equal(3);

    expect(second._id).to.equal(oldPrimaryIntegration._id);
    expect(second.primary).to.equal(false);
    expect(second.active).to.equal(true);
    expect(second.priority).to.equal(2);

    expect(third._id).to.equal(activeIntegration._id);
    expect(third.primary).to.equal(false);
    expect(third.active).to.equal(true);
    expect(third.priority).to.equal(1);

    expect(fourth._id).to.equal(inactiveIntegration._id);
    expect(fourth.primary).to.equal(false);
    expect(fourth.active).to.equal(false);
    expect(fourth.priority).to.equal(0);
  });

  it('should allow set primary for active and recalculate priority for other', async () => {
    await integrationRepository.deleteMany({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const oldPrimaryIntegration = await integrationRepository.create({
      name: 'oldPrimaryIntegration',
      identifier: 'oldPrimaryIntegration',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      primary: true,
      priority: 3,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const activeIntegrationOne = await integrationRepository.create({
      name: 'activeIntegrationOne',
      identifier: 'activeIntegrationOne',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      primary: false,
      priority: 2,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const activeIntegrationTwo = await integrationRepository.create({
      name: 'activeIntegrationTwo',
      identifier: 'activeIntegrationTwo',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      primary: false,
      priority: 1,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const {
      body: { data },
    } = await session.testAgent.post(`/v1/integrations/${activeIntegrationTwo._id}/set-primary`).send({});

    expect(data.primary).to.equal(true);
    expect(data.active).to.equal(true);
    expect(data.priority).to.equal(3);

    const [first, second, third] = await await integrationRepository.find(
      {
        _organizationId: session.organization._id,
        _environmentId: session.environment._id,
        channel: ChannelTypeEnum.EMAIL,
      },
      undefined,
      { sort: { priority: -1 } }
    );

    expect(first._id).to.equal(activeIntegrationTwo._id);
    expect(first.primary).to.equal(true);
    expect(first.active).to.equal(true);
    expect(first.priority).to.equal(3);

    expect(second._id).to.equal(oldPrimaryIntegration._id);
    expect(second.primary).to.equal(false);
    expect(second.active).to.equal(true);
    expect(second.priority).to.equal(2);

    expect(third._id).to.equal(activeIntegrationOne._id);
    expect(third.primary).to.equal(false);
    expect(third.active).to.equal(true);
    expect(third.priority).to.equal(1);
  });

  it('should allow to set primary and do not recalculate priority for all inactive', async () => {
    await integrationRepository.deleteMany({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const inactiveIntegrationOne = await integrationRepository.create({
      name: 'inactiveIntegrationOne',
      identifier: 'inactiveIntegrationOne',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: false,
      primary: false,
      priority: 0,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const inactiveIntegrationTwo = await integrationRepository.create({
      name: 'inactiveIntegrationTwo',
      identifier: 'inactiveIntegrationTwo',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: false,
      primary: false,
      priority: 0,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const integrationToSetPrimary = await integrationRepository.create({
      name: 'integrationToSetPrimary',
      identifier: 'integrationToSetPrimary',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: false,
      primary: false,
      priority: 0,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const {
      body: { data },
    } = await session.testAgent.post(`/v1/integrations/${integrationToSetPrimary._id}/set-primary`).send({});

    expect(data.primary).to.equal(true);
    expect(data.active).to.equal(true);
    expect(data.priority).to.equal(1);

    const [first, second, third] = await await integrationRepository.find(
      {
        _organizationId: session.organization._id,
        _environmentId: session.environment._id,
        channel: ChannelTypeEnum.EMAIL,
      },
      undefined,
      { sort: { priority: -1 } }
    );

    expect(first._id).to.equal(integrationToSetPrimary._id);
    expect(first.primary).to.equal(true);
    expect(first.active).to.equal(true);
    expect(first.priority).to.equal(1);

    expect(second._id).to.equal(inactiveIntegrationOne._id);
    expect(second.primary).to.equal(false);
    expect(second.active).to.equal(false);
    expect(second.priority).to.equal(0);

    expect(third._id).to.equal(inactiveIntegrationTwo._id);
    expect(third.primary).to.equal(false);
    expect(third.active).to.equal(false);
    expect(third.priority).to.equal(0);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - integrationRepository(new IntegrationRepository();

  beforeEach(async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('when integration id is not valid sho...)
 - found(await integrationRepository.findOne({
      _id: integration._id,
      _organizationId: session.org...)
 - updatedOldPrimary(await integrationRepository.findOne({
      _id: oldPrimaryIntegration._id,
      _environmentId: ol...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/e2e/update-integration.e2e.ts
Tamaño: 31423 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CommunityOrganizationRepository, EnvironmentRepository, IntegrationRepository } from '@novu/dal';
import {
  ChannelTypeEnum,
  ChatProviderIdEnum,
  EmailProviderIdEnum,
  FieldOperatorEnum,
  InAppProviderIdEnum,
  ITenantFilterPart,
  PushProviderIdEnum,
} from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Update Integration - /integrations/:integrationId (PUT) #novu-v2', () => {
  let session: UserSession;
  const integrationRepository = new IntegrationRepository();
  const envRepository = new EnvironmentRepository();

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should throw not found exception when integration is not found', async () => {
    const integrationId = IntegrationRepository.createObjectId();
    const payload = {
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      credentials: { apiKey: 'new_key', secretKey: 'new_secret' },
      active: true,
      check: false,
    };

    const { body } = await session.testAgent.put(`/v1/integrations/${integrationId}`).send(payload);

    expect(body.statusCode).to.equal(404);
    expect(body.message).to.equal(`Entity with id ${integrationId} not found`);
  });

  it('should update newly created integration', async () => {
    const payload = {
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      credentials: { apiKey: 'new_key', secretKey: 'new_secret' },
      active: true,
      check: false,
    };

    payload.credentials = { apiKey: 'new_key', secretKey: 'new_secret' };

    const integrationId = (await session.testAgent.get(`/v1/integrations`)).body.data.find(
      (integration) => integration.channel === 'email'
    )._id;

    // update integration
    await session.testAgent.put(`/v1/integrations/${integrationId}`).send(payload);

    const integration = (await session.testAgent.get(`/v1/integrations`)).body.data.find(
      (fetchedIntegration) => fetchedIntegration._id === integrationId
    );

    expect(integration.credentials.apiKey).to.equal(payload.credentials.apiKey);
    expect(integration.credentials.secretKey).to.equal(payload.credentials.secretKey);
  });

  it('should update conditions on integration', async () => {
    const payload = {
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      credentials: { apiKey: 'SG.123', secretKey: 'abc' },
      active: true,
      check: false,
      conditions: [
        {
          children: [{ field: 'identifier', value: 'test', operator: FieldOperatorEnum.EQUAL, on: 'tenant' }],
        },
      ],
    };

    const { data } = (await session.testAgent.get(`/v1/integrations`)).body;

    const integration = data.find((i) => i.primary && i.channel === 'email');

    expect(integration.conditions.length).to.equal(0);

    await session.testAgent.put(`/v1/integrations/${integration._id}`).send(payload);

    const result = await integrationRepository.findOne({
      _id: integration._id,
      _organizationId: session.organization._id,
    });

    expect(result?.conditions?.length).to.equal(1);
    expect(result?.primary).to.equal(false);
    expect(result?.conditions?.at(0)?.children.length).to.equal(1);
    expect(result?.conditions?.at(0)?.children.at(0)?.on).to.equal('tenant');
    expect((result?.conditions?.at(0)?.children.at(0) as ITenantFilterPart)?.field).to.equal('identifier');
    expect((result?.conditions?.at(0)?.children.at(0) as ITenantFilterPart)?.value).to.equal('test');
    expect((result?.conditions?.at(0)?.children.at(0) as ITenantFilterPart)?.operator).to.equal('EQUAL');
  });

  it('should return error with malformed conditions', async () => {
    const payload = {
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      credentials: { apiKey: 'SG.123', secretKey: 'abc' },
      active: true,
      check: false,
      conditions: [
        {
          children: 'test',
        },
      ],
    };

    const { data } = (await session.testAgent.get(`/v1/integrations`)).body;

    const integration = data.find((i) => i.primary && i.channel === 'email');

    expect(integration.conditions.length).to.equal(0);

    const { body } = await session.testAgent.put(`/v1/integrations/${integration._id}`).send(payload);

    expect(body.statusCode).to.equal(400);
    expect(body.error).to.equal('Bad Request');
  });

  it('should not allow to update the integration with same identifier', async () => {
    const identifier2 = 'identifier2';
    const integrationOne = await integrationRepository.create({
      name: 'Test1',
      identifier: 'identifier1',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: false,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });
    await integrationRepository.create({
      name: 'Test2',
      identifier: identifier2,
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: false,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });
    const payload = {
      identifier: identifier2,
      check: false,
    };

    const { body } = await session.testAgent.put(`/v1/integrations/${integrationOne._id}`).send(payload);

    expect(body.statusCode).to.equal(409);
    expect(body.message).to.equal('Integration with identifier already exists');
  });

  it('should allow updating the integration with just identifier', async () => {
    const integrationOne = await integrationRepository.create({
      name: 'Test',
      identifier: 'identifier',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: false,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const payload = {
      identifier: 'identifier2',
      check: false,
    };

    const {
      body: { data },
    } = await session.testAgent.put(`/v1/integrations/${integrationOne._id}`).send(payload);

    expect(data.identifier).to.eq(payload.identifier);
  });

  it('should allow updating the integration with just name', async () => {
    const integrationOne = await integrationRepository.create({
      name: 'Test',
      identifier: 'identifier',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: false,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const payload = {
      name: 'Test2',
      check: false,
    };

    const {
      body: { data },
    } = await session.testAgent.put(`/v1/integrations/${integrationOne._id}`).send(payload);

    expect(data.name).to.eq(payload.name);
  });

  it('should allow updating the integration with just environment', async () => {
    const integrationOne = await integrationRepository.create({
      name: 'Test',
      identifier: 'identifier',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: false,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });
    const prodEnv = await envRepository.findOne({ name: 'Production', _organizationId: session.organization._id });
    const payload = {
      _environmentId: prodEnv?._id,
      check: false,
    };

    const {
      body: { data },
    } = await session.testAgent.put(`/v1/integrations/${integrationOne._id}`).send(payload);

    expect(data._environmentId).to.equal(prodEnv?._id);
  });

  it('should update custom SMTP integration with TLS options successfully', async () => {
    const nodeMailerProviderPayload = {
      providerId: 'nodemailer',
      channel: 'email',
      credentials: {
        host: 'smtp.example.com',
        port: '587',
        secure: true,
        requireTls: true,
        tlsOptions: { rejectUnauthorized: false },
      },
      active: true,
      check: false,
    };

    // create integration
    const nodeMailerIntegrationId = (await session.testAgent.post('/v1/integrations').send(nodeMailerProviderPayload))
      .body.data._id;

    // update integration
    const updatedNodeMailerProviderPayload = {
      providerId: 'nodemailer',
      channel: 'email',
      credentials: {
        host: 'smtp.example.com',
        port: '587',
        secure: true,
        requireTls: false,
        tlsOptions: { rejectUnauthorized: false, enableTrace: true },
      },
      active: true,
      check: false,
    };
    await session.testAgent.put(`/v1/integrations/${nodeMailerIntegrationId}`).send(updatedNodeMailerProviderPayload);

    const integrations = await integrationRepository.findByEnvironmentId(session.environment._id);

    const nodeMailerIntegration = integrations.find((i) => i.providerId.toString() === 'nodemailer');

    expect(nodeMailerIntegration?.credentials?.host).to.equal(updatedNodeMailerProviderPayload.credentials.host);
    expect(nodeMailerIntegration?.credentials?.port).to.equal(updatedNodeMailerProviderPayload.credentials.port);
    expect(nodeMailerIntegration?.credentials?.secure).to.equal(updatedNodeMailerProviderPayload.credentials.secure);
    expect(nodeMailerIntegration?.credentials?.requireTls).to.equal(
      updatedNodeMailerProviderPayload.credentials.requireTls
    );
    expect(nodeMailerIntegration?.credentials?.tlsOptions).to.instanceOf(Object);
    expect(nodeMailerIntegration?.credentials?.tlsOptions).to.eql(
      updatedNodeMailerProviderPayload.credentials.tlsOptions
    );
    expect(nodeMailerIntegration?.active).to.equal(true);
  });

  it('should not calculate primary and priority if active is not defined', async () => {
    await integrationRepository.deleteMany({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const emailIntegration = await integrationRepository.create({
      name: 'SendGrid',
      identifier: 'identifier1',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: false,
      primary: false,
      priority: 0,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const payload = {
      name: 'SendGrid Email',
      check: false,
    };

    const {
      body: { data },
    } = await session.testAgent.put(`/v1/integrations/${emailIntegration._id}`).send(payload);

    expect(data.name).to.equal('SendGrid Email');
    expect(data.priority).to.equal(0);
    expect(data.primary).to.equal(false);
    expect(data.active).to.equal(false);
  });

  it('should not calculate primary and priority if active not changed', async () => {
    await integrationRepository.deleteMany({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const emailIntegration = await integrationRepository.create({
      name: 'SendGrid Email',
      identifier: 'identifier1',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: false,
      primary: false,
      priority: 0,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const payload = {
      active: false,
      check: false,
    };

    const {
      body: { data },
    } = await session.testAgent.put(`/v1/integrations/${emailIntegration._id}`).send(payload);

    expect(data.priority).to.equal(0);
    expect(data.primary).to.equal(false);
    expect(data.active).to.equal(false);
  });

  it('should not calculate primary and priority fields for in-app channel', async () => {
    await integrationRepository.deleteMany({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const inAppIntegration = await integrationRepository.create({
      name: 'Novu In-App',
      identifier: 'identifier1',
      providerId: InAppProviderIdEnum.Novu,
      channel: ChannelTypeEnum.IN_APP,
      active: false,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const payload = {
      active: true,
      check: false,
    };

    const {
      body: { data },
    } = await session.testAgent.put(`/v1/integrations/${inAppIntegration._id}`).send(payload);

    expect(data.priority).to.equal(0);
    expect(data.primary).to.equal(false);
    expect(data.active).to.equal(true);
  });

  it('should not calculate primary and priority fields for push channel', async () => {
    await integrationRepository.deleteMany({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const pushIntegration = await integrationRepository.create({
      name: 'FCM',
      identifier: 'identifier1',
      providerId: PushProviderIdEnum.FCM,
      channel: ChannelTypeEnum.PUSH,
      active: false,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const payload = {
      active: true,
      check: false,
    };

    const {
      body: { data },
    } = await session.testAgent.put(`/v1/integrations/${pushIntegration._id}`).send(payload);

    expect(data.priority).to.equal(0);
    expect(data.primary).to.equal(false);
    expect(data.active).to.equal(true);
  });

  it('should not calculate primary and priority fields for chat channel', async () => {
    await integrationRepository.deleteMany({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const chatIntegration = await integrationRepository.create({
      name: 'Slack',
      identifier: 'identifier1',
      providerId: ChatProviderIdEnum.Slack,
      channel: ChannelTypeEnum.CHAT,
      active: false,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const payload = {
      active: true,
      check: false,
    };

    const {
      body: { data },
    } = await session.testAgent.put(`/v1/integrations/${chatIntegration._id}`).send(payload);

    expect(data.priority).to.equal(0);
    expect(data.primary).to.equal(false);
    expect(data.active).to.equal(true);
  });

  it('should not set the primary if there are no other active integrations', async () => {
    await integrationRepository.deleteMany({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const integration = await integrationRepository.create({
      name: 'integration',
      identifier: 'integration',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: false,
      primary: false,
      priority: 0,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const payload = {
      active: true,
      check: false,
    };

    const {
      body: { data },
    } = await session.testAgent.put(`/v1/integrations/${integration._id}`).send(payload);

    expect(data.priority).to.equal(1);
    expect(data.primary).to.equal(false);
    expect(data.active).to.equal(true);
  });

  it('should not set the primary if there is only Novu active integration', async () => {
    await integrationRepository.deleteMany({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const novuEmail = await integrationRepository.create({
      name: 'novuEmail',
      identifier: 'novuEmail',
      providerId: EmailProviderIdEnum.Novu,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      primary: true,
      priority: 1,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const integration = await integrationRepository.create({
      name: 'integration',
      identifier: 'integration',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: false,
      primary: false,
      priority: 0,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const payload = {
      active: true,
      check: false,
    };

    const {
      body: { data },
    } = await session.testAgent.put(`/v1/integrations/${integration._id}`).send(payload);

    expect(data.priority).to.equal(1);
    expect(data.primary).to.equal(false);
    expect(data.active).to.equal(true);

    const [first, second] = await integrationRepository.find(
      {
        _organizationId: session.organization._id,
        _environmentId: session.environment._id,
        channel: ChannelTypeEnum.EMAIL,
      },
      undefined,
      { sort: { priority: -1 } }
    );

    expect(first._id).to.equal(novuEmail._id);
    expect(first.primary).to.equal(true);
    expect(first.active).to.equal(true);
    expect(first.priority).to.equal(2);

    expect(second._id).to.equal(integration._id);
    expect(second.primary).to.equal(false);
    expect(second.active).to.equal(true);
    expect(second.priority).to.equal(1);
  });

  it('should calculate the highest priority but not set primary if there is another active integration', async () => {
    await integrationRepository.deleteMany({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const firstActiveIntegration = await integrationRepository.create({
      name: 'firstActiveIntegration',
      identifier: 'firstActiveIntegration',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      primary: false,
      priority: 1,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const secondActiveIntegration = await integrationRepository.create({
      name: 'secondActiveIntegration',
      identifier: 'secondActiveIntegration',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: false,
      primary: false,
      priority: 0,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const payload = {
      active: true,
      check: false,
    };

    const {
      body: { data },
    } = await session.testAgent.put(`/v1/integrations/${secondActiveIntegration._id}`).send(payload);

    expect(data.priority).to.equal(2);
    expect(data.primary).to.equal(false);
    expect(data.active).to.equal(true);

    const [first, second] = await await integrationRepository.find(
      {
        _organizationId: session.organization._id,
        _environmentId: session.environment._id,
        channel: ChannelTypeEnum.EMAIL,
      },
      undefined,
      { sort: { priority: -1 } }
    );

    expect(first._id).to.equal(secondActiveIntegration._id);
    expect(first.primary).to.equal(false);
    expect(first.active).to.equal(true);
    expect(first.priority).to.equal(2);

    expect(second._id).to.equal(firstActiveIntegration._id);
    expect(second.primary).to.equal(false);
    expect(second.active).to.equal(true);
    expect(second.priority).to.equal(1);
  });

  it('should calculate the priority but not higher than the primary integration', async () => {
    await integrationRepository.deleteMany({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const primaryIntegration = await integrationRepository.create({
      name: 'primaryIntegration',
      identifier: 'primaryIntegration',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      primary: true,
      priority: 3,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const activeIntegrationOne = await integrationRepository.create({
      name: 'activeIntegrationOne',
      identifier: 'activeIntegrationOne',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      primary: false,
      priority: 2,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const activeIntegrationTwo = await integrationRepository.create({
      name: 'activeIntegrationTwo',
      identifier: 'activeIntegrationTwo',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      primary: false,
      priority: 1,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const inactiveIntegration = await integrationRepository.create({
      name: 'inactiveIntegration',
      identifier: 'inactiveIntegration',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: false,
      primary: false,
      priority: 0,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const integration = await integrationRepository.create({
      name: 'integration',
      identifier: 'integration',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: false,
      primary: false,
      priority: 0,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const payload = {
      active: true,
      check: false,
    };

    const {
      body: { data },
    } = await session.testAgent.put(`/v1/integrations/${integration._id}`).send(payload);

    expect(data.priority).to.equal(3);
    expect(data.primary).to.equal(false);
    expect(data.active).to.equal(true);

    const [first, second, third, fourth, fifth] = await await integrationRepository.find(
      {
        _organizationId: session.organization._id,
        _environmentId: session.environment._id,
        channel: ChannelTypeEnum.EMAIL,
      },
      undefined,
      { sort: { priority: -1 } }
    );

    expect(first._id).to.equal(primaryIntegration._id);
    expect(first.primary).to.equal(true);
    expect(first.active).to.equal(true);
    expect(first.priority).to.equal(4);

    expect(second._id).to.equal(integration._id);
    expect(second.primary).to.equal(false);
    expect(second.active).to.equal(true);
    expect(second.priority).to.equal(3);

    expect(third._id).to.equal(activeIntegrationOne._id);
    expect(third.primary).to.equal(false);
    expect(third.active).to.equal(true);
    expect(third.priority).to.equal(2);

    expect(fourth._id).to.equal(activeIntegrationTwo._id);
    expect(fourth.primary).to.equal(false);
    expect(fourth.active).to.equal(true);
    expect(fourth.priority).to.equal(1);

    expect(fifth._id).to.equal(inactiveIntegration._id);
    expect(fifth.primary).to.equal(false);
    expect(fifth.active).to.equal(false);
    expect(fifth.priority).to.equal(0);
  });

  it('should recalculate the priority when integration is deactivated', async () => {
    await integrationRepository.deleteMany({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const primaryIntegration = await integrationRepository.create({
      name: 'primaryIntegration',
      identifier: 'primaryIntegration',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      primary: true,
      priority: 3,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const activeIntegrationOne = await integrationRepository.create({
      name: 'activeIntegrationOne',
      identifier: 'activeIntegrationOne',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      primary: false,
      priority: 2,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const activeIntegrationTwo = await integrationRepository.create({
      name: 'activeIntegrationTwo',
      identifier: 'activeIntegrationTwo',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      primary: false,
      priority: 1,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const inactiveIntegration = await integrationRepository.create({
      name: 'inactiveIntegration',
      identifier: 'inactiveIntegration',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: false,
      primary: false,
      priority: 0,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const payload = {
      active: false,
      check: false,
    };

    const {
      body: { data },
    } = await session.testAgent.put(`/v1/integrations/${activeIntegrationOne._id}`).send(payload);

    expect(data.priority).to.equal(0);
    expect(data.primary).to.equal(false);
    expect(data.active).to.equal(false);

    const [first, second, third, fourth] = await await integrationRepository.find(
      {
        _organizationId: session.organization._id,
        _environmentId: session.environment._id,
        channel: ChannelTypeEnum.EMAIL,
      },
      undefined,
      { sort: { priority: -1, createdAt: -1 } }
    );

    expect(first._id).to.equal(primaryIntegration._id);
    expect(first.primary).to.equal(true);
    expect(first.active).to.equal(true);
    expect(first.priority).to.equal(2);

    expect(second._id).to.equal(activeIntegrationTwo._id);
    expect(second.primary).to.equal(false);
    expect(second.active).to.equal(true);
    expect(second.priority).to.equal(1);

    expect(third._id).to.equal(inactiveIntegration._id);
    expect(third.primary).to.equal(false);
    expect(third.active).to.equal(false);
    expect(third.priority).to.equal(0);

    expect(fourth._id).to.equal(activeIntegrationOne._id);
    expect(fourth.primary).to.equal(false);
    expect(fourth.active).to.equal(false);
    expect(fourth.priority).to.equal(0);
  });

  it('should recalculate the priority when the primary integration is deactivated', async () => {
    await integrationRepository.deleteMany({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const primaryIntegration = await integrationRepository.create({
      name: 'primaryIntegration',
      identifier: 'primaryIntegration',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      primary: true,
      priority: 3,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const activeIntegrationOne = await integrationRepository.create({
      name: 'activeIntegrationOne',
      identifier: 'activeIntegrationOne',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      primary: false,
      priority: 2,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const activeIntegrationTwo = await integrationRepository.create({
      name: 'activeIntegrationTwo',
      identifier: 'activeIntegrationTwo',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      primary: false,
      priority: 1,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const inactiveIntegration = await integrationRepository.create({
      name: 'inactiveIntegration',
      identifier: 'inactiveIntegration',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: false,
      primary: false,
      priority: 0,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const payload = {
      active: false,
      check: false,
    };

    const {
      body: { data },
    } = await session.testAgent.put(`/v1/integrations/${primaryIntegration._id}`).send(payload);

    expect(data.priority).to.equal(0);
    expect(data.primary).to.equal(false);
    expect(data.active).to.equal(false);

    const [first, second, third, fourth] = await await integrationRepository.find(
      {
        _organizationId: session.organization._id,
        _environmentId: session.environment._id,
        channel: ChannelTypeEnum.EMAIL,
      },
      undefined,
      { sort: { priority: -1, createdAt: -1 } }
    );

    expect(first._id).to.equal(activeIntegrationOne._id);
    expect(first.primary).to.equal(false);
    expect(first.active).to.equal(true);
    expect(first.priority).to.equal(2);

    expect(second._id).to.equal(activeIntegrationTwo._id);
    expect(second.primary).to.equal(false);
    expect(second.active).to.equal(true);
    expect(second.priority).to.equal(1);

    expect(third._id).to.equal(inactiveIntegration._id);
    expect(third.primary).to.equal(false);
    expect(third.active).to.equal(false);
    expect(third.priority).to.equal(0);

    expect(fourth._id).to.equal(primaryIntegration._id);
    expect(fourth.primary).to.equal(false);
    expect(fourth.active).to.equal(false);
    expect(fourth.priority).to.equal(0);
  });

  it('should not disable the novu integration and clear the primary flag if the integration is updated', async () => {
    await integrationRepository.deleteMany({
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const novuIntegration = await integrationRepository.create({
      name: 'Novu Integration',
      identifier: 'novuIntegration',
      providerId: EmailProviderIdEnum.Novu,
      channel: ChannelTypeEnum.EMAIL,
      active: true,
      primary: true,
      priority: 1,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const activeIntegration = await integrationRepository.create({
      name: 'activeIntegration',
      identifier: 'activeIntegration',
      providerId: EmailProviderIdEnum.SendGrid,
      channel: ChannelTypeEnum.EMAIL,
      active: false,
      primary: false,
      priority: 0,
      _organizationId: session.organization._id,
      _environmentId: session.environment._id,
    });

    const payload = {
      active: true,
      check: false,
    };

    const {
      body: { data },
    } = await session.testAgent.put(`/v1/integrations/${activeIntegration._id}`).send(payload);

    const [first, second] = await await integrationRepository.find(
      {
        _organizationId: session.organization._id,
        _environmentId: session.environment._id,
        channel: ChannelTypeEnum.EMAIL,
      },
      undefined,
      { sort: { priority: -1, createdAt: -1 } }
    );

    expect(first._id).to.equal(novuIntegration._id);
    expect(first.primary).to.equal(true);
    expect(first.active).to.equal(true);
    expect(first.priority).to.equal(2);

    expect(second._id).to.equal(data._id);
    expect(second.primary).to.equal(false);
    expect(second.active).to.equal(true);
    expect(second.priority).to.equal(1);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - envRepository(new EnvironmentRepository();

  beforeEach(async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('should throw not found exception whe...)
 - integrationId(await session.testAgent.get(`/v1/integrations`)).body.data.find(
      (integration))
 - integration(await session.testAgent.get(`/v1/integrations`)).body.data.find(
      (fetchedIntegration))
 - integration(data.find((i))
 - result(await integrationRepository.findOne({
      _id: integration._id,
      _organizationId: session.org...)
 - integration(data.find((i))
 - nodeMailerIntegration(integrations.find((i))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/usecases/index.ts
Tamaño: 1724 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  CalculateLimitNovuIntegration,
  ConditionsFilter,
  GetDecryptedIntegrations,
  NormalizeVariables,
  SelectIntegration,
} from '@novu/application-generic';
import { AutoConfigureIntegration } from './auto-configure-integration/auto-configure-integration.usecase';
import { CheckIntegration } from './check-integration/check-integration.usecase';
import { CheckIntegrationEMail } from './check-integration/check-integration-email.usecase';
import { CreateIntegration } from './create-integration/create-integration.usecase';
import { CreateNovuIntegrations } from './create-novu-integrations/create-novu-integrations.usecase';
import { GetActiveIntegrations } from './get-active-integration/get-active-integration.usecase';
import { GetInAppActivated } from './get-in-app-activated/get-in-app-activated.usecase';
import { GetIntegrations } from './get-integrations/get-integrations.usecase';
import { GetWebhookSupportStatus } from './get-webhook-support-status/get-webhook-support-status.usecase';
import { RemoveIntegration } from './remove-integration/remove-integration.usecase';
import { SetIntegrationAsPrimary } from './set-integration-as-primary/set-integration-as-primary.usecase';
import { UpdateIntegration } from './update-integration/update-integration.usecase';

export const USE_CASES = [
  GetInAppActivated,
  GetWebhookSupportStatus,
  CreateIntegration,
  AutoConfigureIntegration,
  ConditionsFilter,
  GetIntegrations,
  GetActiveIntegrations,
  SelectIntegration,
  GetDecryptedIntegrations,
  UpdateIntegration,
  RemoveIntegration,
  CheckIntegration,
  CheckIntegrationEMail,
  CalculateLimitNovuIntegration,
  SetIntegrationAsPrimary,
  CreateNovuIntegrations,
  NormalizeVariables,
];


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/usecases/auto-configure-integration/auto-configure-integration.command.ts
Tamaño: 272 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsString } from 'class-validator';
import { OrganizationCommand } from '../../../shared/commands/organization.command';

export class AutoConfigureIntegrationCommand extends OrganizationCommand {
  @IsDefined()
  @IsString()
  integrationId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class AutoConfigureIntegrationCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/usecases/auto-configure-integration/auto-configure-integration.usecase.ts
Tamaño: 3563 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import {
  buildIntegrationKey,
  ChannelFactory,
  GetDecryptedIntegrations,
  InvalidateCacheService,
  PinoLogger,
} from '@novu/application-generic';
import { IntegrationRepository } from '@novu/dal';
import { AutoConfigureIntegrationResponseDto } from '../../dtos/auto-configure-integration-response.dto';
import { AutoConfigureIntegrationCommand } from './auto-configure-integration.command';

@Injectable()
export class AutoConfigureIntegration {
  constructor(
    private integrationRepository: IntegrationRepository,
    private channelFactory: ChannelFactory,
    private invalidateCache: InvalidateCacheService,
    private logger: PinoLogger
  ) {
    this.logger.setContext(this.constructor.name);
  }

  async execute(command: AutoConfigureIntegrationCommand): Promise<AutoConfigureIntegrationResponseDto> {
    this.logger.trace('Executing Auto Configure Integration Command');

    const encryptedIntegration = await this.integrationRepository.findOne({
      _id: command.integrationId,
      _organizationId: command.organizationId,
    });

    if (!encryptedIntegration) {
      throw new NotFoundException(`Integration not found, id: ${command.integrationId}`);
    }

    const integration = GetDecryptedIntegrations.getDecryptedCredentials(encryptedIntegration);

    try {
      const channelHandler = this.channelFactory.getHandler(
        integration,
        integration.channel as 'email' | 'sms' | 'chat' | 'push'
      );

      const webhookUrl = `${process.env.API_ROOT_URL}/v2/inbound-webhooks/delivery-providers/${integration._environmentId}/${integration._id}`;
      const result = await channelHandler.autoConfigureInboundWebhook({ webhookUrl });

      if (result.success && result.configurations) {
        const updatedConfigurations = {
          ...integration.configurations,
          ...result.configurations,
        };

        await this.integrationRepository.update(
          {
            _id: integration._id,
            _organizationId: integration._organizationId,
            _environmentId: integration._environmentId,
          },
          {
            $set: {
              configurations: updatedConfigurations,
            },
          }
        );

        await this.invalidateCache.invalidateQuery({
          key: buildIntegrationKey().invalidate({
            _organizationId: command.organizationId,
          }),
        });

        this.logger.trace('Auto-configuration completed successfully', {
          integrationId: command.integrationId,
          organizationId: command.organizationId,
          webhookUrl,
        });

        return {
          success: true,
          message: result.message || 'Integration auto-configured successfully',
          integration: { ...encryptedIntegration, configurations: updatedConfigurations },
        };
      } else {
        this.logger.warn('Auto-configuration failed', {
          integrationId: command.integrationId,
          organizationId: command.organizationId,
          message: result.message,
        });

        return {
          success: false,
          message: result.message || 'Auto-configuration failed',
        };
      }
    } catch (error) {
      this.logger.error(
        { err: error, integrationId: command.integrationId, organizationId: command.organizationId },
        'Error during auto-configuration'
      );

      return {
        success: false,
        message: `Auto-configuration failed: ${error.message}`,
      };
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class AutoConfigureIntegration

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/usecases/check-integration/check-integration-email.usecase.ts
Tamaño: 599 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { MailFactory } from '@novu/application-generic';

import { CheckIntegrationCommand } from './check-integration.command';

@Injectable()
export class CheckIntegrationEMail {
  public async execute(command: CheckIntegrationCommand) {
    const mailFactory = new MailFactory();
    const mailHandler = mailFactory.getHandler(
      {
        channel: command.channel,
        credentials: command.credentials ?? {},
        providerId: command.providerId,
      },
      command.credentials?.from
    );

    return await mailHandler.check();
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CheckIntegrationEMail

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/usecases/check-integration/check-integration.command.ts
Tamaño: 406 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChannelTypeEnum, ICredentials } from '@novu/shared';
import { IsDefined, IsString } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';

export class CheckIntegrationCommand extends EnvironmentCommand {
  @IsDefined()
  @IsString()
  providerId: string;

  @IsDefined()
  channel: ChannelTypeEnum;

  @IsDefined()
  credentials?: ICredentials;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CheckIntegrationCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/usecases/check-integration/check-integration.usecase.ts
Tamaño: 899 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable } from '@nestjs/common';
import { ChannelTypeEnum } from '@novu/shared';
import { CheckIntegrationCommand } from './check-integration.command';
import { CheckIntegrationEMail } from './check-integration-email.usecase';

@Injectable()
export class CheckIntegration {
  constructor(private checkIntegrationEmail: CheckIntegrationEMail) {}

  public async execute(command: CheckIntegrationCommand) {
    try {
      switch (command.channel) {
        case ChannelTypeEnum.EMAIL:
          return await this.checkIntegrationEmail.execute(command);
      }
    } catch (e) {
      if (e.message?.includes('getaddrinfo ENOTFOUND')) {
        throw new BadRequestException(
          `Provider gateway can't resolve the host with the given hostname ${command.credentials?.host || ''}`
        );
      }

      throw new BadRequestException(e.message);
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CheckIntegration

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/usecases/create-integration/create-integration.command.ts
Tamaño: 933 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { MessageFilter } from '@novu/application-generic';
import { ChannelTypeEnum, ICredentialsDto } from '@novu/shared';
import { IsArray, IsDefined, IsEnum, IsObject, IsOptional, IsString, ValidateNested } from 'class-validator';

import { EnvironmentCommand } from '../../../shared/commands/project.command';

export class CreateIntegrationCommand extends EnvironmentCommand {
  @IsOptional()
  @IsString()
  name?: string;

  @IsOptional()
  @IsString()
  identifier?: string;

  @IsDefined()
  @IsString()
  providerId: string;

  @IsDefined()
  @IsEnum(ChannelTypeEnum)
  channel: ChannelTypeEnum;

  @IsOptional()
  credentials?: ICredentialsDto;

  @IsOptional()
  active: boolean;

  @IsOptional()
  check: boolean;

  @IsDefined()
  userId: string;

  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  conditions?: MessageFilter[];

  @IsOptional()
  @IsObject()
  configurations?: Record<string, string>;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateIntegrationCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/usecases/create-integration/create-integration.usecase.ts
Tamaño: 6364 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, ConflictException, Inject, Injectable } from '@nestjs/common';
import {
  AnalyticsService,
  areNovuEmailCredentialsSet,
  areNovuSlackCredentialsSet,
  areNovuSmsCredentialsSet,
  buildIntegrationKey,
  encryptCredentials,
  InvalidateCacheService,
} from '@novu/application-generic';
import { DalException, IntegrationEntity, IntegrationQuery, IntegrationRepository } from '@novu/dal';
import {
  CHANNELS_WITH_PRIMARY,
  ChannelTypeEnum,
  ChatProviderIdEnum,
  EmailProviderIdEnum,
  InAppProviderIdEnum,
  providers,
  SmsProviderIdEnum,
  slugify,
} from '@novu/shared';
import shortid from 'shortid';
import { CheckIntegrationCommand } from '../check-integration/check-integration.command';
import { CheckIntegration } from '../check-integration/check-integration.usecase';
import { CreateIntegrationCommand } from './create-integration.command';

@Injectable()
export class CreateIntegration {
  @Inject()
  private checkIntegration: CheckIntegration;
  constructor(
    private invalidateCache: InvalidateCacheService,
    private integrationRepository: IntegrationRepository,
    private analyticsService: AnalyticsService
  ) {}

  private async calculatePriorityAndPrimary(command: CreateIntegrationCommand) {
    const result: { primary: boolean; priority: number } = {
      primary: false,
      priority: 0,
    };

    const highestPriorityIntegration = await this.integrationRepository.findHighestPriorityIntegration({
      _organizationId: command.organizationId,
      _environmentId: command.environmentId,
      channel: command.channel,
    });

    if (highestPriorityIntegration?.primary) {
      result.priority = highestPriorityIntegration.priority;
      await this.integrationRepository.update(
        {
          _id: highestPriorityIntegration._id,
          _organizationId: command.organizationId,
          _environmentId: command.environmentId,
        },
        {
          $set: {
            priority: highestPriorityIntegration.priority + 1,
          },
        }
      );
    } else {
      result.priority = highestPriorityIntegration ? highestPriorityIntegration.priority + 1 : 1;
      result.primary = true;
    }

    return result;
  }

  private async validate(command: CreateIntegrationCommand): Promise<void> {
    const existingIntegration = await this.integrationRepository.findOne({
      _environmentId: command.environmentId,
      providerId: command.providerId,
      channel: command.channel,
    });

    if (
      existingIntegration &&
      command.providerId === InAppProviderIdEnum.Novu &&
      command.channel === ChannelTypeEnum.IN_APP
    ) {
      throw new BadRequestException('One environment can only have one In app provider');
    }

    if (
      (command.providerId === SmsProviderIdEnum.Novu && !areNovuSmsCredentialsSet()) ||
      (command.providerId === EmailProviderIdEnum.Novu && !areNovuEmailCredentialsSet()) ||
      (command.providerId === ChatProviderIdEnum.Novu && !areNovuSlackCredentialsSet())
    ) {
      throw new BadRequestException(`Creating Novu integration for ${command.providerId} provider is not allowed`);
    }

    if (command.providerId === SmsProviderIdEnum.Novu || command.providerId === EmailProviderIdEnum.Novu) {
      const count = await this.integrationRepository.count({
        _environmentId: command.environmentId,
        providerId: command.providerId,
        channel: command.channel,
      });

      if (count > 0) {
        throw new ConflictException(
          `Integration with novu provider for ${command.channel.toLowerCase()} channel already exists`
        );
      }
    }

    if (command.identifier) {
      const existingIntegrationWithIdentifier = await this.integrationRepository.findOne({
        _organizationId: command.organizationId,
        _environmentId: command.environmentId,
        identifier: command.identifier,
      });

      if (existingIntegrationWithIdentifier) {
        throw new ConflictException('Integration with identifier already exists');
      }
    }
  }

  async execute(command: CreateIntegrationCommand): Promise<IntegrationEntity> {
    await this.validate(command);

    this.analyticsService.track('Create Integration - [Integrations]', command.userId, {
      providerId: command.providerId,
      channel: command.channel,
      _organization: command.organizationId,
    });

    try {
      if (command.check) {
        await this.checkIntegration.execute(
          CheckIntegrationCommand.create({
            environmentId: command.environmentId,
            organizationId: command.organizationId,
            providerId: command.providerId,
            channel: command.channel,
            credentials: command.credentials,
          })
        );
      }

      await this.invalidateCache.invalidateQuery({
        key: buildIntegrationKey().invalidate({
          _organizationId: command.organizationId,
        }),
      });

      const providerIdCapitalized = `${command.providerId.charAt(0).toUpperCase()}${command.providerId.slice(1)}`;
      const defaultName =
        providers.find((provider) => provider.id === command.providerId)?.displayName ?? providerIdCapitalized;
      const name = command.name ?? defaultName;
      const identifier = command.identifier ?? `${slugify(name)}-${shortid.generate()}`;

      const query: IntegrationQuery = {
        name,
        identifier,
        _environmentId: command.environmentId,
        _organizationId: command.organizationId,
        providerId: command.providerId,
        channel: command.channel,
        credentials: encryptCredentials(command.credentials ?? {}),
        active: command.active,
        conditions: command.conditions,
        configurations: command.configurations,
      };

      const isActiveAndChannelSupportsPrimary = command.active && CHANNELS_WITH_PRIMARY.includes(command.channel);

      if (isActiveAndChannelSupportsPrimary) {
        const { primary, priority } = await this.calculatePriorityAndPrimary(command);

        query.primary = primary;
        query.priority = priority;
      }

      const integrationEntity = await this.integrationRepository.create(query);

      return integrationEntity;
    } catch (e) {
      if (e instanceof DalException) {
        throw new BadRequestException(e.message);
      }
      throw e;
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - defaultName(providers.find((provider))
Declaraciones 'export' encontradas:
- export class CreateIntegration

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/usecases/create-novu-integrations/create-novu-integrations.command.ts
Tamaño: 446 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChannelTypeEnum, EnvironmentEnum } from '@novu/shared';
import { IsArray, IsEnum, IsOptional } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class CreateNovuIntegrationsCommand extends EnvironmentWithUserCommand {
  name: string | EnvironmentEnum;

  @IsOptional()
  @IsArray()
  @IsEnum(ChannelTypeEnum, { each: true })
  readonly channels?: ChannelTypeEnum[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateNovuIntegrationsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/usecases/create-novu-integrations/create-novu-integrations.usecase.ts
Tamaño: 5598 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { areNovuEmailCredentialsSet, areNovuSlackCredentialsSet, FeatureFlagsService } from '@novu/application-generic';
import { EnvironmentEntity, IntegrationRepository, OrganizationEntity, UserEntity } from '@novu/dal';

import {
  ChannelTypeEnum,
  ChatProviderIdEnum,
  EmailProviderIdEnum,
  EnvironmentEnum,
  FeatureFlagsKeysEnum,
  InAppProviderIdEnum,
} from '@novu/shared';
import { CreateIntegrationCommand } from '../create-integration/create-integration.command';
import { CreateIntegration } from '../create-integration/create-integration.usecase';
import { SetIntegrationAsPrimaryCommand } from '../set-integration-as-primary/set-integration-as-primary.command';
import { SetIntegrationAsPrimary } from '../set-integration-as-primary/set-integration-as-primary.usecase';
import { CreateNovuIntegrationsCommand } from './create-novu-integrations.command';

@Injectable()
export class CreateNovuIntegrations {
  constructor(
    private createIntegration: CreateIntegration,
    private integrationRepository: IntegrationRepository,
    private setIntegrationAsPrimary: SetIntegrationAsPrimary,
    private featureFlagService: FeatureFlagsService
  ) {}

  private async createEmailIntegration(command: CreateNovuIntegrationsCommand) {
    if (!areNovuEmailCredentialsSet() || command.name !== EnvironmentEnum.DEVELOPMENT) {
      return;
    }

    const emailIntegrationCount = await this.integrationRepository.count({
      providerId: EmailProviderIdEnum.Novu,
      channel: ChannelTypeEnum.EMAIL,
      _organizationId: command.organizationId,
      _environmentId: command.environmentId,
    });

    if (emailIntegrationCount === 0) {
      const novuEmailIntegration = await this.createIntegration.execute(
        CreateIntegrationCommand.create({
          providerId: EmailProviderIdEnum.Novu,
          channel: ChannelTypeEnum.EMAIL,
          active: true,
          name: 'Novu Email',
          check: false,
          userId: command.userId,
          environmentId: command.environmentId,
          organizationId: command.organizationId,
        })
      );
      await this.setIntegrationAsPrimary.execute(
        SetIntegrationAsPrimaryCommand.create({
          organizationId: command.organizationId,
          environmentId: command.environmentId,
          integrationId: novuEmailIntegration._id,
          userId: command.userId,
        })
      );
    }
  }

  private async createInAppIntegration(command: CreateNovuIntegrationsCommand) {
    const inAppIntegrationCount = await this.integrationRepository.count({
      providerId: InAppProviderIdEnum.Novu,
      channel: ChannelTypeEnum.IN_APP,
      _organizationId: command.organizationId,
      _environmentId: command.environmentId,
    });

    if (inAppIntegrationCount === 0) {
      const isV2Enabled = await this.featureFlagService.getFlag({
        user: { _id: command.userId } as UserEntity,
        environment: { _id: command.environmentId } as EnvironmentEntity,
        organization: { _id: command.organizationId } as OrganizationEntity,
        key: FeatureFlagsKeysEnum.IS_V2_ENABLED,
        defaultValue: false,
      });

      const name = isV2Enabled ? 'Novu Inbox' : 'Novu In-App';
      await this.createIntegration.execute(
        CreateIntegrationCommand.create({
          name,
          providerId: InAppProviderIdEnum.Novu,
          channel: ChannelTypeEnum.IN_APP,
          active: true,
          check: false,
          userId: command.userId,
          environmentId: command.environmentId,
          organizationId: command.organizationId,
        })
      );
    }
  }

  private async createSlackIntegration(command: CreateNovuIntegrationsCommand) {
    const isSlackTeamsEnabled = await this.featureFlagService.getFlag({
      user: { _id: command.userId } as UserEntity,
      environment: { _id: command.environmentId } as EnvironmentEntity,
      organization: { _id: command.organizationId } as OrganizationEntity,
      key: FeatureFlagsKeysEnum.IS_SLACK_TEAMS_ENABLED,
      defaultValue: false,
    });

    if (!areNovuSlackCredentialsSet() || command.name !== EnvironmentEnum.DEVELOPMENT || !isSlackTeamsEnabled) {
      return;
    }

    const slackIntegrationCount = await this.integrationRepository.count({
      providerId: ChatProviderIdEnum.Novu,
      channel: ChannelTypeEnum.CHAT,
      _organizationId: command.organizationId,
      _environmentId: command.environmentId,
    });

    if (slackIntegrationCount === 0) {
      await this.createIntegration.execute(
        CreateIntegrationCommand.create({
          name: 'Novu Slack',
          providerId: ChatProviderIdEnum.Novu,
          channel: ChannelTypeEnum.CHAT,
          active: true,
          check: false,
          userId: command.userId,
          environmentId: command.environmentId,
          organizationId: command.organizationId,
        })
      );
    }
  }

  async execute(command: CreateNovuIntegrationsCommand): Promise<void> {
    const integrationPromises: Array<Promise<void>> = [];

    if (!command.channels || command.channels.includes(ChannelTypeEnum.EMAIL)) {
      integrationPromises.push(this.createEmailIntegration(command));
    }

    if (!command.channels || command.channels.includes(ChannelTypeEnum.IN_APP)) {
      integrationPromises.push(this.createInAppIntegration(command));
    }

    if (!command.channels || command.channels.includes(ChannelTypeEnum.CHAT)) {
      integrationPromises.push(this.createSlackIntegration(command));
    }

    await Promise.all(integrationPromises);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateNovuIntegrations

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/usecases/get-active-integration/get-active-integration.command.ts
Tamaño: 288 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsBoolean, IsOptional } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class GetActiveIntegrationsCommand extends EnvironmentWithUserCommand {
  @IsBoolean()
  @IsOptional()
  returnCredentials?: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetActiveIntegrationsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/usecases/get-active-integration/get-active-integration.usecase.ts
Tamaño: 1124 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';

import { GetDecryptedIntegrations, GetDecryptedIntegrationsCommand } from '@novu/application-generic';
import { IntegrationResponseDto } from '../../dtos/integration-response.dto';
import { GetActiveIntegrationsCommand } from './get-active-integration.command';

@Injectable()
export class GetActiveIntegrations {
  constructor(private getDecryptedIntegrationsUsecase: GetDecryptedIntegrations) {}

  async execute(command: GetActiveIntegrationsCommand): Promise<IntegrationResponseDto[]> {
    const activeIntegrations = await this.getDecryptedIntegrationsUsecase.execute(
      GetDecryptedIntegrationsCommand.create({
        organizationId: command.organizationId,
        environmentId: command.environmentId,
        userId: command.userId,
        active: true,
        returnCredentials: command.returnCredentials,
      })
    );

    if (!activeIntegrations.length) {
      return [];
    }

    return activeIntegrations;
  }
}

export function notNullish<TValue>(value: TValue | null | undefined): value is TValue {
  return value !== null && value !== undefined;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetActiveIntegrations
- export function notNullish

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/usecases/get-in-app-activated/get-in-app-activated.command.ts
Tamaño: 148 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentCommand } from '../../../shared/commands/project.command';

export class GetInAppActivatedCommand extends EnvironmentCommand {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetInAppActivatedCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/usecases/get-in-app-activated/get-in-app-activated.usecase.ts
Tamaño: 678 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { SubscriberRepository } from '@novu/dal';
import { GetInAppActivatedCommand } from './get-in-app-activated.command';

@Injectable()
export class GetInAppActivated {
  constructor(private readonly subscriberRepository: SubscriberRepository) {}

  async execute(command: GetInAppActivatedCommand): Promise<{ active: boolean }> {
    const inAppSubscriberCount = await this.subscriberRepository.count({
      _organizationId: command.organizationId,
      _environmentId: command.environmentId,
      isOnline: true,
      subscriberId: /on-boarding-subscriber/i,
    });

    return { active: inAppSubscriberCount > 0 };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetInAppActivated

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/usecases/get-integrations/get-integrations.command.ts
Tamaño: 267 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentWithUserCommand } from '@novu/application-generic';
import { IsBoolean, IsOptional } from 'class-validator';

export class GetIntegrationsCommand extends EnvironmentWithUserCommand {
  @IsBoolean()
  @IsOptional()
  returnCredentials?: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetIntegrationsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/usecases/get-integrations/get-integrations.usecase.ts
Tamaño: 789 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { GetDecryptedIntegrations, GetDecryptedIntegrationsCommand } from '@novu/application-generic';
import { IntegrationEntity } from '@novu/dal';

import { GetIntegrationsCommand } from './get-integrations.command';

@Injectable()
export class GetIntegrations {
  constructor(private getDecryptedIntegrationsUsecase: GetDecryptedIntegrations) {}

  async execute(command: GetIntegrationsCommand): Promise<IntegrationEntity[]> {
    return await this.getDecryptedIntegrationsUsecase.execute(
      GetDecryptedIntegrationsCommand.create({
        organizationId: command.organizationId,
        userId: command.userId,
        environmentId: command.environmentId,
        returnCredentials: command.returnCredentials,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetIntegrations

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/usecases/get-webhook-support-status/get-webhook-support-status.command.ts
Tamaño: 264 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsString } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class GetWebhookSupportStatusCommand extends EnvironmentWithUserCommand {
  @IsString()
  providerOrIntegrationId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetWebhookSupportStatusCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/usecases/get-webhook-support-status/get-webhook-support-status.usecase.ts
Tamaño: 2883 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException, Scope } from '@nestjs/common';
import { IMailHandler, ISmsHandler, MailFactory, SmsFactory } from '@novu/application-generic';
import { IntegrationEntity, IntegrationQuery, IntegrationRepository } from '@novu/dal';
import { ChannelTypeEnum, providers } from '@novu/shared';
import { IEmailProvider, ISmsProvider } from '@novu/stateless';

import { GetWebhookSupportStatusCommand } from './get-webhook-support-status.command';

@Injectable({ scope: Scope.REQUEST })
export class GetWebhookSupportStatus {
  public readonly mailFactory = new MailFactory();
  public readonly smsFactory = new SmsFactory();
  private provider: IEmailProvider | ISmsProvider;

  constructor(private integrationRepository: IntegrationRepository) {}

  async execute(command: GetWebhookSupportStatusCommand): Promise<boolean> {
    const integration = await this.getIntegration(command);
    if (!integration) {
      throw new NotFoundException(`Integration for ${command.providerOrIntegrationId} was not found`);
    }

    const hasNoCredentials = !integration.credentials || Object.keys(integration.credentials).length === 0;
    if (hasNoCredentials) {
      throw new BadRequestException(`Integration ${integration._id} doesn't have credentials set up`);
    }

    const { channel, providerId } = integration;
    if (![ChannelTypeEnum.EMAIL, ChannelTypeEnum.SMS].includes(channel)) {
      throw new BadRequestException(`Webhook for ${providerId}-${channel} is not supported yet`);
    }

    this.createProvider(integration);

    if (!this.provider.getMessageId || !this.provider.parseEventBody) {
      return false;
    }

    return true;
  }

  private async getIntegration(command: GetWebhookSupportStatusCommand) {
    const { providerOrIntegrationId } = command;
    const isProviderId = !!providers.find((el) => el.id === providerOrIntegrationId);

    const query: IntegrationQuery = {
      ...(isProviderId
        ? { providerId: providerOrIntegrationId, credentials: { $exists: true } }
        : { _id: providerOrIntegrationId }),
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
    };

    return await this.integrationRepository.findOne(query);
  }

  private getHandler(integration: IntegrationEntity): ISmsHandler | IMailHandler | null {
    switch (integration.channel) {
      case 'sms':
        return this.smsFactory.getHandler(integration);
      default:
        return this.mailFactory.getHandler(integration);
    }
  }

  private createProvider(integration: IntegrationEntity) {
    const handler = this.getHandler(integration);
    if (!handler) {
      throw new NotFoundException(`Handler for integration of ${integration.providerId} was not found`);
    }

    handler.buildProvider(integration.credentials);

    this.provider = handler.getProvider();
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - isProviderId(!!providers.find((el))
Declaraciones 'export' encontradas:
- export class GetWebhookSupportStatus

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/usecases/remove-integration/remove-integration.command.ts
Tamaño: 251 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined } from 'class-validator';

import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class RemoveIntegrationCommand extends EnvironmentWithUserCommand {
  @IsDefined()
  integrationId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RemoveIntegrationCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/usecases/remove-integration/remove-integration.usecase.ts
Tamaño: 2322 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException, Scope } from '@nestjs/common';
import { buildIntegrationKey, InvalidateCacheService } from '@novu/application-generic';
import { DalException, IntegrationEntity, IntegrationRepository } from '@novu/dal';
import { CHANNELS_WITH_PRIMARY, ChannelTypeEnum, EmailProviderIdEnum, SmsProviderIdEnum } from '@novu/shared';

import { RemoveIntegrationCommand } from './remove-integration.command';

@Injectable({
  scope: Scope.REQUEST,
})
export class RemoveIntegration {
  constructor(
    private invalidateCache: InvalidateCacheService,
    private integrationRepository: IntegrationRepository
  ) {}

  async execute(command: RemoveIntegrationCommand) {
    try {
      const existingIntegration = await this.integrationRepository.findOne({
        _id: command.integrationId,
        _organizationId: command.organizationId,
      });
      if (!existingIntegration) {
        throw new NotFoundException(`Entity with id ${command.integrationId} not found`);
      }

      await this.invalidateCache.invalidateQuery({
        key: buildIntegrationKey().invalidate({
          _organizationId: command.organizationId,
        }),
      });

      await this.integrationRepository.delete({
        _id: existingIntegration._id,
        _organizationId: existingIntegration._organizationId,
      });

      const isChannelSupportsPrimary = CHANNELS_WITH_PRIMARY.includes(existingIntegration.channel);
      if (isChannelSupportsPrimary) {
        await this.integrationRepository.recalculatePriorityForAllActive({
          _organizationId: existingIntegration._organizationId,
          _environmentId: existingIntegration._environmentId,
          channel: existingIntegration.channel,
        });
      }
    } catch (e) {
      if (e instanceof DalException) {
        throw new BadRequestException(e.message);
      }
      throw e;
    }

    return await this.integrationRepository.find({
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
    });
  }

  private isBuiltInIntegration(integration: IntegrationEntity) {
    return (
      integration.providerId === EmailProviderIdEnum.Novu ||
      integration.providerId === SmsProviderIdEnum.Novu ||
      integration.channel === ChannelTypeEnum.IN_APP
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RemoveIntegration

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/usecases/set-integration-as-primary/set-integration-as-primary.command.ts
Tamaño: 283 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsMongoId } from 'class-validator';

import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class SetIntegrationAsPrimaryCommand extends EnvironmentWithUserCommand {
  @IsDefined()
  @IsMongoId()
  integrationId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SetIntegrationAsPrimaryCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/usecases/set-integration-as-primary/set-integration-as-primary.usecase.ts
Tamaño: 3231 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import { AnalyticsService, buildIntegrationKey, InvalidateCacheService, PinoLogger } from '@novu/application-generic';
import { IntegrationEntity, IntegrationRepository } from '@novu/dal';
import { CHANNELS_WITH_PRIMARY } from '@novu/shared';

import { SetIntegrationAsPrimaryCommand } from './set-integration-as-primary.command';

@Injectable()
export class SetIntegrationAsPrimary {
  constructor(
    private invalidateCache: InvalidateCacheService,
    private integrationRepository: IntegrationRepository,
    private analyticsService: AnalyticsService,
    private logger: PinoLogger
  ) {
    this.logger.setContext(this.constructor.name);
  }

  private async updatePrimaryFlag({ existingIntegration }: { existingIntegration: IntegrationEntity }) {
    await this.integrationRepository.update(
      {
        _organizationId: existingIntegration._organizationId,
        _environmentId: existingIntegration._environmentId,
        channel: existingIntegration.channel,
        active: true,
        primary: true,
      },
      {
        $set: {
          primary: false,
        },
      }
    );

    await this.integrationRepository.update(
      {
        _id: existingIntegration._id,
        _organizationId: existingIntegration._organizationId,
        _environmentId: existingIntegration._environmentId,
      },
      {
        $set: {
          active: true,
          primary: true,
          conditions: [],
        },
      }
    );
  }

  async execute(command: SetIntegrationAsPrimaryCommand): Promise<IntegrationEntity> {
    this.logger.trace('Executing Set Integration As Primary Usecase');

    const existingIntegration = await this.integrationRepository.findOne({
      _id: command.integrationId,
      _organizationId: command.organizationId,
    });
    if (!existingIntegration) {
      throw new NotFoundException(`Integration with id ${command.integrationId} not found`);
    }

    if (!CHANNELS_WITH_PRIMARY.includes(existingIntegration.channel)) {
      throw new BadRequestException(`Channel ${existingIntegration.channel} does not support primary`);
    }

    const { _organizationId, _environmentId, channel, providerId } = existingIntegration;
    if (existingIntegration.primary) {
      return existingIntegration;
    }

    this.analyticsService.track('Set Integration As Primary - [Integrations]', command.userId, {
      providerId,
      channel,
      _organizationId,
      _environmentId,
    });

    await this.invalidateCache.invalidateQuery({
      key: buildIntegrationKey().invalidate({
        _organizationId,
      }),
    });

    await this.updatePrimaryFlag({ existingIntegration });

    await this.integrationRepository.recalculatePriorityForAllActive({
      _id: existingIntegration._id,
      _organizationId,
      _environmentId,
      channel,
    });

    const updatedIntegration = await this.integrationRepository.findOne({
      _id: command.integrationId,
      _organizationId,
      _environmentId,
    });
    if (!updatedIntegration) throw new NotFoundException(`Integration with id ${command.integrationId} is not found`);

    return updatedIntegration;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SetIntegrationAsPrimary

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/usecases/update-integration/update-integration.command.ts
Tamaño: 941 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { MessageFilter } from '@novu/application-generic';
import { IConfigurations, ICredentialsDto } from '@novu/shared';
import { IsArray, IsDefined, IsMongoId, IsObject, IsOptional, IsString, ValidateNested } from 'class-validator';

import { OrganizationCommand } from '../../../shared/commands/organization.command';

export class UpdateIntegrationCommand extends OrganizationCommand {
  @IsOptional()
  @IsString()
  name?: string;

  @IsOptional()
  @IsString()
  identifier?: string;

  @IsOptional()
  @IsMongoId()
  environmentId?: string;

  @IsOptional()
  @IsMongoId()
  userEnvironmentId: string;

  @IsDefined()
  integrationId: string;

  @IsOptional()
  credentials?: ICredentialsDto;

  @IsOptional()
  active?: boolean;

  @IsOptional()
  check?: boolean;

  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  conditions?: MessageFilter[];

  @IsOptional()
  @IsObject()
  configurations?: IConfigurations;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateIntegrationCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/integrations/usecases/update-integration/update-integration.usecase.ts
Tamaño: 7818 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, ConflictException, Inject, Injectable, NotFoundException } from '@nestjs/common';
import {
  AnalyticsService,
  buildIntegrationKey,
  encryptCredentials,
  FeatureFlagsService,
  InvalidateCacheService,
  PinoLogger,
} from '@novu/application-generic';
import { IntegrationEntity, IntegrationRepository, OrganizationEntity } from '@novu/dal';
import { CHANNELS_WITH_PRIMARY, FeatureFlagsKeysEnum } from '@novu/shared';
import { CheckIntegrationCommand } from '../check-integration/check-integration.command';
import { CheckIntegration } from '../check-integration/check-integration.usecase';
import { UpdateIntegrationCommand } from './update-integration.command';

@Injectable()
export class UpdateIntegration {
  @Inject()
  private checkIntegration: CheckIntegration;
  constructor(
    private invalidateCache: InvalidateCacheService,
    private integrationRepository: IntegrationRepository,
    private analyticsService: AnalyticsService,
    private featureFlagService: FeatureFlagsService,
    private logger: PinoLogger
  ) {
    this.logger.setContext(this.constructor.name);
  }

  private async calculatePriorityAndPrimaryForActive({
    existingIntegration,
  }: {
    existingIntegration: IntegrationEntity;
  }) {
    const result: { primary: boolean; priority: number } = {
      primary: existingIntegration.primary,
      priority: existingIntegration.priority,
    };

    const highestPriorityIntegration = await this.integrationRepository.findHighestPriorityIntegration({
      _organizationId: existingIntegration._organizationId,
      _environmentId: existingIntegration._environmentId,
      channel: existingIntegration.channel,
    });

    if (highestPriorityIntegration?.primary) {
      result.priority = highestPriorityIntegration.priority;
      await this.integrationRepository.update(
        {
          _id: highestPriorityIntegration._id,
          _organizationId: highestPriorityIntegration._organizationId,
          _environmentId: highestPriorityIntegration._environmentId,
        },
        {
          $set: {
            priority: highestPriorityIntegration.priority + 1,
          },
        }
      );
    } else {
      result.priority = highestPriorityIntegration ? highestPriorityIntegration.priority + 1 : 1;
    }

    return result;
  }

  private async calculatePriorityAndPrimary({
    existingIntegration,
    active,
  }: {
    existingIntegration: IntegrationEntity;
    active: boolean;
  }) {
    let result: { primary: boolean; priority: number } = {
      primary: existingIntegration.primary,
      priority: existingIntegration.priority,
    };

    if (active) {
      result = await this.calculatePriorityAndPrimaryForActive({
        existingIntegration,
      });
    } else {
      await this.integrationRepository.recalculatePriorityForAllActive({
        _id: existingIntegration._id,
        _organizationId: existingIntegration._organizationId,
        _environmentId: existingIntegration._environmentId,
        channel: existingIntegration.channel,
        exclude: true,
      });

      result = {
        priority: 0,
        primary: false,
      };
    }

    return result;
  }

  async execute(command: UpdateIntegrationCommand): Promise<IntegrationEntity> {
    this.logger.trace('Executing Update Integration Command');

    const existingIntegration = await this.integrationRepository.findOne({
      _id: command.integrationId,
      _organizationId: command.organizationId,
    });
    if (!existingIntegration) {
      throw new NotFoundException(`Entity with id ${command.integrationId} not found`);
    }

    const identifierHasChanged = command.identifier && command.identifier !== existingIntegration.identifier;
    if (identifierHasChanged) {
      const existingIntegrationWithIdentifier = await this.integrationRepository.findOne({
        _organizationId: command.organizationId,
        identifier: command.identifier,
      });

      if (existingIntegrationWithIdentifier) {
        throw new ConflictException('Integration with identifier already exists');
      }
    }

    this.analyticsService.track('Update Integration - [Integrations]', command.userId, {
      providerId: existingIntegration.providerId,
      channel: existingIntegration.channel,
      _organization: command.organizationId,
      active: command.active,
    });

    const isInvalidationDisabled = await this.featureFlagService.getFlag({
      key: FeatureFlagsKeysEnum.IS_INTEGRATION_INVALIDATION_DISABLED,
      defaultValue: false,
      organization: { _id: command.organizationId } as OrganizationEntity,
    });

    if (!isInvalidationDisabled) {
      await this.invalidateCache.invalidateQuery({
        key: buildIntegrationKey().invalidate({
          _organizationId: command.organizationId,
        }),
      });
    }

    const environmentId = command.environmentId ?? existingIntegration._environmentId;

    if (command.check) {
      await this.checkIntegration.execute(
        CheckIntegrationCommand.create({
          environmentId,
          organizationId: command.organizationId,
          credentials: command.credentials ?? existingIntegration.credentials ?? {},
          providerId: existingIntegration.providerId,
          channel: existingIntegration.channel,
        })
      );
    }

    const updatePayload: Partial<IntegrationEntity> = {};
    const isActiveDefined = typeof command.active !== 'undefined';
    const isActiveChanged = isActiveDefined && existingIntegration.active !== command.active;

    if (command.name) {
      updatePayload.name = command.name;
    }

    if (identifierHasChanged) {
      updatePayload.identifier = command.identifier;
    }

    if (command.environmentId) {
      updatePayload._environmentId = environmentId;
    }

    if (isActiveDefined) {
      updatePayload.active = command.active;
    }

    if (command.credentials) {
      updatePayload.credentials = encryptCredentials(command.credentials);
    }

    if (command.configurations) {
      updatePayload.configurations = command.configurations;
    }

    if (command.conditions) {
      updatePayload.conditions = command.conditions;
    }

    if (!Object.keys(updatePayload).length) {
      throw new BadRequestException('No properties found for update');
    }

    const haveConditions = updatePayload.conditions && updatePayload.conditions?.length > 0;

    const isChannelSupportsPrimary = CHANNELS_WITH_PRIMARY.includes(existingIntegration.channel);
    if (isActiveChanged && isChannelSupportsPrimary) {
      const { primary, priority } = await this.calculatePriorityAndPrimary({
        existingIntegration,
        active: !!command.active,
      });

      updatePayload.primary = primary;
      updatePayload.priority = priority;
    }

    const shouldRemovePrimary = haveConditions && existingIntegration.primary;
    if (shouldRemovePrimary) {
      updatePayload.primary = false;
    }

    await this.integrationRepository.update(
      {
        _id: existingIntegration._id,
        _environmentId: existingIntegration._environmentId,
      },
      {
        $set: updatePayload,
      }
    );

    if (shouldRemovePrimary) {
      await this.integrationRepository.recalculatePriorityForAllActive({
        _id: existingIntegration._id,
        _organizationId: existingIntegration._organizationId,
        _environmentId: existingIntegration._organizationId,
        channel: existingIntegration.channel,
      });
    }

    const updatedIntegration = await this.integrationRepository.findOne({
      _id: command.integrationId,
      _environmentId: environmentId,
    });
    if (!updatedIntegration) {
      throw new NotFoundException(`Integration with id ${command.integrationId} is not found`);
    }

    return updatedIntegration;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateIntegration

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/internal/internal.controller.ts
Tamaño: 1502 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Body, Controller, HttpCode, HttpStatus, Post, UseGuards } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { ApiExcludeController } from '@nestjs/swagger';
import { SubscriberSession } from '../shared/framework/user.decorator';
import {
  UpdateSubscriberOnlineStateRequestDto,
  UpdateSubscriberOnlineStateResponseDto,
} from './dtos/subscriber-online-state.dto';
import { UpdateSubscriberOnlineStateCommand } from './usecases/update-subscriber-online-state/update-subscriber-online-state.command';
import { UpdateSubscriberOnlineState } from './usecases/update-subscriber-online-state/update-subscriber-online-state.usecase';

@Controller('/internal')
@ApiExcludeController()
export class InternalController {
  constructor(private readonly updateSubscriberOnlineStateUsecase: UpdateSubscriberOnlineState) {}

  @Post('/subscriber-online-state')
  @UseGuards(AuthGuard('subscriberJwt'))
  @HttpCode(HttpStatus.OK)
  async updateSubscriberOnlineState(
    @Body() body: UpdateSubscriberOnlineStateRequestDto,
    @SubscriberSession() subscriberSession: SubscriberSession
  ): Promise<UpdateSubscriberOnlineStateResponseDto> {
    const command = UpdateSubscriberOnlineStateCommand.create({
      subscriberId: subscriberSession.subscriberId,
      environmentId: subscriberSession._environmentId,
      isOnline: body.isOnline,
      timestamp: body.timestamp ?? Date.now(),
    });

    return await this.updateSubscriberOnlineStateUsecase.execute(command);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class InternalController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/internal/internal.module.ts
Tamaño: 335 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Module } from '@nestjs/common';
import { SharedModule } from '../shared/shared.module';
import { InternalController } from './internal.controller';
import { USE_CASES } from './usecases';

@Module({
  imports: [SharedModule],
  providers: [...USE_CASES],
  controllers: [InternalController],
})
export class InternalModule {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class InternalModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/internal/dtos/subscriber-online-state.dto.ts
Tamaño: 815 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IsBoolean, IsNotEmpty, IsOptional, IsString } from 'class-validator';

export class UpdateSubscriberOnlineStateRequestDto {
  @ApiProperty({
    description: 'Whether the subscriber is online',
    example: true,
  })
  @IsBoolean()
  isOnline: boolean;

  @ApiProperty({
    description: 'Optional timestamp of the state change',
    example: 1234567890,
    required: false,
  })
  @IsOptional()
  timestamp?: number;
}

export class UpdateSubscriberOnlineStateResponseDto {
  @ApiProperty({
    description: 'Whether the operation was successful',
    example: true,
  })
  success: boolean;

  @ApiProperty({
    description: 'Optional message',
    example: 'Subscriber online state updated successfully',
    required: false,
  })
  message?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateSubscriberOnlineStateRequestDto
- export class UpdateSubscriberOnlineStateResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/internal/e2e/internal.e2e.ts
Tamaño: 2418 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Internal Controller (GET /v1/internal) - #novu-v2', () => {
  let session: UserSession;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  describe('/subscriber-online-state (POST)', () => {
    it('should return 401 when invalid JWT token is provided', async () => {
      const { body } = await session.testAgent
        .post('/v1/internal/subscriber-online-state')
        .set('Authorization', 'Bearer invalid-jwt-token')
        .send({
          isOnline: true,
        })
        .expect(401);

      expect(body.message).to.contain('Unauthorized');
    });

    it('should return 401 when no JWT token is provided', async () => {
      const { body } = await session.testAgent
        .post('/v1/internal/subscriber-online-state')
        .send({
          isOnline: true,
        })
        .expect(401);

      expect(body.message).to.contain('Unauthorized');
    });

    it('should return 401 when JWT token has wrong audience', async () => {
      // Use the regular user token instead of subscriber token (wrong audience)
      const { body } = await session.testAgent
        .post('/v1/internal/subscriber-online-state')
        .set('Authorization', `Bearer ${session.token}`)
        .send({
          isOnline: true,
        })
        .expect(401);

      expect(body.message).to.contain('Unauthorized');
    });

    it('should return 200 when valid subscriber JWT token is provided', async () => {
      const { body } = await session.testAgent
        .post('/v1/internal/subscriber-online-state')
        .set('Authorization', `Bearer ${session.subscriberToken}`)
        .send({
          isOnline: true,
        })
        .expect(200);

      expect(body.data.success).to.equal(true);
      expect(body.data.message).to.equal('Subscriber online state updated successfully');
    });

    it('should update subscriber to offline status', async () => {
      const { body } = await session.testAgent
        .post('/v1/internal/subscriber-online-state')
        .set('Authorization', `Bearer ${session.subscriberToken}`)
        .send({
          isOnline: false,
        })
        .expect(200);

      expect(body.data.success).to.equal(true);
      expect(body.data.message).to.equal('Subscriber online state updated successfully');
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
    await session.initialize();
  });

  describe('/subscriber-online-state (POST...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/internal/usecases/index.ts
Tamaño: 217 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UpdateSubscriberOnlineState } from './update-subscriber-online-state/update-subscriber-online-state.usecase';

export const USE_CASES = [UpdateSubscriberOnlineState];

export { UpdateSubscriberOnlineState };


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/internal/usecases/update-subscriber-online-state/update-subscriber-online-state.command.ts
Tamaño: 421 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BaseCommand } from '@novu/application-generic';
import { IsBoolean, IsMongoId, IsNotEmpty, IsOptional, IsString } from 'class-validator';

export class UpdateSubscriberOnlineStateCommand extends BaseCommand {
  @IsString()
  @IsNotEmpty()
  subscriberId: string;

  @IsString()
  @IsNotEmpty()
  @IsMongoId()
  environmentId: string;

  @IsBoolean()
  isOnline: boolean;

  @IsOptional()
  timestamp?: number;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateSubscriberOnlineStateCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/internal/usecases/update-subscriber-online-state/update-subscriber-online-state.usecase.ts
Tamaño: 1436 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { PinoLogger } from '@novu/application-generic';
import { SubscriberRepository } from '@novu/dal';
import { UpdateSubscriberOnlineStateCommand } from './update-subscriber-online-state.command';

@Injectable()
export class UpdateSubscriberOnlineState {
  constructor(
    private readonly logger: PinoLogger,
    private readonly subscriberRepository: SubscriberRepository
  ) {
    this.logger.setContext(UpdateSubscriberOnlineState.name);
  }

  async execute(command: UpdateSubscriberOnlineStateCommand): Promise<{ success: boolean; message?: string }> {
    this.logger.debug(
      `Updating subscriber online state: ${command.subscriberId} in environment ${command.environmentId} to ${command.isOnline}`
    );

    const updatePayload: { isOnline: boolean; lastOnlineAt?: string } = {
      isOnline: command.isOnline,
      lastOnlineAt: new Date().toISOString(),
    };

    await this.subscriberRepository.update(
      { subscriberId: command.subscriberId, _environmentId: command.environmentId },
      {
        $set: updatePayload,
      },
      {
        writeConcern: { w: 1 },
      }
    );

    this.logger.debug(
      `Subscriber ${command.subscriberId} is now ${command.isOnline ? 'online' : 'offline'} in environment ${command.environmentId}`
    );

    return {
      success: true,
      message: 'Subscriber online state updated successfully',
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateSubscriberOnlineState

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/invites/invites.controller.ts
Tamaño: 4052 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  Body,
  ClassSerializerInterceptor,
  Controller,
  Get,
  Headers,
  Param,
  Post,
  UseInterceptors,
} from '@nestjs/common';
import { ApiExcludeController, ApiTags } from '@nestjs/swagger';
import {
  ApiRateLimitCostEnum,
  IBulkInviteResponse,
  IGetInviteResponseDto,
  MemberRoleEnum,
  UserSessionData,
} from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { ThrottlerCost } from '../rate-limiting/guards';
import { ApiCommonResponses } from '../shared/framework/response.decorator';
import { UserSession } from '../shared/framework/user.decorator';
import { BulkInviteMembersDto } from './dtos/bulk-invite-members.dto';
import { InviteMemberDto, InviteWebhookDto } from './dtos/invite-member.dto';
import { ResendInviteDto } from './dtos/resend-invite.dto';
import { AcceptInviteCommand } from './usecases/accept-invite/accept-invite.command';
import { AcceptInvite } from './usecases/accept-invite/accept-invite.usecase';
import { BulkInviteCommand } from './usecases/bulk-invite/bulk-invite.command';
import { BulkInvite } from './usecases/bulk-invite/bulk-invite.usecase';
import { GetInviteCommand } from './usecases/get-invite/get-invite.command';
import { GetInvite } from './usecases/get-invite/get-invite.usecase';
import { InviteMemberCommand } from './usecases/invite-member/invite-member.command';
import { InviteMember } from './usecases/invite-member/invite-member.usecase';
import { ResendInviteCommand } from './usecases/resend-invite/resend-invite.command';
import { ResendInvite } from './usecases/resend-invite/resend-invite.usecase';

@UseInterceptors(ClassSerializerInterceptor)
@ApiCommonResponses()
@Controller('/invites')
@ApiTags('Invites')
@ApiExcludeController()
export class InvitesController {
  constructor(
    private inviteMemberUsecase: InviteMember,
    private bulkInviteUsecase: BulkInvite,
    private acceptInviteUsecase: AcceptInvite,
    private getInvite: GetInvite,
    private resendInviteUsecase: ResendInvite
  ) {}

  @Get('/:inviteToken')
  async getInviteData(@Param('inviteToken') inviteToken: string): Promise<IGetInviteResponseDto> {
    const command = GetInviteCommand.create({
      token: inviteToken,
    });

    return await this.getInvite.execute(command);
  }

  @Post('/:inviteToken/accept')
  @RequireAuthentication()
  async acceptInviteToken(
    @UserSession() user: UserSessionData,
    @Param('inviteToken') inviteToken: string
  ): Promise<string> {
    const command = AcceptInviteCommand.create({
      token: inviteToken,
      userId: user._id,
    });

    return await this.acceptInviteUsecase.execute(command);
  }

  @Post('/')
  @RequireAuthentication()
  async inviteMember(
    @UserSession() user: UserSessionData,
    @Body() body: InviteMemberDto
  ): Promise<{ success: boolean }> {
    const command = InviteMemberCommand.create({
      userId: user._id,
      organizationId: user.organizationId,
      email: body.email,
      role: MemberRoleEnum.OSS_ADMIN,
    });

    await this.inviteMemberUsecase.execute(command);

    return {
      success: true,
    };
  }

  @Post('/resend')
  @RequireAuthentication()
  async resendInviteMember(
    @UserSession() user: UserSessionData,
    @Body() body: ResendInviteDto
  ): Promise<{ success: boolean }> {
    const command = ResendInviteCommand.create({
      userId: user._id,
      organizationId: user.organizationId,
      memberId: body.memberId,
    });

    await this.resendInviteUsecase.execute(command);

    return {
      success: true,
    };
  }

  @ThrottlerCost(ApiRateLimitCostEnum.BULK)
  @Post('/bulk')
  @RequireAuthentication()
  async bulkInviteMembers(
    @UserSession() user: UserSessionData,
    @Body() body: BulkInviteMembersDto
  ): Promise<IBulkInviteResponse[]> {
    const command = BulkInviteCommand.create({
      userId: user._id,
      organizationId: user.organizationId,
      invitees: body.invitees,
    });

    const response = await this.bulkInviteUsecase.execute(command);

    return response;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class InvitesController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/invites/invites.module.ts
Tamaño: 420 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Module } from '@nestjs/common';
import { AuthModule } from '../auth/auth.module';
import { SharedModule } from '../shared/shared.module';
import { InvitesController } from './invites.controller';
import { USE_CASES } from './usecases';

@Module({
  imports: [SharedModule, AuthModule],
  controllers: [InvitesController],
  providers: [...USE_CASES],
  exports: [...USE_CASES],
})
export class InvitesModule {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class InvitesModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/invites/dtos/bulk-invite-members.dto.ts
Tamaño: 474 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IBulkInviteRequestDto } from '@novu/shared';
import { Type } from 'class-transformer';
import { ArrayNotEmpty, IsArray, IsDefined, IsEmail, IsNotEmpty, ValidateNested } from 'class-validator';

export class EmailInvitee {
  @IsDefined()
  @IsNotEmpty()
  @IsEmail()
  email: string;
}

export class BulkInviteMembersDto implements IBulkInviteRequestDto {
  @ArrayNotEmpty()
  @IsArray()
  @ValidateNested()
  @Type(() => EmailInvitee)
  invitees: EmailInvitee[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class EmailInvitee
- export class BulkInviteMembersDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/invites/dtos/invite-member.dto.ts
Tamaño: 436 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { SubscriberEntity } from '@novu/dal';
import { Type } from 'class-transformer';
import { IsEmail, IsNotEmpty, IsObject, ValidateNested } from 'class-validator';

export class InviteMemberDto {
  @IsEmail()
  @IsNotEmpty()
  email: string;
}

export class InviteWebhookDto {
  @IsObject()
  @ValidateNested()
  @Type(() => SubscriberEntity)
  subscriber: SubscriberEntity;

  @IsObject()
  payload: { organizationId: string };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class InviteMemberDto
- export class InviteWebhookDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/invites/dtos/resend-invite.dto.ts
Tamaño: 140 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsNotEmpty, IsString } from 'class-validator';

export class ResendInviteDto {
  @IsNotEmpty()
  @IsString()
  memberId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ResendInviteDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/invites/e2e/accept-invite.e2e.ts
Tamaño: 3595 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CommunityMemberRepository, MemberEntity } from '@novu/dal';
import { MemberStatusEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Accept invite - /invites/:inviteToken/accept (POST) #novu-v0-os', async () => {
  let session: UserSession;
  let invitedUserSession: UserSession;
  const memberRepository = new CommunityMemberRepository();

  async function setup() {
    session = new UserSession();
    invitedUserSession = new UserSession();
    await invitedUserSession.initialize({
      noOrganization: true,
      noEnvironment: true,
    });

    await session.initialize();

    await session.testAgent.post('/v1/invites/bulk').send({
      invitees: [
        {
          email: 'asdas@dasdas.com',
        },
      ],
    });
  }

  describe('Valid invite accept flow', async () => {
    before(async () => {
      await setup();

      const members = await memberRepository.getOrganizationMembers(session.organization._id);
      const invitee = members.find((i) => !i._userId);

      await invitedUserSession.testAgent.post(`/v1/invites/${invitee.invite.token}/accept`).expect(201);
    });

    it('should change the member status to active', async () => {
      const member = await memberRepository.findMemberByUserId(session.organization._id, invitedUserSession.user._id);

      expect(member?._userId).to.equal(invitedUserSession.user._id);
      expect(member?.memberStatus).to.equal(MemberStatusEnum.ACTIVE);
    });

    it('should invite existing user instead of creating new user', async () => {
      const thirdUserSession = new UserSession();
      await thirdUserSession.initialize();

      const inviteeMembers = await memberRepository.find({
        _organizationId: session.organization._id,
        _userId: invitedUserSession.user._id,
      });
      expect(inviteeMembers.length).to.eq(1);

      await thirdUserSession.testAgent.post('/v1/invites/bulk').send({
        invitees: [
          {
            email: invitedUserSession.user.email,
          },
        ],
      });

      const members = await memberRepository.getOrganizationMembers(thirdUserSession.organization._id);
      const newInvitee = members.find(
        (member) => member.invite && member.invite.email === invitedUserSession.user.email
      );
      expect(newInvitee).to.exist;

      const { body } = await invitedUserSession.testAgent.get(`/v1/invites/${newInvitee.invite.token}`).expect(200);
      expect(body.data.email).to.eq(invitedUserSession.user.email);

      await invitedUserSession.testAgent.post(`/v1/invites/${newInvitee.invite.token}/accept`).expect(201);

      const newInviteeMembers = await memberRepository.find({
        _userId: invitedUserSession.user._id,
      } as MemberEntity & { _organizationId: string });

      expect(newInviteeMembers.length).to.eq(2);
    });
  });

  describe('Invalid accept requests handling', async () => {
    before(async () => {
      await setup();
    });

    it('should reject expired token', async () => {
      const members = await memberRepository.getOrganizationMembers(session.organization._id);
      const invitee = members.find((i) => !i._userId);

      expect(invitee.memberStatus).to.eq(MemberStatusEnum.INVITED);

      await invitedUserSession.testAgent.post(`/v1/invites/${invitee.invite.token}/accept`).expect(201);

      const { body } = await invitedUserSession.testAgent
        .post(`/v1/invites/${invitee.invite.token}/accept`)
        .expect(400);

      expect(body.message).to.contain('expired');
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - setup()
Asignaciones con arrow functions encontradas (posibles funciones):
 - invitedUserSession(new UserSession();
    await invitedUserSession.initialize({
      noOrganization: true,
      noEnv...)
 - invitee(members.find((i))
 - member(await memberRepository.findMemberByUserId(session.organization._id, invitedUserSession.user._id);

 ...)
 - newInvitee(members.find(
        (member))
 - newInviteeMembers(await memberRepository.find({
        _userId: invitedUserSession.user._id,
      } as MemberEntity ...)
 - invitee(members.find((i))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/invites/e2e/bulk-invite.e2e.ts
Tamaño: 3526 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CommunityMemberRepository } from '@novu/dal';
import { IBulkInviteResponse, MemberRoleEnum, MemberStatusEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Bulk invite members - /invites/bulk (POST) #novu-v0-os', async () => {
  let session: UserSession;
  const memberRepository = new CommunityMemberRepository();

  before(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should fail without passing invitees', async () => {
    const { body } = await session.testAgent
      .post('/v1/invites/bulk')
      .send({
        invitees: [],
      })
      .expect(400);
  });

  it('should fail with bad emails', async () => {
    const { body } = await session.testAgent
      .post('/v1/invites/bulk')
      .send({
        invitees: [
          {
            email: 'email@bad',
            role: 'admin',
          },
        ],
      })
      .expect(400);
  });

  it('should invite member as admin', async () => {
    session = new UserSession();
    await session.initialize();

    const { body } = await session.testAgent
      .post('/v1/invites/bulk')
      .send({
        invitees: [
          {
            email: 'dddd@asdas.com',
            role: 'admin',
          },
        ],
      })
      .expect(201);

    const members = await memberRepository.getOrganizationMembers(session.organization._id);

    expect(members.length).to.eq(2);

    const member = members.find((i) => !i._userId);

    expect(member.invite.email).to.equal('dddd@asdas.com');
    expect(member.invite._inviterId).to.equal(session.user._id);
    expect(member.roles.length).to.equal(1);
    expect(member.roles[0]).to.equal(MemberRoleEnum.OSS_ADMIN);
    expect(member.memberStatus).to.equal(MemberStatusEnum.INVITED);
  });

  describe('send valid invites', () => {
    let inviteResponse: IBulkInviteResponse[];

    const invitee = {
      email: 'asdasda@asdas.com',
      role: 'admin',
    };

    before(async () => {
      session = new UserSession();
      await session.initialize();

      const { body } = await session.testAgent
        .post('/v1/invites/bulk')
        .send({
          invitees: [invitee],
        })
        .expect(201);

      inviteResponse = body.data;
    });

    it('should return a matching response', async () => {
      expect(inviteResponse.length).to.equal(1);
      expect(inviteResponse[0].success).to.equal(true);
      expect(inviteResponse[0].email).to.equal(invitee.email);
    });

    it('should create invited member entity', async () => {
      const members = await memberRepository.getOrganizationMembers(session.organization._id);

      expect(members.length).to.eq(2);

      const member = members.find((i) => !i._userId);

      expect(member.invite.email).to.equal(invitee.email);
      expect(member.invite._inviterId).to.equal(session.user._id);
      expect(member.roles.length).to.equal(1);
      expect(member.roles[0]).to.equal(MemberRoleEnum.OSS_ADMIN);

      expect(member.memberStatus).to.equal(MemberStatusEnum.INVITED);
      expect(member._userId).to.be.not.ok;
    });

    it('should fail invite already invited person', async () => {
      const { body } = await session.testAgent.post('/v1/invites/bulk').send({
        invitees: [invitee],
      });

      expect(body.data.length).to.equal(1);
      expect(body.data[0].failReason).to.include('Already invited');
      expect(body.data[0].success).to.equal(false);
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - memberRepository(new CommunityMemberRepository();

  before(async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('should fail without passing invitees...)
 - member(members.find((i))
 - invitee({
      email: 'asdasda@asdas.com',
      role: 'admin',
    };

    before(async ())
 - inviteResponse(body.data;
    });

    it('should return a matching response', async ())
 - member(members.find((i))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/invites/e2e/get-invite.e2e.ts
Tamaño: 2362 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CommunityMemberRepository, CommunityOrganizationRepository } from '@novu/dal';
import { MemberStatusEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Get invite object - /invites/:inviteToken (GET) #novu-v0-os', async () => {
  let session: UserSession;
  const organizationRepository = new CommunityOrganizationRepository();
  const memberRepository = new CommunityMemberRepository();

  describe('valid token returned', async () => {
    before(async () => {
      session = new UserSession();
      await session.initialize();

      await session.testAgent.post('/v1/invites/bulk').send({
        invitees: [
          {
            email: 'asdas@dasdas.com',
          },
        ],
      });
    });

    it('should return a valid invite object', async () => {
      const members = await memberRepository.getOrganizationMembers(session.organization._id);
      const member = members.find((i) => i.memberStatus === MemberStatusEnum.INVITED);

      const { body } = await session.testAgent.get(`/v1/invites/${member.invite.token}`);

      const response = body.data;

      expect(response.inviter._id).to.equal(session.user._id);
      expect(response.organization._id).to.equal(session.organization._id);
    });
  });

  describe('error state validation', async () => {
    before(async () => {
      session = new UserSession();
      await session.initialize();

      await session.testAgent.post('/v1/invites/bulk').send({
        invitees: [
          {
            email: 'asdas@dasdas.com',
          },
        ],
      });
    });

    it('should return an error for expired token', async () => {
      const organization = await organizationRepository.findById(session.organization._id);
      const members = await memberRepository.getOrganizationMembers(session.organization._id);
      const member = members.find((i) => i.memberStatus === MemberStatusEnum.INVITED);

      await memberRepository.update(
        { _organizationId: session.organization._id, _id: member._id, 'invite.token': member.invite.token },
        {
          memberStatus: MemberStatusEnum.ACTIVE,
        }
      );

      const { body } = await session.testAgent.get(`/v1/invites/${member.invite.token}`).expect(400);

      expect(body.message).to.contain('expired');
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - memberRepository(new CommunityMemberRepository();

  describe('valid token returned', async ())
 - session(new UserSession();
      await session.initialize();

      await session.testAgent.post('/v1/invite...)
 - member(members.find((i))
 - response(body.data;

      expect(response.inviter._id).to.equal(session.user._id);
      expect(response.org...)
 - session(new UserSession();
      await session.initialize();

      await session.testAgent.post('/v1/invite...)
 - member(members.find((i))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/invites/e2e/resend-invite.e2e.ts
Tamaño: 2701 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CommunityMemberRepository, MemberEntity } from '@novu/dal';
import { MemberStatusEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Resend invite - /invites/resend (POST) #novu-v0-os', async () => {
  let session: UserSession;
  let invitee: MemberEntity;
  const memberRepository = new CommunityMemberRepository();

  async function setup() {
    session = new UserSession();
    await session.initialize();

    await session.testAgent
      .post('/v1/invites/bulk')
      .send({
        invitees: [
          {
            email: 'asdas@dasdas.com',
          },
        ],
      })
      .expect(201);

    const members = await memberRepository.getOrganizationMembers(session.organization._id);
    invitee = members.find((i) => i.memberStatus === MemberStatusEnum.INVITED);
  }

  describe('Valid resend invite flow', async () => {
    before(async () => {
      await setup();

      const members = await memberRepository.getOrganizationMembers(session.organization._id);

      const invitedMember = members.find((i) => i.memberStatus === MemberStatusEnum.INVITED);

      const { body } = await session.testAgent
        .post('/v1/invites/resend')
        .send({ memberId: invitedMember._id })
        .expect(201);
    });

    it('should change the inviter id', async () => {
      const member = await memberRepository.findMemberById(session.organization._id, invitee._id);

      expect(member.invite._inviterId).to.equal(session.user._id);
    });
  });

  describe('Invalid accept requests handling', async () => {
    before(async () => {
      await setup();
    });

    it('should reject if member already active', async () => {
      expect(invitee.memberStatus).to.eq(MemberStatusEnum.INVITED);
      await memberRepository.update(
        { _organizationId: session.organization._id, _id: invitee._id },
        { memberStatus: MemberStatusEnum.ACTIVE }
      );

      const { body } = await session.testAgent.post('/v1/invites/resend').send({ memberId: invitee._id }).expect(400);

      expect(body.message).to.exist;
      expect(body.message).to.equal('Member already active');
      expect(body.error).to.equal('Bad Request');
    });

    it('should reject if member id invalid', async () => {
      expect(invitee.memberStatus).to.eq(MemberStatusEnum.INVITED);

      const { body } = await session.testAgent
        .post('/v1/invites/resend')
        .send({ memberId: '5fdedb7c25ab1352eef88f60' })
        .expect(400);

      expect(body.message.length).to.exist;
      expect(body.message).to.equal('Member not found');
      expect(body.error).to.equal('Bad Request');
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - setup()
Asignaciones con arrow functions encontradas (posibles funciones):
 - invitee(members.find((i))
 - invitedMember(members.find((i))
 - member(await memberRepository.findMemberById(session.organization._id, invitee._id);

      expect(member.i...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/invites/usecases/index.ts
Tamaño: 428 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { AcceptInvite } from './accept-invite/accept-invite.usecase';
import { BulkInvite } from './bulk-invite/bulk-invite.usecase';
import { GetInvite } from './get-invite/get-invite.usecase';
import { InviteMember } from './invite-member/invite-member.usecase';
import { ResendInvite } from './resend-invite/resend-invite.usecase';

export const USE_CASES = [AcceptInvite, GetInvite, BulkInvite, InviteMember, ResendInvite];


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/invites/usecases/accept-invite/accept-invite.command.ts
Tamaño: 238 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsString } from 'class-validator';
import { AuthenticatedCommand } from '../../../shared/commands/authenticated.command';

export class AcceptInviteCommand extends AuthenticatedCommand {
  @IsString()
  readonly token: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class AcceptInviteCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/invites/usecases/accept-invite/accept-invite.usecase.ts
Tamaño: 3174 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException, Scope } from '@nestjs/common';
import { Novu } from '@novu/api';
import { PinoLogger } from '@novu/application-generic';
import { MemberEntity, MemberRepository, OrganizationRepository, UserEntity, UserRepository } from '@novu/dal';
import { MemberStatusEnum } from '@novu/shared';
import { AuthService } from '../../../auth/services/auth.service';
import { capitalize } from '../../../shared/services/helper/helper.service';
import { AcceptInviteCommand } from './accept-invite.command';

@Injectable({
  scope: Scope.REQUEST,
})
export class AcceptInvite {
  private organizationId: string;

  constructor(
    private organizationRepository: OrganizationRepository,
    private memberRepository: MemberRepository,
    private userRepository: UserRepository,
    private authService: AuthService,
    private logger: PinoLogger
  ) {
    this.logger.setContext(this.constructor.name);
  }

  async execute(command: AcceptInviteCommand): Promise<string> {
    const member = await this.memberRepository.findByInviteToken(command.token);
    if (!member) throw new BadRequestException('No organization found');
    if (!member.invite) throw new BadRequestException('No active invite found for user');

    const organization = await this.organizationRepository.findById(member._organizationId);
    if (!organization) throw new NotFoundException('No organization found');

    const user = await this.userRepository.findById(command.userId);
    if (!user) throw new NotFoundException('No user found');

    this.organizationId = organization._id;

    if (member.memberStatus !== MemberStatusEnum.INVITED) throw new BadRequestException('Token expired');

    const inviter = await this.userRepository.findById(member.invite._inviterId);
    if (!inviter) throw new NotFoundException('No inviter entity found');

    await this.memberRepository.convertInvitedUserToMember(this.organizationId, command.token, {
      memberStatus: MemberStatusEnum.ACTIVE,
      _userId: command.userId,
      answerDate: new Date(),
    });

    await this.sendInviterAcceptedEmail(inviter, member);

    return this.authService.generateUserToken(user);
  }

  async sendInviterAcceptedEmail(inviter: UserEntity, member: MemberEntity) {
    if (!member.invite) return;

    try {
      if ((process.env.NODE_ENV === 'dev' || process.env.NODE_ENV === 'production') && process.env.NOVU_API_KEY) {
        const novu = new Novu({ security: { secretKey: process.env.NOVU_API_KEY } });

        await novu.trigger({
          workflowId: process.env.NOVU_TEMPLATEID_INVITE_ACCEPTED || 'invite-accepted-dEQAsKD1E',
          to: [
            {
              subscriberId: inviter._id,
              firstName: capitalize(inviter.firstName || ''),
              email: inviter.email || '',
            },
          ],
          payload: {
            invitedUserEmail: member.invite.email,
            firstName: capitalize(inviter.firstName || ''),
            ctaUrl: '/team',
          },
        });
      }
    } catch (e) {
      this.logger.error({ message: e.message, stack: e.stack }, 'Accept inviter send email');
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class AcceptInvite

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/invites/usecases/bulk-invite/bulk-invite.command.ts
Tamaño: 263 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { MemberRoleEnum } from '@novu/shared';
import { OrganizationCommand } from '../../../shared/commands/organization.command';

export class BulkInviteCommand extends OrganizationCommand {
  invitees: {
    email: string;
    role?: MemberRoleEnum;
  }[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class BulkInviteCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/invites/usecases/bulk-invite/bulk-invite.usecase.ts
Tamaño: 1742 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, Scope } from '@nestjs/common';
import { PinoLogger } from '@novu/application-generic';
import { MemberRoleEnum } from '@novu/shared';
import { captureException } from '@sentry/node';
import { InviteMemberCommand } from '../invite-member/invite-member.command';
import { InviteMember } from '../invite-member/invite-member.usecase';
import { BulkInviteCommand } from './bulk-invite.command';

interface IBulkInviteResponse {
  success: boolean;
  email: string;
  failReason?: string;
}

@Injectable({
  scope: Scope.REQUEST,
})
export class BulkInvite {
  constructor(
    private inviteMemberUsecase: InviteMember,
    private logger: PinoLogger
  ) {
    this.logger.setContext(this.constructor.name);
  }

  async execute(command: BulkInviteCommand): Promise<IBulkInviteResponse[]> {
    const invites: IBulkInviteResponse[] = [];

    for (const invitee of command.invitees) {
      try {
        await this.inviteMemberUsecase.execute(
          InviteMemberCommand.create({
            email: invitee.email,
            role: MemberRoleEnum.OSS_ADMIN,
            organizationId: command.organizationId,
            userId: command.userId,
          })
        );

        invites.push({
          success: true,
          email: invitee.email,
        });
      } catch (e) {
        if (e.message.includes('Already invited')) {
          invites.push({
            failReason: 'Already invited',
            success: false,
            email: invitee.email,
          });
        } else {
          this.logger.error({ err: e });
          captureException(e);
          invites.push({
            success: false,
            email: invitee.email,
          });
        }
      }
    }

    return invites;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class BulkInvite

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/invites/usecases/get-invite/get-invite.command.ts
Tamaño: 200 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BaseCommand } from '@novu/application-generic';
import { IsNotEmpty } from 'class-validator';

export class GetInviteCommand extends BaseCommand {
  @IsNotEmpty()
  readonly token: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetInviteCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/invites/usecases/get-invite/get-invite.usecase.ts
Tamaño: 1817 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException, Scope } from '@nestjs/common';
import { MemberRepository, OrganizationRepository, UserRepository } from '@novu/dal';
import { MemberStatusEnum, normalizeEmail } from '@novu/shared';

import { GetInviteCommand } from './get-invite.command';

@Injectable({
  scope: Scope.REQUEST,
})
export class GetInvite {
  constructor(
    private organizationRepository: OrganizationRepository,
    private memberRepository: MemberRepository,
    private userRepository: UserRepository
  ) {}

  async execute(command: GetInviteCommand) {
    const invitedMember = await this.memberRepository.findByInviteToken(command.token);
    if (!invitedMember) throw new BadRequestException('No invite found');

    const organization = await this.organizationRepository.findById(invitedMember._organizationId);
    if (!organization) throw new NotFoundException('Organization not found');

    if (invitedMember.memberStatus !== MemberStatusEnum.INVITED) {
      throw new BadRequestException('Invite token expired');
    }

    if (!invitedMember.invite) throw new NotFoundException(`Invite not found`);

    const user = await this.userRepository.findById(invitedMember.invite._inviterId);
    if (!user) throw new NotFoundException('User not found');

    const invitedUser = await this.userRepository.findByEmail(normalizeEmail(invitedMember.invite.email));

    return {
      inviter: {
        _id: user._id,
        firstName: user.firstName,
        lastName: user.lastName,
        profilePicture: user.profilePicture,
      },
      organization: {
        _id: organization._id,
        name: organization.name,
        logo: organization.logo,
      },
      email: invitedMember.invite.email,
      _userId: invitedUser ? invitedUser._id : undefined,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetInvite

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/invites/usecases/invite-member/invite-member.command.ts
Tamaño: 348 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { MemberRoleEnum } from '@novu/shared';
import { IsDefined, IsEmail, IsEnum } from 'class-validator';
import { OrganizationCommand } from '../../../shared/commands/organization.command';

export class InviteMemberCommand extends OrganizationCommand {
  @IsEmail()
  readonly email: string;

  @IsDefined()
  readonly role: MemberRoleEnum;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class InviteMemberCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/invites/usecases/invite-member/invite-member.usecase.ts
Tamaño: 2770 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException, Scope } from '@nestjs/common';
import { Novu } from '@novu/api';
import { AnalyticsService } from '@novu/application-generic';
import { IAddMemberData, MemberRepository, OrganizationRepository, UserRepository } from '@novu/dal';
import { MemberRoleEnum, MemberStatusEnum } from '@novu/shared';
import { capitalize, createGuid } from '../../../shared/services/helper/helper.service';
import { InviteMemberCommand } from './invite-member.command';

@Injectable({
  scope: Scope.REQUEST,
})
export class InviteMember {
  constructor(
    private organizationRepository: OrganizationRepository,
    private userRepository: UserRepository,
    private memberRepository: MemberRepository,
    private analyticsService: AnalyticsService
  ) {}

  async execute(command: InviteMemberCommand) {
    const organization = await this.organizationRepository.findById(command.organizationId);
    if (!organization) throw new BadRequestException('No organization found');

    const foundInvitee = await this.memberRepository.findInviteeByEmail(organization._id, command.email);

    if (foundInvitee) throw new BadRequestException('Already invited');

    const inviterUser = await this.userRepository.findById(command.userId);
    if (!inviterUser) throw new NotFoundException(`Inviter ${command.userId} is not found`);

    const token = createGuid();

    if (process.env.NOVU_API_KEY && (process.env.NODE_ENV === 'dev' || process.env.NODE_ENV === 'production')) {
      const novu = new Novu({ security: { secretKey: process.env.NOVU_API_KEY } });
      await novu.trigger({
        workflowId: process.env.NOVU_TEMPLATEID_INVITE_TO_ORGANISATION || 'invite-to-organization-wBnO8NpDn',
        to: [
          {
            subscriberId: command.email,
            email: command.email,
          },
        ],
        payload: {
          email: command.email,
          inviteeName: capitalize(command.email.split('@')[0]),
          organizationName: capitalize(organization.name),
          inviterName: capitalize(inviterUser.firstName ?? ''),
          acceptInviteUrl: `${process.env.FRONT_BASE_URL}/auth/invitation/${token}`,
        },
      });
    }

    const memberPayload: IAddMemberData = {
      roles: [command.role as MemberRoleEnum],
      memberStatus: MemberStatusEnum.INVITED,
      invite: {
        token,
        _inviterId: command.userId,
        email: command.email,
        invitationDate: new Date(),
      },
    };

    await this.memberRepository.addMember(organization._id, memberPayload);

    this.analyticsService.track('Invite Organization Member', command.userId, {
      _organization: command.organizationId,
      role: command.role,
      email: command.email,
    });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class InviteMember

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/invites/usecases/resend-invite/resend-invite.command.ts
Tamaño: 238 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsString } from 'class-validator';
import { OrganizationCommand } from '../../../shared/commands/organization.command';

export class ResendInviteCommand extends OrganizationCommand {
  @IsString()
  readonly memberId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ResendInviteCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/invites/usecases/resend-invite/resend-invite.usecase.ts
Tamaño: 2563 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, Scope } from '@nestjs/common';
import { Novu } from '@novu/api';
import { MemberRepository, OrganizationRepository, UserRepository } from '@novu/dal';
import { MemberStatusEnum } from '@novu/shared';
import { capitalize, createGuid } from '../../../shared/services/helper/helper.service';
import { ResendInviteCommand } from './resend-invite.command';

@Injectable({
  scope: Scope.REQUEST,
})
export class ResendInvite {
  constructor(
    private organizationRepository: OrganizationRepository,
    private userRepository: UserRepository,
    private memberRepository: MemberRepository
  ) {}

  async execute(command: ResendInviteCommand) {
    const organization = await this.organizationRepository.findById(command.organizationId);
    if (!organization) throw new BadRequestException('No organization found');

    const foundInvitee = await this.memberRepository.findOne({
      _id: command.memberId,
      _organizationId: command.organizationId,
    });
    if (!foundInvitee) throw new BadRequestException('Member not found');
    if (foundInvitee.memberStatus !== MemberStatusEnum.INVITED) throw new BadRequestException('Member already active');
    if (!foundInvitee.invite) throw new BadRequestException('Invited user is not found');

    const inviterUser = await this.userRepository.findById(command.userId);
    if (!inviterUser) throw new BadRequestException('Inviter is not found');

    const token = createGuid();

    if (process.env.NODE_ENV === 'dev' || process.env.NODE_ENV === 'production') {
      const novu = new Novu({ security: { secretKey: process.env.NOVU_API_KEY } });

      // cspell:disable-next
      await novu.trigger({
        workflowId: process.env.NOVU_TEMPLATEID_INVITE_TO_ORGANISATION || 'invite-to-organization-wBnO8NpDn',
        to: [
          {
            subscriberId: foundInvitee.invite.email,
            email: foundInvitee.invite.email,
          },
        ],
        payload: {
          email: foundInvitee.invite.email,
          inviteeName: capitalize(foundInvitee.invite.email.split('@')[0]),
          organizationName: capitalize(organization.name),
          inviterName: capitalize(inviterUser.firstName ?? ''),
          acceptInviteUrl: `${process.env.FRONT_BASE_URL}/auth/invitation/${token}`,
        },
      });
    }

    await this.memberRepository.update(foundInvitee, {
      memberStatus: MemberStatusEnum.INVITED,
      invite: {
        token,
        _inviterId: command.userId,
        invitationDate: new Date(),
      },
    });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ResendInvite

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/layouts-v1.controller.ts
Tamaño: 9190 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  BadRequestException,
  Body,
  Controller,
  Delete,
  Get,
  HttpCode,
  HttpStatus,
  Param,
  Patch,
  Post,
  Query,
} from '@nestjs/common';
import { ApiOperation, ApiParam, ApiTags } from '@nestjs/swagger';
import { ApiExcludeController } from '@nestjs/swagger/dist/decorators/api-exclude-controller.decorator';
import { GetLayoutCommand, GetLayoutUseCase, OtelSpan, PinoLogger } from '@novu/application-generic';
import { OrderByEnum, OrderDirectionEnum, UserSessionData } from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { ExternalApiAccessible } from '../auth/framework/external-api.decorator';
import {
  ApiBadRequestResponse,
  ApiCommonResponses,
  ApiConflictResponse,
  ApiNoContentResponse,
  ApiNotFoundResponse,
  ApiOkResponse,
  ApiResponse,
} from '../shared/framework/response.decorator';
import { SdkMethodName } from '../shared/framework/swagger/sdk.decorators';
import { UserSession } from '../shared/framework/user.decorator';
import {
  CreateLayoutRequestDto,
  CreateLayoutResponseDto,
  FilterLayoutsRequestDto,
  FilterLayoutsResponseDto,
  GetLayoutResponseDto,
  UpdateLayoutRequestDto,
  UpdateLayoutResponseDto,
} from './dtos';
import { LayoutId } from './types';
import {
  CreateLayoutCommand,
  CreateLayoutUseCase,
  DeleteLayoutCommand,
  DeleteLayoutUseCase,
  FilterLayoutsCommand,
  FilterLayoutsUseCase,
  SetDefaultLayoutCommand,
  SetDefaultLayoutUseCase,
  UpdateLayoutCommand,
  UpdateLayoutUseCase,
} from './usecases';

@ApiCommonResponses()
@Controller('/layouts')
@ApiTags('Layouts')
@RequireAuthentication()
@ApiExcludeController()
export class LayoutsControllerV1 {
  constructor(
    private createLayoutUseCase: CreateLayoutUseCase,
    private deleteLayoutUseCase: DeleteLayoutUseCase,
    private filterLayoutsUseCase: FilterLayoutsUseCase,
    private getLayoutUseCase: GetLayoutUseCase,
    private setDefaultLayoutUseCase: SetDefaultLayoutUseCase,
    private updateLayoutUseCase: UpdateLayoutUseCase,
    private logger: PinoLogger
  ) {
    this.logger.setContext(this.constructor.name);
  }

  @Post('')
  @ExternalApiAccessible()
  @ApiResponse(CreateLayoutResponseDto, 201)
  @ApiOperation({ summary: 'Layout creation', description: 'Create a layout' })
  @OtelSpan()
  @SdkMethodName('create')
  async createLayout(
    @UserSession() user: UserSessionData,
    @Body() body: CreateLayoutRequestDto
  ): Promise<CreateLayoutResponseDto> {
    this.logger.trace('Executing new layout command');

    const layout = await this.createLayoutUseCase.execute(
      CreateLayoutCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
        name: body.name,
        identifier: body.identifier,
        description: body.description,
        content: body.content,
        variables: body.variables,
        isDefault: body.isDefault,
      })
    );

    this.logger.trace(`Created new Layout${layout._id}`);

    return {
      _id: layout._id,
    };
  }

  @Get()
  @ExternalApiAccessible()
  @ApiOkResponse({
    description: 'The list of layouts that match the criteria of the query params are successfully returned.',
  })
  @ApiBadRequestResponse({
    description: 'Page size can not be larger than the page size limit.',
  })
  @ApiOperation({
    summary: 'Filter layouts',
    description:
      'Returns a list of layouts that can be paginated using the `page` query parameter and filtered by' +
      ' the environment where it is executed from the organization the user belongs to.',
  })
  async listLayouts(
    @UserSession() user: UserSessionData,
    @Query() query?: FilterLayoutsRequestDto
  ): Promise<FilterLayoutsResponseDto> {
    return await this.filterLayoutsUseCase.execute(
      FilterLayoutsCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        page: query?.page,
        pageSize: query?.pageSize,
        sortBy: query?.sortBy,
        orderBy: this.resolveOrderBy(query),
      })
    );
  }

  private resolveOrderBy(query?: FilterLayoutsRequestDto): OrderDirectionEnum {
    if (!query || !query.orderBy) {
      return OrderDirectionEnum.DESC;
    }
    if (query?.orderBy === OrderByEnum.ASC) {
      return OrderDirectionEnum.ASC;
    }
    if (query?.orderBy === OrderByEnum.DESC) {
      return OrderDirectionEnum.DESC;
    }
    if (query?.orderBy === OrderDirectionEnum.DESC) {
      return OrderDirectionEnum.DESC;
    }
    if (query?.orderBy === OrderDirectionEnum.ASC) {
      return OrderDirectionEnum.ASC;
    }

    return query?.orderBy;
  }

  @Get('/:layoutId')
  @ExternalApiAccessible()
  @ApiResponse(GetLayoutResponseDto)
  @ApiNotFoundResponse({
    description: 'The layout with the layoutId provided does not exist in the database.',
  })
  @ApiParam({ name: 'layoutId', description: 'The layout id', type: String, required: true })
  @ApiOperation({ summary: 'Get layout', description: 'Get a layout by its ID' })
  async getLayout(
    @UserSession() user: UserSessionData,
    @Param('layoutId') layoutId: LayoutId
  ): Promise<GetLayoutResponseDto> {
    return await this.getLayoutUseCase.execute(
      GetLayoutCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        layoutIdOrInternalId: layoutId,
      })
    );
  }

  @Delete('/:layoutId')
  @ExternalApiAccessible()
  @ApiNoContentResponse({
    description: 'The layout has been deleted correctly',
  })
  @ApiNotFoundResponse({
    description: 'The layout with the layoutId provided does not exist in the database so it can not be deleted.',
  })
  @ApiConflictResponse({
    description:
      'Either you are trying to delete a layout that is being used or a layout that is the default in the environment.',
  })
  @ApiParam({ name: 'layoutId', description: 'The layout id', type: String, required: true })
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({ summary: 'Delete layout', description: 'Execute a soft delete of a layout given a certain ID.' })
  async deleteLayout(@UserSession() user: UserSessionData, @Param('layoutId') layoutId: LayoutId): Promise<void> {
    return await this.deleteLayoutUseCase.execute(
      DeleteLayoutCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
        layoutId,
      })
    );
  }

  @Patch('/:layoutId')
  @ExternalApiAccessible()
  @ApiResponse(UpdateLayoutResponseDto)
  @ApiBadRequestResponse({
    description: 'The payload provided or the URL param are not right.',
  })
  @ApiNotFoundResponse({
    description: 'The layout with the layoutId provided does not exist in the database so it can not be updated.',
  })
  @ApiConflictResponse({
    description:
      'One default layout is needed. If you are trying to turn a default layout as not default, you should turn a different layout as default first and automatically it will be done by the system.',
    schema: { example: `One default layout is required` },
  })
  @ApiParam({ name: 'layoutId', description: 'The layout id', type: String, required: true })
  @ApiOperation({
    summary: 'Update a layout',
    description: 'Update the name, content and variables of a layout. Also change it to be default or no.',
  })
  async updateLayout(
    @UserSession() user: UserSessionData,
    @Param('layoutId') layoutId: LayoutId,
    @Body() body: UpdateLayoutRequestDto
  ): Promise<UpdateLayoutResponseDto> {
    if (!body || Object.keys(body).length === 0) {
      throw new BadRequestException('Payload can not be empty');
    }

    return await this.updateLayoutUseCase.execute(
      UpdateLayoutCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
        layoutId,
        name: body.name,
        identifier: body.identifier,
        description: body.description,
        content: body.content,
        variables: body.variables,
        isDefault: body.isDefault,
      })
    );
  }

  @Post('/:layoutId/default')
  @ExternalApiAccessible()
  @ApiNoContentResponse({
    description: 'The selected layout has been set as the default for the environment.',
  })
  @ApiNotFoundResponse({
    description:
      'The layout with the layoutId provided does not exist in the database so it can not be set as the default for the environment.',
  })
  @ApiParam({ name: 'layoutId', description: 'The layout id', type: String, required: true })
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({
    summary: 'Set default layout',
    description:
      'Sets the default layout for the environment and updates to non default to the existing default layout (if any).',
  })
  @SdkMethodName('setAsDefault')
  async setDefaultLayout(@UserSession() user: UserSessionData, @Param('layoutId') layoutId: LayoutId): Promise<void> {
    await this.setDefaultLayoutUseCase.execute(
      SetDefaultLayoutCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
        layoutId,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class LayoutsControllerV1

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/layouts-v1.module.ts
Tamaño: 734 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { forwardRef, Module } from '@nestjs/common';

import { ResourceValidatorService } from '@novu/application-generic';
import { AuthModule } from '../auth/auth.module';
import { ChangeModule } from '../change/change.module';
import { MessageTemplateModule } from '../message-template/message-template.module';
import { SharedModule } from '../shared/shared.module';
import { LayoutsControllerV1 } from './layouts-v1.controller';
import { USE_CASES } from './usecases';

@Module({
  imports: [SharedModule, ChangeModule, MessageTemplateModule, forwardRef(() => AuthModule)],
  providers: [...USE_CASES, ResourceValidatorService],
  exports: [...USE_CASES],
  controllers: [LayoutsControllerV1],
})
export class LayoutsV1Module {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class LayoutsV1Module

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/dtos/create-layout.dto.ts
Tamaño: 1318 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IsBoolean, IsDefined, IsOptional, IsString } from 'class-validator';

import { LayoutVariables } from '../types';

export class CreateLayoutResponseDto {
  @ApiProperty({
    description: 'The unique identifier for the Layout created.',
  })
  _id: string;
}

export class CreateLayoutRequestDto {
  @ApiProperty({
    description: 'User defined custom name and provided by the user that will name the Layout created.',
  })
  @IsString()
  @IsDefined()
  name: string;

  @ApiProperty({
    description: 'User defined custom key that will be a unique identifier for the Layout created.',
  })
  @IsString()
  @IsDefined()
  identifier: string;

  @ApiPropertyOptional({
    description: 'User description of the layout',
  })
  @IsString()
  @IsOptional()
  description: string;

  @ApiProperty({
    description: 'User defined content for the layout.',
  })
  @IsDefined()
  content: string;

  @ApiPropertyOptional({
    description: 'User defined variables to render in the layout placeholders.',
  })
  @IsOptional()
  variables?: LayoutVariables;

  @ApiPropertyOptional({
    description: 'Variable that defines if the layout is chosen as default when creating a layout.',
  })
  @IsBoolean()
  @IsOptional()
  isDefault?: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateLayoutResponseDto
- export class CreateLayoutRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/dtos/filter-layouts.dto.ts
Tamaño: 1483 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { OrderByEnum } from '@novu/shared';

import { Transform } from 'class-transformer';
import { IsInt, IsOptional, IsString, Min } from 'class-validator';
import { LayoutDto } from './layout.dto';

export class FilterLayoutsRequestDto {
  @Transform(({ value }) => Number(value))
  @IsOptional()
  @IsInt()
  @Min(0)
  @ApiPropertyOptional({ type: Number, description: 'Number of page for pagination', required: false })
  public page?: number;

  @Transform(({ value }) => Number(value))
  @IsOptional()
  @IsInt()
  @Min(0)
  @ApiPropertyOptional({ type: Number, description: 'Size of page for pagination', required: false })
  public pageSize?: number;

  @IsOptional()
  @IsString()
  @ApiPropertyOptional({
    type: String,
    description: 'Sort field. Currently only supported `createdAt`',
    required: false,
  })
  public sortBy?: string;

  @Transform(({ value }) => Number(value))
  @IsOptional()
  @ApiPropertyOptional({
    type: String,
    enum: OrderByEnum,
    description: 'Direction of the sorting query param',
    required: false,
  })
  public orderBy?: number | OrderByEnum;
}

export class FilterLayoutsResponseDto {
  @ApiProperty({
    type: LayoutDto,
    isArray: true,
  })
  data: LayoutDto[];

  @ApiProperty({
    type: Number,
  })
  page: number;

  @ApiProperty({
    type: Number,
  })
  pageSize: number;

  @ApiProperty({
    type: Number,
  })
  totalCount: number;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class FilterLayoutsRequestDto
- export class FilterLayoutsResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/dtos/get-layout.dto.ts
Tamaño: 98 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { LayoutDto } from './layout.dto';

export class GetLayoutResponseDto extends LayoutDto {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetLayoutResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/dtos/index.ts
Tamaño: 176 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './create-layout.dto';
export * from './filter-layouts.dto';
export * from './get-layout.dto';
export * from './layout.dto';
export * from './update-layout.dto';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/dtos/layout.dto.ts
Tamaño: 1547 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { UserEntity } from '@novu/dal';
import { ResourceOriginEnum, ResourceTypeEnum } from '@novu/shared';
import { Type } from 'class-transformer';
import { ControlsMetadataDto } from '../../workflows-v2/dtos/controls-metadata.dto';
import { ChannelTypeEnum, ITemplateVariable } from '../types';

export class LayoutDto {
  @ApiPropertyOptional()
  _id?: string;

  @ApiProperty()
  _organizationId: string;

  @ApiProperty()
  _environmentId: string;

  @ApiProperty()
  _creatorId: string;

  @ApiProperty()
  name: string;

  @ApiProperty()
  identifier: string;

  @ApiProperty()
  description?: string;

  @ApiProperty({
    enum: ChannelTypeEnum,
  })
  channel: ChannelTypeEnum;

  @ApiProperty()
  content?: string;

  @ApiProperty()
  contentType?: string;

  @ApiPropertyOptional()
  variables?: ITemplateVariable[];

  @ApiProperty()
  isDefault: boolean;

  @ApiProperty()
  isDeleted: boolean;

  @ApiPropertyOptional()
  createdAt?: string;

  @ApiPropertyOptional()
  updatedAt?: string;

  @ApiPropertyOptional()
  updatedBy?: UserEntity;

  @ApiPropertyOptional()
  _parentId?: string;

  @ApiPropertyOptional()
  type?: ResourceTypeEnum;

  @ApiPropertyOptional()
  origin?: ResourceOriginEnum;

  @ApiProperty({
    description: 'Controls metadata for the layout',
    type: () => ControlsMetadataDto,
    required: true,
  })
  @Type(() => ControlsMetadataDto)
  controls: ControlsMetadataDto;

  @ApiPropertyOptional()
  isTranslationEnabled?: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class LayoutDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/dtos/update-layout.dto.ts
Tamaño: 1292 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IsBoolean, IsOptional, IsString } from 'class-validator';
import { LayoutVariables } from '../types';
import { LayoutDto } from './layout.dto';

export class UpdateLayoutResponseDto extends LayoutDto {}

export class UpdateLayoutRequestDto {
  @ApiPropertyOptional({
    description: 'User defined custom name and provided by the user that will name the Layout updated.',
  })
  @IsString()
  @IsOptional()
  name?: string;

  @ApiProperty({
    description: 'User defined custom key that will be a unique identifier for the Layout updated.',
  })
  @IsString()
  @IsOptional()
  identifier: string;

  @ApiPropertyOptional({
    description: 'User defined description of the layout',
  })
  @IsString()
  @IsOptional()
  description?: string;

  @ApiPropertyOptional({
    description: 'User defined content for the layout.',
  })
  @IsOptional()
  content?: string;

  @ApiPropertyOptional({
    description: 'User defined variables to render in the layout placeholders.',
  })
  @IsOptional()
  variables?: LayoutVariables;

  @ApiPropertyOptional({
    description: 'Variable that defines if the layout is chosen as default when creating a layout.',
  })
  @IsBoolean()
  @IsOptional()
  isDefault?: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateLayoutResponseDto
- export class UpdateLayoutRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/e2e/create-layout.e2e.ts
Tamaño: 5152 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';

import { LayoutId, TemplateVariableTypeEnum } from '../types';

const BASE_PATH = '/v1/layouts';

describe('Layout creation - /layouts (POST) #novu-v0', async () => {
  let session: UserSession;
  let initialDefaultLayoutId: LayoutId;

  before(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should throw validation error for missing request payload information', async () => {
    const { body } = await session.testAgent.post(BASE_PATH).send({});

    expect(body.statusCode).to.equal(400);
    expect(body.message.find((i) => i.includes('name'))).to.be.ok;
    expect(body.message.find((i) => i.includes('content'))).to.be.ok;
    expect(body.message).to.eql([
      'name should not be null or undefined',
      'name must be a string',
      'identifier should not be null or undefined',
      'identifier must be a string',
      'content should not be null or undefined',
    ]);
  });

  it('should create a new layout successfully', async () => {
    const layoutName = 'layout-name-creation';
    const layoutIdentifier = 'layout-identifier-creation';
    const layoutDescription = 'Amazing new layout';
    const content = '<html><body><div>Hello {{organizationName}} {{{body}}}</div></body></html>';
    const variables = [
      { name: 'organizationName', type: TemplateVariableTypeEnum.STRING, defaultValue: 'Company', required: false },
    ];
    const isDefault = true;
    const response = await session.testAgent.post(BASE_PATH).send({
      name: layoutName,
      identifier: layoutIdentifier,
      description: layoutDescription,
      content,
      variables,
      isDefault,
    });

    expect(response.statusCode).to.eql(201);

    const { body } = response;
    initialDefaultLayoutId = body.data._id;

    expect(initialDefaultLayoutId).to.exist;
    expect(initialDefaultLayoutId).to.be.string;
  });
  it('should throw error for a create with layout identifier that already exists in the environment', async () => {
    const firstLayoutUrl = `${BASE_PATH}/${initialDefaultLayoutId}`;
    const firstLayoutResponse = await session.testAgent.get(firstLayoutUrl);
    const existingLayoutIdentifier = firstLayoutResponse.body.data.identifier;

    const layoutName = 'second-layout-name-creation';
    const layoutDescription = 'Amazing new layout';
    const content = '<html><body><div>Hello {{organizationName}} {{{body}}}</div></body></html>';
    const variables = [
      { name: 'organizationName', type: TemplateVariableTypeEnum.STRING, defaultValue: 'Company', required: false },
    ];
    const isDefault = false;

    const response = await session.testAgent.post(BASE_PATH).send({
      name: layoutName,
      identifier: existingLayoutIdentifier,
      description: layoutDescription,
      content,
      variables,
      isDefault,
    });

    expect(response.statusCode).to.eql(409);
    expect(response.body.error).to.eql('Conflict');
    expect(response.body.message).to.eql(
      `Layout with identifier: ${existingLayoutIdentifier} already exists under environment ${session.environment._id}`
    );
    expect(response.body.statusCode).to.eql(409);
  });

  it('if the layout created is assigned as default it should set as non default the existing default layout', async () => {
    const firstLayoutUrl = `${BASE_PATH}/${initialDefaultLayoutId}`;
    const firstLayoutResponse = await session.testAgent.get(firstLayoutUrl);
    expect(firstLayoutResponse.body.data._id).to.eql(initialDefaultLayoutId);
    expect(firstLayoutResponse.body.data.isDefault).to.eql(true);

    const layoutName = 'layout-name-creation-new-default';
    const layoutIdentifier = 'layout-identifier-creation-new-default';
    const layoutDescription = 'new-default-layout';
    const content = '<html><body><div>Hello {{organizationName}} {{{body}}}</div></body></html>';
    const variables = [
      { name: 'organizationName', type: TemplateVariableTypeEnum.STRING, defaultValue: 'Company', required: false },
    ];
    const isDefault = true;
    const response = await session.testAgent.post(BASE_PATH).send({
      name: layoutName,
      identifier: layoutIdentifier,
      description: layoutDescription,
      content,
      variables,
      isDefault,
    });

    expect(response.statusCode).to.eql(201);

    const firstLayoutNonDefaultResponse = await session.testAgent.get(firstLayoutUrl);
    expect(firstLayoutNonDefaultResponse.body.data._id).to.eql(initialDefaultLayoutId);
    expect(firstLayoutNonDefaultResponse.body.data.isDefault).to.eql(false);

    const secondLayoutId = response.body.data._id;
    const secondLayoutUrl = `${BASE_PATH}/${secondLayoutId}`;
    const secondLayoutDefaultResponse = await session.testAgent.get(secondLayoutUrl);
    expect(secondLayoutDefaultResponse.body.data._id).to.eql(secondLayoutId);
    expect(secondLayoutDefaultResponse.body.data.name).to.eql(layoutName);
    expect(secondLayoutDefaultResponse.body.data.identifier).to.eql(layoutIdentifier);
    expect(secondLayoutDefaultResponse.body.data.isDefault).to.eql(true);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - BASE_PATH('/v1/layouts';

describe('Layout creation - /layouts (POST) #novu-v0', async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('should throw validation error for mi...)
 - initialDefaultLayoutId(body.data._id;

    expect(initialDefaultLayoutId).to.exist;
    expect(initialDefaultLayoutId).to.b...)
 - response(await session.testAgent.post(BASE_PATH).send({
      name: layoutName,
      identifier: existingLay...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/e2e/delete-layout.e2e.ts
Tamaño: 4530 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Test } from '@nestjs/testing';
import { CreateMessageTemplate, CreateMessageTemplateCommand } from '@novu/application-generic';
import { MessageTemplateRepository } from '@novu/dal';
import { EmailBlockTypeEnum, ResourceTypeEnum, StepTypeEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { MessageTemplateModule } from '../../message-template/message-template.module';
import { SharedModule } from '../../shared/shared.module';
import { createLayout } from './helpers';

const BASE_PATH = '/v1/layouts';

describe('Delete a layout - /layouts/:layoutId (DELETE) #novu-v0', async () => {
  let useCase: CreateMessageTemplate;
  let session: UserSession;

  before(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [SharedModule, MessageTemplateModule],
      providers: [],
    }).compile();

    session = new UserSession();
    await session.initialize();

    useCase = moduleRef.get<CreateMessageTemplate>(CreateMessageTemplate);
  });

  it('should soft delete the requested layout successfully if exists in the database for that user', async () => {
    const layoutName = 'layout-name-deletion';
    const layoutIdentifier = 'layout-identifier-deletion';
    const isDefault = false;
    const createdLayout = await createLayout(session, layoutName, isDefault, layoutIdentifier);
    const url = `${BASE_PATH}/${createdLayout._id}`;
    const deleteResponse = await session.testAgent.delete(url);

    expect(deleteResponse.statusCode).to.eql(204);
    expect(deleteResponse.body).to.eql({});

    const checkIfDeletedResponse = await session.testAgent.get(url);
    expect(checkIfDeletedResponse.statusCode).to.eql(404);
  });

  it('should throw a not found error when the layout ID to soft delete does not exist in the database', async () => {
    const nonExistingLayoutId = 'ab12345678901234567890ab';
    const url = `${BASE_PATH}/${nonExistingLayoutId}`;
    const { body } = await session.testAgent.delete(url);

    expect(body.statusCode).to.equal(404);
    expect(body.message).to.eql(
      `Layout not found for id ${nonExistingLayoutId} in the environment ${session.environment._id}`
    );
    expect(body.error).to.eql('Not Found');
  });

  it('should throw a conflict error when the layout ID to soft delete is the default layout', async () => {
    const layoutName = 'layout-name-deletion';
    const layoutIdentifier = 'layout-identifier-deletion';
    const isDefault = true;
    const createdLayout = await createLayout(session, layoutName, isDefault, layoutIdentifier);
    const url = `${BASE_PATH}/${createdLayout._id}`;
    const deleteResponse = await session.testAgent.delete(url);

    expect(deleteResponse.statusCode).to.eql(409);
    expect(deleteResponse.body.error).to.eql('Conflict');
    expect(deleteResponse.body.message).to.eql(
      `Layout with id ${createdLayout._id} is being used as your default layout, so it can not be deleted`
    );
    expect(deleteResponse.body.statusCode).to.eql(409);
  });

  it('should throw a conflict error when the layout ID to soft delete is associated to message templates', async () => {
    const layoutName = 'layout-name-deletion-conflict';
    const layoutIdentifier = 'layout-identifier-deletion-conflict';
    const isDefault = true;
    const createdLayout = await createLayout(session, layoutName, isDefault, layoutIdentifier);

    const parentChangeId = MessageTemplateRepository.createObjectId();
    const content = [{ type: EmailBlockTypeEnum.TEXT, content: 'test' }];
    const command = CreateMessageTemplateCommand.create({
      userId: session.user._id,
      organizationId: session.organization._id,
      environmentId: session.environment._id,
      type: StepTypeEnum.PUSH,
      name: 'test-message-template',
      title: 'test',
      layoutId: createdLayout._id,
      variables: [],
      content,
      parentChangeId,
      workflowType: ResourceTypeEnum.REGULAR,
    });

    const result = await useCase.execute(command);
    expect(result._layoutId).to.eql(createdLayout._id);

    const url = `${BASE_PATH}/${createdLayout._id}`;
    const deleteResponse = await session.testAgent.delete(url);

    expect(deleteResponse.statusCode).to.eql(409);
    expect(deleteResponse.body.error).to.eql('Conflict');
    expect(deleteResponse.body.message).to.eql(
      `Layout with id ${createdLayout._id} is being used so it can not be deleted`
    );
    expect(deleteResponse.body.statusCode).to.eql(409);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - BASE_PATH('/v1/layouts';

describe('Delete a layout - /layouts/:layoutId (DELETE) #novu-v0', async ())
 - useCase(moduleRef.get<CreateMessageTemplate>(CreateMessageTemplate);
  });

  it('should soft delete the req...)
 - checkIfDeletedResponse(await session.testAgent.get(url);
    expect(checkIfDeletedResponse.statusCode).to.eql(404);
  });

...)
 - deleteResponse(await session.testAgent.delete(url);

    expect(deleteResponse.statusCode).to.eql(409);
    expect(...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/e2e/filter-layouts.e2e.ts
Tamaño: 6796 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';

import { createLayout } from './helpers';

const BASE_PATH = '/v1/layouts';

describe('Filter layouts - /layouts (GET) #novu-v0', async () => {
  let session: UserSession;

  before(async () => {
    session = new UserSession();
    await session.initialize();

    await createLayout(session, 'layout-name-1', false, 'layout-identifier-1');
    await createLayout(session, 'layout-name-2', false, 'layout-identifier-2');
    await createLayout(session, 'layout-name-3', false, 'layout-identifier-3');
  });

  it('should return a validation error if the params provided are not in the right type', async () => {
    const url = `${BASE_PATH}?page=first&pageSize=big`;
    const response = await session.testAgent.get(url);

    expect(response.statusCode).to.eql(400);
    expect(response.body.error).to.eql('Bad Request');
    expect(response.body.message).to.eql([
      'page must not be less than 0',
      'page must be an integer number',
      'pageSize must not be less than 0',
      'pageSize must be an integer number',
    ]);
  });

  it('should return a validation error if the expected params provided are not integers', async () => {
    const url = `${BASE_PATH}?page=1.5&pageSize=1.5`;
    const response = await session.testAgent.get(url);

    expect(response.statusCode).to.eql(400);
    expect(response.body.error).to.eql('Bad Request');
    expect(response.body.message).to.eql(['page must be an integer number', 'pageSize must be an integer number']);
  });

  it('should return a validation error if the expected params provided are negative integers', async () => {
    const url = `${BASE_PATH}?page=-1&pageSize=-1`;
    const response = await session.testAgent.get(url);

    expect(response.statusCode).to.eql(400);
    expect(response.body.error).to.eql('Bad Request');
    expect(response.body.message).to.eql(['page must not be less than 0', 'pageSize must not be less than 0']);
  });

  it('should return a Bad Request error if the page size requested is bigger than the max allowed (1000)', async () => {
    const url = `${BASE_PATH}?page=1&pageSize=1001`;
    const response = await session.testAgent.get(url);

    expect(response.statusCode).to.eql(400);
    expect(response.body.error).to.eql('Bad Request');
    expect(response.body.message).to.eql('Page size can not be larger then 1000');
  });

  it('should retrieve all the layouts that exist in the database for the environment if not query params provided', async () => {
    const url = `${BASE_PATH}`;
    const response = await session.testAgent.get(url);

    expect(response.statusCode).to.eql(200);

    const { data, totalCount, page, pageSize } = response.body;

    expect(data.length).to.eql(4);
    expect(totalCount).to.eql(4);
    expect(page).to.eql(0);
    expect(pageSize).to.eql(10);
  });

  it('should retrieve two layouts from the database for the environment if pageSize is set to 2 and page 0 selected', async () => {
    const url = `${BASE_PATH}?page=0&pageSize=2`;
    const response = await session.testAgent.get(url);

    expect(response.statusCode).to.eql(200);

    const { data, totalCount, page, pageSize } = response.body;

    expect(data.length).to.eql(2);
    expect(totalCount).to.eql(4);
    expect(page).to.eql(0);
    expect(pageSize).to.eql(2);

    expect(data[0].name).to.eql('layout-name-3');
    expect(data[1].name).to.eql('layout-name-2');
  });

  it('should retrieve two layout from the database for the environment if pageSize is set to 2 and page 1 selected', async () => {
    const url = `${BASE_PATH}?page=1&pageSize=2`;
    const response = await session.testAgent.get(url);

    expect(response.statusCode).to.eql(200);

    const { data, totalCount, page, pageSize } = response.body;

    expect(data.length).to.eql(2);
    expect(totalCount).to.eql(4);
    expect(page).to.eql(1);
    expect(pageSize).to.eql(2);

    expect(data[0].name).to.eql('layout-name-1');
  });

  it('should retrieve zero layouts from the database for the environment if pageSize is set to 2 and page 2 selected', async () => {
    const url = `${BASE_PATH}?page=2&pageSize=2`;
    const response = await session.testAgent.get(url);

    expect(response.statusCode).to.eql(200);

    const { data, totalCount, page, pageSize } = response.body;

    expect(data.length).to.eql(0);
    expect(totalCount).to.eql(4);
    expect(page).to.eql(2);
    expect(pageSize).to.eql(2);
  });

  it('should ignore other query params and return all the layouts that belong to the environment', async () => {
    const url = `${BASE_PATH}?unsupportedParam=whatever`;
    const response = await session.testAgent.get(url);

    expect(response.statusCode).to.eql(200);

    const { data, totalCount, page, pageSize } = response.body;

    expect(data.length).to.eql(4);
    expect(totalCount).to.eql(4);
    expect(page).to.eql(0);
    expect(pageSize).to.eql(10);
  });

  it('should order the filtered layouts by creation date in ascendent order', async () => {
    const url = `${BASE_PATH}?sortBy=createdAt&orderBy=1`;
    const response = await session.testAgent.get(url);

    expect(response.statusCode).to.eql(200);

    const { data, totalCount, page, pageSize } = response.body;

    expect(data.length).to.eql(4);
    expect(totalCount).to.eql(4);
    expect(page).to.eql(0);
    expect(pageSize).to.eql(10);

    expect(data[1].name).to.eql('layout-name-1');
    expect(data[2].name).to.eql('layout-name-2');
    expect(data[3].name).to.eql('layout-name-3');
  });

  it('should order the filtered layouts by creation date in descendent order', async () => {
    const url = `${BASE_PATH}?sortBy=createdAt&orderBy=-1`;
    const response = await session.testAgent.get(url);

    expect(response.statusCode).to.eql(200);

    const { data, totalCount, page, pageSize } = response.body;

    expect(data.length).to.eql(4);
    expect(totalCount).to.eql(4);
    expect(page).to.eql(0);
    expect(pageSize).to.eql(10);

    expect(data[0].name).to.eql('layout-name-3');
    expect(data[1].name).to.eql('layout-name-2');
    expect(data[2].name).to.eql('layout-name-1');
  });

  it('should order the filtered layouts by creation date in descendent order limited to the amount of layouts by page size', async () => {
    const url = `${BASE_PATH}?sortBy=createdAt&orderBy=-1&pageSize=2`;
    const response = await session.testAgent.get(url);

    expect(response.statusCode).to.eql(200);

    const { data, totalCount, page, pageSize } = response.body;

    expect(data.length).to.eql(2);
    expect(totalCount).to.eql(4);
    expect(page).to.eql(0);
    expect(pageSize).to.eql(2);

    expect(data[0].name).to.eql('layout-name-3');
    expect(data[1].name).to.eql('layout-name-2');
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - BASE_PATH('/v1/layouts';

describe('Filter layouts - /layouts (GET) #novu-v0', async ())
 - session(new UserSession();
    await session.initialize();

    await createLayout(session, 'layout-name-1',...)
 - response(await session.testAgent.get(url);

    expect(response.statusCode).to.eql(400);
    expect(response....)
 - response(await session.testAgent.get(url);

    expect(response.statusCode).to.eql(400);
    expect(response....)
 - response(await session.testAgent.get(url);

    expect(response.statusCode).to.eql(400);
    expect(response....)
 - response(await session.testAgent.get(url);

    expect(response.statusCode).to.eql(400);
    expect(response....)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/e2e/get-layout.e2e.ts
Tamaño: 2679 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { LayoutDto } from '../dtos';
import { ChannelTypeEnum, TemplateVariableTypeEnum } from '../types';
import { createLayout } from './helpers';

const BASE_PATH = '/v1/layouts';

describe('Get a layout - /layouts/:layoutId (GET) #novu-v0', async () => {
  const layoutName = 'layout-name-retrieval';
  const layoutIdentifier = 'layout-identifier-retrieval';
  const isDefault = false;
  let session: UserSession;
  let createdLayout: LayoutDto;

  before(async () => {
    session = new UserSession();
    await session.initialize();
    createdLayout = await createLayout(session, layoutName, isDefault, layoutIdentifier);
  });

  it('should retrieve the requested layout successfully if exists in the database for that user', async () => {
    const expectedDescription = 'Amazing new layout';
    const expectedContent = '<html><body><div>Hello {{organizationName}} {{{body}}}</div></body></html>';

    const expectedVariables = [
      { name: 'organizationName', type: TemplateVariableTypeEnum.STRING, defaultValue: 'Company', required: false },
    ];

    const url = `${BASE_PATH}/${createdLayout._id}`;
    const getResponse = await session.testAgent.get(url);

    expect(getResponse.statusCode).to.eql(200);

    const layout = getResponse.body.data;

    expect(layout._id).to.eql(createdLayout._id);
    expect(layout._environmentId).to.eql(session.environment._id);
    expect(layout._organizationId).to.eql(session.organization._id);
    expect(layout._creatorId).to.eql(session.user._id);
    expect(layout.name).to.eql(layoutName);
    expect(layout.identifier).to.eql(layoutIdentifier);
    expect(layout.description).to.eql(expectedDescription);
    expect(layout.content).to.eql(expectedContent);
    expect(layout.variables).to.eql(expectedVariables);
    expect(layout.channel).to.eql(ChannelTypeEnum.EMAIL);
    expect(layout.contentType).to.eql('customHtml');
    expect(layout.isDefault).to.eql(false);
    expect(layout.isDeleted).to.eql(false);
    expect(layout.createdAt).to.be.ok;
    expect(layout.updatedAt).to.be.ok;
  });

  it('should throw a not found error when the layout ID does not exist in the database for the user requesting it', async () => {
    const nonExistingLayoutId = 'ab12345678901234567890ab';
    const url = `${BASE_PATH}/${nonExistingLayoutId}`;
    const { body } = await session.testAgent.get(url);

    expect(body.statusCode).to.equal(404);
    expect(body.message).to.eql(
      `Layout not found for id ${nonExistingLayoutId} in the environment ${session.environment._id}`
    );
    expect(body.error).to.eql('Not Found');
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - BASE_PATH('/v1/layouts';

describe('Get a layout - /layouts/:layoutId (GET) #novu-v0', async ())
 - isDefault(false;
  let session: UserSession;
  let createdLayout: LayoutDto;

  before(async ())
 - createdLayout(await createLayout(session, layoutName, isDefault, layoutIdentifier);
  });

  it('should retrieve t...)
 - layout(getResponse.body.data;

    expect(layout._id).to.eql(createdLayout._id);
    expect(layout._environ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/e2e/set-default-layout.e2e.ts
Tamaño: 2896 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { LayoutDto } from '../dtos';
import { createLayout } from './helpers';

const BASE_PATH = '/v1/layouts';

describe('Set layout as default - /layouts/:layoutId/default (POST) #novu-v0', async () => {
  const layoutName = 'layout-name-set-default';
  const layoutIdentifier = 'layout-identifier-set-default';
  const isDefault = false;
  let session: UserSession;
  let createdLayout: LayoutDto;

  before(async () => {
    session = new UserSession();
    await session.initialize();
    createdLayout = await createLayout(session, layoutName, isDefault, layoutIdentifier);
  });

  it('should set the chosen layout as default', async () => {
    expect(createdLayout.isDefault).to.eql(false);

    const url = `${BASE_PATH}/${createdLayout._id}/default`;
    const updateResponse = await session.testAgent.post(url);
    expect(updateResponse.status).to.eql(204);

    const getUrl = `${BASE_PATH}/${createdLayout._id}`;
    const getResponse = await session.testAgent.get(getUrl);
    expect(getResponse.status).to.eql(200);
    expect(getResponse.body.data.isDefault).to.eql(true);
  });

  it('should set the chosen layout as default and the previous default layout is non default anymore', async () => {
    const secondLayoutName = 'layout-name-set-default-2';
    const secondLayoutIdentifier = 'layout-identifier-set-default-2';
    const secondLayout = await createLayout(session, secondLayoutName, false, secondLayoutIdentifier);
    expect(secondLayout.isDefault).to.eql(false);

    const firstLayoutUrl = `${BASE_PATH}/${createdLayout._id}`;
    const firstLayoutResponse = await session.testAgent.get(firstLayoutUrl);
    expect(firstLayoutResponse.body.data.isDefault).to.eql(true);

    const url = `${BASE_PATH}/${secondLayout._id}/default`;
    const updateResponse = await session.testAgent.post(url);
    expect(updateResponse.status).to.eql(204);

    const updatedFirstLayoutResponse = await session.testAgent.get(firstLayoutUrl);
    expect(updatedFirstLayoutResponse.body.data.isDefault).to.eql(false);

    const secondLayoutUrl = `${BASE_PATH}/${secondLayout._id}`;
    const updatedSecondLayoutResponse = await session.testAgent.get(secondLayoutUrl);
    expect(updatedSecondLayoutResponse.body.data.isDefault).to.eql(true);
  });

  it('should throw a not found error when the layout ID does not exist in the database when trying to set it as default', async () => {
    const nonExistingLayoutId = 'ab12345678901234567890ab';
    const url = `${BASE_PATH}/${nonExistingLayoutId}/default`;
    const { body } = await session.testAgent.post(url);

    expect(body.statusCode).to.equal(404);
    expect(body.message).to.eql(
      `Layout not found for id ${nonExistingLayoutId} in the environment ${session.environment._id}`
    );
    expect(body.error).to.eql('Not Found');
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - BASE_PATH('/v1/layouts';

describe('Set layout as default - /layouts/:layoutId/default (POST) #novu-v0', async...)
 - isDefault(false;
  let session: UserSession;
  let createdLayout: LayoutDto;

  before(async ())
 - createdLayout(await createLayout(session, layoutName, isDefault, layoutIdentifier);
  });

  it('should set the ch...)
 - getResponse(await session.testAgent.get(getUrl);
    expect(getResponse.status).to.eql(200);
    expect(getRespo...)
 - updatedSecondLayoutResponse(await session.testAgent.get(secondLayoutUrl);
    expect(updatedSecondLayoutResponse.body.data.isDef...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/e2e/update-layout.e2e.ts
Tamaño: 6731 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { LayoutDto } from '../dtos';
import { createLayout } from './helpers';

const BASE_PATH = '/v1/layouts';

describe('Layout update - /layouts (PATCH) #novu-v0', async () => {
  let session: UserSession;
  let createdLayout: LayoutDto;

  before(async () => {
    session = new UserSession();
    await session.initialize();
    createdLayout = await createLayout(session, 'layout-name-update', true, 'layout-identifier-update');
  });

  it('should throw validation error for empty payload when not sending a body', async () => {
    const url = `${BASE_PATH}/${createdLayout._id}`;

    const updateResponse = await session.testAgent.patch(url).send();

    const { body } = updateResponse;
    expect(body.statusCode).to.eql(400);
    expect(body.message).to.eql('Payload can not be empty');
  });

  it('should throw validation error for empty payload when sending a body of an empty object', async () => {
    const url = `${BASE_PATH}/${createdLayout._id}`;

    const updateResponse = await session.testAgent.patch(url).send({});

    const { body } = updateResponse;
    expect(body.statusCode).to.eql(400);
    expect(body.message).to.eql('Payload can not be empty');
  });

  it('should throw a not found error when the layout ID does not exist in the database when trying to update it', async () => {
    const nonExistingLayoutId = 'ab12345678901234567890ab';
    const updatedLayoutName = 'layout-name-update';
    const updatedLayoutIdentifier = 'layout-identifier-update';
    const updatedDescription = 'We thought it was more amazing than it is';
    const updatedContent = `{{{body}}}`;
    const updatedVariables = [];

    const url = `${BASE_PATH}/${nonExistingLayoutId}`;
    const { body } = await session.testAgent.patch(url).send({
      name: updatedLayoutName,
      identifier: updatedLayoutIdentifier,
      description: updatedDescription,
      content: updatedContent,
      variables: updatedVariables,
    });

    expect(body.statusCode).to.equal(404);
    expect(body.message).to.eql(
      `Layout not found for id ${nonExistingLayoutId} in the environment ${session.environment._id}`
    );
    expect(body.error).to.eql('Not Found');
  });

  it('should update a new layout successfully', async () => {
    const url = `${BASE_PATH}/${createdLayout._id}`;

    const updatedLayoutName = 'layout-name-update-1';
    const updatedLayoutIdentifier = 'layout-identifier-update-1';
    const updatedDescription = 'We thought it was more amazing than it is';
    const updatedContent = `{{{body}}}`;
    const updatedVariables = [];

    const updateResponse = await session.testAgent.patch(url).send({
      name: updatedLayoutName,
      identifier: updatedLayoutIdentifier,
      description: updatedDescription,
      content: updatedContent,
      variables: updatedVariables,
    });

    expect(updateResponse.statusCode).to.eql(200);

    const updatedBody = updateResponse.body.data;
    expect(updatedBody._id).to.eql(createdLayout._id);
    expect(updatedBody._environmentId).to.eql(session.environment._id);
    expect(updatedBody._organizationId).to.eql(session.organization._id);
    expect(updatedBody._creatorId).to.eql(session.user._id);
    expect(updatedBody.name).to.eql(updatedLayoutName);
    expect(updatedBody.identifier).to.eql(updatedLayoutIdentifier);
    expect(updatedBody.description).to.eql(updatedDescription);
    expect(updatedBody.content).to.eql(updatedContent);
    expect(updatedBody.variables).to.eql(updatedVariables);
    expect(updatedBody.contentType).to.eql('customHtml');
    expect(updatedBody.isDeleted).to.eql(false);
    expect(updatedBody.createdAt).to.be.ok;
    expect(updatedBody.updatedAt).to.be.ok;
  });

  it('should throw a conflict error when a default layout is updated to not be default', async () => {
    const url = `${BASE_PATH}/${createdLayout._id}`;

    const updatedIsDefault = false;

    const updateResponse = await session.testAgent.patch(url).send({
      isDefault: updatedIsDefault,
    });

    expect(updateResponse.body.error).to.eql('Conflict');
    expect(updateResponse.body.message).to.eql('One default layout is required');
    expect(updateResponse.body.statusCode).to.eql(409);
  });

  it('should throw error for an update of layout identifier that already exists in the environment', async () => {
    const updatedLayoutIdentifier = 'second-layout-identifier-update';

    await createLayout(session, 'second-layout-name-update', false, updatedLayoutIdentifier);
    const url = `${BASE_PATH}/${createdLayout._id}`;

    const updateResponse = await session.testAgent.patch(url).send({
      identifier: updatedLayoutIdentifier,
    });
    expect(updateResponse.body.message).to.eq(
      `Layout with identifier: ${updatedLayoutIdentifier} already exists under environment ${session.environment._id}`
    );
    expect(updateResponse.body.error).to.eq('Conflict');
    expect(updateResponse.body.statusCode).to.eq(409);
  });

  it('if the layout updated is assigned as default it should set as non default the existing default layout', async () => {
    const firstLayout = await createLayout(
      session,
      'layout-name-update-first-created',
      true,
      'layout-identifier-update-first-created'
    );
    const secondLayout = await createLayout(
      session,
      'layout-name-update-second-created',
      false,
      'layout-identifier-update-second-created'
    );

    const firstLayoutUrl = `${BASE_PATH}/${firstLayout._id}`;
    const firstLayoutResponse = await session.testAgent.get(firstLayoutUrl);
    expect(firstLayoutResponse.body.data._id).to.eql(firstLayout._id);
    expect(firstLayoutResponse.body.data.isDefault).to.eql(true);

    const secondLayoutUrl = `${BASE_PATH}/${secondLayout._id}`;
    const secondLayoutResponse = await session.testAgent.get(secondLayoutUrl);
    expect(secondLayoutResponse.body.data._id).to.eql(secondLayout._id);
    expect(secondLayoutResponse.body.data.isDefault).to.eql(false);

    // We proceed to set the second layout as default by update
    const updateResponse = await session.testAgent.patch(secondLayoutUrl).send({
      isDefault: true,
    });

    const firstLayoutNonDefaultResponse = await session.testAgent.get(firstLayoutUrl);
    expect(firstLayoutNonDefaultResponse.body.data._id).to.eql(firstLayout._id);
    expect(firstLayoutNonDefaultResponse.body.data.isDefault).to.eql(false);

    const secondLayoutDefaultResponse = await session.testAgent.get(secondLayoutUrl);
    expect(secondLayoutDefaultResponse.body.data._id).to.eql(secondLayout._id);
    expect(secondLayoutDefaultResponse.body.data.isDefault).to.eql(true);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - BASE_PATH('/v1/layouts';

describe('Layout update - /layouts (PATCH) #novu-v0', async ())
 - createdLayout(await createLayout(session, 'layout-name-update', true, 'layout-identifier-update');
  });

  it('sh...)
 - updatedBody(updateResponse.body.data;
    expect(updatedBody._id).to.eql(createdLayout._id);
    expect(updatedB...)
 - updateResponse(await session.testAgent.patch(url).send({
      isDefault: updatedIsDefault,
    });

    expect(upd...)
 - updateResponse(await session.testAgent.patch(url).send({
      identifier: updatedLayoutIdentifier,
    });
    exp...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/e2e/helpers/index.ts
Tamaño: 1213 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';

import { LayoutDto } from '../../dtos';
import { LayoutIdentifier, LayoutName, TemplateVariableTypeEnum } from '../../types';

const BASE_PATH = '/v1/layouts';

export const createLayout = async (
  session: UserSession,
  name: LayoutName,
  isDefault: boolean,
  identifier: LayoutIdentifier
): Promise<LayoutDto> => {
  const description = 'Amazing new layout';
  const content = '<html><body><div>Hello {{organizationName}} {{{body}}}</div></body></html>';
  const variables = [
    { name: 'organizationName', type: TemplateVariableTypeEnum.STRING, defaultValue: 'Company', required: false },
  ];
  const response = await session.testAgent.post(BASE_PATH).send({
    name,
    identifier,
    description,
    content,
    variables,
    isDefault,
  });

  expect(response.statusCode).to.eql(201);

  const { body } = response;
  const createdLayout = body.data;
  expect(createdLayout._id).to.exist;
  expect(createdLayout._id).to.be.string;

  const url = `${BASE_PATH}/${createdLayout._id}`;
  const getResponse = await session.testAgent.get(url);
  expect(getResponse.status).to.eql(200);

  return getResponse.body.data;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - createLayout(async (
  session: UserSession,
  name: LayoutName,
  isDefault: boolean,
  identifier: LayoutIdenti...)
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/types/index.ts
Tamaño: 531 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  ChannelTypeEnum,
  EnvironmentId,
  IEmailBlock,
  ITemplateVariable,
  LayoutDescription,
  LayoutId,
  LayoutIdentifier,
  LayoutName,
  OrderDirectionEnum,
  OrganizationId,
  TemplateVariableTypeEnum,
  UserId,
} from '@novu/shared';

export type LayoutVariables = ITemplateVariable[];

export {
  ChannelTypeEnum,
  EnvironmentId,
  IEmailBlock,
  ITemplateVariable,
  OrderDirectionEnum,
  OrganizationId,
  LayoutDescription,
  LayoutId,
  LayoutName,
  LayoutIdentifier,
  TemplateVariableTypeEnum,
  UserId,
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/usecases/index.ts
Tamaño: 1651 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { GetLayoutUseCase, GetNovuLayout } from '@novu/application-generic';
import { CheckLayoutIsUsedUseCase } from './check-layout-is-used/check-layout-is-used.use-case';
import { CreateDefaultLayout } from './create-default-layout/create-default-layout.usecase';
import { CreateDefaultLayoutChangeUseCase } from './create-default-layout-change/create-default-layout-change.usecase';
import { CreateLayoutUseCase } from './create-layout/create-layout.use-case';
import { CreateLayoutChangeUseCase } from './create-layout-change/create-layout-change.use-case';
import { DeleteLayoutUseCase } from './delete-layout/delete-layout.use-case';
import { FilterLayoutsUseCase } from './filter-layouts/filter-layouts.use-case';
import { FindDeletedLayoutUseCase } from './find-deleted-layout/find-deleted-layout.use-case';
import { SetDefaultLayoutUseCase } from './set-default-layout/set-default-layout.use-case';
import { UpdateLayoutUseCase } from './update-layout/update-layout.use-case';

export * from './check-layout-is-used';
export * from './create-default-layout';
export * from './create-layout';
export * from './create-layout-change';
export * from './delete-layout';
export * from './filter-layouts';
export * from './find-deleted-layout';
export * from './set-default-layout';
export * from './update-layout';

export const USE_CASES = [
  CreateDefaultLayoutChangeUseCase,
  CheckLayoutIsUsedUseCase,
  CreateDefaultLayout,
  CreateLayoutChangeUseCase,
  CreateLayoutUseCase,
  DeleteLayoutUseCase,
  FilterLayoutsUseCase,
  FindDeletedLayoutUseCase,
  GetLayoutUseCase,
  GetNovuLayout,
  SetDefaultLayoutUseCase,
  UpdateLayoutUseCase,
];


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export
- export
- export
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/usecases/check-layout-is-used/check-layout-is-used.command.ts
Tamaño: 295 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsString } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';
import { LayoutId } from '../../types';

export class CheckLayoutIsUsedCommand extends EnvironmentCommand {
  @IsString()
  @IsDefined()
  layoutId: LayoutId;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CheckLayoutIsUsedCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/usecases/check-layout-is-used/check-layout-is-used.use-case.ts
Tamaño: 919 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { LayoutEntity, LayoutRepository } from '@novu/dal';
import {
  FindMessageTemplatesByLayoutCommand,
  FindMessageTemplatesByLayoutUseCase,
} from '../../../message-template/usecases';
import { CheckLayoutIsUsedCommand } from './check-layout-is-used.command';

@Injectable()
export class CheckLayoutIsUsedUseCase {
  constructor(private findMessageTemplatesByLayout: FindMessageTemplatesByLayoutUseCase) {}

  async execute(command: CheckLayoutIsUsedCommand): Promise<boolean> {
    const findMessageTemplatesByLayoutCommand = FindMessageTemplatesByLayoutCommand.create({
      environmentId: command.environmentId,
      layoutId: command.layoutId,
      organizationId: command.organizationId,
    });

    const messageTemplates = await this.findMessageTemplatesByLayout.execute(findMessageTemplatesByLayoutCommand);

    return messageTemplates.length > 0;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CheckLayoutIsUsedUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/usecases/check-layout-is-used/index.ts
Tamaño: 97 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './check-layout-is-used.command';
export * from './check-layout-is-used.use-case';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/usecases/create-default-layout-change/create-default-layout-change.command.ts
Tamaño: 441 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsOptional, IsString } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';
import { LayoutId } from '../../types';

export class CreateDefaultLayoutChangeCommand extends EnvironmentWithUserCommand {
  @IsString()
  @IsDefined()
  layoutId: LayoutId;

  @IsString()
  @IsOptional()
  changeId?: string;

  @IsString()
  @IsOptional()
  parentChangeId?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateDefaultLayoutChangeCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/usecases/create-default-layout-change/create-default-layout-change.usecase.ts
Tamaño: 1919 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { CreateChange, CreateChangeCommand } from '@novu/application-generic';
import { ChangeRepository, LayoutEntity, LayoutRepository } from '@novu/dal';
import { ChangeEntityTypeEnum } from '@novu/shared';
import { LayoutDto } from '../../dtos';
import { FindDeletedLayoutCommand, FindDeletedLayoutUseCase } from '../find-deleted-layout';
import { CreateDefaultLayoutChangeCommand } from './create-default-layout-change.command';

type GetChangeId = {
  environmentId: string;
  layoutId: string;
};

@Injectable()
export class CreateDefaultLayoutChangeUseCase {
  constructor(
    private createChange: CreateChange,
    private findDeletedLayout: FindDeletedLayoutUseCase,
    private layoutRepository: LayoutRepository,
    private changeRepository: ChangeRepository
  ) {}

  async execute(command: CreateDefaultLayoutChangeCommand): Promise<void> {
    let item: LayoutEntity | LayoutDto | null = await this.layoutRepository.findOne({
      _id: command.layoutId,
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
    });

    const changeId = command.changeId || (await this.getChangeId(command));

    if (!item) {
      item = await this.findDeletedLayout.execute(FindDeletedLayoutCommand.create(command));
    }

    if (item) {
      await this.createChange.execute(
        CreateChangeCommand.create({
          organizationId: command.organizationId,
          environmentId: command.environmentId,
          userId: command.userId,
          type: ChangeEntityTypeEnum.DEFAULT_LAYOUT,
          parentChangeId: command.parentChangeId,
          changeId,
          item,
        })
      );
    }
  }

  private async getChangeId(command: GetChangeId) {
    return await this.changeRepository.getChangeId(
      command.environmentId,
      ChangeEntityTypeEnum.DEFAULT_LAYOUT,
      command.layoutId
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateDefaultLayoutChangeUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/usecases/create-default-layout/create-default-layout.command.ts
Tamaño: 166 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class CreateDefaultLayoutCommand extends EnvironmentWithUserCommand {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateDefaultLayoutCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/usecases/create-default-layout/create-default-layout.usecase.ts
Tamaño: 1190 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { GetNovuLayout } from '@novu/application-generic';
import { LayoutRepository } from '@novu/dal';
import { LayoutDto } from '../../dtos';
import { CreateLayoutCommand, CreateLayoutUseCase } from '../create-layout';
import { SetDefaultLayoutUseCase } from '../set-default-layout';
import { CreateDefaultLayoutCommand } from './create-default-layout.command';

@Injectable()
export class CreateDefaultLayout {
  constructor(
    private setDefaultLayout: SetDefaultLayoutUseCase,
    private layoutRepository: LayoutRepository,
    private createLayout: CreateLayoutUseCase,
    private getNovuLayout: GetNovuLayout
  ) {}

  async execute(command: CreateDefaultLayoutCommand): Promise<LayoutDto> {
    return await this.createLayout.execute(
      CreateLayoutCommand.create({
        userId: command.userId,
        name: 'Default Layout',
        isDefault: true,
        identifier: 'novu-default-layout',
        content: await this.getNovuLayout.execute({}),
        environmentId: command.environmentId,
        organizationId: command.organizationId,
        description: 'The default layout created by Novu',
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateDefaultLayout

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/usecases/create-default-layout/index.ts
Tamaño: 98 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './create-default-layout.command';
export * from './create-default-layout.usecase';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/usecases/create-layout-change/create-layout-change.command.ts
Tamaño: 335 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsBoolean, IsDefined, IsOptional, IsString } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';
import { LayoutId } from '../../types';

export class CreateLayoutChangeCommand extends EnvironmentWithUserCommand {
  @IsString()
  @IsDefined()
  layoutId: LayoutId;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateLayoutChangeCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/usecases/create-layout-change/create-layout-change.use-case.ts
Tamaño: 1619 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { CreateChange, CreateChangeCommand } from '@novu/application-generic';
import { ChangeRepository, LayoutRepository } from '@novu/dal';
import { ChangeEntityTypeEnum } from '@novu/shared';
import { FindDeletedLayoutCommand, FindDeletedLayoutUseCase } from '../find-deleted-layout';
import { CreateLayoutChangeCommand } from './create-layout-change.command';

@Injectable()
export class CreateLayoutChangeUseCase {
  constructor(
    private createChange: CreateChange,
    private findDeletedLayout: FindDeletedLayoutUseCase,
    private layoutRepository: LayoutRepository,
    private changeRepository: ChangeRepository
  ) {}

  async execute(command: CreateLayoutChangeCommand, isDeleteChange = false): Promise<void> {
    const item = isDeleteChange
      ? await this.findDeletedLayout.execute(FindDeletedLayoutCommand.create(command))
      : await this.layoutRepository.findOne({
          _id: command.layoutId,
          _environmentId: command.environmentId,
          _organizationId: command.organizationId,
        });

    if (item) {
      const parentChangeId: string = await this.changeRepository.getChangeId(
        command.environmentId,
        ChangeEntityTypeEnum.LAYOUT,
        command.layoutId
      );

      await this.createChange.execute(
        CreateChangeCommand.create({
          organizationId: command.organizationId,
          environmentId: command.environmentId,
          userId: command.userId,
          type: ChangeEntityTypeEnum.LAYOUT,
          item,
          changeId: parentChangeId,
        })
      );
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateLayoutChangeUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/usecases/create-layout-change/index.ts
Tamaño: 97 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './create-layout-change.command';
export * from './create-layout-change.use-case';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/usecases/create-layout/create-layout.command.ts
Tamaño: 892 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ResourceOriginEnum, ResourceTypeEnum } from '@novu/shared';
import { IsBoolean, IsDefined, IsEnum, IsOptional, IsString } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';
import { LayoutDescription, LayoutIdentifier, LayoutName, LayoutVariables } from '../../types';

export class CreateLayoutCommand extends EnvironmentWithUserCommand {
  @IsString()
  @IsDefined()
  name: LayoutName;

  @IsString()
  @IsDefined()
  identifier: LayoutIdentifier;

  @IsString()
  @IsOptional()
  description?: LayoutDescription;

  @IsString()
  @IsOptional()
  content?: string;

  @IsOptional()
  variables?: LayoutVariables;

  @IsBoolean()
  @IsOptional()
  isDefault?: boolean;

  @IsOptional()
  @IsEnum(ResourceTypeEnum)
  type?: ResourceTypeEnum;

  @IsOptional()
  @IsEnum(ResourceOriginEnum)
  origin?: ResourceOriginEnum;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateLayoutCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/usecases/create-layout/create-layout.use-case.ts
Tamaño: 5779 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, ConflictException, Injectable } from '@nestjs/common';
import {
  AnalyticsService,
  ContentService,
  layoutControlSchema,
  layoutUiSchema,
  ResourceValidatorService,
} from '@novu/application-generic';
import { ControlSchemas, LayoutEntity, LayoutRepository } from '@novu/dal';
import { isReservedVariableName, ResourceOriginEnum, ResourceTypeEnum } from '@novu/shared';
import { LayoutDto } from '../../dtos';
import { ChannelTypeEnum, ITemplateVariable, LayoutId } from '../../types';
import { CreateLayoutChangeCommand, CreateLayoutChangeUseCase } from '../create-layout-change';
import { SetDefaultLayoutCommand, SetDefaultLayoutUseCase } from '../set-default-layout';
import { CreateLayoutCommand } from './create-layout.command';

@Injectable()
export class CreateLayoutUseCase {
  constructor(
    private createLayoutChange: CreateLayoutChangeUseCase,
    private setDefaultLayout: SetDefaultLayoutUseCase,
    private layoutRepository: LayoutRepository,
    private analyticsService: AnalyticsService,
    private resourceValidatorService: ResourceValidatorService
  ) {}

  async execute(command: CreateLayoutCommand): Promise<LayoutDto & { _id: string }> {
    const isV2Layout =
      command.origin === ResourceOriginEnum.NOVU_CLOUD || command.origin === ResourceOriginEnum.EXTERNAL;
    await this.resourceValidatorService.validateLayoutsLimit(command.environmentId, isV2Layout);

    const variables = this.getExtractedVariables(command.variables as ITemplateVariable[], command.content ?? '');
    const hasBody = command.content?.includes('{{{body}}}');
    if (!hasBody && !isV2Layout) {
      throw new BadRequestException('Layout content must contain {{{body}}}');
    }
    const layoutIdentifierExist = await this.layoutRepository.findOne({
      _organizationId: command.organizationId,
      _environmentId: command.environmentId,
      identifier: command.identifier,
      ...(isV2Layout ? { type: command.type, origin: command.origin } : {}),
    });
    if (layoutIdentifierExist) {
      throw new ConflictException(
        `Layout with identifier: ${command.identifier} already exists under environment ${command.environmentId}`
      );
    }
    let entity = this.mapToEntity({ ...command, contentType: 'customHtml', variables });
    if (isV2Layout) {
      entity = this.mapToEntity({
        ...command,
        controls: { schema: layoutControlSchema, uiSchema: layoutUiSchema },
        contentType: undefined,
        type: command.type,
        origin: command.origin,
      });
    }

    const layout = await this.layoutRepository.createLayout(entity);
    const dto = this.mapFromEntity(layout);

    if (dto._id && dto.isDefault) {
      const setDefaultLayoutCommand = SetDefaultLayoutCommand.create({
        environmentId: dto._environmentId,
        layoutId: dto._id,
        organizationId: dto._organizationId,
        userId: dto._creatorId,
        type: dto.type,
        origin: dto.origin,
      });
      await this.setDefaultLayout.execute(setDefaultLayoutCommand);
    } else if (!isV2Layout) {
      await this.createChange(command, dto._id);
    }

    this.analyticsService.track('[Layout] - Create', command.userId, {
      _organizationId: command.organizationId,
      _environmentId: command.environmentId,
      layoutId: dto._id,
    });

    return dto;
  }

  private async createChange(command: CreateLayoutCommand, layoutId: LayoutId): Promise<void> {
    const createLayoutChangeCommand = CreateLayoutChangeCommand.create({
      environmentId: command.environmentId,
      layoutId,
      organizationId: command.organizationId,
      userId: command.userId,
    });

    await this.createLayoutChange.execute(createLayoutChangeCommand);
  }

  private mapToEntity(
    domainEntity: CreateLayoutCommand & { controls?: ControlSchemas; contentType?: 'customHtml' }
  ): Omit<LayoutEntity, '_id' | 'createdAt' | 'updatedAt'> {
    return {
      _environmentId: domainEntity.environmentId,
      _organizationId: domainEntity.organizationId,
      _creatorId: domainEntity.userId,
      channel: ChannelTypeEnum.EMAIL,
      content: domainEntity.content,
      contentType: domainEntity.contentType,
      description: domainEntity.description,
      name: domainEntity.name,
      identifier: domainEntity.identifier,
      variables: domainEntity.variables,
      isDefault: domainEntity.isDefault ?? false,
      type: domainEntity.type,
      origin: domainEntity.origin,
      deleted: false,
      controls: domainEntity.controls,
      _updatedBy: domainEntity.userId,
    };
  }

  private mapFromEntity(layout: LayoutEntity): LayoutDto & { _id: string } {
    return {
      ...layout,
      _id: layout._id,
      _organizationId: layout._organizationId,
      _environmentId: layout._environmentId,
      isDeleted: layout.deleted,
      controls: {
        uiSchema: layout.controls?.uiSchema,
        dataSchema: layout.controls?.schema,
      },
    };
  }

  private getExtractedVariables(variables: ITemplateVariable[], content: string): ITemplateVariable[] {
    const contentService = new ContentService();
    const extractedVariables = contentService
      .extractVariables(content)
      .filter((item) => !isReservedVariableName(item.name)) as ITemplateVariable[];

    if (!variables || variables.length === 0) {
      return extractedVariables;
    }

    return extractedVariables.map((variable) => {
      const { name, type, defaultValue, required } = variable;
      const variableFromRequest = variables.find((item) => item.name === name);

      return {
        name,
        type,
        defaultValue: variableFromRequest?.defaultValue ?? defaultValue,
        required: variableFromRequest?.required ?? required,
      };
    });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - extractedVariables(contentService
      .extractVariables(content)
      .filter((item))
 - variableFromRequest(variables.find((item))
Declaraciones 'export' encontradas:
- export class CreateLayoutUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/usecases/create-layout/index.ts
Tamaño: 83 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './create-layout.command';
export * from './create-layout.use-case';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/usecases/delete-layout/delete-layout.command.ts
Tamaño: 306 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsString } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';
import { LayoutId } from '../../types';

export class DeleteLayoutCommand extends EnvironmentWithUserCommand {
  @IsString()
  @IsDefined()
  layoutId: LayoutId;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DeleteLayoutCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/usecases/delete-layout/delete-layout.use-case.ts
Tamaño: 2707 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ConflictException, Injectable } from '@nestjs/common';
import { AnalyticsService, GetLayoutCommand, GetLayoutUseCase } from '@novu/application-generic';
import { LayoutRepository } from '@novu/dal';
import { ResourceOriginEnum } from '@novu/shared';
import { CheckLayoutIsUsedCommand, CheckLayoutIsUsedUseCase } from '../check-layout-is-used';
import { CreateLayoutChangeCommand, CreateLayoutChangeUseCase } from '../create-layout-change';
import { DeleteLayoutCommand } from './delete-layout.command';

@Injectable()
export class DeleteLayoutUseCase {
  constructor(
    private getLayoutUseCase: GetLayoutUseCase,
    private checkLayoutIsUsed: CheckLayoutIsUsedUseCase,
    private createLayoutChange: CreateLayoutChangeUseCase,
    private layoutRepository: LayoutRepository,
    private analyticsService: AnalyticsService
  ) {}

  async execute(command: DeleteLayoutCommand): Promise<void> {
    const getLayoutCommand = GetLayoutCommand.create({
      layoutIdOrInternalId: command.layoutId,
      environmentId: command.environmentId,
      organizationId: command.organizationId,
    });

    const layout = await this.getLayoutUseCase.execute(getLayoutCommand);

    const isUsed = await this.checkLayoutIsUsed.execute(
      CheckLayoutIsUsedCommand.create({
        environmentId: command.environmentId,
        layoutId: command.layoutId,
        organizationId: command.organizationId,
      })
    );

    if (isUsed) {
      throw new ConflictException(`Layout with id ${command.layoutId} is being used so it can not be deleted`);
    }

    if (layout.isDefault) {
      throw new ConflictException(
        `Layout with id ${command.layoutId} is being used as your default layout, so it can not be deleted`
      );
    }

    await this.layoutRepository.deleteLayout(command.layoutId, layout._environmentId, layout._organizationId);

    await this.createChange(command, layout.origin);

    this.analyticsService.track('[Layout] - Delete', command.userId, {
      _organizationId: command.organizationId,
      _environmentId: command.environmentId,
      layoutId: command.layoutId,
    });
  }

  private async createChange(command: DeleteLayoutCommand, origin?: ResourceOriginEnum): Promise<void> {
    if (origin === ResourceOriginEnum.NOVU_CLOUD || origin === ResourceOriginEnum.EXTERNAL) {
      return;
    }

    const createLayoutChangeCommand = CreateLayoutChangeCommand.create({
      environmentId: command.environmentId,
      layoutId: command.layoutId,
      organizationId: command.organizationId,
      userId: command.userId,
    });

    const isDeleteChange = true;
    await this.createLayoutChange.execute(createLayoutChangeCommand, isDeleteChange);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DeleteLayoutUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/usecases/delete-layout/index.ts
Tamaño: 83 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './delete-layout.command';
export * from './delete-layout.use-case';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/usecases/filter-layouts/filter-layouts.command.ts
Tamaño: 484 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsNumber, IsOptional, IsString } from 'class-validator';

import { EnvironmentCommand } from '../../../shared/commands/project.command';

import { OrderDirectionEnum } from '../../types';

export class FilterLayoutsCommand extends EnvironmentCommand {
  @IsNumber()
  @IsOptional()
  page?: number = 0;

  @IsNumber()
  @IsOptional()
  pageSize?: number = 10;

  @IsString()
  @IsOptional()
  sortBy?: string;

  @IsNumber()
  @IsOptional()
  orderBy?: OrderDirectionEnum;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class FilterLayoutsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/usecases/filter-layouts/filter-layouts.use-case.ts
Tamaño: 1947 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable } from '@nestjs/common';
import { LayoutEntity, LayoutRepository } from '@novu/dal';
import { LayoutDto } from '../../dtos/layout.dto';
import { FilterLayoutsCommand } from './filter-layouts.command';

const DEFAULT_LAYOUT_LIMIT = 10;
const MAX_LAYOUT_LIMIT = 1000;

@Injectable()
export class FilterLayoutsUseCase {
  constructor(private layoutRepository: LayoutRepository) {}

  async execute(command: FilterLayoutsCommand) {
    const { pageSize = DEFAULT_LAYOUT_LIMIT, page = 0 } = command;

    if (pageSize > MAX_LAYOUT_LIMIT) {
      throw new BadRequestException(`Page size can not be larger then ${MAX_LAYOUT_LIMIT}`);
    }

    const query = this.mapFromCommandToEntity(command);

    const totalCount = await this.layoutRepository.count(query);

    const skipTimes = page <= 0 ? 0 : page;
    const pagination = {
      limit: pageSize,
      skip: skipTimes * pageSize,
      ...(command.sortBy && { sortBy: command.sortBy }),
      ...(command.orderBy && { orderBy: command.orderBy }),
    };

    const filteredLayouts = await this.layoutRepository.filterLayouts(query, pagination);

    return {
      page,
      totalCount,
      pageSize,
      data: filteredLayouts.map(this.mapFromEntityToDto),
    };
  }

  private mapFromCommandToEntity(
    command: FilterLayoutsCommand
  ): Pick<LayoutEntity, '_environmentId' | '_organizationId'> {
    return {
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
    } as Pick<LayoutEntity, '_environmentId' | '_organizationId'>;
  }

  private mapFromEntityToDto(layout: LayoutEntity): LayoutDto {
    return {
      ...layout,
      _id: layout._id,
      _organizationId: layout._organizationId,
      _environmentId: layout._environmentId,
      isDeleted: layout.deleted,
      controls: {
        schema: layout.controls?.schema,
        uiSchema: layout.controls?.uiSchema,
      },
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class FilterLayoutsUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/usecases/filter-layouts/index.ts
Tamaño: 85 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './filter-layouts.command';
export * from './filter-layouts.use-case';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/usecases/find-deleted-layout/find-deleted-layout.command.ts
Tamaño: 311 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsString } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';
import { LayoutId } from '../../types';

export class FindDeletedLayoutCommand extends EnvironmentWithUserCommand {
  @IsString()
  @IsDefined()
  layoutId: LayoutId;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class FindDeletedLayoutCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/usecases/find-deleted-layout/find-deleted-layout.spec.ts
Tamaño: 3922 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Test } from '@nestjs/testing';
import { LayoutRepository } from '@novu/dal';
import { ApiServiceLevelEnum, TemplateVariableTypeEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { ChangeModule } from '../../../change/change.module';
import { MessageTemplateModule } from '../../../message-template/message-template.module';
import { SharedModule } from '../../../shared/shared.module';
import { LayoutsV1Module } from '../../layouts-v1.module';
import { CreateLayoutCommand, CreateLayoutUseCase } from '../create-layout';
import { DeleteLayoutCommand, DeleteLayoutUseCase } from '../delete-layout';
import { FindDeletedLayoutCommand } from './find-deleted-layout.command';
import { FindDeletedLayoutUseCase } from './find-deleted-layout.use-case';

describe('Find Deleted Layout Usecase', () => {
  let createLayoutUseCase: CreateLayoutUseCase;
  let deleteLayoutUseCase: DeleteLayoutUseCase;
  let findDeletedLayoutUseCase: FindDeletedLayoutUseCase;
  let session: UserSession;

  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [SharedModule, ChangeModule, MessageTemplateModule, LayoutsV1Module],
      providers: [],
    }).compile();

    session = new UserSession();
    await session.initialize();

    findDeletedLayoutUseCase = moduleRef.get<FindDeletedLayoutUseCase>(FindDeletedLayoutUseCase);
    createLayoutUseCase = moduleRef.get<CreateLayoutUseCase>(CreateLayoutUseCase);
    deleteLayoutUseCase = moduleRef.get<DeleteLayoutUseCase>(DeleteLayoutUseCase);
  });

  it('should throw an error if there is no deleted layout', async () => {
    const nonExistentLayoutId = LayoutRepository.createObjectId();

    const command = FindDeletedLayoutCommand.create({
      layoutId: nonExistentLayoutId,
      environmentId: session.environment._id,
      organizationId: session.organization._id,
      userId: session.user._id,
    });

    try {
      const result = await findDeletedLayoutUseCase.execute(command);
      expect(result).not.to.be.ok;
    } catch (error) {
      expect(error.response).to.eql({
        message: `Layout deleted not found for id ${nonExistentLayoutId} in the environment ${session.environment._id}`,
        error: 'Not Found',
        statusCode: 404,
      });
    }
  });

  it('should find the deleted layout', async () => {
    await session.updateOrganizationServiceLevel(ApiServiceLevelEnum.PRO);
    const environmentId = session.environment._id;
    const organizationId = session.organization._id;
    const userId = session.user._id;

    const name = 'find-deleted-layout-name';
    const identifier = 'find-deleted-layout-identifier';
    const description = 'Amazing new layout';
    const content = '<html><body><div>Hello {{organizationName}} {{{body}}}</div></body></html>';
    const variables = [
      { name: 'organizationName', type: TemplateVariableTypeEnum.STRING, defaultValue: 'Company', required: false },
    ];
    const isDefault = false;

    const createCommand = CreateLayoutCommand.create({
      content,
      identifier,
      description,
      environmentId,
      isDefault,
      name,
      organizationId,
      userId,
      variables,
    });
    const createdLayout = await createLayoutUseCase.execute(createCommand);

    const layoutId = createdLayout._id;

    const deleteCommand = DeleteLayoutCommand.create({
      layoutId,
      environmentId,
      organizationId,
      userId,
    });
    await deleteLayoutUseCase.execute(deleteCommand);

    const findDeletedLayoutCommand = FindDeletedLayoutCommand.create({
      layoutId,
      environmentId,
      organizationId,
      userId,
    });
    const foundDeletedLayout = await findDeletedLayoutUseCase.execute(findDeletedLayoutCommand);

    expect(foundDeletedLayout._id).to.eql(layoutId);
    expect(foundDeletedLayout.isDeleted).to.eql(true);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - deleteLayoutUseCase(moduleRef.get<DeleteLayoutUseCase>(DeleteLayoutUseCase);
  });

  it('should throw an error if there...)
 - result(await findDeletedLayoutUseCase.execute(command);
      expect(result).not.to.be.ok;
    } catch (err...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/usecases/find-deleted-layout/find-deleted-layout.use-case.ts
Tamaño: 1858 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { LayoutEntity, LayoutRepository } from '@novu/dal';
import { LayoutDto } from '../../dtos';
import { IEmailBlock, ITemplateVariable } from '../../types';
import { FindDeletedLayoutCommand } from './find-deleted-layout.command';

@Injectable()
export class FindDeletedLayoutUseCase {
  constructor(private layoutRepository: LayoutRepository) {}

  async execute(command: FindDeletedLayoutCommand): Promise<LayoutDto> {
    const layout = await this.layoutRepository.findDeleted(command.layoutId, command.environmentId);

    if (!layout) {
      throw new NotFoundException(
        `Layout deleted not found for id ${command.layoutId} in the environment ${command.environmentId}`
      );
    }

    return this.mapFromEntity(layout);
  }

  private mapFromEntity(layout: LayoutEntity): LayoutDto {
    return {
      ...layout,
      _id: layout._id,
      _organizationId: layout._organizationId,
      _environmentId: layout._environmentId,
      variables: this.mapVariablesFromEntity(layout.variables),
      isDeleted: layout.deleted,
      controls: {
        schema: layout.controls?.schema,
        uiSchema: layout.controls?.uiSchema,
      },
    };
  }

  private mapVariablesFromEntity(variables?: ITemplateVariable[]): ITemplateVariable[] {
    if (!variables || variables.length === 0) {
      return [];
    }

    return variables.map((variable) => {
      const { name, type, defaultValue, required } = variable;

      return {
        name,
        type,
        defaultValue,
        required,
      };
    });
  }

  private mapContentFromEntity(blocks: IEmailBlock[]): IEmailBlock[] {
    return blocks.map((block) => {
      const { content, type, url } = block;

      return {
        content,
        type,
        ...(url && { url }),
      };
    });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class FindDeletedLayoutUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/usecases/find-deleted-layout/index.ts
Tamaño: 95 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './find-deleted-layout.command';
export * from './find-deleted-layout.use-case';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/usecases/set-default-layout/index.ts
Tamaño: 93 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './set-default-layout.command';
export * from './set-default-layout.use-case';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/usecases/set-default-layout/set-default-layout.command.ts
Tamaño: 549 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ResourceOriginEnum, ResourceTypeEnum } from '@novu/shared';
import { IsDefined, IsEnum, IsOptional, IsString } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';
import { LayoutId } from '../../types';

export class SetDefaultLayoutCommand extends EnvironmentWithUserCommand {
  @IsString()
  @IsDefined()
  layoutId: LayoutId;

  @IsEnum(ResourceTypeEnum)
  @IsOptional()
  type?: ResourceTypeEnum;

  @IsEnum(ResourceOriginEnum)
  @IsOptional()
  origin?: ResourceOriginEnum;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SetDefaultLayoutCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/usecases/set-default-layout/set-default-layout.use-case.ts
Tamaño: 5086 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { AnalyticsService, GetLayoutUseCase, PinoLogger } from '@novu/application-generic';
import { ChangeRepository, LayoutRepository } from '@novu/dal';
import { ChangeEntityTypeEnum, ResourceOriginEnum, ResourceTypeEnum } from '@novu/shared';

import { EnvironmentId, LayoutId, OrganizationId } from '../../types';
import { CreateDefaultLayoutChangeCommand } from '../create-default-layout-change/create-default-layout-change.command';
import { CreateDefaultLayoutChangeUseCase } from '../create-default-layout-change/create-default-layout-change.usecase';
import { SetDefaultLayoutCommand } from './set-default-layout.command';

@Injectable()
export class SetDefaultLayoutUseCase {
  constructor(
    private getLayout: GetLayoutUseCase,
    private createDefaultLayoutChange: CreateDefaultLayoutChangeUseCase,
    private layoutRepository: LayoutRepository,
    private changeRepository: ChangeRepository,
    private analyticsService: AnalyticsService,
    private logger: PinoLogger
  ) {
    this.logger.setContext(this.constructor.name);
  }

  async execute(command: SetDefaultLayoutCommand) {
    const isV2Layout =
      command.origin === ResourceOriginEnum.NOVU_CLOUD || command.origin === ResourceOriginEnum.EXTERNAL;

    const layout = await this.getLayout.execute({
      layoutIdOrInternalId: command.layoutId,
      environmentId: command.environmentId,
      organizationId: command.organizationId,
      type: command.type,
      origin: command.origin,
    });

    const existingDefaultLayoutId = await this.findExistingDefaultLayoutId(layout._id as string, command, isV2Layout);

    if (!existingDefaultLayoutId) {
      await this.createDefaultChange(command, isV2Layout);

      return;
    }

    try {
      await this.setIsDefaultForLayout(existingDefaultLayoutId, command.environmentId, command.organizationId, false);

      if (!isV2Layout) {
        const existingParentChangeId = await this.getParentChangeId(command.environmentId, existingDefaultLayoutId);
        const previousDefaultLayoutChangeId = await this.changeRepository.getChangeId(
          command.environmentId,
          ChangeEntityTypeEnum.DEFAULT_LAYOUT,
          existingDefaultLayoutId
        );

        await this.createLayoutChangeForPreviousDefault(
          command,
          existingDefaultLayoutId,
          previousDefaultLayoutChangeId,
          isV2Layout
        );

        await this.setIsDefaultForLayout(layout._id as string, command.environmentId, command.organizationId, true);
        await this.createDefaultChange(
          {
            ...command,
            parentChangeId: existingParentChangeId || previousDefaultLayoutChangeId,
          },
          isV2Layout
        );
      }

      this.analyticsService.track('[Layout] - Set default layout', command.userId, {
        _organizationId: command.organizationId,
        _environmentId: command.environmentId,
        newDefaultLayoutId: layout._id,
        previousDefaultLayout: existingDefaultLayoutId,
      });
    } catch (error) {
      this.logger.error({ err: error });
      // TODO: Rollback through transactions
    }
  }

  private async createLayoutChangeForPreviousDefault(
    command: SetDefaultLayoutCommand,
    layoutId: LayoutId,
    changeId: string,
    isV2Layout: boolean
  ) {
    await this.createDefaultChange({ ...command, layoutId, changeId }, isV2Layout);
  }

  private async findExistingDefaultLayoutId(
    layoutId: LayoutId,
    command: SetDefaultLayoutCommand,
    isV2Layout: boolean
  ): Promise<LayoutId | undefined> {
    const defaultLayout = await this.layoutRepository.findOne({
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
      isDefault: true,
      ...(isV2Layout ? { type: command.type, origin: command.origin } : {}),
      _id: { $ne: layoutId },
    });

    if (!defaultLayout) {
      return undefined;
    }

    return defaultLayout._id;
  }

  private async setIsDefaultForLayout(
    layoutId: LayoutId,
    environmentId: EnvironmentId,
    organizationId: OrganizationId,
    isDefault: boolean
  ): Promise<void> {
    await this.layoutRepository.updateIsDefault(layoutId, environmentId, organizationId, isDefault);
  }

  private async createDefaultChange(command: CreateDefaultLayoutChangeCommand, isV2Layout: boolean) {
    if (isV2Layout) {
      return;
    }

    const createLayoutChangeCommand = CreateDefaultLayoutChangeCommand.create({
      environmentId: command.environmentId,
      layoutId: command.layoutId,
      organizationId: command.organizationId,
      userId: command.userId,
      changeId: command.changeId,
      parentChangeId: command.parentChangeId,
    });

    await this.createDefaultLayoutChange.execute(createLayoutChangeCommand);
  }

  private async getParentChangeId(environmentId: string, layoutId: string) {
    const parentChangeId = await this.changeRepository.getParentId(
      environmentId,
      ChangeEntityTypeEnum.DEFAULT_LAYOUT,
      layoutId
    );

    return parentChangeId;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SetDefaultLayoutUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/usecases/update-layout/index.ts
Tamaño: 83 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './update-layout.command';
export * from './update-layout.use-case';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/usecases/update-layout/update-layout.command.ts
Tamaño: 944 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ResourceOriginEnum, ResourceTypeEnum } from '@novu/shared';
import { IsBoolean, IsDefined, IsEnum, IsOptional, IsString } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';
import { LayoutDescription, LayoutId, LayoutIdentifier, LayoutName, LayoutVariables } from '../../types';

export class UpdateLayoutCommand extends EnvironmentWithUserCommand {
  @IsString()
  @IsDefined()
  layoutId: LayoutId;

  @IsString()
  @IsOptional()
  name?: LayoutName;

  @IsString()
  @IsOptional()
  identifier?: LayoutIdentifier;

  @IsString()
  @IsOptional()
  description?: LayoutDescription;

  @IsOptional()
  content?: string;

  @IsOptional()
  variables?: LayoutVariables;

  @IsBoolean()
  @IsOptional()
  isDefault?: boolean;

  @IsOptional()
  @IsEnum(ResourceTypeEnum)
  type?: ResourceTypeEnum;

  @IsOptional()
  @IsEnum(ResourceOriginEnum)
  origin?: ResourceOriginEnum;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateLayoutCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v1/usecases/update-layout/update-layout.use-case.ts
Tamaño: 5320 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, ConflictException, Injectable } from '@nestjs/common';
import { AnalyticsService, GetLayoutCommand, GetLayoutUseCase, layoutControlSchema } from '@novu/application-generic';
import { LayoutEntity, LayoutRepository } from '@novu/dal';
import { ResourceOriginEnum } from '@novu/shared';
import { LayoutDto } from '../../dtos/layout.dto';
import { CreateLayoutChangeCommand, CreateLayoutChangeUseCase } from '../create-layout-change';
import { SetDefaultLayoutCommand, SetDefaultLayoutUseCase } from '../set-default-layout';
import { UpdateLayoutCommand } from './update-layout.command';

@Injectable()
export class UpdateLayoutUseCase {
  constructor(
    private getLayoutUseCase: GetLayoutUseCase,
    private createLayoutChange: CreateLayoutChangeUseCase,
    private setDefaultLayout: SetDefaultLayoutUseCase,
    private layoutRepository: LayoutRepository,
    private analyticsService: AnalyticsService
  ) {}

  async execute(command: UpdateLayoutCommand): Promise<LayoutDto> {
    const isV2Layout =
      command.origin === ResourceOriginEnum.NOVU_CLOUD || command.origin === ResourceOriginEnum.EXTERNAL;
    const getLayoutCommand = GetLayoutCommand.create({
      layoutIdOrInternalId: command.layoutId,
      environmentId: command.environmentId,
      organizationId: command.organizationId,
      type: command.type,
      origin: command.origin,
    });
    const databaseEntity = await this.getLayoutUseCase.execute(getLayoutCommand);

    const identifierHasChanged = command.identifier && command.identifier !== databaseEntity.identifier;
    if (identifierHasChanged) {
      const existingLayoutWithIdentifier = await this.layoutRepository.findOne({
        _organizationId: command.organizationId,
        _environmentId: command.environmentId,
        identifier: command.identifier,
      });

      if (existingLayoutWithIdentifier) {
        throw new ConflictException(
          `Layout with identifier: ${command.identifier} already exists under environment ${command.environmentId}`
        );
      }
    }

    if (typeof command.isDefault === 'boolean' && !command.isDefault && databaseEntity.isDefault) {
      throw new ConflictException(`One default layout is required`);
    }

    const patchedEntity = this.applyUpdatesToEntity(this.mapToEntity(databaseEntity), command);
    const hasBody = patchedEntity.content?.includes('{{{body}}}');
    if (!hasBody && !isV2Layout) {
      throw new BadRequestException('Layout content must contain {{{body}}}');
    }

    const updatedEntity = await this.layoutRepository.updateLayout(patchedEntity);

    const dto = this.mapFromEntity(updatedEntity);

    if (dto._id && dto.isDefault === true) {
      const setDefaultLayoutCommand = SetDefaultLayoutCommand.create({
        environmentId: dto._environmentId,
        layoutId: dto._id,
        organizationId: dto._organizationId,
        userId: dto._creatorId,
        type: dto.type,
        origin: dto.origin,
      });
      await this.setDefaultLayout.execute(setDefaultLayoutCommand);
    } else {
      await this.createChange(command, isV2Layout);
    }

    this.analyticsService.track('[Layout] - Update', command.userId, {
      _organizationId: command.organizationId,
      _environmentId: command.environmentId,
      layoutId: dto._id,
    });

    return dto;
  }

  private async createChange(command: UpdateLayoutCommand, isV2Layout: boolean): Promise<void> {
    if (isV2Layout) {
      return;
    }

    const createLayoutChangeCommand = CreateLayoutChangeCommand.create({
      environmentId: command.environmentId,
      layoutId: command.layoutId,
      organizationId: command.organizationId,
      userId: command.userId,
    });

    await this.createLayoutChange.execute(createLayoutChangeCommand);
  }

  private applyUpdatesToEntity(layout: LayoutEntity, updates: UpdateLayoutCommand): LayoutEntity {
    return {
      ...layout,
      ...(updates.name && { name: updates.name }),
      ...(updates.identifier && { identifier: updates.identifier }),
      ...(updates.description && { description: updates.description }),
      ...(updates.content && { content: updates.content }),
      ...(updates.variables && { variables: updates.variables }),
      ...(typeof updates.isDefault === 'boolean' && { isDefault: updates.isDefault }),
      _updatedBy: updates.userId,
    };
  }

  private mapFromEntity(layout: LayoutEntity): LayoutDto {
    return {
      ...layout,
      _id: layout._id,
      _organizationId: layout._organizationId,
      _environmentId: layout._environmentId,
      isDeleted: layout.deleted,
      controls: {
        dataSchema: layout.controls?.schema,
        uiSchema: layout.controls?.uiSchema,
      },
      isTranslationEnabled: layout.isTranslationEnabled,
    };
  }

  private mapToEntity(layout: LayoutDto): LayoutEntity {
    return {
      ...layout,
      _id: layout._id as string,
      _organizationId: layout._organizationId,
      _environmentId: layout._environmentId,
      contentType: layout.contentType ? 'customHtml' : undefined,
      deleted: layout.isDeleted,
      controls: {
        schema: layout.controls?.dataSchema ?? layoutControlSchema,
        uiSchema: layout.controls?.uiSchema,
      },
      isTranslationEnabled: layout.isTranslationEnabled,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateLayoutUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/layouts.controller.ts
Tamaño: 9343 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ClassSerializerInterceptor, HttpStatus } from '@nestjs/common';
import {
  Body,
  Controller,
  Delete,
  Get,
  HttpCode,
  Param,
  Post,
  Put,
  Query,
  UseInterceptors,
} from '@nestjs/common/decorators';
import { ApiBody, ApiOperation, ApiParam, ApiTags } from '@nestjs/swagger';
import {
  ExternalApiAccessible,
  ParseSlugEnvironmentIdPipe,
  ParseSlugIdPipe,
  RequirePermissions,
  UserSession,
} from '@novu/application-generic';
import { ApiRateLimitCategoryEnum, DirectionEnum, PermissionsEnum, UserSessionData } from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { ThrottlerCategory } from '../rate-limiting/guards/throttler.decorator';
import { ApiCommonResponses, ApiResponse } from '../shared/framework/response.decorator';
import { SdkMethodName } from '../shared/framework/swagger/sdk.decorators';
import {
  CreateLayoutDto,
  DuplicateLayoutDto,
  GetLayoutListQueryParamsDto,
  GetLayoutUsageResponseDto,
  LayoutResponseDto,
  ListLayoutResponseDto,
  UpdateLayoutDto,
} from './dtos';
import { GenerateLayoutPreviewResponseDto } from './dtos/generate-layout-preview-response.dto';
import { LayoutPreviewRequestDto } from './dtos/layout-preview-request.dto';
import { DeleteLayoutCommand, DeleteLayoutUseCase } from './usecases/delete-layout';
import { DuplicateLayoutCommand, DuplicateLayoutUseCase } from './usecases/duplicate-layout';
import { GetLayoutCommand, GetLayoutUseCase } from './usecases/get-layout';
import { GetLayoutUsageCommand, GetLayoutUsageUseCase } from './usecases/get-layout-usage';
import { ListLayoutsCommand, ListLayoutsUseCase } from './usecases/list-layouts';
import { PreviewLayoutCommand, PreviewLayoutUsecase } from './usecases/preview-layout';
import { UpsertLayout, UpsertLayoutCommand } from './usecases/upsert-layout';
import { EMPTY_LAYOUT } from './utils/layout-templates';

@ThrottlerCategory(ApiRateLimitCategoryEnum.CONFIGURATION)
@ApiCommonResponses()
@Controller({ path: `/layouts`, version: '2' })
@UseInterceptors(ClassSerializerInterceptor)
@RequireAuthentication()
@ApiTags('Layouts')
export class LayoutsController {
  constructor(
    private upsertLayoutUseCase: UpsertLayout,
    private getLayoutUseCase: GetLayoutUseCase,
    private deleteLayoutUseCase: DeleteLayoutUseCase,
    private duplicateLayoutUseCase: DuplicateLayoutUseCase,
    private listLayoutsUseCase: ListLayoutsUseCase,
    private previewLayoutUsecase: PreviewLayoutUsecase,
    private getLayoutUsageUseCase: GetLayoutUsageUseCase
  ) {}

  @Post('')
  @ApiOperation({
    summary: 'Create a layout',
    description: 'Creates a new layout in the Novu Cloud environment',
  })
  @ExternalApiAccessible()
  @ApiBody({ type: CreateLayoutDto, description: 'Layout creation details' })
  @ApiResponse(LayoutResponseDto, 201)
  @RequirePermissions(PermissionsEnum.WORKFLOW_WRITE)
  async create(
    @UserSession(ParseSlugEnvironmentIdPipe) user: UserSessionData,
    @Body() createLayoutDto: CreateLayoutDto
  ): Promise<LayoutResponseDto> {
    return this.upsertLayoutUseCase.execute(
      UpsertLayoutCommand.create({
        layoutDto: {
          ...createLayoutDto,
          controlValues: {
            email: {
              body: JSON.stringify(EMPTY_LAYOUT),
              editorType: 'block',
            },
          },
        },
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
      })
    );
  }

  @Put(':layoutId')
  @ExternalApiAccessible()
  @ApiOperation({
    summary: 'Update a layout',
    description: 'Updates the details of an existing layout, here **layoutId** is the identifier of the layout',
  })
  @ApiBody({ type: UpdateLayoutDto, description: 'Layout update details' })
  @ApiResponse(LayoutResponseDto)
  @RequirePermissions(PermissionsEnum.WORKFLOW_WRITE)
  async update(
    @UserSession(ParseSlugEnvironmentIdPipe) user: UserSessionData,
    @Param('layoutId', ParseSlugIdPipe) layoutIdOrInternalId: string,
    @Body() updateLayoutDto: UpdateLayoutDto
  ): Promise<LayoutResponseDto> {
    return this.upsertLayoutUseCase.execute(
      UpsertLayoutCommand.create({
        layoutDto: {
          ...updateLayoutDto,
        },
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
        layoutIdOrInternalId,
      })
    );
  }

  @Get(':layoutId')
  @ExternalApiAccessible()
  @ApiOperation({
    summary: 'Retrieve a layout',
    description: 'Fetches details of a specific layout by its unique identifier **layoutId**',
  })
  @ApiResponse(LayoutResponseDto)
  @RequirePermissions(PermissionsEnum.WORKFLOW_READ)
  async get(
    @UserSession(ParseSlugEnvironmentIdPipe) user: UserSessionData,
    @Param('layoutId', ParseSlugIdPipe) layoutIdOrInternalId: string
  ): Promise<LayoutResponseDto> {
    return this.getLayoutUseCase.execute(
      GetLayoutCommand.create({
        layoutIdOrInternalId,
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
      })
    );
  }

  @Delete(':layoutId')
  @ExternalApiAccessible()
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({
    summary: 'Delete a layout',
    description: 'Removes a specific layout by its unique identifier **layoutId**',
  })
  @ApiParam({ name: 'layoutId', description: 'The unique identifier of the layout', type: String })
  @RequirePermissions(PermissionsEnum.WORKFLOW_WRITE)
  async delete(
    @UserSession(ParseSlugEnvironmentIdPipe) user: UserSessionData,
    @Param('layoutId', ParseSlugIdPipe) layoutIdOrInternalId: string
  ) {
    await this.deleteLayoutUseCase.execute(
      DeleteLayoutCommand.create({
        layoutIdOrInternalId,
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
      })
    );
  }

  @Post(':layoutId/duplicate')
  @ExternalApiAccessible()
  @ApiOperation({
    summary: 'Duplicate a layout',
    description:
      'Duplicates a layout by its unique identifier **layoutId**. This will create a new layout with the content of the original layout.',
  })
  @ApiBody({ type: DuplicateLayoutDto })
  @ApiResponse(LayoutResponseDto, 201)
  @RequirePermissions(PermissionsEnum.WORKFLOW_WRITE)
  @SdkMethodName('duplicate')
  async duplicate(
    @UserSession(ParseSlugEnvironmentIdPipe) user: UserSessionData,
    @Param('layoutId', ParseSlugIdPipe) layoutIdOrInternalId: string,
    @Body() duplicateLayoutDto: DuplicateLayoutDto
  ): Promise<LayoutResponseDto> {
    return this.duplicateLayoutUseCase.execute(
      DuplicateLayoutCommand.create({
        layoutIdOrInternalId,
        overrides: duplicateLayoutDto,
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
      })
    );
  }

  @Get('')
  @ExternalApiAccessible()
  @ApiOperation({
    summary: 'List all layouts',
    description: 'Retrieves a list of layouts with optional filtering and pagination',
  })
  @ApiResponse(ListLayoutResponseDto)
  @RequirePermissions(PermissionsEnum.WORKFLOW_READ)
  async list(
    @UserSession(ParseSlugEnvironmentIdPipe) user: UserSessionData,
    @Query() query: GetLayoutListQueryParamsDto
  ): Promise<ListLayoutResponseDto> {
    return this.listLayoutsUseCase.execute(
      ListLayoutsCommand.create({
        offset: Number(query.offset || '0'),
        limit: Number(query.limit || '50'),
        orderDirection: query.orderDirection ?? DirectionEnum.DESC,
        orderBy: query.orderBy ?? 'createdAt',
        searchQuery: query.query,
        user,
      })
    );
  }

  @Post(':layoutId/preview')
  @ExternalApiAccessible()
  @ApiOperation({
    summary: 'Generate layout preview',
    description: 'Generates a preview for a layout by its unique identifier **layoutId**',
  })
  @ApiBody({ type: LayoutPreviewRequestDto, description: 'Layout preview generation details' })
  @ApiResponse(GenerateLayoutPreviewResponseDto, 201)
  @RequirePermissions(PermissionsEnum.WORKFLOW_READ)
  @SdkMethodName('generatePreview')
  async generatePreview(
    @UserSession(ParseSlugEnvironmentIdPipe) user: UserSessionData,
    @Param('layoutId', ParseSlugIdPipe) layoutIdOrInternalId: string,
    @Body() layoutPreviewRequestDto: LayoutPreviewRequestDto
  ): Promise<GenerateLayoutPreviewResponseDto> {
    return await this.previewLayoutUsecase.execute(
      PreviewLayoutCommand.create({
        user,
        layoutIdOrInternalId,
        layoutPreviewRequestDto,
      })
    );
  }

  @Get(':layoutId/usage')
  @ExternalApiAccessible()
  @ApiOperation({
    summary: 'Get layout usage',
    description:
      'Retrieves information about workflows that use the specified layout by its unique identifier **layoutId**',
  })
  @ApiResponse(GetLayoutUsageResponseDto)
  @RequirePermissions(PermissionsEnum.WORKFLOW_READ)
  @SdkMethodName('usage')
  async getUsage(
    @UserSession(ParseSlugEnvironmentIdPipe) user: UserSessionData,
    @Param('layoutId', ParseSlugIdPipe) layoutIdOrInternalId: string
  ): Promise<GetLayoutUsageResponseDto> {
    return this.getLayoutUsageUseCase.execute(
      GetLayoutUsageCommand.create({
        layoutIdOrInternalId,
        environmentId: user.environmentId,
        organizationId: user.organizationId,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class LayoutsController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/layouts.module.ts
Tamaño: 1643 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Module } from '@nestjs/common';
import { GetWorkflowByIdsUseCase, UpsertControlValuesUseCase } from '@novu/application-generic';
import { AuthModule } from '../auth/auth.module';
import { PreviewStep } from '../bridge/usecases/preview-step';
import { LayoutsV1Module } from '../layouts-v1/layouts-v1.module';
import { ControlValueSanitizerService } from '../shared/services/control-value-sanitizer.service';
import { SharedModule } from '../shared/shared.module';
import { CreateVariablesObject } from '../shared/usecases/create-variables-object/create-variables-object.usecase';
import { BuildStepDataUsecase, BuildVariableSchemaUsecase } from '../workflows-v2/usecases';
import { MockDataGeneratorService } from '../workflows-v2/usecases/preview/services/mock-data-generator.service';
import { PayloadMergerService } from '../workflows-v2/usecases/preview/services/payload-merger.service';
import { PreviewPayloadProcessorService } from '../workflows-v2/usecases/preview/services/preview-payload-processor.service';
import { LayoutsController } from './layouts.controller';
import { USE_CASES } from './usecases';

const MODULES = [SharedModule, AuthModule, LayoutsV1Module];

@Module({
  imports: MODULES,
  providers: [
    ...USE_CASES,
    UpsertControlValuesUseCase,
    CreateVariablesObject,
    ControlValueSanitizerService,
    PreviewPayloadProcessorService,
    MockDataGeneratorService,
    GetWorkflowByIdsUseCase,
    BuildVariableSchemaUsecase,
    BuildStepDataUsecase,
    PayloadMergerService,
    PreviewStep,
  ],
  exports: [...USE_CASES],
  controllers: [LayoutsController],
})
export class LayoutsV2Module {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class LayoutsV2Module

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/dtos/create-layout.dto.ts
Tamaño: 929 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IsBoolean, IsEnum, IsOptional, IsString } from 'class-validator';
import { LayoutCreationSourceEnum } from '../types';

export class CreateLayoutDto {
  @ApiProperty({ description: 'Unique identifier for the layout' })
  @IsString()
  layoutId: string;

  @ApiProperty({ description: 'Name of the layout' })
  @IsString()
  name: string;

  @ApiPropertyOptional({
    description: 'Enable or disable translations for this layout',
    required: false,
    default: false,
  })
  @IsOptional()
  @IsBoolean()
  isTranslationEnabled?: boolean;

  @ApiProperty({
    description: 'Source of layout creation',
    enum: LayoutCreationSourceEnum,
    enumName: 'LayoutCreationSourceEnum',
    required: false,
    default: LayoutCreationSourceEnum.DASHBOARD,
  })
  @IsOptional()
  @IsEnum(LayoutCreationSourceEnum)
  __source?: LayoutCreationSourceEnum;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateLayoutDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/dtos/duplicate-layout.dto.ts
Tamaño: 434 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IsOptional, IsString } from 'class-validator';

export class DuplicateLayoutDto {
  @ApiProperty({ description: 'Name of the layout' })
  @IsString()
  name: string;

  @ApiPropertyOptional({
    description: 'Enable or disable translations for this layout',
    required: false,
    default: false,
  })
  @IsOptional()
  isTranslationEnabled?: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DuplicateLayoutDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/dtos/generate-layout-preview-response.dto.ts
Tamaño: 1362 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiExtraModels, ApiProperty, ApiPropertyOptional, getSchemaPath } from '@nestjs/swagger';
import { ChannelTypeEnum } from '@novu/shared';
import { Type } from 'class-transformer';
import { IsOptional, IsString, ValidateNested } from 'class-validator';

import { LayoutPreviewPayloadDto } from './layout-preview-payload.dto';

export class EmailLayoutRenderOutput {
  @ApiProperty({ description: 'Content of the email' })
  @IsString()
  body: string;
}

@ApiExtraModels(EmailLayoutRenderOutput)
export class GenerateLayoutPreviewResponseDto {
  @ApiProperty({
    description: 'Preview payload example',
    type: () => LayoutPreviewPayloadDto,
  })
  @ValidateNested()
  @Type(() => LayoutPreviewPayloadDto)
  previewPayloadExample: LayoutPreviewPayloadDto;

  @ApiPropertyOptional({
    description: 'The payload schema that was used to generate the preview payload example',
    type: 'object',
    nullable: true,
    additionalProperties: true,
  })
  @IsOptional()
  schema?: any | null;

  @ApiProperty({
    description: 'Preview result',
    type: 'object',
    oneOf: [
      {
        properties: {
          type: { enum: [ChannelTypeEnum.EMAIL] },
          preview: { $ref: getSchemaPath(EmailLayoutRenderOutput) },
        },
      },
    ],
  })
  result: {
    type: ChannelTypeEnum.EMAIL;
    preview?: EmailLayoutRenderOutput;
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class EmailLayoutRenderOutput
- export class GenerateLayoutPreviewResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/dtos/get-layout-list-query-params.dto.ts
Tamaño: 583 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional } from '@nestjs/swagger';
import { IsOptional, IsString } from 'class-validator';
import { LimitOffsetPaginationQueryDto } from '../../shared/dtos/limit-offset-pagination.dto';
import { LayoutResponseDto } from './layout-response.dto';

export class GetLayoutListQueryParamsDto extends LimitOffsetPaginationQueryDto(LayoutResponseDto, [
  'createdAt',
  'updatedAt',
  'name',
]) {
  @ApiPropertyOptional({
    description: 'Search query to filter layouts',
    type: 'string',
    required: false,
  })
  @IsOptional()
  @IsString()
  query?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetLayoutListQueryParamsDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/dtos/get-layout-usage-response.dto.ts
Tamaño: 514 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';

export class WorkflowInfoDto {
  @ApiProperty({
    description: 'The name of the workflow',
    example: 'Welcome Email',
  })
  name: string;

  @ApiProperty({
    description: 'The unique identifier of the workflow',
    example: 'welcome-email',
  })
  workflowId: string;
}

export class GetLayoutUsageResponseDto {
  @ApiProperty({
    description: 'Array of workflows that use this layout',
    type: [WorkflowInfoDto],
  })
  workflows: WorkflowInfoDto[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class WorkflowInfoDto
- export class GetLayoutUsageResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/dtos/index.ts
Tamaño: 298 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './create-layout.dto';
export * from './duplicate-layout.dto';
export * from './get-layout-list-query-params.dto';
export * from './get-layout-usage-response.dto';
export * from './layout-response.dto';
export * from './list-layout-response.dto';
export * from './update-layout.dto';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export
- export
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/dtos/layout-controls.dto.ts
Tamaño: 597 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IsEnum, IsOptional, IsString, ValidateNested } from 'class-validator';

export class EmailControlsDto {
  @ApiProperty({
    description: 'Body of the layout.',
  })
  @IsString()
  body: string;

  @ApiProperty({
    description: 'Editor type of the layout.',
    enum: ['html', 'block'],
  })
  @IsString()
  @IsEnum(['html', 'block'])
  editorType: 'html' | 'block';
}

export class LayoutControlValuesDto {
  @ApiProperty({
    description: 'Email layout controls',
  })
  @IsOptional()
  @ValidateNested()
  email?: EmailControlsDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class EmailControlsDto
- export class LayoutControlValuesDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/dtos/layout-preview-payload.dto.ts
Tamaño: 522 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { IsOptional, ValidateNested } from 'class-validator';
import { SubscriberResponseDtoOptional } from '../../subscribers/dtos';

export class LayoutPreviewPayloadDto {
  @ApiPropertyOptional({
    description: 'Partial subscriber information',
    type: SubscriberResponseDtoOptional,
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => SubscriberResponseDtoOptional)
  subscriber?: SubscriberResponseDtoOptional;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class LayoutPreviewPayloadDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/dtos/layout-preview-request.dto.ts
Tamaño: 713 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { IsObject, IsOptional } from 'class-validator';

import { LayoutPreviewPayloadDto } from './layout-preview-payload.dto';

export class LayoutPreviewRequestDto {
  @ApiPropertyOptional({
    description: 'Optional control values for layout preview',
    type: 'object',
    additionalProperties: true,
  })
  @IsOptional()
  @IsObject()
  controlValues?: Record<string, unknown>;

  @ApiPropertyOptional({
    description: 'Optional payload for layout preview',
    type: () => LayoutPreviewPayloadDto,
  })
  @IsOptional()
  @Type(() => LayoutPreviewPayloadDto)
  previewPayload?: LayoutPreviewPayloadDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class LayoutPreviewRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/dtos/layout-response.dto.ts
Tamaño: 2766 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { ResourceOriginEnum, ResourceTypeEnum, Slug } from '@novu/shared';
import { Type } from 'class-transformer';
import { IsBoolean, IsEnum, IsOptional, IsString, ValidateNested } from 'class-validator';
import { ControlsMetadataDto } from '../../workflows-v2/dtos/controls-metadata.dto';
import { UserResponseDto } from '../../workflows-v2/dtos/user-response.dto';
import { CreateLayoutDto } from './create-layout.dto';
import { LayoutControlValuesDto } from './layout-controls.dto';
import { UpdateLayoutDto } from './update-layout.dto';

export type LayoutCreateAndUpdateKeys = keyof CreateLayoutDto | keyof UpdateLayoutDto;

class LayoutControlsDto extends ControlsMetadataDto {
  @ApiProperty({ description: 'Email layout controls' })
  @IsOptional()
  values?: LayoutControlValuesDto;
}

export class LayoutResponseDto {
  @ApiProperty({ description: 'Unique internal identifier of the layout' })
  @IsString()
  _id: string;

  @ApiProperty({ description: 'Unique identifier for the layout' })
  @IsString()
  layoutId: string;

  @ApiProperty({ description: 'Slug of the layout', type: 'string' })
  @IsString()
  slug: Slug;

  @ApiProperty({ description: 'Name of the layout' })
  @IsString()
  name: string;

  @ApiProperty({ description: 'Whether the layout is the default layout' })
  @IsBoolean()
  isDefault: boolean;

  @ApiProperty({
    description: 'Whether the layout translations are enabled',
  })
  @IsBoolean()
  isTranslationEnabled: boolean;

  @ApiProperty({ description: 'Last updated timestamp' })
  @IsString()
  updatedAt: string;

  @ApiPropertyOptional({
    description: 'User who last updated the layout',
    type: () => UserResponseDto,
    nullable: true,
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => UserResponseDto)
  updatedBy?: UserResponseDto;

  @ApiProperty({ description: 'Creation timestamp' })
  @IsString()
  createdAt: string;

  @ApiProperty({
    description: 'Origin of the layout',
    enum: [...Object.values(ResourceOriginEnum)],
    enumName: 'ResourceOriginEnum',
  })
  @IsEnum(ResourceOriginEnum)
  origin: ResourceOriginEnum;

  @ApiProperty({
    description: 'Type of the layout',
    enum: [...Object.values(ResourceTypeEnum)],
    enumName: 'ResourceTypeEnum',
  })
  @IsEnum(ResourceTypeEnum)
  type: ResourceTypeEnum;

  @ApiPropertyOptional({
    description: 'The variables JSON Schema for the layout',
    type: 'object',
    nullable: true,
    additionalProperties: true,
  })
  @IsOptional()
  variables?: object;

  @ApiProperty({
    description: 'Controls metadata for the layout',
    type: () => LayoutControlsDto,
    required: true,
  })
  @Type(() => LayoutControlsDto)
  controls: LayoutControlsDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - LayoutCreateAndUpdateKeys(keyof CreateLayoutDto | keyof UpdateLayoutDto;

class LayoutControlsDto extends ControlsMetadataDto ...)
Declaraciones 'export' encontradas:
- export  type
- export class LayoutResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/dtos/list-layout-response.dto.ts
Tamaño: 598 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { IsArray, IsNumber, ValidateNested } from 'class-validator';
import { LayoutResponseDto } from './layout-response.dto';

export class ListLayoutResponseDto {
  @ApiProperty({
    description: 'List of layouts',
    type: LayoutResponseDto,
    isArray: true,
  })
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => LayoutResponseDto)
  layouts: LayoutResponseDto[];

  @ApiProperty({
    description: 'Total number of layouts',
    type: 'number',
  })
  @IsNumber()
  totalCount: number;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ListLayoutResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/dtos/update-layout.dto.ts
Tamaño: 798 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { IsBoolean, IsOptional, IsString, ValidateNested } from 'class-validator';
import { LayoutControlValuesDto } from './layout-controls.dto';

export class UpdateLayoutDto {
  @ApiProperty({ description: 'Name of the layout' })
  @IsString()
  name: string;

  @ApiPropertyOptional({
    description: 'Enable or disable translations for this layout',
    required: false,
    default: false,
  })
  @IsOptional()
  @IsBoolean()
  isTranslationEnabled?: boolean;

  @ApiProperty({ type: LayoutControlValuesDto, description: 'Control values for the layout' })
  @IsOptional()
  @ValidateNested()
  @Type(() => LayoutControlValuesDto)
  controlValues?: LayoutControlValuesDto | null;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateLayoutDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/e2e/preview-layout.e2e.ts
Tamaño: 23512 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { EnvironmentRepository, LayoutRepository } from '@novu/dal';
import { ApiServiceLevelEnum, ChannelTypeEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

import { initNovuClassSdkInternalAuth } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';
import { CreateLayoutDto } from '../dtos';
import { LayoutCreationSourceEnum } from '../types';

describe('Preview Layout #novu-v2', () => {
  let session: UserSession;
  let novuClient: Novu;
  let layoutRepository: LayoutRepository;
  let environmentRepository: EnvironmentRepository;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    novuClient = initNovuClassSdkInternalAuth(session);
    await session.updateOrganizationServiceLevel(ApiServiceLevelEnum.PRO);
    layoutRepository = new LayoutRepository();
    environmentRepository = new EnvironmentRepository();

    await environmentRepository.updateOne(
      {
        _id: session.environment._id,
      },
      {
        bridge: { url: `http://localhost:${process.env.PORT}/v1/environments/${session.environment._id}/bridge` },
      }
    );
  });

  describe('Layout Preview - POST /v2/layouts/:layoutId/preview', () => {
    let htmlLayout: any;
    let blockLayout: any;

    beforeEach(async () => {
      // Create HTML layout for testing
      const htmlLayoutData: CreateLayoutDto = {
        layoutId: 'html-layout-preview-test',
        name: 'HTML Layout Preview Test',
        __source: LayoutCreationSourceEnum.DASHBOARD,
      };

      const { result: createdHtmlLayout } = await novuClient.layouts.create(htmlLayoutData);
      htmlLayout = createdHtmlLayout;

      // Update HTML layout with valid content
      await novuClient.layouts.update(
        {
          name: 'HTML Layout Preview Test',
          controlValues: {
            email: {
              body: `
                <html>
                  <head><title>Test HTML Layout</title></head>
                  <body>
                    <div style="font-family: Arial, sans-serif;">
                      <h1>Welcome {{subscriber.firstName}}!</h1>
                      <div class="content">
                        {{content}}
                      </div>
                      <footer>
                        <p>Best regards, The Team</p>
                      </footer>
                    </div>
                  </body>
                </html>
              `,
              editorType: 'html',
            },
          },
        },
        htmlLayout.layoutId
      );

      // Create Block layout for testing
      const blockLayoutData: CreateLayoutDto = {
        layoutId: 'block-layout-preview-test',
        name: 'Block Layout Preview Test',
        __source: LayoutCreationSourceEnum.DASHBOARD,
      };

      const { result: createdBlockLayout } = await novuClient.layouts.create(blockLayoutData);
      blockLayout = createdBlockLayout;

      // Update Block layout with valid Maily JSON content
      const validMailyContent = JSON.stringify({
        type: 'doc',
        content: [
          {
            type: 'heading',
            attrs: { level: 1, textAlign: null, showIfKey: null },
            content: [
              { type: 'text', text: 'Welcome ' },
              {
                type: 'variable',
                attrs: { id: 'subscriber.firstName', fallback: 'there' },
              },
              { type: 'text', text: '!' },
            ],
          },
          {
            type: 'paragraph',
            attrs: { textAlign: null, showIfKey: null },
            content: [
              {
                type: 'variable',
                attrs: { id: 'content' },
              },
            ],
          },
          {
            type: 'paragraph',
            attrs: { textAlign: null, showIfKey: null },
            content: [{ type: 'text', text: 'Best regards, The Team' }],
          },
        ],
      });

      await novuClient.layouts.update(
        {
          name: 'Block Layout Preview Test',
          controlValues: {
            email: {
              body: validMailyContent,
              editorType: 'block',
            },
          },
        },
        blockLayout.layoutId
      );
    });

    it('should successfully preview HTML layout with default values', async () => {
      const previewRequest = {};

      const { result } = await novuClient.layouts.generatePreview(previewRequest, htmlLayout.layoutId);

      expect(result).to.exist;
      expect(result.result.type).to.equal(ChannelTypeEnum.EMAIL);
      expect(result.result.preview).to.exist;
      expect(result.result.preview?.body).to.be.a('string');
      expect(result.result.preview?.body).to.contain('<html>');
      expect(result.previewPayloadExample).to.exist;
      expect(result.previewPayloadExample).to.be.an('object');
    });

    it('should successfully preview Block layout with default values', async () => {
      const previewRequest = {};

      const { result } = await novuClient.layouts.generatePreview(previewRequest, blockLayout.layoutId);

      expect(result).to.exist;
      expect(result.result.type).to.equal(ChannelTypeEnum.EMAIL);
      expect(result.result.preview).to.exist;
      expect(result.result.preview?.body).to.be.a('string');
      expect(result.previewPayloadExample).to.exist;
      expect(result.previewPayloadExample).to.be.an('object');
    });

    it('should preview HTML layout with custom control values', async () => {
      const customHtmlContent = `
        <html>
          <head><title>Custom Preview</title></head>
          <body>
            <div style="background-color: #f0f0f0; padding: 20px;">
              <h2>Custom HTML Content</h2>
              <p>Hello {{subscriber.firstName}} {{subscriber.lastName}}!</p>
              <div>{{content}}</div>
              <p>Custom footer message</p>
            </div>
          </body>
        </html>
      `;

      const previewRequest = {
        controlValues: {
          email: {
            body: customHtmlContent,
            editorType: 'html',
          },
        },
      };

      const { result } = await novuClient.layouts.generatePreview(previewRequest, htmlLayout.layoutId);

      expect(result.result.preview?.body).to.contain('Custom HTML Content');
      expect(result.result.preview?.body).to.contain('background-color: #f0f0f0');
      expect(result.result.preview?.body).to.contain('<html>');
    });

    it('should preview Block layout with custom control values', async () => {
      const customBlockContent = JSON.stringify({
        type: 'doc',
        content: [
          {
            type: 'heading',
            attrs: { level: 2, textAlign: 'center', showIfKey: null },
            content: [{ type: 'text', text: 'Custom Block Layout Preview' }],
          },
          {
            type: 'paragraph',
            attrs: { textAlign: null, showIfKey: null },
            content: [
              { type: 'text', text: 'Hello ' },
              {
                type: 'variable',
                attrs: { id: 'subscriber.firstName', fallback: 'User' },
              },
              { type: 'text', text: '!' },
            ],
          },
          {
            type: 'paragraph',
            attrs: { textAlign: null, showIfKey: null },
            content: [
              {
                type: 'variable',
                attrs: { id: 'content' },
              },
            ],
          },
        ],
      });

      const previewRequest = {
        controlValues: {
          email: {
            body: customBlockContent,
            editorType: 'block',
          },
        },
      };

      const { result } = await novuClient.layouts.generatePreview(previewRequest, blockLayout.layoutId);

      expect(result.result.preview?.body).to.be.a('string');
      expect(result.result.type).to.equal(ChannelTypeEnum.EMAIL);
    });

    it('should preview with custom payload example', async () => {
      const previewRequest = {
        previewPayload: {
          subscriber: {
            avatar: 'https://example.com/avatar.png',
            data: {},
            firstName: 'John',
            lastName: 'Doe',
            email: 'john.doe@example.com',
            locale: 'en_US',
            phone: '+1234567890',
            timezone: 'America/New_York',
          },
        },
      };

      const { result } = await novuClient.layouts.generatePreview(previewRequest, htmlLayout.layoutId);

      expect(result.result.preview?.body).to.exist;
      expect(result.previewPayloadExample).to.deep.include(previewRequest.previewPayload);
    });

    it('should preview with both custom control values and payload', async () => {
      const customHtmlContent = `
        <html>
          <body>
            <h1>Hello {{subscriber.firstName}} {{subscriber.lastName}}!</h1>
            <p>Email: {{subscriber.email}}</p>
            <div class="main-content">{{content}}</div>
          </body>
        </html>
      `;

      const previewRequest = {
        controlValues: {
          email: {
            body: customHtmlContent,
            editorType: 'html',
          },
        },
        previewPayload: {
          subscriber: {
            avatar: 'https://example.com/avatar.png',
            data: {},
            firstName: 'Jane',
            lastName: 'Smith',
            email: 'jane.smith@example.com',
            locale: 'en_US',
            phone: '+1234567890',
            timezone: 'America/New_York',
          },
        },
      };

      const { result } = await novuClient.layouts.generatePreview(previewRequest, htmlLayout.layoutId);

      expect(result.result.preview?.body).to.contain('<h1>');
      expect(result.result.preview?.body).to.contain('main-content');
      expect(result.previewPayloadExample.subscriber).to.deep.equal(previewRequest.previewPayload.subscriber);
    });

    it('should handle empty control values gracefully', async () => {
      const previewRequest = {
        controlValues: {},
      };

      const { result } = await novuClient.layouts.generatePreview(previewRequest, htmlLayout.layoutId);

      expect(result).to.exist;
      expect(result.result.type).to.equal(ChannelTypeEnum.EMAIL);
      expect(result.previewPayloadExample).to.exist;
    });

    it('should handle missing previewPayload gracefully', async () => {
      const previewRequest = {
        controlValues: {
          email: {
            body: '<html><body><h1>Test</h1>{{content}}</body></html>',
            editorType: 'html',
          },
        },
      };

      const { result } = await novuClient.layouts.generatePreview(previewRequest, htmlLayout.layoutId);

      expect(result).to.exist;
      expect(result.result.type).to.equal(ChannelTypeEnum.EMAIL);
      expect(result.result.preview?.body).to.contain('<h1>Test</h1>');
    });

    it('should handle completely empty request', async () => {
      const previewRequest = {};

      const { result } = await novuClient.layouts.generatePreview(previewRequest, htmlLayout.layoutId);

      expect(result).to.exist;
      expect(result.result.type).to.equal(ChannelTypeEnum.EMAIL);
      expect(result.previewPayloadExample).to.exist;
    });

    describe('Error Handling', () => {
      it('should return 404 when previewing non-existent layout', async () => {
        const previewRequest = {
          controlValues: {
            email: {
              body: '<html><body>{{content}}</body></html>',
              editorType: 'html',
            },
          },
        };

        try {
          await novuClient.layouts.generatePreview(previewRequest, 'non-existent-layout-id');
          expect.fail('Should have thrown 404 error');
        } catch (error: any) {
          expect(error.statusCode).to.equal(404);
        }
      });

      it('should handle invalid HTML content gracefully', async () => {
        const previewRequest = {
          controlValues: {
            email: {
              body: 'Invalid HTML without content variable',
              editorType: 'html',
            },
          },
        };

        // The preview should still work but may not render optimally
        const { result } = await novuClient.layouts.generatePreview(previewRequest, htmlLayout.layoutId);

        expect(result).to.exist;
        expect(result.result.type).to.equal(ChannelTypeEnum.EMAIL);
      });

      it('should handle invalid JSON content gracefully', async () => {
        const previewRequest = {
          controlValues: {
            email: {
              body: 'Invalid JSON content',
              editorType: 'block',
            },
          },
        };

        // The preview should still work but may not render optimally
        const { result } = await novuClient.layouts.generatePreview(previewRequest, blockLayout.layoutId);

        expect(result).to.exist;
        expect(result.result.type).to.equal(ChannelTypeEnum.EMAIL);
      });

      it('should handle malformed subscriber payload gracefully', async () => {
        const previewRequest = {
          previewPayload: {
            subscriber: {
              firstName: 'Alice',
              lastName: 'Johnson',
              email: 'alice@example.com',
              accountType: 'Premium',
            },
          },
        };

        const { result } = await novuClient.layouts.generatePreview(previewRequest, htmlLayout.layoutId);

        expect(result).to.exist;
        expect(result.result.type).to.equal(ChannelTypeEnum.EMAIL);
      });
    });

    describe('Editor Type Specific Tests', () => {
      it('should properly render HTML with complex structure', async () => {
        const complexHtmlContent = `
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Complex HTML Layout</title>
            <style>
              body { font-family: Arial, sans-serif; margin: 0; padding: 20px; }
              .header { background-color: #007bff; color: white; padding: 20px; text-align: center; }
              .content { margin: 20px 0; padding: 20px; border: 1px solid #ddd; }
              .footer { background-color: #f8f9fa; padding: 10px; text-align: center; }
            </style>
          </head>
          <body>
            <div class="header">
              <h1>Welcome {{subscriber.firstName}}!</h1>
            </div>
            <div class="content">
              {{content}}
            </div>
            <div class="footer">
              <p>Thank you for using our service!</p>
            </div>
          </body>
          </html>
        `;

        const previewRequest = {
          controlValues: {
            email: {
              body: complexHtmlContent,
              editorType: 'html',
            },
          },
          previewPayload: {
            subscriber: {
              firstName: 'Alice',
            },
          },
        };

        const { result } = await novuClient.layouts.generatePreview(previewRequest, htmlLayout.layoutId);

        expect(result.result.preview?.body).to.contain('class="header"');
        expect(result.result.preview?.body).to.contain('Welcome Alice!');
        expect(result.result.preview?.body).to.contain('class="content"');
        expect(result.result.preview?.body).to.contain('class="footer"');
      });

      it('should properly render Block content with various node types', async () => {
        const complexBlockContent = JSON.stringify({
          type: 'doc',
          content: [
            {
              type: 'heading',
              attrs: { level: 1, textAlign: 'center', showIfKey: null },
              content: [
                { type: 'text', text: 'Welcome ' },
                {
                  type: 'variable',
                  attrs: { id: 'subscriber.firstName', fallback: 'User' },
                },
              ],
            },
            {
              type: 'paragraph',
              attrs: { textAlign: null, showIfKey: null },
              content: [
                { type: 'text', text: 'This is a ' },
                { type: 'text', marks: [{ type: 'bold' }], text: 'bold' },
                { type: 'text', text: ' and ' },
                { type: 'text', marks: [{ type: 'italic' }], text: 'italic' },
                { type: 'text', text: ' text example.' },
              ],
            },
            {
              type: 'bulletList',
              content: [
                {
                  type: 'listItem',
                  content: [
                    {
                      type: 'paragraph',
                      attrs: { textAlign: null, showIfKey: null },
                      content: [{ type: 'text', text: 'First item' }],
                    },
                  ],
                },
                {
                  type: 'listItem',
                  content: [
                    {
                      type: 'paragraph',
                      attrs: { textAlign: null, showIfKey: null },
                      content: [{ type: 'text', text: 'Second item' }],
                    },
                  ],
                },
              ],
            },
            {
              type: 'paragraph',
              attrs: { textAlign: null, showIfKey: null },
              content: [
                {
                  type: 'variable',
                  attrs: { id: 'content' },
                },
              ],
            },
          ],
        });

        const previewRequest = {
          controlValues: {
            email: {
              body: complexBlockContent,
              editorType: 'block',
            },
          },
        };

        const { result } = await novuClient.layouts.generatePreview(previewRequest, blockLayout.layoutId);

        expect(result.result.preview?.body).to.be.a('string');
        expect(result.result.type).to.equal(ChannelTypeEnum.EMAIL);
      });

      it('should handle mixed variable types in HTML', async () => {
        const htmlWithVariables = `
          <html>
            <body>
              <h1>Hello {{subscriber.firstName}} {{subscriber.lastName}}!</h1>
              <p>Your email: {{subscriber.email}}</p>
              <p>Account type: {{subscriber.accountType}}</p>
              <div>
                {{content}}
              </div>
              <p>Date: {{currentDate}}</p>
            </body>
          </html>
        `;

        const previewRequest = {
          controlValues: {
            email: {
              body: htmlWithVariables,
              editorType: 'html',
            },
          },
          previewPayload: {
            subscriber: {
              firstName: 'Alice',
              lastName: 'Johnson',
              email: 'alice@example.com',
              accountType: 'Premium',
            },
          },
        };

        const { result } = await novuClient.layouts.generatePreview(previewRequest, htmlLayout.layoutId);

        expect(result.result.preview?.body).to.contain('<h1>');
        expect(result.result.preview?.body).to.contain('<p>');
        expect(result.previewPayloadExample?.subscriber?.firstName).to.equal('Alice');
      });

      it('should handle conditional content in Block editor', async () => {
        const conditionalBlockContent = JSON.stringify({
          type: 'doc',
          content: [
            {
              type: 'paragraph',
              attrs: { textAlign: null, showIfKey: 'subscriber.isPremium' },
              content: [
                { type: 'text', text: 'Premium content: ' },
                {
                  type: 'variable',
                  attrs: { id: 'premiumMessage', fallback: 'Premium features available' },
                },
              ],
            },
            {
              type: 'paragraph',
              attrs: { textAlign: null, showIfKey: null },
              content: [
                {
                  type: 'variable',
                  attrs: { id: 'content' },
                },
              ],
            },
          ],
        });

        const previewRequest = {
          controlValues: {
            email: {
              body: conditionalBlockContent,
              editorType: 'block',
            },
          },
        };

        const { result } = await novuClient.layouts.generatePreview(previewRequest, blockLayout.layoutId);

        expect(result.result.preview?.body).to.be.a('string');
        expect(result.result.type).to.equal(ChannelTypeEnum.EMAIL);
      });
    });

    describe('Performance and Edge Cases', () => {
      it('should handle very large HTML content', async () => {
        const largeHtmlContent = `
          <html>
            <body>
              ${'<p>Large content block</p>'.repeat(100)}
              {{content}}
              ${'<div>More content</div>'.repeat(50)}
            </body>
          </html>
        `;

        const previewRequest = {
          controlValues: {
            email: {
              body: largeHtmlContent,
              editorType: 'html',
            },
          },
        };

        const { result } = await novuClient.layouts.generatePreview(previewRequest, htmlLayout.layoutId);

        expect(result.result.preview?.body).to.be.a('string');
        expect(result.result.preview?.body.length).to.be.greaterThan(1000);
      });

      it('should handle very large Block content', async () => {
        const paragraphs = Array.from({ length: 50 }, (_, i) => ({
          type: 'paragraph',
          attrs: { textAlign: null, showIfKey: null },
          content: [{ type: 'text', text: `Paragraph ${i + 1} with some content.` }],
        }));

        const largeBlockContent = JSON.stringify({
          type: 'doc',
          content: [
            ...paragraphs,
            {
              type: 'paragraph',
              attrs: { textAlign: null, showIfKey: null },
              content: [
                {
                  type: 'variable',
                  attrs: { id: 'content' },
                },
              ],
            },
          ],
        });

        const previewRequest = {
          controlValues: {
            email: {
              body: largeBlockContent,
              editorType: 'block',
            },
          },
        };

        const { result } = await novuClient.layouts.generatePreview(previewRequest, blockLayout.layoutId);

        expect(result.result.preview?.body).to.be.a('string');
        expect(result.result.type).to.equal(ChannelTypeEnum.EMAIL);
      });

      it('should handle special characters in content', async () => {
        const htmlWithSpecialChars = `
          <html>
            <body>
              <h1>Special Characters: &amp; &lt; &gt; &quot; &#39;</h1>
              <p>Unicode: 🎉 ✨ 🚀 emojis and accents</p>
              {{content}}
            </body>
          </html>
        `;

        const previewRequest = {
          controlValues: {
            email: {
              body: htmlWithSpecialChars,
              editorType: 'html',
            },
          },
        };

        const { result } = await novuClient.layouts.generatePreview(previewRequest, htmlLayout.layoutId);

        expect(result.result.preview?.body).to.contain('&amp;');
        expect(result.result.preview?.body).to.contain('🎉');
      });
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - environmentRepository(new EnvironmentRepository();

    await environmentRepository.updateOne(
      {
        _id: sessio...)
 - validMailyContent(JSON.stringify({
        type: 'doc',
        content: [
          {
            type: 'heading',
  ...)
 - previewRequest({
          controlValues: {
            email: {
              body: '<html><body>{{content}}</body...)
 - class("footer"');
      });

      it('should properly render Block content with various node types', asyn...)
 - paragraphs(Array.from({ length: 50 }, (_, i))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/e2e/upsert-layout.e2e.ts
Tamaño: 12720 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { LayoutsControllerCreateResponse } from '@novu/api/models/operations';
import { layoutControlSchema, layoutUiSchema } from '@novu/application-generic';
import { LayoutRepository } from '@novu/dal';
import { ApiServiceLevelEnum, FeatureNameEnum, getFeatureForTierAsNumber } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { expectSdkExceptionGeneric, initNovuClassSdkInternalAuth } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';
import { CreateLayoutDto, UpdateLayoutDto } from '../dtos';
import { LayoutCreationSourceEnum } from '../types';
import { EMPTY_LAYOUT } from '../utils/layout-templates';

describe('Upsert Layout #novu-v2', () => {
  let session: UserSession;
  let novuClient: Novu;
  let layoutRepository: LayoutRepository;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    novuClient = initNovuClassSdkInternalAuth(session);
    layoutRepository = new LayoutRepository();
  });

  describe('Create Layout - POST /v2/layouts', () => {
    it('should not allow to create more than 1 layout for a free tier organization', async () => {
      await session.updateOrganizationServiceLevel(ApiServiceLevelEnum.FREE);
      const layoutData: CreateLayoutDto = {
        layoutId: `test-layout-creation`,
        name: 'Test Layout Creation',
        __source: LayoutCreationSourceEnum.DASHBOARD,
      };

      await novuClient.layouts.create(layoutData);

      const res = await expectSdkExceptionGeneric(() => novuClient.layouts.create(layoutData));
      expect(res.error?.statusCode).eq(400);
    });

    it('should allow to create 2 and more layouts for a pro+ tier organization', async () => {
      await session.updateOrganizationServiceLevel(ApiServiceLevelEnum.PRO);
      const layoutData1: CreateLayoutDto = {
        layoutId: `test-layout-creation1`,
        name: 'Test Layout Creation1',
        __source: LayoutCreationSourceEnum.DASHBOARD,
      };
      const layoutData2: CreateLayoutDto = {
        layoutId: `test-layout-creation2`,
        name: 'Test Layout Creation2',
        __source: LayoutCreationSourceEnum.DASHBOARD,
      };
      const layoutData3: CreateLayoutDto = {
        layoutId: `test-layout-creation3`,
        name: 'Test Layout Creation3',
        __source: LayoutCreationSourceEnum.DASHBOARD,
      };

      await novuClient.layouts.create(layoutData1);
      await novuClient.layouts.create(layoutData2);
      const res = await novuClient.layouts.create(layoutData3);
      expect(res.result).to.exist;
    });

    it('should create a new layout successfully', async () => {
      const layoutData: CreateLayoutDto = {
        layoutId: `test-layout-creation`,
        name: 'Test Layout Creation',
        __source: LayoutCreationSourceEnum.DASHBOARD,
      };

      const { result: createdLayout } = await novuClient.layouts.create(layoutData);

      expect(createdLayout).to.exist;
      expect(createdLayout.layoutId).to.equal(layoutData.layoutId);
      expect(createdLayout.name).to.equal(layoutData.name);
      expect(createdLayout.isDefault).to.be.true;
      expect(createdLayout.id).to.be.a('string');
      expect(createdLayout.createdAt).to.be.a('string');
      expect(createdLayout.updatedAt).to.be.a('string');
      expect(createdLayout.controls.values).to.deep.equal({
        email: {
          body: JSON.stringify(EMPTY_LAYOUT),
          editorType: 'block',
        },
      });
      expect(createdLayout.controls.uiSchema).to.deep.equal(layoutUiSchema);
      expect(createdLayout.controls.dataSchema).to.deep.equal(layoutControlSchema);
      expect(createdLayout.variables).to.exist;
      expect(createdLayout.variables).to.be.an('object');
    });

    it('should create first layout as default and not set the second layout', async () => {
      await session.updateOrganizationServiceLevel(ApiServiceLevelEnum.PRO);

      await layoutRepository.delete({
        _organizationId: session.organization._id,
        _environmentId: session.environment._id,
        isDefault: true,
      });

      const layoutData: CreateLayoutDto = {
        layoutId: `first-layout`,
        name: 'First Layout',
        __source: LayoutCreationSourceEnum.DASHBOARD,
      };

      const { result: createdLayout } = await novuClient.layouts.create(layoutData);

      expect(createdLayout.isDefault).to.be.true;

      const layoutData2: CreateLayoutDto = {
        layoutId: `second-layout`,
        name: 'Second Layout',
        __source: LayoutCreationSourceEnum.DASHBOARD,
      };

      const { result: createdLayout2 } = await novuClient.layouts.create(layoutData2);

      expect(createdLayout2.isDefault).to.be.false;
    });
  });

  describe('Update Layout - PUT /v2/layouts/:layoutId', () => {
    let existingLayout: LayoutsControllerCreateResponse['result'];

    beforeEach(async () => {
      const createData: CreateLayoutDto = {
        layoutId: `existing-layout`,
        name: 'Existing Layout',
        __source: LayoutCreationSourceEnum.DASHBOARD,
      };

      const { result } = await novuClient.layouts.create(createData);
      existingLayout = result;
    });

    it('should update an existing layout successfully', async () => {
      const updateData: UpdateLayoutDto = {
        name: 'Updated Layout Name',
        controlValues: {
          email: {
            body: '<html><body><div>{{content}}</div></body></html>',
            editorType: 'html',
          },
        },
      };

      const { result: updatedLayout } = await novuClient.layouts.update(updateData, existingLayout.layoutId);

      expect(updatedLayout.id).to.equal(existingLayout.id);
      expect(updatedLayout.layoutId).to.equal(existingLayout.layoutId);
      expect(updatedLayout.name).to.equal(updateData.name);
      expect(updatedLayout.controls.values.email?.body).to.contain(updateData.controlValues?.email?.body);
      expect(updatedLayout.controls.values.email?.editorType).to.equal(updateData.controlValues?.email?.editorType);
    });

    it('should validate HTML content when editorType is html', async () => {
      const updateData: UpdateLayoutDto = {
        name: 'HTML Layout',
        controlValues: {
          email: {
            body: 'Invalid HTML content without proper structure',
            editorType: 'html',
          },
        },
      };

      try {
        await novuClient.layouts.update(updateData, existingLayout.layoutId);
        expect.fail('Should have thrown validation error');
      } catch (error: any) {
        expect(error.statusCode).to.equal(400);
        expect(error.message).to.contain('Content must be a valid HTML content');
      }
    });

    it('should validate Maily JSON content when editorType is block', async () => {
      const updateData: UpdateLayoutDto = {
        name: 'Block Layout',
        controlValues: {
          email: {
            body: 'Invalid JSON content',
            editorType: 'block',
          },
        },
      };

      try {
        await novuClient.layouts.update(updateData, existingLayout.layoutId);
        expect.fail('Should have thrown validation error');
      } catch (error: any) {
        expect(error.statusCode).to.equal(400);
        expect(error.message).to.contain('Content must be a valid Maily JSON content');
      }
    });

    it('should not allow Maily JSON content when no content variable provided', async () => {
      const validMailyContent = JSON.stringify({
        type: 'doc',
        content: [
          {
            type: 'paragraph',
            attrs: { textAlign: null, showIfKey: null },
            content: [{ type: 'text', text: 'Hello from layout' }],
          },
        ],
      });
      const updateData: UpdateLayoutDto = {
        name: 'Block Layout',
        controlValues: {
          email: {
            body: validMailyContent,
            editorType: 'block',
          },
        },
      };

      try {
        await novuClient.layouts.update(updateData, existingLayout.layoutId);
        expect.fail('Should have thrown validation error');
      } catch (error: any) {
        expect(error.statusCode).to.equal(400);
        expect(error.ctx.controls['email.body'][0].message).to.contain(
          'The layout body should contain the "content" variable'
        );
      }
    });

    it('should not allow HTML content when no content variable provided', async () => {
      const validHtmlContent = `
        <html>
          <head><title>Test Layout</title></head>
          <body>
            <div>Hello {{subscriber.firstName}}</div>
          </body>
        </html>
      `;
      const updateData: UpdateLayoutDto = {
        name: 'Block Layout',
        controlValues: {
          email: {
            body: validHtmlContent,
            editorType: 'html',
          },
        },
      };

      try {
        await novuClient.layouts.update(updateData, existingLayout.layoutId);
        expect.fail('Should have thrown validation error');
      } catch (error: any) {
        expect(error.statusCode).to.equal(400);
        expect(error.ctx.controls['email.body'][0].message).to.contain(
          'The layout body should contain the "content" variable'
        );
      }
    });

    it('should accept valid HTML content', async () => {
      const validHtmlContent = `
        <html>
          <head><title>Test Layout</title></head>
          <body>
            <div>Hello {{subscriber.firstName}}</div>
            <div>{{content}}</div>
          </body>
        </html>
      `;

      const updateData: UpdateLayoutDto = {
        name: 'Valid HTML Layout',
        controlValues: {
          email: {
            body: validHtmlContent,
            editorType: 'html',
          },
        },
      };

      const { result: updatedLayout } = await novuClient.layouts.update(updateData, existingLayout.layoutId);

      expect(updatedLayout.name).to.equal(updateData.name);
      expect(updatedLayout.controls.values.email?.body).to.eq(validHtmlContent);
      expect(updatedLayout.controls.values.email?.editorType).to.equal('html');
    });

    it('should accept valid Maily JSON content', async () => {
      const validMailyContent = JSON.stringify({
        type: 'doc',
        content: [
          {
            type: 'paragraph',
            attrs: { textAlign: null, showIfKey: null },
            content: [
              { type: 'text', text: 'Hello from layout' },
              {
                type: 'variable',
                attrs: {
                  id: 'content',
                },
              },
            ],
          },
        ],
      });

      const updateData: UpdateLayoutDto = {
        name: 'Valid Block Layout',
        controlValues: {
          email: {
            body: validMailyContent,
            editorType: 'block',
          },
        },
      };

      const { result: updatedLayout } = await novuClient.layouts.update(updateData, existingLayout.layoutId);

      expect(updatedLayout.name).to.equal(updateData.name);
      expect(updatedLayout.controls.values.email?.body).to.equal(validMailyContent);
      expect(updatedLayout.controls.values.email?.editorType).to.equal('block');
    });

    it('should delete control values when set to null', async () => {
      const updateData: UpdateLayoutDto = {
        name: 'Layout with deleted controls',
        controlValues: null,
      };

      const { result: updatedLayout } = await novuClient.layouts.update(updateData, existingLayout.layoutId);
      expect(updatedLayout.name).to.equal(updateData.name);
      expect(updatedLayout.controls.values).to.deep.equal({});
    });
  });

  describe('Error Handling', () => {
    it('should return 404 when updating non-existent layout', async () => {
      const updateData: UpdateLayoutDto = {
        name: 'Non-existent Layout',
        controlValues: {
          email: {
            body: '<html><body><div>Content: {{content}}</div></body></html>',
            editorType: 'html',
          },
        },
      };

      try {
        await novuClient.layouts.update(updateData, 'non-existent-layout-id');
        expect.fail('Should have thrown 404 error');
      } catch (error: any) {
        expect(error.statusCode).to.equal(404);
      }
    });

    it('should return 400 for invalid layout data', async () => {
      try {
        await novuClient.layouts.create({
          layoutId: 'invalid-layout',
          name: '',
        } as CreateLayoutDto);
        expect.fail('Should have thrown validation error');
      } catch (error: any) {
        expect(error.statusCode).to.be.oneOf([400, 422]);
      }
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - layoutRepository(new LayoutRepository();
  });

  describe('Create Layout - POST /v2/layouts', ())
 - res(await expectSdkExceptionGeneric(())
 - res(await novuClient.layouts.create(layoutData3);
      expect(res.result).to.exist;
    });

    it('sh...)
 - existingLayout(result;
    });

    it('should update an existing layout successfully', async ())
 - UpdateLayoutDto({
        name: 'HTML Layout',
        controlValues: {
          email: {
            body: 'Invali...)
 - UpdateLayoutDto({
        name: 'Block Layout',
        controlValues: {
          email: {
            body: 'Inval...)
 - UpdateLayoutDto({
        name: 'Block Layout',
        controlValues: {
          email: {
            body: validM...)
 - UpdateLayoutDto({
        name: 'Block Layout',
        controlValues: {
          email: {
            body: validH...)
 - UpdateLayoutDto({
        name: 'Non-existent Layout',
        controlValues: {
          email: {
            body:...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/types/index.ts
Tamaño: 68 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export enum LayoutCreationSourceEnum {
  DASHBOARD = 'dashboard',
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  enum

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/index.ts
Tamaño: 904 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BuildLayoutIssuesUsecase } from './build-layout-issues/build-layout-issues.usecase';
import { DeleteLayoutUseCase } from './delete-layout';
import { DuplicateLayoutUseCase } from './duplicate-layout';
import { GetLayoutUseCase } from './get-layout';
import { GetLayoutUsageUseCase } from './get-layout-usage';
import { LayoutVariablesSchemaUseCase } from './layout-variables-schema';
import { ListLayoutsUseCase } from './list-layouts';
import { PreviewLayoutUsecase } from './preview-layout';
import { LayoutSyncToEnvironmentUseCase } from './sync-to-environment';
import { UpsertLayout } from './upsert-layout';

export const USE_CASES = [
  UpsertLayout,
  GetLayoutUseCase,
  DeleteLayoutUseCase,
  DuplicateLayoutUseCase,
  ListLayoutsUseCase,
  LayoutVariablesSchemaUseCase,
  PreviewLayoutUsecase,
  GetLayoutUsageUseCase,
  BuildLayoutIssuesUsecase,
  LayoutSyncToEnvironmentUseCase,
];


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/mapper.ts
Tamaño: 1540 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChannelTypeEnum, ShortIsPrefixEnum } from '@novu/shared';
import { LayoutDto } from '../../layouts-v1/dtos/layout.dto';
import { JSONSchemaDto } from '../../shared/dtos/json-schema.dto';
import { buildSlug } from '../../shared/helpers/build-slug';
import { LayoutResponseDto } from '../dtos';
import { EmailControlsDto } from '../dtos/layout-controls.dto';

export const mapToResponseDto = ({
  layout,
  controlValues,
  variables,
}: {
  layout: LayoutDto;
  controlValues?: Record<string, unknown> | null;
  variables?: JSONSchemaDto;
}): LayoutResponseDto => {
  const isEmailLayout = layout.channel === ChannelTypeEnum.EMAIL && controlValues?.email;

  return {
    _id: layout._id!,
    layoutId: layout.identifier,
    name: layout.name,
    slug: buildSlug(layout.name, ShortIsPrefixEnum.LAYOUT, layout._id!),
    isDefault: layout.isDefault,
    updatedAt: layout.updatedAt!,
    updatedBy: layout.updatedBy
      ? {
          _id: layout.updatedBy._id,
          firstName: layout.updatedBy.firstName,
          lastName: layout.updatedBy.lastName,
          externalId: layout.updatedBy.externalId,
        }
      : undefined,
    createdAt: layout.createdAt!,
    origin: layout.origin!,
    type: layout.type!,
    variables,
    controls: {
      uiSchema: layout.controls?.uiSchema,
      dataSchema: layout.controls?.dataSchema,
      values: {
        ...(isEmailLayout ? { email: controlValues?.email as EmailControlsDto } : {}),
      },
    },
    isTranslationEnabled: !!layout.isTranslationEnabled,
  };
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - mapToResponseDto({
  layout,
  controlValues,
  variables,
}: {
  layout: LayoutDto;
  controlValues?: Record<string,...)
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/build-layout-issues/build-layout-issues.command.ts
Tamaño: 572 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentWithUserCommand } from '@novu/application-generic';
import { ResourceOriginEnum } from '@novu/shared';
import { IsDefined, IsEnum, IsObject, IsOptional } from 'class-validator';

import { JSONSchemaDto } from '../../../shared/dtos/json-schema.dto';

export class BuildLayoutIssuesCommand extends EnvironmentWithUserCommand {
  @IsDefined()
  @IsEnum(ResourceOriginEnum)
  resourceOrigin: ResourceOriginEnum;

  @IsObject()
  @IsOptional()
  controlValues: Record<string, unknown> | null;

  @IsObject()
  @IsDefined()
  controlSchema: JSONSchemaDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class BuildLayoutIssuesCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/build-layout-issues/build-layout-issues.usecase.ts
Tamaño: 3724 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { dashboardSanitizeControlValues, Instrument, InstrumentUsecase, PinoLogger } from '@novu/application-generic';
import { ContentIssueEnum, LAYOUT_CONTENT_VARIABLE, LayoutIssuesDto, ResourceOriginEnum } from '@novu/shared';
import { merge } from 'es-toolkit/compat';
import { hasMailyVariable, isStringifiedMailyJSONContent } from '../../../shared/helpers/maily-utils';
import {
  ControlIssues,
  processControlValuesByLiquid,
  processControlValuesBySchema,
} from '../../../shared/utils/issues';
import { LayoutVariablesSchemaCommand, LayoutVariablesSchemaUseCase } from '../layout-variables-schema';
import { BuildLayoutIssuesCommand } from './build-layout-issues.command';

@Injectable()
export class BuildLayoutIssuesUsecase {
  constructor(
    private layoutVariablesSchemaUseCase: LayoutVariablesSchemaUseCase,
    private logger: PinoLogger
  ) {}

  @InstrumentUsecase()
  async execute(command: BuildLayoutIssuesCommand): Promise<LayoutIssuesDto> {
    const { resourceOrigin, environmentId, organizationId, controlSchema, controlValues } = command;

    const layoutVariablesSchema = await this.layoutVariablesSchemaUseCase.execute(
      LayoutVariablesSchemaCommand.create({
        environmentId,
        organizationId,
        controlValues: controlValues ?? {},
      })
    );

    const content = (controlValues?.email as { body: string })?.body;
    const isMailyContent = isStringifiedMailyJSONContent(content);
    const contentIssues: ControlIssues = {};
    if (
      (isMailyContent && !hasMailyVariable(content, LAYOUT_CONTENT_VARIABLE)) ||
      (!isMailyContent && !this.hasHtmlVariable(content, LAYOUT_CONTENT_VARIABLE))
    ) {
      contentIssues.controls = {
        'email.body': [
          {
            message: `The layout body should contain the "${LAYOUT_CONTENT_VARIABLE}" variable`,
            issueType: ContentIssueEnum.MISSING_VALUE,
          },
        ],
      };
    }

    const sanitizedControlValues = this.sanitizeControlValues(controlValues ?? {}, resourceOrigin);

    const schemaIssues = processControlValuesBySchema({
      controlSchema,
      controlValues: sanitizedControlValues ?? {},
    });

    const liquidIssues: ControlIssues = {};
    processControlValuesByLiquid({
      variableSchema: layoutVariablesSchema,
      currentValue: controlValues ?? {},
      currentPath: [],
      issues: liquidIssues,
    });

    return merge(contentIssues, schemaIssues, liquidIssues);
  }

  @Instrument()
  private sanitizeControlValues(
    newControlValues: Record<string, unknown> | undefined,
    layoutOrigin: ResourceOriginEnum
  ) {
    return newControlValues && layoutOrigin === ResourceOriginEnum.NOVU_CLOUD
      ? dashboardSanitizeControlValues(this.logger, newControlValues, 'layout') || {}
      : this.frameworkSanitizeEmptyStringsToNull(newControlValues) || {};
  }

  private frameworkSanitizeEmptyStringsToNull(
    obj: Record<string, unknown> | undefined | null
  ): Record<string, unknown> | undefined | null {
    if (typeof obj !== 'object' || obj === null || obj === undefined) return obj;

    return Object.fromEntries(
      Object.entries(obj).map(([key, value]) => {
        if (typeof value === 'string' && value.trim() === '') {
          return [key, null];
        }
        if (typeof value === 'object') {
          return [key, this.frameworkSanitizeEmptyStringsToNull(value as Record<string, unknown>)];
        }

        return [key, value];
      })
    );
  }

  private hasHtmlVariable(content: string, variable: string): boolean {
    const liquidVariableRegex = new RegExp(`\\{\\{\\s*${variable}\\s*\\}\\}`, 'g');

    return liquidVariableRegex.test(content);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class BuildLayoutIssuesUsecase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/delete-layout/delete-layout.command.ts
Tamaño: 261 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentWithUserCommand } from '@novu/application-generic';
import { IsDefined, IsString } from 'class-validator';

export class DeleteLayoutCommand extends EnvironmentWithUserCommand {
  @IsString()
  @IsDefined()
  layoutIdOrInternalId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DeleteLayoutCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/delete-layout/delete-layout.use-case.spec.ts
Tamaño: 11227 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ConflictException } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import { AnalyticsService, PinoLogger } from '@novu/application-generic';
import { ControlValuesRepository, LayoutRepository } from '@novu/dal';
import { ChannelTypeEnum, ControlValuesLevelEnum, ResourceOriginEnum, ResourceTypeEnum } from '@novu/shared';
import { expect } from 'chai';
import sinon from 'sinon';
import { GetLayoutUseCase } from '../get-layout';
import { DeleteLayoutCommand } from './delete-layout.command';
import { DeleteLayoutUseCase } from './delete-layout.use-case';

describe('DeleteLayoutUseCase', () => {
  let getLayoutUseCaseMock: sinon.SinonStubbedInstance<GetLayoutUseCase>;
  let layoutRepositoryMock: sinon.SinonStubbedInstance<LayoutRepository>;
  let controlValuesRepositoryMock: sinon.SinonStubbedInstance<ControlValuesRepository>;
  let analyticsServiceMock: sinon.SinonStubbedInstance<AnalyticsService>;
  let moduleRefMock: sinon.SinonStubbedInstance<ModuleRef>;
  let pinoLoggerMock: sinon.SinonStubbedInstance<PinoLogger>;
  let deleteLayoutUseCase: DeleteLayoutUseCase;

  const mockUser = {
    _id: 'user_id',
    environmentId: 'env_id',
    organizationId: 'org_id',
  };

  const mockLayout = {
    _id: 'layout_id',
    layoutId: 'layout_id',
    identifier: 'layout_identifier',
    name: 'Test Layout',
    isDefault: false,
    createdAt: '2023-01-01T00:00:00Z',
    updatedAt: '2023-01-01T00:00:00Z',
    _environmentId: 'env_id',
    _organizationId: 'org_id',
    origin: ResourceOriginEnum.NOVU_CLOUD,
    type: ResourceTypeEnum.BRIDGE,
    channel: ChannelTypeEnum.EMAIL,
  };

  const mockDefaultLayout = {
    ...mockLayout,
    isDefault: true,
    name: 'Default Layout',
  };

  const mockStepControlValues = [
    {
      _id: 'step_control_1',
      _environmentId: 'env_id',
      _organizationId: 'org_id',
      level: ControlValuesLevelEnum.STEP_CONTROLS,
      controls: {
        email: {
          layoutId: 'layout_id',
          subject: 'Test Subject',
        },
      },
    },
    {
      _id: 'step_control_2',
      _environmentId: 'env_id',
      _organizationId: 'org_id',
      level: ControlValuesLevelEnum.STEP_CONTROLS,
      controls: {
        email: {
          layoutId: 'layout_id',
          body: 'Test Body',
        },
      },
    },
  ];

  beforeEach(() => {
    getLayoutUseCaseMock = sinon.createStubInstance(GetLayoutUseCase);
    layoutRepositoryMock = sinon.createStubInstance(LayoutRepository);
    controlValuesRepositoryMock = sinon.createStubInstance(ControlValuesRepository);
    analyticsServiceMock = sinon.createStubInstance(AnalyticsService);
    pinoLoggerMock = sinon.createStubInstance(PinoLogger);
    moduleRefMock = sinon.createStubInstance(ModuleRef);

    deleteLayoutUseCase = new DeleteLayoutUseCase(
      getLayoutUseCaseMock as any,
      layoutRepositoryMock as any,
      controlValuesRepositoryMock as any,
      analyticsServiceMock as any,
      moduleRefMock as any,
      pinoLoggerMock as any
    );

    // Default mocks
    getLayoutUseCaseMock.execute.resolves(mockLayout as any);
    controlValuesRepositoryMock.update.resolves({ matched: 2, modified: 2 } as any);
    controlValuesRepositoryMock.delete.resolves({} as any);
    layoutRepositoryMock.deleteLayout.resolves();
  });

  afterEach(() => {
    sinon.restore();
  });

  describe('execute', () => {
    it('should successfully delete non-default layout', async () => {
      const command = DeleteLayoutCommand.create({
        layoutIdOrInternalId: 'layout_identifier',
        userId: mockUser._id,
        environmentId: mockUser.environmentId,
        organizationId: mockUser.organizationId,
      });

      await deleteLayoutUseCase.execute(command);

      // Verify v1 use case was called with correct parameters
      expect(getLayoutUseCaseMock.execute.calledOnce).to.be.true;
      const getLayoutCommand = getLayoutUseCaseMock.execute.firstCall.args[0];
      expect(getLayoutCommand.layoutIdOrInternalId).to.equal('layout_identifier');
      expect(getLayoutCommand.environmentId).to.equal('env_id');
      expect(getLayoutCommand.organizationId).to.equal('org_id');
      expect(getLayoutCommand.skipAdditionalFields).to.be.true;

      // Verify layout was deleted from repository
      expect(layoutRepositoryMock.deleteLayout.calledOnce).to.be.true;
      expect(layoutRepositoryMock.deleteLayout.firstCall.args).to.deep.equal(['layout_id', 'env_id', 'org_id']);

      // Verify control values were deleted
      expect(controlValuesRepositoryMock.delete.calledOnce).to.be.true;
      expect(controlValuesRepositoryMock.delete.firstCall.args[0]).to.deep.equal({
        _environmentId: 'env_id',
        _organizationId: 'org_id',
        _layoutId: 'layout_id',
        level: ControlValuesLevelEnum.LAYOUT_CONTROLS,
      });
    });

    it('should throw ConflictException when trying to delete default layout', async () => {
      getLayoutUseCaseMock.execute.resolves(mockDefaultLayout as any);

      const command = DeleteLayoutCommand.create({
        layoutIdOrInternalId: 'default_layout',
        userId: mockUser._id,
        environmentId: mockUser.environmentId,
        organizationId: mockUser.organizationId,
      });

      try {
        await deleteLayoutUseCase.execute(command);
        expect.fail('Should have thrown an error');
      } catch (error) {
        expect(error).to.be.instanceOf(ConflictException);
        expect(error.message).to.include('is being used as a default layout, it can not be deleted');
      }

      // Verify layout was not deleted
      expect(layoutRepositoryMock.deleteLayout.called).to.be.false;
    });

    it('should remove layout references from step controls', async () => {
      const command = DeleteLayoutCommand.create({
        layoutIdOrInternalId: 'layout_identifier',
        userId: mockUser._id,
        environmentId: mockUser.environmentId,
        organizationId: mockUser.organizationId,
      });

      await deleteLayoutUseCase.execute(command);

      // Verify update was called to remove layout references
      expect(controlValuesRepositoryMock.update.calledOnce).to.be.true;
      expect(controlValuesRepositoryMock.update.firstCall.args[0]).to.deep.equal({
        level: ControlValuesLevelEnum.STEP_CONTROLS,
        _environmentId: 'env_id',
        _organizationId: 'org_id',
        'controls.layoutId': 'layout_id',
      });
      expect(controlValuesRepositoryMock.update.firstCall.args[1]).to.deep.equal({
        $unset: { 'controls.layoutId': '' },
      });
    });

    it('should handle case where no step controls reference the layout', async () => {
      controlValuesRepositoryMock.update.resolves({ matched: 0, modified: 0 } as any);

      const command = DeleteLayoutCommand.create({
        layoutIdOrInternalId: 'layout_identifier',
        userId: mockUser._id,
        environmentId: mockUser.environmentId,
        organizationId: mockUser.organizationId,
      });

      await deleteLayoutUseCase.execute(command);

      // Verify update was still called (even if no documents matched)
      expect(controlValuesRepositoryMock.update.calledOnce).to.be.true;

      // Verify layout was still deleted
      expect(layoutRepositoryMock.deleteLayout.calledOnce).to.be.true;
    });

    it('should track analytics event', async () => {
      const command = DeleteLayoutCommand.create({
        layoutIdOrInternalId: 'layout_identifier',
        userId: mockUser._id,
        environmentId: mockUser.environmentId,
        organizationId: mockUser.organizationId,
      });

      await deleteLayoutUseCase.execute(command);

      expect(analyticsServiceMock.track.calledOnce).to.be.true;
      expect(analyticsServiceMock.track.firstCall.args[0]).to.equal('Delete layout - [Layouts]');
      expect(analyticsServiceMock.track.firstCall.args[1]).to.equal('user_id');
      expect(analyticsServiceMock.track.firstCall.args[2]).to.deep.equal({
        _organizationId: 'org_id',
        _environmentId: 'env_id',
        layoutId: 'layout_id',
      });
    });

    it('should propagate error from v1 use case', async () => {
      const error = new Error('Layout not found');
      getLayoutUseCaseMock.execute.rejects(error);

      const command = DeleteLayoutCommand.create({
        layoutIdOrInternalId: 'non_existent',
        userId: mockUser._id,
        environmentId: mockUser.environmentId,
        organizationId: mockUser.organizationId,
      });

      try {
        await deleteLayoutUseCase.execute(command);
        expect.fail('Should have thrown an error');
      } catch (thrownError) {
        expect(thrownError.message).to.equal('Layout not found');
      }
    });

    it('should propagate error from step controls cleanup', async () => {
      const error = new Error('Database error');
      controlValuesRepositoryMock.update.rejects(error);

      const command = DeleteLayoutCommand.create({
        layoutIdOrInternalId: 'layout_identifier',
        userId: mockUser._id,
        environmentId: mockUser.environmentId,
        organizationId: mockUser.organizationId,
      });

      try {
        await deleteLayoutUseCase.execute(command);
        expect.fail('Should have thrown an error');
      } catch (thrownError) {
        expect(thrownError.message).to.equal('Database error');
      }
    });

    it('should propagate error from step controls update', async () => {
      const error = new Error('Update error');
      controlValuesRepositoryMock.update.rejects(error);

      const command = DeleteLayoutCommand.create({
        layoutIdOrInternalId: 'layout_identifier',
        userId: mockUser._id,
        environmentId: mockUser.environmentId,
        organizationId: mockUser.organizationId,
      });

      try {
        await deleteLayoutUseCase.execute(command);
        expect.fail('Should have thrown an error');
      } catch (thrownError) {
        expect(thrownError.message).to.equal('Update error');
      }
    });

    it('should propagate error from layout deletion', async () => {
      const error = new Error('Delete error');
      layoutRepositoryMock.deleteLayout.rejects(error);

      const command = DeleteLayoutCommand.create({
        layoutIdOrInternalId: 'layout_identifier',
        userId: mockUser._id,
        environmentId: mockUser.environmentId,
        organizationId: mockUser.organizationId,
      });

      try {
        await deleteLayoutUseCase.execute(command);
        expect.fail('Should have thrown an error');
      } catch (thrownError) {
        expect(thrownError.message).to.equal('Delete error');
      }
    });

    it('should validate deletion order: step controls cleanup before layout deletion', async () => {
      const command = DeleteLayoutCommand.create({
        layoutIdOrInternalId: 'layout_identifier',
        userId: mockUser._id,
        environmentId: mockUser.environmentId,
        organizationId: mockUser.organizationId,
      });

      await deleteLayoutUseCase.execute(command);

      // Verify step controls update was called before layout deletion
      expect(controlValuesRepositoryMock.update.calledBefore(layoutRepositoryMock.deleteLayout)).to.be.true;
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - mockStepControlValues([
    {
      _id: 'step_control_1',
      _environmentId: 'env_id',
      _organizationId: 'org_id'...)
 - deleteLayoutUseCase(new DeleteLayoutUseCase(
      getLayoutUseCaseMock as any,
      layoutRepositoryMock as any,
     ...)
 - getLayoutCommand(getLayoutUseCaseMock.execute.firstCall.args[0];
      expect(getLayoutCommand.layoutIdOrInternalId)....)
 - command(DeleteLayoutCommand.create({
        layoutIdOrInternalId: 'default_layout',
        userId: mockUse...)
 - command(DeleteLayoutCommand.create({
        layoutIdOrInternalId: 'layout_identifier',
        userId: mock...)
 - command(DeleteLayoutCommand.create({
        layoutIdOrInternalId: 'layout_identifier',
        userId: mock...)
 - command(DeleteLayoutCommand.create({
        layoutIdOrInternalId: 'layout_identifier',
        userId: mock...)
 - command(DeleteLayoutCommand.create({
        layoutIdOrInternalId: 'non_existent',
        userId: mockUser....)
 - command(DeleteLayoutCommand.create({
        layoutIdOrInternalId: 'layout_identifier',
        userId: mock...)
 - command(DeleteLayoutCommand.create({
        layoutIdOrInternalId: 'layout_identifier',
        userId: mock...)
 - command(DeleteLayoutCommand.create({
        layoutIdOrInternalId: 'layout_identifier',
        userId: mock...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/delete-layout/delete-layout.use-case.ts
Tamaño: 3789 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ConflictException, Injectable } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import { AnalyticsService, PinoLogger } from '@novu/application-generic';
import { ControlValuesRepository, LayoutRepository, LocalizationResourceEnum } from '@novu/dal';
import { ControlValuesLevelEnum } from '@novu/shared';
import { LayoutResponseDto } from '../../dtos';
import { GetLayoutCommand, GetLayoutUseCase } from '../get-layout';
import { DeleteLayoutCommand } from './delete-layout.command';

@Injectable()
export class DeleteLayoutUseCase {
  constructor(
    private getLayoutUseCase: GetLayoutUseCase,
    private layoutRepository: LayoutRepository,
    private controlValuesRepository: ControlValuesRepository,
    private analyticsService: AnalyticsService,
    private moduleRef: ModuleRef,
    private logger: PinoLogger
  ) {}

  async execute(command: DeleteLayoutCommand): Promise<void> {
    const { environmentId, organizationId, userId } = command;
    const layout = await this.getLayoutUseCase.execute(
      GetLayoutCommand.create({
        layoutIdOrInternalId: command.layoutIdOrInternalId,
        environmentId,
        organizationId,
        userId,
        skipAdditionalFields: true,
      })
    );

    if (layout.isDefault) {
      throw new ConflictException(
        `Layout with id ${command.layoutIdOrInternalId} is being used as a default layout, it can not be deleted`
      );
    }

    await this.removeLayoutReferencesFromStepControls({
      layoutId: layout.layoutId!,
      environmentId,
      organizationId,
    });

    await this.deleteTranslationGroup(layout, command);

    await this.layoutRepository.deleteLayout(layout._id!, environmentId, organizationId);

    await this.controlValuesRepository.delete({
      _environmentId: environmentId,
      _organizationId: organizationId,
      _layoutId: layout._id!,
      level: ControlValuesLevelEnum.LAYOUT_CONTROLS,
    });

    this.analyticsService.track('Delete layout - [Layouts]', userId, {
      _organizationId: organizationId,
      _environmentId: environmentId,
      layoutId: layout._id!,
    });
  }

  private async removeLayoutReferencesFromStepControls({
    layoutId,
    environmentId,
    organizationId,
  }: {
    layoutId: string;
    environmentId: string;
    organizationId: string;
  }): Promise<void> {
    await this.controlValuesRepository.update(
      {
        level: ControlValuesLevelEnum.STEP_CONTROLS,
        _environmentId: environmentId,
        _organizationId: organizationId,
        'controls.layoutId': layoutId,
      },
      { $unset: { 'controls.layoutId': '' } }
    );
  }

  private async deleteTranslationGroup(layout: LayoutResponseDto, command: DeleteLayoutCommand) {
    const isEnterprise = process.env.NOVU_ENTERPRISE === 'true' || process.env.CI_EE_TEST === 'true';
    const isSelfHosted = process.env.IS_SELF_HOSTED === 'true';

    if (!isEnterprise || isSelfHosted) {
      return;
    }

    try {
      const deleteTranslationGroupUseCase = this.moduleRef.get(
        require('@novu/ee-translation')?.DeleteTranslationGroup,
        {
          strict: false,
        }
      );

      await deleteTranslationGroupUseCase.execute({
        resourceId: layout.layoutId,
        resourceType: LocalizationResourceEnum.LAYOUT,
        organizationId: command.organizationId,
        environmentId: command.environmentId,
        userId: command.userId,
      });
    } catch (error) {
      this.logger.error(`Failed to delete translations for layout`, {
        layoutId: layout.layoutId,
        organizationId: command.organizationId,
        error: error instanceof Error ? error.message : String(error),
      });

      // translation group might not be present, so we can ignore the error
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DeleteLayoutUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/delete-layout/index.ts
Tamaño: 83 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './delete-layout.command';
export * from './delete-layout.use-case';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/duplicate-layout/duplicate-layout.command.ts
Tamaño: 459 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentWithUserCommand } from '@novu/application-generic';
import { Type } from 'class-transformer';
import { IsDefined, IsString, ValidateNested } from 'class-validator';
import { DuplicateLayoutDto } from '../../dtos';

export class DuplicateLayoutCommand extends EnvironmentWithUserCommand {
  @IsString()
  @IsDefined()
  layoutIdOrInternalId: string;

  @ValidateNested()
  @Type(() => DuplicateLayoutDto)
  overrides: DuplicateLayoutDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DuplicateLayoutCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/duplicate-layout/duplicate-layout.use-case.spec.ts
Tamaño: 13089 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ModuleRef } from '@nestjs/core';
import { AnalyticsService, PinoLogger } from '@novu/application-generic';
import { ControlValuesRepository } from '@novu/dal';
import { ChannelTypeEnum, ControlValuesLevelEnum, ResourceOriginEnum, ResourceTypeEnum } from '@novu/shared';
import { expect } from 'chai';
import sinon from 'sinon';
import { GetLayoutUseCase } from '../get-layout';
import { UpsertLayout } from '../upsert-layout';
import { DuplicateLayoutCommand } from './duplicate-layout.command';
import { DuplicateLayoutUseCase } from './duplicate-layout.use-case';

describe('DuplicateLayoutUseCase', () => {
  let getLayoutUseCaseMock: sinon.SinonStubbedInstance<GetLayoutUseCase>;
  let upsertLayoutUseCaseMock: sinon.SinonStubbedInstance<UpsertLayout>;
  let controlValuesRepositoryMock: sinon.SinonStubbedInstance<ControlValuesRepository>;
  let analyticsServiceMock: sinon.SinonStubbedInstance<AnalyticsService>;
  let moduleRefMock: sinon.SinonStubbedInstance<ModuleRef>;
  let pinoLoggerMock: sinon.SinonStubbedInstance<PinoLogger>;
  let duplicateLayoutUseCase: DuplicateLayoutUseCase;

  const mockUser = {
    _id: 'user_id',
    environmentId: 'env_id',
    organizationId: 'org_id',
  };

  const mockOriginalLayout = {
    _id: 'original_layout_id',
    identifier: 'original_layout_identifier',
    name: 'Original Layout',
    isDefault: false,
    createdAt: '2023-01-01T00:00:00Z',
    updatedAt: '2023-01-01T00:00:00Z',
    _environmentId: 'env_id',
    _organizationId: 'org_id',
    origin: ResourceOriginEnum.NOVU_CLOUD,
    type: ResourceTypeEnum.BRIDGE,
    channel: ChannelTypeEnum.EMAIL,
  };

  const mockOriginalControlValues = {
    _id: 'original_control_values_id',
    _environmentId: 'env_id',
    _organizationId: 'org_id',
    _layoutId: 'original_layout_id',
    level: ControlValuesLevelEnum.LAYOUT_CONTROLS,
    controls: {
      email: {
        body: '<html><body>{{content}}</body></html>',
        subject: 'Original Subject',
      },
    },
  };

  const mockDuplicatedLayout = {
    _id: 'duplicated_layout_id',
    layoutId: 'duplicated_layout_identifier',
    name: 'Duplicated Layout',
    isDefault: false,
    createdAt: '2023-01-02T00:00:00Z',
    updatedAt: '2023-01-02T00:00:00Z',
    _environmentId: 'env_id',
    _organizationId: 'org_id',
    origin: ResourceOriginEnum.NOVU_CLOUD,
    type: ResourceTypeEnum.BRIDGE,
    controls: {
      schema: {},
      values: {
        email: mockOriginalControlValues.controls.email,
      },
    },
  };

  const mockOverrides = {
    name: 'Duplicated Layout',
  };

  beforeEach(() => {
    getLayoutUseCaseMock = sinon.createStubInstance(GetLayoutUseCase);
    upsertLayoutUseCaseMock = sinon.createStubInstance(UpsertLayout);
    controlValuesRepositoryMock = sinon.createStubInstance(ControlValuesRepository);
    analyticsServiceMock = sinon.createStubInstance(AnalyticsService);
    moduleRefMock = sinon.createStubInstance(ModuleRef);
    pinoLoggerMock = sinon.createStubInstance(PinoLogger);

    duplicateLayoutUseCase = new DuplicateLayoutUseCase(
      getLayoutUseCaseMock as any,
      upsertLayoutUseCaseMock as any,
      controlValuesRepositoryMock as any,
      analyticsServiceMock as any,
      moduleRefMock as any,
      pinoLoggerMock as any
    );

    // Default mocks
    getLayoutUseCaseMock.execute.resolves(mockOriginalLayout as any);
    controlValuesRepositoryMock.findOne.resolves(mockOriginalControlValues as any);
    upsertLayoutUseCaseMock.execute.resolves(mockDuplicatedLayout as any);
  });

  afterEach(() => {
    sinon.restore();
  });

  describe('execute', () => {
    it('should successfully duplicate layout with control values', async () => {
      const command = DuplicateLayoutCommand.create({
        layoutIdOrInternalId: 'original_layout_identifier',
        overrides: mockOverrides,
        userId: mockUser._id,
        environmentId: mockUser.environmentId,
        organizationId: mockUser.organizationId,
      });

      const result = await duplicateLayoutUseCase.execute(command);

      expect(result).to.deep.equal(mockDuplicatedLayout);

      // Verify v1 use case was called with correct parameters
      expect(getLayoutUseCaseMock.execute.calledOnce).to.be.true;
      const v1Command = getLayoutUseCaseMock.execute.firstCall.args[0];
      expect(v1Command.layoutIdOrInternalId).to.equal('original_layout_identifier');
      expect(v1Command.environmentId).to.equal('env_id');
      expect(v1Command.organizationId).to.equal('org_id');
      expect(v1Command.skipAdditionalFields).to.be.true;

      // Verify control values repository was called
      expect(controlValuesRepositoryMock.findOne.calledOnce).to.be.true;
      expect(controlValuesRepositoryMock.findOne.firstCall.args[0]).to.deep.equal({
        _environmentId: 'env_id',
        _organizationId: 'org_id',
        _layoutId: 'original_layout_id',
        level: ControlValuesLevelEnum.LAYOUT_CONTROLS,
      });

      // Verify upsert use case was called with correct parameters
      expect(upsertLayoutUseCaseMock.execute.calledOnce).to.be.true;
      const upsertCommand = upsertLayoutUseCaseMock.execute.firstCall.args[0];
      expect(upsertCommand.layoutDto.name).to.equal('Duplicated Layout');
      expect(upsertCommand.layoutDto.controlValues).to.deep.equal(mockOriginalControlValues.controls);
      expect(upsertCommand.userId).to.deep.equal(mockUser._id);
      expect(upsertCommand.environmentId).to.deep.equal(mockUser.environmentId);
      expect(upsertCommand.organizationId).to.deep.equal(mockUser.organizationId);
    });

    it('should duplicate layout without control values when none exist', async () => {
      controlValuesRepositoryMock.findOne.resolves(null);

      const command = DuplicateLayoutCommand.create({
        layoutIdOrInternalId: 'original_layout_identifier',
        overrides: mockOverrides,
        userId: mockUser._id,
        environmentId: mockUser.environmentId,
        organizationId: mockUser.organizationId,
      });

      const result = await duplicateLayoutUseCase.execute(command);

      expect(result).to.deep.equal(mockDuplicatedLayout);

      // Verify control values repository was called
      expect(controlValuesRepositoryMock.findOne.calledOnce).to.be.true;

      // Verify upsert use case was called with null control values
      expect(upsertLayoutUseCaseMock.execute.calledOnce).to.be.true;
      const upsertCommand = upsertLayoutUseCaseMock.execute.firstCall.args[0];
      expect(upsertCommand.layoutDto.controlValues).to.be.null;
    });

    it('should handle empty control values controls', async () => {
      const controlValuesWithEmptyControls = {
        ...mockOriginalControlValues,
        controls: undefined,
      };
      controlValuesRepositoryMock.findOne.resolves(controlValuesWithEmptyControls as any);

      const command = DuplicateLayoutCommand.create({
        layoutIdOrInternalId: 'original_layout_identifier',
        overrides: mockOverrides,
        userId: mockUser._id,
        environmentId: mockUser.environmentId,
        organizationId: mockUser.organizationId,
      });

      const result = await duplicateLayoutUseCase.execute(command);

      expect(result).to.deep.equal(mockDuplicatedLayout);

      // Verify upsert use case was called with null control values
      expect(upsertLayoutUseCaseMock.execute.calledOnce).to.be.true;
      const upsertCommand = upsertLayoutUseCaseMock.execute.firstCall.args[0];
      expect(upsertCommand.layoutDto.controlValues).to.be.null;
    });

    it('should track analytics event', async () => {
      const command = DuplicateLayoutCommand.create({
        layoutIdOrInternalId: 'original_layout_identifier',
        overrides: mockOverrides,
        userId: mockUser._id,
        environmentId: mockUser.environmentId,
        organizationId: mockUser.organizationId,
      });

      await duplicateLayoutUseCase.execute(command);

      expect(analyticsServiceMock.track.calledOnce).to.be.true;
      expect(analyticsServiceMock.track.firstCall.args[0]).to.equal('Duplicate layout - [Layouts]');
      expect(analyticsServiceMock.track.firstCall.args[1]).to.equal('user_id');
      expect(analyticsServiceMock.track.firstCall.args[2]).to.deep.equal({
        _organizationId: 'org_id',
        _environmentId: 'env_id',
        originalLayoutId: 'original_layout_id',
        duplicatedLayoutId: 'duplicated_layout_id',
      });
    });

    it('should use override name correctly', async () => {
      const customOverrides = {
        name: 'Custom Duplicated Name',
      };

      const command = DuplicateLayoutCommand.create({
        layoutIdOrInternalId: 'original_layout_identifier',
        overrides: customOverrides,
        userId: mockUser._id,
        environmentId: mockUser.environmentId,
        organizationId: mockUser.organizationId,
      });

      await duplicateLayoutUseCase.execute(command);

      expect(upsertLayoutUseCaseMock.execute.calledOnce).to.be.true;
      const upsertCommand = upsertLayoutUseCaseMock.execute.firstCall.args[0];
      expect(upsertCommand.layoutDto.name).to.equal('Custom Duplicated Name');
    });

    it('should propagate error from v1 use case', async () => {
      const error = new Error('Layout not found');
      getLayoutUseCaseMock.execute.rejects(error);

      const command = DuplicateLayoutCommand.create({
        layoutIdOrInternalId: 'non_existent',
        overrides: mockOverrides,
        userId: mockUser._id,
        environmentId: mockUser.environmentId,
        organizationId: mockUser.organizationId,
      });

      try {
        await duplicateLayoutUseCase.execute(command);
        expect.fail('Should have thrown an error');
      } catch (thrownError) {
        expect(thrownError.message).to.equal('Layout not found');
      }
    });

    it('should propagate error from control values repository', async () => {
      const error = new Error('Database error');
      controlValuesRepositoryMock.findOne.rejects(error);

      const command = DuplicateLayoutCommand.create({
        layoutIdOrInternalId: 'original_layout_identifier',
        overrides: mockOverrides,
        userId: mockUser._id,
        environmentId: mockUser.environmentId,
        organizationId: mockUser.organizationId,
      });

      try {
        await duplicateLayoutUseCase.execute(command);
        expect.fail('Should have thrown an error');
      } catch (thrownError) {
        expect(thrownError.message).to.equal('Database error');
      }
    });

    it('should propagate error from upsert use case', async () => {
      const error = new Error('Upsert error');
      upsertLayoutUseCaseMock.execute.rejects(error);

      const command = DuplicateLayoutCommand.create({
        layoutIdOrInternalId: 'original_layout_identifier',
        overrides: mockOverrides,
        userId: mockUser._id,
        environmentId: mockUser.environmentId,
        organizationId: mockUser.organizationId,
      });

      try {
        await duplicateLayoutUseCase.execute(command);
        expect.fail('Should have thrown an error');
      } catch (thrownError) {
        expect(thrownError.message).to.equal('Upsert error');
      }
    });

    it('should validate execution order: get original before duplicate creation', async () => {
      const command = DuplicateLayoutCommand.create({
        layoutIdOrInternalId: 'original_layout_identifier',
        overrides: mockOverrides,
        userId: mockUser._id,
        environmentId: mockUser.environmentId,
        organizationId: mockUser.organizationId,
      });

      await duplicateLayoutUseCase.execute(command);

      // Verify original layout was fetched before duplication
      expect(getLayoutUseCaseMock.execute.calledBefore(upsertLayoutUseCaseMock.execute)).to.be.true;
      expect(controlValuesRepositoryMock.findOne.calledBefore(upsertLayoutUseCaseMock.execute)).to.be.true;
    });

    it('should preserve original layout control values structure', async () => {
      const complexControlValues = {
        ...mockOriginalControlValues,
        controls: {
          email: {
            body: '<html><head><style>body { margin: 0; }</style></head><body>{{content}}</body></html>',
            subject: 'Complex Subject {{payload.name}}',
            preheader: 'Preview text',
            customField: 'custom value',
          },
        },
      };
      controlValuesRepositoryMock.findOne.resolves(complexControlValues as any);

      const command = DuplicateLayoutCommand.create({
        layoutIdOrInternalId: 'original_layout_identifier',
        overrides: mockOverrides,
        userId: mockUser._id,
        environmentId: mockUser.environmentId,
        organizationId: mockUser.organizationId,
      });

      await duplicateLayoutUseCase.execute(command);

      expect(upsertLayoutUseCaseMock.execute.calledOnce).to.be.true;
      const upsertCommand = upsertLayoutUseCaseMock.execute.firstCall.args[0];
      expect(upsertCommand.layoutDto.controlValues).to.deep.equal(complexControlValues.controls);
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - mockOverrides({
    name: 'Duplicated Layout',
  };

  beforeEach(())
 - duplicateLayoutUseCase(new DuplicateLayoutUseCase(
      getLayoutUseCaseMock as any,
      upsertLayoutUseCaseMock as any,...)
 - upsertCommand(upsertLayoutUseCaseMock.execute.firstCall.args[0];
      expect(upsertCommand.layoutDto.name).to.equ...)
 - upsertCommand(upsertLayoutUseCaseMock.execute.firstCall.args[0];
      expect(upsertCommand.layoutDto.controlValue...)
 - upsertCommand(upsertLayoutUseCaseMock.execute.firstCall.args[0];
      expect(upsertCommand.layoutDto.controlValue...)
 - command(DuplicateLayoutCommand.create({
        layoutIdOrInternalId: 'original_layout_identifier',
        ...)
 - upsertCommand(upsertLayoutUseCaseMock.execute.firstCall.args[0];
      expect(upsertCommand.layoutDto.name).to.equ...)
 - command(DuplicateLayoutCommand.create({
        layoutIdOrInternalId: 'non_existent',
        overrides: moc...)
 - command(DuplicateLayoutCommand.create({
        layoutIdOrInternalId: 'original_layout_identifier',
        ...)
 - command(DuplicateLayoutCommand.create({
        layoutIdOrInternalId: 'original_layout_identifier',
        ...)
 - command(DuplicateLayoutCommand.create({
        layoutIdOrInternalId: 'original_layout_identifier',
        ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/duplicate-layout/duplicate-layout.use-case.ts
Tamaño: 3774 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import { AnalyticsService, PinoLogger } from '@novu/application-generic';
import { ControlValuesRepository, LocalizationResourceEnum } from '@novu/dal';
import { ControlValuesLevelEnum } from '@novu/shared';
import { LayoutResponseDto } from '../../dtos';
import { GetLayoutCommand, GetLayoutUseCase } from '../get-layout';
import { UpsertLayout, UpsertLayoutCommand } from '../upsert-layout';
import { DuplicateLayoutCommand } from './duplicate-layout.command';

@Injectable()
export class DuplicateLayoutUseCase {
  constructor(
    private getLayoutUseCase: GetLayoutUseCase,
    private upsertLayoutUseCase: UpsertLayout,
    private controlValuesRepository: ControlValuesRepository,
    private analyticsService: AnalyticsService,
    private moduleRef: ModuleRef,
    private logger: PinoLogger
  ) {}

  async execute(command: DuplicateLayoutCommand): Promise<LayoutResponseDto> {
    const originalLayout = await this.getLayoutUseCase.execute(
      GetLayoutCommand.create({
        layoutIdOrInternalId: command.layoutIdOrInternalId,
        environmentId: command.environmentId,
        organizationId: command.organizationId,
        userId: command.userId,
        skipAdditionalFields: true,
      })
    );

    const originalControlValues = await this.controlValuesRepository.findOne({
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
      _layoutId: originalLayout._id!,
      level: ControlValuesLevelEnum.LAYOUT_CONTROLS,
    });

    const duplicatedLayout = await this.upsertLayoutUseCase.execute(
      UpsertLayoutCommand.create({
        layoutDto: {
          name: command.overrides.name,
          isTranslationEnabled: command.overrides.isTranslationEnabled,
          controlValues: originalControlValues?.controls ?? null,
        },
        environmentId: command.environmentId,
        organizationId: command.organizationId,
        userId: command.userId,
      })
    );

    this.analyticsService.track('Duplicate layout - [Layouts]', command.userId, {
      _organizationId: command.organizationId,
      _environmentId: command.environmentId,
      originalLayoutId: originalLayout._id!,
      duplicatedLayoutId: duplicatedLayout._id,
    });

    if (duplicatedLayout.isTranslationEnabled) {
      await this.duplicateTranslationsForLayout({
        sourceResourceId: originalLayout.layoutId,
        targetResourceId: duplicatedLayout.layoutId,
        command,
      });
    }

    return duplicatedLayout;
  }

  private async duplicateTranslationsForLayout({
    sourceResourceId,
    targetResourceId,
    command,
  }: {
    sourceResourceId: string;
    targetResourceId: string;
    command: DuplicateLayoutCommand;
  }) {
    const isEnterprise = process.env.NOVU_ENTERPRISE === 'true' || process.env.CI_EE_TEST === 'true';
    const isSelfHosted = process.env.IS_SELF_HOSTED === 'true';

    if (!isEnterprise || isSelfHosted) {
      return;
    }

    try {
      const duplicateLocales = this.moduleRef.get(require('@novu/ee-translation')?.DuplicateLocales, {
        strict: false,
      });

      await duplicateLocales.execute({
        sourceResourceId,
        sourceResourceType: LocalizationResourceEnum.LAYOUT,
        targetResourceId,
        organizationId: command.organizationId,
        environmentId: command.environmentId,
        userId: command.userId,
      });
    } catch (error) {
      this.logger.error(`Failed to duplicate translations for layout`, {
        sourceResourceId,
        targetResourceId,
        organizationId: command.organizationId,
        error: error instanceof Error ? error.message : String(error),
      });

      throw error;
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DuplicateLayoutUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/duplicate-layout/index.ts
Tamaño: 89 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './duplicate-layout.command';
export * from './duplicate-layout.use-case';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/get-layout-usage/get-layout-usage.command.ts
Tamaño: 221 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentCommand } from '@novu/application-generic';
import { IsString } from 'class-validator';

export class GetLayoutUsageCommand extends EnvironmentCommand {
  @IsString()
  layoutIdOrInternalId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetLayoutUsageCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/get-layout-usage/get-layout-usage.usecase.ts
Tamaño: 2222 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { InstrumentUsecase } from '@novu/application-generic';
import { ControlValuesRepository, NotificationTemplateRepository } from '@novu/dal';
import { ControlValuesLevelEnum } from '@novu/shared';
import { GetLayoutUsageResponseDto, WorkflowInfoDto } from '../../dtos';
import { GetLayoutCommand, GetLayoutUseCase } from '../get-layout';
import { GetLayoutUsageCommand } from './get-layout-usage.command';

@Injectable()
export class GetLayoutUsageUseCase {
  constructor(
    private controlValuesRepository: ControlValuesRepository,
    private notificationTemplateRepository: NotificationTemplateRepository,
    private getLayoutUseCase: GetLayoutUseCase
  ) {}

  @InstrumentUsecase()
  async execute(command: GetLayoutUsageCommand): Promise<GetLayoutUsageResponseDto> {
    // First, resolve the layout to get its internal ID
    const layout = await this.getLayoutUseCase.execute(
      GetLayoutCommand.create({
        layoutIdOrInternalId: command.layoutIdOrInternalId,
        environmentId: command.environmentId,
        organizationId: command.organizationId,
        skipAdditionalFields: true,
      })
    );

    const workflows: WorkflowInfoDto[] = [];

    // Get control values that reference this layout
    const controlValues = await this.controlValuesRepository.find({
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
      level: ControlValuesLevelEnum.STEP_CONTROLS,
      'controls.layoutId': layout.layoutId,
    });

    // Get unique workflow IDs from the control values
    const workflowIds = [...new Set(controlValues.map((cv) => cv._workflowId).filter(Boolean))] as string[];

    // Fetch workflow information for each workflow ID
    for (const workflowId of workflowIds) {
      try {
        const workflow = await this.notificationTemplateRepository.findById(workflowId, command.environmentId);

        if (workflow && workflow.triggers && workflow.triggers.length > 0) {
          workflows.push({
            name: workflow.name,
            workflowId: workflow.triggers[0].identifier,
          });
        }
      } catch (error) {}
    }

    return {
      workflows,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - workflowIds([...new Set(controlValues.map((cv))
Declaraciones 'export' encontradas:
- export class GetLayoutUsageUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/get-layout-usage/index.ts
Tamaño: 88 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './get-layout-usage.command';
export * from './get-layout-usage.usecase';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/get-layout/get-layout.command.ts
Tamaño: 372 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentCommand } from '@novu/application-generic';
import { IsBoolean, IsOptional, IsString } from 'class-validator';

export class GetLayoutCommand extends EnvironmentCommand {
  @IsString()
  @IsOptional()
  layoutIdOrInternalId?: string;

  @IsBoolean()
  @IsOptional()
  skipAdditionalFields?: boolean;

  @IsString()
  @IsOptional()
  userId?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetLayoutCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/get-layout/get-layout.use-case.spec.ts
Tamaño: 9714 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  AnalyticsService,
  GetLayoutCommand as GetLayoutCommandV1,
  GetLayoutUseCase as GetLayoutUseCaseV1,
} from '@novu/application-generic';
import { ControlValuesRepository } from '@novu/dal';
import { ChannelTypeEnum, ControlValuesLevelEnum, ResourceOriginEnum, ResourceTypeEnum } from '@novu/shared';
import { expect } from 'chai';
import sinon from 'sinon';
import { LayoutVariablesSchemaUseCase } from '../layout-variables-schema';
import { GetLayoutCommand } from './get-layout.command';
import { GetLayoutUseCase } from './get-layout.use-case';

describe('GetLayoutUseCase', () => {
  let getLayoutUseCaseV1Mock: sinon.SinonStubbedInstance<GetLayoutUseCaseV1>;
  let controlValuesRepositoryMock: sinon.SinonStubbedInstance<ControlValuesRepository>;
  let layoutVariablesSchemaUseCaseMock: sinon.SinonStubbedInstance<LayoutVariablesSchemaUseCase>;
  let analyticsServiceMock: sinon.SinonStubbedInstance<AnalyticsService>;
  let getLayoutUseCase: GetLayoutUseCase;

  const mockUser = {
    _id: 'user_id',
    environmentId: 'env_id',
    organizationId: 'org_id',
  };

  const mockLayout = {
    _id: 'layout_id',
    identifier: 'layout_identifier',
    name: 'Test Layout',
    isDefault: false,
    createdAt: '2023-01-01T00:00:00Z',
    updatedAt: '2023-01-01T00:00:00Z',
    _environmentId: 'env_id',
    _organizationId: 'org_id',
    origin: ResourceOriginEnum.NOVU_CLOUD,
    type: ResourceTypeEnum.BRIDGE,
    channel: ChannelTypeEnum.EMAIL,
    controls: {
      dataSchema: {},
      uiSchema: {},
    },
  };

  const mockControlValues = {
    _id: 'control_values_id',
    _environmentId: 'env_id',
    _organizationId: 'org_id',
    _layoutId: 'layout_id',
    level: ControlValuesLevelEnum.LAYOUT_CONTROLS,
    controls: {
      email: {
        body: '<html><body>{{content}}</body></html>',
      },
    },
  };

  const mockVariablesSchema = {
    type: 'object',
    properties: {
      body: {
        type: 'string',
      },
    },
  };

  beforeEach(() => {
    getLayoutUseCaseV1Mock = sinon.createStubInstance(GetLayoutUseCaseV1);
    controlValuesRepositoryMock = sinon.createStubInstance(ControlValuesRepository);
    layoutVariablesSchemaUseCaseMock = sinon.createStubInstance(LayoutVariablesSchemaUseCase);
    analyticsServiceMock = sinon.createStubInstance(AnalyticsService);

    getLayoutUseCase = new GetLayoutUseCase(
      getLayoutUseCaseV1Mock as any,
      controlValuesRepositoryMock as any,
      layoutVariablesSchemaUseCaseMock as any,
      analyticsServiceMock as any
    );

    // Default mocks
    getLayoutUseCaseV1Mock.execute.resolves(mockLayout as any);
    controlValuesRepositoryMock.findOne.resolves(mockControlValues as any);
    layoutVariablesSchemaUseCaseMock.execute.resolves(mockVariablesSchema as any);
  });

  afterEach(() => {
    sinon.restore();
  });

  describe('execute', () => {
    it('should successfully get layout with control values', async () => {
      const command = GetLayoutCommand.create({
        layoutIdOrInternalId: 'layout_identifier',
        environmentId: 'env_id',
        organizationId: 'org_id',
        userId: 'user_id',
      });

      const result = await getLayoutUseCase.execute(command);

      expect(result).to.deep.include({
        _id: 'layout_id',
        layoutId: 'layout_identifier',
        name: 'Test Layout',
        isDefault: false,
        origin: ResourceOriginEnum.NOVU_CLOUD,
        type: ResourceTypeEnum.BRIDGE,
      });

      expect(result.controls).to.exist;
      expect(result.controls.values?.email).to.deep.equal(mockControlValues.controls.email);
      expect(result.variables).to.deep.equal(mockVariablesSchema);

      // Verify v1 use case was called with correct parameters
      expect(getLayoutUseCaseV1Mock.execute.calledOnce).to.be.true;
      const v1Command = getLayoutUseCaseV1Mock.execute.firstCall.args[0];
      expect(v1Command.layoutIdOrInternalId).to.equal('layout_identifier');
      expect(v1Command.environmentId).to.equal('env_id');
      expect(v1Command.organizationId).to.equal('org_id');
      expect(v1Command.type).to.equal(ResourceTypeEnum.BRIDGE);
      expect(v1Command.origin).to.equal(ResourceOriginEnum.NOVU_CLOUD);
    });

    it('should get layout without control values when none exist', async () => {
      controlValuesRepositoryMock.findOne.resolves(null);

      const command = GetLayoutCommand.create({
        layoutIdOrInternalId: 'layout_identifier',
        environmentId: 'env_id',
        organizationId: 'org_id',
        userId: 'user_id',
      });

      const result = await getLayoutUseCase.execute(command);

      expect(result.controls.values).to.deep.equal({});
      expect(result.variables).to.deep.equal(mockVariablesSchema);

      // Verify control values repository was called with correct parameters
      expect(controlValuesRepositoryMock.findOne.calledOnce).to.be.true;
      expect(controlValuesRepositoryMock.findOne.firstCall.args[0]).to.deep.equal({
        _environmentId: 'env_id',
        _organizationId: 'org_id',
        _layoutId: 'layout_id',
        level: ControlValuesLevelEnum.LAYOUT_CONTROLS,
      });
    });

    it('should call layout variables schema use case', async () => {
      const command = GetLayoutCommand.create({
        layoutIdOrInternalId: 'layout_identifier',
        environmentId: 'env_id',
        organizationId: 'org_id',
        userId: 'user_id',
      });

      await getLayoutUseCase.execute(command);

      expect(layoutVariablesSchemaUseCaseMock.execute.calledOnce).to.be.true;
      const schemaCommand = layoutVariablesSchemaUseCaseMock.execute.firstCall.args[0];
      expect(schemaCommand.environmentId).to.equal('env_id');
      expect(schemaCommand.organizationId).to.equal('org_id');
    });

    it('should track analytics event', async () => {
      const command = GetLayoutCommand.create({
        layoutIdOrInternalId: 'layout_identifier',
        environmentId: 'env_id',
        organizationId: 'org_id',
        userId: 'user_id',
      });

      await getLayoutUseCase.execute(command);

      expect(analyticsServiceMock.track.calledOnce).to.be.true;
      expect(analyticsServiceMock.track.firstCall.args[0]).to.equal('Get layout - [Layouts]');
      expect(analyticsServiceMock.track.firstCall.args[1]).to.equal('user_id');
      expect(analyticsServiceMock.track.firstCall.args[2]).to.deep.equal({
        _organizationId: 'org_id',
        _environmentId: 'env_id',
        layoutId: 'layout_id',
      });
    });

    it('should handle empty control values controls', async () => {
      const controlValuesWithEmptyControls = {
        ...mockControlValues,
        controls: undefined,
      };
      controlValuesRepositoryMock.findOne.resolves(controlValuesWithEmptyControls as any);

      const command = GetLayoutCommand.create({
        layoutIdOrInternalId: 'layout_identifier',
        environmentId: 'env_id',
        organizationId: 'org_id',
        userId: 'user_id',
      });

      const result = await getLayoutUseCase.execute(command);

      expect(result.controls.values).to.deep.equal({});
    });

    it('should pass through layout properties correctly', async () => {
      const defaultLayout = {
        ...mockLayout,
        isDefault: true,
        name: 'Default Layout',
      };
      getLayoutUseCaseV1Mock.execute.resolves(defaultLayout as any);

      const command = GetLayoutCommand.create({
        layoutIdOrInternalId: 'default_layout',
        environmentId: 'env_id',
        organizationId: 'org_id',
        userId: 'user_id',
      });

      const result = await getLayoutUseCase.execute(command);

      expect(result.isDefault).to.be.true;
      expect(result.name).to.equal('Default Layout');
      expect(result.createdAt).to.equal('2023-01-01T00:00:00Z');
      expect(result.updatedAt).to.equal('2023-01-01T00:00:00Z');
    });

    it('should propagate error from v1 use case', async () => {
      const error = new Error('Layout not found');
      getLayoutUseCaseV1Mock.execute.rejects(error);

      const command = GetLayoutCommand.create({
        layoutIdOrInternalId: 'non_existent',
        environmentId: 'env_id',
        organizationId: 'org_id',
        userId: 'user_id',
      });

      try {
        await getLayoutUseCase.execute(command);
        expect.fail('Should have thrown an error');
      } catch (thrownError) {
        expect(thrownError.message).to.equal('Layout not found');
      }
    });

    it('should propagate error from control values repository', async () => {
      const error = new Error('Database error');
      controlValuesRepositoryMock.findOne.rejects(error);

      const command = GetLayoutCommand.create({
        layoutIdOrInternalId: 'layout_identifier',
        environmentId: 'env_id',
        organizationId: 'org_id',
        userId: 'user_id',
      });

      try {
        await getLayoutUseCase.execute(command);
        expect.fail('Should have thrown an error');
      } catch (thrownError) {
        expect(thrownError.message).to.equal('Database error');
      }
    });

    it('should propagate error from layout variables schema use case', async () => {
      const error = new Error('Schema error');
      layoutVariablesSchemaUseCaseMock.execute.rejects(error);

      const command = GetLayoutCommand.create({
        layoutIdOrInternalId: 'layout_identifier',
        environmentId: 'env_id',
        organizationId: 'org_id',
        userId: 'user_id',
      });

      try {
        await getLayoutUseCase.execute(command);
        expect.fail('Should have thrown an error');
      } catch (thrownError) {
        expect(thrownError.message).to.equal('Schema error');
      }
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - mockVariablesSchema({
    type: 'object',
    properties: {
      body: {
        type: 'string',
      },
    },
  };

...)
 - getLayoutUseCase(new GetLayoutUseCase(
      getLayoutUseCaseV1Mock as any,
      controlValuesRepositoryMock as any,...)
 - v1Command(getLayoutUseCaseV1Mock.execute.firstCall.args[0];
      expect(v1Command.layoutIdOrInternalId).to.eq...)
 - result(await getLayoutUseCase.execute(command);

      expect(result.controls.values).to.deep.equal({});
  ...)
 - schemaCommand(layoutVariablesSchemaUseCaseMock.execute.firstCall.args[0];
      expect(schemaCommand.environmentId...)
 - command(GetLayoutCommand.create({
        layoutIdOrInternalId: 'layout_identifier',
        environmentId: ...)
 - result(await getLayoutUseCase.execute(command);

      expect(result.controls.values).to.deep.equal({});
  ...)
 - result(await getLayoutUseCase.execute(command);

      expect(result.isDefault).to.be.true;
      expect(re...)
 - command(GetLayoutCommand.create({
        layoutIdOrInternalId: 'non_existent',
        environmentId: 'env_...)
 - command(GetLayoutCommand.create({
        layoutIdOrInternalId: 'layout_identifier',
        environmentId: ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/get-layout/get-layout.use-case.ts
Tamaño: 2433 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import {
  AnalyticsService,
  GetLayoutCommand as GetLayoutCommandV1,
  GetLayoutUseCase as GetLayoutUseCaseV1,
} from '@novu/application-generic';
import { ControlValuesRepository } from '@novu/dal';
import { ControlValuesLevelEnum, ResourceOriginEnum, ResourceTypeEnum } from '@novu/shared';
import { LayoutResponseDto } from '../../dtos';
import { LayoutVariablesSchemaUseCase } from '../layout-variables-schema';
import { LayoutVariablesSchemaCommand } from '../layout-variables-schema/layout-variables-schema.command';
import { mapToResponseDto } from '../mapper';
import { GetLayoutCommand } from './get-layout.command';

@Injectable()
export class GetLayoutUseCase {
  constructor(
    private getLayoutUseCaseV1: GetLayoutUseCaseV1,
    private controlValuesRepository: ControlValuesRepository,
    private layoutVariablesSchemaUseCase: LayoutVariablesSchemaUseCase,
    private analyticsService: AnalyticsService
  ) {}

  async execute(command: GetLayoutCommand): Promise<LayoutResponseDto> {
    const layout = await this.getLayoutUseCaseV1.execute(
      GetLayoutCommandV1.create({
        layoutIdOrInternalId: command.layoutIdOrInternalId,
        environmentId: command.environmentId,
        organizationId: command.organizationId,
        type: ResourceTypeEnum.BRIDGE,
        origin: ResourceOriginEnum.NOVU_CLOUD,
      })
    );

    this.analyticsService.track('Get layout - [Layouts]', command.userId ?? command.environmentId, {
      _organizationId: command.organizationId,
      _environmentId: command.environmentId,
      layoutId: layout._id!,
    });

    if (command.skipAdditionalFields) {
      return mapToResponseDto({
        layout,
      });
    }

    const controlValues = await this.controlValuesRepository.findOne({
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
      _layoutId: layout._id!,
      level: ControlValuesLevelEnum.LAYOUT_CONTROLS,
    });

    const layoutVariablesSchema = await this.layoutVariablesSchemaUseCase.execute(
      LayoutVariablesSchemaCommand.create({
        environmentId: command.environmentId,
        organizationId: command.organizationId,
        controlValues: controlValues?.controls ?? {},
      })
    );

    return mapToResponseDto({
      layout,
      controlValues: controlValues?.controls ?? null,
      variables: layoutVariablesSchema,
    });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetLayoutUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/get-layout/index.ts
Tamaño: 77 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './get-layout.command';
export * from './get-layout.use-case';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/layout-variables-schema/index.ts
Tamaño: 102 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './layout-variables-schema.command';
export * from './layout-variables-schema.usecase';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/layout-variables-schema/layout-variables-schema.command.ts
Tamaño: 238 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentCommand } from '@novu/application-generic';
import { IsObject } from 'class-validator';

export class LayoutVariablesSchemaCommand extends EnvironmentCommand {
  @IsObject()
  controlValues: Record<string, unknown>;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class LayoutVariablesSchemaCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/layout-variables-schema/layout-variables-schema.usecase.ts
Tamaño: 2026 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { FeatureFlagsService, InstrumentUsecase } from '@novu/application-generic';
import { JsonSchemaTypeEnum } from '@novu/dal';
import { FeatureFlagsKeysEnum, LAYOUT_CONTENT_VARIABLE } from '@novu/shared';

import { JSONSchemaDto } from '../../../shared/dtos/json-schema.dto';
import { CreateVariablesObjectCommand } from '../../../shared/usecases/create-variables-object/create-variables-object.command';
import { CreateVariablesObject } from '../../../shared/usecases/create-variables-object/create-variables-object.usecase';
import { buildContextSchema, buildSubscriberSchema } from '../../../shared/utils/create-schema';
import { LayoutVariablesSchemaCommand } from './layout-variables-schema.command';

@Injectable()
export class LayoutVariablesSchemaUseCase {
  constructor(
    private readonly createVariablesObject: CreateVariablesObject,
    private readonly featureFlagsService: FeatureFlagsService
  ) {}

  @InstrumentUsecase()
  async execute(command: LayoutVariablesSchemaCommand): Promise<JSONSchemaDto> {
    const { controlValues } = command;

    const { subscriber, context } = await this.createVariablesObject.execute(
      CreateVariablesObjectCommand.create({
        environmentId: command.environmentId,
        organizationId: command.organizationId,
        controlValues: Object.values(controlValues?.email ?? {}),
      })
    );

    const isContextEnabled = await this.featureFlagsService.getFlag({
      key: FeatureFlagsKeysEnum.IS_CONTEXT_ENABLED,
      organization: { _id: command.organizationId },
      environment: { _id: command.environmentId },
      defaultValue: false,
    });

    return {
      type: JsonSchemaTypeEnum.OBJECT,
      properties: {
        subscriber: buildSubscriberSchema(subscriber),
        [LAYOUT_CONTENT_VARIABLE]: {
          type: JsonSchemaTypeEnum.STRING,
        },
        ...(isContextEnabled ? { context: buildContextSchema(context) } : {}),
      },
      additionalProperties: false,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class LayoutVariablesSchemaUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/list-layouts/index.ts
Tamaño: 81 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './list-layouts.command';
export * from './list-layouts.use-case';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/list-layouts/list-layouts.command.ts
Tamaño: 242 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { PaginatedListCommand } from '@novu/application-generic';
import { IsOptional, IsString } from 'class-validator';

export class ListLayoutsCommand extends PaginatedListCommand {
  @IsString()
  @IsOptional()
  searchQuery?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ListLayoutsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/list-layouts/list-layouts.use-case.spec.ts
Tamaño: 13353 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { LayoutEntity, LayoutRepository } from '@novu/dal';
import { ChannelTypeEnum, DirectionEnum, ResourceOriginEnum, ResourceTypeEnum } from '@novu/shared';
import { expect } from 'chai';
import sinon from 'sinon';
import * as mapperModule from '../mapper';
import { ListLayoutsCommand } from './list-layouts.command';
import { ListLayoutsUseCase } from './list-layouts.use-case';

describe('ListLayoutsUseCase', () => {
  let layoutRepositoryMock: sinon.SinonStubbedInstance<LayoutRepository>;
  let listLayoutsUseCase: ListLayoutsUseCase;
  let mapToResponseDtoStub: sinon.SinonStub;

  const mockUser = {
    _id: 'user_id',
    environmentId: 'env_id',
    organizationId: 'org_id',
  };

  const mockLayoutEntity: LayoutEntity = {
    _id: 'layout_id_1',
    identifier: 'layout_identifier_1',
    name: 'Test Layout 1',
    isDefault: false,
    channel: ChannelTypeEnum.EMAIL,
    content: '<html><body>{{content}}</body></html>',
    contentType: 'customHtml',
    updatedAt: '2023-01-02T00:00:00.000Z',
    createdAt: '2023-01-01T00:00:00.000Z',
    _environmentId: 'env_id',
    _organizationId: 'org_id',
    _creatorId: 'creator_id',
    deleted: false,
    origin: ResourceOriginEnum.NOVU_CLOUD,
    type: ResourceTypeEnum.BRIDGE,
    controls: {
      schema: {},
      uiSchema: {},
    },
  };

  const mockLayoutEntity2: LayoutEntity = {
    _id: 'layout_id_2',
    identifier: 'layout_identifier_2',
    name: 'Test Layout 2',
    isDefault: true,
    channel: ChannelTypeEnum.EMAIL,
    content: '<html><body>{{content}}</body></html>',
    contentType: 'customHtml',
    updatedAt: '2023-01-02T00:00:00.000Z',
    createdAt: '2023-01-01T00:00:00.000Z',
    _environmentId: 'env_id',
    _organizationId: 'org_id',
    _creatorId: 'creator_id',
    deleted: false,
    origin: ResourceOriginEnum.NOVU_CLOUD,
    type: ResourceTypeEnum.BRIDGE,
    controls: {
      schema: {},
      uiSchema: {},
    },
  };

  const mockRepositoryResponse = {
    data: [mockLayoutEntity, mockLayoutEntity2],
    totalCount: 2,
  };

  const mockLayoutResponseDto = {
    _id: 'layout_id_1',
    layoutId: 'layout_identifier_1',
    name: 'Test Layout 1',
    isDefault: false,
    updatedAt: '2023-01-02T00:00:00.000Z',
    createdAt: '2023-01-01T00:00:00.000Z',
    origin: ResourceOriginEnum.NOVU_CLOUD,
    type: ResourceTypeEnum.BRIDGE,
    variables: {},
    issues: undefined,
    controls: {
      uiSchema: {},
      values: {},
    },
  };

  const mockLayoutResponseDto2 = {
    _id: 'layout_id_2',
    layoutId: 'layout_identifier_2',
    name: 'Test Layout 2',
    isDefault: true,
    updatedAt: '2023-01-04T00:00:00.000Z',
    createdAt: '2023-01-03T00:00:00.000Z',
    origin: ResourceOriginEnum.NOVU_CLOUD,
    type: ResourceTypeEnum.BRIDGE,
    variables: {},
    issues: undefined,
    controls: {
      uiSchema: {},
      values: {},
    },
  };

  beforeEach(() => {
    layoutRepositoryMock = sinon.createStubInstance(LayoutRepository);
    mapToResponseDtoStub = sinon.stub(mapperModule, 'mapToResponseDto');

    listLayoutsUseCase = new ListLayoutsUseCase(layoutRepositoryMock as any);

    // Default mocks
    layoutRepositoryMock.getV2List.resolves(mockRepositoryResponse);
    mapToResponseDtoStub.onFirstCall().returns(mockLayoutResponseDto);
    mapToResponseDtoStub.onSecondCall().returns(mockLayoutResponseDto2);
  });

  afterEach(() => {
    sinon.restore();
  });

  describe('execute', () => {
    it('should successfully list layouts with default parameters', async () => {
      const command = ListLayoutsCommand.create({
        user: mockUser as any,
        offset: 0,
        limit: 10,
        orderBy: 'createdAt',
        orderDirection: DirectionEnum.DESC,
      });

      const result = await listLayoutsUseCase.execute(command);

      expect(result).to.deep.equal({
        layouts: [mockLayoutResponseDto, mockLayoutResponseDto2],
        totalCount: 2,
      });

      // Verify repository was called with correct parameters
      expect(layoutRepositoryMock.getV2List.calledOnce).to.be.true;
      const repositoryCall = layoutRepositoryMock.getV2List.firstCall.args[0];
      expect(repositoryCall).to.deep.equal({
        organizationId: 'org_id',
        environmentId: 'env_id',
        skip: 0,
        limit: 10,
        searchQuery: undefined,
        orderBy: 'createdAt',
        orderDirection: DirectionEnum.DESC,
      });
    });

    it('should handle search query parameter', async () => {
      const command = ListLayoutsCommand.create({
        user: mockUser as any,
        offset: 0,
        limit: 10,
        orderBy: 'name',
        orderDirection: DirectionEnum.ASC,
        searchQuery: 'test search',
      });

      await listLayoutsUseCase.execute(command);

      const repositoryCall = layoutRepositoryMock.getV2List.firstCall.args[0];
      expect(repositoryCall.searchQuery).to.equal('test search');
      expect(repositoryCall.orderBy).to.equal('name');
      expect(repositoryCall.orderDirection).to.equal(DirectionEnum.ASC);
    });

    it('should handle pagination parameters', async () => {
      const command = ListLayoutsCommand.create({
        user: mockUser as any,
        offset: 20,
        limit: 5,
        orderBy: 'updatedAt',
        orderDirection: DirectionEnum.DESC,
      });

      await listLayoutsUseCase.execute(command);

      const repositoryCall = layoutRepositoryMock.getV2List.firstCall.args[0];
      expect(repositoryCall.skip).to.equal(20);
      expect(repositoryCall.limit).to.equal(5);
      expect(repositoryCall.orderBy).to.equal('updatedAt');
    });

    it('should return empty result when repository returns null data', async () => {
      layoutRepositoryMock.getV2List.resolves({ data: null, totalCount: 0 });

      const command = ListLayoutsCommand.create({
        user: mockUser as any,
        offset: 0,
        limit: 10,
        orderBy: 'createdAt',
        orderDirection: DirectionEnum.DESC,
      });

      const result = await listLayoutsUseCase.execute(command);

      expect(result).to.deep.equal({
        layouts: [],
        totalCount: 0,
      });
    });

    it('should return empty result when repository returns undefined data', async () => {
      layoutRepositoryMock.getV2List.resolves({ data: undefined, totalCount: 0 });

      const command = ListLayoutsCommand.create({
        user: mockUser as any,
        offset: 0,
        limit: 10,
        orderBy: 'createdAt',
        orderDirection: DirectionEnum.DESC,
      });

      const result = await listLayoutsUseCase.execute(command);

      expect(result).to.deep.equal({
        layouts: [],
        totalCount: 0,
      });
    });

    it('should handle empty data array', async () => {
      layoutRepositoryMock.getV2List.resolves({ data: [], totalCount: 0 });

      const command = ListLayoutsCommand.create({
        user: mockUser as any,
        offset: 0,
        limit: 10,
        orderBy: 'createdAt',
        orderDirection: DirectionEnum.DESC,
      });

      const result = await listLayoutsUseCase.execute(command);

      expect(result).to.deep.equal({
        layouts: [],
        totalCount: 0,
      });
    });

    it('should propagate repository errors', async () => {
      const error = new Error('Database connection failed');
      layoutRepositoryMock.getV2List.rejects(error);

      const command = ListLayoutsCommand.create({
        user: mockUser as any,
        offset: 0,
        limit: 10,
        orderBy: 'createdAt',
        orderDirection: DirectionEnum.DESC,
      });

      try {
        await listLayoutsUseCase.execute(command);
        expect.fail('Should have thrown an error');
      } catch (thrownError) {
        expect(thrownError.message).to.equal('Database connection failed');
      }
    });

    it('should call mapToResponseDto for each layout', async () => {
      const command = ListLayoutsCommand.create({
        user: mockUser as any,
        offset: 0,
        limit: 10,
        orderBy: 'createdAt',
        orderDirection: DirectionEnum.DESC,
      });

      await listLayoutsUseCase.execute(command);

      expect(mapToResponseDtoStub.calledTwice).to.be.true;

      // Verify first call
      const firstCallArgs = mapToResponseDtoStub.firstCall.args[0];
      expect(firstCallArgs.layout._id).to.equal('layout_id_1');
      expect(firstCallArgs.layout.identifier).to.equal('layout_identifier_1');
      expect(firstCallArgs.controlValues).to.be.null;
      expect(firstCallArgs.variables).to.deep.equal({});

      // Verify second call
      const secondCallArgs = mapToResponseDtoStub.secondCall.args[0];
      expect(secondCallArgs.layout._id).to.equal('layout_id_2');
      expect(secondCallArgs.layout.identifier).to.equal('layout_identifier_2');
      expect(secondCallArgs.controlValues).to.be.null;
      expect(secondCallArgs.variables).to.deep.equal({});
    });

    it('should handle single layout in result', async () => {
      const singleLayoutResponse = {
        data: [mockLayoutEntity],
        totalCount: 1,
      };
      layoutRepositoryMock.getV2List.resolves(singleLayoutResponse);
      mapToResponseDtoStub.onFirstCall().returns(mockLayoutResponseDto);

      const command = ListLayoutsCommand.create({
        user: mockUser as any,
        offset: 0,
        limit: 10,
        orderBy: 'createdAt',
        orderDirection: DirectionEnum.DESC,
      });

      const result = await listLayoutsUseCase.execute(command);

      expect(result).to.deep.equal({
        layouts: [mockLayoutResponseDto],
        totalCount: 1,
      });
      expect(mapToResponseDtoStub.calledOnce).to.be.true;
    });

    it('should preserve totalCount from repository response', async () => {
      const responseWithDifferentTotal = {
        data: [mockLayoutEntity],
        totalCount: 100, // More than actual data length
      };
      layoutRepositoryMock.getV2List.resolves(responseWithDifferentTotal);
      mapToResponseDtoStub.onFirstCall().returns(mockLayoutResponseDto);

      const command = ListLayoutsCommand.create({
        user: mockUser as any,
        offset: 50,
        limit: 10,
        orderBy: 'createdAt',
        orderDirection: DirectionEnum.DESC,
      });

      const result = await listLayoutsUseCase.execute(command);

      expect(result.totalCount).to.equal(100);
      expect(result.layouts).to.have.length(1);
    });

    it('should handle layouts with deleted flag correctly', async () => {
      const deletedLayoutEntity = {
        ...mockLayoutEntity,
        deleted: true,
      };

      const responseWithDeletedLayout = {
        data: [deletedLayoutEntity],
        totalCount: 1,
      };
      layoutRepositoryMock.getV2List.resolves(responseWithDeletedLayout);

      const command = ListLayoutsCommand.create({
        user: mockUser as any,
        offset: 0,
        limit: 10,
        orderBy: 'createdAt',
        orderDirection: DirectionEnum.DESC,
      });

      await listLayoutsUseCase.execute(command);

      // Verify the mapFromEntity method correctly maps deleted flag
      const mapperCall = mapToResponseDtoStub.firstCall.args[0];
      expect(mapperCall.layout.isDeleted).to.be.true;
    });

    it('should handle layouts without controls', async () => {
      const layoutWithoutControls = {
        ...mockLayoutEntity,
        controls: undefined,
      };

      const responseWithoutControls = {
        data: [layoutWithoutControls],
        totalCount: 1,
      };
      layoutRepositoryMock.getV2List.resolves(responseWithoutControls);

      const command = ListLayoutsCommand.create({
        user: mockUser as any,
        offset: 0,
        limit: 10,
        orderBy: 'createdAt',
        orderDirection: DirectionEnum.DESC,
      });

      await listLayoutsUseCase.execute(command);

      // Verify the mapFromEntity method handles missing controls
      const mapperCall = mapToResponseDtoStub.firstCall.args[0];
      expect(mapperCall.layout.controls).to.deep.equal({});
    });

    it('should correctly map entity properties to DTO', async () => {
      const command = ListLayoutsCommand.create({
        user: mockUser as any,
        offset: 0,
        limit: 10,
        orderBy: 'createdAt',
        orderDirection: DirectionEnum.DESC,
      });

      await listLayoutsUseCase.execute(command);

      const mapperCall = mapToResponseDtoStub.firstCall.args[0];
      const layoutDto = mapperCall.layout;

      // Verify all entity properties are correctly mapped
      expect(layoutDto._id).to.equal(mockLayoutEntity._id);
      expect(layoutDto._organizationId).to.equal(mockLayoutEntity._organizationId);
      expect(layoutDto._environmentId).to.equal(mockLayoutEntity._environmentId);
      expect(layoutDto.identifier).to.equal(mockLayoutEntity.identifier);
      expect(layoutDto.name).to.equal(mockLayoutEntity.name);
      expect(layoutDto.isDefault).to.equal(mockLayoutEntity.isDefault);
      expect(layoutDto.channel).to.equal(mockLayoutEntity.channel);
      expect(layoutDto.content).to.equal(mockLayoutEntity.content);
      expect(layoutDto.contentType).to.equal(mockLayoutEntity.contentType);
      expect(layoutDto.isDeleted).to.equal(mockLayoutEntity.deleted);
      expect(layoutDto.origin).to.equal(mockLayoutEntity.origin);
      expect(layoutDto.type).to.equal(mockLayoutEntity.type);
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - mockLayoutResponseDto2({
    _id: 'layout_id_2',
    layoutId: 'layout_identifier_2',
    name: 'Test Layout 2',
    isDefa...)
 - listLayoutsUseCase(new ListLayoutsUseCase(layoutRepositoryMock as any);

    // Default mocks
    layoutRepositoryMock....)
 - repositoryCall(layoutRepositoryMock.getV2List.firstCall.args[0];
      expect(repositoryCall).to.deep.equal({
     ...)
 - repositoryCall(layoutRepositoryMock.getV2List.firstCall.args[0];
      expect(repositoryCall.searchQuery).to.equal(...)
 - repositoryCall(layoutRepositoryMock.getV2List.firstCall.args[0];
      expect(repositoryCall.skip).to.equal(20);
  ...)
 - result(await listLayoutsUseCase.execute(command);

      expect(result).to.deep.equal({
        layouts: []...)
 - result(await listLayoutsUseCase.execute(command);

      expect(result).to.deep.equal({
        layouts: []...)
 - result(await listLayoutsUseCase.execute(command);

      expect(result).to.deep.equal({
        layouts: []...)
 - command(ListLayoutsCommand.create({
        user: mockUser as any,
        offset: 0,
        limit: 10,
   ...)
 - secondCallArgs(mapToResponseDtoStub.secondCall.args[0];
      expect(secondCallArgs.layout._id).to.equal('layout_id...)
 - result(await listLayoutsUseCase.execute(command);

      expect(result).to.deep.equal({
        layouts: [m...)
 - result(await listLayoutsUseCase.execute(command);

      expect(result.totalCount).to.equal(100);
      exp...)
 - mapperCall(mapToResponseDtoStub.firstCall.args[0];
      expect(mapperCall.layout.isDeleted).to.be.true;
    })...)
 - mapperCall(mapToResponseDtoStub.firstCall.args[0];
      expect(mapperCall.layout.controls).to.deep.equal({});
...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/list-layouts/list-layouts.use-case.ts
Tamaño: 1788 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { InstrumentUsecase } from '@novu/application-generic';
import { LayoutEntity, LayoutRepository } from '@novu/dal';
import { LayoutDto } from '../../../layouts-v1/dtos/layout.dto';
import { LayoutResponseDto, ListLayoutResponseDto } from '../../dtos';
import { mapToResponseDto } from '../mapper';
import { ListLayoutsCommand } from './list-layouts.command';

@Injectable()
export class ListLayoutsUseCase {
  constructor(private layoutRepository: LayoutRepository) {}

  @InstrumentUsecase()
  async execute(command: ListLayoutsCommand): Promise<ListLayoutResponseDto> {
    const res = await this.layoutRepository.getV2List({
      organizationId: command.user.organizationId,
      environmentId: command.user.environmentId,
      skip: command.offset,
      limit: command.limit,
      searchQuery: command.searchQuery,
      orderBy: command.orderBy ? command.orderBy : 'createdAt',
      orderDirection: command.orderDirection,
    });

    if (res.data === null || res.data === undefined) {
      return { layouts: [], totalCount: 0 };
    }

    const layoutDtos = res.data.map((layout) => this.mapLayoutToResponseDto(layout));

    return {
      layouts: layoutDtos,
      totalCount: res.totalCount,
    };
  }

  private mapLayoutToResponseDto(layout: LayoutEntity): LayoutResponseDto {
    const layoutDto = this.mapFromEntity(layout);

    return mapToResponseDto({
      layout: layoutDto,
      controlValues: null,
      variables: {},
    });
  }

  private mapFromEntity(layout: LayoutEntity): LayoutDto {
    return {
      ...layout,
      _id: layout._id,
      _organizationId: layout._organizationId,
      _environmentId: layout._environmentId,
      isDeleted: layout.deleted,
      controls: {},
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - layoutDtos(res.data.map((layout))
Declaraciones 'export' encontradas:
- export class ListLayoutsUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/preview-layout/index.ts
Tamaño: 84 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './preview-layout.command';
export * from './preview-layout.usecase';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/preview-layout/preview-layout.command.ts
Tamaño: 323 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentWithUserObjectCommand } from '@novu/application-generic';
import { LayoutPreviewRequestDto } from '../../dtos/layout-preview-request.dto';

export class PreviewLayoutCommand extends EnvironmentWithUserObjectCommand {
  layoutIdOrInternalId: string;
  layoutPreviewRequestDto: LayoutPreviewRequestDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class PreviewLayoutCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/preview-layout/preview-layout.usecase.spec.ts
Tamaño: 20803 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { LayoutControlType } from '@novu/application-generic';
import {
  ChannelTypeEnum,
  LAYOUT_PREVIEW_EMAIL_STEP,
  LAYOUT_PREVIEW_WORKFLOW_ID,
  ResourceOriginEnum,
} from '@novu/shared';
import { expect } from 'chai';
import sinon from 'sinon';
import { PreviewStep } from '../../../bridge/usecases/preview-step';
import { ControlValueSanitizerService } from '../../../shared/services/control-value-sanitizer.service';
import { CreateVariablesObject } from '../../../shared/usecases/create-variables-object';
import { PayloadMergerService } from '../../../workflows-v2/usecases/preview/services/payload-merger.service';
import { PreviewPayloadProcessorService } from '../../../workflows-v2/usecases/preview/services/preview-payload-processor.service';
import { GetLayoutUseCase } from '../get-layout';
import { PreviewLayoutCommand } from './preview-layout.command';
import { PreviewLayoutUsecase } from './preview-layout.usecase';
import { enhanceBodyForPreview } from './preview-utils';

describe('PreviewLayoutUsecase', () => {
  let getLayoutUseCaseMock: sinon.SinonStubbedInstance<GetLayoutUseCase>;
  let createVariablesObjectMock: sinon.SinonStubbedInstance<CreateVariablesObject>;
  let controlValueSanitizerMock: sinon.SinonStubbedInstance<ControlValueSanitizerService>;
  let payloadProcessorMock: sinon.SinonStubbedInstance<PreviewPayloadProcessorService>;
  let payloadMergerMock: sinon.SinonStubbedInstance<PayloadMergerService>;
  let previewStepUsecaseMock: sinon.SinonStubbedInstance<PreviewStep>;

  let previewLayoutUsecase: PreviewLayoutUsecase;

  const mockUser = {
    _id: 'user_id',
    environmentId: 'env_id',
    organizationId: 'org_id',
  };

  const mockLayout = {
    _id: 'layout_id',
    identifier: 'layout_identifier',
    name: 'Test Layout',
    controls: {
      values: {
        email: {
          body: '<html>{{content}}</html>',
          editorType: 'html',
        },
      },
    },
    variables: {
      name: { type: 'string', default: 'John' },
      email: { type: 'string', default: 'john@example.com' },
    },
  };

  const mockLayoutWithoutControls = {
    ...mockLayout,
    controls: {
      values: {},
    },
    variables: {},
  };

  const mockControlValues = {
    email: {
      body: '<html>Custom {{content}}</html>',
      editorType: 'html',
    },
  };

  const mockVariablesObject = {
    name: 'Jane',
    email: 'jane@example.com',
  };

  const mockSanitizedControls = {
    email: {
      body: '<html>Sanitized {{content}}</html>',
      editorType: 'html',
    },
  };

  const mockPreviewTemplateData = {
    controlValues: {
      email: {
        body: '<html>Processed {{content}}</html>',
        editorType: 'html',
      },
    } as LayoutControlType,
    payloadExample: {
      content: 'Test content',
      user: { name: 'Test User' },
    },
  };

  const mockPayloadExample = {
    content: 'Merged content',
    user: { name: 'Merged User' },
  };

  const mockCleanedPayloadExample = {
    payload: { content: 'Cleaned content' },
    subscriber: { email: 'test@example.com' },
  };

  const mockPreviewStepOutput = {
    outputs: {
      body: '<html>Final rendered content</html>',
    },
  };

  beforeEach(() => {
    getLayoutUseCaseMock = sinon.createStubInstance(GetLayoutUseCase);
    createVariablesObjectMock = sinon.createStubInstance(CreateVariablesObject);
    controlValueSanitizerMock = sinon.createStubInstance(ControlValueSanitizerService);
    payloadProcessorMock = sinon.createStubInstance(PreviewPayloadProcessorService);
    payloadMergerMock = sinon.createStubInstance(PayloadMergerService);
    previewStepUsecaseMock = sinon.createStubInstance(PreviewStep);

    previewLayoutUsecase = new PreviewLayoutUsecase(
      getLayoutUseCaseMock as any,
      createVariablesObjectMock as any,
      controlValueSanitizerMock as any,
      payloadProcessorMock as any,
      payloadMergerMock as any,
      previewStepUsecaseMock as any
    );

    // Default mocks setup
    getLayoutUseCaseMock.execute.resolves(mockLayout as any);
    createVariablesObjectMock.execute.resolves(mockVariablesObject);
    controlValueSanitizerMock.sanitizeControlsForPreview.returns(mockSanitizedControls);
    controlValueSanitizerMock.processControlValues.returns({
      previewTemplateData: mockPreviewTemplateData,
      sanitizedControls: mockSanitizedControls,
    });
    payloadMergerMock.mergePayloadExample.resolves(mockPayloadExample);
    payloadProcessorMock.cleanPreviewExamplePayload.returns(mockCleanedPayloadExample);
    previewStepUsecaseMock.execute.resolves(mockPreviewStepOutput as any);
  });

  afterEach(() => {
    sinon.restore();
  });

  describe('execute', () => {
    it('should successfully execute with provided control values', async () => {
      const command = PreviewLayoutCommand.create({
        user: mockUser as any,
        layoutIdOrInternalId: 'layout_id',
        layoutPreviewRequestDto: {
          controlValues: mockControlValues,
          previewPayload: { subscriber: { email: 'test@example.com' } },
        },
      });

      const result = await previewLayoutUsecase.execute(command);

      expect(result.result).to.deep.equal({
        preview: { body: '<html>Final rendered content</html>' },
        type: ChannelTypeEnum.EMAIL,
      });
      expect(result.previewPayloadExample).to.deep.equal(mockPayloadExample);
      expect(result.schema).to.exist;
      expect(result.schema?.type).to.equal('object');
      expect(result.schema?.properties).to.have.keys(['subscriber', 'context']);
    });

    it('should use layout control values when command control values are not provided', async () => {
      const command = PreviewLayoutCommand.create({
        user: mockUser as any,
        layoutIdOrInternalId: 'layout_id',
        layoutPreviewRequestDto: {},
      });

      await previewLayoutUsecase.execute(command);

      // Verify that layout control values were used
      expect(createVariablesObjectMock.execute.calledOnce).to.be.true;
      const createVariablesCall = createVariablesObjectMock.execute.firstCall.args[0];
      expect(createVariablesCall.controlValues).to.deep.equal(Object.values(mockLayout.controls.values.email));
    });

    it('should use empty object when both command and layout control values are missing', async () => {
      getLayoutUseCaseMock.execute.resolves(mockLayoutWithoutControls as any);

      const command = PreviewLayoutCommand.create({
        user: mockUser as any,
        layoutIdOrInternalId: 'layout_id',
        layoutPreviewRequestDto: {},
      });

      await previewLayoutUsecase.execute(command);

      // Verify empty control values were used
      expect(controlValueSanitizerMock.sanitizeControlsForPreview.calledOnce).to.be.true;
      const sanitizeCall = controlValueSanitizerMock.sanitizeControlsForPreview.firstCall.args[0];
      expect(sanitizeCall).to.deep.equal({});
    });

    it('should call all dependencies with correct parameters', async () => {
      const command = PreviewLayoutCommand.create({
        user: mockUser as any,
        layoutIdOrInternalId: 'layout_id',
        layoutPreviewRequestDto: {
          controlValues: mockControlValues,
          previewPayload: { subscriber: { email: 'test@example.com' } },
        },
      });

      await previewLayoutUsecase.execute(command);

      // Verify getLayoutUseCase call
      expect(getLayoutUseCaseMock.execute.calledOnce).to.be.true;
      const getLayoutCall = getLayoutUseCaseMock.execute.firstCall.args[0];
      expect(getLayoutCall).to.deep.equal({
        layoutIdOrInternalId: 'layout_id',
        environmentId: mockUser.environmentId,
        organizationId: mockUser.organizationId,
        userId: mockUser._id,
      });

      // Verify createVariablesObject call
      expect(createVariablesObjectMock.execute.calledOnce).to.be.true;
      const createVariablesCall = createVariablesObjectMock.execute.firstCall.args[0];
      expect(createVariablesCall.environmentId).to.equal(mockUser.environmentId);
      expect(createVariablesCall.organizationId).to.equal(mockUser.organizationId);
      expect(createVariablesCall.variableSchema).to.deep.equal(mockLayout.variables);

      // Verify controlValueSanitizer calls
      expect(controlValueSanitizerMock.sanitizeControlsForPreview.calledOnce).to.be.true;
      const sanitizeCall = controlValueSanitizerMock.sanitizeControlsForPreview.firstCall.args;
      expect(sanitizeCall[0]).to.deep.equal(mockControlValues);
      expect(sanitizeCall[1]).to.equal('layout');
      expect(sanitizeCall[2]).to.equal(ResourceOriginEnum.NOVU_CLOUD);

      expect(controlValueSanitizerMock.processControlValues.calledOnce).to.be.true;
      const processCall = controlValueSanitizerMock.processControlValues.firstCall.args;
      expect(processCall[0]).to.deep.equal(mockSanitizedControls);
      expect(processCall[1]).to.deep.equal(mockLayout.variables);
      expect(processCall[2]).to.deep.equal(mockVariablesObject);

      // Verify payloadMerger call
      expect(payloadMergerMock.mergePayloadExample.calledOnce).to.be.true;
      const mergeCall = payloadMergerMock.mergePayloadExample.firstCall.args[0];
      expect(mergeCall.payloadExample).to.deep.equal(mockPreviewTemplateData.payloadExample);
      expect(mergeCall.userPayloadExample).to.deep.equal(command.layoutPreviewRequestDto.previewPayload);
      expect(mergeCall.user).to.deep.equal(command.user);

      // Verify payloadProcessor call
      expect(payloadProcessorMock.cleanPreviewExamplePayload.calledOnceWith(mockPayloadExample)).to.be.true;

      // Verify previewStepUsecase call
      expect(previewStepUsecaseMock.execute.calledOnce).to.be.true;
      const previewCall = previewStepUsecaseMock.execute.firstCall.args[0];
      expect(previewCall.payload).to.deep.equal(mockCleanedPayloadExample.payload);
      expect(previewCall.subscriber).to.deep.equal(mockCleanedPayloadExample.subscriber);
      expect(previewCall.controls).to.deep.equal({
        subject: 'email-layout-preview',
        body: enhanceBodyForPreview(
          mockPreviewTemplateData.controlValues.email?.editorType ?? 'block',
          mockPreviewTemplateData.controlValues.email?.body ?? ''
        ),
        editorType: mockPreviewTemplateData.controlValues.email?.editorType,
      });
      expect(previewCall.environmentId).to.equal(mockUser.environmentId);
      expect(previewCall.organizationId).to.equal(mockUser.organizationId);
      expect(previewCall.stepId).to.equal(LAYOUT_PREVIEW_EMAIL_STEP);
      expect(previewCall.userId).to.equal(mockUser._id);
      expect(previewCall.workflowId).to.equal(LAYOUT_PREVIEW_WORKFLOW_ID);
      expect(previewCall.workflowOrigin).to.equal(ResourceOriginEnum.NOVU_CLOUD);
      expect(previewCall.state).to.deep.equal([]);
    });

    it('should handle missing previewPayload gracefully', async () => {
      const command = PreviewLayoutCommand.create({
        user: mockUser as any,
        layoutIdOrInternalId: 'layout_id',
        layoutPreviewRequestDto: {
          controlValues: mockControlValues,
        },
      });

      await previewLayoutUsecase.execute(command);

      const mergeCall = payloadMergerMock.mergePayloadExample.firstCall.args[0];
      expect(mergeCall.userPayloadExample).to.be.undefined;
    });

    it('should handle missing variables schema', async () => {
      const layoutWithoutVariables = {
        ...mockLayout,
        variables: undefined,
      };
      getLayoutUseCaseMock.execute.resolves(layoutWithoutVariables as any);

      const command = PreviewLayoutCommand.create({
        user: mockUser as any,
        layoutIdOrInternalId: 'layout_id',
        layoutPreviewRequestDto: {
          controlValues: mockControlValues,
        },
      });

      await previewLayoutUsecase.execute(command);

      const createVariablesCall = createVariablesObjectMock.execute.firstCall.args[0];
      expect(createVariablesCall.variableSchema).to.deep.equal({});
    });

    it('should handle missing email controls in preview template data', async () => {
      const templateDataWithoutEmail = {
        ...mockPreviewTemplateData,
        controlValues: {} as LayoutControlType,
      };
      controlValueSanitizerMock.processControlValues.returns({
        previewTemplateData: templateDataWithoutEmail,
        sanitizedControls: mockSanitizedControls,
      });

      const command = PreviewLayoutCommand.create({
        user: mockUser as any,
        layoutIdOrInternalId: 'layout_id',
        layoutPreviewRequestDto: {
          controlValues: mockControlValues,
        },
      });

      await previewLayoutUsecase.execute(command);

      expect(previewStepUsecaseMock.execute.calledOnce).to.be.true;
      const previewCall = previewStepUsecaseMock.execute.firstCall.args[0];
      expect(previewCall.controls.body).to.eq('{}');
      expect(previewCall.controls.editorType).to.eq('block');
    });

    it('should handle missing payload in cleaned payload example', async () => {
      const cleanedPayloadWithoutPayload = {
        payload: undefined,
        subscriber: { email: 'test@example.com' },
      };
      payloadProcessorMock.cleanPreviewExamplePayload.returns(cleanedPayloadWithoutPayload);

      const command = PreviewLayoutCommand.create({
        user: mockUser as any,
        layoutIdOrInternalId: 'layout_id',
        layoutPreviewRequestDto: {
          controlValues: mockControlValues,
        },
      });

      await previewLayoutUsecase.execute(command);

      const previewCall = previewStepUsecaseMock.execute.firstCall.args[0];
      expect(previewCall.payload).to.deep.equal({});
    });

    it('should handle missing subscriber in cleaned payload example', async () => {
      const cleanedPayloadWithoutSubscriber = {
        payload: { content: 'test' },
        subscriber: undefined,
      };
      payloadProcessorMock.cleanPreviewExamplePayload.returns(cleanedPayloadWithoutSubscriber);

      const command = PreviewLayoutCommand.create({
        user: mockUser as any,
        layoutIdOrInternalId: 'layout_id',
        layoutPreviewRequestDto: {
          controlValues: mockControlValues,
        },
      });

      await previewLayoutUsecase.execute(command);

      const previewCall = previewStepUsecaseMock.execute.firstCall.args[0];
      expect(previewCall.subscriber).to.deep.equal({});
    });

    describe('error handling', () => {
      it('should return fallback response when getLayoutUseCase throws error', async () => {
        try {
          const error = new Error('Layout not found');
          getLayoutUseCaseMock.execute.rejects(error);

          const command = PreviewLayoutCommand.create({
            user: mockUser as any,
            layoutIdOrInternalId: 'invalid_layout_id',
            layoutPreviewRequestDto: {
              controlValues: mockControlValues,
            },
          });

          await previewLayoutUsecase.execute(command);
        } catch (error) {
          expect(error.message).to.equal('Layout not found');
        }
      });

      it('should return fallback response when createVariablesObject throws error', async () => {
        const error = new Error('Variables creation failed');
        createVariablesObjectMock.execute.rejects(error);

        const command = PreviewLayoutCommand.create({
          user: mockUser as any,
          layoutIdOrInternalId: 'layout_id',
          layoutPreviewRequestDto: {
            controlValues: mockControlValues,
          },
        });

        const result = await previewLayoutUsecase.execute(command);

        expect(result).to.deep.equal({
          result: {
            type: ChannelTypeEnum.EMAIL,
          },
          previewPayloadExample: {},
          schema: null,
        });
      });

      it('should return fallback response when controlValueSanitizer throws error', async () => {
        const error = new Error('Control value sanitization failed');
        controlValueSanitizerMock.sanitizeControlsForPreview.throws(error);

        const command = PreviewLayoutCommand.create({
          user: mockUser as any,
          layoutIdOrInternalId: 'layout_id',
          layoutPreviewRequestDto: {
            controlValues: mockControlValues,
          },
        });

        const result = await previewLayoutUsecase.execute(command);

        expect(result).to.deep.equal({
          result: {
            type: ChannelTypeEnum.EMAIL,
          },
          previewPayloadExample: {},
          schema: null,
        });
      });

      it('should return fallback response when payloadMerger throws error', async () => {
        const error = new Error('Payload merge failed');
        payloadMergerMock.mergePayloadExample.rejects(error);

        const command = PreviewLayoutCommand.create({
          user: mockUser as any,
          layoutIdOrInternalId: 'layout_id',
          layoutPreviewRequestDto: {
            controlValues: mockControlValues,
          },
        });

        const result = await previewLayoutUsecase.execute(command);

        expect(result).to.deep.equal({
          result: {
            type: ChannelTypeEnum.EMAIL,
          },
          previewPayloadExample: {},
          schema: null,
        });
      });

      it('should return fallback response when payloadProcessor throws error', async () => {
        const error = new Error('Payload processing failed');
        payloadProcessorMock.cleanPreviewExamplePayload.throws(error);

        const command = PreviewLayoutCommand.create({
          user: mockUser as any,
          layoutIdOrInternalId: 'layout_id',
          layoutPreviewRequestDto: {
            controlValues: mockControlValues,
          },
        });

        const result = await previewLayoutUsecase.execute(command);

        expect(result).to.deep.equal({
          result: {
            type: ChannelTypeEnum.EMAIL,
          },
          previewPayloadExample: {},
          schema: null,
        });
      });

      it('should return fallback response when previewStepUsecase throws error', async () => {
        const error = new Error('Preview step execution failed');
        previewStepUsecaseMock.execute.rejects(error);

        const command = PreviewLayoutCommand.create({
          user: mockUser as any,
          layoutIdOrInternalId: 'layout_id',
          layoutPreviewRequestDto: {
            controlValues: mockControlValues,
          },
        });

        const result = await previewLayoutUsecase.execute(command);

        expect(result).to.deep.equal({
          result: {
            type: ChannelTypeEnum.EMAIL,
          },
          previewPayloadExample: {},
          schema: null,
        });
      });

      it('should not call subsequent dependencies when early dependency fails', async () => {
        const error = new Error('Early failure');
        createVariablesObjectMock.execute.rejects(error);

        const command = PreviewLayoutCommand.create({
          user: mockUser as any,
          layoutIdOrInternalId: 'layout_id',
          layoutPreviewRequestDto: {
            controlValues: mockControlValues,
          },
        });

        await previewLayoutUsecase.execute(command);

        // Verify that dependencies after createVariablesObject were not called
        expect(controlValueSanitizerMock.sanitizeControlsForPreview.called).to.be.false;
        expect(payloadMergerMock.mergePayloadExample.called).to.be.false;
        expect(previewStepUsecaseMock.execute.called).to.be.false;
      });
    });

    describe('edge cases', () => {
      it('should handle empty previewStepOutput', async () => {
        previewStepUsecaseMock.execute.resolves({ outputs: {} } as any);

        const command = PreviewLayoutCommand.create({
          user: mockUser as any,
          layoutIdOrInternalId: 'layout_id',
          layoutPreviewRequestDto: {
            controlValues: mockControlValues,
          },
        });

        const result = await previewLayoutUsecase.execute(command);

        expect(result.result.preview?.body).to.be.undefined;
        expect(result.result.type).to.equal(ChannelTypeEnum.EMAIL);
      });

      it('should handle null previewStepOutput outputs', async () => {
        previewStepUsecaseMock.execute.resolves({ outputs: null } as any);

        const command = PreviewLayoutCommand.create({
          user: mockUser as any,
          layoutIdOrInternalId: 'layout_id',
          layoutPreviewRequestDto: {
            controlValues: mockControlValues,
          },
        });

        const result = await previewLayoutUsecase.execute(command);

        expect(result.result.preview?.body).to.be.undefined;
        expect(result.result.type).to.equal(ChannelTypeEnum.EMAIL);
      });
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - mockPreviewStepOutput({
    outputs: {
      body: '<html>Final rendered content</html>',
    },
  };

  beforeEach(())
 - previewLayoutUsecase(new PreviewLayoutUsecase(
      getLayoutUseCaseMock as any,
      createVariablesObjectMock as any,...)
 - result(await previewLayoutUsecase.execute(command);

      expect(result.result).to.deep.equal({
        pr...)
 - createVariablesCall(createVariablesObjectMock.execute.firstCall.args[0];
      expect(createVariablesCall.controlValues)...)
 - sanitizeCall(controlValueSanitizerMock.sanitizeControlsForPreview.firstCall.args[0];
      expect(sanitizeCall).t...)
 - previewCall(previewStepUsecaseMock.execute.firstCall.args[0];
      expect(previewCall.payload).to.deep.equal(mo...)
 - mergeCall(payloadMergerMock.mergePayloadExample.firstCall.args[0];
      expect(mergeCall.userPayloadExample)....)
 - createVariablesCall(createVariablesObjectMock.execute.firstCall.args[0];
      expect(createVariablesCall.variableSchema...)
 - previewCall(previewStepUsecaseMock.execute.firstCall.args[0];
      expect(previewCall.controls.body).to.eq('{}'...)
 - previewCall(previewStepUsecaseMock.execute.firstCall.args[0];
      expect(previewCall.payload).to.deep.equal({}...)
 - previewCall(previewStepUsecaseMock.execute.firstCall.args[0];
      expect(previewCall.subscriber).to.deep.equal...)
 - command(PreviewLayoutCommand.create({
            user: mockUser as any,
            layoutIdOrInternalId: '...)
 - result(await previewLayoutUsecase.execute(command);

        expect(result).to.deep.equal({
          resul...)
 - result(await previewLayoutUsecase.execute(command);

        expect(result).to.deep.equal({
          resul...)
 - result(await previewLayoutUsecase.execute(command);

        expect(result).to.deep.equal({
          resul...)
 - result(await previewLayoutUsecase.execute(command);

        expect(result).to.deep.equal({
          resul...)
 - result(await previewLayoutUsecase.execute(command);

        expect(result).to.deep.equal({
          resul...)
 - command(PreviewLayoutCommand.create({
          user: mockUser as any,
          layoutIdOrInternalId: 'layo...)
 - result(await previewLayoutUsecase.execute(command);

        expect(result.result.preview?.body).to.be.unde...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/preview-layout/preview-layout.usecase.ts
Tamaño: 5531 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { EmailControlType, InstrumentUsecase, LayoutControlType } from '@novu/application-generic';
import { JsonSchemaTypeEnum } from '@novu/dal';
import { ContextResolved } from '@novu/framework/internal';
import {
  ChannelTypeEnum,
  LAYOUT_PREVIEW_EMAIL_STEP,
  LAYOUT_PREVIEW_WORKFLOW_ID,
  ResourceOriginEnum,
} from '@novu/shared';
import { PreviewStep, PreviewStepCommand } from '../../../bridge/usecases/preview-step';
import { ControlValueSanitizerService } from '../../../shared/services/control-value-sanitizer.service';
import { CreateVariablesObject, CreateVariablesObjectCommand } from '../../../shared/usecases/create-variables-object';
import { buildContextSchema, buildSubscriberSchema } from '../../../shared/utils/create-schema';
import { PayloadMergerService } from '../../../workflows-v2/usecases/preview/services/payload-merger.service';
import { PreviewPayloadProcessorService } from '../../../workflows-v2/usecases/preview/services/preview-payload-processor.service';
import { GenerateLayoutPreviewResponseDto } from '../../dtos/generate-layout-preview-response.dto';
import { GetLayoutCommand, GetLayoutUseCase } from '../get-layout';
import { PreviewLayoutCommand } from './preview-layout.command';
import { enhanceBodyForPreview } from './preview-utils';

@Injectable()
export class PreviewLayoutUsecase {
  constructor(
    private getLayoutUseCase: GetLayoutUseCase,
    private createVariablesObject: CreateVariablesObject,
    private controlValueSanitizer: ControlValueSanitizerService,
    private payloadProcessor: PreviewPayloadProcessorService,
    private payloadMerger: PayloadMergerService,
    private previewStepUsecase: PreviewStep
  ) {}

  @InstrumentUsecase()
  async execute(command: PreviewLayoutCommand): Promise<GenerateLayoutPreviewResponseDto> {
    const layout = await this.getLayoutUseCase.execute(
      GetLayoutCommand.create({
        layoutIdOrInternalId: command.layoutIdOrInternalId,
        environmentId: command.user.environmentId,
        organizationId: command.user.organizationId,
        userId: command.user._id,
      })
    );

    try {
      const controlValues = command.layoutPreviewRequestDto.controlValues || layout.controls.values || {};
      const variableSchema = layout.variables ?? {};

      // extract all variables from the control values and build the variables object
      const variablesObject = await this.createVariablesObject.execute(
        CreateVariablesObjectCommand.create({
          environmentId: command.user.environmentId,
          organizationId: command.user.organizationId,
          controlValues: Object.values(controlValues.email ?? {}),
          variableSchema,
        })
      );

      const sanitizedControls = this.controlValueSanitizer.sanitizeControlsForPreview(
        controlValues as Record<string, unknown>,
        'layout',
        ResourceOriginEnum.NOVU_CLOUD
      );

      const { previewTemplateData } = this.controlValueSanitizer.processControlValues(
        sanitizedControls,
        variableSchema,
        variablesObject
      );

      const payloadExample = await this.payloadMerger.mergePayloadExample({
        payloadExample: previewTemplateData.payloadExample,
        userPayloadExample: command.layoutPreviewRequestDto.previewPayload,
        user: command.user,
      });

      const cleanedPayloadExample = this.payloadProcessor.cleanPreviewExamplePayload(payloadExample);

      const { email } = previewTemplateData.controlValues as LayoutControlType;
      const editorType = email?.editorType ?? 'block';
      const body = email?.body ?? (editorType === 'block' ? '{}' : '');

      const executeOutput = await this.previewStepUsecase.execute(
        PreviewStepCommand.create({
          payload: (cleanedPayloadExample.payload ?? {}) as Record<string, unknown>,
          subscriber: cleanedPayloadExample.subscriber ?? {},
          context: (cleanedPayloadExample.context ?? {}) as ContextResolved,
          // mapping the email layout controls to the email step controls
          controls: {
            subject: 'email-layout-preview',
            body: enhanceBodyForPreview(editorType, body),
            editorType,
          } as EmailControlType,
          environmentId: command.user.environmentId,
          organizationId: command.user.organizationId,
          stepId: LAYOUT_PREVIEW_EMAIL_STEP,
          userId: command.user._id,
          workflowId: LAYOUT_PREVIEW_WORKFLOW_ID,
          workflowOrigin: ResourceOriginEnum.NOVU_CLOUD,
          layoutId: layout.layoutId,
          state: [],
        })
      );

      const { body: previewBody } = executeOutput.outputs as any;

      // Generate schema from the preview payload example
      const schema = {
        type: JsonSchemaTypeEnum.OBJECT,
        properties: {
          subscriber: buildSubscriberSchema(payloadExample.subscriber),
          context: buildContextSchema(payloadExample.context),
        },
      };

      return {
        result: {
          preview: { body: previewBody },
          type: ChannelTypeEnum.EMAIL,
        },
        previewPayloadExample: payloadExample,
        schema,
      };
    } catch (error) {
      /*
       * If preview execution fails, still return valid schema and payload example
       * but with an empty preview result
       */
      return {
        result: {
          type: ChannelTypeEnum.EMAIL,
        },
        previewPayloadExample: {},
        schema: null,
      };
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class PreviewLayoutUsecase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/preview-layout/preview-utils.ts
Tamaño: 939 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { JSONContent as MailyJSONContent } from '@maily-to/render';
import { LAYOUT_CONTENT_VARIABLE, LAYOUT_PREVIEW_CONTENT_PLACEHOLDER } from '@novu/shared';

import { replaceMailyNodesByCondition } from '../../../shared/helpers/maily-utils';

export const enhanceBodyForPreview = (editorType: string, body: string) => {
  if (editorType === 'html') {
    return body?.replace(
      new RegExp(`\\{\\{\\s*${LAYOUT_CONTENT_VARIABLE}\\s*\\}\\}`),
      LAYOUT_PREVIEW_CONTENT_PLACEHOLDER
    );
  }

  return JSON.stringify(
    replaceMailyNodesByCondition(
      body,
      (node) => node.type === 'variable' && node.attrs?.id === LAYOUT_CONTENT_VARIABLE,
      (node) => {
        return {
          type: 'text',
          text: LAYOUT_PREVIEW_CONTENT_PLACEHOLDER,
          attrs: {
            ...node.attrs,
            shouldDangerouslySetInnerHTML: true,
          },
        } satisfies MailyJSONContent;
      }
    )
  );
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - enhanceBodyForPreview(editorType: string, body: string))
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/sync-to-environment/index.ts
Tamaño: 108 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './layout-sync-to-environment.command';
export * from './layout-sync-to-environment.usecase';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/sync-to-environment/layout-sync-to-environment.command.ts
Tamaño: 599 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentWithUserObjectCommand } from '@novu/application-generic';
import { ClientSession } from '@novu/dal';
import { Exclude } from 'class-transformer';
import { IsDefined, IsOptional, IsString } from 'class-validator';

export class LayoutSyncToEnvironmentCommand extends EnvironmentWithUserObjectCommand {
  @IsString()
  @IsDefined()
  layoutIdOrInternalId: string;

  @IsString()
  @IsDefined()
  targetEnvironmentId: string;

  /**
   * Exclude session from the command to avoid serializing it in the response
   */
  @IsOptional()
  @Exclude()
  session?: ClientSession | null;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class LayoutSyncToEnvironmentCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/sync-to-environment/layout-sync-to-environment.usecase.ts
Tamaño: 4348 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import { Instrument, InstrumentUsecase } from '@novu/application-generic';
import { LocalizationResourceEnum } from '@novu/dal';
import { ResourceOriginEnum } from '@novu/shared';
import { LayoutResponseDto } from '../../dtos';
import { GetLayoutCommand, GetLayoutUseCase } from '../get-layout';
import { UpsertLayout, UpsertLayoutCommand, UpsertLayoutDataCommand } from '../upsert-layout';
import { LayoutSyncToEnvironmentCommand } from './layout-sync-to-environment.command';

export const SYNCABLE_LAYOUT_ORIGINS = [ResourceOriginEnum.NOVU_CLOUD];

class LayoutNotSyncableException extends BadRequestException {
  constructor(layout: Pick<LayoutResponseDto, 'layoutId' | 'origin'>) {
    const reason = `origin '${layout.origin}' is not allowed (must be one of: ${SYNCABLE_LAYOUT_ORIGINS.join(', ')})`;

    super({
      message: `Cannot sync layout: ${reason}`,
      layoutId: layout.layoutId,
      origin: layout.origin,
      allowedOrigins: SYNCABLE_LAYOUT_ORIGINS,
    });
  }
}

@Injectable()
export class LayoutSyncToEnvironmentUseCase {
  constructor(
    private getLayoutUseCase: GetLayoutUseCase,
    private upsertLayoutUseCase: UpsertLayout,
    private moduleRef: ModuleRef
  ) {}

  @InstrumentUsecase()
  async execute(command: LayoutSyncToEnvironmentCommand): Promise<LayoutResponseDto> {
    if (command.user.environmentId === command.targetEnvironmentId) {
      throw new BadRequestException('Cannot sync layout to the same environment');
    }

    const sourceLayout = await this.getLayoutUseCase.execute(
      GetLayoutCommand.create({
        environmentId: command.user.environmentId,
        organizationId: command.user.organizationId,
        layoutIdOrInternalId: command.layoutIdOrInternalId,
      })
    );

    if (!this.isSyncable(sourceLayout)) {
      throw new LayoutNotSyncableException(sourceLayout);
    }

    const externalId = sourceLayout.layoutId;
    const targetLayout = await this.findLayoutInTargetEnvironment(command, externalId);

    const layoutDto = await this.buildRequestDto(sourceLayout);

    const upsertedLayout = await this.upsertLayoutUseCase.execute(
      UpsertLayoutCommand.create({
        environmentId: command.targetEnvironmentId,
        organizationId: command.user.organizationId,
        userId: command.user._id,
        layoutIdOrInternalId: targetLayout?.layoutId,
        layoutDto,
      })
    );

    await this.publishTranslationGroup(sourceLayout.layoutId, LocalizationResourceEnum.LAYOUT, command);

    return upsertedLayout;
  }

  private isSyncable(layout: LayoutResponseDto): boolean {
    return SYNCABLE_LAYOUT_ORIGINS.includes(layout.origin);
  }

  private async buildRequestDto(sourceLayout: LayoutResponseDto): Promise<UpsertLayoutDataCommand> {
    return {
      layoutId: sourceLayout.layoutId,
      name: sourceLayout.name,
      isTranslationEnabled: sourceLayout.isTranslationEnabled,
      controlValues: sourceLayout.controls.values,
    };
  }

  private async publishTranslationGroup(
    resourceId: string,
    resourceType: LocalizationResourceEnum,
    command: LayoutSyncToEnvironmentCommand
  ): Promise<void> {
    const isEnterprise = process.env.NOVU_ENTERPRISE === 'true' || process.env.CI_EE_TEST === 'true';
    const isSelfHosted = process.env.IS_SELF_HOSTED === 'true';

    if (!isEnterprise || isSelfHosted) {
      return;
    }

    const publishTranslationGroup = this.moduleRef.get(require('@novu/ee-translation')?.PublishTranslationGroup, {
      strict: false,
    });

    const { user, targetEnvironmentId } = command;

    await publishTranslationGroup.execute({
      user,
      resourceId,
      resourceType,
      sourceEnvironmentId: user.environmentId,
      targetEnvironmentId,
    });
  }

  @Instrument()
  private async findLayoutInTargetEnvironment(
    command: LayoutSyncToEnvironmentCommand,
    externalId: string
  ): Promise<LayoutResponseDto | undefined> {
    try {
      return await this.getLayoutUseCase.execute(
        GetLayoutCommand.create({
          environmentId: command.targetEnvironmentId,
          organizationId: command.user.organizationId,
          layoutIdOrInternalId: externalId,
        })
      );
    } catch (error) {
      return undefined;
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export class LayoutSyncToEnvironmentUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/upsert-layout/index.ts
Tamaño: 82 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './upsert-layout.command';
export * from './upsert-layout.usecase';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/upsert-layout/upsert-layout.command.ts
Tamaño: 1030 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentWithUserCommand } from '@novu/application-generic';
import { MAX_NAME_LENGTH } from '@novu/shared';
import { Type } from 'class-transformer';
import { IsBoolean, IsEnum, IsNotEmpty, IsOptional, IsString, Length, ValidateNested } from 'class-validator';
import { LayoutControlValuesDto } from '../../dtos/layout-controls.dto';
import { LayoutCreationSourceEnum } from '../../types';

export class UpsertLayoutDataCommand {
  @IsString()
  @IsOptional()
  layoutId?: string;

  @IsString()
  @IsNotEmpty()
  @Length(1, MAX_NAME_LENGTH)
  name: string;

  @IsOptional()
  @IsBoolean()
  isTranslationEnabled?: boolean;

  @IsOptional()
  @IsEnum(LayoutCreationSourceEnum)
  __source?: LayoutCreationSourceEnum;

  @IsOptional()
  controlValues?: LayoutControlValuesDto | null;
}

export class UpsertLayoutCommand extends EnvironmentWithUserCommand {
  @ValidateNested()
  @Type(() => UpsertLayoutDataCommand)
  layoutDto: UpsertLayoutDataCommand;

  @IsOptional()
  @IsString()
  layoutIdOrInternalId?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpsertLayoutDataCommand
- export class UpsertLayoutCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/upsert-layout/upsert-layout.usecase.spec.ts
Tamaño: 35588 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import {
  AnalyticsService,
  GetLayoutUseCase as GetLayoutUseCaseV0,
  layoutControlSchema,
  PinoLogger,
  UpsertControlValuesUseCase,
} from '@novu/application-generic';
import { ControlValuesRepository, JsonSchemaTypeEnum, LayoutRepository } from '@novu/dal';
import {
  ChannelTypeEnum,
  ContentIssueEnum,
  ControlValuesLevelEnum,
  LayoutControlValuesDto,
  LayoutIssuesDto,
  ResourceOriginEnum,
  ResourceTypeEnum,
  slugify,
} from '@novu/shared';
import { expect } from 'chai';
import sinon from 'sinon';
import { LayoutDto } from '../../../layouts-v1/dtos';
import { CreateLayoutUseCase, UpdateLayoutUseCase } from '../../../layouts-v1/usecases';
import { JSONSchemaDto } from '../../../shared/dtos/json-schema.dto';
import { LayoutCreationSourceEnum } from '../../types';
import { BuildLayoutIssuesUsecase } from '../build-layout-issues/build-layout-issues.usecase';
import { GetLayoutUseCase } from '../get-layout';
import { mapToResponseDto } from '../mapper';
import { UpsertLayoutCommand } from './upsert-layout.command';
import { UpsertLayout } from './upsert-layout.usecase';

// Mock the utility functions
const isStringifiedMailyJSONContentStub = sinon.stub();

// Mock modules using require to ensure proper stubbing
sinon
  .stub(require('../../../shared/helpers/maily-utils'), 'isStringifiedMailyJSONContent')
  .callsFake(isStringifiedMailyJSONContentStub);

/**
 * Sets up mocks for the enterprise translation module
 * Returns the translation stub for further customization if needed
 */
function setupTranslationMocks(moduleRef: sinon.SinonStubbedInstance<ModuleRef>): sinon.SinonStub {
  const eeTranslation = require('@novu/ee-translation');
  if (!eeTranslation) {
    throw new Error('ee-translation does not exist');
  }

  const { ManageTranslations } = eeTranslation;

  // Create translation service stub that returns original content (no translation applied)
  const manageTranslationsStub = sinon.stub(ManageTranslations.prototype, 'execute').callsFake(async (command: any) => {
    return command.content || '';
  });

  const mockLogger = {
    setContext: sinon.stub(),
  };

  // Mock moduleRef.get to return the ManageTranslations class when requested
  (moduleRef as any).get = sinon.stub().callsFake((token) => {
    if (token === ManageTranslations) {
      return new ManageTranslations({} as any, {} as any, mockLogger as any, {} as any);
    }
    return null;
  });

  return manageTranslationsStub;
}

describe('UpsertLayoutUseCase', () => {
  let getLayoutUseV0CaseMock: sinon.SinonStubbedInstance<GetLayoutUseCaseV0>;
  let createLayoutUseCaseMock: sinon.SinonStubbedInstance<CreateLayoutUseCase>;
  let updateLayoutUseCaseMock: sinon.SinonStubbedInstance<UpdateLayoutUseCase>;
  let controlValuesRepositoryMock: sinon.SinonStubbedInstance<ControlValuesRepository>;
  let upsertControlValuesUseCaseMock: sinon.SinonStubbedInstance<UpsertControlValuesUseCase>;
  let layoutRepositoryMock: sinon.SinonStubbedInstance<LayoutRepository>;
  let analyticsServiceMock: sinon.SinonStubbedInstance<AnalyticsService>;
  let buildLayoutIssuesUsecaseMock: sinon.SinonStubbedInstance<BuildLayoutIssuesUsecase>;
  let getLayoutUseCaseMock: sinon.SinonStubbedInstance<GetLayoutUseCase>;
  let moduleRefMock: sinon.SinonStubbedInstance<ModuleRef>;
  let pinoLoggerMock: sinon.SinonStubbedInstance<PinoLogger>;

  let upsertLayoutUseCase: UpsertLayout;

  const mockUser = {
    _id: 'user_id',
    environmentId: 'env_id',
    organizationId: 'org_id',
  };

  const mockLayoutDto = {
    name: 'Test Layout',
    __source: LayoutCreationSourceEnum.DASHBOARD,
    controlValues: {
      email: {
        body: '<html><body>{{content}}</body></html>',
        editorType: 'html' as 'html' | 'block',
      },
    } as LayoutControlValuesDto,
  };

  const mockExistingLayout: LayoutDto & { _id: string } = {
    _id: 'existing_layout_id',
    identifier: 'existing_layout_identifier',
    name: 'Existing Layout',
    _creatorId: 'creator_id',
    isDefault: false,
    isDeleted: false,
    createdAt: '2023-01-01T00:00:00Z',
    updatedAt: '2023-01-01T00:00:00Z',
    _environmentId: 'env_id',
    _organizationId: 'org_id',
    origin: ResourceOriginEnum.NOVU_CLOUD,
    type: ResourceTypeEnum.BRIDGE,
    channel: ChannelTypeEnum.EMAIL,
    controls: {
      dataSchema: layoutControlSchema,
      uiSchema: {},
    },
  };

  const mockCreatedLayout: LayoutDto & { _id: string } = {
    _id: 'new_layout_id',
    identifier: 'test-layout',
    name: 'Test Layout',
    _creatorId: 'creator_id',
    isDefault: true,
    isDeleted: false,
    createdAt: '2023-01-01T00:00:00Z',
    updatedAt: '2023-01-01T00:00:00Z',
    _environmentId: 'env_id',
    _organizationId: 'org_id',
    origin: ResourceOriginEnum.NOVU_CLOUD,
    type: ResourceTypeEnum.BRIDGE,
    channel: ChannelTypeEnum.EMAIL,
    controls: {
      dataSchema: layoutControlSchema,
      uiSchema: {},
    },
  };

  const mockControlValues = {
    _id: 'control_values_id',
    controls: {
      email: {
        body: '<html><body>{{content}}</body></html>',
        editorType: 'html',
      },
    },
  };

  const mockLayoutVariablesSchema: JSONSchemaDto = {
    type: JsonSchemaTypeEnum.OBJECT,
    properties: {
      subscriber: {
        type: JsonSchemaTypeEnum.OBJECT,
        properties: {
          email: { type: JsonSchemaTypeEnum.STRING },
          firstName: { type: JsonSchemaTypeEnum.STRING },
        },
      },
      content: { type: JsonSchemaTypeEnum.STRING },
    },
  };

  beforeEach(() => {
    getLayoutUseV0CaseMock = sinon.createStubInstance(GetLayoutUseCaseV0);
    createLayoutUseCaseMock = sinon.createStubInstance(CreateLayoutUseCase);
    updateLayoutUseCaseMock = sinon.createStubInstance(UpdateLayoutUseCase);
    controlValuesRepositoryMock = sinon.createStubInstance(ControlValuesRepository);
    upsertControlValuesUseCaseMock = sinon.createStubInstance(UpsertControlValuesUseCase);
    layoutRepositoryMock = sinon.createStubInstance(LayoutRepository);
    analyticsServiceMock = sinon.createStubInstance(AnalyticsService);
    buildLayoutIssuesUsecaseMock = sinon.createStubInstance(BuildLayoutIssuesUsecase);
    getLayoutUseCaseMock = sinon.createStubInstance(GetLayoutUseCase);
    moduleRefMock = sinon.createStubInstance(ModuleRef);
    pinoLoggerMock = sinon.createStubInstance(PinoLogger);

    setupTranslationMocks(moduleRefMock as any);

    upsertLayoutUseCase = new UpsertLayout(
      getLayoutUseV0CaseMock as any,
      createLayoutUseCaseMock as any,
      updateLayoutUseCaseMock as any,
      controlValuesRepositoryMock as any,
      upsertControlValuesUseCaseMock as any,
      layoutRepositoryMock as any,
      analyticsServiceMock as any,
      buildLayoutIssuesUsecaseMock as any,
      getLayoutUseCaseMock as any,
      moduleRefMock as any,
      pinoLoggerMock as any
    );

    // Default mocks setup
    isStringifiedMailyJSONContentStub.returns(false);
    buildLayoutIssuesUsecaseMock.execute.resolves({} as LayoutIssuesDto);
    upsertControlValuesUseCaseMock.execute.resolves(mockControlValues as any);
    layoutRepositoryMock.findOne.resolves(undefined);
  });

  afterEach(() => {
    sinon.restore();
    isStringifiedMailyJSONContentStub.reset();
  });

  describe('execute', () => {
    describe('create layout path', () => {
      beforeEach(() => {
        getLayoutUseV0CaseMock.execute.resolves(undefined);
        createLayoutUseCaseMock.execute.resolves(mockCreatedLayout);
        getLayoutUseCaseMock.execute.resolves(
          mapToResponseDto({
            layout: mockCreatedLayout,
            controlValues: mockControlValues,
            variables: mockLayoutVariablesSchema,
          })
        );
      });

      it('should successfully create a new layout when no existing layout found', async () => {
        const command = UpsertLayoutCommand.create({
          userId: mockUser._id,
          environmentId: mockUser.environmentId,
          organizationId: mockUser.organizationId,
          layoutDto: mockLayoutDto,
        });

        const result = await upsertLayoutUseCase.execute(command);

        expect(result).to.exist;
        expect(result._id).to.equal(mockCreatedLayout._id);
        expect(result.name).to.equal(mockCreatedLayout.name);
        expect(createLayoutUseCaseMock.execute.calledOnce).to.be.true;
        expect(updateLayoutUseCaseMock.execute.called).to.be.false;
      });

      it('should call createLayoutUseCase with correct parameters', async () => {
        const command = UpsertLayoutCommand.create({
          userId: mockUser._id,
          environmentId: mockUser.environmentId,
          organizationId: mockUser.organizationId,
          layoutDto: mockLayoutDto,
        });

        await upsertLayoutUseCase.execute(command);

        expect(createLayoutUseCaseMock.execute.calledOnce).to.be.true;
        const createCommand = createLayoutUseCaseMock.execute.firstCall.args[0];
        expect(createCommand.environmentId).to.equal(mockUser.environmentId);
        expect(createCommand.organizationId).to.equal(mockUser.organizationId);
        expect(createCommand.userId).to.equal(mockUser._id);
        expect(createCommand.name).to.equal(mockLayoutDto.name);
        expect(createCommand.identifier).to.equal(slugify(mockLayoutDto.name));
        expect(createCommand.type).to.equal(ResourceTypeEnum.BRIDGE);
        expect(createCommand.origin).to.equal(ResourceOriginEnum.NOVU_CLOUD);
        expect(createCommand.isDefault).to.be.true;
      });

      it('should use custom layoutId when provided instead of slugified name', async () => {
        const customLayoutId = 'custom-layout-identifier';
        const layoutDtoWithCustomId = {
          ...mockLayoutDto,
          layoutId: customLayoutId,
        };

        const command = UpsertLayoutCommand.create({
          userId: mockUser._id,
          environmentId: mockUser.environmentId,
          organizationId: mockUser.organizationId,
          layoutDto: layoutDtoWithCustomId,
        });

        await upsertLayoutUseCase.execute(command);

        expect(createLayoutUseCaseMock.execute.calledOnce).to.be.true;
        const createCommand = createLayoutUseCaseMock.execute.firstCall.args[0];
        expect(createCommand.identifier).to.equal(customLayoutId);
        expect(createCommand.name).to.equal(mockLayoutDto.name);
      });

      it('should set isDefault to false when a default layout already exists', async () => {
        const existingDefaultLayout = { ...mockExistingLayout, isDefault: true };
        layoutRepositoryMock.findOne.resolves(existingDefaultLayout as any);

        const command = UpsertLayoutCommand.create({
          userId: mockUser._id,
          environmentId: mockUser.environmentId,
          organizationId: mockUser.organizationId,
          layoutDto: mockLayoutDto,
        });

        await upsertLayoutUseCase.execute(command);

        const createCommand = createLayoutUseCaseMock.execute.firstCall.args[0];
        expect(createCommand.isDefault).to.be.false;
      });

      it('should track "Layout Create" analytics event', async () => {
        const command = UpsertLayoutCommand.create({
          userId: mockUser._id,
          environmentId: mockUser.environmentId,
          organizationId: mockUser.organizationId,
          layoutDto: mockLayoutDto,
        });

        await upsertLayoutUseCase.execute(command);

        expect(analyticsServiceMock.mixpanelTrack.calledOnce).to.be.true;
        const [eventName, userId, props] = analyticsServiceMock.mixpanelTrack.firstCall.args;
        expect(eventName).to.equal('Layout Create - [Layouts]');
        expect(userId).to.equal(mockUser._id);
        expect(props).to.deep.equal({
          _organization: mockUser.organizationId,
          name: mockLayoutDto.name,
          source: mockLayoutDto.__source,
        });
      });
    });

    describe('update layout path', () => {
      beforeEach(() => {
        getLayoutUseV0CaseMock.execute.resolves(mockExistingLayout);
        updateLayoutUseCaseMock.execute.resolves(mockExistingLayout);
        getLayoutUseCaseMock.execute.resolves(
          mapToResponseDto({
            layout: mockExistingLayout,
            controlValues: mockControlValues,
            variables: mockLayoutVariablesSchema,
          })
        );
      });

      it('should successfully update an existing layout when layoutIdOrInternalId provided', async () => {
        const command = UpsertLayoutCommand.create({
          userId: mockUser._id,
          environmentId: mockUser.environmentId,
          organizationId: mockUser.organizationId,
          layoutDto: mockLayoutDto,
          layoutIdOrInternalId: 'existing_layout_id',
        });

        const result = await upsertLayoutUseCase.execute(command);

        expect(result).to.exist;
        expect(result._id).to.equal(mockExistingLayout._id);
        expect(updateLayoutUseCaseMock.execute.calledOnce).to.be.true;
        expect(createLayoutUseCaseMock.execute.called).to.be.false;
      });

      it('should call getLayoutUseCase with correct parameters', async () => {
        const command = UpsertLayoutCommand.create({
          userId: mockUser._id,
          environmentId: mockUser.environmentId,
          organizationId: mockUser.organizationId,
          layoutDto: mockLayoutDto,
          layoutIdOrInternalId: 'existing_layout_id',
        });

        await upsertLayoutUseCase.execute(command);

        expect(getLayoutUseV0CaseMock.execute.calledOnce).to.be.true;
        const getCommand = getLayoutUseV0CaseMock.execute.firstCall.args[0];
        expect(getCommand.layoutIdOrInternalId).to.equal('existing_layout_id');
        expect(getCommand.environmentId).to.equal(mockUser.environmentId);
        expect(getCommand.organizationId).to.equal(mockUser.organizationId);
        expect(getCommand.type).to.equal(ResourceTypeEnum.BRIDGE);
        expect(getCommand.origin).to.equal(ResourceOriginEnum.NOVU_CLOUD);
      });

      it('should call updateLayoutUseCase with correct parameters', async () => {
        const command = UpsertLayoutCommand.create({
          userId: mockUser._id,
          environmentId: mockUser.environmentId,
          organizationId: mockUser.organizationId,
          layoutDto: mockLayoutDto,
          layoutIdOrInternalId: 'existing_layout_id',
        });

        await upsertLayoutUseCase.execute(command);

        expect(updateLayoutUseCaseMock.execute.calledOnce).to.be.true;
        const updateCommand = updateLayoutUseCaseMock.execute.firstCall.args[0];
        expect(updateCommand.environmentId).to.equal(mockUser.environmentId);
        expect(updateCommand.organizationId).to.equal(mockUser.organizationId);
        expect(updateCommand.userId).to.equal(mockUser._id);
        expect(updateCommand.layoutId).to.equal(mockExistingLayout._id);
        expect(updateCommand.name).to.equal(mockLayoutDto.name);
        expect(updateCommand.type).to.equal(mockExistingLayout.type);
        expect(updateCommand.origin).to.equal(mockExistingLayout.origin);
      });

      it('should track "Layout Update" analytics event', async () => {
        const command = UpsertLayoutCommand.create({
          userId: mockUser._id,
          environmentId: mockUser.environmentId,
          organizationId: mockUser.organizationId,
          layoutDto: mockLayoutDto,
          layoutIdOrInternalId: 'existing_layout_id',
        });

        await upsertLayoutUseCase.execute(command);

        expect(analyticsServiceMock.mixpanelTrack.calledOnce).to.be.true;
        const [eventName, userId, props] = analyticsServiceMock.mixpanelTrack.firstCall.args;
        expect(eventName).to.equal('Layout Update - [Layouts]');
        expect(userId).to.equal(mockUser._id);
        expect(props).to.deep.equal({
          _organization: mockUser.organizationId,
          name: mockLayoutDto.name,
          source: mockLayoutDto.__source,
        });
      });
    });

    describe('control values handling', () => {
      beforeEach(() => {
        getLayoutUseV0CaseMock.execute.resolves(undefined);
        createLayoutUseCaseMock.execute.resolves(mockCreatedLayout);
        getLayoutUseCaseMock.execute.resolves(
          mapToResponseDto({
            layout: mockCreatedLayout,
            controlValues: mockControlValues,
            variables: mockLayoutVariablesSchema,
          })
        );
      });

      it('should upsert control values when provided', async () => {
        const command = UpsertLayoutCommand.create({
          userId: mockUser._id,
          environmentId: mockUser.environmentId,
          organizationId: mockUser.organizationId,
          layoutDto: mockLayoutDto,
        });

        await upsertLayoutUseCase.execute(command);

        expect(upsertControlValuesUseCaseMock.execute.calledOnce).to.be.true;
        const upsertCommand = upsertControlValuesUseCaseMock.execute.firstCall.args[0];
        expect(upsertCommand.organizationId).to.equal(mockUser.organizationId);
        expect(upsertCommand.environmentId).to.equal(mockUser.environmentId);
        expect(upsertCommand.layoutId).to.equal(mockCreatedLayout._id);
        expect(upsertCommand.level).to.equal(ControlValuesLevelEnum.LAYOUT_CONTROLS);
        expect(upsertCommand.newControlValues).to.deep.equal(mockLayoutDto.controlValues);
      });

      it('should delete control values when set to null', async () => {
        const layoutDtoWithNullControls = {
          ...mockLayoutDto,
          controlValues: null,
        };

        const command = UpsertLayoutCommand.create({
          userId: mockUser._id,
          environmentId: mockUser.environmentId,
          organizationId: mockUser.organizationId,
          layoutDto: layoutDtoWithNullControls,
        });

        await upsertLayoutUseCase.execute(command);

        expect(controlValuesRepositoryMock.delete.calledOnce).to.be.true;
        const deleteParams = controlValuesRepositoryMock.delete.firstCall.args[0];
        expect(deleteParams._environmentId).to.equal(mockUser.environmentId);
        expect(deleteParams._organizationId).to.equal(mockUser.organizationId);
        expect(deleteParams._layoutId).to.equal(mockCreatedLayout._id);
        expect(deleteParams.level).to.equal(ControlValuesLevelEnum.LAYOUT_CONTROLS);
      });

      it('should handle empty control values', async () => {
        const layoutDtoWithEmptyControls = {
          ...mockLayoutDto,
          controlValues: {},
        };

        const command = UpsertLayoutCommand.create({
          userId: mockUser._id,
          environmentId: mockUser.environmentId,
          organizationId: mockUser.organizationId,
          layoutDto: layoutDtoWithEmptyControls,
        });

        await upsertLayoutUseCase.execute(command);

        expect(upsertControlValuesUseCaseMock.execute.calledOnce).to.be.true;
        const upsertCommand = upsertControlValuesUseCaseMock.execute.firstCall.args[0];
        expect(upsertCommand.newControlValues).to.deep.equal({});
      });
    });
  });

  describe('validation', () => {
    describe('email content validation', () => {
      beforeEach(() => {
        getLayoutUseV0CaseMock.execute.resolves(undefined);
        createLayoutUseCaseMock.execute.resolves(mockCreatedLayout);
        getLayoutUseCaseMock.execute.resolves(
          mapToResponseDto({
            layout: mockCreatedLayout,
            controlValues: mockControlValues,
            variables: mockLayoutVariablesSchema,
          })
        );
      });

      it('should validate HTML content correctly', async () => {
        const htmlLayoutDto = {
          ...mockLayoutDto,
          controlValues: {
            email: {
              body: '<html><body>Valid HTML</body></html>',
              editorType: 'html' as 'html' | 'block',
            },
          },
        };

        const command = UpsertLayoutCommand.create({
          userId: mockUser._id,
          environmentId: mockUser.environmentId,
          organizationId: mockUser.organizationId,
          layoutDto: htmlLayoutDto,
        });

        await upsertLayoutUseCase.execute(command);

        expect(buildLayoutIssuesUsecaseMock.execute.calledOnce).to.be.true;
      });

      it('should throw BadRequestException for invalid HTML content with html editor type', async () => {
        const invalidHtmlLayoutDto = {
          ...mockLayoutDto,
          controlValues: {
            email: {
              body: 'Invalid HTML content',
              editorType: 'html' as 'html' | 'block',
            },
          },
        };

        const command = UpsertLayoutCommand.create({
          userId: mockUser._id,
          environmentId: mockUser.environmentId,
          organizationId: mockUser.organizationId,
          layoutDto: invalidHtmlLayoutDto,
        });

        try {
          await upsertLayoutUseCase.execute(command);
          expect.fail('Should have thrown BadRequestException');
        } catch (error) {
          expect(error).to.be.instanceOf(BadRequestException);
          expect(error.message).to.equal('Content must be a valid HTML content');
        }
      });

      it('should validate Maily JSON content correctly', async () => {
        isStringifiedMailyJSONContentStub.returns(true);

        const mailyLayoutDto = {
          ...mockLayoutDto,
          controlValues: {
            email: {
              body: '{"type":"doc","content":[]}',
              editorType: 'block' as 'html' | 'block',
            },
          },
        };

        const command = UpsertLayoutCommand.create({
          userId: mockUser._id,
          environmentId: mockUser.environmentId,
          organizationId: mockUser.organizationId,
          layoutDto: mailyLayoutDto,
        });

        await upsertLayoutUseCase.execute(command);

        expect(buildLayoutIssuesUsecaseMock.execute.calledOnce).to.be.true;
      });

      it('should throw BadRequestException for invalid Maily JSON content with block editor type', async () => {
        isStringifiedMailyJSONContentStub.returns(false);

        const invalidMailyLayoutDto = {
          ...mockLayoutDto,
          controlValues: {
            email: {
              body: 'Invalid Maily JSON',
              editorType: 'block' as 'html' | 'block',
            },
          },
        };

        const command = UpsertLayoutCommand.create({
          userId: mockUser._id,
          environmentId: mockUser.environmentId,
          organizationId: mockUser.organizationId,
          layoutDto: invalidMailyLayoutDto,
        });

        try {
          await upsertLayoutUseCase.execute(command);
          expect.fail('Should have thrown BadRequestException');
        } catch (error) {
          expect(error).to.be.instanceOf(BadRequestException);
          expect(error.message).to.equal('Content must be a valid Maily JSON content');
        }
      });

      it('should throw BadRequestException for content that is neither HTML nor Maily JSON', async () => {
        isStringifiedMailyJSONContentStub.returns(false);

        const invalidLayoutDto = {
          ...mockLayoutDto,
          controlValues: {
            email: {
              body: 'Neither HTML nor Maily JSON',
              editorType: 'html' as 'html' | 'block',
            },
          },
        };

        const command = UpsertLayoutCommand.create({
          userId: mockUser._id,
          environmentId: mockUser.environmentId,
          organizationId: mockUser.organizationId,
          layoutDto: invalidLayoutDto,
        });

        try {
          await upsertLayoutUseCase.execute(command);
          expect.fail('Should have thrown BadRequestException');
        } catch (error) {
          expect(error).to.be.instanceOf(BadRequestException);
          expect(error.message).to.equal('Content must be a valid HTML content');
        }
      });

      it('should skip email validation when no email controls provided', async () => {
        const noEmailLayoutDto = {
          ...mockLayoutDto,
          controlValues: {},
        };

        const command = UpsertLayoutCommand.create({
          userId: mockUser._id,
          environmentId: mockUser.environmentId,
          organizationId: mockUser.organizationId,
          layoutDto: noEmailLayoutDto,
        });

        await upsertLayoutUseCase.execute(command);

        expect(buildLayoutIssuesUsecaseMock.execute.calledOnce).to.be.true;
      });
    });

    describe('layout issues validation', () => {
      beforeEach(() => {
        getLayoutUseV0CaseMock.execute.resolves(undefined);
        createLayoutUseCaseMock.execute.resolves(mockCreatedLayout);
        getLayoutUseCaseMock.execute.resolves(
          mapToResponseDto({
            layout: mockCreatedLayout,
            controlValues: mockControlValues,
            variables: mockLayoutVariablesSchema,
          })
        );
      });

      it('should call buildLayoutIssuesUsecase with correct parameters', async () => {
        const command = UpsertLayoutCommand.create({
          userId: mockUser._id,
          environmentId: mockUser.environmentId,
          organizationId: mockUser.organizationId,
          layoutDto: mockLayoutDto,
        });

        await upsertLayoutUseCase.execute(command);

        expect(buildLayoutIssuesUsecaseMock.execute.calledOnce).to.be.true;
        const issuesCommand = buildLayoutIssuesUsecaseMock.execute.firstCall.args[0];
        expect(issuesCommand.controlSchema).to.deep.equal(layoutControlSchema);
        expect(issuesCommand.controlValues).to.deep.equal(mockLayoutDto.controlValues);
        expect(issuesCommand.resourceOrigin).to.equal(ResourceOriginEnum.NOVU_CLOUD);
        expect(issuesCommand.userId).to.deep.equal(mockUser._id);
      });

      it('should use EXTERNAL origin when __source is not provided', async () => {
        const layoutDtoWithoutSource = {
          ...mockLayoutDto,
          __source: undefined,
        };

        const command = UpsertLayoutCommand.create({
          userId: mockUser._id,
          environmentId: mockUser.environmentId,
          organizationId: mockUser.organizationId,
          layoutDto: layoutDtoWithoutSource,
        });

        await upsertLayoutUseCase.execute(command);

        const issuesCommand = buildLayoutIssuesUsecaseMock.execute.firstCall.args[0];
        expect(issuesCommand.resourceOrigin).to.equal(ResourceOriginEnum.EXTERNAL);
      });

      it('should throw BadRequestException when layout issues exist', async () => {
        const mockIssues: LayoutIssuesDto = {
          controls: {
            'email.body': [
              {
                message: 'Body is required',
                issueType: ContentIssueEnum.MISSING_VALUE,
              },
            ],
            'email.editorType': [
              {
                message: 'Invalid editor type',
                issueType: ContentIssueEnum.ILLEGAL_VARIABLE_IN_CONTROL_VALUE,
              },
            ],
          },
        };
        buildLayoutIssuesUsecaseMock.execute.resolves(mockIssues);

        const command = UpsertLayoutCommand.create({
          userId: mockUser._id,
          environmentId: mockUser.environmentId,
          organizationId: mockUser.organizationId,
          layoutDto: mockLayoutDto,
        });

        try {
          await upsertLayoutUseCase.execute(command);
          expect.fail('Should have thrown BadRequestException');
        } catch (error) {
          expect(error).to.be.instanceOf(BadRequestException);
          // The BadRequestException constructor converts the issues object to a string message
          expect(error.response).to.deep.equal(mockIssues);
        }
      });
    });
  });

  describe('error handling', () => {
    it('should propagate errors from getLayoutUseCase', async () => {
      const error = new Error('Failed to get layout');
      getLayoutUseV0CaseMock.execute.rejects(error);

      const command = UpsertLayoutCommand.create({
        userId: mockUser._id,
        environmentId: mockUser.environmentId,
        organizationId: mockUser.organizationId,
        layoutDto: mockLayoutDto,
        layoutIdOrInternalId: 'existing_layout_id',
      });

      try {
        await upsertLayoutUseCase.execute(command);
        expect.fail('Should have thrown error');
      } catch (thrownError) {
        expect(thrownError).to.equal(error);
      }
    });

    it('should propagate errors from createLayoutUseCase', async () => {
      const error = new Error('Failed to create layout');
      getLayoutUseV0CaseMock.execute.resolves(undefined);
      createLayoutUseCaseMock.execute.rejects(error);

      const command = UpsertLayoutCommand.create({
        userId: mockUser._id,
        environmentId: mockUser.environmentId,
        organizationId: mockUser.organizationId,
        layoutDto: mockLayoutDto,
      });

      try {
        await upsertLayoutUseCase.execute(command);
        expect.fail('Should have thrown error');
      } catch (thrownError) {
        expect(thrownError).to.equal(error);
      }
    });

    it('should propagate errors from updateLayoutUseCase', async () => {
      const error = new Error('Failed to update layout');
      getLayoutUseV0CaseMock.execute.resolves(mockExistingLayout);
      updateLayoutUseCaseMock.execute.rejects(error);

      const command = UpsertLayoutCommand.create({
        userId: mockUser._id,
        environmentId: mockUser.environmentId,
        organizationId: mockUser.organizationId,
        layoutDto: mockLayoutDto,
        layoutIdOrInternalId: 'existing_layout_id',
      });

      try {
        await upsertLayoutUseCase.execute(command);
        expect.fail('Should have thrown error');
      } catch (thrownError) {
        expect(thrownError).to.equal(error);
      }
    });

    it('should propagate errors from upsertControlValuesUseCase', async () => {
      const error = new Error('Failed to upsert control values');
      getLayoutUseV0CaseMock.execute.resolves(undefined);
      createLayoutUseCaseMock.execute.resolves(mockCreatedLayout);
      upsertControlValuesUseCaseMock.execute.rejects(error);

      const command = UpsertLayoutCommand.create({
        userId: mockUser._id,
        environmentId: mockUser.environmentId,
        organizationId: mockUser.organizationId,
        layoutDto: mockLayoutDto,
      });

      try {
        await upsertLayoutUseCase.execute(command);
        expect.fail('Should have thrown error');
      } catch (thrownError) {
        expect(thrownError).to.equal(error);
      }
    });

    it('should propagate errors from getLayoutUseCase', async () => {
      const error = new Error('Failed to generate schema');
      getLayoutUseV0CaseMock.execute.resolves(undefined);
      createLayoutUseCaseMock.execute.resolves(mockCreatedLayout);
      getLayoutUseCaseMock.execute.rejects(error);

      const command = UpsertLayoutCommand.create({
        userId: mockUser._id,
        environmentId: mockUser.environmentId,
        organizationId: mockUser.organizationId,
        layoutDto: mockLayoutDto,
      });

      try {
        await upsertLayoutUseCase.execute(command);
        expect.fail('Should have thrown error');
      } catch (thrownError) {
        expect(thrownError).to.equal(error);
      }
    });
  });

  describe('edge cases', () => {
    it('should handle layout without type and origin in update path', async () => {
      const layoutWithoutTypeAndOrigin = {
        ...mockExistingLayout,
        type: undefined,
        origin: undefined,
      };
      getLayoutUseV0CaseMock.execute.resolves(layoutWithoutTypeAndOrigin);
      updateLayoutUseCaseMock.execute.resolves(layoutWithoutTypeAndOrigin);

      const command = UpsertLayoutCommand.create({
        userId: mockUser._id,
        environmentId: mockUser.environmentId,
        organizationId: mockUser.organizationId,
        layoutDto: mockLayoutDto,
        layoutIdOrInternalId: 'existing_layout_id',
      });

      await upsertLayoutUseCase.execute(command);

      const updateCommand = updateLayoutUseCaseMock.execute.firstCall.args[0];
      expect(updateCommand.type).to.equal(ResourceTypeEnum.BRIDGE);
      expect(updateCommand.origin).to.equal(ResourceOriginEnum.NOVU_CLOUD);
    });

    it('should handle undefined control values in command', async () => {
      const layoutDtoWithUndefinedControls = {
        ...mockLayoutDto,
        controlValues: undefined,
      };

      getLayoutUseV0CaseMock.execute.resolves(undefined);
      createLayoutUseCaseMock.execute.resolves(mockCreatedLayout);

      const command = UpsertLayoutCommand.create({
        userId: mockUser._id,
        environmentId: mockUser.environmentId,
        organizationId: mockUser.organizationId,
        layoutDto: layoutDtoWithUndefinedControls,
      });

      await upsertLayoutUseCase.execute(command);

      expect(controlValuesRepositoryMock.delete.calledOnce).to.be.false;
      expect(upsertControlValuesUseCaseMock.execute.calledOnce).to.be.false;
    });

    it('should handle empty string layoutIdOrInternalId', async () => {
      getLayoutUseV0CaseMock.execute.resolves(undefined);
      createLayoutUseCaseMock.execute.resolves(mockCreatedLayout);

      const command = UpsertLayoutCommand.create({
        userId: mockUser._id,
        environmentId: mockUser.environmentId,
        organizationId: mockUser.organizationId,
        layoutDto: mockLayoutDto,
        layoutIdOrInternalId: '',
      });

      await upsertLayoutUseCase.execute(command);

      // Should follow create path since empty string is falsy
      expect(createLayoutUseCaseMock.execute.calledOnce).to.be.true;
      expect(getLayoutUseV0CaseMock.execute.called).to.be.false;
    });
  });

  describe('parameter verification', () => {
    beforeEach(() => {
      getLayoutUseV0CaseMock.execute.resolves(undefined);
      createLayoutUseCaseMock.execute.resolves(mockCreatedLayout);
    });

    it('should pass all required parameters to dependencies', async () => {
      const command = UpsertLayoutCommand.create({
        userId: mockUser._id,
        environmentId: mockUser.environmentId,
        organizationId: mockUser.organizationId,
        layoutDto: mockLayoutDto,
      });

      await upsertLayoutUseCase.execute(command);

      // Verify all major dependencies were called with correct basic parameters
      expect(buildLayoutIssuesUsecaseMock.execute.calledOnce).to.be.true;
      expect(createLayoutUseCaseMock.execute.calledOnce).to.be.true;
      expect(upsertControlValuesUseCaseMock.execute.calledOnce).to.be.true;
      expect(getLayoutUseCaseMock.execute.calledOnce).to.be.true;
      expect(analyticsServiceMock.mixpanelTrack.calledOnce).to.be.true;
    });

    it('should use correct identifiers and names', async () => {
      const customLayoutDto = {
        ...mockLayoutDto,
        name: 'Custom Layout Name',
      };

      const command = UpsertLayoutCommand.create({
        userId: mockUser._id,
        environmentId: mockUser.environmentId,
        organizationId: mockUser.organizationId,
        layoutDto: customLayoutDto,
      });

      await upsertLayoutUseCase.execute(command);

      const createCommand = createLayoutUseCaseMock.execute.firstCall.args[0];
      expect(createCommand.name).to.equal('Custom Layout Name');
      expect(createCommand.identifier).to.equal(slugify('Custom Layout Name'));
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - setupTranslationMocks(moduleRef: sinon.SinonStubbedInstance<ModuleRef>)
Asignaciones con arrow functions encontradas (posibles funciones):
 - manageTranslationsStub(sinon.stub(ManageTranslations.prototype, 'execute').callsFake(async (command: any))
 - get(sinon.stub().callsFake((token))
 - JSONSchemaDto({
    type: JsonSchemaTypeEnum.OBJECT,
    properties: {
      subscriber: {
        type: JsonSchem...)
 - upsertLayoutUseCase(new UpsertLayout(
      getLayoutUseV0CaseMock as any,
      createLayoutUseCaseMock as any,
      u...)
 - result(await upsertLayoutUseCase.execute(command);

        expect(result).to.exist;
        expect(result....)
 - createCommand(createLayoutUseCaseMock.execute.firstCall.args[0];
        expect(createCommand.environmentId).to.eq...)
 - createCommand(createLayoutUseCaseMock.execute.firstCall.args[0];
        expect(createCommand.identifier).to.equal...)
 - createCommand(createLayoutUseCaseMock.execute.firstCall.args[0];
        expect(createCommand.isDefault).to.be.fal...)
 - result(await upsertLayoutUseCase.execute(command);

        expect(result).to.exist;
        expect(result....)
 - getCommand(getLayoutUseV0CaseMock.execute.firstCall.args[0];
        expect(getCommand.layoutIdOrInternalId).to...)
 - updateCommand(updateLayoutUseCaseMock.execute.firstCall.args[0];
        expect(updateCommand.environmentId).to.eq...)
 - upsertCommand(upsertControlValuesUseCaseMock.execute.firstCall.args[0];
        expect(upsertCommand.organizationI...)
 - deleteParams(controlValuesRepositoryMock.delete.firstCall.args[0];
        expect(deleteParams._environmentId).to...)
 - upsertCommand(upsertControlValuesUseCaseMock.execute.firstCall.args[0];
        expect(upsertCommand.newControlVal...)
 - command(UpsertLayoutCommand.create({
          userId: mockUser._id,
          environmentId: mockUser.envir...)
 - command(UpsertLayoutCommand.create({
          userId: mockUser._id,
          environmentId: mockUser.envir...)
 - command(UpsertLayoutCommand.create({
          userId: mockUser._id,
          environmentId: mockUser.envir...)
 - command(UpsertLayoutCommand.create({
          userId: mockUser._id,
          environmentId: mockUser.envir...)
 - command(UpsertLayoutCommand.create({
          userId: mockUser._id,
          environmentId: mockUser.envir...)
 - command(UpsertLayoutCommand.create({
          userId: mockUser._id,
          environmentId: mockUser.envir...)
 - issuesCommand(buildLayoutIssuesUsecaseMock.execute.firstCall.args[0];
        expect(issuesCommand.controlSchema)....)
 - issuesCommand(buildLayoutIssuesUsecaseMock.execute.firstCall.args[0];
        expect(issuesCommand.resourceOrigin)...)
 - command(UpsertLayoutCommand.create({
          userId: mockUser._id,
          environmentId: mockUser.envir...)
 - command(UpsertLayoutCommand.create({
        userId: mockUser._id,
        environmentId: mockUser.environme...)
 - command(UpsertLayoutCommand.create({
        userId: mockUser._id,
        environmentId: mockUser.environme...)
 - command(UpsertLayoutCommand.create({
        userId: mockUser._id,
        environmentId: mockUser.environme...)
 - command(UpsertLayoutCommand.create({
        userId: mockUser._id,
        environmentId: mockUser.environme...)
 - command(UpsertLayoutCommand.create({
        userId: mockUser._id,
        environmentId: mockUser.environme...)
 - updateCommand(updateLayoutUseCaseMock.execute.firstCall.args[0];
      expect(updateCommand.type).to.equal(Resourc...)
 - command(UpsertLayoutCommand.create({
        userId: mockUser._id,
        environmentId: mockUser.environme...)
 - command(UpsertLayoutCommand.create({
        userId: mockUser._id,
        environmentId: mockUser.environme...)
 - command(UpsertLayoutCommand.create({
        userId: mockUser._id,
        environmentId: mockUser.environme...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/usecases/upsert-layout/upsert-layout.usecase.ts
Tamaño: 8622 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import {
  AnalyticsService,
  GetLayoutCommand as GetLayoutCommandV0,
  GetLayoutUseCase as GetLayoutUseCaseV0,
  InstrumentUsecase,
  layoutControlSchema,
  PinoLogger,
  UpsertControlValuesCommand,
  UpsertControlValuesUseCase,
} from '@novu/application-generic';
import { ControlValuesRepository, LayoutRepository, LocalizationResourceEnum } from '@novu/dal';
import {
  ControlValuesLevelEnum,
  LayoutControlValuesDto,
  ResourceOriginEnum,
  ResourceTypeEnum,
  slugify,
} from '@novu/shared';
import { LayoutDto } from '../../../layouts-v1/dtos';
import {
  CreateLayoutCommand,
  CreateLayoutUseCase,
  UpdateLayoutCommand,
  UpdateLayoutUseCase,
} from '../../../layouts-v1/usecases';
import { isStringifiedMailyJSONContent } from '../../../shared/helpers/maily-utils';
import { LayoutResponseDto } from '../../dtos';
import { BuildLayoutIssuesCommand } from '../build-layout-issues/build-layout-issues.command';
import { BuildLayoutIssuesUsecase } from '../build-layout-issues/build-layout-issues.usecase';
import { GetLayoutCommand } from '../get-layout';
import { GetLayoutUseCase } from '../get-layout/get-layout.use-case';
import { UpsertLayoutCommand } from './upsert-layout.command';

@Injectable()
export class UpsertLayout {
  constructor(
    private getLayoutUseCaseV0: GetLayoutUseCaseV0,
    private createLayoutUseCaseV0: CreateLayoutUseCase,
    private updateLayoutUseCaseV0: UpdateLayoutUseCase,
    private controlValuesRepository: ControlValuesRepository,
    private upsertControlValuesUseCase: UpsertControlValuesUseCase,
    private layoutRepository: LayoutRepository,
    private analyticsService: AnalyticsService,
    private buildLayoutIssuesUsecase: BuildLayoutIssuesUsecase,
    private getLayoutUseCase: GetLayoutUseCase,
    private moduleRef: ModuleRef,
    private logger: PinoLogger
  ) {}

  @InstrumentUsecase()
  async execute(command: UpsertLayoutCommand): Promise<LayoutResponseDto> {
    const { controlValues } = command.layoutDto;

    await this.validateLayout({
      command,
      controlValues,
    });

    const existingLayout = command.layoutIdOrInternalId
      ? await this.getLayoutUseCaseV0.execute(
          GetLayoutCommandV0.create({
            layoutIdOrInternalId: command.layoutIdOrInternalId,
            environmentId: command.environmentId,
            organizationId: command.organizationId,
            type: ResourceTypeEnum.BRIDGE,
            origin: ResourceOriginEnum.NOVU_CLOUD,
          })
        )
      : null;

    let upsertedLayout: LayoutDto;
    if (existingLayout) {
      this.mixpanelTrack(command, 'Layout Update - [Layouts]');

      upsertedLayout = await this.updateLayoutUseCaseV0.execute(
        UpdateLayoutCommand.create({
          environmentId: command.environmentId,
          organizationId: command.organizationId,
          userId: command.userId,
          layoutId: existingLayout._id!,
          name: command.layoutDto.name,
          type: existingLayout.type ?? ResourceTypeEnum.BRIDGE,
          origin: existingLayout.origin ?? ResourceOriginEnum.NOVU_CLOUD,
        })
      );
    } else {
      this.mixpanelTrack(command, 'Layout Create - [Layouts]');

      const defaultLayout = await this.layoutRepository.findOne({
        _organizationId: command.organizationId,
        _environmentId: command.environmentId,
        type: ResourceTypeEnum.BRIDGE,
        origin: ResourceOriginEnum.NOVU_CLOUD,
        isDefault: true,
      });

      upsertedLayout = await this.createLayoutUseCaseV0.execute(
        CreateLayoutCommand.create({
          environmentId: command.environmentId,
          organizationId: command.organizationId,
          userId: command.userId,
          name: command.layoutDto.name,
          identifier: command.layoutDto.layoutId || slugify(command.layoutDto.name),
          type: ResourceTypeEnum.BRIDGE,
          origin: ResourceOriginEnum.NOVU_CLOUD,
          isDefault: !defaultLayout,
        })
      );
    }

    await this.toggleTranslationsForLayout(command, upsertedLayout);

    await this.upsertControlValues(command, upsertedLayout._id!);

    return await this.getLayoutUseCase.execute(
      GetLayoutCommand.create({
        layoutIdOrInternalId: upsertedLayout.identifier,
        environmentId: command.environmentId,
        organizationId: command.organizationId,
        userId: command.userId,
      })
    );
  }

  private async validateLayout({
    command,
    controlValues,
  }: {
    command: UpsertLayoutCommand;
    controlValues?: LayoutControlValuesDto | null;
  }) {
    if (!controlValues) {
      return;
    }

    if (controlValues.email) {
      const { body: content, editorType } = controlValues.email;
      const isMailyContent = isStringifiedMailyJSONContent(content);
      const isHtmlContent =
        content.includes('<html') &&
        content.includes('</html>') &&
        content.includes('<body') &&
        content.includes('</body>');

      if (!isMailyContent && !isHtmlContent) {
        throw new BadRequestException(
          editorType === 'html' ? 'Content must be a valid HTML content' : 'Content must be a valid Maily JSON content'
        );
      }

      if (editorType === 'html' && !isHtmlContent) {
        throw new BadRequestException('Content must be a valid HTML content');
      } else if (editorType === 'block' && !isMailyContent) {
        throw new BadRequestException('Content must be a valid Maily JSON content');
      }
    }

    const issues = await this.buildLayoutIssuesUsecase.execute(
      BuildLayoutIssuesCommand.create({
        controlSchema: layoutControlSchema,
        controlValues,
        resourceOrigin: command.layoutDto.__source ? ResourceOriginEnum.NOVU_CLOUD : ResourceOriginEnum.EXTERNAL,
        environmentId: command.environmentId,
        organizationId: command.organizationId,
        userId: command.userId,
      })
    );

    if (Object.keys(issues).length > 0) {
      throw new BadRequestException(issues);
    }
  }

  private async upsertControlValues(command: UpsertLayoutCommand, layoutId: string) {
    const {
      layoutDto: { controlValues },
    } = command;
    const doNothing = typeof controlValues === 'undefined';
    if (doNothing) {
      return null;
    }

    const shouldDelete = controlValues === null;
    if (shouldDelete) {
      this.controlValuesRepository.delete({
        _environmentId: command.environmentId,
        _organizationId: command.organizationId,
        _layoutId: layoutId,
        level: ControlValuesLevelEnum.LAYOUT_CONTROLS,
      });

      return null;
    }

    return this.upsertControlValuesUseCase.execute(
      UpsertControlValuesCommand.create({
        organizationId: command.organizationId,
        environmentId: command.environmentId,
        layoutId,
        level: ControlValuesLevelEnum.LAYOUT_CONTROLS,
        newControlValues: controlValues as unknown as Record<string, unknown>,
      })
    );
  }

  private mixpanelTrack(command: UpsertLayoutCommand, eventName: string) {
    this.analyticsService.mixpanelTrack(eventName, command.userId, {
      _organization: command.organizationId,
      name: command.layoutDto.name,
      source: command.layoutDto.__source,
    });
  }

  private async toggleTranslationsForLayout(command: UpsertLayoutCommand, layoutDto: LayoutDto) {
    const isEnterprise = process.env.NOVU_ENTERPRISE === 'true' || process.env.CI_EE_TEST === 'true';
    const isSelfHosted = process.env.IS_SELF_HOSTED === 'true';

    if (!isEnterprise || isSelfHosted) {
      return;
    }

    try {
      const manageTranslations = this.moduleRef.get(require('@novu/ee-translation')?.ManageTranslations, {
        strict: false,
      });

      await manageTranslations.execute({
        enabled: command.layoutDto.isTranslationEnabled,
        resourceId: layoutDto.identifier,
        resourceType: LocalizationResourceEnum.LAYOUT,
        organizationId: command.organizationId,
        environmentId: command.environmentId,
        userId: command.userId,
        resourceEntity: layoutDto,
      });
    } catch (error) {
      this.logger.error(
        `Failed to ${command.layoutDto.isTranslationEnabled ? 'enable' : 'disable'} translations for layout`,
        {
          layoutId: layoutDto.identifier,
          enabled: command.layoutDto.isTranslationEnabled,
          organizationId: command.organizationId,
          error: error instanceof Error ? error.message : String(error),
        }
      );

      throw error;
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpsertLayout

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/layouts-v2/utils/layout-templates.ts
Tamaño: 10619 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export const EMPTY_LAYOUT = {
  type: 'doc',
  content: [
    {
      type: 'paragraph',
      attrs: { textAlign: null, showIfKey: null },
      content: [{ type: 'text', text: ' ' }],
    },
    {
      type: 'paragraph',
      attrs: { textAlign: 'left', showIfKey: null },
      content: [
        {
          type: 'variable',
          attrs: {
            id: 'content',
            label: null,
            fallback: null,
            required: false,
            aliasFor: null,
          },
        },
      ],
    },
    {
      type: 'paragraph',
      attrs: { textAlign: null, showIfKey: null },
      content: [{ type: 'text', text: ' ' }],
    },
  ],
};

export const createDefaultLayout = (organizationName: string) => ({
  type: 'doc',
  content: [
    {
      type: 'section',
      attrs: {
        borderRadius: 0,
        backgroundColor: '#FFFFFF',
        align: 'left',
        borderWidth: 0,
        borderColor: '#e2e2e2',
        paddingTop: 8,
        paddingRight: 8,
        paddingBottom: 8,
        paddingLeft: 8,
        marginTop: 0,
        marginRight: 0,
        marginBottom: 0,
        marginLeft: 0,
        showIfKey: null,
      },
      content: [
        {
          type: 'spacer',
          attrs: { height: 8, showIfKey: null },
        },
        {
          type: 'columns',
          attrs: { showIfKey: null, gap: 8 },
          content: [
            {
              type: 'column',
              attrs: {
                columnId: '36de3eda-0677-47c3-a8b7-e071dec9ce30',
                width: 'auto',
                verticalAlign: 'middle',
              },
              content: [
                {
                  type: 'image',
                  attrs: {
                    src: 'https://prod-novu-app-bucket.s3.us-east-1.amazonaws.com/assets/email-editor/logo.png',
                    alt: null,
                    title: null,
                    width: '48',
                    height: '48',
                    alignment: 'left',
                    externalLink: null,
                    isExternalLinkVariable: false,
                    borderRadius: 0,
                    isSrcVariable: false,
                    aspectRatio: null,
                    lockAspectRatio: true,
                    showIfKey: null,
                    aliasFor: null,
                  },
                },
              ],
            },
            {
              type: 'column',
              attrs: {
                columnId: '6feb593e-374a-4479-a1c7-872c60c2f4e0',
                width: 'auto',
                verticalAlign: 'middle',
              },
              content: [
                {
                  type: 'paragraph',
                  attrs: { textAlign: 'right', showIfKey: null },
                },
              ],
            },
          ],
        },
      ],
    },
    {
      type: 'section',
      attrs: {
        borderRadius: 6,
        backgroundColor: '#ffffff',
        align: 'left',
        borderWidth: 0,
        borderColor: '#ffffff',
        paddingTop: 8,
        paddingRight: 8,
        paddingBottom: 8,
        paddingLeft: 8,
        marginTop: 0,
        marginRight: 0,
        marginBottom: 0,
        marginLeft: 0,
        showIfKey: null,
      },
      content: [
        {
          type: 'spacer',
          attrs: { height: 4, showIfKey: null },
        },
        {
          type: 'paragraph',
          attrs: { textAlign: null, showIfKey: null },
          content: [
            {
              type: 'variable',
              attrs: {
                id: 'content',
                label: null,
                fallback: null,
                required: false,
                aliasFor: null,
              },
            },
            { type: 'text', text: ' ' },
          ],
        },
        {
          type: 'spacer',
          attrs: { height: 4, showIfKey: null },
        },
      ],
    },
    {
      type: 'section',
      attrs: {
        borderRadius: 0,
        backgroundColor: '#FFFFFF',
        align: 'left',
        borderWidth: 0,
        borderColor: '#e2e2e2',
        paddingTop: 8,
        paddingRight: 8,
        paddingBottom: 8,
        paddingLeft: 8,
        marginTop: 0,
        marginRight: 0,
        marginBottom: 0,
        marginLeft: 0,
        showIfKey: null,
      },
      content: [
        {
          type: 'columns',
          attrs: { showIfKey: null, gap: 0 },
          content: [
            {
              type: 'column',
              attrs: {
                columnId: '8a20f82f-ecb5-4cbd-923e-ff82f3bb9b79',
                width: '60',
                verticalAlign: 'top',
              },
              content: [
                {
                  type: 'paragraph',
                  attrs: { textAlign: null, showIfKey: null },
                  content: [{ type: 'text', text: organizationName }],
                },
                {
                  type: 'spacer',
                  attrs: { height: 4, showIfKey: null },
                },
                {
                  type: 'footer',
                  attrs: { textAlign: null, 'maily-component': 'footer' },
                  content: [
                    {
                      type: 'text',
                      marks: [{ type: 'textStyle', attrs: { color: 'rgb(55, 65, 81)' } }],
                      text: '1234 Example Street, DE 19801, United States',
                    },
                  ],
                },
              ],
            },
            {
              type: 'column',
              attrs: {
                columnId: 'cd30ba93-7a8f-4d03-b66a-88ae4fe99abf',
                width: '40',
                verticalAlign: 'top',
              },
              content: [
                {
                  type: 'footer',
                  attrs: { textAlign: 'right', 'maily-component': 'footer' },
                  content: [
                    {
                      type: 'text',
                      marks: [
                        {
                          type: 'link',
                          attrs: {
                            href: 'https://novu.co/',
                            target: '_blank',
                            rel: 'noopener noreferrer nofollow',
                            class: null,
                            isUrlVariable: false,
                            aliasFor: null,
                          },
                        },
                      ],
                      text: 'Visit Company',
                    },
                    { type: 'text', text: ' | ' },
                    {
                      type: 'text',
                      marks: [
                        {
                          type: 'link',
                          attrs: {
                            href: 'support@novu.co',
                            target: '_blank',
                            rel: 'noopener noreferrer nofollow',
                            class: null,
                            isUrlVariable: false,
                            aliasFor: null,
                          },
                        },
                      ],
                      text: 'Contact Us',
                    },
                  ],
                },
                {
                  type: 'spacer',
                  attrs: { height: 4, showIfKey: null },
                },
                {
                  type: 'section',
                  attrs: {
                    borderRadius: 0,
                    backgroundColor: '#FFFFFF',
                    align: 'left',
                    borderWidth: 0,
                    borderColor: '#e2e2e2',
                    paddingTop: 0,
                    paddingRight: 0,
                    paddingBottom: 0,
                    paddingLeft: 0,
                    marginTop: 0,
                    marginRight: 0,
                    marginBottom: 0,
                    marginLeft: 0,
                    showIfKey: null,
                  },
                  content: [
                    {
                      type: 'paragraph',
                      attrs: { textAlign: 'right', showIfKey: null },
                      content: [
                        {
                          type: 'inlineImage',
                          attrs: {
                            height: 20,
                            width: 20,
                            src: 'https://prod-novu-app-bucket.s3.us-east-1.amazonaws.com/assets/email-editor/linkedin.png',
                            isSrcVariable: false,
                            alt: null,
                            title: null,
                            externalLink: 'https://www.linkedin.com/company/novuco/',
                            isExternalLinkVariable: false,
                            aliasFor: null,
                          },
                        },
                        { type: 'text', text: '  ' },
                        {
                          type: 'inlineImage',
                          attrs: {
                            height: 20,
                            width: 20,
                            src: 'https://prod-novu-app-bucket.s3.us-east-1.amazonaws.com/assets/email-editor/youtube.png',
                            isSrcVariable: false,
                            alt: null,
                            title: null,
                            externalLink: 'https://www.youtube.com/@novuhq',
                            isExternalLinkVariable: false,
                            aliasFor: null,
                          },
                        },
                        { type: 'text', text: '  ' },
                        {
                          type: 'inlineImage',
                          attrs: {
                            height: 20,
                            width: 20,
                            src: 'https://prod-novu-app-bucket.s3.us-east-1.amazonaws.com/assets/email-editor/twitter.png',
                            isSrcVariable: false,
                            alt: null,
                            title: null,
                            externalLink: 'https://x.com/novuhq',
                            isExternalLinkVariable: false,
                            aliasFor: null,
                          },
                        },
                      ],
                    },
                  ],
                },
              ],
            },
          ],
        },
      ],
    },
    {
      type: 'spacer',
      attrs: { height: 8, showIfKey: null },
    },
  ],
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - createDefaultLayout(organizationName: string))
Declaraciones 'export' encontradas:
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/message-template/message-template.controller.ts
Tamaño: 171 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Controller } from '@nestjs/common';
import { ApiBearerAuth } from '@nestjs/swagger';

@Controller('/message-templates')
export class MessageTemplateController {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class MessageTemplateController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/message-template/message-template.module.ts
Tamaño: 461 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Module } from '@nestjs/common';
import { ChangeModule } from '../change/change.module';
import { SharedModule } from '../shared/shared.module';
import { MessageTemplateController } from './message-template.controller';
import { USE_CASES } from './usecases';

@Module({
  imports: [SharedModule, ChangeModule],
  controllers: [MessageTemplateController],
  providers: [...USE_CASES],
  exports: [...USE_CASES],
})
export class MessageTemplateModule {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class MessageTemplateModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/message-template/usecases/index.ts
Tamaño: 443 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CreateMessageTemplate, DeleteMessageTemplate, UpdateMessageTemplate } from '@novu/application-generic';

import { FindMessageTemplatesByLayoutUseCase } from './find-message-templates-by-layout/find-message-templates-by-layout.use-case';

export * from './find-message-templates-by-layout';
export const USE_CASES = [
  CreateMessageTemplate,
  FindMessageTemplatesByLayoutUseCase,
  UpdateMessageTemplate,
  DeleteMessageTemplate,
];


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/message-template/usecases/find-message-templates-by-layout/find-message-templates-by-layout.command.ts
Tamaño: 306 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { LayoutId } from '@novu/shared';
import { IsDefined, IsString } from 'class-validator';

import { EnvironmentCommand } from '../../../shared/commands/project.command';

export class FindMessageTemplatesByLayoutCommand extends EnvironmentCommand {
  @IsDefined()
  @IsString()
  layoutId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class FindMessageTemplatesByLayoutCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/message-template/usecases/find-message-templates-by-layout/find-message-templates-by-layout.use-case.ts
Tamaño: 765 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { MessageTemplateEntity, MessageTemplateRepository } from '@novu/dal';

import { FindMessageTemplatesByLayoutCommand } from './find-message-templates-by-layout.command';

const DEFAULT_PAGE_SIZE = 100;

@Injectable()
export class FindMessageTemplatesByLayoutUseCase {
  constructor(private messageTemplateRepository: MessageTemplateRepository) {}

  async execute(command: FindMessageTemplatesByLayoutCommand): Promise<MessageTemplateEntity[]> {
    // TODO: Implement proper pagination
    const messageTemplates = await this.messageTemplateRepository.getMessageTemplatesByLayout(
      command.environmentId,
      command.layoutId,
      { limit: DEFAULT_PAGE_SIZE }
    );

    return messageTemplates;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class FindMessageTemplatesByLayoutUseCase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/message-template/usecases/find-message-templates-by-layout/index.ts
Tamaño: 121 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './find-message-templates-by-layout.command';
export * from './find-message-templates-by-layout.use-case';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/messages/messages.controller.ts
Tamaño: 5221 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Controller, Delete, Get, HttpCode, HttpStatus, Param, Query } from '@nestjs/common';
import { ApiOperation, ApiParam, ApiTags } from '@nestjs/swagger';
import { RequirePermissions } from '@novu/application-generic';
import { PermissionsEnum, UserSessionData } from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { ExternalApiAccessible } from '../auth/framework/external-api.decorator';
import {
  ApiCommonResponses,
  ApiNoContentResponse,
  ApiOkResponse,
  ApiResponse,
} from '../shared/framework/response.decorator';
import { SdkMethodName } from '../shared/framework/swagger/sdk.decorators';
import { UserSession } from '../shared/framework/user.decorator';
import { MessagesResponseDto } from '../widgets/dtos/message-response.dto';
import { DeleteMessageResponseDto } from './dtos/delete-message-response.dto';
import { GetMessagesRequestDto } from './dtos/get-messages-requests.dto';
import { DeleteMessageByTransactionIdRequestDto } from './dtos/remove-messages-by-transactionId-request.dto';
import { DeleteMessageParams } from './params/delete-message.param';
import { GetMessages, GetMessagesCommand } from './usecases/get-messages';
import { RemoveMessage, RemoveMessageCommand } from './usecases/remove-message';
import { RemoveMessagesByTransactionIdCommand } from './usecases/remove-messages-by-transactionId/remove-messages-by-transactionId.command';
import { RemoveMessagesByTransactionId } from './usecases/remove-messages-by-transactionId/remove-messages-by-transactionId.usecase';

@ApiCommonResponses()
@RequireAuthentication()
@Controller('/messages')
@ApiTags('Messages')
export class MessagesController {
  constructor(
    private removeMessage: RemoveMessage,
    private getMessagesUsecase: GetMessages,
    private removeMessagesByTransactionId: RemoveMessagesByTransactionId
  ) {}

  @Get('')
  @ExternalApiAccessible()
  @ApiOkResponse({
    type: MessagesResponseDto,
  })
  @ApiOperation({
    summary: 'List all messages',
    description: `List all messages for the current environment. 
    This API supports filtering by **channel**, **subscriberId**, and **transactionId**. 
    This API returns a paginated list of messages.`,
  })
  @RequirePermissions(PermissionsEnum.MESSAGE_READ)
  async getMessages(
    @UserSession() user: UserSessionData,
    @Query() query: GetMessagesRequestDto
  ): Promise<MessagesResponseDto> {
    let transactionIdQuery: string[] | undefined;
    if (query.transactionId) {
      transactionIdQuery = Array.isArray(query.transactionId) ? query.transactionId : [query.transactionId];
    }

    let contextKeysQuery: string[] | undefined;
    if (query.contextKeys !== undefined) {
      contextKeysQuery = Array.isArray(query.contextKeys) ? query.contextKeys : [query.contextKeys];
    }

    return await this.getMessagesUsecase.execute(
      GetMessagesCommand.create({
        organizationId: user.organizationId,
        environmentId: user.environmentId,
        channel: query.channel,
        subscriberId: query.subscriberId,
        contextKeys: contextKeysQuery,
        page: query.page ? Number(query.page) : 0,
        limit: query.limit ? Number(query.limit) : 10,
        transactionIds: transactionIdQuery,
      })
    );
  }

  @Delete('/:messageId')
  @ExternalApiAccessible()
  @ApiResponse(DeleteMessageResponseDto)
  @ApiOperation({
    summary: 'Delete a message',
    description: `Delete a message entity from the Novu platform by **messageId**. 
    This action is irreversible. **messageId** is required and of mongodbId type.`,
  })
  @ApiParam({ name: 'messageId', type: String, required: true, example: '507f1f77bcf86cd799439011' })
  @RequirePermissions(PermissionsEnum.MESSAGE_WRITE)
  async deleteMessage(
    @UserSession() user: UserSessionData,
    @Param() { messageId }: DeleteMessageParams
  ): Promise<DeleteMessageResponseDto> {
    return await this.removeMessage.execute(
      RemoveMessageCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        messageId,
      })
    );
  }

  @Delete('/transaction/:transactionId')
  @HttpCode(HttpStatus.NO_CONTENT)
  @ExternalApiAccessible()
  @ApiNoContentResponse()
  @ApiOperation({
    summary: 'Delete messages by transactionId',
    description: `Delete multiple messages from the Novu platform using **transactionId** of triggered event. 
    This API supports filtering by **channel** and delete all messages associated with the **transactionId**.`,
  })
  @ApiParam({ name: 'transactionId', type: String, required: true, example: '507f1f77bcf86cd799439011' })
  @SdkMethodName('deleteByTransactionId')
  @RequirePermissions(PermissionsEnum.MESSAGE_WRITE)
  async deleteMessagesByTransactionId(
    @UserSession() user: UserSessionData,
    @Param() { transactionId }: { transactionId: string },
    @Query() query: DeleteMessageByTransactionIdRequestDto
  ) {
    return await this.removeMessagesByTransactionId.execute(
      RemoveMessagesByTransactionIdCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        transactionId,
        channel: query.channel,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class MessagesController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/messages/messages.module.ts
Tamaño: 691 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { forwardRef, Module } from '@nestjs/common';
import { TerminusModule } from '@nestjs/terminus';
import { AuthModule } from '../auth/auth.module';
import { SharedModule } from '../shared/shared.module';
import { SubscribersV1Module } from '../subscribers/subscribersV1.module';
import { WidgetsModule } from '../widgets/widgets.module';
import { MessagesController } from './messages.controller';
import { USE_CASES } from './usecases';

@Module({
  imports: [SharedModule, SubscribersV1Module, AuthModule, TerminusModule, forwardRef(() => WidgetsModule)],
  controllers: [MessagesController],
  providers: [...USE_CASES],
  exports: [...USE_CASES],
})
export class MessagesModule {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class MessagesModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/messages/dtos/delete-message-response.dto.ts
Tamaño: 451 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IsBoolean, IsDefined, IsString } from 'class-validator';

export class DeleteMessageResponseDto {
  @ApiProperty({
    description: 'A boolean stating the success of the action',
  })
  @IsBoolean()
  @IsDefined()
  acknowledged: boolean;

  @ApiProperty({
    description: 'The status enum for the performed action',
    enum: ['deleted'],
  })
  @IsString()
  @IsDefined()
  status: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DeleteMessageResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/messages/dtos/get-messages-requests.dto.ts
Tamaño: 1273 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiHideProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { ChannelTypeEnum } from '@novu/shared';
import { Transform } from 'class-transformer';
import { IsArray, IsNumber, IsOptional, IsString } from 'class-validator';

export class GetMessagesRequestDto {
  @ApiPropertyOptional({
    enum: [...Object.values(ChannelTypeEnum)],
    enumName: 'ChannelTypeEnum',
  })
  channel?: ChannelTypeEnum;

  @ApiPropertyOptional({
    type: String,
  })
  @IsOptional()
  subscriberId?: string;

  @ApiPropertyOptional({
    type: String,
    isArray: true,
  })
  @IsOptional()
  transactionId?: string[];

  @ApiPropertyOptional({
    type: String,
    isArray: true,
    description: 'Filter by exact context keys (format: "type:id")',
    example: ['tenant:org-123', 'region:us-east-1'],
  })
  @IsOptional()
  contextKeys?: string[] | string;

  @ApiPropertyOptional({
    type: Number,
    default: 0,
  })
  @IsOptional()
  @IsNumber()
  @Transform(({ value }) => Number(value))
  page?: number;

  @ApiPropertyOptional({
    type: Number,
    default: 10,
  })
  @IsOptional()
  @IsNumber()
  @Transform(({ value }) => Number(value))
  limit?: number;

  constructor() {
    this.page = 0; // Default value
    this.limit = 10; // Default value
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetMessagesRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/messages/dtos/remove-messages-by-transactionId-request.dto.ts
Tamaño: 404 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiPropertyOptional } from '@nestjs/swagger';
import { ChannelTypeEnum } from '@novu/shared';
import { IsEnum, IsOptional } from 'class-validator';

export class DeleteMessageByTransactionIdRequestDto {
  @ApiPropertyOptional({
    enum: ChannelTypeEnum,
    description: 'The channel of the message to be deleted',
  })
  @IsOptional()
  @IsEnum(ChannelTypeEnum)
  channel?: ChannelTypeEnum;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DeleteMessageByTransactionIdRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/messages/e2e/get-messages.e2e.ts
Tamaño: 5860 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { ChannelTypeEnum } from '@novu/api/models/components';
import { NotificationTemplateEntity, SubscriberEntity } from '@novu/dal';
import { CreateWorkflowDto, StepTypeEnum, WorkflowCreationSourceEnum, WorkflowResponseDto } from '@novu/shared';
import { SubscribersService, UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Get Message - /messages (GET) #novu-v2', () => {
  let session: UserSession;
  let template: NotificationTemplateEntity;
  let subscriber: SubscriberEntity;
  let subscriberService: SubscribersService;
  let novuClient: Novu;
  const isContextEnabled = process.env.IS_CONTEXT_ENABLED;

  before(() => {
    // @ts-expect-error
    process.env.IS_CONTEXT_ENABLED = 'true';
  });

  after(() => {
    // @ts-expect-error
    process.env.IS_CONTEXT_ENABLED = isContextEnabled;
  });

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();

    template = await session.createTemplate();
    subscriberService = new SubscribersService(session.organization._id, session.environment._id);
    subscriber = await subscriberService.createSubscriber();
    novuClient = initNovuClassSdk(session);
  });

  it('should fetch existing messages', async () => {
    const subscriber2 = await subscriberService.createSubscriber();

    await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: [
        { subscriberId: subscriber.subscriberId, email: 'gg@ff.com' },
        { subscriberId: subscriber2.subscriberId, email: 'john@doe.com' },
      ],
      payload: {
        email: 'new-test-email@gmail.com',
        firstName: 'Testing of User Name',
        urlVar: '/test/url/path',
      },
    });

    await session.waitForJobCompletion(template._id);

    let response = await novuClient.messages.retrieve({});
    expect(response.result.data.length).to.be.equal(4);

    response = await novuClient.messages.retrieve({ channel: ChannelTypeEnum.Email });
    expect(response.result.data.length).to.be.equal(2);

    response = await novuClient.messages.retrieve({ subscriberId: subscriber2.subscriberId });
    expect(response.result.data.length).to.be.equal(2);
  });

  it('should fetch messages using transactionId filter', async () => {
    const subscriber3 = await subscriberService.createSubscriber();

    const transactionId1 = '1566f9d0-6037-48c1-b356-42667921cadd';
    const transactionId2 = 'd2d9f9b5-4a96-403a-927f-1f8f40c6c7a9';

    await triggerEventWithTransactionId(template.triggers[0].identifier, subscriber3.subscriberId, transactionId1);
    await triggerEventWithTransactionId(template.triggers[0].identifier, subscriber3.subscriberId, transactionId2);

    await session.waitForWorkflowQueueCompletion();
    await session.waitForSubscriberQueueCompletion();
    await session.waitForStandardQueueCompletion();
    await session.waitForJobCompletion(template._id);

    let response = await novuClient.messages.retrieve({ subscriberId: subscriber3.subscriberId });
    expect(response.result.data.length).to.be.equal(4);

    response = await novuClient.messages.retrieve({ transactionId: [transactionId1] });
    expect(response.result.data.length).to.be.equal(2);

    response = await novuClient.messages.retrieve({ transactionId: [transactionId1, transactionId2] });
    expect(response.result.data.length).to.be.equal(4);

    response = await novuClient.messages.retrieve({ transactionId: [transactionId2] });
    expect(response.result.data.length).to.be.equal(2);
  });

  it('should fetch messages using contextKeys filter', async () => {
    const subscriber4 = await subscriberService.createSubscriber();

    const workflowBody: CreateWorkflowDto = {
      name: 'Test Context Workflow',
      workflowId: 'test-context-workflow-messages',
      __source: WorkflowCreationSourceEnum.DASHBOARD,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          name: 'Test Step',
          controlValues: {
            subject: 'Test Subject',
            body: 'Test Body',
          },
        },
      ],
    };

    const workflowResponse = await session.testAgent.post('/v2/workflows').send(workflowBody);
    expect(workflowResponse.status).to.equal(201);
    const workflow: WorkflowResponseDto = workflowResponse.body.data;

    await novuClient.trigger({
      workflowId: workflow.workflowId,
      to: subscriber4.subscriberId,
      payload: {},
      context: { teamId: 'team-alpha' },
    });

    await novuClient.trigger({
      workflowId: workflow.workflowId,
      to: subscriber4.subscriberId,
      payload: {},
      context: { teamId: 'team-beta' },
    });

    await session.waitForWorkflowQueueCompletion();
    await session.waitForSubscriberQueueCompletion();
    await session.waitForStandardQueueCompletion();
    await session.waitForJobCompletion(workflow._id);

    let response = await novuClient.messages.retrieve({ subscriberId: subscriber4.subscriberId });
    expect(response.result.data.length).to.be.equal(2);

    response = await novuClient.messages.retrieve({
      subscriberId: subscriber4.subscriberId,
      contextKeys: ['teamId:team-alpha'],
    });
    expect(response.result.data.length).to.be.equal(1);

    response = await novuClient.messages.retrieve({
      subscriberId: subscriber4.subscriberId,
      contextKeys: ['teamId:team-beta'],
    });
    expect(response.result.data.length).to.be.equal(1);
  });

  async function triggerEventWithTransactionId(
    templateIdentifier: string,
    subscriberId: string,
    transactionId: string
  ) {
    return await novuClient.trigger({
      workflowId: templateIdentifier,
      to: [{ subscriberId, email: 'gg@ff.com' }],
      payload: {},
      transactionId,
    });
  }
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - triggerEventWithTransactionId(templateIdentifier: string,
    subscriberId: string,
    transactionId: string)
Asignaciones con arrow functions encontradas (posibles funciones):
 - isContextEnabled(process.env.IS_CONTEXT_ENABLED;

  before(())
 - IS_CONTEXT_ENABLED('true';
  });

  after(())
 - IS_CONTEXT_ENABLED(isContextEnabled;
  });

  beforeEach(async ())
 - novuClient(initNovuClassSdk(session);
  });

  it('should fetch existing messages', async ())
 - response(await novuClient.messages.retrieve({ subscriberId: subscriber2.subscriberId });
    expect(response....)
 - response(await novuClient.messages.retrieve({ transactionId: [transactionId2] });
    expect(response.result....)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/messages/e2e/remove-message.e2e.ts
Tamaño: 2181 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { MessageRepository, NotificationTemplateEntity, SubscriberEntity } from '@novu/dal';
import { ChannelTypeEnum } from '@novu/shared';
import { SubscribersService, UserSession } from '@novu/testing';
import axios from 'axios';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

const axiosInstance = axios.create();

describe('Delete Message - /messages/:messageId (DELETE) #novu-v2', () => {
  let session: UserSession;
  const messageRepository = new MessageRepository();
  let template: NotificationTemplateEntity;
  let subscriber: SubscriberEntity;
  let subscriberService: SubscribersService;
  let novuClient: Novu;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    template = await session.createTemplate();
    subscriberService = new SubscribersService(session.organization._id, session.environment._id);
    subscriber = await subscriberService.createSubscriber();
    novuClient = initNovuClassSdk(session);
  });

  it('should fail to delete non existing message', async () => {
    const response = await session.testAgent.delete(`/v1/messages/${MessageRepository.createObjectId()}`);

    expect(response.statusCode).to.equal(404);
    expect(response.body.error).to.equal('Not Found');
  });

  it('should delete a existing message', async () => {
    await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: [{ subscriberId: subscriber.subscriberId, email: 'gg@ff.com' }],
      payload: {
        email: 'new-test-email@gmail.com',
        firstName: 'Testing of User Name',
        urlVar: '/test/url/path',
      },
    });

    await session.waitForJobCompletion(template._id);

    const messages = await messageRepository.findBySubscriberChannel(
      session.environment._id,
      subscriber._id,
      ChannelTypeEnum.EMAIL
    );

    const message = messages[0];

    await novuClient.messages.delete(message._id);

    const result = await messageRepository.findOne({ _id: message._id, _environmentId: message._environmentId });
    expect(result).to.not.be.ok;
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - axiosInstance(axios.create();

describe('Delete Message - /messages/:messageId (DELETE) #novu-v2', ())
 - messageRepository(new MessageRepository();
  let template: NotificationTemplateEntity;
  let subscriber: SubscriberEnt...)
 - novuClient(initNovuClassSdk(session);
  });

  it('should fail to delete non existing message', async ())
 - response(await session.testAgent.delete(`/v1/messages/${MessageRepository.createObjectId()}`);

    expect(re...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/messages/e2e/remove-messages-by-transactionId.e2e.ts
Tamaño: 4436 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { MessageRepository, NotificationTemplateEntity, SubscriberEntity } from '@novu/dal';
import { ChannelTypeEnum } from '@novu/shared';
import { SubscribersService, UserSession } from '@novu/testing';
import { expect } from 'chai';
import { expectSdkExceptionGeneric, initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Delete Messages By TransactionId - /messages/?transactionId= (DELETE) #novu-v2', () => {
  let session: UserSession;
  const messageRepository = new MessageRepository();
  let template: NotificationTemplateEntity;
  let subscriber: SubscriberEntity;
  let subscriberService: SubscribersService;
  let novuClient: Novu;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    template = await session.createTemplate();
    subscriberService = new SubscribersService(session.organization._id, session.environment._id);
    subscriber = await subscriberService.createSubscriber();
    novuClient = initNovuClassSdk(session);
  });

  it('should fail to delete non existing message', async () => {
    const { error } = await expectSdkExceptionGeneric(() => novuClient.messages.deleteByTransactionId('abc-1234'));
    expect(error?.statusCode).to.equal(404);
    expect(error?.ctx?.error, JSON.stringify(error)).to.equal('Not Found');
  });

  it('should delete messages by transactionId', async () => {
    await novuClient.subscribers.create({
      subscriberId: '123456',
      firstName: 'broadcast ',
      lastName: 'subscriber',
    });

    const res = await novuClient.triggerBroadcast({
      name: template.triggers[0].identifier,
      payload: {
        email: 'new-test-email@gmail.com',
        firstName: 'Testing of User Name',
        urlVar: '/test/url/path',
      },
    });
    await session.waitForJobCompletion(template._id);

    const { transactionId } = res.result;

    const messages = await messageRepository.find({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      transactionId,
    });

    expect(messages.length).to.be.greaterThan(0);
    expect(transactionId).to.be.ok;

    if (transactionId == null) {
      throw new Error('must have transaction id');
    }
    await novuClient.messages.deleteByTransactionId(transactionId);

    const result = await messageRepository.find({
      transactionId,
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
    });

    expect(result.length).to.equal(0);
  });

  it('should delete messages by transactionId and channel', async () => {
    const response = await novuClient.triggerBroadcast({
      name: template.triggers[0].identifier,
      payload: {
        email: 'new-test-email@gmail.com',
        firstName: 'Testing of User Name',
        urlVar: '/test/url/path',
      },
    });

    await session.waitForJobCompletion(template._id);
    const { transactionId } = response.result;

    const messages = await messageRepository.find({
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
      transactionId,
    });

    const emailMessages = messages.filter((message) => message.channel === ChannelTypeEnum.EMAIL);
    const inAppMessages = messages.filter((message) => message.channel === ChannelTypeEnum.IN_APP);
    const inAppMessagesCount = inAppMessages.length;

    expect(messages.length).to.be.greaterThan(0);
    expect(emailMessages.length).to.be.greaterThan(0);
    expect(inAppMessagesCount).to.be.greaterThan(0);
    expect(transactionId).to.be.ok;
    if (transactionId == null) {
      throw new Error('must have transaction id');
    }
    await novuClient.messages.deleteByTransactionId(transactionId, ChannelTypeEnum.EMAIL);

    const result = await messageRepository.find({
      transactionId,
      _environmentId: session.environment._id,
      _organizationId: session.organization._id,
    });

    const emailResult = result.filter((message) => message.channel === ChannelTypeEnum.EMAIL);
    const inAppResult = result.filter((message) => message.channel === ChannelTypeEnum.IN_APP);
    const inAppResultCount = inAppResult.length;

    expect(result.length).to.be.greaterThan(0);
    expect(emailResult.length).to.equal(0);
    expect(inAppResultCount).to.be.greaterThan(0);
    expect(inAppResultCount).to.equal(inAppMessagesCount);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - transactionId(DELETE) #novu-v2', ())
 - messageRepository(new MessageRepository();
  let template: NotificationTemplateEntity;
  let subscriber: SubscriberEnt...)
 - novuClient(initNovuClassSdk(session);
  });

  it('should fail to delete non existing message', async ())
 - result(await messageRepository.find({
      transactionId,
      _environmentId: session.environment._id,
 ...)
 - emailMessages(messages.filter((message))
 - inAppMessages(messages.filter((message))
 - emailResult(result.filter((message))
 - inAppResult(result.filter((message))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/messages/params/delete-message.param.ts
Tamaño: 119 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsMongoId } from 'class-validator';

export class DeleteMessageParams {
  @IsMongoId()
  messageId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DeleteMessageParams

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/messages/usecases/index.ts
Tamaño: 308 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { GetMessages } from './get-messages';
import { RemoveMessage } from './remove-message';
import { RemoveMessagesByTransactionId } from './remove-messages-by-transactionId/remove-messages-by-transactionId.usecase';

export const USE_CASES = [RemoveMessage, GetMessages, RemoveMessagesByTransactionId];


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/messages/usecases/get-messages/get-messages.command.ts
Tamaño: 592 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChannelTypeEnum } from '@novu/shared';
import { IsArray, IsNumber, IsOptional, IsString } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';

export class GetMessagesCommand extends EnvironmentCommand {
  @IsOptional()
  subscriberId?: string;

  @IsOptional()
  channel?: ChannelTypeEnum;

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  contextKeys?: string[];

  @IsNumber()
  page = 0;

  @IsNumber()
  limit = 10;

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  transactionIds?: string[] | undefined;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetMessagesCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/messages/usecases/get-messages/get-messages.usecase.ts
Tamaño: 3105 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable } from '@nestjs/common';
import { FeatureFlagsService } from '@novu/application-generic';
import { MessageEntity, MessageRepository, OrganizationEntity, SubscriberEntity } from '@novu/dal';
import { ActorTypeEnum, FeatureFlagsKeysEnum } from '@novu/shared';
import { GetSubscriber, GetSubscriberCommand } from '../../../subscribers/usecases/get-subscriber';
import { GetMessagesCommand } from './get-messages.command';

@Injectable()
export class GetMessages {
  constructor(
    private messageRepository: MessageRepository,
    private getSubscriberUseCase: GetSubscriber,
    private featureFlagService: FeatureFlagsService
  ) {}

  async execute(command: GetMessagesCommand) {
    const LIMIT = command.limit;
    const COUNT_LIMIT = 1000;

    if (LIMIT > 1000) {
      throw new BadRequestException('Limit can not be larger then 1000');
    }

    const query: Partial<Omit<MessageEntity, 'transactionId'>> & {
      _environmentId: string;
      transactionId?: string[];
      contextKeys?: string[];
    } = {
      _environmentId: command.environmentId,
    };

    if (command.subscriberId) {
      const subscriber = await this.getSubscriberUseCase.execute(
        GetSubscriberCommand.create({
          subscriberId: command.subscriberId,
          environmentId: command.environmentId,
          organizationId: command.organizationId,
        })
      );

      query._subscriberId = subscriber._id;
    }

    if (command.channel) {
      query.channel = command.channel;
    }

    if (command.transactionIds) {
      query.transactionId = command.transactionIds;
    }

    if (command.contextKeys) {
      query.contextKeys = command.contextKeys;
    }

    const data = await this.messageRepository.getMessages(query, '', {
      limit: LIMIT,
      sort: { createdAt: -1 },
      skip: command.page * LIMIT,
    });

    for (const message of data) {
      if (message._actorId && message.actor?.type === ActorTypeEnum.USER) {
        message.actor.data = this.processUserAvatar(message.actorSubscriber);
      }
    }

    const isEnabled = await this.featureFlagService.getFlag({
      key: FeatureFlagsKeysEnum.IS_NEW_MESSAGES_API_RESPONSE_ENABLED,
      organization: { _id: command.organizationId } as OrganizationEntity,
      defaultValue: false,
    });

    if (isEnabled) {
      return {
        hasMore: data?.length === command.limit,
        page: command.page,
        pageSize: LIMIT,
        data,
      };
    }

    const totalCount = await this.messageRepository.count(query);

    const hasMore = this.getHasMore(command.page, LIMIT, data.length, totalCount);

    return {
      page: command.page,
      totalCount,
      hasMore,
      pageSize: LIMIT,
      data,
    };
  }

  private getHasMore(page: number, limit: number, feedLength: number, totalCount: number) {
    const currentPaginationTotal = page * limit + feedLength;

    return currentPaginationTotal < totalCount;
  }

  private processUserAvatar(actorSubscriber?: SubscriberEntity): string | null {
    return actorSubscriber?.avatar || null;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetMessages

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/messages/usecases/get-messages/index.ts
Tamaño: 80 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './get-messages.command';
export * from './get-messages.usecase';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/messages/usecases/remove-message/index.ts
Tamaño: 84 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './remove-message.command';
export * from './remove-message.usecase';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/messages/usecases/remove-message/remove-message.command.ts
Tamaño: 224 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsString } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';

export class RemoveMessageCommand extends EnvironmentCommand {
  @IsString()
  messageId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RemoveMessageCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/messages/usecases/remove-message/remove-message.usecase.ts
Tamaño: 1541 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import { buildFeedKey, buildMessageCountKey, InvalidateCacheService } from '@novu/application-generic';
import { MessageRepository } from '@novu/dal';

import { RemoveMessageCommand } from './remove-message.command';

@Injectable()
export class RemoveMessage {
  constructor(
    private invalidateCache: InvalidateCacheService,
    private messageRepository: MessageRepository
  ) {}

  async execute(command: RemoveMessageCommand) {
    const message = await this.messageRepository.findMessageById({
      _environmentId: command.environmentId,
      _id: command.messageId,
    });
    if (!message) {
      throw new NotFoundException(`Message with id ${command.messageId} not found`);
    }

    if (!message.subscriber)
      throw new BadRequestException(`A subscriber was not found for message ${command.messageId}`);

    await this.invalidateCache.invalidateQuery({
      key: buildFeedKey().invalidate({
        subscriberId: message.subscriber.subscriberId,
        _environmentId: command.environmentId,
      }),
    });

    await this.invalidateCache.invalidateQuery({
      key: buildMessageCountKey().invalidate({
        subscriberId: message.subscriber.subscriberId,
        _environmentId: command.environmentId,
      }),
    });

    await this.messageRepository.delete({
      _environmentId: command.environmentId,
      _id: command.messageId,
    });

    return {
      acknowledged: true,
      status: 'deleted',
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RemoveMessage

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/messages/usecases/remove-messages-by-transactionId/remove-messages-by-transactionId.command.ts
Tamaño: 385 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChannelTypeEnum } from '@novu/shared';
import { IsEnum, IsOptional, IsString } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';

export class RemoveMessagesByTransactionIdCommand extends EnvironmentCommand {
  @IsString()
  transactionId: string;

  @IsEnum(ChannelTypeEnum)
  @IsOptional()
  channel?: ChannelTypeEnum;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RemoveMessagesByTransactionIdCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/messages/usecases/remove-messages-by-transactionId/remove-messages-by-transactionId.usecase.ts
Tamaño: 1888 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';

import { buildFeedKey, buildMessageCountKey, InvalidateCacheService } from '@novu/application-generic';
import { EnforceEnvId, MessageEntity, MessageRepository } from '@novu/dal';

import { RemoveMessagesByTransactionIdCommand } from './remove-messages-by-transactionId.command';

@Injectable()
export class RemoveMessagesByTransactionId {
  constructor(
    private messageRepository: MessageRepository,
    private invalidateCache: InvalidateCacheService
  ) {}

  async execute(command: RemoveMessagesByTransactionIdCommand) {
    const messages = await this.messageRepository.findMessagesByTransactionId({
      transactionId: [command.transactionId],
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
      ...(command.channel && { channel: command.channel }),
    });

    if (messages.length === 0) {
      throw new NotFoundException('Invalid transactionId or channel');
    }

    for (const message of messages) {
      const subscriberId = message.subscriber?.subscriberId;
      if (subscriberId) {
        await this.invalidateCache.invalidateQuery({
          key: buildFeedKey().invalidate({
            subscriberId,
            _environmentId: command.environmentId,
          }),
        });

        await this.invalidateCache.invalidateQuery({
          key: buildMessageCountKey().invalidate({
            subscriberId,
            _environmentId: command.environmentId,
          }),
        });
      }
    }

    const deleteQuery: Partial<MessageEntity> & EnforceEnvId = {
      transactionId: command.transactionId,
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
    };

    if (command.channel) {
      deleteQuery.channel = command.channel;
    }

    await this.messageRepository.delete(deleteQuery);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RemoveMessagesByTransactionId

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notification-groups/notification-groups.controller.ts
Tamaño: 5760 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  Body,
  ClassSerializerInterceptor,
  Controller,
  Delete,
  Get,
  Param,
  Patch,
  Post,
  UseInterceptors,
} from '@nestjs/common';
import { ApiExcludeController, ApiOperation, ApiTags } from '@nestjs/swagger';
import { UserSessionData } from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { ExternalApiAccessible } from '../auth/framework/external-api.decorator';
import { ApiCommonResponses, ApiResponse } from '../shared/framework/response.decorator';
import { UserSession } from '../shared/framework/user.decorator';
import { CreateNotificationGroupRequestDto } from './dtos/create-notification-group-request.dto';
import { DeleteNotificationGroupResponseDto } from './dtos/delete-notification-group-response.dto';
import { NotificationGroupResponseDto } from './dtos/notification-group-response.dto';
import { CreateNotificationGroupCommand } from './usecases/create-notification-group/create-notification-group.command';
import { CreateNotificationGroup } from './usecases/create-notification-group/create-notification-group.usecase';
import { DeleteNotificationGroupCommand } from './usecases/delete-notification-group/delete-notification-group.command';
import { DeleteNotificationGroup } from './usecases/delete-notification-group/delete-notification-group.usecase';
import { GetNotificationGroupCommand } from './usecases/get-notification-group/get-notification-group.command';
import { GetNotificationGroup } from './usecases/get-notification-group/get-notification-group.usecase';
import { GetNotificationGroupsCommand } from './usecases/get-notification-groups/get-notification-groups.command';
import { GetNotificationGroups } from './usecases/get-notification-groups/get-notification-groups.usecase';
import { UpdateNotificationGroupCommand } from './usecases/update-notification-group/update-notification-group.command';
import { UpdateNotificationGroup } from './usecases/update-notification-group/update-notification-group.usecase';

@ApiCommonResponses()
@Controller('/notification-groups')
@UseInterceptors(ClassSerializerInterceptor)
@RequireAuthentication()
@ApiTags('Workflow groups')
@ApiExcludeController()
export class NotificationGroupsController {
  constructor(
    private createNotificationGroupUsecase: CreateNotificationGroup,
    private getNotificationGroupsUsecase: GetNotificationGroups,
    private getNotificationGroupUsecase: GetNotificationGroup,
    private deleteNotificationGroupUsecase: DeleteNotificationGroup,
    private updateNotificationGroupUsecase: UpdateNotificationGroup
  ) {}

  @Post('')
  @ExternalApiAccessible()
  @ApiResponse(NotificationGroupResponseDto, 201)
  @ApiOperation({
    summary: 'Create workflow group',
    description: `workflow group was previously named notification group`,
  })
  createNotificationGroup(
    @UserSession() user: UserSessionData,
    @Body() body: CreateNotificationGroupRequestDto
  ): Promise<NotificationGroupResponseDto> {
    return this.createNotificationGroupUsecase.execute(
      CreateNotificationGroupCommand.create({
        organizationId: user.organizationId,
        userId: user._id,
        environmentId: user.environmentId,
        name: body.name,
      })
    );
  }

  @Get('')
  @ExternalApiAccessible()
  @ApiResponse(NotificationGroupResponseDto, 200, true)
  @ApiOperation({
    summary: 'Get workflow groups',
    description: `workflow group was previously named notification group`,
  })
  listNotificationGroups(@UserSession() user: UserSessionData): Promise<NotificationGroupResponseDto[]> {
    return this.getNotificationGroupsUsecase.execute(
      GetNotificationGroupsCommand.create({
        organizationId: user.organizationId,
        userId: user._id,
        environmentId: user.environmentId,
      })
    );
  }

  @Get('/:id')
  @ExternalApiAccessible()
  @ApiResponse(NotificationGroupResponseDto, 200)
  @ApiOperation({
    summary: 'Get workflow group',
    description: `workflow group was previously named notification group`,
  })
  getNotificationGroup(
    @UserSession() user: UserSessionData,
    @Param('id') id: string
  ): Promise<NotificationGroupResponseDto> {
    return this.getNotificationGroupUsecase.execute(
      GetNotificationGroupCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
        id,
      })
    );
  }

  @Patch('/:id')
  @ExternalApiAccessible()
  @ApiResponse(NotificationGroupResponseDto, 200)
  @ApiOperation({
    summary: 'Update workflow group',
    description: `workflow group was previously named notification group`,
  })
  updateNotificationGroup(
    @UserSession() user: UserSessionData,
    @Param('id') id: string,
    @Body() body: CreateNotificationGroupRequestDto
  ): Promise<NotificationGroupResponseDto> {
    return this.updateNotificationGroupUsecase.execute(
      UpdateNotificationGroupCommand.create({
        organizationId: user.organizationId,
        userId: user._id,
        environmentId: user.environmentId,
        name: body.name,
        id,
      })
    );
  }

  @Delete('/:id')
  @ExternalApiAccessible()
  @ApiResponse(DeleteNotificationGroupResponseDto, 200)
  @ApiOperation({
    summary: 'Delete workflow group',
    description: `workflow group was previously named notification group`,
  })
  deleteNotificationGroup(
    @UserSession() user: UserSessionData,
    @Param('id') id: string
  ): Promise<DeleteNotificationGroupResponseDto> {
    return this.deleteNotificationGroupUsecase.execute(
      DeleteNotificationGroupCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
        id,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class NotificationGroupsController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notification-groups/notification-groups.module.ts
Tamaño: 565 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { forwardRef, Module } from '@nestjs/common';
import { AuthModule } from '../auth/auth.module';
import { ChangeModule } from '../change/change.module';
import { SharedModule } from '../shared/shared.module';
import { NotificationGroupsController } from './notification-groups.controller';
import { USE_CASES } from './usecases';

@Module({
  imports: [SharedModule, forwardRef(() => AuthModule), ChangeModule],
  providers: [...USE_CASES],
  controllers: [NotificationGroupsController],
  exports: [...USE_CASES],
})
export class NotificationGroupsModule {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class NotificationGroupsModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notification-groups/dtos/create-notification-group-request.dto.ts
Tamaño: 216 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IsDefined, IsString } from 'class-validator';

export class CreateNotificationGroupRequestDto {
  @ApiProperty()
  @IsString()
  @IsDefined()
  name: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateNotificationGroupRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notification-groups/dtos/delete-notification-group-response.dto.ts
Tamaño: 461 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IsBoolean, IsDefined, IsString } from 'class-validator';

export class DeleteNotificationGroupResponseDto {
  @ApiProperty({
    description: 'A boolean stating the success of the action',
  })
  @IsBoolean()
  @IsDefined()
  acknowledged: boolean;

  @ApiProperty({
    description: 'The status enum for the performed action',
    enum: ['deleted'],
  })
  @IsString()
  @IsDefined()
  status: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DeleteNotificationGroupResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notification-groups/dtos/notification-group-response.dto.ts
Tamaño: 327 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';

export class NotificationGroupResponseDto {
  @ApiPropertyOptional()
  _id?: string;

  @ApiProperty()
  name: string;

  @ApiProperty()
  _environmentId: string;

  @ApiProperty()
  _organizationId: string;

  @ApiPropertyOptional()
  _parentId?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class NotificationGroupResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notification-groups/e2e/create-notification-group.e2e.ts
Tamaño: 691 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Create Notification Group - /notification-groups (POST) #novu-v0', async () => {
  let session: UserSession;

  before(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should create notification group', async () => {
    const testTemplate = {
      name: 'Test name',
    };

    const { body } = await session.testAgent.post(`/v1/notification-groups`).send(testTemplate);

    expect(body.data).to.be.ok;
    const group = body.data;

    expect(group.name).to.equal(`Test name`);
    expect(group._environmentId).to.equal(session.environment._id);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
    await session.initialize();
  });

  it('should create notification group', a...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notification-groups/e2e/delete-notification-group.e2e.ts
Tamaño: 1762 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Delete Notification Group - /notification-groups/:id (DELETE) #novu-v0', async () => {
  let session: UserSession;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should delete notification group by id', async () => {
    const postNotificationGroup1 = await session.testAgent.post(`/v1/notification-groups`).send({
      name: 'Test delete group',
    });

    const { id } = postNotificationGroup1.body.data;

    const getResult = await session.testAgent.get(`/v1/notification-groups/${id}`);

    const group = getResult.body.data;

    expect(group.name).to.equal(`Test delete group`);
    expect(group._id).to.equal(postNotificationGroup1.body.data.id);
    expect(group._environmentId).to.equal(session.environment._id);

    const { body: deleteResult } = await session.testAgent.delete(`/v1/notification-groups/${id}`);

    expect(deleteResult.data.acknowledged).to.equal(true);
    expect(deleteResult.data.status).to.equal('deleted');

    const { body: getResultAfterDelete } = await session.testAgent.get(`/v1/notification-groups/${id}`);

    expect(getResultAfterDelete.statusCode).to.eq(404);
  });

  it('should return 404 error when attempting to delete non-existent notification group', async () => {
    const postNotificationGroup1 = await session.testAgent.post(`/v1/notification-groups`).send({
      name: 'Test name',
    });

    const { id } = postNotificationGroup1.body.data;

    await session.testAgent.delete(`/v1/notification-groups/${id}`);

    const { body } = await session.testAgent.delete(`/v1/notification-groups/${id}`);

    expect(body.statusCode).to.equal(404);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
    await session.initialize();
  });

  it('should delete notification group by ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notification-groups/e2e/get-notification-group.e2e.ts
Tamaño: 1353 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Get Notification Group - /notification-groups/:id (GET) #novu-v0', async () => {
  let session: UserSession;

  const testTemplate = {
    name: 'Test name',
  };

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should get the notification group by id', async () => {
    const postNotificationGroup1 = await session.testAgent.post(`/v1/notification-groups`).send(testTemplate);

    const { id } = postNotificationGroup1.body.data;

    const { body } = await session.testAgent.get(`/v1/notification-groups/${id}`);

    const group = body.data;

    expect(group.name).to.equal(`Test name`);
    expect(group._id).to.equal(postNotificationGroup1.body.data.id);
    expect(group._environmentId).to.equal(session.environment._id);
  });

  it('should get 404 when notification group is not present with the requested id', async () => {
    const postNotificationGroup1 = await session.testAgent.post(`/v1/notification-groups`).send(testTemplate);

    const { id } = postNotificationGroup1.body.data;

    await session.testAgent.delete(`/v1/notification-groups/${id}`);

    const { body } = await session.testAgent.get(`/v1/notification-groups/${id}`);

    expect(body.statusCode).to.equal(404);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - testTemplate({
    name: 'Test name',
  };

  beforeEach(async ())
 - session(new UserSession();
    await session.initialize();
  });

  it('should get the notification group by...)
 - group(body.data;

    expect(group.name).to.equal(`Test name`);
    expect(group._id).to.equal(postNotific...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notification-groups/e2e/get-notification-groups.e2e.ts
Tamaño: 863 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Get Notification Groups - /notification-groups (GET) #novu-v0', async () => {
  let session: UserSession;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should get all notification groups', async () => {
    await session.testAgent.post(`/v1/notification-groups`).send({
      name: 'Test name',
    });
    await session.testAgent.post(`/v1/notification-groups`).send({
      name: 'Test name 2',
    });

    const { body } = await session.testAgent.get(`/v1/notification-groups`);

    expect(body.data.length).to.equal(3);
    const group = body.data.find((i) => i.name === 'Test name');

    expect(group.name).to.equal(`Test name`);
    expect(group._environmentId).to.equal(session.environment._id);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
    await session.initialize();
  });

  it('should get all notification groups',...)
 - group(body.data.find((i))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notification-groups/e2e/update-notification-group.e2e.ts
Tamaño: 2044 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Update Notification Group - /notification-groups/:id (PATCH) #novu-v0', async () => {
  let session: UserSession;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('update the notification group by id', async () => {
    const postNotificationGroup = await session.testAgent.post(`/v1/notification-groups`).send({
      name: 'Test name 1',
    });

    const { id } = postNotificationGroup.body.data;

    const { body: getNotificationGroupResult } = await session.testAgent.get(`/v1/notification-groups/${id}`);

    expect(getNotificationGroupResult.data.name).to.equal(`Test name 1`);
    expect(getNotificationGroupResult.data._id).to.equal(postNotificationGroup.body.data.id);
    expect(getNotificationGroupResult.data._environmentId).to.equal(session.environment._id);

    const { body: putNotificationGroup } = await session.testAgent.patch(`/v1/notification-groups/${id}`).send({
      name: 'Updated name',
    });

    expect(putNotificationGroup.data._id).to.equal(id);

    const { body: getUpdatedNotificationGroupResult } = await session.testAgent.get(`/v1/notification-groups/${id}`);

    expect(getUpdatedNotificationGroupResult.data.name).to.equal(`Updated name`);
    expect(getUpdatedNotificationGroupResult.data.id).to.equal(id);
    expect(getUpdatedNotificationGroupResult.data._environmentId).to.equal(session.environment._id);
  });

  it('should return a 404 error if the notification group to be updated does not exist', async () => {
    const postNotificationGroup1 = await session.testAgent.post(`/v1/notification-groups`).send({
      name: 'Test name',
    });

    const { id } = postNotificationGroup1.body.data;

    await session.testAgent.delete(`/v1/notification-groups/${id}`);

    const { body } = await session.testAgent.patch(`/v1/notification-groups/${id}`).send({
      name: 'Updated name',
    });

    expect(body.statusCode).to.equal(404);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
    await session.initialize();
  });

  it('update the notification group by id'...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notification-groups/usecases/index.ts
Tamaño: 671 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CreateNotificationGroup } from './create-notification-group/create-notification-group.usecase';
import { DeleteNotificationGroup } from './delete-notification-group/delete-notification-group.usecase';
import { GetNotificationGroup } from './get-notification-group/get-notification-group.usecase';
import { GetNotificationGroups } from './get-notification-groups/get-notification-groups.usecase';
import { UpdateNotificationGroup } from './update-notification-group/update-notification-group.usecase';

export const USE_CASES = [
  GetNotificationGroups,
  CreateNotificationGroup,
  GetNotificationGroup,
  DeleteNotificationGroup,
  UpdateNotificationGroup,
];


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notification-groups/usecases/create-notification-group/create-notification-group.command.ts
Tamaño: 245 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsString } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class CreateNotificationGroupCommand extends EnvironmentWithUserCommand {
  @IsString()
  name: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateNotificationGroupCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notification-groups/usecases/create-notification-group/create-notification-group.usecase.ts
Tamaño: 1340 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { CreateChange, CreateChangeCommand } from '@novu/application-generic';
import { NotificationGroupEntity, NotificationGroupRepository } from '@novu/dal';
import { ChangeEntityTypeEnum } from '@novu/shared';

import { CreateNotificationGroupCommand } from './create-notification-group.command';

@Injectable()
export class CreateNotificationGroup {
  constructor(
    private notificationGroupRepository: NotificationGroupRepository,
    private createChange: CreateChange
  ) {}

  async execute(command: CreateNotificationGroupCommand): Promise<NotificationGroupEntity> {
    const group = await this.notificationGroupRepository.findOne({
      _organizationId: command.organizationId,
    });

    const item = await this.notificationGroupRepository.create({
      _environmentId: command.environmentId,
      _organizationId: command.organizationId,
      name: command.name,
      _parentId: group?._id,
    });

    await this.createChange.execute(
      CreateChangeCommand.create({
        item,
        environmentId: command.environmentId,
        organizationId: command.organizationId,
        userId: command.userId,
        type: ChangeEntityTypeEnum.NOTIFICATION_GROUP,
        changeId: NotificationGroupRepository.createObjectId(),
      })
    );

    return item;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateNotificationGroup

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notification-groups/usecases/delete-notification-group/delete-notification-group.command.ts
Tamaño: 269 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsString } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class DeleteNotificationGroupCommand extends EnvironmentWithUserCommand {
  @IsString()
  @IsDefined()
  id: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DeleteNotificationGroupCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notification-groups/usecases/delete-notification-group/delete-notification-group.usecase.ts
Tamaño: 1020 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import { DalException, NotificationGroupRepository } from '@novu/dal';
import { DeleteNotificationGroupCommand } from './delete-notification-group.command';

@Injectable()
export class DeleteNotificationGroup {
  constructor(private notificationGroupRepository: NotificationGroupRepository) {}

  async execute(command: DeleteNotificationGroupCommand) {
    const { environmentId, id } = command;
    try {
      const group = await this.notificationGroupRepository.findOne({
        _environmentId: environmentId,
        _id: id,
      });

      if (group === null) throw new NotFoundException();

      await this.notificationGroupRepository.delete({
        _environmentId: environmentId,
        _id: id,
      });
    } catch (e) {
      if (e instanceof DalException) {
        throw new BadRequestException(e.message);
      }
      throw e;
    }

    return {
      acknowledged: true,
      status: 'deleted',
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DeleteNotificationGroup

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notification-groups/usecases/get-notification-group/get-notification-group.command.ts
Tamaño: 266 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsString } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class GetNotificationGroupCommand extends EnvironmentWithUserCommand {
  @IsString()
  @IsDefined()
  id: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetNotificationGroupCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notification-groups/usecases/get-notification-group/get-notification-group.usecase.ts
Tamaño: 706 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { NotificationGroupEntity, NotificationGroupRepository } from '@novu/dal';
import { GetNotificationGroupCommand } from './get-notification-group.command';

@Injectable()
export class GetNotificationGroup {
  constructor(private notificationGroupRepository: NotificationGroupRepository) {}

  async execute(command: GetNotificationGroupCommand): Promise<NotificationGroupEntity> {
    const { id, environmentId } = command;

    const result = await this.notificationGroupRepository.findOne({
      _environmentId: environmentId,
      _id: id,
    });

    if (result === null) throw new NotFoundException();

    return result;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetNotificationGroup

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notification-groups/usecases/get-notification-groups/get-notification-groups.command.ts
Tamaño: 168 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class GetNotificationGroupsCommand extends EnvironmentWithUserCommand {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetNotificationGroupsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notification-groups/usecases/get-notification-groups/get-notification-groups.usecase.ts
Tamaño: 554 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { NotificationGroupEntity, NotificationGroupRepository } from '@novu/dal';
import { GetNotificationGroupsCommand } from './get-notification-groups.command';

@Injectable()
export class GetNotificationGroups {
  constructor(private notificationGroupRepository: NotificationGroupRepository) {}

  async execute(command: GetNotificationGroupsCommand): Promise<NotificationGroupEntity[]> {
    return await this.notificationGroupRepository.find({
      _environmentId: command.environmentId,
    });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetNotificationGroups

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notification-groups/usecases/update-notification-group/update-notification-group.command.ts
Tamaño: 315 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsString } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class UpdateNotificationGroupCommand extends EnvironmentWithUserCommand {
  @IsString()
  @IsDefined()
  id: string;

  @IsString()
  @IsDefined()
  name: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateNotificationGroupCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notification-groups/usecases/update-notification-group/update-notification-group.usecase.ts
Tamaño: 1202 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { NotificationGroupRepository } from '@novu/dal';
import { GetNotificationGroup } from '../get-notification-group/get-notification-group.usecase';
import { UpdateNotificationGroupCommand } from './update-notification-group.command';

@Injectable()
export class UpdateNotificationGroup {
  constructor(
    private notificationGroupRepository: NotificationGroupRepository,
    private getNotificationGroup: GetNotificationGroup
  ) {}

  async execute(command: UpdateNotificationGroupCommand) {
    const { id, environmentId, name, organizationId, userId } = command;

    const item = await this.getNotificationGroup.execute({
      environmentId,
      organizationId,
      userId,
      id,
    });

    const result = await this.notificationGroupRepository.update(
      {
        _id: item._id,
        _environmentId: item._environmentId,
      },
      {
        $set: {
          name,
        },
      }
    );

    if (result.matched === 0) {
      throw new NotFoundException();
    }

    return await this.getNotificationGroup.execute({
      environmentId,
      organizationId,
      userId,
      id,
    });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateNotificationGroup

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notifications/notification.controller.ts
Tamaño: 7930 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Controller, Get, Param, Query } from '@nestjs/common';
import { ApiExcludeEndpoint, ApiOperation, ApiQuery, ApiTags } from '@nestjs/swagger';
import { FeatureFlagsService, RequirePermissions } from '@novu/application-generic';
import {
  ChannelTypeEnum,
  FeatureFlagsKeysEnum,
  PermissionsEnum,
  SeverityLevelEnum,
  UserSessionData,
} from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { ExternalApiAccessible } from '../auth/framework/external-api.decorator';
import { ApiCommonResponses, ApiOkResponse, ApiResponse } from '../shared/framework/response.decorator';
import { SdkGroupName, SdkMethodName } from '../shared/framework/swagger/sdk.decorators';
import { UserSession } from '../shared/framework/user.decorator';
import { ActivitiesRequestDto } from './dtos/activities-request.dto';
import { ActivitiesResponseDto, ActivityNotificationResponseDto } from './dtos/activities-response.dto';
import { ActivityGraphStatesResponse } from './dtos/activity-graph-states-response.dto';
import { ActivityStatsResponseDto } from './dtos/activity-stats-response.dto';
import { GetActivityCommand } from './usecases/get-activity/get-activity.command';
import { GetActivity } from './usecases/get-activity/get-activity.usecase';
import { GetActivityFeedCommand } from './usecases/get-activity-feed/get-activity-feed.command';
import { GetActivityFeed } from './usecases/get-activity-feed/get-activity-feed.usecase';
import { GetActivityGraphStatsCommand } from './usecases/get-activity-graph-states/get-activity-graph-states.command';
import { GetActivityGraphStats } from './usecases/get-activity-graph-states/get-activity-graph-states.usecase';
import { GetActivityStats, GetActivityStatsCommand } from './usecases/get-activity-stats';

@ApiCommonResponses()
@RequireAuthentication()
@Controller('/notifications')
@ApiTags('Notifications')
export class NotificationsController {
  constructor(
    private getActivityFeedUsecase: GetActivityFeed,
    private getActivityStatsUsecase: GetActivityStats,
    private getActivityGraphStatsUsecase: GetActivityGraphStats,
    private getActivityUsecase: GetActivity,
    private featureFlagsService: FeatureFlagsService
  ) {}

  @Get('')
  @ApiOkResponse({
    type: ActivitiesResponseDto,
  })
  @ApiOperation({
    summary: 'List all events',
    description: `List all notification events (triggered events) for the current environment. 
    This API supports filtering by **channels**, **templates**, **emails**, **subscriberIds**, **transactionId**, **topicKey**. 
    Checkout all available filters in the query section.
    This API returns event triggers, to list each channel notifications, check messages APIs.`,
  })
  @ExternalApiAccessible()
  @RequirePermissions(PermissionsEnum.NOTIFICATION_READ)
  async listNotifications(
    @UserSession() user: UserSessionData,
    @Query() query: ActivitiesRequestDto
  ): Promise<ActivitiesResponseDto> {
    let channelsQuery: ChannelTypeEnum[] | null = null;
    if (query.channels) {
      channelsQuery = Array.isArray(query.channels) ? query.channels : [query.channels];
    }

    let templatesQuery: string[] | null = null;
    if (query.templates) {
      templatesQuery = Array.isArray(query.templates) ? query.templates : [query.templates];
    }

    let emailsQuery: string[] = [];
    if (query.emails) {
      emailsQuery = Array.isArray(query.emails) ? query.emails : [query.emails];
    }

    let subscribersQuery: string[] = [];
    if (query.subscriberIds) {
      subscribersQuery = Array.isArray(query.subscriberIds) ? query.subscriberIds : [query.subscriberIds];
    }

    let transactionIdQuery: string[] | undefined;
    if (query.transactionId) {
      transactionIdQuery = Array.isArray(query.transactionId) ? query.transactionId : [query.transactionId];
    }

    let severityQuery: SeverityLevelEnum[] | null = null;
    if (query.severity) {
      severityQuery = Array.isArray(query.severity) ? query.severity : [query.severity];
    }

    // Check if context search is enabled via feature flag
    const isContextEnabled = await this.featureFlagsService.getFlag({
      key: FeatureFlagsKeysEnum.IS_CONTEXT_ENABLED,
      defaultValue: false,
      organization: { _id: user.organizationId },
      user: { _id: user._id },
      environment: { _id: user.environmentId },
    });

    let contextKeysQuery: string[] | undefined;
    if (isContextEnabled && query.contextKeys !== undefined) {
      contextKeysQuery = Array.isArray(query.contextKeys) ? query.contextKeys : [query.contextKeys];
    }

    return this.getActivityFeedUsecase.execute(
      GetActivityFeedCommand.create({
        page: query.page,
        limit: query.limit,
        organizationId: user.organizationId,
        environmentId: user.environmentId,
        userId: user._id,
        channels: channelsQuery,
        templates: templatesQuery,
        emails: emailsQuery,
        search: query.search,
        subscriberIds: subscribersQuery,
        transactionId: transactionIdQuery,
        topicKey: query.topicKey,
        severity: severityQuery,
        after: query.after,
        before: query.before,
        contextKeys: contextKeysQuery,
      })
    );
  }

  @ApiResponse(ActivityStatsResponseDto)
  @ApiExcludeEndpoint()
  @ApiOperation({
    summary: 'Retrieve events statistics',
    description: `Retrieve notification statistics for the current environment. 
    This API returns the number of weekly and monthly notifications sent for the current environment.`,
    deprecated: true,
  })
  @Get('/stats')
  @ExternalApiAccessible()
  @SdkGroupName('Notifications.Stats')
  @RequirePermissions(PermissionsEnum.NOTIFICATION_READ)
  getActivityStats(@UserSession() user: UserSessionData): Promise<ActivityStatsResponseDto> {
    return this.getActivityStatsUsecase.execute(
      GetActivityStatsCommand.create({
        organizationId: user.organizationId,
        environmentId: user.environmentId,
      })
    );
  }

  @Get('/graph/stats')
  @ExternalApiAccessible()
  @ApiExcludeEndpoint()
  @ApiResponse(ActivityGraphStatesResponse, 200, true)
  @ApiOperation({
    summary: 'Retrieve events graph statistics',
    description: `Retrieve events graph statistics for the current environment. 
    This API returns the number of events sent. This data is used to generate the graph in the legacy dashboard.`,
    deprecated: true,
  })
  @ApiQuery({
    name: 'days',
    type: Number,
    required: false,
  })
  @SdkGroupName('Notifications.Stats')
  @SdkMethodName('graph')
  @RequirePermissions(PermissionsEnum.NOTIFICATION_READ)
  getActivityGraphStats(
    @UserSession() user: UserSessionData,
    @Query('days') days = 32
  ): Promise<ActivityGraphStatesResponse[]> {
    return this.getActivityGraphStatsUsecase.execute(
      GetActivityGraphStatsCommand.create({
        days: days ? Number(days) : 32,
        organizationId: user.organizationId,
        environmentId: user.environmentId,
        userId: user._id,
      })
    );
  }

  @Get('/:notificationId')
  @ApiResponse(ActivityNotificationResponseDto)
  @ApiOperation({
    summary: 'Retrieve an event',
    description: `Retrieve an event by its unique key identifier **notificationId**. 
    Here **notificationId** is of mongodbId type. 
    This API returns the event details - execution logs, status, actual notification (message) generated by each workflow step.`,
  })
  @ExternalApiAccessible()
  @RequirePermissions(PermissionsEnum.NOTIFICATION_READ)
  getNotification(
    @UserSession() user: UserSessionData,
    @Param('notificationId') notificationId: string
  ): Promise<ActivityNotificationResponseDto> {
    return this.getActivityUsecase.execute(
      GetActivityCommand.create({
        notificationId,
        organizationId: user.organizationId,
        environmentId: user.environmentId,
        userId: user._id,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class NotificationsController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notifications/notification.module.ts
Tamaño: 509 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Module } from '@nestjs/common';
import { CommunityOrganizationRepository } from '@novu/dal';
import { AuthModule } from '../auth/auth.module';
import { SharedModule } from '../shared/shared.module';
import { NotificationsController } from './notification.controller';
import { USE_CASES } from './usecases';

@Module({
  imports: [SharedModule, AuthModule],
  providers: [...USE_CASES, CommunityOrganizationRepository],
  controllers: [NotificationsController],
})
export class NotificationModule {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class NotificationModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notifications/dtos/activities-request.dto.ts
Tamaño: 2952 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiHideProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { ChannelTypeEnum, SeverityLevelEnum } from '@novu/shared';
import { Type } from 'class-transformer';
import { IsArray, IsInt, IsOptional, IsString, Max, Min } from 'class-validator';
import { IsEnumOrArray } from '../../shared/validators/is-enum-or-array';

export class ActivitiesRequestDto {
  @ApiPropertyOptional({
    enum: [...Object.values(ChannelTypeEnum)],
    enumName: 'ChannelTypeEnum',
    isArray: true,
    description: 'Array of channel types',
  })
  @IsOptional()
  channels?: ChannelTypeEnum[] | ChannelTypeEnum;

  @ApiPropertyOptional({
    type: String,
    isArray: true,
    description: 'Array of template IDs or a single template ID',
  })
  @IsOptional()
  templates?: string[] | string;

  @ApiPropertyOptional({
    type: String,
    isArray: true,
    description: 'Array of email addresses or a single email address',
  })
  @IsOptional()
  emails?: string | string[];

  @ApiPropertyOptional({
    type: String,
    deprecated: true,
    description: 'Search term (deprecated)',
  })
  @IsOptional()
  search?: string;

  @ApiPropertyOptional({
    type: String,
    isArray: true,
    description: 'Array of subscriber IDs or a single subscriber ID',
  })
  @IsOptional()
  subscriberIds?: string | string[];

  @ApiPropertyOptional({
    type: String,
    isArray: true,
    description: 'Array of severity levels or a single severity level',
  })
  @IsOptional()
  @IsEnumOrArray(SeverityLevelEnum)
  severity?: SeverityLevelEnum[] | SeverityLevelEnum;

  @ApiPropertyOptional({
    type: Number,
    default: 0,
    description: 'Page number for pagination',
  })
  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(0)
  page: number = 0;

  @ApiPropertyOptional({
    type: Number,
    default: 10,
    minimum: 1,
    maximum: 50,
    description: 'Limit for pagination',
  })
  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  @Max(50)
  limit: number = 10;

  @ApiPropertyOptional({
    type: String,
    description: 'The transaction ID to filter by',
  })
  @IsOptional()
  transactionId?: string[] | string;

  @ApiPropertyOptional({
    type: String,
    description: 'Topic Key for filtering notifications by topic',
  })
  @IsOptional()
  @IsString()
  topicKey?: string;

  @ApiPropertyOptional({
    type: String,
    isArray: true,
    description: 'Filter by exact context keys (format: "type:id")',
    example: ['tenant:org-123', 'region:us-east-1'],
  })
  @IsOptional()
  contextKeys?: string[] | string;

  @ApiPropertyOptional({
    type: String,
    description: 'Date filter for records after this timestamp. Defaults to earliest date allowed by subscription plan',
  })
  @IsOptional()
  after?: string;

  @ApiPropertyOptional({
    type: String,
    description: 'Date filter for records before this timestamp. Defaults to current time of request (now)',
  })
  @IsOptional()
  before?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - number(0;

  @ApiPropertyOptional({
    type: Number,
    default: 10,
    minimum: 1,
    maximum: 50,
   ...)
Declaraciones 'export' encontradas:
- export class ActivitiesRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notifications/dtos/activities-response.dto.ts
Tamaño: 15522 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import {
  DaysEnum,
  DigestTypeEnum,
  DigestUnitEnum,
  ExecutionDetailsSourceEnum,
  ExecutionDetailsStatusEnum,
  MessageTemplateDto,
  MonthlyTypeEnum,
  OrdinalEnum,
  OrdinalValueEnum,
  ProvidersIdEnum,
  ProvidersIdEnumConst,
  ResourceOriginEnum,
  SeverityLevelEnum,
  StepTypeEnum,
  TriggerTypeEnum,
} from '@novu/shared';
import { IsArray, IsEnum, IsNumber, IsOptional, IsString } from 'class-validator';
import { StepFilterDto } from '../../shared/dtos/step-filter-dto';

export class DigestTimedConfigDto {
  @ApiPropertyOptional({ description: 'Time at which the digest is triggered' })
  @IsOptional()
  @IsString()
  atTime?: string;

  @ApiPropertyOptional({
    description: 'Days of the week for the digest',
    type: 'array',
    items: {
      type: 'string',
      enum: Object.values(DaysEnum),
    },
    enumName: 'DaysEnum',
  })
  @IsOptional()
  @IsArray()
  @IsEnum(DaysEnum, { each: true })
  weekDays?: DaysEnum[];

  @ApiPropertyOptional({ description: 'Specific days of the month for the digest', type: [Number] })
  @IsOptional()
  @IsArray()
  @IsNumber({}, { each: true })
  monthDays?: number[];

  @ApiPropertyOptional({
    description: 'Ordinal position for the digest',
    enum: [...Object.values(OrdinalEnum)],
    enumName: 'OrdinalEnum',
  })
  @IsOptional()
  @IsEnum(OrdinalEnum)
  ordinal?: OrdinalEnum;

  @ApiPropertyOptional({
    description: 'Value of the ordinal',
    enum: [...Object.values(OrdinalValueEnum)],
    enumName: 'OrdinalValueEnum',
  })
  @IsOptional()
  @IsEnum(OrdinalValueEnum)
  ordinalValue?: OrdinalValueEnum;

  @ApiPropertyOptional({
    description: 'Type of monthly schedule',
    enum: [...Object.values(MonthlyTypeEnum)],
    enumName: 'MonthlyTypeEnum',
  })
  @IsOptional()
  @IsEnum(MonthlyTypeEnum)
  monthlyType?: MonthlyTypeEnum;

  @ApiPropertyOptional({ description: 'Cron expression for scheduling' })
  @IsOptional()
  @IsString()
  cronExpression?: string;

  @ApiPropertyOptional({ description: 'Until date for scheduling' })
  @IsOptional()
  @IsString()
  untilDate?: string;
}

export class DigestMetadataDto {
  @ApiPropertyOptional({ description: 'Optional key for the digest' })
  digestKey?: string;

  @ApiPropertyOptional({ description: 'Amount for the digest', type: Number })
  amount?: number;

  @ApiPropertyOptional({ description: 'Unit of the digest', enum: DigestUnitEnum })
  unit?: DigestUnitEnum;

  @ApiProperty({
    enum: [...Object.values(DigestTypeEnum)],
    enumName: 'DigestTypeEnum',
    description: 'The Digest Type',
    type: String,
  })
  type: DigestTypeEnum;

  @ApiPropertyOptional({
    type: 'array',
    items: {
      type: 'object',
      additionalProperties: true,
    },
    description: 'Optional array of events associated with the digest, represented as key-value pairs',
  })
  events?: Record<string, unknown>[];

  // Properties for Regular Digest
  @ApiPropertyOptional({
    description: 'Regular digest: Indicates if backoff is enabled for the regular digest',
    type: Boolean,
  })
  backoff?: boolean;

  @ApiPropertyOptional({ description: 'Regular digest: Amount for backoff', type: Number })
  backoffAmount?: number;

  @ApiPropertyOptional({
    description: 'Regular digest: Unit for backoff',
    enum: [...Object.values(DigestUnitEnum)],
    enumName: 'DigestUnitEnum',
  })
  backoffUnit?: DigestUnitEnum;

  @ApiPropertyOptional({ description: 'Regular digest: Indicates if the digest should update', type: Boolean })
  updateMode?: boolean;

  // Properties for Timed Digest
  @ApiPropertyOptional({ description: 'Configuration for timed digest', type: () => DigestTimedConfigDto })
  timed?: DigestTimedConfigDto;
}

export class ActivityNotificationStepResponseDto {
  @ApiProperty({ description: 'Unique identifier of the step', type: String })
  _id: string;

  @ApiProperty({ description: 'Whether the step is active or not', type: Boolean })
  active: boolean;

  @ApiPropertyOptional({ description: 'Reply callback settings', type: Object })
  replyCallback?: {
    active: boolean;
    url: string;
  };

  @ApiPropertyOptional({ description: 'Control variables', type: Object })
  controlVariables?: Record<string, unknown>;

  @ApiPropertyOptional({ description: 'Metadata for the workflow step', type: Object })
  metadata?: any; // Adjust the type based on your actual metadata structure

  @ApiPropertyOptional({ description: 'Step issues', type: Object })
  issues?: any; // Adjust the type based on your actual issues structure

  @ApiProperty({ description: 'Filter criteria for the step', isArray: true, type: StepFilterDto })
  filters: StepFilterDto[];

  @ApiPropertyOptional({ description: 'Optional template for the step', type: MessageTemplateDto })
  template?: MessageTemplateDto;

  @ApiPropertyOptional({ description: 'Variants of the step', type: [ActivityNotificationStepResponseDto] })
  variants?: ActivityNotificationStepResponseDto[]; // Assuming variants are the same type

  @ApiProperty({ description: 'The identifier for the template associated with this step', type: String })
  _templateId: string;

  @ApiPropertyOptional({ description: 'The name of the step', type: String })
  name?: string;

  @ApiPropertyOptional({ description: 'The unique identifier for the parent step', type: String })
  _parentId?: string | null;
}
// Activity Notification Execution Detail Response DTO
export class ActivityNotificationExecutionDetailResponseDto {
  @ApiProperty({ description: 'Unique identifier of the execution detail', type: String })
  _id: string;

  @ApiPropertyOptional({ description: 'Creation time of the execution detail', type: String })
  createdAt?: string;

  @ApiProperty({
    enum: [...Object.values(ExecutionDetailsStatusEnum)],
    enumName: 'ExecutionDetailsStatusEnum',
    description: 'Status of the execution detail',
    type: String,
  })
  status: ExecutionDetailsStatusEnum;

  @ApiProperty({ description: 'Detailed information about the execution', type: String })
  detail: string;

  @ApiProperty({ description: 'Whether the execution is a retry or not', type: Boolean })
  isRetry: boolean;

  @ApiProperty({ description: 'Whether the execution is a test or not', type: Boolean })
  isTest: boolean;

  @ApiPropertyOptional({
    enum: [...new Set([...Object.values(ProvidersIdEnumConst).flatMap((enumObj) => Object.values(enumObj))])],
    enumName: 'ProvidersIdEnum',
    description: 'Provider ID of the execution',
    type: String,
  })
  @IsString()
  @IsOptional()
  @IsEnum(ProvidersIdEnumConst)
  providerId?: ProvidersIdEnum;

  @ApiPropertyOptional({ description: 'Raw data of the execution', type: String })
  raw?: string | null;

  @ApiProperty({
    enum: [...Object.values(ExecutionDetailsSourceEnum)],
    enumName: 'ExecutionDetailsSourceEnum',
    description: 'Source of the execution detail',
    type: String,
  })
  @IsString()
  @IsEnum(ExecutionDetailsSourceEnum)
  source: ExecutionDetailsSourceEnum;
}

// Activity Notification Job Response DTO
export class ActivityNotificationJobResponseDto {
  @ApiProperty({ description: 'Unique identifier of the job', type: String })
  _id: string;

  @ApiProperty({ description: 'Type of the job', type: String })
  type: StepTypeEnum;

  @ApiPropertyOptional({
    description: 'Optional digest for the job, including metadata and events',
    type: DigestMetadataDto,
  })
  digest?: DigestMetadataDto;

  @ApiProperty({
    description: 'Execution details of the job',
    type: [ActivityNotificationExecutionDetailResponseDto],
  })
  executionDetails: ActivityNotificationExecutionDetailResponseDto[];

  @ApiProperty({
    description: 'Step details of the job',
    type: ActivityNotificationStepResponseDto,
  })
  step: ActivityNotificationStepResponseDto;

  @ApiPropertyOptional({
    description: 'Optional context object for additional error details.',
    type: 'object',
    required: false,
    additionalProperties: true,
    example: {
      workflowId: 'some_wf_id',
      stepId: 'some_wf_id',
    },
  })
  overrides?: Record<string, unknown>;

  @ApiPropertyOptional({ description: 'Optional payload for the job', type: Object })
  payload?: Record<string, unknown>;

  @ApiProperty({
    enum: [...new Set([...Object.values(ProvidersIdEnumConst).flatMap((enumObj) => Object.values(enumObj))])],
    enumName: 'ProvidersIdEnum',
    description: 'Provider ID of the job',
    type: String, // Explicit type reference for enum
  })
  providerId: ProvidersIdEnum;

  @ApiProperty({ description: 'Status of the job', type: String })
  status: string;

  @ApiPropertyOptional({ description: 'Updated time of the notification', type: String })
  updatedAt?: string;

  @ApiPropertyOptional({
    description: 'The number of times the digest/delay job has been extended to align with the subscribers schedule',
    type: Number,
  })
  scheduleExtensionsCount?: number;
}

// Activity Notification Subscriber Response DTO
export class ActivityNotificationSubscriberResponseDto {
  @ApiPropertyOptional({ description: 'First name of the subscriber', type: String })
  firstName?: string;

  @ApiProperty({ description: 'External unique identifier of the subscriber', type: String })
  subscriberId: string;

  @ApiProperty({ description: 'Internal to Novu unique identifier of the subscriber', type: String })
  _id: string;

  @ApiPropertyOptional({ description: 'Last name of the subscriber', type: String })
  lastName?: string;

  @ApiPropertyOptional({ description: 'Email address of the subscriber', type: String })
  email?: string;

  @ApiPropertyOptional({ description: 'Phone number of the subscriber', type: String })
  phone?: string;
}

// Notification Trigger Variable DTO
export class NotificationTriggerVariable {
  @ApiProperty({ description: 'Name of the variable', type: String })
  name: string;
}

export class NotificationTriggerDto {
  @ApiProperty({
    enum: TriggerTypeEnum,
    description: 'Type of the trigger',
    type: String, // Explicit type reference for enum
  })
  type: TriggerTypeEnum;

  @ApiProperty({ description: 'Identifier of the trigger', type: String })
  identifier: string;

  @ApiProperty({
    description: 'Variables of the trigger',
    type: [NotificationTriggerVariable],
  })
  variables: NotificationTriggerVariable[];

  @ApiPropertyOptional({
    description: 'Subscriber variables of the trigger',
    type: [NotificationTriggerVariable],
  })
  subscriberVariables?: NotificationTriggerVariable[];
}

// Activity Notification Template Response DTO
export class ActivityNotificationTemplateResponseDto {
  @ApiPropertyOptional({ description: 'Unique identifier of the template', type: String })
  _id?: string;

  @ApiProperty({ description: 'Name of the template', type: String })
  name: string;

  @ApiProperty({
    enum: [...Object.values(ResourceOriginEnum)],
    enumName: 'ResourceOriginEnum',
    description: 'Origin of the workflow',
    type: String,
  })
  @IsString()
  @IsEnum(ResourceOriginEnum)
  origin?: ResourceOriginEnum;

  @ApiProperty({
    description: 'Triggers of the template',
    type: [NotificationTriggerDto],
  })
  triggers: NotificationTriggerDto[];
}

export class ActivityTopicDto {
  @ApiProperty({ description: 'Internal Topic ID of the notification', type: String })
  _topicId: string;

  @ApiProperty({ description: 'Topic Key of the notification', type: String })
  topicKey: string;
}

// Activity Notification Response DTO
export class ActivityNotificationResponseDto {
  @ApiPropertyOptional({ description: 'Unique identifier of the notification', type: String })
  _id?: string;

  @ApiProperty({ description: 'Environment ID of the notification', type: String })
  _environmentId: string;

  @ApiProperty({ description: 'Organization ID of the notification', type: String })
  _organizationId: string;

  @ApiProperty({ description: 'Subscriber ID of the notification', type: String })
  _subscriberId: string; // Added to align with NotificationEntity

  @ApiProperty({ description: 'Transaction ID of the notification', type: String })
  transactionId: string;

  @ApiPropertyOptional({ description: 'Template ID of the notification', type: String })
  _templateId?: string; // Added to align with NotificationEntity

  @ApiPropertyOptional({ description: 'Digested Notification ID', type: String })
  _digestedNotificationId?: string; // Added to align with NotificationEntity

  @ApiPropertyOptional({ description: 'Creation time of the notification', type: String })
  createdAt?: string;

  @ApiPropertyOptional({ description: 'Last updated time of the notification', type: String })
  updatedAt?: string; // Added to align with NotificationEntity

  @ApiPropertyOptional({
    description: 'Channels of the notification',
    enum: [...Object.values(StepTypeEnum)],
    enumName: 'StepTypeEnum',
    isArray: true,
    type: String,
  })
  channels?: StepTypeEnum[];

  @ApiPropertyOptional({
    description: 'Subscriber of the notification',
    type: ActivityNotificationSubscriberResponseDto,
  })
  subscriber?: ActivityNotificationSubscriberResponseDto;

  @ApiPropertyOptional({
    description: 'Template of the notification',
    type: ActivityNotificationTemplateResponseDto,
  })
  template?: ActivityNotificationTemplateResponseDto;

  @ApiPropertyOptional({
    description: 'Jobs of the notification',
    type: [ActivityNotificationJobResponseDto],
  })
  jobs?: ActivityNotificationJobResponseDto[];

  @ApiPropertyOptional({
    description: 'Payload of the notification',
    type: 'object',
    required: false,
    additionalProperties: true,
  })
  payload?: Record<string, unknown>; // Added to align with NotificationEntity

  @ApiPropertyOptional({
    description: 'Tags associated with the notification',
    type: [String],
  })
  tags?: string[]; // Added to align with NotificationEntity

  @ApiPropertyOptional({
    description: 'Controls associated with the notification',
    type: 'object',
    required: false,
    additionalProperties: true,
  })
  controls?: Record<string, unknown>; // Added to align with NotificationEntity

  @ApiPropertyOptional({
    description: 'To field for subscriber definition',
    type: 'object',
    required: false,
    additionalProperties: true,
  })
  to?: Record<string, unknown>; // Added to align with NotificationEntity

  @ApiPropertyOptional({ description: 'Topics of the notification', type: [ActivityTopicDto] })
  topics?: ActivityTopicDto[];

  @ApiPropertyOptional({
    description: 'Severity of the notification',
    enum: [...Object.values(SeverityLevelEnum)],
    enumName: 'SeverityLevelEnum',
  })
  severity: SeverityLevelEnum;

  @ApiPropertyOptional({ description: 'Criticality of the notification', type: Boolean })
  critical?: boolean;

  @ApiPropertyOptional({ description: 'Contexts (keys) in which the notification was sent', type: [String] })
  contextKeys?: string[];
}

// Activities Response DTO
export class ActivitiesResponseDto {
  @ApiProperty({ description: 'Indicates if there are more activities in the result set', type: Boolean })
  hasMore: boolean;

  @ApiProperty({
    description: 'Array of activity notifications',
    type: [ActivityNotificationResponseDto],
  })
  data: ActivityNotificationResponseDto[];

  @ApiProperty({ description: 'Page size of the activities', type: Number })
  pageSize: number;

  @ApiProperty({ description: 'Current page of the activities', type: Number })
  page: number;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class DigestTimedConfigDto
- export class DigestMetadataDto
- export class ActivityNotificationStepResponseDto
- export class ActivityNotificationExecutionDetailResponseDto
- export class ActivityNotificationJobResponseDto
- export class ActivityNotificationSubscriberResponseDto
- export class NotificationTriggerVariable
- export class NotificationTriggerDto
- export class ActivityNotificationTemplateResponseDto
- export class ActivityTopicDto
- export class ActivityNotificationResponseDto
- export class ActivitiesResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notifications/dtos/activity-graph-states-response.dto.ts
Tamaño: 349 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { ChannelTypeEnum } from '@novu/shared';

export class ActivityGraphStatesResponse {
  @ApiProperty()
  _id: string;

  @ApiProperty()
  count: number;

  @ApiProperty()
  templates: string[];

  @ApiProperty({
    enum: ChannelTypeEnum,
    isArray: true,
  })
  channels: ChannelTypeEnum[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ActivityGraphStatesResponse

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notifications/dtos/activity-stats-response.dto.ts
Tamaño: 170 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';

export class ActivityStatsResponseDto {
  @ApiProperty()
  weeklySent: number;

  @ApiProperty()
  monthlySent: number;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ActivityStatsResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notifications/e2e/get-activity-feed.e2e.ts
Tamaño: 11762 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { ActivityNotificationResponseDto, ChannelTypeEnum } from '@novu/api/models/components';
import { NotificationTemplateEntity, NotificationTemplateRepository, SubscriberRepository } from '@novu/dal';
import { CreateWorkflowDto, StepTypeEnum, WorkflowCreationSourceEnum, WorkflowResponseDto } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Get activity feed - /notifications (GET) #novu-v2', async () => {
  let session: UserSession;
  let template: NotificationTemplateEntity;
  let smsOnlyTemplate: NotificationTemplateEntity;
  let subscriberId: string;
  let novuClient: Novu;
  const isContextEnabled = process.env.IS_CONTEXT_ENABLED;

  before(() => {
    // @ts-expect-error
    process.env.IS_CONTEXT_ENABLED = 'true';
  });

  after(() => {
    // @ts-expect-error
    process.env.IS_CONTEXT_ENABLED = isContextEnabled;
  });

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    template = await session.createTemplate();
    smsOnlyTemplate = await session.createChannelTemplate(StepTypeEnum.SMS);
    subscriberId = SubscriberRepository.createObjectId();
    novuClient = initNovuClassSdk(session);

    await session.testAgent
      .post('/v1/widgets/session/initialize')
      .send({
        applicationIdentifier: session.environment.identifier,
        subscriberId,
        firstName: 'Test',
        lastName: 'User',
        email: 'test@example.com',
      })
      .expect(201);
  });

  it('should get the current activity feed of user', async () => {
    await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: subscriberId,
      payload: { firstName: 'Test' },
    });

    await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: subscriberId,
      payload: { firstName: 'Test' },
    });

    await session.waitForJobCompletion(template._id);
    const body = await novuClient.notifications.list({ page: 0 });
    const activities = body.result;

    expect(activities.hasMore).to.equal(false);
    expect(activities.data.length, JSON.stringify(body.result)).to.equal(2);
    const activity = activities.data[0];
    if (!activity || !activity.template || !activity.subscriber) {
      throw new Error(`must have activity${JSON.stringify(activity)}`);
    }
    expect(activity.template.name).to.equal(template.name);
    expect(activity.template.id).to.equal(template._id);
    expect(activity.subscriber.firstName).to.equal('Test');
    expect(activity.channels).to.be.ok;
    expect(activity.channels).to.include.oneOf(Object.keys(ChannelTypeEnum).map((i) => ChannelTypeEnum[i]));
  });

  it('should filter by channel', async () => {
    await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: subscriberId,
      payload: { firstName: 'Test' },
    });

    await novuClient.trigger({
      workflowId: smsOnlyTemplate.triggers[0].identifier,
      to: subscriberId,
      payload: {
        firstName: 'Test',
      },
    });

    await novuClient.trigger({
      workflowId: smsOnlyTemplate.triggers[0].identifier,
      to: subscriberId,
      payload: {
        firstName: 'Test',
      },
    });

    await session.waitForJobCompletion([template._id, smsOnlyTemplate._id]);
    await novuClient.notifications.list({ page: 0, transactionId: ChannelTypeEnum.Sms });

    const body = await novuClient.notifications.list({ page: 0, channels: [ChannelTypeEnum.Sms] });
    const activities = body.result;

    expect(activities.hasMore).to.equal(false);
    expect(activities.data.length).to.equal(2);
    const activity = activities.data[0];
    if (!activity || !activity.template || !activity.subscriber) {
      throw new Error('must have activity');
    }

    expect(activity.template?.name).to.equal(smsOnlyTemplate.name);
    expect(activity.channels).to.include(ChannelTypeEnum.Sms);
  });

  it('should filter by templateId', async () => {
    await novuClient.trigger({
      workflowId: smsOnlyTemplate.triggers[0].identifier,
      to: subscriberId,
      payload: {
        firstName: 'Test',
      },
    });

    await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: subscriberId,
      payload: { firstName: 'Test' },
    });

    await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: subscriberId,
      payload: { firstName: 'Test' },
    });
    await session.waitForJobCompletion(template._id);
    const body = await novuClient.notifications.list({ page: 0, templates: [template._id] });
    const activities = body.result;

    expect(activities.hasMore).to.equal(false);
    expect(activities.data.length).to.equal(2);

    expect(getActivity(activities.data, 0).template?.id).to.equal(template._id);
    expect(getActivity(activities.data, 1).template?.id).to.equal(template._id);
  });
  function getActivity(
    activities: Array<ActivityNotificationResponseDto>,
    index: number
  ): ActivityNotificationResponseDto {
    const activity = activities[index];
    if (!activity || !activity.template || !activity.subscriber) {
      throw new Error('must have activity');
    }

    return activity;
  }

  it('should filter by email', async () => {
    await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: {
        subscriberId: SubscriberRepository.createObjectId(),
        email: 'test@email.coms',
      },
      payload: {
        firstName: 'Test',
      },
    });
    await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: {
        subscriberId: SubscriberRepository.createObjectId(),
      },
      payload: {
        firstName: 'Test',
      },
    });

    await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: SubscriberRepository.createObjectId(),
      payload: {
        firstName: 'Test',
      },
    });

    await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: SubscriberRepository.createObjectId(),
      payload: {
        firstName: 'Test',
      },
    });

    await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: subscriberId,
      payload: {
        firstName: 'Test',
      },
    });

    await session.waitForJobCompletion(template._id);
    const activities = (await novuClient.notifications.list({ page: 0, emails: ['test@email.coms'] })).result.data;

    expect(activities.length).to.equal(1);
    expect(getActivity(activities, 0).template?.id).to.equal(template._id);
  });

  it('should filter by subscriberId', async () => {
    const subscriberIdToCreate = `${SubscriberRepository.createObjectId()}some-test`;

    await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: {
        subscriberId: subscriberIdToCreate,
        email: 'test@email.coms',
      },
      payload: {
        firstName: 'Test',
      },
    });
    await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: SubscriberRepository.createObjectId(),
      payload: {
        firstName: 'Test',
      },
    });

    await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: SubscriberRepository.createObjectId(),
      payload: {
        firstName: 'Test',
      },
    });
    await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: subscriberId,
      payload: {
        firstName: 'Test',
      },
    });

    await session.waitForJobCompletion(template._id);
    const { result } = await novuClient.notifications.list({ page: 0, subscriberIds: [subscriberIdToCreate] });
    const activities = result.data;

    expect(activities.length).to.equal(1);
    expect(activities[0].template?.id, JSON.stringify(template)).to.equal(template._id);
  });

  it('should return with deleted workflow and subscriber data', async () => {
    const notificationTemplateRepository = new NotificationTemplateRepository();
    const subscriberRepository = new SubscriberRepository();
    const templateToDelete = await session.createTemplate();
    const subscriberIdToDelete = `${SubscriberRepository.createObjectId()}`;

    await novuClient.trigger({
      workflowId: templateToDelete.triggers[0].identifier,
      to: subscriberIdToDelete,
      payload: { firstName: 'Test' },
    });

    await session.waitForJobCompletion(templateToDelete._id);

    await notificationTemplateRepository.delete({ _id: templateToDelete._id, _environmentId: session.environment._id });
    const subscriberToDelete = await subscriberRepository.findOne({
      subscriberId: subscriberIdToDelete,
      _environmentId: session.environment._id,
    });
    await subscriberRepository.delete({ _id: subscriberToDelete?._id, _environmentId: session.environment._id });

    const body = await novuClient.notifications.list({ page: 0 });
    const activities = body.result;

    expect(activities.hasMore).to.equal(false);
    expect(activities.data.length, JSON.stringify(body.result)).to.equal(1);
    const activity = activities.data[0];

    expect(activity.template).to.be.undefined;
    expect(activity.subscriber).to.be.undefined;
    expect(activity.channels).to.be.ok;
    expect(activity.channels).to.include.oneOf(Object.keys(ChannelTypeEnum).map((i) => ChannelTypeEnum[i]));
  });

  it('should filter by contextKeys', async () => {
    const workflowBody: CreateWorkflowDto = {
      name: 'Test Context Workflow',
      workflowId: 'test-context-workflow-notifications',
      __source: WorkflowCreationSourceEnum.DASHBOARD,
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          name: 'Test Step',
          controlValues: {
            subject: 'Test Subject',
            body: 'Test Body',
          },
        },
      ],
    };

    const workflowResponse = await session.testAgent.post('/v2/workflows').send(workflowBody);
    expect(workflowResponse.status).to.equal(201);
    const workflow: WorkflowResponseDto = workflowResponse.body.data;

    await novuClient.trigger({
      workflowId: workflow.workflowId,
      to: subscriberId,
      payload: {},
      context: { projectId: 'project-alpha' },
    });

    await novuClient.trigger({
      workflowId: workflow.workflowId,
      to: subscriberId,
      payload: {},
      context: { projectId: 'project-beta' },
    });

    await session.waitForWorkflowQueueCompletion();
    await session.waitForSubscriberQueueCompletion();
    await session.waitForStandardQueueCompletion();
    await session.waitForJobCompletion(workflow._id);

    // Test 1: No contextKeys filter - should return all notifications
    let body = await novuClient.notifications.list({ page: 0 });
    expect(body.result.data.length).to.be.equal(2);

    // Test 2: Filter by specific context - should return only matching notification
    body = await novuClient.notifications.list({ page: 0, contextKeys: ['projectId:project-alpha'] });
    expect(body.result.data.length).to.be.equal(1);
    expect(body.result.data[0].template?.id).to.equal(workflow._id);
    expect(body.result.data[0].contextKeys).to.deep.equal(['projectId:project-alpha']);

    // Test 3: Filter by different context - should return only matching notification
    body = await novuClient.notifications.list({ page: 0, contextKeys: ['projectId:project-beta'] });
    expect(body.result.data.length).to.be.equal(1);
    expect(body.result.data[0].template?.id).to.equal(workflow._id);
    expect(body.result.data[0].contextKeys).to.deep.equal(['projectId:project-beta']);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getActivity(activities: Array<ActivityNotificationResponseDto>,
    index: number)
Asignaciones con arrow functions encontradas (posibles funciones):
 - isContextEnabled(process.env.IS_CONTEXT_ENABLED;

  before(())
 - IS_CONTEXT_ENABLED('true';
  });

  after(())
 - IS_CONTEXT_ENABLED(isContextEnabled;
  });

  beforeEach(async ())
 - novuClient(initNovuClassSdk(session);

    await session.testAgent
      .post('/v1/widgets/session/initialize'...)
 - activity(activities.data[0];
    if (!activity || !activity.template || !activity.subscriber) {
      throw n...)
 - activity(activities.data[0];
    if (!activity || !activity.template || !activity.subscriber) {
      throw n...)
 - activity(activities[index];
    if (!activity || !activity.template || !activity.subscriber) {
      throw ne...)
 - activities(await novuClient.notifications.list({ page: 0, emails: ['test@email.coms'] })).result.data;

    exp...)
 - activities(result.data;

    expect(activities.length).to.equal(1);
    expect(activities[0].template?.id, JSON...)
 - activity(activities.data[0];

    expect(activity.template).to.be.undefined;
    expect(activity.subscriber)....)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notifications/e2e/get-activity.e2e.ts
Tamaño: 14014 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Novu } from '@novu/api';
import { ActivityNotificationResponseDto } from '@novu/api/models/components';
import { MessageRepository, NotificationRepository, NotificationTemplateEntity, SubscriberRepository } from '@novu/dal';
import { JobStatusEnum, StepTypeEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { initNovuClassSdk } from '../../shared/helpers/e2e/sdk/e2e-sdk.helper';

describe('Get activity - /notifications/:notificationId (GET) #novu-v2', async () => {
  let session: UserSession;
  let template: NotificationTemplateEntity;
  let novuClient: Novu;
  let originalTraceReadValue: string | undefined;
  let originalTraceWriteValue: string | undefined;
  let originalStepRunEnvValue: string | undefined;
  const messageRepository: MessageRepository = new MessageRepository();
  const notificationRepository: NotificationRepository = new NotificationRepository();

  const updateNotification = async ({
    id,
    status,
    body,
  }: {
    id: string;
    status: 'read' | 'unread' | 'archive' | 'unarchive' | 'snooze' | 'unsnooze';
    body?: any;
  }) => {
    return await session.testAgent
      .patch(`/v1/inbox/notifications/${id}/${status}`)
      .set('Authorization', `Bearer ${session.subscriberToken}`)
      .send(body);
  };

  before(async () => {
    originalTraceReadValue = process.env.IS_TRACE_LOGS_READ_ENABLED;
    originalTraceWriteValue = process.env.IS_TRACE_LOGS_ENABLED;
    (process.env as any).IS_TRACE_LOGS_READ_ENABLED = 'true';
    (process.env as any).IS_TRACE_LOGS_ENABLED = 'true';
  });

  after(async () => {
    if (originalTraceReadValue === undefined) {
      delete (process.env as any).IS_TRACE_LOGS_READ_ENABLED;
    } else {
      (process.env as any).IS_TRACE_LOGS_READ_ENABLED = originalTraceReadValue;
    }
    if (originalTraceWriteValue === undefined) {
      delete (process.env as any).IS_TRACE_LOGS_ENABLED;
    } else {
      (process.env as any).IS_TRACE_LOGS_ENABLED = originalTraceWriteValue;
    }
    if (originalStepRunEnvValue === undefined) {
      delete (process.env as any).IS_STEP_RUN_LOGS_READ_ENABLED;
    }
    if (originalStepRunEnvValue !== undefined) {
      (process.env as any).IS_STEP_RUN_LOGS_READ_ENABLED = originalStepRunEnvValue;
    }
  });

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();

    template = await session.createTemplate({
      steps: [
        {
          type: StepTypeEnum.IN_APP,
          content: 'Test notification content {{name}}',
        },
      ],
    });

    novuClient = initNovuClassSdk(session);
  });

  it('should return traces in activity feed when traces feature flag is enabled', async () => {
    // Step 1: Trigger a notification to create trace logs
    const triggerResponse = await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: session.subscriberId,
      payload: { name: 'Test User' },
    });

    expect(triggerResponse.result?.acknowledged).to.equal(true);

    // Step 2: Wait for the worker to process the notification and create traces
    await session.waitForJobCompletion(template._id);
    const message = await messageRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId: session.subscriberProfile?._id,
      _templateId: template._id,
      transactionId: triggerResponse.result?.transactionId,
    });

    expect(message).to.be.ok;
    if (!message) throw new Error('Message not found');

    const { body, status } = await updateNotification({
      id: message._id,
      status: 'read',
    });
    expect(status).to.equal(200);

    const notification = await notificationRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId: session.subscriberProfile?._id,
      _templateId: template._id,
      transactionId: triggerResponse.result?.transactionId,
    });
    expect(notification).to.be.ok;
    if (!notification) throw new Error('Notification not found');

    const activityResponse = await session.testAgent.get(`/v1/notifications/${notification._id}`).expect(200);
    const activity: ActivityNotificationResponseDto = activityResponse.body.data;
    expect(activity).to.be.ok;
    if (!activity.jobs) throw new Error('Jobs not found');

    expect(activity.jobs).to.be.an('array');

    const actualDetails = activity.jobs[0].executionDetails.map((detail) => detail.detail);
    const expectedExecutionDetails = ['Step queued', 'Message created', 'Message sent', 'Message read'];

    expect(actualDetails.length).to.be.equal(4);
    expectedExecutionDetails.forEach((expectedDetail) => {
      expect(actualDetails).to.include(expectedDetail);
    });
  });

  it('should fallback to old method when traces query fails', async () => {
    const triggerResponse = await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: session.subscriberId,
      payload: { name: 'Test User' },
    });

    await session.waitForJobCompletion(template._id);

    const message = await messageRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId: session.subscriberProfile?._id,
      _templateId: template._id,
      transactionId: triggerResponse.result?.transactionId,
    });

    expect(message).to.be.ok;
    if (!message) throw new Error('Message not found');

    const notification = await notificationRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId: session.subscriberProfile?._id,
      _templateId: template._id,
      transactionId: triggerResponse.result?.transactionId,
    });
    expect(notification).to.be.ok;
    if (!notification) throw new Error('Notification not found');

    const activityResponse = await session.testAgent.get(`/v1/notifications/${notification._id}`).expect(200);
    const activity: ActivityNotificationResponseDto = activityResponse.body.data;
    expect(activity).to.be.ok;
    if (!activity.jobs) throw new Error('Jobs not found');

    expect(activity.jobs).to.be.an('array');

    const actualDetails = activity.jobs[0].executionDetails.map((detail) => detail.detail);
    const expectedExecutionDetails = ['Step queued', 'Message created', 'Message sent'];

    expect(actualDetails.length).to.be.equal(3);
    expectedExecutionDetails.forEach((expectedDetail) => {
      expect(actualDetails).to.include(
        expectedDetail,
        `Expected execution detail '${expectedDetail}' not found in job. Found: ${actualDetails.join(', ')}`
      );
    });
    expect(actualDetails).to.not.include('Message read');
  });

  it('should return traces in activity feed with step runs and trace logs', async () => {
    // Step 1: Trigger a notification to create trace logs
    const triggerResponse = await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: session.subscriberId,
      payload: { name: 'Test User' },
    });

    expect(triggerResponse.result?.acknowledged).to.equal(true);

    // Step 2: Wait for the worker to process the notification and create traces
    await session.waitForJobCompletion(template._id);
    const message = await messageRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId: session.subscriberProfile?._id,
      _templateId: template._id,
      transactionId: triggerResponse.result?.transactionId,
    });

    expect(message).to.be.ok;
    if (!message) throw new Error('Message not found');

    const { body, status } = await updateNotification({
      id: message._id,
      status: 'read',
    });
    expect(status).to.equal(200);

    const notification = await notificationRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId: session.subscriberProfile?._id,
      _templateId: template._id,
      transactionId: triggerResponse.result?.transactionId,
    });
    expect(notification).to.be.ok;
    if (!notification) throw new Error('Notification not found');

    const activityResponse = await session.testAgent.get(`/v1/notifications/${notification._id}`).expect(200);
    const activity: ActivityNotificationResponseDto = activityResponse.body.data;
    expect(activity).to.be.ok;
    if (!activity.jobs) throw new Error('Jobs not found');

    expect(activity.jobs).to.be.an('array');

    const actualDetails = activity.jobs[0].executionDetails.map((detail) => detail.detail);
    const expectedExecutionDetails = ['Step queued', 'Message created', 'Message sent', 'Message read'];

    expect(actualDetails.length).to.be.equal(4);
    expectedExecutionDetails.forEach((expectedDetail) => {
      expect(actualDetails).to.include(
        expectedDetail,
        `Expected execution detail '${expectedDetail}' not found in job. Found: ${actualDetails.join(', ')}`
      );
    });
  });

  it('should use step runs when both trace and step run feature flags are enabled', async () => {
    // Enable both feature flags
    (process.env as any).IS_STEP_RUN_LOGS_READ_ENABLED = 'true';

    const triggerResponse = await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: session.subscriberId,
      payload: { name: 'Test User' },
    });

    expect(triggerResponse.result?.acknowledged).to.equal(true);

    await session.waitForJobCompletion(template._id);

    const notification = await notificationRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId: session.subscriberProfile?._id,
      _templateId: template._id,
      transactionId: triggerResponse.result?.transactionId,
    });
    expect(notification).to.be.ok;
    if (!notification) throw new Error('Notification not found');

    const activityResponse = await session.testAgent.get(`/v1/notifications/${notification._id}`).expect(200);
    const activity: ActivityNotificationResponseDto = activityResponse.body.data;
    expect(activity).to.be.ok;

    expect(activity.jobs?.length).to.be.equal(2);
    expect(activity.jobs?.[0].type).to.be.equal(StepTypeEnum.TRIGGER);
    expect(activity.jobs?.[0].status).to.be.equal(JobStatusEnum.COMPLETED);
    expect(activity.jobs?.[1].type).to.be.equal(StepTypeEnum.IN_APP);
    expect(activity.jobs?.[1].status).to.be.equal(JobStatusEnum.COMPLETED);

    // Reset feature flag
    delete (process.env as any).IS_STEP_RUN_LOGS_READ_ENABLED;
  });

  it('should fallback to trace log method when step runs are not found', async () => {
    /*
     *  Enable both feature flags
     * (process.env as any).IS_STEP_RUN_LOGS_READ_ENABLED = 'true';
     */

    const triggerResponse = await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: session.subscriberId,
      payload: { name: 'Test User' },
    });

    expect(triggerResponse.result?.acknowledged).to.equal(true);

    await session.waitForJobCompletion(template._id);

    const message = await messageRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId: session.subscriberProfile?._id,
      _templateId: template._id,
      transactionId: triggerResponse.result?.transactionId,
    });

    expect(message).to.be.ok;
    if (!message) throw new Error('Message not found');

    const notification = await notificationRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId: session.subscriberProfile?._id,
      _templateId: template._id,
      transactionId: triggerResponse.result?.transactionId,
    });
    expect(notification).to.be.ok;
    if (!notification) throw new Error('Notification not found');

    const activityResponse = await session.testAgent.get(`/v1/notifications/${notification._id}`).expect(200);
    const activity: ActivityNotificationResponseDto = activityResponse.body.data;
    expect(activity).to.be.ok;

    // Should still return jobs (even if from step_runs)
    expect(activity.jobs?.length).to.be.equal(1);
    expect(activity.jobs?.[0].type).to.be.equal(StepTypeEnum.IN_APP);
    expect(activity.jobs?.[0].status).to.be.equal(JobStatusEnum.COMPLETED);
  });

  it('should fallback to old method when traces query fails', async () => {
    const triggerResponse = await novuClient.trigger({
      workflowId: template.triggers[0].identifier,
      to: session.subscriberId,
      payload: { name: 'Test User' },
    });

    await session.waitForJobCompletion(template._id);

    const message = await messageRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId: session.subscriberProfile?._id,
      _templateId: template._id,
      transactionId: triggerResponse.result?.transactionId,
    });

    expect(message).to.be.ok;
    if (!message) throw new Error('Message not found');

    const notification = await notificationRepository.findOne({
      _environmentId: session.environment._id,
      _subscriberId: session.subscriberProfile?._id,
      _templateId: template._id,
      transactionId: triggerResponse.result?.transactionId,
    });
    expect(notification).to.be.ok;
    if (!notification) throw new Error('Notification not found');

    const activityResponse = await session.testAgent.get(`/v1/notifications/${notification._id}`).expect(200);
    const activity: ActivityNotificationResponseDto = activityResponse.body.data;
    expect(activity).to.be.ok;
    if (!activity.jobs) throw new Error('Jobs not found');

    expect(activity.jobs).to.be.an('array');

    const actualDetails = activity.jobs[0].executionDetails.map((detail) => detail.detail);
    const expectedExecutionDetails = ['Step queued', 'Message created', 'Message sent'];

    expect(actualDetails.length).to.be.equal(3);
    expectedExecutionDetails.forEach((expectedDetail) => {
      expect(actualDetails).to.include(
        expectedDetail,
        `Expected execution detail '${expectedDetail}' not found in job. Found: ${actualDetails.join(', ')}`
      );
    });
    expect(actualDetails).to.not.include('Message read');
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - updateNotification(async ({
    id,
    status,
    body,
  }: {
    id: string;
    status: 'read' | 'unread' | 'archi...)
 - IS_TRACE_LOGS_ENABLED('true';
  });

  after(async ())
 - IS_STEP_RUN_LOGS_READ_ENABLED(originalStepRunEnvValue;
    }
  });

  beforeEach(async ())
 - novuClient(initNovuClassSdk(session);
  });

  it('should return traces in activity feed when traces feature fl...)
 - actualDetails(activity.jobs[0].executionDetails.map((detail))
 - expectedExecutionDetails(['Step queued', 'Message created', 'Message sent', 'Message read'];

    expect(actualDetails.length...)
 - actualDetails(activity.jobs[0].executionDetails.map((detail))
 - expectedExecutionDetails(['Step queued', 'Message created', 'Message sent'];

    expect(actualDetails.length).to.be.equal(3)...)
 - actualDetails(activity.jobs[0].executionDetails.map((detail))
 - expectedExecutionDetails(['Step queued', 'Message created', 'Message sent', 'Message read'];

    expect(actualDetails.length...)
 - ActivityNotificationResponseDto(activityResponse.body.data;
    expect(activity).to.be.ok;

    expect(activity.jobs?.length).to.be....)
 - ActivityNotificationResponseDto(activityResponse.body.data;
    expect(activity).to.be.ok;

    // Should still return jobs (even if...)
 - actualDetails(activity.jobs[0].executionDetails.map((detail))
 - expectedExecutionDetails(['Step queued', 'Message created', 'Message sent'];

    expect(actualDetails.length).to.be.equal(3)...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notifications/usecases/index.ts
Tamaño: 423 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { GetActivity } from './get-activity/get-activity.usecase';
import { GetActivityFeed } from './get-activity-feed/get-activity-feed.usecase';
import { GetActivityGraphStats } from './get-activity-graph-states/get-activity-graph-states.usecase';
import { GetActivityStats } from './get-activity-stats';

export const USE_CASES = [
  GetActivityStats,
  GetActivityGraphStats,
  GetActivityFeed,
  GetActivity,
  //
];


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notifications/usecases/get-activity-feed/get-activity-feed.command.ts
Tamaño: 1178 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChannelTypeEnum, SeverityLevelEnum } from '@novu/shared';
import { IsArray, IsEnum, IsMongoId, IsNumber, IsOptional, IsString } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class GetActivityFeedCommand extends EnvironmentWithUserCommand {
  @IsNumber()
  page: number;

  @IsNumber()
  limit: number;

  @IsOptional()
  @IsEnum(ChannelTypeEnum, {
    each: true,
  })
  channels?: ChannelTypeEnum[] | null;

  @IsOptional()
  @IsArray()
  @IsMongoId({ each: true })
  templates?: string[] | null;

  @IsOptional()
  @IsArray()
  emails?: string[];

  @IsOptional()
  @IsString()
  search?: string;

  @IsOptional()
  @IsArray()
  subscriberIds?: string[];

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  transactionId?: string[];

  @IsOptional()
  @IsString()
  topicKey?: string;

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  contextKeys?: string[];

  @IsOptional()
  @IsArray()
  @IsEnum(SeverityLevelEnum, { each: true })
  severity?: SeverityLevelEnum[] | null;

  @IsOptional()
  @IsString()
  after?: string;

  @IsOptional()
  @IsString()
  before?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetActivityFeedCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notifications/usecases/get-activity-feed/get-activity-feed.usecase.spec.ts
Tamaño: 6795 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { HttpException, HttpStatus } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { FeatureFlagsService, PinoLogger, TraceLogRepository } from '@novu/application-generic';
import { CommunityOrganizationRepository, NotificationRepository, SubscriberRepository } from '@novu/dal';
import { ApiServiceLevelEnum } from '@novu/shared';
import { expect } from 'chai';
import sinon from 'sinon';
import { GetActivityFeed } from './get-activity-feed.usecase';

describe('GetActivityFeed - validateRetentionLimitForTier', () => {
  let useCase: GetActivityFeed;
  let organizationRepository: CommunityOrganizationRepository;
  let sandbox: sinon.SinonSandbox;

  beforeEach(async () => {
    sandbox = sinon.createSandbox();

    const moduleRef = await Test.createTestingModule({
      providers: [
        GetActivityFeed,
        SubscriberRepository,
        NotificationRepository,
        {
          provide: CommunityOrganizationRepository,
          useValue: {
            findById: () => {},
          },
        },
        {
          provide: TraceLogRepository,
          useValue: {
            createStepRun: () => {},
          },
        },
        {
          provide: FeatureFlagsService,
          useValue: {
            getFlag: () => Promise.resolve({ value: false }),
          },
        },
        {
          provide: PinoLogger,
          useValue: {
            info: () => {},
            error: () => {},
            warn: () => {},
            debug: () => {},
            trace: () => {},
            setContext: () => {},
          },
        },
      ],
    }).compile();

    useCase = moduleRef.get<GetActivityFeed>(GetActivityFeed);
    organizationRepository = moduleRef.get(CommunityOrganizationRepository);
  });

  afterEach(() => {
    sandbox.restore();
  });

  describe('Date handling', () => {
    it('should default to maximum allowed retention period when no dates provided', async () => {
      const now = new Date();
      sandbox.useFakeTimers(now.getTime());

      const mockOrg = {
        _id: 'org-123',
        apiServiceLevel: ApiServiceLevelEnum.PRO,
        createdAt: new Date('2024-01-01'),
      };

      sandbox.stub(organizationRepository, 'findById').resolves(mockOrg as any);

      const result = await (useCase as any).validateRetentionLimitForTier('org-123');
      const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
      expect(new Date(result.after).getTime()).to.be.approximately(sevenDaysAgo.getTime(), 1000); // allowing 1s difference
      expect(result.before).to.equal(now.toISOString());
    });

    it('should use provided dates when within retention period', async () => {
      const now = new Date();
      const twoDaysAgo = new Date(now.getTime() - 2 * 24 * 60 * 60 * 1000);

      const mockOrg = {
        _id: 'org-123',
        apiServiceLevel: ApiServiceLevelEnum.FREE,
        createdAt: new Date('2024-01-01'),
      };

      sandbox.stub(organizationRepository, 'findById').resolves(mockOrg as any);

      const result = await (useCase as any).validateRetentionLimitForTier(
        'org-123',
        twoDaysAgo.toISOString(),
        now.toISOString()
      );

      expect(result.after).to.equal(twoDaysAgo.toISOString());
      expect(result.before).to.equal(now.toISOString());
    });

    it('should reject when after date is later than before date', async () => {
      const now = new Date();
      const tomorrow = new Date(now.getTime() + 24 * 60 * 60 * 1000);

      const mockOrg = {
        _id: 'org-123',
        apiServiceLevel: ApiServiceLevelEnum.FREE,
        createdAt: new Date('2024-01-01'),
      };

      sandbox.stub(organizationRepository, 'findById').resolves(mockOrg as any);

      try {
        await (useCase as any).validateRetentionLimitForTier('org-123', tomorrow.toISOString(), now.toISOString());
        expect.fail('Should have thrown an error');
      } catch (error) {
        expect(error).to.be.instanceOf(HttpException);
        expect(error.message).to.match(/Invalid date range/);
        expect(error.status).to.equal(HttpStatus.BAD_REQUEST);
      }
    });
  });

  describe('Retention periods by tier', () => {
    const testCases = [
      {
        tier: 'Legacy Free',
        apiServiceLevel: ApiServiceLevelEnum.FREE,
        createdAt: new Date('2024-01-01'),
        allowedDays: 30,
        rejectedDays: 31,
      },
      {
        tier: 'New Free',
        apiServiceLevel: ApiServiceLevelEnum.FREE,
        createdAt: new Date('2025-03-01'),
        allowedDays: 1,
        rejectedDays: 2,
      },
      {
        tier: 'Pro',
        apiServiceLevel: ApiServiceLevelEnum.PRO,
        createdAt: new Date(),
        allowedDays: 7,
        rejectedDays: 8,
      },
      {
        tier: 'Team',
        apiServiceLevel: ApiServiceLevelEnum.BUSINESS,
        createdAt: new Date(),
        allowedDays: 90,
        rejectedDays: 91,
      },
    ];

    testCases.forEach(({ tier, apiServiceLevel, createdAt, allowedDays, rejectedDays }) => {
      describe(tier, () => {
        it(`should allow access within ${allowedDays} days`, async () => {
          const now = new Date();
          const withinPeriod = new Date(now.getTime() - allowedDays * 24 * 60 * 60 * 1000);

          const mockOrg = {
            _id: 'org-123',
            apiServiceLevel,
            createdAt,
          };

          sandbox.stub(organizationRepository, 'findById').resolves(mockOrg as any);

          const result = await (useCase as any).validateRetentionLimitForTier(
            'org-123',
            withinPeriod.toISOString(),
            now.toISOString()
          );

          expect(result.after).to.equal(withinPeriod.toISOString());
          expect(result.before).to.equal(now.toISOString());
        });

        it(`should reject access beyond ${rejectedDays} days`, async () => {
          const now = new Date();
          const beyondPeriod = new Date(now.getTime() - rejectedDays * 24 * 60 * 60 * 1000);

          const mockOrg = {
            _id: 'org-123',
            apiServiceLevel,
            createdAt,
          };

          sandbox.stub(organizationRepository, 'findById').resolves(mockOrg as any);

          try {
            await (useCase as any).validateRetentionLimitForTier(
              'org-123',
              beyondPeriod.toISOString(),
              now.toISOString()
            );
            expect.fail('Should have thrown an error');
          } catch (error) {
            expect(error).to.be.instanceOf(HttpException);
            console.log(error.message);
            expect(error.message).to.match(/retention period/);
            expect(error.status).to.equal(HttpStatus.PAYMENT_REQUIRED);
          }
        });
      });
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - moduleRef(await Test.createTestingModule({
      providers: [
        GetActivityFeed,
        SubscriberRepos...)
 - organizationRepository(moduleRef.get(CommunityOrganizationRepository);
  });

  afterEach(())
 - sevenDaysAgo(new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
      expect(new Date(result.after).getTime()).to...)
 - result(await (useCase as any).validateRetentionLimitForTier(
        'org-123',
        twoDaysAgo.toISOStr...)
 - mockOrg({
        _id: 'org-123',
        apiServiceLevel: ApiServiceLevelEnum.FREE,
        createdAt: new ...)
 - testCases([
      {
        tier: 'Legacy Free',
        apiServiceLevel: ApiServiceLevelEnum.FREE,
        cr...)
 - result(await (useCase as any).validateRetentionLimitForTier(
            'org-123',
            withinPerio...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notifications/usecases/get-activity-feed/get-activity-feed.usecase.ts
Tamaño: 12673 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { HttpException, HttpStatus, Injectable } from '@nestjs/common';
import {
  FeatureFlagsService,
  Instrument,
  PinoLogger,
  QueryBuilder,
  Trace,
  TraceLogRepository,
} from '@novu/application-generic';
import {
  CommunityOrganizationRepository,
  ExecutionDetailFeedItem,
  NotificationFeedItemEntity,
  NotificationRepository,
  OrganizationEntity,
  SubscriberRepository,
} from '@novu/dal';
import {
  ApiServiceLevelEnum,
  ExecutionDetailsSourceEnum,
  ExecutionDetailsStatusEnum,
  FeatureFlagsKeysEnum,
  FeatureNameEnum,
  getFeatureForTierAsNumber,
} from '@novu/shared';
import { ActivitiesResponseDto, ActivityNotificationResponseDto } from '../../dtos/activities-response.dto';
import { GetActivityFeedCommand } from './get-activity-feed.command';
import { mapFeedItemToDto } from './map-feed-item-to.dto';

const traceFindColumns = ['entity_id', 'id', 'status', 'title', 'raw_data', 'created_at'] as const;
type TraceFindResult = Pick<Trace, (typeof traceFindColumns)[number]>;

@Injectable()
export class GetActivityFeed {
  constructor(
    private subscribersRepository: SubscriberRepository,
    private notificationRepository: NotificationRepository,
    private organizationRepository: CommunityOrganizationRepository,
    private traceLogRepository: TraceLogRepository,
    private featureFlagsService: FeatureFlagsService,
    private logger: PinoLogger
  ) {}

  async execute(command: GetActivityFeedCommand): Promise<ActivitiesResponseDto> {
    let subscriberIds: string[] | undefined;

    const { after, before } = await this.validateRetentionLimitForTier(
      command.organizationId,
      command.after,
      command.before
    );

    command.after = after;
    command.before = before;

    if (command.search || command.emails?.length || command.subscriberIds?.length) {
      subscriberIds = await this.findSubscribers(command);
    }

    if (subscriberIds && subscriberIds.length === 0) {
      return {
        page: 0,
        hasMore: false,
        pageSize: command.limit,
        data: [],
      };
    }

    const notifications: NotificationFeedItemEntity[] = await this.getFeedNotifications(command, subscriberIds);

    const data = notifications.reduce<ActivityNotificationResponseDto[]>((memo, notification) => {
      // TODO: Identify why mongo returns an array of undefined or null values. Is it a data issue?
      if (notification) {
        memo.push(mapFeedItemToDto(notification));
      }

      return memo;
    }, []);

    return {
      page: command.page,
      hasMore: notifications?.length === command.limit,
      pageSize: command.limit,
      data,
    };
  }

  private async validateRetentionLimitForTier(organizationId: string, after?: string, before?: string) {
    const organization = await this.organizationRepository.findById(organizationId);

    if (!organization) {
      throw new HttpException('Organization not found', HttpStatus.INTERNAL_SERVER_ERROR);
    }

    const maxRetentionMs = this.getMaxRetentionPeriodByOrganization(organization);

    // For unlimited retention (self-hosted), skip retention validation
    if (maxRetentionMs === Number.MAX_SAFE_INTEGER) {
      const effectiveAfterDate = after ? this.parseAndValidateDate(after, 'after') : undefined;
      const effectiveBeforeDate = before ? this.parseAndValidateDate(before, 'before') : undefined;

      // Basic validation for date range if both dates are provided
      if (effectiveAfterDate && effectiveBeforeDate && effectiveAfterDate > effectiveBeforeDate) {
        throw new HttpException(
          'Invalid date range: start date (after) must be earlier than end date (before)',
          HttpStatus.BAD_REQUEST
        );
      }

      return {
        after: effectiveAfterDate?.toISOString(),
        before: effectiveBeforeDate?.toISOString(),
      };
    }

    const earliestAllowedDate = new Date(Date.now() - maxRetentionMs);

    // If no after date is provided, default to the earliest allowed date
    const effectiveAfterDate = after ? this.parseAndValidateDate(after, 'after') : earliestAllowedDate;
    const effectiveBeforeDate = before ? this.parseAndValidateDate(before, 'before') : new Date();

    this.validateDateRange(earliestAllowedDate, effectiveAfterDate, effectiveBeforeDate);

    return {
      after: effectiveAfterDate.toISOString(),
      before: effectiveBeforeDate.toISOString(),
    };
  }

  private parseAndValidateDate(dateString: string, parameterName: string): Date {
    const parsedDate = new Date(dateString);

    if (Number.isNaN(parsedDate.getTime())) {
      throw new HttpException(
        `Invalid date format for parameter '${parameterName}': ${dateString}. Please provide a valid ISO 8601 date string.`,
        HttpStatus.BAD_REQUEST
      );
    }

    return parsedDate;
  }

  private validateDateRange(earliestAllowedDate: Date, afterDate: Date, beforeDate: Date) {
    if (afterDate > beforeDate) {
      throw new HttpException(
        'Invalid date range: start date (after) must be earlier than end date (before)',
        HttpStatus.BAD_REQUEST
      );
    }

    // add buffer to account for time delay in execution
    const buffer = 1 * 60 * 60 * 1000; // 1 hour
    const bufferedEarliestAllowedDate = new Date(earliestAllowedDate.getTime() - buffer);

    if (afterDate < bufferedEarliestAllowedDate || beforeDate < bufferedEarliestAllowedDate) {
      throw new HttpException(
        `Requested date range exceeds your plan's retention period. ` +
          `The earliest accessible date for your plan is ${earliestAllowedDate.toISOString().split('T')[0]}. ` +
          `Please upgrade your plan to access older activities.`,
        HttpStatus.PAYMENT_REQUIRED
      );
    }
  }

  /**
   * Notifications are automatically deleted after a certain period of time
   * by a background job.
   *
   * @see https://github.com/novuhq/cloud-infra/blob/main/scripts/expiredNotification.js#L93
   */
  private getMaxRetentionPeriodByOrganization(organization: OrganizationEntity) {
    // 1. Self-hosted: effectively unlimited, use a large but safe finite window (100 years)
    if (process.env.IS_SELF_HOSTED === 'true') {
      return 100 * 365 * 24 * 60 * 60 * 1000; // ~100 years in ms, safe for Date math
    }

    const { apiServiceLevel, createdAt } = organization;

    // 2. Special case: Free tier orgs created before Feb 28, 2025 get 30 days
    if (apiServiceLevel === ApiServiceLevelEnum.FREE && new Date(createdAt) < new Date('2025-02-28')) {
      return 30 * 24 * 60 * 60 * 1000;
    }

    // 3. Otherwise, use tier-based retention from feature flags
    return getFeatureForTierAsNumber(
      FeatureNameEnum.PLATFORM_ACTIVITY_FEED_RETENTION,
      apiServiceLevel ?? ApiServiceLevelEnum.FREE,
      true
    );
  }

  @Instrument()
  private async findSubscribers(command: GetActivityFeedCommand): Promise<string[]> {
    return await this.subscribersRepository.searchSubscribers(
      command.environmentId,
      command.subscriberIds,
      command.emails,
      command.search
    );
  }

  @Instrument()
  private async getFeedNotifications(
    command: GetActivityFeedCommand,
    subscriberIds?: string[]
  ): Promise<NotificationFeedItemEntity[]> {
    const notifications = await this.notificationRepository.getFeed(
      command.environmentId,
      {
        channels: command.channels,
        templates: command.templates,
        subscriberIds: subscriberIds || [],
        transactionId: command.transactionId,
        topicKey: command.topicKey,
        after: command.after,
        before: command.before,
        severity: command.severity,
        contextKeys: command.contextKeys,
      },
      command.page * command.limit,
      command.limit
    );

    const isClickHouseOnlyEnabled = await this.featureFlagsService.getFlag({
      key: FeatureFlagsKeysEnum.IS_EXECUTION_DETAILS_CLICKHOUSE_ONLY_ENABLED,
      defaultValue: false,
      organization: { _id: command.organizationId },
      user: { _id: command.userId },
      environment: { _id: command.environmentId },
    });

    if (isClickHouseOnlyEnabled) {
      return await this.enhanceNotificationsWithTraces(notifications, command);
    }

    return notifications;
  }

  private async enhanceNotificationsWithTraces(
    notifications: NotificationFeedItemEntity[],
    command: GetActivityFeedCommand
  ): Promise<NotificationFeedItemEntity[]> {
    try {
      // Collect all job IDs from all notifications
      const allJobIds: string[] = [];
      for (const notification of notifications) {
        if (notification.jobs) {
          allJobIds.push(...notification.jobs.map((job) => job._id));
        }
      }

      if (allJobIds.length === 0) {
        return notifications;
      }

      // Get execution details from ClickHouse for all job IDs
      const executionDetailsByJobId = await this.getExecutionDetailsByEntityId(allJobIds, command);

      // Enhance each notification with the execution details
      const enhancedNotifications = notifications.map((notification) => {
        if (!notification.jobs) {
          return notification;
        }

        const enhancedJobs = notification.jobs.map((job) => {
          const executionDetails = executionDetailsByJobId.get(job._id) || [];

          return {
            ...job,
            executionDetails,
          };
        });

        return {
          ...notification,
          jobs: enhancedJobs,
        };
      });

      this.logger.debug('Successfully enhanced notifications with ClickHouse execution details', {
        notificationCount: notifications.length,
        jobCount: allJobIds.length,
        executionDetailsCount: Array.from(executionDetailsByJobId.values()).flat().length,
      });

      return enhancedNotifications;
    } catch (error) {
      this.logger.error(
        {
          error: error instanceof Error ? error.message : 'Unknown error',
          environmentId: command.environmentId,
          organizationId: command.organizationId,
        },
        'Failed to enhance notifications with ClickHouse execution details, falling back to MongoDB data'
      );

      // Fall back to the original notifications if ClickHouse query fails
      return notifications;
    }
  }

  private mapTraceStatusToExecutionStatus(traceStatus: string): ExecutionDetailsStatusEnum {
    switch (traceStatus.toLowerCase()) {
      case 'success':
        return ExecutionDetailsStatusEnum.SUCCESS;
      case 'error':
      case 'failed':
        return ExecutionDetailsStatusEnum.FAILED;
      case 'warning':
        return ExecutionDetailsStatusEnum.WARNING;
      case 'pending':
        return ExecutionDetailsStatusEnum.PENDING;
      case 'queued':
        return ExecutionDetailsStatusEnum.QUEUED;
      default:
        return ExecutionDetailsStatusEnum.PENDING;
    }
  }

  private async getExecutionDetailsByEntityId(
    entityIds: string[],
    command: GetActivityFeedCommand
  ): Promise<Map<string, ExecutionDetailFeedItem[]>> {
    if (entityIds.length === 0) {
      return new Map();
    }

    const traceQuery = new QueryBuilder<Trace>({
      environmentId: command.environmentId,
    })
      .whereIn('entity_id', entityIds)
      .whereEquals('entity_type', 'step_run')
      .build();

    const traceResult = await this.traceLogRepository.find({
      where: traceQuery,
      orderBy: 'created_at',
      orderDirection: 'ASC',
      select: traceFindColumns,
    });

    const executionDetailsByEntityId = new Map<string, ExecutionDetailFeedItem[]>();

    // Group traces by entity ID
    const traceLogsByEntityId = new Map<string, TraceFindResult[]>();
    for (const trace of traceResult.data) {
      if (!traceLogsByEntityId.has(trace.entity_id)) {
        traceLogsByEntityId.set(trace.entity_id, []);
      }
      const entityTraces = traceLogsByEntityId.get(trace.entity_id);
      if (entityTraces) {
        entityTraces.push(trace);
      }
    }

    // Convert traces to execution details for each entity
    for (const [entityId, traces] of traceLogsByEntityId) {
      const executionDetails: ExecutionDetailFeedItem[] = traces.map((trace: TraceFindResult) => ({
        _id: trace.id,
        providerId: undefined,
        detail: trace.title,
        source: ExecutionDetailsSourceEnum.INTERNAL,
        _jobId: entityId,
        status: this.mapTraceStatusToExecutionStatus(trace.status),
        isTest: false,
        isRetry: false,
        createdAt: new Date(trace.created_at).toISOString(),
        raw: trace.raw_data,
      }));

      executionDetailsByEntityId.set(entityId, executionDetails);
    }

    return executionDetailsByEntityId;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - data(notifications.reduce<ActivityNotificationResponseDto[]>((memo, notification))
 - enhancedNotifications(notifications.map((notification))
 - enhancedJobs(notification.jobs.map((job))
Declaraciones 'export' encontradas:
- export class GetActivityFeed

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notifications/usecases/get-activity-feed/map-feed-item-to.dto.ts
Tamaño: 9144 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  ExecutionDetailFeedItem,
  JobFeedItem,
  NotificationFeedItemEntity,
  NotificationStepEntity,
  StepFilter,
  SubscriberFeedItem,
  TemplateFeedItem,
} from '@novu/dal';
import {
  DigestTypeEnum,
  FilterParts,
  FilterPartTypeEnum,
  IDigestRegularMetadata,
  IDigestTimedMetadata,
  IWorkflowStepMetadata,
  ProvidersIdEnum,
  SeverityLevelEnum,
  StepTypeEnum,
} from '@novu/shared';
import { MessageTemplateDto } from '../../../shared/dtos/message.template.dto';
import {
  FieldFilterPartDto,
  FilterPartsDto,
  OnlineInLastFilterPartDto,
  PreviousStepFilterPartDto,
  RealtimeOnlineFilterPartDto,
  StepFilterDto,
  TenantFilterPartDto,
  WebhookFilterPartDto,
} from '../../../shared/dtos/step-filter-dto';
import {
  ActivityNotificationExecutionDetailResponseDto,
  ActivityNotificationJobResponseDto,
  ActivityNotificationResponseDto,
  ActivityNotificationStepResponseDto,
  ActivityNotificationSubscriberResponseDto,
  ActivityNotificationTemplateResponseDto,
  DigestMetadataDto,
} from '../../dtos/activities-response.dto';

function buildSubscriberDto(subscriber: SubscriberFeedItem): ActivityNotificationSubscriberResponseDto {
  return {
    _id: subscriber._id,
    subscriberId: subscriber.subscriberId,
    email: subscriber.email,
    firstName: subscriber.firstName,
    lastName: subscriber.lastName,
    phone: subscriber.phone,
  };
}

function buildTemplate(template: TemplateFeedItem): ActivityNotificationTemplateResponseDto {
  return {
    _id: template._id,
    name: template.name,
    triggers: template.triggers,
    origin: template.origin,
  };
}

export function mapFeedItemToDto(entity: NotificationFeedItemEntity): ActivityNotificationResponseDto {
  return {
    _digestedNotificationId: entity._digestedNotificationId,
    _environmentId: entity._environmentId,
    _id: entity._id,
    _organizationId: entity._organizationId,
    _subscriberId: entity._subscriberId,
    _templateId: entity._templateId,
    topics: entity.topics?.map((topic) => ({
      _topicId: topic._topicId,
      topicKey: topic.topicKey,
    })),
    channels: entity.channels,
    createdAt: entity.createdAt,
    jobs: entity.jobs.map(mapJobToDto),
    tags: entity.tags,
    transactionId: entity.transactionId,
    updatedAt: entity.updatedAt,
    controls: entity.controls as Record<string, unknown>,
    payload: entity.payload as Record<string, unknown>,
    to: entity.to as Record<string, unknown>,
    subscriber: entity.subscriber ? buildSubscriberDto(entity.subscriber) : undefined,
    template: entity.template ? buildTemplate(entity.template) : undefined,
    severity: entity.severity ?? SeverityLevelEnum.NONE,
    critical: entity.critical,
    contextKeys: entity.contextKeys,
  };
}

function mapChildFilterToDto(filterPart: FilterParts): FilterPartsDto {
  switch (filterPart.on) {
    case FilterPartTypeEnum.SUBSCRIBER:
    case FilterPartTypeEnum.PAYLOAD:
      return {
        ...filterPart,
        on: filterPart.on, // Ensure the correct enum value is set
      } as FieldFilterPartDto;

    case FilterPartTypeEnum.WEBHOOK:
      return {
        ...filterPart,
        on: FilterPartTypeEnum.WEBHOOK,
      } as WebhookFilterPartDto;

    case FilterPartTypeEnum.IS_ONLINE:
      return {
        ...filterPart,
        on: FilterPartTypeEnum.IS_ONLINE,
      } as RealtimeOnlineFilterPartDto;

    case FilterPartTypeEnum.IS_ONLINE_IN_LAST:
      return {
        ...filterPart,
        on: FilterPartTypeEnum.IS_ONLINE_IN_LAST,
      } as OnlineInLastFilterPartDto;

    case FilterPartTypeEnum.PREVIOUS_STEP:
      return {
        ...filterPart,
        on: FilterPartTypeEnum.PREVIOUS_STEP,
      } as PreviousStepFilterPartDto;

    case FilterPartTypeEnum.TENANT:
      return {
        ...filterPart,
        on: FilterPartTypeEnum.TENANT,
      } as TenantFilterPartDto;

    default:
      throw new Error(`Unknown filter part type: ${filterPart}`);
  }
}

function mapToFilterDto(stepFilter: StepFilter): StepFilterDto {
  return {
    children: stepFilter.children.map((child) => mapChildFilterToDto(child)),
    isNegated: stepFilter.isNegated,
    type: stepFilter.type,
    value: stepFilter.value,
  };
}

function convertStepToResponse(step: NotificationStepEntity): ActivityNotificationStepResponseDto {
  const responseDto = new ActivityNotificationStepResponseDto();

  responseDto._id = step._id || '';
  responseDto.active = step.active || false;
  responseDto.replyCallback = step.replyCallback;
  responseDto.controlVariables = step.controlVariables;
  responseDto.metadata = step.metadata;
  responseDto.issues = step.issues;
  responseDto._templateId = step._templateId || '';
  responseDto.name = step.name;
  responseDto._parentId = step._parentId || null;

  // Map filters
  responseDto.filters = (step.filters || []).map(mapToFilterDto);

  // Map template if exists
  if (step.template) {
    const messageTemplateDto = new MessageTemplateDto();
    messageTemplateDto.type = step.template.type;
    messageTemplateDto.content = step.template.content;
    messageTemplateDto.contentType = step.template.contentType;
    messageTemplateDto.cta = step.template.cta;
    messageTemplateDto.actor = step.template.actor;
    messageTemplateDto.variables = step.template.variables;
    messageTemplateDto._feedId = step.template._feedId;
    messageTemplateDto._layoutId = step.template._layoutId;
    messageTemplateDto.name = step.template.name;
    messageTemplateDto.subject = step.template.subject;
    messageTemplateDto.title = step.template.title;
    messageTemplateDto.preheader = step.template.preheader;
    messageTemplateDto.senderName = step.template.senderName;
    messageTemplateDto._creatorId = step.template._creatorId;

    responseDto.template = messageTemplateDto;
  }

  if (step.variants) {
    responseDto.variants = step.variants.map((variant) => convertStepToResponse(variant));
  }

  return responseDto;
}

function isDigestRegularMetadata(item: IWorkflowStepMetadata): item is IDigestRegularMetadata {
  return 'type' in item && (item.type === DigestTypeEnum.REGULAR || item.type === DigestTypeEnum.BACKOFF);
}

function isDigestTimedMetadata(item: IWorkflowStepMetadata): item is IDigestTimedMetadata {
  return 'type' in item && item.type === DigestTypeEnum.TIMED;
}

export function mapDigest(
  digestData?:
    | (IWorkflowStepMetadata & {
        events?: any[];
      })
    | string
    | null
): DigestMetadataDto | undefined {
  if (!digestData) {
    return undefined;
  }

  const digestItem =
    typeof digestData === 'string'
      ? (JSON.parse(digestData) as IWorkflowStepMetadata & {
          events?: any[];
        })
      : (digestData as IWorkflowStepMetadata & {
          events?: any[];
        });

  if (!digestItem) {
    return undefined;
  }

  // Type guarding and mapping based on the type of item
  if (isDigestRegularMetadata(digestItem)) {
    // If it's IDigestRegularMetadata
    return {
      digestKey: digestItem.digestKey,
      amount: digestItem.amount,
      unit: digestItem.unit,
      events: digestItem.events || [], // Default to an empty array if no events are provided
      type: digestItem.type, // Set the type as either REGULAR or BACKOFF
      backoff: digestItem.backoff,
      backoffAmount: digestItem.backoffAmount,
      backoffUnit: digestItem.backoffUnit,
      updateMode: digestItem.updateMode, // Set update mode if available
    };
  }
  if (isDigestTimedMetadata(digestItem)) {
    return {
      digestKey: digestItem.digestKey,
      amount: digestItem.amount,
      unit: digestItem.unit,
      events: digestItem.events || [], // Default to an empty array if no events are provided
      type: DigestTypeEnum.TIMED, // Set the type as TIMED
      timed: {
        atTime: digestItem.timed?.atTime,
        weekDays: digestItem.timed?.weekDays,
        monthDays: digestItem.timed?.monthDays,
        ordinal: digestItem.timed?.ordinal,
        ordinalValue: digestItem.timed?.ordinalValue,
        monthlyType: digestItem.timed?.monthlyType,
        cronExpression: digestItem.timed?.cronExpression,
        untilDate: digestItem.timed?.untilDate,
      },
    };
  }

  return undefined;
}

function mapJobToDto(item: JobFeedItem): ActivityNotificationJobResponseDto {
  return {
    _id: item._id,
    type: item.type as StepTypeEnum,
    digest: mapDigest(item.digest),
    executionDetails: item.executionDetails.map(convertExecutionDetail),
    step: convertStepToResponse(item.step),
    overrides: item.overrides,
    payload: item.payload,
    providerId: item.providerId as ProvidersIdEnum,
    status: item.status,
    updatedAt: item.updatedAt,
    scheduleExtensionsCount: item.scheduleExtensionsCount,
  };
}

function convertExecutionDetail(entity: ExecutionDetailFeedItem): ActivityNotificationExecutionDetailResponseDto {
  return {
    _id: entity._id,
    detail: entity.detail,
    isRetry: entity.isRetry,
    isTest: entity.isTest,
    providerId: entity.providerId as unknown as ProvidersIdEnum,
    source: entity.source,
    status: entity.status,
    raw: entity.raw || undefined,
    createdAt: entity.createdAt,
  };
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - buildSubscriberDto(subscriber: SubscriberFeedItem)
 - buildTemplate(template: TemplateFeedItem)
 - mapFeedItemToDto(entity: NotificationFeedItemEntity)
 - mapChildFilterToDto(filterPart: FilterParts)
 - mapToFilterDto(stepFilter: StepFilter)
 - convertStepToResponse(step: NotificationStepEntity)
 - isDigestRegularMetadata(item: IWorkflowStepMetadata)
 - isDigestTimedMetadata(item: IWorkflowStepMetadata)
 - mapDigest(digestData?:
    | (IWorkflowStepMetadata & {
        events?: any[];
      })
 - mapJobToDto(item: JobFeedItem)
 - convertExecutionDetail(entity: ExecutionDetailFeedItem)
Asignaciones con arrow functions encontradas (posibles funciones):
 - variants(step.variants.map((variant))
Declaraciones 'export' encontradas:
- export function mapFeedItemToDto
- export function mapDigest

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notifications/usecases/get-activity-graph-states/get-activity-graph-states.command.ts
Tamaño: 271 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsNumber, IsOptional } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class GetActivityGraphStatsCommand extends EnvironmentWithUserCommand {
  @IsNumber()
  @IsOptional()
  days: number;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetActivityGraphStatsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notifications/usecases/get-activity-graph-states/get-activity-graph-states.usecase.ts
Tamaño: 683 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { NotificationRepository } from '@novu/dal';
import { subDays } from 'date-fns';
import { ActivityGraphStatesResponse } from '../../dtos/activity-graph-states-response.dto';
import { GetActivityGraphStatsCommand } from './get-activity-graph-states.command';

@Injectable()
export class GetActivityGraphStats {
  constructor(private notificationRepository: NotificationRepository) {}

  async execute(command: GetActivityGraphStatsCommand): Promise<ActivityGraphStatesResponse[]> {
    return await this.notificationRepository.getActivityGraphStats(
      subDays(new Date(), command.days),
      command.environmentId
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetActivityGraphStats

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notifications/usecases/get-activity-stats/get-activity-stats.command.ts
Tamaño: 147 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentCommand } from '../../../shared/commands/project.command';

export class GetActivityStatsCommand extends EnvironmentCommand {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetActivityStatsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notifications/usecases/get-activity-stats/get-activity-stats.usecase.ts
Tamaño: 641 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { NotificationRepository } from '@novu/dal';
import { ActivityStatsResponseDto } from '../../dtos/activity-stats-response.dto';
import { GetActivityStatsCommand } from './get-activity-stats.command';

@Injectable()
export class GetActivityStats {
  constructor(private notificationRepository: NotificationRepository) {}

  async execute(command: GetActivityStatsCommand): Promise<ActivityStatsResponseDto> {
    const result = await this.notificationRepository.getStats(command.environmentId);

    return {
      weeklySent: result.weekly,
      monthlySent: result.monthly,
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetActivityStats

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notifications/usecases/get-activity-stats/index.ts
Tamaño: 137 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export { GetActivityStatsCommand } from './get-activity-stats.command';
export { GetActivityStats } from './get-activity-stats.usecase';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notifications/usecases/get-activity/get-activity.command.ts
Tamaño: 271 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsMongoId } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class GetActivityCommand extends EnvironmentWithUserCommand {
  @IsDefined()
  @IsMongoId()
  notificationId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetActivityCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/notifications/usecases/get-activity/get-activity.usecase.ts
Tamaño: 14737 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import {
  AnalyticsService,
  FeatureFlagsService,
  PinoLogger,
  QueryBuilder,
  StepRun,
  StepRunRepository,
  Trace,
  TraceLogRepository,
  WorkflowRun,
  WorkflowRunRepository,
} from '@novu/application-generic';
import {
  ExecutionDetailFeedItem,
  JobFeedItem,
  JobStatusEnum,
  NotificationFeedItemEntity,
  NotificationRepository,
  NotificationStepEntity,
} from '@novu/dal';
import {
  ExecutionDetailsSourceEnum,
  ExecutionDetailsStatusEnum,
  FeatureFlagsKeysEnum,
  ProvidersIdEnum,
  StepTypeEnum,
  TriggerTypeEnum,
} from '@novu/shared';

import { ActivityNotificationResponseDto } from '../../dtos/activities-response.dto';
import { mapFeedItemToDto } from '../get-activity-feed/map-feed-item-to.dto';
import { GetActivityCommand } from './get-activity.command';

const workflowRunSelectColumns = [
  'workflow_run_id',
  'workflow_id',
  'workflow_name',
  'organization_id',
  'environment_id',
  'subscriber_id',
  'external_subscriber_id',
  'trigger_identifier',
  'transaction_id',
  'channels',
  'subscriber_to',
  'payload',
  'topics',
  'context_keys',
  'created_at',
  'updated_at',
] as const;

const stepRunSelectColumns = [
  'step_run_id',
  'step_id',
  'step_type',
  'provider_id',
  'status',
  'created_at',
  'updated_at',
  'schedule_extensions_count',
] as const;
type StepRunFetchResult = Pick<StepRun, (typeof stepRunSelectColumns)[number]>;

const traceSelectColumns = ['id', 'entity_id', 'title', 'status', 'created_at', 'raw_data'] as const;

@Injectable()
export class GetActivity {
  constructor(
    private notificationRepository: NotificationRepository,
    private analyticsService: AnalyticsService,
    private traceLogRepository: TraceLogRepository,
    private stepRunRepository: StepRunRepository,
    private workflowRunRepository: WorkflowRunRepository,
    private logger: PinoLogger,
    private featureFlagsService: FeatureFlagsService
  ) {}

  async execute(command: GetActivityCommand): Promise<ActivityNotificationResponseDto> {
    this.analyticsService.track('Get Activity Feed Item - [Activity Feed]', command.userId, {
      _organization: command.organizationId,
    });

    const flagContext = {
      organization: { _id: command.organizationId },
      user: { _id: command.userId },
      environment: { _id: command.environmentId },
    } as const;

    const [tracesEnabled, stepRunsEnabled, workflowRunsEnabled] = await Promise.all([
      this.featureFlagsService.getFlag({
        key: FeatureFlagsKeysEnum.IS_TRACE_LOGS_READ_ENABLED,
        defaultValue: false,
        ...flagContext,
      }),
      this.featureFlagsService.getFlag({
        key: FeatureFlagsKeysEnum.IS_STEP_RUN_LOGS_READ_ENABLED,
        defaultValue: false,
        ...flagContext,
      }),
      this.featureFlagsService.getFlag({
        key: FeatureFlagsKeysEnum.IS_WORKFLOW_RUN_LOGS_READ_ENABLED,
        defaultValue: false,
        ...flagContext,
      }),
    ]);

    this.logger.debug('feature flags', {
      tracesEnabled,
      stepRunsEnabled,
      workflowRunsEnabled,
    });

    let feedItem: NotificationFeedItemEntity | null = null;

    if (workflowRunsEnabled && stepRunsEnabled && tracesEnabled) {
      this.logger.debug('analytics full ingegration enabled');
      feedItem = await this.getFeedItemFromWorkflowRuns(command);
    } else if (tracesEnabled && stepRunsEnabled) {
      this.logger.debug('analytics step runs enabled, no workflow runs');
      feedItem = await this.getFeedItemFromStepRuns(command);
    } else if (tracesEnabled) {
      this.logger.debug('analytics traces enabled, no step runs or workflow runs');
      feedItem = await this.getFeedItemFromTraceLog(command);
    } else {
      this.logger.debug('analytics fallback to old method');
      feedItem = await this.notificationRepository.getFeedItem(
        command.notificationId,
        command.environmentId,
        command.organizationId
      );
    }

    if (!feedItem) {
      throw new NotFoundException('Notification not found', {
        cause: `Notification with id ${command.notificationId} not found`,
      });
    }

    return mapFeedItemToDto(feedItem);
  }

  private mapTraceStatusToExecutionStatus(traceStatus: string): ExecutionDetailsStatusEnum {
    switch (traceStatus.toLowerCase()) {
      case 'success':
        return ExecutionDetailsStatusEnum.SUCCESS;
      case 'error':
      case 'failed':
        return ExecutionDetailsStatusEnum.FAILED;
      case 'warning':
        return ExecutionDetailsStatusEnum.WARNING;
      case 'pending':
        return ExecutionDetailsStatusEnum.PENDING;
      case 'queued':
        return ExecutionDetailsStatusEnum.QUEUED;
      default:
        return ExecutionDetailsStatusEnum.PENDING;
    }
  }

  private async getExecutionDetailsByEntityId(
    entityIds: string[],
    command: GetActivityCommand
  ): Promise<Map<string, ExecutionDetailFeedItem[]>> {
    if (entityIds.length === 0) {
      return new Map();
    }

    const traceQuery = new QueryBuilder<Trace>({
      environmentId: command.environmentId,
    })
      .whereIn('entity_id', entityIds)
      .whereEquals('entity_type', 'step_run')
      .build();

    const traceResult = await this.traceLogRepository.find({
      where: traceQuery,
      orderBy: 'created_at',
      orderDirection: 'ASC',
      select: traceSelectColumns,
    });

    const executionDetailsByEntityId = new Map<string, ExecutionDetailFeedItem[]>();

    // Group traces by entity ID
    const traceLogsByEntityId = new Map<string, typeof traceResult.data>();
    for (const trace of traceResult.data) {
      if (!traceLogsByEntityId.has(trace.entity_id)) {
        traceLogsByEntityId.set(trace.entity_id, []);
      }
      // biome-ignore lint/style/noNonNullAssertion: <explanation> we we create it in the if above
      traceLogsByEntityId.get(trace.entity_id)!.push(trace);
    }

    // Convert traces to execution details for each entity
    for (const [entityId, traces] of traceLogsByEntityId) {
      const executionDetails: ExecutionDetailFeedItem[] = traces.map((trace) => ({
        _id: trace.id,
        // TODO: add providerId from traces
        providerId: undefined, // Will be overridden by step runs if available
        detail: trace.title,
        source: ExecutionDetailsSourceEnum.INTERNAL,
        _jobId: entityId,
        status: this.mapTraceStatusToExecutionStatus(trace.status),
        isTest: false,
        isRetry: false,
        createdAt: new Date(trace.created_at).toISOString(),
        raw: trace.raw_data,
      }));

      executionDetailsByEntityId.set(entityId, executionDetails);
    }

    return executionDetailsByEntityId;
  }

  private async processStepRunsForFeedItem(
    feedItem: NotificationFeedItemEntity,
    command: GetActivityCommand
  ): Promise<JobFeedItem[]> {
    const stepRunsQuery = new QueryBuilder<StepRun>({
      environmentId: command.environmentId,
    })
      .whereEquals('transaction_id', feedItem.transactionId)
      .build();

    const stepRunsResult = await this.stepRunRepository.find({
      where: stepRunsQuery,
      orderBy: 'created_at',
      orderDirection: 'ASC',
      useFinal: true,
      select: stepRunSelectColumns,
    });

    if (!stepRunsResult.data || stepRunsResult.data.length === 0) {
      return [];
    }

    const stepRunIds = stepRunsResult.data.map((stepRun) => stepRun.step_run_id);
    const executionDetailsByStepRunId = await this.getExecutionDetailsByEntityId(stepRunIds, command);

    return stepRunsResult.data.map((stepRun) => mapStepRunToJob(stepRun, executionDetailsByStepRunId));
  }

  private async getFeedItemFromStepRuns(command: GetActivityCommand): Promise<NotificationFeedItemEntity | null> {
    try {
      const feedItem = await this.notificationRepository.findNotificationMetadataOnly(
        command.notificationId,
        command.environmentId,
        command.organizationId
      );

      if (!feedItem) {
        return null;
      }

      // Process step runs and add them to the feed item
      feedItem.jobs = await this.processStepRunsForFeedItem(feedItem, command);

      return feedItem;
    } catch (error) {
      this.logger.error(
        {
          error: error instanceof Error ? error.message : 'Unknown error',
          notificationId: command.notificationId,
          environmentId: command.environmentId,
          organizationId: command.organizationId,
        },
        'Failed to get feed item from step runs'
      );

      // Fall back to the current stage 1 method (traces + jobs from MongoDB)
      return await this.getFeedItemFromTraceLog(command);
    }
  }

  private async getFeedItemFromWorkflowRuns(command: GetActivityCommand): Promise<NotificationFeedItemEntity | null> {
    try {
      const workflowRunQuery = new QueryBuilder<WorkflowRun>({
        environmentId: command.environmentId,
      })
        .whereEquals('workflow_run_id', command.notificationId)
        .build();

      const workflowRunsResult = await this.workflowRunRepository.find({
        where: workflowRunQuery,
        orderBy: 'created_at',
        orderDirection: 'ASC',
        limit: 1,
        useFinal: true,
        select: workflowRunSelectColumns,
      });

      if (!workflowRunsResult.data || workflowRunsResult.data.length === 0) {
        this.logger.warn(
          {
            notificationId: command.notificationId,
            environmentId: command.environmentId,
            organizationId: command.organizationId,
          },
          'No workflow run found in ClickHouse, falling back to step runs'
        );

        // Fall back to step runs method
        return await this.getFeedItemFromStepRuns(command);
      }

      const mostRecentWorkflowRun = workflowRunsResult.data[0];

      // Create the base feed item from workflow run data
      const feedItem: NotificationFeedItemEntity = {
        _id: mostRecentWorkflowRun.workflow_run_id,
        _organizationId: mostRecentWorkflowRun.organization_id,
        _environmentId: mostRecentWorkflowRun.environment_id,
        _templateId: mostRecentWorkflowRun.workflow_id,
        _subscriberId: mostRecentWorkflowRun.subscriber_id,
        transactionId: mostRecentWorkflowRun.transaction_id,
        template: {
          _id: mostRecentWorkflowRun.workflow_id,
          name: mostRecentWorkflowRun.workflow_name,
          triggers: [
            {
              identifier: mostRecentWorkflowRun.trigger_identifier,
              type: TriggerTypeEnum.EVENT,
              variables: [],
            },
          ],
        },
        subscriber: {
          _id: mostRecentWorkflowRun.subscriber_id,
          subscriberId: mostRecentWorkflowRun.external_subscriber_id || '',
          firstName: '',
          lastName: '',
          email: '',
          phone: undefined,
        },
        jobs: [],
        to: mostRecentWorkflowRun.subscriber_to ? JSON.parse(mostRecentWorkflowRun.subscriber_to) : {},
        payload: mostRecentWorkflowRun.payload ? JSON.parse(mostRecentWorkflowRun.payload) : {},
        contextKeys: mostRecentWorkflowRun.context_keys,
        createdAt: new Date(mostRecentWorkflowRun.created_at).toISOString(),
        updatedAt: new Date(mostRecentWorkflowRun.updated_at).toISOString(),
        channels: mostRecentWorkflowRun.channels ? JSON.parse(mostRecentWorkflowRun.channels) : [],
        topics: mostRecentWorkflowRun.topics ? JSON.parse(mostRecentWorkflowRun.topics) : [],
      };

      feedItem.jobs = await this.processStepRunsForFeedItem(feedItem, command);

      return feedItem;
    } catch (error) {
      this.logger.error(
        {
          error: error instanceof Error ? error.message : 'Unknown error',
          notificationId: command.notificationId,
          environmentId: command.environmentId,
          organizationId: command.organizationId,
        },
        'Failed to get feed item from workflow runs'
      );

      // Fall back to step runs method
      return await this.getFeedItemFromStepRuns(command);
    }
  }

  private async getFeedItemFromTraceLog(command: GetActivityCommand) {
    try {
      const feedItem = await this.notificationRepository.findMetadataForTraces(
        command.notificationId,
        command.environmentId,
        command.organizationId
      );

      if (!feedItem) {
        return null;
      }

      const jobIds = feedItem.jobs.map((job) => job._id);

      if (jobIds.length === 0) {
        return feedItem;
      }

      const executionDetailsByJobId = await this.getExecutionDetailsByEntityId(jobIds, command);

      feedItem.jobs = feedItem.jobs.map((job) => {
        const executionDetails = executionDetailsByJobId.get(job._id) || [];

        return {
          ...job,
          executionDetails,
        };
      });

      return feedItem;
    } catch (error) {
      this.logger.error(
        {
          error: error instanceof Error ? error.message : 'Unknown error',
          notificationId: command.notificationId,
          environmentId: command.environmentId,
          organizationId: command.organizationId,
        },
        'Failed to get feed item from trace log'
      );

      // Fall back to the old method if trace log query fails
      return await this.notificationRepository.getFeedItem(
        command.notificationId,
        command.environmentId,
        command.organizationId
      );
    }
  }
}

function mapStepRunToJob(
  stepRun: StepRunFetchResult,
  executionDetailsByStepRunId: Map<string, ExecutionDetailFeedItem[]>
): JobFeedItem {
  const baseExecutionDetails = executionDetailsByStepRunId.get(stepRun.step_run_id) || [];
  // Create execution details with provider ID from step run data
  const executionDetails: ExecutionDetailFeedItem[] = baseExecutionDetails.map((detail) => ({
    ...detail,
    providerId: stepRun.provider_id as ProvidersIdEnum,
  }));

  const stepRunDto: NotificationStepEntity = {
    _id: stepRun.step_id,
    _templateId: stepRun.step_id,
    active: true,
    filters: [],
  };

  const jobDto: JobFeedItem = {
    _id: stepRun.step_run_id,
    status: stepRun.status as JobStatusEnum,
    overrides: {}, // Step runs don't have overrides, use empty object
    payload: {}, // Step runs don't have payload, use empty object
    step: stepRunDto,
    type: stepRun.step_type as StepTypeEnum,
    providerId: stepRun.provider_id as ProvidersIdEnum,
    createdAt: new Date(stepRun.created_at).toISOString(),
    updatedAt: new Date(stepRun.updated_at).toISOString(),
    digest: undefined, // Step runs don't have digest info
    executionDetails,
    scheduleExtensionsCount: stepRun.schedule_extensions_count,
  };

  return jobDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - mapStepRunToJob(stepRun: StepRunFetchResult,
  executionDetailsByStepRunId: Map<string, ExecutionDetailFeedItem[]>)
Asignaciones con arrow functions encontradas (posibles funciones):
 - stepRunIds(stepRunsResult.data.map((stepRun))
 - executionDetailsByStepRunId(await this.getExecutionDetailsByEntityId(stepRunIds, command);

    return stepRunsResult.data.map((...)
 - jobIds(feedItem.jobs.map((job))
 - jobs(feedItem.jobs.map((job))
Declaraciones 'export' encontradas:
- export class GetActivity

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/ee.organization.controller.ts
Tamaño: 5452 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Body, ClassSerializerInterceptor, Controller, Get, Patch, Put, UseInterceptors } from '@nestjs/common';
import { ApiExcludeController, ApiOperation, ApiTags } from '@nestjs/swagger';
import { ExternalApiAccessible, RequirePermissions } from '@novu/application-generic';
import { PermissionsEnum, UserSessionData } from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { ApiCommonResponses, ApiResponse } from '../shared/framework/response.decorator';
import { UserSession } from '../shared/framework/user.decorator';
import { IGetMyOrganizationDto } from './dtos/get-my-organization.dto';
import { GetOrganizationSettingsDto } from './dtos/get-organization-settings.dto';
import { OrganizationBrandingResponseDto, OrganizationResponseDto } from './dtos/organization-response.dto';
import { RenameOrganizationDto } from './dtos/rename-organization.dto';
import { UpdateBrandingDetailsDto } from './dtos/update-branding-details.dto';
import { UpdateOrganizationSettingsDto } from './dtos/update-organization-settings.dto';
import { GetMyOrganizationCommand } from './usecases/get-my-organization/get-my-organization.command';
import { GetMyOrganization } from './usecases/get-my-organization/get-my-organization.usecase';
import { GetOrganizationSettingsCommand } from './usecases/get-organization-settings/get-organization-settings.command';
import { GetOrganizationSettings } from './usecases/get-organization-settings/get-organization-settings.usecase';
import { RenameOrganization } from './usecases/rename-organization/rename-organization.usecase';
import { RenameOrganizationCommand } from './usecases/rename-organization/rename-organization-command';
import { UpdateBrandingDetailsCommand } from './usecases/update-branding-details/update-branding-details.command';
import { UpdateBrandingDetails } from './usecases/update-branding-details/update-branding-details.usecase';
import { UpdateOrganizationSettingsCommand } from './usecases/update-organization-settings/update-organization-settings.command';
import { UpdateOrganizationSettings } from './usecases/update-organization-settings/update-organization-settings.usecase';

@Controller('/organizations')
@UseInterceptors(ClassSerializerInterceptor)
@RequireAuthentication()
@ApiTags('Organizations')
@ApiCommonResponses()
@ApiExcludeController()
export class EEOrganizationController {
  constructor(
    private updateBrandingDetailsUsecase: UpdateBrandingDetails,
    private getMyOrganizationUsecase: GetMyOrganization,
    private renameOrganizationUsecase: RenameOrganization,
    private getOrganizationSettingsUsecase: GetOrganizationSettings,
    private updateOrganizationSettingsUsecase: UpdateOrganizationSettings
  ) {}

  /**
   * @deprecated - used in v1 legacy web
   */
  @Get('/me')
  @ApiResponse(OrganizationResponseDto)
  @ApiOperation({
    summary: 'Fetch current organization details',
  })
  async getMyOrganization(@UserSession() user: UserSessionData): Promise<IGetMyOrganizationDto> {
    const command = GetMyOrganizationCommand.create({
      userId: user._id,
      id: user.organizationId,
    });

    return await this.getMyOrganizationUsecase.execute(command);
  }

  /**
   * @deprecated - used in v1 legacy web
   */
  @Put('/branding')
  @ApiResponse(OrganizationBrandingResponseDto)
  @ApiOperation({
    summary: 'Update organization branding details',
  })
  async updateBrandingDetails(@UserSession() user: UserSessionData, @Body() body: UpdateBrandingDetailsDto) {
    return await this.updateBrandingDetailsUsecase.execute(
      UpdateBrandingDetailsCommand.create({
        logo: body.logo,
        color: body.color,
        userId: user._id,
        id: user.organizationId,
        fontColor: body.fontColor,
        fontFamily: body.fontFamily,
        contentBackground: body.contentBackground,
      })
    );
  }

  /**
   * @deprecated - used in v1 legacy web
   */
  @Patch('/')
  @ApiResponse(RenameOrganizationDto)
  @ApiOperation({
    summary: 'Rename organization name',
  })
  async renameOrganization(@UserSession() user: UserSessionData, @Body() body: RenameOrganizationDto) {
    return await this.renameOrganizationUsecase.execute(
      RenameOrganizationCommand.create({
        name: body.name,
        userId: user._id,
        id: user.organizationId,
      })
    );
  }

  @Get('/settings')
  @ExternalApiAccessible()
  @ApiResponse(GetOrganizationSettingsDto)
  @ApiOperation({
    summary: 'Get organization settings',
  })
  @RequirePermissions(PermissionsEnum.ORG_SETTINGS_READ)
  async getSettings(@UserSession() user: UserSessionData) {
    return await this.getOrganizationSettingsUsecase.execute(
      GetOrganizationSettingsCommand.create({
        organizationId: user.organizationId,
      })
    );
  }

  @Patch('/settings')
  @ApiResponse(UpdateOrganizationSettingsDto)
  @ApiOperation({
    summary: 'Update organization settings',
  })
  @RequirePermissions(PermissionsEnum.ORG_SETTINGS_WRITE)
  async updateSettings(@UserSession() user: UserSessionData, @Body() body: UpdateOrganizationSettingsDto) {
    return await this.updateOrganizationSettingsUsecase.execute(
      UpdateOrganizationSettingsCommand.create({
        userId: user._id,
        organizationId: user.organizationId,
        removeNovuBranding: body.removeNovuBranding,
        defaultLocale: body.defaultLocale,
        targetLocales: body.targetLocales,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class EEOrganizationController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/organization.controller.ts
Tamaño: 7884 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  Body,
  ClassSerializerInterceptor,
  Controller,
  Delete,
  Get,
  Param,
  Patch,
  Post,
  Put,
  UseInterceptors,
} from '@nestjs/common';
import { ApiExcludeEndpoint, ApiOperation, ApiParam, ApiTags } from '@nestjs/swagger';
import { ApiExcludeController } from '@nestjs/swagger/dist/decorators/api-exclude-controller.decorator';
import { OrganizationEntity } from '@novu/dal';
import { MemberRoleEnum, UserSessionData } from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { ExternalApiAccessible } from '../auth/framework/external-api.decorator';
import { ApiCommonResponses, ApiResponse } from '../shared/framework/response.decorator';
import { UserSession } from '../shared/framework/user.decorator';
import { CreateOrganizationDto } from './dtos/create-organization.dto';
import { IGetMyOrganizationDto } from './dtos/get-my-organization.dto';
import { IGetOrganizationsDto } from './dtos/get-organizations.dto';
import { MemberResponseDto } from './dtos/member-response.dto';
import { OrganizationBrandingResponseDto, OrganizationResponseDto } from './dtos/organization-response.dto';
import { RenameOrganizationDto } from './dtos/rename-organization.dto';
import { UpdateBrandingDetailsDto } from './dtos/update-branding-details.dto';
import { UpdateMemberRolesDto } from './dtos/update-member-roles.dto';
import { CreateOrganizationCommand } from './usecases/create-organization/create-organization.command';
import { CreateOrganization } from './usecases/create-organization/create-organization.usecase';
import { GetMyOrganizationCommand } from './usecases/get-my-organization/get-my-organization.command';
import { GetMyOrganization } from './usecases/get-my-organization/get-my-organization.usecase';
import { GetOrganizationsCommand } from './usecases/get-organizations/get-organizations.command';
import { GetOrganizations } from './usecases/get-organizations/get-organizations.usecase';
import { ChangeMemberRoleCommand } from './usecases/membership/change-member-role/change-member-role.command';
import { ChangeMemberRole } from './usecases/membership/change-member-role/change-member-role.usecase';
import { GetMembersCommand } from './usecases/membership/get-members/get-members.command';
import { GetMembers } from './usecases/membership/get-members/get-members.usecase';
import { RemoveMemberCommand } from './usecases/membership/remove-member/remove-member.command';
import { RemoveMember } from './usecases/membership/remove-member/remove-member.usecase';
import { RenameOrganization } from './usecases/rename-organization/rename-organization.usecase';
import { RenameOrganizationCommand } from './usecases/rename-organization/rename-organization-command';
import { UpdateBrandingDetailsCommand } from './usecases/update-branding-details/update-branding-details.command';
import { UpdateBrandingDetails } from './usecases/update-branding-details/update-branding-details.usecase';

@Controller('/organizations')
@UseInterceptors(ClassSerializerInterceptor)
@RequireAuthentication()
@ApiTags('Organizations')
@ApiCommonResponses()
@ApiExcludeController()
export class OrganizationController {
  constructor(
    private createOrganizationUsecase: CreateOrganization,
    private getMembers: GetMembers,
    private removeMemberUsecase: RemoveMember,
    private changeMemberRoleUsecase: ChangeMemberRole,
    private updateBrandingDetailsUsecase: UpdateBrandingDetails,
    private getOrganizationsUsecase: GetOrganizations,
    private getMyOrganizationUsecase: GetMyOrganization,
    private renameOrganizationUsecase: RenameOrganization
  ) {}

  @Post('/')
  @ExternalApiAccessible()
  @ApiResponse(OrganizationResponseDto, 201)
  @ApiOperation({
    summary: 'Create an organization',
  })
  async createOrganization(
    @UserSession() user: UserSessionData,
    @Body() body: CreateOrganizationDto
  ): Promise<OrganizationEntity> {
    return await this.createOrganizationUsecase.execute(
      CreateOrganizationCommand.create({
        userId: user._id,
        logo: body.logo,
        name: body.name,
        jobTitle: body.jobTitle,
        domain: body.domain,
        language: body.language,
      })
    );
  }

  @Get('/')
  @ExternalApiAccessible()
  @ApiResponse(OrganizationResponseDto, 200, true)
  @ApiOperation({
    summary: 'Fetch all organizations',
  })
  async listOrganizations(@UserSession() user: UserSessionData): Promise<IGetOrganizationsDto> {
    const command = GetOrganizationsCommand.create({
      userId: user._id,
    });

    return await this.getOrganizationsUsecase.execute(command);
  }

  @Get('/me')
  @ExternalApiAccessible()
  @ApiResponse(OrganizationResponseDto)
  @ApiOperation({
    summary: 'Fetch current organization details',
  })
  async getSelfOrganizationData(@UserSession() user: UserSessionData): Promise<IGetMyOrganizationDto> {
    const command = GetMyOrganizationCommand.create({
      userId: user._id,
      id: user.organizationId,
    });

    return await this.getMyOrganizationUsecase.execute(command);
  }
  @Delete('/members/:memberId')
  @ExternalApiAccessible()
  @ApiResponse(MemberResponseDto)
  @ApiOperation({
    summary: 'Remove a member from organization using memberId',
  })
  @ApiParam({ name: 'memberId', type: String, required: true })
  async remove(@UserSession() user: UserSessionData, @Param('memberId') memberId: string) {
    return await this.removeMemberUsecase.execute(
      RemoveMemberCommand.create({
        userId: user._id,
        organizationId: user.organizationId,
        memberId,
      })
    );
  }
  @Put('/members/:memberId/roles')
  @ExternalApiAccessible()
  @ApiExcludeEndpoint()
  @ApiResponse(MemberResponseDto)
  @ApiOperation({
    summary: 'Update a member role to admin',
  })
  @ApiParam({ name: 'memberId', type: String, required: true })
  async updateMemberRoles(
    @UserSession() user: UserSessionData,
    @Param('memberId') memberId: string,
    @Body() body: UpdateMemberRolesDto
  ) {
    if (body.role !== MemberRoleEnum.OSS_ADMIN) {
      throw new Error('Only admin role can be assigned to a member');
    }

    return await this.changeMemberRoleUsecase.execute(
      ChangeMemberRoleCommand.create({
        memberId,
        role: MemberRoleEnum.OSS_ADMIN,
        userId: user._id,
        organizationId: user.organizationId,
      })
    );
  }

  @Get('/members')
  @ExternalApiAccessible()
  @ApiResponse(MemberResponseDto, 200, true)
  @ApiOperation({
    summary: 'Fetch all members of current organizations',
  })
  async listOrganizationMembers(@UserSession() user: UserSessionData) {
    return await this.getMembers.execute(
      GetMembersCommand.create({
        user,
        userId: user._id,
        organizationId: user.organizationId,
      })
    );
  }

  @Put('/branding')
  @ExternalApiAccessible()
  @ApiResponse(OrganizationBrandingResponseDto)
  @ApiOperation({
    summary: 'Update organization branding details',
  })
  async updateBrandingDetails(@UserSession() user: UserSessionData, @Body() body: UpdateBrandingDetailsDto) {
    return await this.updateBrandingDetailsUsecase.execute(
      UpdateBrandingDetailsCommand.create({
        logo: body.logo,
        color: body.color,
        userId: user._id,
        id: user.organizationId,
        fontColor: body.fontColor,
        fontFamily: body.fontFamily,
        contentBackground: body.contentBackground,
      })
    );
  }

  @Patch('/')
  @ExternalApiAccessible()
  @ApiResponse(RenameOrganizationDto)
  @ApiOperation({
    summary: 'Rename organization name',
  })
  async rename(@UserSession() user: UserSessionData, @Body() body: RenameOrganizationDto) {
    return await this.renameOrganizationUsecase.execute(
      RenameOrganizationCommand.create({
        name: body.name,
        userId: user._id,
        id: user.organizationId,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class OrganizationController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/organization.module.ts
Tamaño: 2103 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  DynamicModule,
  ForwardReference,
  forwardRef,
  MiddlewareConsumer,
  Module,
  NestModule,
  RequestMethod,
} from '@nestjs/common';
import { Type } from '@nestjs/common/interfaces/type.interface';
import { AuthGuard } from '@nestjs/passport';
import { isClerkEnabled } from '@novu/shared';
import { AuthModule } from '../auth/auth.module';
import { EnvironmentsModuleV1 } from '../environments-v1/environments-v1.module';
import { IntegrationModule } from '../integrations/integrations.module';
import { LayoutsV2Module } from '../layouts-v2/layouts.module';
import { SharedModule } from '../shared/shared.module';
import { UserModule } from '../user/user.module';
import { EEOrganizationController } from './ee.organization.controller';
import { OrganizationController } from './organization.controller';
import { USE_CASES } from './usecases';

const enterpriseImports = (): Array<Type | DynamicModule | Promise<DynamicModule> | ForwardReference> => {
  const modules: Array<Type | DynamicModule | Promise<DynamicModule> | ForwardReference> = [];
  if (process.env.NOVU_ENTERPRISE === 'true' || process.env.CI_EE_TEST === 'true') {
    if (require('@novu/ee-billing')?.BillingModule) {
      modules.push(require('@novu/ee-billing')?.BillingModule.forRoot());
    }
  }

  return modules;
};

function getControllers() {
  if (isClerkEnabled()) {
    return [EEOrganizationController];
  }

  return [OrganizationController];
}

@Module({
  imports: [
    SharedModule,
    UserModule,
    EnvironmentsModuleV1,
    IntegrationModule,
    forwardRef(() => AuthModule),
    LayoutsV2Module,
    ...enterpriseImports(),
  ],
  controllers: [...getControllers()],
  providers: [...USE_CASES],
  exports: [...USE_CASES],
})
export class OrganizationModule implements NestModule {
  configure(consumer: MiddlewareConsumer): MiddlewareConsumer | void {
    if (process.env.NOVU_ENTERPRISE !== 'true' && process.env.CI_EE_TEST !== 'true') {
      consumer.apply(AuthGuard).exclude({
        method: RequestMethod.GET,
        path: '/organizations/invite/:inviteToken',
      });
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getControllers()
Asignaciones con arrow functions encontradas (posibles funciones):
 - enterpriseImports(): Array<Type | DynamicModule | Promise<DynamicModule> | ForwardReference>)
Declaraciones 'export' encontradas:
- export class OrganizationModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/dtos/create-organization.dto.ts
Tamaño: 486 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ICreateOrganizationDto, JobTitleEnum, ProductUseCases } from '@novu/shared';
import { IsDefined, IsEnum, IsOptional, IsString } from 'class-validator';

export class CreateOrganizationDto implements ICreateOrganizationDto {
  @IsString()
  @IsDefined()
  name: string;

  @IsString()
  @IsOptional()
  logo?: string;

  @IsOptional()
  @IsEnum(JobTitleEnum)
  jobTitle?: JobTitleEnum;

  @IsString()
  @IsOptional()
  domain?: string;

  @IsOptional()
  language?: string[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateOrganizationDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/dtos/get-my-organization.dto.ts
Tamaño: 105 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { OrganizationEntity } from '@novu/dal';

export type IGetMyOrganizationDto = OrganizationEntity;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/dtos/get-organization-settings.dto.ts
Tamaño: 704 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IsValidLocale } from '@novu/application-generic';
import { OrganizationEntity } from '@novu/dal';
import { IsArray, IsBoolean, IsOptional, IsString } from 'class-validator';

export class GetOrganizationSettingsDto {
  @ApiProperty({
    description: 'Remove Novu branding',
    example: false,
  })
  @IsBoolean()
  removeNovuBranding: boolean;

  @ApiProperty({
    description: 'Default locale',
    example: 'en_US',
  })
  @IsValidLocale()
  defaultLocale: string;

  @ApiProperty({
    description: 'Target locales',
    example: ['en_US', 'es_ES'],
  })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  targetLocales?: string[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetOrganizationSettingsDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/dtos/get-organizations.dto.ts
Tamaño: 106 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { OrganizationEntity } from '@novu/dal';

export type IGetOrganizationsDto = OrganizationEntity[];


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/dtos/member-response.dto.ts
Tamaño: 1288 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { MemberRoleEnum, MemberStatusEnum } from '@novu/shared';
import { IsDate, IsEnum, IsObject, IsString } from 'class-validator';

export class MemberUserDto {
  @ApiProperty()
  @IsString()
  _id: string;

  @ApiProperty()
  @IsString()
  firstName: string;

  @ApiProperty()
  @IsString()
  lastName: string;

  @ApiProperty()
  @IsString()
  email: string;
}

export class MemberInviteDTO {
  @ApiProperty()
  @IsString()
  email: string;

  @ApiProperty()
  @IsString()
  token: string;

  @ApiProperty()
  @IsDate()
  invitationDate: Date;

  @ApiPropertyOptional()
  @IsDate()
  answerDate?: Date;

  @ApiProperty()
  @IsString()
  _inviterId: string;
}

export class MemberResponseDto {
  @ApiProperty()
  @IsString()
  _id: string;

  @ApiProperty()
  @IsString()
  _userId: string;

  @ApiPropertyOptional()
  @IsObject()
  user?: MemberUserDto;

  @ApiPropertyOptional({ enum: MemberRoleEnum })
  @IsEnum(MemberRoleEnum)
  roles?: MemberRoleEnum;

  @ApiPropertyOptional()
  @IsObject()
  invite?: MemberInviteDTO;

  @ApiPropertyOptional({
    enum: { ...MemberStatusEnum },
  })
  @IsEnum(MemberStatusEnum)
  memberStatus?: MemberStatusEnum;

  @ApiProperty()
  @IsString()
  _organizationId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class MemberUserDto
- export class MemberInviteDTO
- export class MemberResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/dtos/organization-response.dto.ts
Tamaño: 1239 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { DirectionEnum, PartnerTypeEnum } from '@novu/dal';
import { IsArray, IsEnum, IsObject, IsString } from 'class-validator';
import { UpdateBrandingDetailsDto } from './update-branding-details.dto';

export class IPartnerConfigurationResponseDto {
  @ApiPropertyOptional()
  @IsArray()
  @IsString({ each: true })
  projectIds?: string[];

  @ApiProperty()
  @IsString()
  accessToken: string;

  @ApiProperty()
  @IsString()
  configurationId: string;

  @ApiPropertyOptional()
  @IsString()
  teamId: string;

  @ApiProperty({
    enum: PartnerTypeEnum,
    description: 'Partner Type Enum',
  })
  @IsEnum(PartnerTypeEnum)
  partnerType: PartnerTypeEnum;
}

export class OrganizationBrandingResponseDto extends UpdateBrandingDetailsDto {
  @ApiPropertyOptional({
    enum: DirectionEnum,
  })
  @IsString()
  direction?: DirectionEnum;
}

export class OrganizationResponseDto {
  @ApiProperty()
  @IsString()
  name: string;

  @ApiPropertyOptional()
  @IsString()
  logo?: string;

  @ApiProperty()
  @IsObject()
  branding: OrganizationBrandingResponseDto;

  @ApiPropertyOptional()
  @IsObject()
  partnerConfigurations: IPartnerConfigurationResponseDto[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class IPartnerConfigurationResponseDto
- export class OrganizationBrandingResponseDto
- export class OrganizationResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/dtos/rename-organization.dto.ts
Tamaño: 140 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsString } from 'class-validator';

export class RenameOrganizationDto {
  @IsString()
  @IsDefined()
  name: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RenameOrganizationDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/dtos/update-branding-details.dto.ts
Tamaño: 801 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsHexColor, IsOptional, IsString, IsUrl } from 'class-validator';
import { IsImageUrl } from '../../shared/validators/image.validator';

const environments = ['production', 'test'];
const protocols = environments.includes(process.env.NODE_ENV || '') ? ['https'] : ['http', 'https'];

export class UpdateBrandingDetailsDto {
  @IsUrl({
    require_protocol: true,
    protocols,
    require_tld: false,
  })
  @IsImageUrl({
    message: 'Logo must be a valid image URL with one of the following extensions: jpg, jpeg, png, gif, svg',
  })
  @IsOptional()
  logo: string;

  @IsOptional()
  @IsHexColor()
  color: string;

  @IsOptional()
  @IsHexColor()
  fontColor: string;

  @IsOptional()
  @IsHexColor()
  contentBackground: string;

  @IsOptional()
  @IsString()
  fontFamily?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateBrandingDetailsDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/dtos/update-member-roles.dto.ts
Tamaño: 188 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { MemberRoleEnum } from '@novu/shared';
import { IsEnum } from 'class-validator';

export class UpdateMemberRolesDto {
  @IsEnum(MemberRoleEnum)
  role: MemberRoleEnum.OSS_ADMIN;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateMemberRolesDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/dtos/update-organization-settings.dto.ts
Tamaño: 729 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { IsValidLocale } from '@novu/application-generic';
import { IsArray, IsBoolean, IsOptional, IsString } from 'class-validator';

export class UpdateOrganizationSettingsDto {
  @ApiProperty({
    description: 'Enable or disable Novu branding',
    example: true,
  })
  @IsOptional()
  @IsBoolean()
  removeNovuBranding?: boolean;

  @ApiProperty({
    description: 'Default locale',
    example: 'en_US',
  })
  @IsOptional()
  @IsValidLocale()
  defaultLocale?: string;

  @ApiProperty({
    description: 'Target locales',
    example: ['en_US', 'es_ES'],
  })
  @IsOptional()
  @IsArray()
  @IsString({ each: true }) // TODO: validate locales
  targetLocales?: string[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateOrganizationSettingsDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/e2e/change-member-role.e2e.ts
Tamaño: 2204 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CommunityMemberRepository } from '@novu/dal';
import { MemberRoleEnum, MemberStatusEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { describe } from 'mocha';

describe('Change member role - /organizations/members/:memberId/role (PUT) #novu-v0-os', async () => {
  const memberRepository = new CommunityMemberRepository();
  let session: UserSession;
  let user2: UserSession;
  let user3: UserSession;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();

    user2 = new UserSession();
    await user2.initialize({
      noOrganization: true,
    });

    user3 = new UserSession();
    await user3.initialize({
      noOrganization: true,
    });
  });

  // Currently skipped until we implement role management
  it.skip('should update admin to member', async () => {
    await memberRepository.addMember(session.organization._id, {
      _userId: user2.user._id,
      invite: null,
      roles: [MemberRoleEnum.OSS_ADMIN],
      memberStatus: MemberStatusEnum.ACTIVE,
    });

    const member = await memberRepository.findMemberByUserId(session.organization._id, user2.user._id);
    const { body } = await session.testAgent.put(`/v1/organizations/members/${member._id}/roles`).send({
      role: MemberRoleEnum.OSS_MEMBER,
    });

    expect(body.data.roles.length).to.equal(1);
    expect(body.data.roles[0]).to.equal(MemberRoleEnum.OSS_MEMBER);
  });

  it('should update member to admin', async () => {
    await memberRepository.addMember(session.organization._id, {
      _userId: user3.user._id,
      invite: null,
      roles: [MemberRoleEnum.OSS_MEMBER],
      memberStatus: MemberStatusEnum.ACTIVE,
    });

    const member = await memberRepository.findMemberByUserId(session.organization._id, user3.user._id);

    const { body } = await session.testAgent.put(`/v1/organizations/members/${member._id}/roles`).send({
      role: MemberRoleEnum.OSS_ADMIN,
    });

    expect(body.data.roles.length).to.equal(1);
    expect(body.data.roles.includes(MemberRoleEnum.OSS_ADMIN)).to.be.ok;
    expect(body.data.roles.includes(MemberRoleEnum.OSS_MEMBER)).not.to.be.ok;
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - memberRepository(new CommunityMemberRepository();
  let session: UserSession;
  let user2: UserSession;
  let user3: ...)
 - user3(new UserSession();
    await user3.initialize({
      noOrganization: true,
    });
  });

  // Curr...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/e2e/create-organization.e2e.ts
Tamaño: 9492 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  CommunityMemberRepository,
  CommunityOrganizationRepository,
  CommunityUserRepository,
  EnvironmentRepository,
  IntegrationRepository,
} from '@novu/dal';
import {
  ApiServiceLevelEnum,
  ChannelTypeEnum,
  ChatProviderIdEnum,
  EmailProviderIdEnum,
  ICreateOrganizationDto,
  InAppProviderIdEnum,
  JobTitleEnum,
  MemberRoleEnum,
  SmsProviderIdEnum,
} from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Create Organization - /organizations (POST) #novu-v0-os', async () => {
  let session: UserSession;
  const organizationRepository = new CommunityOrganizationRepository();
  const userRepository = new CommunityUserRepository();
  const memberRepository = new CommunityMemberRepository();
  const integrationRepository = new IntegrationRepository();
  const environmentRepository = new EnvironmentRepository();

  before(async () => {
    session = new UserSession();
    await session.initialize({
      noOrganization: true,
    });
  });

  describe('Valid Creation', () => {
    it('should add the user as admin', async () => {
      const { body } = await session.testAgent
        .post('/v1/organizations')
        .send({
          name: 'Test Org 2',
        })
        .expect(201);
      const dbOrganization = await organizationRepository.findById(body.data._id);

      const members = await memberRepository.getOrganizationMembers(dbOrganization?._id as string);

      expect(members.length).to.eq(1);
      expect(members[0]._userId).to.eq(session.user._id);
      expect(members[0].roles[0]).to.eq(MemberRoleEnum.OSS_ADMIN);
    });

    it('should create organization with correct name', async () => {
      const demoOrganization = {
        name: 'Hello Org',
      };
      const { body } = await session.testAgent.post('/v1/organizations').send(demoOrganization).expect(201);

      expect(body.data.name).to.eq(demoOrganization.name);
    });

    it('should not create organization with no name', async () => {
      await session.testAgent.post('/v1/organizations').send({}).expect(400);
    });

    it('should create organization with apiServiceLevel of free by default', async () => {
      const testOrganization = {
        name: 'Free Org',
      };

      const { body } = await session.testAgent.post('/v1/organizations').send(testOrganization).expect(201);
      const dbOrganization = await organizationRepository.findById(body.data._id);

      expect(dbOrganization?.apiServiceLevel).to.eq(ApiServiceLevelEnum.FREE);
    });

    it('should create organization with questionnaire data', async () => {
      const testOrganization: ICreateOrganizationDto = {
        name: 'Org Name',
        domain: 'org.com',
      };

      const { body } = await session.testAgent.post('/v1/organizations').send(testOrganization).expect(201);
      const dbOrganization = await organizationRepository.findById(body.data._id);

      expect(dbOrganization?.name).to.eq(testOrganization.name);
      expect(dbOrganization?.domain).to.eq(testOrganization.domain);
    });

    it('should update user job title on organization creation', async () => {
      const testOrganization: ICreateOrganizationDto = {
        name: 'Org Name',
        jobTitle: JobTitleEnum.PRODUCT_MANAGER,
      };

      await session.testAgent.post('/v1/organizations').send(testOrganization).expect(201);
      const user = await userRepository.findById(session.user._id);

      expect(user?.jobTitle).to.eq(testOrganization.jobTitle);
    });

    it('should create organization with built in Novu integrations and set them as primary', async () => {
      const testOrganization: ICreateOrganizationDto = {
        name: 'Org Name',
      };

      const { body } = await session.testAgent.post('/v1/organizations').send(testOrganization).expect(201);
      const integrations = await integrationRepository.find({ _organizationId: body.data._id });
      const environments = await environmentRepository.find({ _organizationId: body.data._id });
      const productionEnv = environments.find((e) => e.name === 'Production');
      const developmentEnv = environments.find((e) => e.name === 'Development');
      const novuEmailIntegration = integrations.filter(
        (i) => i.active && i.channel === ChannelTypeEnum.EMAIL && i.providerId === EmailProviderIdEnum.Novu
      );
      const novuSmsIntegration = integrations.filter(
        (i) => i.active && i.channel === ChannelTypeEnum.SMS && i.providerId === SmsProviderIdEnum.Novu
      );
      const novuChatIntegration = integrations.filter(
        (i) => i.active && i.channel === ChannelTypeEnum.CHAT && i.providerId === ChatProviderIdEnum.Novu
      );
      const novuInAppIntegration = integrations.filter(
        (i) => i.active && i.channel === ChannelTypeEnum.IN_APP && i.providerId === InAppProviderIdEnum.Novu
      );
      const novuEmailIntegrationProduction = novuEmailIntegration.filter(
        (el) => el._environmentId === productionEnv?._id
      );
      const novuEmailIntegrationDevelopment = novuEmailIntegration.filter(
        (el) => el._environmentId === developmentEnv?._id
      );
      const novuSmsIntegrationProduction = novuSmsIntegration.filter((el) => el._environmentId === productionEnv?._id);
      const novuSmsIntegrationDevelopment = novuSmsIntegration.filter(
        (el) => el._environmentId === developmentEnv?._id
      );
      const novuInAppIntegrationProduction = novuInAppIntegration.filter(
        (el) => el._environmentId === productionEnv?._id
      );
      const novuInAppIntegrationDevelopment = novuInAppIntegration.filter(
        (el) => el._environmentId === developmentEnv?._id
      );

      expect(integrations.length).to.eq(6);
      expect(novuEmailIntegration?.length).to.eq(2);
      expect(novuSmsIntegration?.length).to.eq(2);
      expect(novuChatIntegration?.length).to.eq(1);
      expect(novuInAppIntegration?.length).to.eq(2);

      expect(novuEmailIntegrationProduction.length).to.eq(1);
      expect(novuSmsIntegrationProduction.length).to.eq(1);
      expect(novuInAppIntegrationProduction.length).to.eq(1);
      expect(novuEmailIntegrationDevelopment.length).to.eq(1);
      expect(novuSmsIntegrationDevelopment.length).to.eq(1);
      expect(novuInAppIntegrationDevelopment.length).to.eq(1);

      expect(novuEmailIntegrationProduction[0].primary).to.eq(true);
      expect(novuSmsIntegrationProduction[0].primary).to.eq(true);
      expect(novuEmailIntegrationDevelopment[0].primary).to.eq(true);
      expect(novuSmsIntegrationDevelopment[0].primary).to.eq(true);
    });

    it('when Novu Email credentials are not set it should not create Novu Email integration', async () => {
      const oldNovuEmailIntegrationApiKey = process.env.NOVU_EMAIL_INTEGRATION_API_KEY;
      process.env.NOVU_EMAIL_INTEGRATION_API_KEY = '';
      const testOrganization: ICreateOrganizationDto = {
        name: 'Org Name',
      };

      const { body } = await session.testAgent.post('/v1/organizations').send(testOrganization).expect(201);
      const integrations = await integrationRepository.find({ _organizationId: body.data._id });
      const environments = await environmentRepository.find({ _organizationId: body.data._id });
      const productionEnv = environments.find((e) => e.name === 'Production');
      const developmentEnv = environments.find((e) => e.name === 'Development');
      const novuSmsIntegration = integrations.filter(
        (i) => i.active && i.name === 'Novu SMS' && i.providerId === SmsProviderIdEnum.Novu
      );

      expect(integrations.length).to.eq(4);
      expect(novuSmsIntegration?.length).to.eq(2);
      expect(novuSmsIntegration.filter((el) => el._environmentId === productionEnv?._id).length).to.eq(1);
      expect(novuSmsIntegration.filter((el) => el._environmentId === developmentEnv?._id).length).to.eq(1);
      process.env.NOVU_EMAIL_INTEGRATION_API_KEY = oldNovuEmailIntegrationApiKey;
    });

    it('when Novu SMS credentials are not set it should not create Novu SMS integration', async () => {
      const oldNovuSmsIntegrationAccountSid = process.env.NOVU_SMS_INTEGRATION_ACCOUNT_SID;
      process.env.NOVU_SMS_INTEGRATION_ACCOUNT_SID = '';
      const testOrganization: ICreateOrganizationDto = {
        name: 'Org Name',
      };

      const { body } = await session.testAgent.post('/v1/organizations').send(testOrganization).expect(201);
      const integrations = await integrationRepository.find({ _organizationId: body.data._id });
      const environments = await environmentRepository.find({ _organizationId: body.data._id });
      const productionEnv = environments.find((e) => e.name === 'Production');
      const developmentEnv = environments.find((e) => e.name === 'Development');
      const novuEmailIntegrations = integrations.filter(
        (i) => i.active && i.name === 'Novu Email' && i.providerId === EmailProviderIdEnum.Novu
      );

      expect(integrations.length).to.eq(4);
      expect(novuEmailIntegrations?.length).to.eq(2);
      expect(novuEmailIntegrations.filter((el) => el._environmentId === productionEnv?._id).length).to.eq(1);
      expect(novuEmailIntegrations.filter((el) => el._environmentId === developmentEnv?._id).length).to.eq(1);
      process.env.NOVU_SMS_INTEGRATION_ACCOUNT_SID = oldNovuSmsIntegrationAccountSid;
    });

    it('when Novu Chat credentials are not set it should not create Novu Chat integration', async () => {
      // todo
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - environmentRepository(new EnvironmentRepository();

  before(async ())
 - session(new UserSession();
    await session.initialize({
      noOrganization: true,
    });
  });

  descr...)
 - members(await memberRepository.getOrganizationMembers(dbOrganization?._id as string);

      expect(members....)
 - dbOrganization(await organizationRepository.findById(body.data._id);

      expect(dbOrganization?.apiServiceLevel)...)
 - dbOrganization(await organizationRepository.findById(body.data._id);

      expect(dbOrganization?.name).to.eq(test...)
 - user(await userRepository.findById(session.user._id);

      expect(user?.jobTitle).to.eq(testOrganizatio...)
 - productionEnv(environments.find((e))
 - developmentEnv(environments.find((e))
 - novuEmailIntegration(integrations.filter(
        (i))
 - novuSmsIntegration(integrations.filter(
        (i))
 - novuChatIntegration(integrations.filter(
        (i))
 - novuInAppIntegration(integrations.filter(
        (i))
 - novuEmailIntegrationProduction(novuEmailIntegration.filter(
        (el))
 - novuEmailIntegrationDevelopment(novuEmailIntegration.filter(
        (el))
 - novuSmsIntegrationProduction(novuSmsIntegration.filter((el))
 - novuSmsIntegrationDevelopment(novuSmsIntegration.filter(
        (el))
 - novuInAppIntegrationProduction(novuInAppIntegration.filter(
        (el))
 - novuInAppIntegrationDevelopment(novuInAppIntegration.filter(
        (el))
 - productionEnv(environments.find((e))
 - developmentEnv(environments.find((e))
 - novuSmsIntegration(integrations.filter(
        (i))
 - NOVU_EMAIL_INTEGRATION_API_KEY(oldNovuEmailIntegrationApiKey;
    });

    it('when Novu SMS credentials are not set it should not ...)
 - productionEnv(environments.find((e))
 - developmentEnv(environments.find((e))
 - novuEmailIntegrations(integrations.filter(
        (i))
 - NOVU_SMS_INTEGRATION_ACCOUNT_SID(oldNovuSmsIntegrationAccountSid;
    });

    it('when Novu Chat credentials are not set it should n...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/e2e/get-members.e2e.ts
Tamaño: 1472 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CommunityMemberRepository } from '@novu/dal';
import { MemberRoleEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Get members - /organization/members (GET) #novu-v0-os', async () => {
  let session: UserSession;
  let otherSession: UserSession;

  const memberRepository = new CommunityMemberRepository();

  before(async () => {
    session = new UserSession();
    await session.initialize();

    otherSession = new UserSession();
    await otherSession.initialize({
      noOrganization: true,
    });

    await session.testAgent
      .post('/v1/invites/bulk')
      .send({
        invitees: [
          {
            email: 'dddd@asdas.com',
            role: MemberRoleEnum.OSS_ADMIN,
          },
        ],
      })
      .expect(201);

    const members = await memberRepository.getOrganizationMembers(session.organization._id);
    const invitee = members.find((i) => !i._userId);

    await otherSession.testAgent.post(`/v1/invites/${invitee.invite.token}/accept`).expect(201);

    otherSession.organization = session.organization;
    await otherSession.fetchJWT();
  });

  it('should see emails of all members as admin', async () => {
    const { body } = await session.testAgent.get('/v1/organizations/members').expect(200);

    expect(JSON.stringify(body.data)).to.include('dddd@asdas.com');
    expect(JSON.stringify(body.data)).to.include(session.user.firstName);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - memberRepository(new CommunityMemberRepository();

  before(async ())
 - invitee(members.find((i))
 - organization(session.organization;
    await otherSession.fetchJWT();
  });

  it('should see emails of all membe...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/e2e/get-my-organization.e2e.ts
Tamaño: 563 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Get my organization - /organizations/me (GET) #novu-v0-os', async () => {
  let session: UserSession;

  before(async () => {
    session = new UserSession();
    await session.initialize();
  });

  describe('Get organization profile', () => {
    it('should return the correct organization', async () => {
      const { body } = await session.testAgent.get('/v1/organizations/me').expect(200);

      expect(body.data._id).to.eq(session.organization._id);
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
    await session.initialize();
  });

  describe('Get organization profile', ())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/e2e/get-organizations.e2e.ts
Tamaño: 1767 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CommunityMemberRepository, OrganizationEntity } from '@novu/dal';
import { MemberRoleEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Get organizations - /organizations (GET) #novu-v0-os', async () => {
  let session: UserSession;
  let otherSession: UserSession;
  let thirdSession: UserSession;

  let thirdOldOrganization: OrganizationEntity;

  const memberRepository = new CommunityMemberRepository();

  before(async () => {
    session = new UserSession();
    await session.initialize();

    otherSession = new UserSession();
    await otherSession.initialize();

    thirdSession = new UserSession();
    await thirdSession.initialize();

    await session.testAgent
      .post('/v1/invites/bulk')
      .send({
        invitees: [
          {
            email: 'dddd@asdas.com',
            role: MemberRoleEnum.OSS_MEMBER,
          },
        ],
      })
      .expect(201);

    const members = await memberRepository.getOrganizationMembers(session.organization._id);
    const invitee = members.find((i) => !i._userId);

    thirdOldOrganization = thirdSession.organization;

    await thirdSession.testAgent.post(`/v1/invites/${invitee.invite.token}/accept`).expect(201);
  });

  it('should see all organizations that you are a part of', async () => {
    const { body } = await thirdSession.testAgent.get('/v1/organizations').expect(200);

    expect(JSON.stringify(body.data)).to.include(session.organization.name);
    expect(JSON.stringify(body.data)).to.include(thirdSession.organization.name);
    expect(JSON.stringify(body.data)).to.include(thirdOldOrganization.name);
    expect(JSON.stringify(body.data)).to.not.include(otherSession.organization.name);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - memberRepository(new CommunityMemberRepository();

  before(async ())
 - invitee(members.find((i))
 - thirdOldOrganization(thirdSession.organization;

    await thirdSession.testAgent.post(`/v1/invites/${invitee.invite.toke...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/e2e/remove-member.e2e.ts
Tamaño: 3349 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CommunityMemberRepository, EnvironmentRepository, MemberEntity } from '@novu/dal';
import { MemberRoleEnum, MemberStatusEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { describe } from 'mocha';

describe('Remove organization member - /organizations/members/:memberId (DELETE) #novu-v0-os', async () => {
  let session: UserSession;
  const memberRepository = new CommunityMemberRepository();
  const environmentRepository = new EnvironmentRepository();
  let user2: UserSession;
  let user3: UserSession;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();

    user2 = new UserSession();
    await user2.initialize({
      noOrganization: true,
    });

    user3 = new UserSession();
    await user3.initialize({
      noOrganization: true,
    });

    await memberRepository.addMember(session.organization._id, {
      _userId: user2.user._id,
      invite: null,
      roles: [MemberRoleEnum.OSS_ADMIN],
      memberStatus: MemberStatusEnum.ACTIVE,
    });

    await memberRepository.addMember(session.organization._id, {
      _userId: user3.user._id,
      invite: null,
      roles: [MemberRoleEnum.OSS_ADMIN],
      memberStatus: MemberStatusEnum.ACTIVE,
    });

    user2.organization = session.organization;
    user3.organization = session.organization;
  });

  it('should switch the apiKey association when api key creator removed', async () => {
    const members: MemberEntity[] = await getOrganizationMembers();
    const originalCreator = members.find((i) => i._userId === session.user._id);
    await user2.fetchJWT();

    expect(session.environment.apiKeys[0]._userId).to.equal(session.user._id);
    const { body } = await user2.testAgent.delete(`/v1/organizations/members/${originalCreator._id}`);
    expect(body.data._id).to.equal(originalCreator._id);

    const membersAfterRemoval: MemberEntity[] = await getOrganizationMembers(user2);
    const originalCreatorAfterRemoval = membersAfterRemoval.find((i) => i._userId === originalCreator.user._id);
    expect(originalCreatorAfterRemoval).to.not.be.ok;

    const environment = await environmentRepository.findOne({ _id: session.environment._id });
    expect(environment.apiKeys[0]._userId).to.not.equal(session.user._id);
  });

  it('should remove the member by his id', async () => {
    const members: MemberEntity[] = await getOrganizationMembers();
    const user2Member = members.find((i) => i._userId === user2.user._id);

    const { body } = await session.testAgent.delete(`/v1/organizations/members/${user2Member._id}`).expect(200);

    expect(body.data._id).to.equal(user2Member._id);

    const membersAfterRemoval: MemberEntity[] = await getOrganizationMembers();
    const user2Removed = membersAfterRemoval.find((i) => i._userId === user2.user._id);

    expect(user2Removed).to.not.be.ok;

    /**
     * The API Key owner should not be updated if non creator was removed
     */
    const environment = await environmentRepository.findOne({ _id: session.environment._id });
    expect(environment.apiKeys[0]._userId).to.equal(session.user._id);
  });

  async function getOrganizationMembers(sessionToUser = session) {
    const { body } = await sessionToUser.testAgent.get('/v1/organizations/members');

    return body.data;
  }
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getOrganizationMembers(sessionToUser = session)
Asignaciones con arrow functions encontradas (posibles funciones):
 - environmentRepository(new EnvironmentRepository();
  let user2: UserSession;
  let user3: UserSession;

  beforeEach(async...)
 - organization(session.organization;
  });

  it('should switch the apiKey association when api key creator removed...)
 - originalCreator(members.find((i))
 - originalCreatorAfterRemoval(membersAfterRemoval.find((i))
 - environment(await environmentRepository.findOne({ _id: session.environment._id });
    expect(environment.apiKey...)
 - user2Member(members.find((i))
 - user2Removed(membersAfterRemoval.find((i))

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/e2e/rename-organization.e2e.ts
Tamaño: 654 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Rename Organization - /organizations (PATCH) #novu-v0-os', () => {
  let session: UserSession;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should rename the organization', async () => {
    const payload = {
      name: 'Liberty Powers',
    };

    await session.testAgent.patch('/v1/organizations').send(payload);

    const { body } = await session.testAgent.get('/v1/organizations/me').expect(200);
    const organization = body.data;

    expect(organization?.name).to.equal(payload.name);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
    await session.initialize();
  });

  it('should rename the organization', asy...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/e2e/update-branding-details.e2e.ts
Tamaño: 2879 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { processTestAgentExpectedStatusCode, UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Update Branding Details - /organizations/branding (PUT) #novu-v0-os', () => {
  let session: UserSession;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
  });

  it('should update organization name only', async () => {
    const payload = {
      name: 'New Name',
    };

    await session.testAgent.patch('/v1/organizations').send(payload).expect(processTestAgentExpectedStatusCode(200));
    const { body } = await session.testAgent.get('/v1/organizations/me').expect(200);
    const organization = body.data;

    expect(organization?.name).to.equal(payload.name);
    expect(organization?.logo).to.equal(session.organization.logo);
  });

  it('should update the branding details', async () => {
    const payload = {
      color: '#fefefe',
      fontColor: '#f4f4f4',
      contentBackground: '#fefefe',
      fontFamily: 'Nunito',
      logo: 'https://s3.us-east-1.amazonaws.com/novu-app-bucket/2/1/3.png',
    };

    const result = await session.testAgent
      .put('/v1/organizations/branding')
      .send(payload)
      .expect(processTestAgentExpectedStatusCode(200));

    const { body } = await session.testAgent.get('/v1/organizations/me').expect(200);
    const organization = body.data;

    expect(organization?.branding.color).to.equal(payload.color);
    expect(organization?.branding.logo).to.equal(payload.logo);
    expect(organization?.branding.fontColor).to.equal(payload.fontColor);
    expect(organization?.branding.fontFamily).to.equal(payload.fontFamily);
    expect(organization?.branding.contentBackground).to.equal(payload.contentBackground);
  });

  it('logo should be an https protocol', async () => {
    const payload = {
      logo: 'http://s3.us-east-1.amazonaws.com/novu-app-bucket/2/1/3.png',
    };

    const result = await session.testAgent.put('/v1/organizations/branding').send(payload).expect(400);
  });

  ['png', 'jpg', 'jpeg', 'gif', 'svg'].forEach((extension) => {
    it(`should update if logo is a valid image URL with ${extension} extension`, async () => {
      const payload = {
        logo: `https://s3.us-east-1.amazonaws.com/novu-app-bucket/2/1/3.${extension}`,
      };

      const result = await session.testAgent
        .put('/v1/organizations/branding')
        .send(payload)
        .expect(processTestAgentExpectedStatusCode(200));
    });
  });

  ['exe', 'zip'].forEach((extension) => {
    it(`should fail to update if logo is a valid image URL with ${extension} extension`, async () => {
      const payload = {
        logo: `https://s3.us-east-1.amazonaws.com/novu-app-bucket/2/1/3.${extension}`,
      };

      const result = await session.testAgent.put('/v1/organizations/branding').send(payload).expect(400);
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - session(new UserSession();
    await session.initialize();
  });

  it('should update organization name only...)
 - organization(body.data;

    expect(organization?.name).to.equal(payload.name);
    expect(organization?.logo).to...)
 - organization(body.data;

    expect(organization?.branding.color).to.equal(payload.color);
    expect(organizatio...)
 - result(await session.testAgent.put('/v1/organizations/branding').send(payload).expect(400);
  });

  ['png'...)
 - result(await session.testAgent
        .put('/v1/organizations/branding')
        .send(payload)
        .e...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/e2e/update-organization-settings.e2e.ts
Tamaño: 1998 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CommunityOrganizationRepository } from '@novu/dal';
import { ApiServiceLevelEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

describe('Update Organization Settings - /organizations/settings (PATCH) #novu-v2', () => {
  let session: UserSession;
  let organizationRepository: CommunityOrganizationRepository;

  beforeEach(async () => {
    session = new UserSession();
    await session.initialize();
    organizationRepository = new CommunityOrganizationRepository();
  });

  it('should allow updating removeNovuBranding for PRO tier organizations', async () => {
    await organizationRepository.update(
      { _id: session.organization._id },
      { apiServiceLevel: ApiServiceLevelEnum.PRO }
    );

    const payload = { removeNovuBranding: true };

    const { body } = await session.testAgent.patch('/v1/organizations/settings').send(payload).expect(200);

    expect(body.data.removeNovuBranding).to.equal(true);
  });

  it('should block branding updates for free tier organizations', async () => {
    await organizationRepository.update(
      { _id: session.organization._id },
      { apiServiceLevel: ApiServiceLevelEnum.FREE }
    );

    const payload = { removeNovuBranding: true };

    const { body } = await session.testAgent.patch('/v1/organizations/settings').send(payload).expect(402);

    expect(body.message).to.include('Removing Novu branding is not allowed on the free plan');
  });

  it('should allow free tier organizations to call endpoint without branding changes', async () => {
    await organizationRepository.update(
      { _id: session.organization._id },
      { apiServiceLevel: ApiServiceLevelEnum.FREE }
    );

    const payload = {};

    const { body } = await session.testAgent.patch('/v1/organizations/settings').send(payload).expect(200);

    expect(body.data).to.have.property('removeNovuBranding');
    expect(typeof body.data.removeNovuBranding).to.equal('boolean');
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - organizationRepository(new CommunityOrganizationRepository();
  });

  it('should allow updating removeNovuBranding for PRO...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/usecases/index.ts
Tamaño: 1815 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { isClerkEnabled } from '@novu/shared';
import { CreateOrganization } from './create-organization/create-organization.usecase';
import { SyncExternalOrganization } from './create-organization/sync-external-organization/sync-external-organization.usecase';
import { GetMyOrganization } from './get-my-organization/get-my-organization.usecase';
import { GetOrganization } from './get-organization/get-organization.usecase';
import { GetOrganizationSettings } from './get-organization-settings/get-organization-settings.usecase';
import { GetOrganizations } from './get-organizations/get-organizations.usecase';
import { AddMember } from './membership/add-member/add-member.usecase';
import { ChangeMemberRole } from './membership/change-member-role/change-member-role.usecase';
import { GetMembers } from './membership/get-members/get-members.usecase';
import { RemoveMember } from './membership/remove-member/remove-member.usecase';
import { RenameOrganization } from './rename-organization/rename-organization.usecase';
import { UpdateBrandingDetails } from './update-branding-details/update-branding-details.usecase';
import { UpdateOrganizationSettings } from './update-organization-settings/update-organization-settings.usecase';

// TODO: move ee.organization.controller.ts to EE package
function getEnterpriseUsecases() {
  if (isClerkEnabled()) {
    return [
      {
        provide: 'SyncOrganizationUsecase',
        useClass: SyncExternalOrganization,
      },
    ];
  }

  return [];
}

export const USE_CASES = [
  AddMember,
  CreateOrganization,
  GetOrganization,
  GetMembers,
  RemoveMember,
  ChangeMemberRole,
  UpdateBrandingDetails,
  GetOrganizations,
  GetMyOrganization,
  RenameOrganization,
  GetOrganizationSettings,
  UpdateOrganizationSettings,
  ...getEnterpriseUsecases(),
];


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getEnterpriseUsecases()
Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/usecases/create-organization/create-organization.command.ts
Tamaño: 674 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiServiceLevelEnum, JobTitleEnum } from '@novu/shared';
import { IsDefined, IsEnum, IsOptional, IsString } from 'class-validator';

import { AuthenticatedCommand } from '../../../shared/commands/authenticated.command';

export class CreateOrganizationCommand extends AuthenticatedCommand {
  @IsString()
  @IsDefined()
  public readonly name: string;

  @IsString()
  @IsOptional()
  public readonly logo?: string;

  @IsOptional()
  @IsEnum(JobTitleEnum)
  jobTitle?: JobTitleEnum;

  @IsString()
  @IsOptional()
  domain?: string;

  @IsOptional()
  language?: string[];

  @IsOptional()
  @IsEnum(ApiServiceLevelEnum)
  apiServiceLevel?: ApiServiceLevelEnum;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateOrganizationCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/usecases/create-organization/create-organization.usecase.ts
Tamaño: 3882 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Inject, Injectable } from '@nestjs/common';
import { AnalyticsService } from '@novu/application-generic';
import { OrganizationEntity, OrganizationRepository, UserRepository } from '@novu/dal';
import { ApiServiceLevelEnum, EnvironmentEnum, JobTitleEnum, MemberRoleEnum } from '@novu/shared';

import { CreateEnvironmentCommand } from '../../../environments-v1/usecases/create-environment/create-environment.command';
import { CreateEnvironment } from '../../../environments-v1/usecases/create-environment/create-environment.usecase';
import { GetOrganizationCommand } from '../get-organization/get-organization.command';
import { GetOrganization } from '../get-organization/get-organization.usecase';
import { AddMemberCommand } from '../membership/add-member/add-member.command';
import { AddMember } from '../membership/add-member/add-member.usecase';
import { CreateOrganizationCommand } from './create-organization.command';

@Injectable()
export class CreateOrganization {
  constructor(
    private readonly organizationRepository: OrganizationRepository,
    private readonly addMemberUsecase: AddMember,
    private readonly getOrganizationUsecase: GetOrganization,
    private readonly userRepository: UserRepository,
    private readonly createEnvironmentUsecase: CreateEnvironment,
    private analyticsService: AnalyticsService
  ) {}

  async execute(command: CreateOrganizationCommand): Promise<OrganizationEntity> {
    const user = await this.userRepository.findById(command.userId);
    if (!user) throw new BadRequestException('User not found');

    const isSelfHosted = process.env.IS_SELF_HOSTED === 'true';
    const isEnterprise = process.env.NOVU_ENTERPRISE === 'true' || process.env.CI_EE_TEST === 'true';
    const defaultApiServiceLevel =
      isSelfHosted && isEnterprise ? ApiServiceLevelEnum.UNLIMITED : ApiServiceLevelEnum.FREE;

    const createdOrganization = await this.organizationRepository.create({
      logo: command.logo,
      name: command.name,
      apiServiceLevel: command.apiServiceLevel || defaultApiServiceLevel,
      domain: command.domain,
      language: command.language,
    });

    if (command.jobTitle) {
      await this.updateJobTitle(user, command.jobTitle);
    }

    await this.addMemberUsecase.execute(
      AddMemberCommand.create({
        roles: [MemberRoleEnum.OSS_ADMIN],
        organizationId: createdOrganization._id,
        userId: command.userId,
      })
    );

    const devEnv = await this.createEnvironmentUsecase.execute(
      CreateEnvironmentCommand.create({
        userId: user._id,
        name: EnvironmentEnum.DEVELOPMENT,
        organizationId: createdOrganization._id,
        system: true,
      })
    );

    await this.createEnvironmentUsecase.execute(
      CreateEnvironmentCommand.create({
        userId: user._id,
        name: EnvironmentEnum.PRODUCTION,
        organizationId: createdOrganization._id,
        parentEnvironmentId: devEnv._id,
        system: true,
      })
    );

    this.analyticsService.upsertGroup(createdOrganization._id, createdOrganization, user);

    this.analyticsService.track('[Authentication] - Create Organization', user._id, {
      _organization: createdOrganization._id,
      language: command.language,
      creatorJobTitle: command.jobTitle,
    });

    const organizationAfterChanges = await this.getOrganizationUsecase.execute(
      GetOrganizationCommand.create({
        id: createdOrganization._id,
        userId: command.userId,
      })
    );

    return organizationAfterChanges as OrganizationEntity;
  }

  private async updateJobTitle(user, jobTitle: JobTitleEnum) {
    await this.userRepository.update(
      {
        _id: user._id,
      },
      {
        $set: {
          jobTitle,
        },
      }
    );

    this.analyticsService.setValue(user._id, 'jobTitle', jobTitle);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateOrganization

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/usecases/create-organization/sync-external-organization/sync-external-organization.command.ts
Tamaño: 271 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { AuthenticatedCommand } from '@novu/application-generic';
import { IsDefined, IsEnum, IsOptional, IsString } from 'class-validator';

export class SyncExternalOrganizationCommand extends AuthenticatedCommand {
  @IsDefined()
  @IsString()
  externalId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SyncExternalOrganizationCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/usecases/create-organization/sync-external-organization/sync-external-organization.usecase.ts
Tamaño: 6196 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import { AnalyticsService, PinoLogger } from '@novu/application-generic';
import { OrganizationEntity, OrganizationRepository, UserRepository } from '@novu/dal';
import { CreateEnvironmentCommand } from '../../../../environments-v1/usecases/create-environment/create-environment.command';
import { CreateEnvironment } from '../../../../environments-v1/usecases/create-environment/create-environment.usecase';
import { CreateNovuIntegrationsCommand } from '../../../../integrations/usecases/create-novu-integrations/create-novu-integrations.command';
import { CreateNovuIntegrations } from '../../../../integrations/usecases/create-novu-integrations/create-novu-integrations.usecase';
import { UpsertLayout, UpsertLayoutCommand } from '../../../../layouts-v2/usecases/upsert-layout';
import { createDefaultLayout } from '../../../../layouts-v2/utils/layout-templates';
import { GetOrganizationCommand } from '../../get-organization/get-organization.command';
import { GetOrganization } from '../../get-organization/get-organization.usecase';
import { SyncExternalOrganizationCommand } from './sync-external-organization.command';

// TODO: eventually move to @novu/ee-auth

/**
 * This logic is closely related to the CreateOrganization use case.
 * @see src/app/organization/usecases/create-organization/create-organization.usecase.ts
 *
 * The side effects of creating a new organization are largely
 * consistent with those in CreateOrganization, with only minor differences.
 */

@Injectable()
export class SyncExternalOrganization {
  constructor(
    private readonly organizationRepository: OrganizationRepository,
    private readonly getOrganizationUsecase: GetOrganization,
    private readonly userRepository: UserRepository,
    private readonly createEnvironmentUsecase: CreateEnvironment,
    private readonly createNovuIntegrations: CreateNovuIntegrations,
    private readonly upsertLayoutUsecase: UpsertLayout,
    private analyticsService: AnalyticsService,
    private moduleRef: ModuleRef,
    private logger: PinoLogger
  ) {
    this.logger.setContext(this.constructor.name);
  }

  async execute(command: SyncExternalOrganizationCommand): Promise<OrganizationEntity> {
    const user = await this.userRepository.findById(command.userId);
    if (!user) throw new BadRequestException('User not found');
    if (!user._id) {
      this.logger.error({ err: 'User not found' }, 'User not found when syncing external organization');

      throw new BadRequestException('User not found');
    }

    const isSelfHosted = process.env.IS_SELF_HOSTED === 'true';
    const isEnterprise = process.env.NOVU_ENTERPRISE === 'true' || process.env.CI_EE_TEST === 'true';

    const organization = await this.organizationRepository.create({
      externalId: command.externalId,
      apiServiceLevel: isSelfHosted && isEnterprise ? 'unlimited' : undefined,
    });

    const devEnv = await this.createEnvironmentUsecase.execute(
      CreateEnvironmentCommand.create({
        userId: user._id,
        name: 'Development',
        organizationId: organization._id,
        system: true,
      })
    );

    await this.createNovuIntegrations.execute(
      CreateNovuIntegrationsCommand.create({
        environmentId: devEnv._id,
        organizationId: devEnv._organizationId,
        userId: user._id,
        name: devEnv.name,
      })
    );

    await this.upsertLayoutUsecase.execute(
      UpsertLayoutCommand.create({
        environmentId: devEnv._id,
        organizationId: devEnv._organizationId,
        userId: user._id,
        layoutDto: {
          name: 'Default layout',
          controlValues: {
            email: {
              body: JSON.stringify(createDefaultLayout(organization.name)),
              editorType: 'block',
            },
          },
        },
      })
    );

    const prodEnv = await this.createEnvironmentUsecase.execute(
      CreateEnvironmentCommand.create({
        userId: user._id,
        name: 'Production',
        organizationId: organization._id,
        parentEnvironmentId: devEnv._id,
        system: true,
      })
    );

    await this.createNovuIntegrations.execute(
      CreateNovuIntegrationsCommand.create({
        environmentId: prodEnv._id,
        organizationId: prodEnv._organizationId,
        userId: user._id,
        name: prodEnv.name,
      })
    );

    await this.upsertLayoutUsecase.execute(
      UpsertLayoutCommand.create({
        environmentId: prodEnv._id,
        organizationId: prodEnv._organizationId,
        userId: user._id,
        layoutDto: {
          name: 'Default layout',
          controlValues: {
            email: {
              body: JSON.stringify(createDefaultLayout(organization.name)),
              editorType: 'block',
            },
          },
        },
      })
    );

    this.analyticsService.upsertGroup(organization._id, organization, user);

    this.analyticsService.track('[Authentication] - Create Organization', user._id, {
      _organization: organization._id,
    });

    const organizationAfterChanges = await this.getOrganizationUsecase.execute(
      GetOrganizationCommand.create({
        id: organization._id,
        userId: command.userId,
      })
    );

    if (organizationAfterChanges !== null) {
      await this.createCustomer(user.email, organizationAfterChanges._id);
    }

    return organizationAfterChanges as OrganizationEntity;
  }

  private async createCustomer(billingEmail: string, organizationId: string) {
    try {
      if (process.env.NOVU_ENTERPRISE === 'true' || process.env.CI_EE_TEST === 'true') {
        if (!require('@novu/ee-billing')?.GetOrCreateCustomer) {
          throw new BadRequestException('Billing module is not loaded');
        }
        const usecase = this.moduleRef.get(require('@novu/ee-billing')?.GetOrCreateCustomer, {
          strict: false,
        });
        await usecase.execute({
          organizationId,
          billingEmail,
        });
      }
    } catch (e) {
      this.logger.error({ err: e }, `Unexpected error while importing enterprise modules`);
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class SyncExternalOrganization

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/usecases/get-my-organization/get-my-organization.command.ts
Tamaño: 249 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined } from 'class-validator';
import { AuthenticatedCommand } from '../../../shared/commands/authenticated.command';

export class GetMyOrganizationCommand extends AuthenticatedCommand {
  @IsDefined()
  public readonly id: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetMyOrganizationCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/usecases/get-my-organization/get-my-organization.usecase.ts
Tamaño: 802 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, Scope, UnauthorizedException } from '@nestjs/common';
import { GetOrganizationCommand } from '../get-organization/get-organization.command';
import { GetOrganization } from '../get-organization/get-organization.usecase';
import { GetMyOrganizationCommand } from './get-my-organization.command';

@Injectable({
  scope: Scope.REQUEST,
})
export class GetMyOrganization {
  constructor(private getOrganizationUseCase: GetOrganization) {}

  async execute(command: GetMyOrganizationCommand) {
    const organization = await this.getOrganizationUseCase.execute(
      GetOrganizationCommand.create({
        id: command.id,
        userId: command.userId,
      })
    );
    if (!organization) throw new UnauthorizedException('No organization found');

    return organization;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetMyOrganization

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/usecases/get-organization-settings/get-organization-settings.command.ts
Tamaño: 346 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BaseCommand } from '@novu/application-generic';
import { OrganizationEntity } from '@novu/dal';
import { IsNotEmpty, IsOptional } from 'class-validator';

export class GetOrganizationSettingsCommand extends BaseCommand {
  @IsNotEmpty()
  readonly organizationId: string;

  @IsOptional()
  readonly organization?: OrganizationEntity;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetOrganizationSettingsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/usecases/get-organization-settings/get-organization-settings.usecase.ts
Tamaño: 1007 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, NotFoundException } from '@nestjs/common';
import { CommunityOrganizationRepository } from '@novu/dal';
import { DEFAULT_LOCALE } from '@novu/shared';
import { GetOrganizationSettingsDto } from '../../dtos/get-organization-settings.dto';
import { GetOrganizationSettingsCommand } from './get-organization-settings.command';

@Injectable()
export class GetOrganizationSettings {
  constructor(private organizationRepository: CommunityOrganizationRepository) {}

  async execute(command: GetOrganizationSettingsCommand): Promise<GetOrganizationSettingsDto> {
    const organization = command.organization ?? (await this.organizationRepository.findById(command.organizationId));

    if (!organization) {
      throw new NotFoundException('Organization not found');
    }

    return {
      removeNovuBranding: organization.removeNovuBranding || false,
      defaultLocale: organization.defaultLocale || DEFAULT_LOCALE,
      targetLocales: organization.targetLocales || [],
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetOrganizationSettings

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/usecases/get-organization/get-organization.command.ts
Tamaño: 187 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { AuthenticatedCommand } from '../../../shared/commands/authenticated.command';

export class GetOrganizationCommand extends AuthenticatedCommand {
  public readonly id: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetOrganizationCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/usecases/get-organization/get-organization.usecase.ts
Tamaño: 426 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, Scope } from '@nestjs/common';
import { OrganizationRepository } from '@novu/dal';
import { GetOrganizationCommand } from './get-organization.command';

@Injectable()
export class GetOrganization {
  constructor(private readonly organizationRepository: OrganizationRepository) {}

  async execute(command: GetOrganizationCommand) {
    return await this.organizationRepository.findById(command.id);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetOrganization

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/usecases/get-organizations/get-organizations.command.ts
Tamaño: 157 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { AuthenticatedCommand } from '../../../shared/commands/authenticated.command';

export class GetOrganizationsCommand extends AuthenticatedCommand {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetOrganizationsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/usecases/get-organizations/get-organizations.usecase.ts
Tamaño: 480 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, Scope } from '@nestjs/common';
import { OrganizationRepository } from '@novu/dal';
import { GetOrganizationsCommand } from './get-organizations.command';

@Injectable({
  scope: Scope.REQUEST,
})
export class GetOrganizations {
  constructor(private readonly organizationRepository: OrganizationRepository) {}

  async execute(command: GetOrganizationsCommand) {
    return await this.organizationRepository.findUserActiveOrganizations(command.userId);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetOrganizations

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/usecases/membership/add-member/add-member.command.ts
Tamaño: 309 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { MemberRoleEnum } from '@novu/shared';
import { ArrayNotEmpty } from 'class-validator';
import { OrganizationCommand } from '../../../../shared/commands/organization.command';

export class AddMemberCommand extends OrganizationCommand {
  @ArrayNotEmpty()
  public readonly roles: MemberRoleEnum[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class AddMemberCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/usecases/membership/add-member/add-member.usecase.ts
Tamaño: 923 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable } from '@nestjs/common';
import { MemberRepository } from '@novu/dal';
import { MemberStatusEnum } from '@novu/shared';
import { AddMemberCommand } from './add-member.command';

@Injectable()
export class AddMember {
  constructor(private readonly memberRepository: MemberRepository) {}

  async execute(command: AddMemberCommand): Promise<void> {
    const isAlreadyMember = await this.isMember(command.organizationId, command.userId);
    if (isAlreadyMember) throw new BadRequestException('Member already exists');

    await this.memberRepository.addMember(command.organizationId, {
      _userId: command.userId,
      roles: command.roles,
      memberStatus: MemberStatusEnum.ACTIVE,
    });
  }

  private async isMember(organizationId: string, userId: string): Promise<boolean> {
    return !!(await this.memberRepository.findMemberByUserId(organizationId, userId));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class AddMember

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/usecases/membership/change-member-role/change-member-role.command.ts
Tamaño: 369 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { MemberRoleEnum } from '@novu/shared';
import { IsDefined, IsEnum, IsMongoId } from 'class-validator';
import { OrganizationCommand } from '../../../../shared/commands/organization.command';

export class ChangeMemberRoleCommand extends OrganizationCommand {
  @IsDefined()
  role: MemberRoleEnum.OSS_ADMIN;

  @IsDefined()
  @IsMongoId()
  memberId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ChangeMemberRoleCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/usecases/membership/change-member-role/change-member-role.usecase.ts
Tamaño: 1394 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import { MemberRepository, OrganizationRepository } from '@novu/dal';
import { MemberRoleEnum } from '@novu/shared';

import { ChangeMemberRoleCommand } from './change-member-role.command';

@Injectable()
export class ChangeMemberRole {
  constructor(
    private organizationRepository: OrganizationRepository,
    private memberRepository: MemberRepository
  ) {}

  async execute(command: ChangeMemberRoleCommand) {
    if (![MemberRoleEnum.OSS_MEMBER, MemberRoleEnum.OSS_ADMIN].includes(command.role)) {
      throw new BadRequestException('Not supported role type');
    }

    if (command.role !== MemberRoleEnum.OSS_ADMIN) {
      throw new BadRequestException(`The change of role to an ${command.role} type is not supported`);
    }

    const organization = await this.organizationRepository.findById(command.organizationId);
    if (!organization) throw new NotFoundException('No organization was found');

    const member = await this.memberRepository.findMemberById(organization._id, command.memberId);
    if (!member) throw new NotFoundException('No member was found');

    const roles = [command.role];

    await this.memberRepository.updateMemberRoles(organization._id, command.memberId, roles);

    return this.memberRepository.findMemberByUserId(organization._id, member._userId);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ChangeMemberRole

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/usecases/membership/get-members/get-members.command.ts
Tamaño: 285 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { UserSessionData } from '@novu/shared';
import { IsDefined } from 'class-validator';
import { OrganizationCommand } from '../../../../shared/commands/organization.command';

export class GetMembersCommand extends OrganizationCommand {
  @IsDefined()
  user: UserSessionData;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetMembersCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/usecases/membership/get-members/get-members.usecase.ts
Tamaño: 852 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, Scope } from '@nestjs/common';
import { MemberRepository } from '@novu/dal';
import { MemberRoleEnum, MemberStatusEnum } from '@novu/shared';
import { GetMembersCommand } from './get-members.command';

@Injectable({
  scope: Scope.REQUEST,
})
export class GetMembers {
  constructor(private membersRepository: MemberRepository) {}

  async execute(command: GetMembersCommand) {
    return (await this.membersRepository.getOrganizationMembers(command.organizationId))
      .map((member) => {
        if (!command.user.roles.includes(MemberRoleEnum.OSS_ADMIN)) {
          if (member.memberStatus === MemberStatusEnum.INVITED) return null;
          if (member.user) member.user.email = '';
          if (member.invite) member.invite.email = '';
        }

        return member;
      })
      .filter((member) => !!member);
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - email('';
        }

        return member;
      })
      .filter((member))
Declaraciones 'export' encontradas:
- export class GetMembers

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/usecases/membership/remove-member/remove-member.command.ts
Tamaño: 258 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsMongoId, IsString } from 'class-validator';
import { OrganizationCommand } from '../../../../shared/commands/organization.command';

export class RemoveMemberCommand extends OrganizationCommand {
  @IsString()
  @IsMongoId()
  memberId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RemoveMemberCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/usecases/membership/remove-member/remove-member.usecase.ts
Tamaño: 1687 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Injectable, NotFoundException, Scope } from '@nestjs/common';
import { EnvironmentRepository, MemberRepository } from '@novu/dal';
import { RemoveMemberCommand } from './remove-member.command';

@Injectable({
  scope: Scope.REQUEST,
})
export class RemoveMember {
  constructor(
    private memberRepository: MemberRepository,
    private environmentRepository: EnvironmentRepository
  ) {}

  async execute(command: RemoveMemberCommand) {
    const members = await this.memberRepository.getOrganizationMembers(command.organizationId);
    const memberToRemove = members.find((i) => i._id === command.memberId);

    if (!memberToRemove) throw new NotFoundException('Member not found');
    if (memberToRemove._userId && memberToRemove._userId && memberToRemove._userId === command.userId) {
      throw new BadRequestException('Cannot remove self from members');
    }

    await this.memberRepository.removeMemberById(command.organizationId, memberToRemove._id);
    const environments = await this.environmentRepository.findOrganizationEnvironments(command.organizationId);
    const isMemberAssociatedWithEnvironment = environments.some((i) =>
      i.apiKeys.some((key) => key._userId === memberToRemove._userId)
    );

    if (isMemberAssociatedWithEnvironment) {
      const owner = await this.memberRepository.getOrganizationOwnerAccount(command.organizationId);
      if (!owner) throw new NotFoundException('No owner account found for organization');

      await this.environmentRepository.updateApiKeyUserId(
        command.organizationId,
        memberToRemove._userId,
        owner._userId
      );
    }

    return memberToRemove;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - memberToRemove(members.find((i))
 - isMemberAssociatedWithEnvironment(environments.some((i))
Declaraciones 'export' encontradas:
- export class RemoveMember

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/usecases/rename-organization/rename-organization-command.ts
Tamaño: 310 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsNotEmpty } from 'class-validator';
import { AuthenticatedCommand } from '../../../shared/commands/authenticated.command';

export class RenameOrganizationCommand extends AuthenticatedCommand {
  @IsDefined()
  public readonly id: string;

  @IsDefined()
  @IsNotEmpty()
  name: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RenameOrganizationCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/usecases/rename-organization/rename-organization.usecase.ts
Tamaño: 511 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { OrganizationRepository } from '@novu/dal';
import { RenameOrganizationCommand } from './rename-organization-command';

@Injectable()
export class RenameOrganization {
  constructor(private organizationRepository: OrganizationRepository) {}

  async execute(command: RenameOrganizationCommand) {
    const payload = {
      name: command.name,
    };

    await this.organizationRepository.renameOrganization(command.id, payload);

    return payload;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RenameOrganization

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/usecases/update-branding-details/update-branding-details.command.ts
Tamaño: 556 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsHexColor, IsOptional, IsUrl } from 'class-validator';
import { AuthenticatedCommand } from '../../../shared/commands/authenticated.command';

export class UpdateBrandingDetailsCommand extends AuthenticatedCommand {
  @IsDefined()
  public readonly id: string;

  @IsUrl({ require_tld: false })
  @IsOptional()
  logo: string;

  @IsOptional()
  @IsHexColor()
  color: string;

  @IsOptional()
  @IsHexColor()
  fontColor: string;

  @IsOptional()
  @IsHexColor()
  contentBackground: string;

  @IsOptional()
  fontFamily?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateBrandingDetailsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/usecases/update-branding-details/update-branding-details.usecase.ts
Tamaño: 681 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { OrganizationRepository } from '@novu/dal';
import { UpdateBrandingDetailsCommand } from './update-branding-details.command';

@Injectable()
export class UpdateBrandingDetails {
  constructor(private organizationRepository: OrganizationRepository) {}

  async execute(command: UpdateBrandingDetailsCommand) {
    const payload = {
      color: command.color,
      logo: command.logo,
      fontColor: command.fontColor,
      contentBackground: command.contentBackground,
      fontFamily: command.fontFamily,
    };

    await this.organizationRepository.updateBrandingDetails(command.id, payload);

    return payload;
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateBrandingDetails

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/usecases/update-organization-settings/update-organization-settings.command.ts
Tamaño: 513 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { AuthenticatedCommand, IsValidLocale } from '@novu/application-generic';
import { IsArray, IsBoolean, IsNotEmpty, IsOptional, IsString } from 'class-validator';

export class UpdateOrganizationSettingsCommand extends AuthenticatedCommand {
  @IsNotEmpty()
  readonly organizationId: string;

  @IsOptional()
  @IsBoolean()
  removeNovuBranding?: boolean;

  @IsOptional()
  @IsValidLocale()
  defaultLocale?: string;

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  targetLocales?: string[];
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateOrganizationSettingsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/organization/usecases/update-organization-settings/update-organization-settings.usecase.ts
Tamaño: 3942 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { HttpException, HttpStatus, Injectable, NotFoundException } from '@nestjs/common';
import { AnalyticsService } from '@novu/application-generic';
import { CommunityOrganizationRepository, OrganizationEntity } from '@novu/dal';
import { ApiServiceLevelEnum, DEFAULT_LOCALE, FeatureNameEnum, getFeatureForTierAsBoolean } from '@novu/shared';
import { GetOrganizationSettingsDto } from '../../dtos/get-organization-settings.dto';
import { UpdateOrganizationSettingsCommand } from './update-organization-settings.command';

@Injectable()
export class UpdateOrganizationSettings {
  constructor(
    private organizationRepository: CommunityOrganizationRepository,
    private analyticsService: AnalyticsService
  ) {}

  async execute(command: UpdateOrganizationSettingsCommand): Promise<GetOrganizationSettingsDto> {
    const organization = await this.organizationRepository.findById(command.organizationId);

    if (!organization) {
      throw new NotFoundException('Organization not found');
    }

    this.validateTierRestrictions(command, organization);

    const updateFields = this.buildUpdateFields(command);

    if (Object.keys(updateFields).length === 0) {
      return this.buildSettingsResponse(organization);
    }

    await this.organizationRepository.updateOne({ _id: organization._id }, { $set: updateFields });

    if (command.removeNovuBranding !== undefined) {
      this.analyticsService.mixpanelTrack('Remove Branding', command.userId, {
        _organization: command.organizationId,
        newStatus: command.removeNovuBranding,
      });
    }

    return this.buildSettingsResponse({
      ...organization,
      ...updateFields,
    });
  }

  private validateTierRestrictions(command: UpdateOrganizationSettingsCommand, organization: OrganizationEntity): void {
    // Only validate branding feature access if user is trying to update it
    if (command.removeNovuBranding !== undefined) {
      const canRemoveNovuBranding = getFeatureForTierAsBoolean(
        FeatureNameEnum.PLATFORM_REMOVE_NOVU_BRANDING_BOOLEAN,
        organization.apiServiceLevel || ApiServiceLevelEnum.FREE
      );

      if (!canRemoveNovuBranding) {
        throw new HttpException(
          {
            error: 'Payment Required',
            message:
              'Removing Novu branding is not allowed on the free plan. Please upgrade to a paid plan to access this feature.',
          },
          HttpStatus.PAYMENT_REQUIRED
        );
      }
    }

    if (command.targetLocales !== undefined || command.defaultLocale !== undefined) {
      const canUseTranslations = getFeatureForTierAsBoolean(
        FeatureNameEnum.AUTO_TRANSLATIONS,
        organization.apiServiceLevel || ApiServiceLevelEnum.FREE
      );

      if (!canUseTranslations) {
        throw new HttpException(
          {
            error: 'Payment Required',
            message:
              'Update of locales is a part of the translation feature. Please upgrade to a paid plan to access this feature.',
          },
          HttpStatus.PAYMENT_REQUIRED
        );
      }
    }
  }

  private buildUpdateFields(command: UpdateOrganizationSettingsCommand): Partial<OrganizationEntity> {
    const updateFields: Partial<OrganizationEntity> = {};

    if (command.removeNovuBranding !== undefined) {
      updateFields.removeNovuBranding = command.removeNovuBranding;
    }

    if (command.defaultLocale !== undefined) {
      updateFields.defaultLocale = command.defaultLocale;
    }

    if (command.targetLocales !== undefined) {
      updateFields.targetLocales = command.targetLocales;
    }

    return updateFields;
  }

  private buildSettingsResponse(organization: OrganizationEntity): GetOrganizationSettingsDto {
    return {
      removeNovuBranding: organization.removeNovuBranding || false,
      defaultLocale: organization.defaultLocale || DEFAULT_LOCALE,
      targetLocales: organization.targetLocales || [],
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateOrganizationSettings

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/outbound-webhooks/outbound-webhooks.controller.ts
Tamaño: 2797 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ClassSerializerInterceptor, Controller, Get, Post, UseInterceptors } from '@nestjs/common';
import { ApiExcludeController, ApiOperation } from '@nestjs/swagger';
import { ProductFeature, RequirePermissions, UserSession } from '@novu/application-generic';
import { PermissionsEnum, ProductFeatureKeyEnum, UserSessionData } from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { CreateWebhookPortalResponseDto } from './dtos/create-webhook-portal-response.dto';
import { GetWebhookPortalTokenResponseDto } from './dtos/get-webhook-portal-token-response.dto';
import { CreateWebhookPortalCommand } from './usecases/create-webhook-portal-token/create-webhook-portal.command';
import { CreateWebhookPortalUsecase } from './usecases/create-webhook-portal-token/create-webhook-portal.usecase';
import { GetWebhookPortalTokenCommand } from './usecases/get-webhook-portal-token/get-webhook-portal-token.command';
import { GetWebhookPortalTokenUsecase } from './usecases/get-webhook-portal-token/get-webhook-portal-token.usecase';

@Controller({ path: `/outbound-webhooks`, version: '2' })
@UseInterceptors(ClassSerializerInterceptor)
@RequireAuthentication()
@ApiExcludeController()
export class OutboundWebhooksController {
  constructor(
    private getWebhookPortalTokenUsecase: GetWebhookPortalTokenUsecase,
    private createWebhookPortalTokenUsecase: CreateWebhookPortalUsecase
  ) {}

  @Get('/portal/token')
  @ProductFeature(ProductFeatureKeyEnum.WEBHOOKS)
  @RequirePermissions(PermissionsEnum.WEBHOOK_WRITE, PermissionsEnum.WEBHOOK_READ)
  @ApiOperation({
    summary: 'Get Webhook Portal Access Token',
    description:
      'Generates a short-lived token and URL for accessing the Svix application portal for the current environment.',
  })
  async getPortalToken(@UserSession() user: UserSessionData): Promise<GetWebhookPortalTokenResponseDto> {
    return await this.getWebhookPortalTokenUsecase.execute(
      GetWebhookPortalTokenCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
      })
    );
  }

  @Post('/portal/token')
  @ProductFeature(ProductFeatureKeyEnum.WEBHOOKS)
  @RequirePermissions(PermissionsEnum.WEBHOOK_WRITE)
  @ApiOperation({
    summary: 'Create Webhook Portal Access Token',
    description: 'Creates a token for accessing the webhook portal for the current environment.',
  })
  async createPortalToken(@UserSession() user: UserSessionData): Promise<CreateWebhookPortalResponseDto> {
    return await this.createWebhookPortalTokenUsecase.execute(
      CreateWebhookPortalCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class OutboundWebhooksController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/outbound-webhooks/outbound-webhooks.module.ts
Tamaño: 1415 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { DynamicModule, Module } from '@nestjs/common';
import { SendWebhookMessage, SvixProviderService } from '@novu/application-generic';
import { NoopSendWebhookMessage } from '../inbox/usecases/noop-send-webhook-message.usecase';
import { SharedModule } from '../shared/shared.module';
import { OutboundWebhooksController } from './outbound-webhooks.controller';
import { CreateWebhookPortalUsecase } from './usecases/create-webhook-portal-token/create-webhook-portal.usecase';
import { GetWebhookPortalTokenUsecase } from './usecases/get-webhook-portal-token/get-webhook-portal-token.usecase';

@Module({})
class OutboundWebhooksModuleDefinition {}

export const OutboundWebhooksModule = {
  forRoot(): DynamicModule {
    const isEnterprise = process.env.NOVU_ENTERPRISE === 'true';

    if (isEnterprise) {
      return {
        module: OutboundWebhooksModuleDefinition,
        imports: [SharedModule],
        controllers: [OutboundWebhooksController],
        providers: [GetWebhookPortalTokenUsecase, CreateWebhookPortalUsecase, SvixProviderService, SendWebhookMessage],
        exports: [SendWebhookMessage],
      };
    }

    return {
      module: OutboundWebhooksModuleDefinition,
      imports: [SharedModule],
      providers: [
        {
          provide: SendWebhookMessage,
          useClass: NoopSendWebhookMessage,
        },
      ],
      exports: [SendWebhookMessage],
    };
  },
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/outbound-webhooks/webhooks.const.ts
Tamaño: 5087 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';
import { MessageWebhookResponseDto } from '@novu/application-generic';
import { WebhookEventEnum, WebhookObjectTypeEnum } from '@novu/shared';
import { InboxPreference } from '../inbox/utils/types';
import { WorkflowResponseDto } from '../workflows-v2/dtos/workflow-response.dto';

interface WebhookEventConfig {
  event: WebhookEventEnum;
  // biome-ignore lint/complexity/noBannedTypes: <explanation> This is the expected type for the payloadDto for SwaggerDocumentOptions.extraModels
  payloadDto: Function;
  objectType: WebhookObjectTypeEnum;
}

type WebhookEventRecord = Record<WebhookEventEnum, WebhookEventConfig>;

export class WebhookUpdatedWorkflowDto {
  @ApiProperty({ description: 'Current workflow state', type: () => WorkflowResponseDto })
  object: WorkflowResponseDto;

  @ApiProperty({ description: 'Previous state of the workflow', type: () => WorkflowResponseDto })
  previousObject: WorkflowResponseDto;
}

export class WebhookCreatedWorkflowDto {
  @ApiProperty({ description: 'Current workflow state', type: () => WorkflowResponseDto })
  object: WorkflowResponseDto;
}

export class WebhookDeletedWorkflowDto {
  @ApiProperty({ description: 'Current workflow state', type: () => WorkflowResponseDto })
  object: WorkflowResponseDto;
}

export class WebhookMessageDto {
  @ApiProperty({ description: 'Current message state' })
  object: MessageWebhookResponseDto;
}

export class WebhookMessageFailedDto {
  @ApiProperty({ description: 'Current message state' })
  object: MessageWebhookResponseDto;

  @ApiProperty({ description: 'Error message' })
  error: {
    message: string;
  };
}

export class WebhookPreferenceDto {
  @ApiProperty({ description: 'Current preference state' })
  object: InboxPreference;
}

// Create the webhook events as a record to ensure all enum values are covered
const webhookEventRecord = {
  [WebhookEventEnum.MESSAGE_SENT]: {
    event: WebhookEventEnum.MESSAGE_SENT,
    payloadDto: WebhookMessageDto,
    objectType: WebhookObjectTypeEnum.MESSAGE,
  },
  [WebhookEventEnum.MESSAGE_FAILED]: {
    event: WebhookEventEnum.MESSAGE_FAILED,
    payloadDto: WebhookMessageFailedDto,
    objectType: WebhookObjectTypeEnum.MESSAGE,
  },
  [WebhookEventEnum.MESSAGE_DELIVERED]: {
    event: WebhookEventEnum.MESSAGE_DELIVERED,
    payloadDto: WebhookMessageDto,
    objectType: WebhookObjectTypeEnum.MESSAGE,
  },
  [WebhookEventEnum.MESSAGE_SEEN]: {
    event: WebhookEventEnum.MESSAGE_SEEN,
    payloadDto: WebhookMessageDto,
    objectType: WebhookObjectTypeEnum.MESSAGE,
  },
  [WebhookEventEnum.MESSAGE_READ]: {
    event: WebhookEventEnum.MESSAGE_READ,
    payloadDto: WebhookMessageDto,
    objectType: WebhookObjectTypeEnum.MESSAGE,
  },
  [WebhookEventEnum.MESSAGE_UNREAD]: {
    event: WebhookEventEnum.MESSAGE_UNREAD,
    payloadDto: WebhookMessageDto,
    objectType: WebhookObjectTypeEnum.MESSAGE,
  },
  [WebhookEventEnum.MESSAGE_ARCHIVED]: {
    event: WebhookEventEnum.MESSAGE_ARCHIVED,
    payloadDto: WebhookMessageDto,
    objectType: WebhookObjectTypeEnum.MESSAGE,
  },
  [WebhookEventEnum.MESSAGE_UNARCHIVED]: {
    event: WebhookEventEnum.MESSAGE_UNARCHIVED,
    payloadDto: WebhookMessageDto,
    objectType: WebhookObjectTypeEnum.MESSAGE,
  },
  [WebhookEventEnum.MESSAGE_SNOOZED]: {
    event: WebhookEventEnum.MESSAGE_SNOOZED,
    payloadDto: WebhookMessageDto,
    objectType: WebhookObjectTypeEnum.MESSAGE,
  },
  [WebhookEventEnum.MESSAGE_UNSNOOZED]: {
    event: WebhookEventEnum.MESSAGE_UNSNOOZED,
    payloadDto: WebhookMessageDto,
    objectType: WebhookObjectTypeEnum.MESSAGE,
  },
  [WebhookEventEnum.MESSAGE_DELETED]: {
    event: WebhookEventEnum.MESSAGE_DELETED,
    payloadDto: WebhookMessageDto,
    objectType: WebhookObjectTypeEnum.MESSAGE,
  },
  [WebhookEventEnum.WORKFLOW_CREATED]: {
    event: WebhookEventEnum.WORKFLOW_CREATED,
    payloadDto: WebhookCreatedWorkflowDto,
    objectType: WebhookObjectTypeEnum.WORKFLOW,
  },
  [WebhookEventEnum.WORKFLOW_UPDATED]: {
    event: WebhookEventEnum.WORKFLOW_UPDATED,
    payloadDto: WebhookUpdatedWorkflowDto,
    objectType: WebhookObjectTypeEnum.WORKFLOW,
  },
  [WebhookEventEnum.WORKFLOW_DELETED]: {
    event: WebhookEventEnum.WORKFLOW_DELETED,
    payloadDto: WebhookDeletedWorkflowDto,
    objectType: WebhookObjectTypeEnum.WORKFLOW,
  },
  [WebhookEventEnum.WORKFLOW_PUBLISHED]: {
    event: WebhookEventEnum.WORKFLOW_PUBLISHED,
    payloadDto: WebhookUpdatedWorkflowDto,
    objectType: WebhookObjectTypeEnum.WORKFLOW,
  },
  [WebhookEventEnum.PREFERENCE_UPDATED]: {
    event: WebhookEventEnum.PREFERENCE_UPDATED,
    payloadDto: WebhookPreferenceDto,
    objectType: WebhookObjectTypeEnum.PREFERENCE,
  },
} as const satisfies WebhookEventRecord;

// Helper function to ensure all enum values are present exactly once
function createWebhookEvents<T extends WebhookEventRecord>(record: T): WebhookEventConfig[] {
  return Object.values(record);
}

// Export the webhook events array created from the type-safe record
export const webhookEvents = createWebhookEvents(webhookEventRecord);


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - WebhookEventRecord(Record<WebhookEventEnum, WebhookEventConfig>;

export class WebhookUpdatedWorkflowDto {
  @ApiProper...)
Declaraciones 'export' encontradas:
- export class WebhookUpdatedWorkflowDto
- export class WebhookCreatedWorkflowDto
- export class WebhookDeletedWorkflowDto
- export class WebhookMessageDto
- export class WebhookMessageFailedDto
- export class WebhookPreferenceDto
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/outbound-webhooks/dtos/create-webhook-portal-response.dto.ts
Tamaño: 189 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ApiProperty } from '@nestjs/swagger';

export class CreateWebhookPortalResponseDto {
  @ApiProperty({
    description: 'The webhook portal application ID',
  })
  appId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateWebhookPortalResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/outbound-webhooks/dtos/get-webhook-portal-token-response.dto.ts
Tamaño: 248 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsNotEmpty, IsString } from 'class-validator';

export class GetWebhookPortalTokenResponseDto {
  @IsNotEmpty()
  @IsString()
  url: string;

  @IsNotEmpty()
  @IsString()
  token: string;

  @IsNotEmpty()
  @IsString()
  appId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetWebhookPortalTokenResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/outbound-webhooks/usecases/create-webhook-portal-token/create-webhook-portal.command.ts
Tamaño: 166 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class CreateWebhookPortalCommand extends EnvironmentWithUserCommand {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateWebhookPortalCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/outbound-webhooks/usecases/create-webhook-portal-token/create-webhook-portal.usecase.ts
Tamaño: 2081 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Inject, Injectable, NotFoundException, Scope } from '@nestjs/common';
import { generateWebhookAppId, LogDecorator, SvixClient } from '@novu/application-generic';
import { EnvironmentRepository, OrganizationRepository } from '@novu/dal';
import { CreateWebhookPortalResponseDto } from '../../dtos/create-webhook-portal-response.dto';
import { CreateWebhookPortalCommand } from './create-webhook-portal.command';

@Injectable()
export class CreateWebhookPortalUsecase {
  constructor(
    private environmentRepository: EnvironmentRepository,
    @Inject('SVIX_CLIENT') private svix: SvixClient,
    private organizationRepository: OrganizationRepository
  ) {}

  @LogDecorator()
  async execute(command: CreateWebhookPortalCommand): Promise<CreateWebhookPortalResponseDto> {
    if (!this.svix) {
      throw new BadRequestException('Webhook system is not enabled');
    }

    const environment = await this.environmentRepository.findOne({
      _id: command.environmentId,
      _organizationId: command.organizationId,
    });

    if (!environment) {
      throw new NotFoundException(
        `Environment not found for id ${command.environmentId} and organization ${command.organizationId}`
      );
    }

    const organization = await this.organizationRepository.findById(command.organizationId);
    if (!organization) {
      throw new NotFoundException(`Organization not found for id ${command.organizationId}`);
    }

    try {
      const app = await this.svix.application.create({
        name: organization.name,
        uid: generateWebhookAppId(command.organizationId, command.environmentId),
        metadata: {
          environmentId: command.environmentId,
          organizationId: command.organizationId,
        },
      });

      await this.environmentRepository.updateOne({ _id: command.environmentId }, { $set: { webhookAppId: app.uid } });

      return {
        appId: app.uid!,
      };
    } catch (error) {
      throw new BadRequestException(`Failed to generate Svix portal token: ${error?.message}`);
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateWebhookPortalUsecase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/outbound-webhooks/usecases/get-webhook-portal-token/get-webhook-portal-token.command.ts
Tamaño: 288 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BaseCommand } from '@novu/application-generic';
import { IsDefined } from 'class-validator';
import { EnvironmentCommand } from '../../../shared/commands/project.command';

export class GetWebhookPortalTokenCommand extends EnvironmentCommand {
  @IsDefined()
  userId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetWebhookPortalTokenCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/outbound-webhooks/usecases/get-webhook-portal-token/get-webhook-portal-token.usecase.ts
Tamaño: 1831 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BadRequestException, Inject, Injectable, NotFoundException, Scope } from '@nestjs/common';
import { generateWebhookAppId, LogDecorator, SvixClient } from '@novu/application-generic';
import { EnvironmentRepository } from '@novu/dal';
import { GetWebhookPortalTokenResponseDto } from '../../dtos/get-webhook-portal-token-response.dto';
import { GetWebhookPortalTokenCommand } from './get-webhook-portal-token.command';

@Injectable()
export class GetWebhookPortalTokenUsecase {
  constructor(
    private environmentRepository: EnvironmentRepository,
    @Inject('SVIX_CLIENT') private svix: SvixClient
  ) {}

  @LogDecorator()
  async execute(command: GetWebhookPortalTokenCommand): Promise<GetWebhookPortalTokenResponseDto> {
    if (!this.svix) {
      throw new BadRequestException('Webhook system is not enabled');
    }

    const environment = await this.environmentRepository.findOne({
      _id: command.environmentId,
      _organizationId: command.organizationId,
    });

    if (!environment) {
      throw new NotFoundException(
        `Environment not found for id ${command.environmentId} and organization ${command.organizationId}`
      );
    }

    if (!environment.webhookAppId) {
      throw new NotFoundException(`Portal not found for environment ${command.environmentId}`);
    }

    try {
      const svixResponse = await this.svix.authentication.appPortalAccess(environment.webhookAppId, {});

      return {
        url: svixResponse.url,
        token: svixResponse.token,
        appId: environment.webhookAppId,
      };
    } catch (error) {
      if (error.code === 404) {
        throw new NotFoundException(`Portal not found for environment ${command.environmentId}`);
      }

      throw new BadRequestException(`Failed to generate Svix portal token: ${error?.message}`);
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetWebhookPortalTokenUsecase

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/partner-integrations/partner-integrations.controller.ts
Tamaño: 5077 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  Body,
  ClassSerializerInterceptor,
  Controller,
  Get,
  Headers,
  Param,
  Post,
  Put,
  Query,
  UseInterceptors,
} from '@nestjs/common';
import { ApiExcludeController, ApiTags } from '@nestjs/swagger';
import { RequirePermissions } from '@novu/application-generic';
import { PermissionsEnum, UserSessionData } from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { UserSession } from '../shared/framework/user.decorator';
import { CreateVercelIntegrationRequestDto } from './dtos/create-vercel-integration-request.dto';
import { CreateVercelIntegrationResponseDto } from './dtos/create-vercel-integration-response.dto';
import { UpdateVercelIntegrationRequestDto } from './dtos/update-vercel-integration-request.dto';
import { CreateVercelIntegrationCommand } from './usecases/create-vercel-integration/create-vercel-integration.command';
import { CreateVercelIntegration } from './usecases/create-vercel-integration/create-vercel-integration.usecase';
import { GetVercelIntegrationCommand } from './usecases/get-vercel-integration/get-vercel-integration.command';
import { GetVercelIntegration } from './usecases/get-vercel-integration/get-vercel-integration.usecase';
import { GetVercelIntegrationProjectsCommand } from './usecases/get-vercel-projects/get-vercel-integration-projects.command';
import { GetVercelIntegrationProjects } from './usecases/get-vercel-projects/get-vercel-integration-projects.usecase';
import { ProcessVercelWebhookCommand } from './usecases/process-vercel-webhook/process-vercel-webhook.command';
import { ProcessVercelWebhook } from './usecases/process-vercel-webhook/process-vercel-webhook.usecase';
import { UpdateVercelIntegrationCommand } from './usecases/update-vercel-integration/update-vercel-integration.command';
import { UpdateVercelIntegration } from './usecases/update-vercel-integration/update-vercel-integration.usecase';

@Controller('/partner-integrations')
@UseInterceptors(ClassSerializerInterceptor)
@ApiTags('Partner Integrations')
@ApiExcludeController()
export class PartnerIntegrationsController {
  constructor(
    private createVercelIntegrationUsecase: CreateVercelIntegration,
    private getVercelIntegrationProjectsUsecase: GetVercelIntegrationProjects,
    private getVercelIntegrationUsecase: GetVercelIntegration,
    private updateVercelIntegrationUsecase: UpdateVercelIntegration,
    private processVercelWebhookUsecase: ProcessVercelWebhook
  ) {}

  @Post('/vercel')
  @RequireAuthentication()
  @RequirePermissions(PermissionsEnum.PARTNER_INTEGRATION_WRITE)
  async createVercelIntegration(
    @UserSession() user: UserSessionData,
    @Body() body: CreateVercelIntegrationRequestDto
  ): Promise<CreateVercelIntegrationResponseDto> {
    return await this.createVercelIntegrationUsecase.execute(
      CreateVercelIntegrationCommand.create({
        vercelIntegrationCode: body.vercelIntegrationCode,
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
        configurationId: body.configurationId,
      })
    );
  }

  @Put('/vercel')
  @RequireAuthentication()
  @RequirePermissions(PermissionsEnum.PARTNER_INTEGRATION_WRITE)
  async updateVercelIntegration(@UserSession() user: UserSessionData, @Body() body: UpdateVercelIntegrationRequestDto) {
    return await this.updateVercelIntegrationUsecase.execute(
      UpdateVercelIntegrationCommand.create({
        data: body.data,
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
        configurationId: body.configurationId,
      })
    );
  }

  @Get('/vercel/:configurationId')
  @RequireAuthentication()
  @RequirePermissions(PermissionsEnum.PARTNER_INTEGRATION_READ)
  async getVercelIntegration(@UserSession() user: UserSessionData, @Param('configurationId') configurationId: string) {
    return await this.getVercelIntegrationUsecase.execute(
      GetVercelIntegrationCommand.create({
        userId: user._id,
        configurationId,
        environmentId: user.environmentId,
        organizationId: user.organizationId,
      })
    );
  }

  @Get('/vercel/:configurationId/projects')
  @RequireAuthentication()
  @RequirePermissions(PermissionsEnum.PARTNER_INTEGRATION_READ)
  async getVercelProjects(
    @UserSession() user: UserSessionData,
    @Param('configurationId') configurationId: string,
    @Query('nextPage') nextPage?: string
  ) {
    return await this.getVercelIntegrationProjectsUsecase.execute(
      GetVercelIntegrationProjectsCommand.create({
        configurationId,
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
        ...(nextPage && { nextPage }),
      })
    );
  }

  @Post('/vercel/webhook')
  async webhook(@Body() body: any, @Headers('x-vercel-signature') signatureHeader: string) {
    return this.processVercelWebhookUsecase.execute(
      ProcessVercelWebhookCommand.create({
        body,
        signatureHeader,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class PartnerIntegrationsController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/partner-integrations/partner-integrations.module.ts
Tamaño: 740 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { HttpModule } from '@nestjs/axios';
import { Module } from '@nestjs/common';
import { CommunityOrganizationRepository, CommunityUserRepository } from '@novu/dal';
import { BridgeModule } from '../bridge';
import { EnvironmentsModuleV1 } from '../environments-v1/environments-v1.module';
import { SharedModule } from '../shared/shared.module';
import { PartnerIntegrationsController } from './partner-integrations.controller';
import { USE_CASES } from './usecases';

@Module({
  imports: [SharedModule, HttpModule, EnvironmentsModuleV1, BridgeModule],
  providers: [...USE_CASES, CommunityUserRepository, CommunityOrganizationRepository],
  controllers: [PartnerIntegrationsController],
})
export class PartnerIntegrationsModule {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class PartnerIntegrationsModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/partner-integrations/dtos/create-vercel-integration-request.dto.ts
Tamaño: 226 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsString } from 'class-validator';

export class CreateVercelIntegrationRequestDto {
  @IsDefined()
  @IsString()
  vercelIntegrationCode: string;

  @IsDefined()
  @IsString()
  configurationId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateVercelIntegrationRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/partner-integrations/dtos/create-vercel-integration-response.dto.ts
Tamaño: 133 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined } from 'class-validator';

export class CreateVercelIntegrationResponseDto {
  @IsDefined()
  success: boolean;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateVercelIntegrationResponseDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/partner-integrations/dtos/update-vercel-integration-request.dto.ts
Tamaño: 213 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsString } from 'class-validator';

export class UpdateVercelIntegrationRequestDto {
  @IsDefined()
  data: Record<string, string[]>;

  @IsDefined()
  @IsString()
  configurationId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateVercelIntegrationRequestDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/partner-integrations/usecases/index.ts
Tamaño: 677 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CreateVercelIntegration } from './create-vercel-integration/create-vercel-integration.usecase';
import { GetVercelIntegration } from './get-vercel-integration/get-vercel-integration.usecase';
import { GetVercelIntegrationProjects } from './get-vercel-projects/get-vercel-integration-projects.usecase';
import { ProcessVercelWebhook } from './process-vercel-webhook/process-vercel-webhook.usecase';
import { UpdateVercelIntegration } from './update-vercel-integration/update-vercel-integration.usecase';

export const USE_CASES = [
  CreateVercelIntegration,
  GetVercelIntegrationProjects,
  GetVercelIntegration,
  UpdateVercelIntegration,
  ProcessVercelWebhook,
];


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/partner-integrations/usecases/create-vercel-integration/create-vercel-integration.command.ts
Tamaño: 306 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class CreateVercelIntegrationCommand extends EnvironmentWithUserCommand {
  @IsDefined()
  vercelIntegrationCode: string;
  @IsDefined()
  configurationId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateVercelIntegrationCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/partner-integrations/usecases/create-vercel-integration/create-vercel-integration.spec.ts
Tamaño: 4430 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { HttpService } from '@nestjs/axios';
import { BadRequestException } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { AnalyticsService } from '@novu/application-generic';
import { OrganizationRepository, PartnerTypeEnum } from '@novu/dal';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { of } from 'rxjs';
import { assert, match, restore, stub } from 'sinon';
import { CreateVercelIntegration } from './create-vercel-integration.usecase';

describe('CreateVercelIntegration', () => {
  let createVercelIntegration: CreateVercelIntegration;
  let session: UserSession;
  let httpServiceMock;
  let organizationRepositoryMock;
  let analyticsServiceMock;
  beforeEach(async () => {
    httpServiceMock = {
      post: stub().returns(
        of({
          data: {
            access_token: 'test-token',
            team_id: 'test-team-id',
          },
        })
      ),
    };

    organizationRepositoryMock = {
      upsertPartnerConfiguration: stub().resolves(true),
    };

    analyticsServiceMock = {
      track: stub().resolves(),
    };

    const moduleRef = await Test.createTestingModule({
      providers: [
        CreateVercelIntegration,
        {
          provide: HttpService,
          useValue: httpServiceMock,
        },
        {
          provide: OrganizationRepository,
          useValue: organizationRepositoryMock,
        },
        { provide: AnalyticsService, useValue: analyticsServiceMock },
      ],
    }).compile();

    session = new UserSession();
    await session.initialize();
    createVercelIntegration = moduleRef.get<CreateVercelIntegration>(CreateVercelIntegration);

    // @ts-ignore
    process.env.VERCEL_CLIENT_ID = 'test-client-id';
    // @ts-ignore
    process.env.VERCEL_CLIENT_SECRET = 'test-client-secret';
    // @ts-ignore
    process.env.VERCEL_REDIRECT_URI = 'test-redirect-uri';
    // @ts-ignore
    process.env.VERCEL_BASE_URL = 'https://api.vercel.com';
  });

  afterEach(() => {
    restore();
  });

  it('should successfully set vercel configuration', async () => {
    const command = {
      organizationId: session.organization._id,
      vercelIntegrationCode: 'test-code',
      configurationId: 'test-config-id',
      userId: session.user._id,
      environmentId: session.environment._id,
    };

    const result = await createVercelIntegration.execute(command);

    expect(result.success).to.equal(true);

    // Verify HTTP call
    assert.calledWith(
      httpServiceMock.post,
      'https://api.vercel.com/v2/oauth/access_token',
      match.instanceOf(URLSearchParams),
      {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
      }
    );

    // Verify the URLSearchParams content
    const postCall = httpServiceMock.post.getCall(0);
    const [, postData] = postCall.args;
    expect(postData.get('code')).to.equal('test-code');
    expect(postData.get('client_id')).to.equal('test-client-id');
    expect(postData.get('client_secret')).to.equal('test-client-secret');
    expect(postData.get('redirect_uri')).to.equal('test-redirect-uri');

    // Verify organization repository call
    assert.calledWith(organizationRepositoryMock.upsertPartnerConfiguration, {
      organizationId: command.organizationId,
      configuration: {
        accessToken: 'test-token',
        configurationId: command.configurationId,
        teamId: 'test-team-id',
        partnerType: PartnerTypeEnum.VERCEL,
      },
    });

    assert.calledWith(
      analyticsServiceMock.track,
      'Create Vercel Integration - [Partner Integrations]',
      command.userId,
      { _organization: command.organizationId }
    );
  });

  it('should throw BadRequestException when Vercel returns an error', async () => {
    httpServiceMock.post.throws(new Error('Vercel error'));

    try {
      await createVercelIntegration.execute({
        userId: session.user._id,
        organizationId: session.organization._id,
        environmentId: session.environment._id,
        vercelIntegrationCode: 'test-code',
        configurationId: 'test-config-id',
      });
      throw new Error('Should not reach here');
    } catch (error) {
      expect(error).to.be.instanceOf(BadRequestException);
      expect(error.message).to.equal('Vercel error');
      assert.notCalled(organizationRepositoryMock.upsertPartnerConfiguration);
    }
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - VERCEL_BASE_URL('https://api.vercel.com';
  });

  afterEach(())

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/partner-integrations/usecases/create-vercel-integration/create-vercel-integration.usecase.ts
Tamaño: 2609 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { HttpService } from '@nestjs/axios';
import { BadRequestException, Injectable } from '@nestjs/common';
import { AnalyticsService } from '@novu/application-generic';
import { OrganizationRepository, PartnerTypeEnum } from '@novu/dal';
import { lastValueFrom } from 'rxjs';

import { CreateVercelIntegrationResponseDto } from '../../dtos/create-vercel-integration-response.dto';
import { CreateVercelIntegrationCommand } from './create-vercel-integration.command';

@Injectable()
export class CreateVercelIntegration {
  constructor(
    private httpService: HttpService,
    private organizationRepository: OrganizationRepository,
    private analyticsService: AnalyticsService
  ) {}

  async execute(command: CreateVercelIntegrationCommand): Promise<CreateVercelIntegrationResponseDto> {
    try {
      const tokenData = await this.getVercelToken(command.vercelIntegrationCode);

      const configuration = {
        accessToken: tokenData.accessToken,
        configurationId: command.configurationId,
        teamId: tokenData.teamId,
        partnerType: PartnerTypeEnum.VERCEL,
      };

      await this.organizationRepository.upsertPartnerConfiguration({
        organizationId: command.organizationId,
        configuration,
      });

      this.analyticsService.track('Create Vercel Integration - [Partner Integrations]', command.userId, {
        _organization: command.organizationId,
      });

      return {
        success: true,
      };
    } catch (error) {
      throw new BadRequestException(
        error?.response?.data?.error_description || error?.response?.data?.message || error.message
      );
    }
  }

  private async getVercelToken(code: string): Promise<{
    accessToken: string;
    teamId: string;
  }> {
    try {
      const postData = new URLSearchParams({
        code: code as string,
        client_id: process.env.VERCEL_CLIENT_ID as string,
        client_secret: process.env.VERCEL_CLIENT_SECRET as string,
        redirect_uri: process.env.VERCEL_REDIRECT_URI as string,
      });

      const response = await lastValueFrom(
        this.httpService.post(`${process.env.VERCEL_BASE_URL}/v2/oauth/access_token`, postData, {
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
          },
        })
      );

      const { data } = response;

      return {
        accessToken: data.access_token,
        teamId: data.team_id,
      };
    } catch (error) {
      throw new BadRequestException(
        error?.response?.data?.error_description || error?.response?.data?.message || error.message
      );
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class CreateVercelIntegration

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/partner-integrations/usecases/get-vercel-integration/get-vercel-integration.command.ts
Tamaño: 195 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class GetVercelIntegrationCommand extends EnvironmentWithUserCommand {
  configurationId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetVercelIntegrationCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/partner-integrations/usecases/get-vercel-integration/get-vercel-integration.spec.ts
Tamaño: 2859 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Test } from '@nestjs/testing';
import { OrganizationRepository } from '@novu/dal';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { assert, restore, stub } from 'sinon';

import { GetVercelIntegration } from './get-vercel-integration.usecase';

describe('GetVercelIntegration', () => {
  let getVercelIntegration: GetVercelIntegration;
  let session: UserSession;
  let organizationRepositoryMock;

  beforeEach(async () => {
    organizationRepositoryMock = {
      findByPartnerConfigurationId: stub().resolves([
        {
          _id: 'org-id-1',
          partnerConfigurations: [
            {
              projectIds: ['project-1', 'project-2'],
            },
          ],
        },
        {
          _id: 'org-id-2',
          partnerConfigurations: [
            {
              projectIds: ['project-2', 'project-3'],
            },
          ],
        },
      ]),
    };

    const moduleRef = await Test.createTestingModule({
      providers: [
        GetVercelIntegration,
        {
          provide: OrganizationRepository,
          useValue: organizationRepositoryMock,
        },
      ],
    }).compile();

    session = new UserSession();
    await session.initialize();
    getVercelIntegration = moduleRef.get<GetVercelIntegration>(GetVercelIntegration);
  });

  afterEach(() => {
    restore();
  });

  it('should get vercel configuration details', async () => {
    const command = {
      userId: session.user._id,
      organizationId: session.organization._id,
      environmentId: session.environment._id,
      configurationId: 'test-config-id',
    };

    const result = await getVercelIntegration.execute(command);

    expect(result).to.be.an('array');
    expect(result[0]).to.deep.equal({
      organizationId: 'org-id-1',
      projectIds: ['project-1', 'project-2'],
    });
    expect(result[1]).to.deep.equal({
      organizationId: 'org-id-2',
      projectIds: ['project-2', 'project-3'],
    });

    assert.calledOnceWithExactly(organizationRepositoryMock.findByPartnerConfigurationId, {
      userId: command.userId,
      configurationId: command.configurationId,
    });
  });

  it('should return empty array when no configurations found', async () => {
    organizationRepositoryMock.findByPartnerConfigurationId.resolves([]);

    const command = {
      userId: session.user._id,
      organizationId: session.organization._id,
      environmentId: session.environment._id,
      configurationId: 'test-config-id',
    };

    const result = await getVercelIntegration.execute(command);

    expect(result).to.be.an('array');
    expect(result).to.have.length(0);

    assert.calledOnceWithExactly(organizationRepositoryMock.findByPartnerConfigurationId, {
      userId: command.userId,
      configurationId: command.configurationId,
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - getVercelIntegration(moduleRef.get<GetVercelIntegration>(GetVercelIntegration);
  });

  afterEach(())
 - result(await getVercelIntegration.execute(command);

    expect(result).to.be.an('array');
    expect(resul...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/partner-integrations/usecases/get-vercel-integration/get-vercel-integration.usecase.ts
Tamaño: 1211 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { OrganizationRepository } from '@novu/dal';

import { GetVercelIntegrationCommand } from './get-vercel-integration.command';

@Injectable()
export class GetVercelIntegration {
  constructor(private organizationRepository: OrganizationRepository) {}

  async execute(command: GetVercelIntegrationCommand) {
    return await this.getConfigurationDetails(command);
  }

  private async getConfigurationDetails(command: GetVercelIntegrationCommand) {
    const details = await this.organizationRepository.findByPartnerConfigurationId({
      userId: command.userId,
      configurationId: command.configurationId,
    });

    return details.reduce(
      (acc, curr) => {
        if (
          curr.partnerConfigurations &&
          curr.partnerConfigurations.length >= 1 &&
          curr.partnerConfigurations[0].projectIds &&
          curr.partnerConfigurations[0].projectIds.length >= 1
        ) {
          acc.push({
            organizationId: curr._id,
            projectIds: curr.partnerConfigurations[0].projectIds,
          });
        }

        return acc;
      },
      [] as { organizationId: string; projectIds: string[] }[]
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - details(await this.organizationRepository.findByPartnerConfigurationId({
      userId: command.userId,
     ...)
Declaraciones 'export' encontradas:
- export class GetVercelIntegration

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/partner-integrations/usecases/get-vercel-projects/get-vercel-integration-projects.command.ts
Tamaño: 351 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { IsDefined, IsOptional, IsString } from 'class-validator';
import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class GetVercelIntegrationProjectsCommand extends EnvironmentWithUserCommand {
  @IsDefined()
  @IsString()
  configurationId: string;

  @IsOptional()
  @IsString()
  nextPage?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class GetVercelIntegrationProjectsCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/partner-integrations/usecases/get-vercel-projects/get-vercel-integration-projects.spec.ts
Tamaño: 4181 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { HttpService } from '@nestjs/axios';
import { BadRequestException } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { OrganizationRepository } from '@novu/dal';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { of } from 'rxjs';
import { assert, restore, stub } from 'sinon';
import { GetVercelIntegrationProjects } from './get-vercel-integration-projects.usecase';

describe('GetVercelIntegrationProjects', () => {
  let getVercelIntegrationProjects: GetVercelIntegrationProjects;
  let session: UserSession;
  let httpServiceMock;
  let organizationRepositoryMock;

  beforeEach(async () => {
    httpServiceMock = {
      get: stub().returns(
        of({
          data: {
            projects: [
              { id: 'project-1', name: 'Project One' },
              { id: 'project-2', name: 'Project Two' },
            ],
            pagination: {
              next: 'next-page-token',
            },
          },
        })
      ),
    };

    organizationRepositoryMock = {
      findByPartnerConfigurationId: stub().resolves([
        {
          partnerConfigurations: [
            {
              configurationId: 'test-config-id',
              accessToken: 'test-token',
              teamId: 'test-team-id',
            },
          ],
        },
      ]),
    };

    const moduleRef = await Test.createTestingModule({
      providers: [
        GetVercelIntegrationProjects,
        {
          provide: HttpService,
          useValue: httpServiceMock,
        },
        {
          provide: OrganizationRepository,
          useValue: organizationRepositoryMock,
        },
      ],
    }).compile();

    session = new UserSession();
    await session.initialize();
    getVercelIntegrationProjects = moduleRef.get<GetVercelIntegrationProjects>(GetVercelIntegrationProjects);
  });

  afterEach(() => {
    restore();
  });

  it('should get vercel projects successfully', async () => {
    const command = {
      userId: session.user._id,
      organizationId: session.organization._id,
      environmentId: session.environment._id,
      configurationId: 'test-config-id',
    };

    const result = await getVercelIntegrationProjects.execute(command);

    expect(result.projects).to.have.length(2);
    expect(result.projects[0]).to.deep.equal({
      name: 'Project One',
      id: 'project-1',
    });
    expect(result.pagination).to.deep.equal({
      next: 'next-page-token',
    });

    assert.calledWith(organizationRepositoryMock.findByPartnerConfigurationId, {
      userId: command.userId,
      configurationId: command.configurationId,
    });

    const expectedUrl = `${process.env.VERCEL_BASE_URL}/v10/projects?limit=100&teamId=test-team-id`;
    assert.calledWith(httpServiceMock.get, expectedUrl, {
      headers: {
        Authorization: 'Bearer test-token',
      },
    });
  });

  it('should throw BadRequestException when no configuration found', async () => {
    organizationRepositoryMock.findByPartnerConfigurationId.resolves([]);

    try {
      await getVercelIntegrationProjects.execute({
        userId: session.user._id,
        organizationId: session.organization._id,
        environmentId: session.environment._id,
        configurationId: 'test-config-id',
      });
      throw new Error('Should not reach here');
    } catch (error) {
      expect(error).to.be.instanceOf(BadRequestException);
      expect(error.message).to.equal('No partner configuration found.');
      assert.notCalled(httpServiceMock.get);
    }
  });

  it('should throw BadRequestException when HTTP request fails', async () => {
    httpServiceMock.get.throws(new Error('HTTP Error'));

    try {
      await getVercelIntegrationProjects.execute({
        userId: session.user._id,
        organizationId: session.organization._id,
        environmentId: session.environment._id,
        configurationId: 'test-config-id',
      });
      throw new Error('Should not reach here');
    } catch (error) {
      expect(error).to.be.instanceOf(BadRequestException);
      expect(error.message).to.equal('HTTP Error');
      assert.called(httpServiceMock.get);
    }
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - getVercelIntegrationProjects(moduleRef.get<GetVercelIntegrationProjects>(GetVercelIntegrationProjects);
  });

  afterEach(())
 - teamId(test-team-id`;
    assert.calledWith(httpServiceMock.get, expectedUrl, {
      headers: {
        Au...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/partner-integrations/usecases/get-vercel-projects/get-vercel-integration-projects.usecase.ts
Tamaño: 2803 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { HttpService } from '@nestjs/axios';
import { BadRequestException, Injectable } from '@nestjs/common';
import { OrganizationRepository } from '@novu/dal';
import { lastValueFrom } from 'rxjs';

import { GetVercelIntegrationProjectsCommand } from './get-vercel-integration-projects.command';

@Injectable()
export class GetVercelIntegrationProjects {
  constructor(
    private httpService: HttpService,
    private organizationRepository: OrganizationRepository
  ) {}

  async execute(command: GetVercelIntegrationProjectsCommand) {
    try {
      const configuration = await this.getCurrentOrgPartnerConfiguration({
        userId: command.userId,
        configurationId: command.configurationId,
      });

      if (!configuration || !configuration.accessToken) {
        throw new BadRequestException({
          message: 'No partner configuration found.',
          type: 'vercel',
        });
      }

      const projects = await this.getVercelProjects(configuration.accessToken, configuration.teamId, command.nextPage);

      return projects;
    } catch (error) {
      throw new BadRequestException(error.message);
    }
  }

  async getCurrentOrgPartnerConfiguration({ userId, configurationId }: { userId: string; configurationId: string }) {
    const orgsWithIntegration = await this.organizationRepository.findByPartnerConfigurationId({
      userId,
      configurationId,
    });

    if (orgsWithIntegration.length === 0) {
      throw new BadRequestException({
        message: 'No partner configuration found.',
        type: 'vercel',
      });
    }

    const firstOrg = orgsWithIntegration[0];
    const configuration = firstOrg.partnerConfigurations?.find((config) => config.configurationId === configurationId);
    if (!firstOrg.partnerConfigurations?.length || !configuration) {
      throw new BadRequestException({
        message: 'No partner configuration found',
        type: 'vercel',
      });
    }

    return configuration;
  }

  private async getVercelProjects(accessToken: string, teamId: string | null, until?: string) {
    const queryParams = new URLSearchParams();
    queryParams.set('limit', '100');

    if (teamId) {
      queryParams.set('teamId', teamId);
    }

    if (until) {
      queryParams.set('until', until);
    }

    const response = await lastValueFrom(
      this.httpService.get(`${process.env.VERCEL_BASE_URL}/v10/projects?${queryParams.toString()}`, {
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      })
    );

    return { projects: this.mapProjects(response.data.projects), pagination: response.data.pagination };
  }

  private mapProjects(projects) {
    return projects.map((project) => {
      return {
        name: project.name,
        id: project.id,
      };
    });
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - configuration(firstOrg.partnerConfigurations?.find((config))
 - response(await lastValueFrom(
      this.httpService.get(`${process.env.VERCEL_BASE_URL}/v10/projects?${query...)
Declaraciones 'export' encontradas:
- export class GetVercelIntegrationProjects

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/partner-integrations/usecases/process-vercel-webhook/process-vercel-webhook.command.ts
Tamaño: 239 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BaseCommand } from '@novu/application-generic';
import { IsDefined } from 'class-validator';

export class ProcessVercelWebhookCommand extends BaseCommand {
  @IsDefined()
  signatureHeader: string;

  @IsDefined()
  body: any;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ProcessVercelWebhookCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/partner-integrations/usecases/process-vercel-webhook/process-vercel-webhook.spec.ts
Tamaño: 5655 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import crypto from 'node:crypto';
import { BadRequestException } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { PinoLogger } from '@novu/application-generic';
import {
  CommunityOrganizationRepository,
  CommunityUserRepository,
  EnvironmentRepository,
  MemberRepository,
} from '@novu/dal';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { assert, restore, stub } from 'sinon';
import { Sync } from '../../../bridge/usecases/sync';
import { ProcessVercelWebhook } from './process-vercel-webhook.usecase';

describe('ProcessVercelWebhook', () => {
  let processVercelWebhook: ProcessVercelWebhook;
  let session: UserSession;
  let organizationRepositoryMock;
  let environmentRepositoryMock;
  let memberRepositoryMock;
  let communityUserRepositoryMock;
  let syncUsecaseMock;
  let loggerMock;
  beforeEach(async () => {
    organizationRepositoryMock = {
      find: stub().resolves([{ _id: 'test-org-id' }]),
    };

    environmentRepositoryMock = {
      findOne: stub().resolves({
        _id: 'test-env-id',
        _organizationId: 'test-org-id',
      }),
    };

    memberRepositoryMock = {
      getOrganizationOwnerAccount: stub().resolves({
        _userId: 'test-user-id',
      }),
    };

    communityUserRepositoryMock = {
      findOne: stub().resolves({
        _id: 'test-internal-user-id',
      }),
    };

    syncUsecaseMock = {
      execute: stub().resolves(true),
    };

    loggerMock = {
      info: stub(),
      error: stub(),
      warn: stub(),
      debug: stub(),
      trace: stub(),
      setContext: stub(),
    };

    const moduleRef = await Test.createTestingModule({
      providers: [
        ProcessVercelWebhook,
        {
          provide: CommunityOrganizationRepository,
          useValue: organizationRepositoryMock,
        },
        {
          provide: EnvironmentRepository,
          useValue: environmentRepositoryMock,
        },
        {
          provide: MemberRepository,
          useValue: memberRepositoryMock,
        },
        {
          provide: CommunityUserRepository,
          useValue: communityUserRepositoryMock,
        },
        {
          provide: Sync,
          useValue: syncUsecaseMock,
        },
        {
          provide: PinoLogger,
          useValue: loggerMock,
        },
      ],
    }).compile();

    // @ts-ignore
    process.env.VERCEL_CLIENT_SECRET = 'test-secret';
    session = new UserSession();
    await session.initialize();
    processVercelWebhook = moduleRef.get<ProcessVercelWebhook>(ProcessVercelWebhook);
  });

  afterEach(() => {
    restore();
  });

  it('should skip non-deployment events', async () => {
    const result = await processVercelWebhook.execute({
      body: {
        type: 'other-event',
      },
      signatureHeader: 'test-signature',
    });

    expect(result).to.equal(true);
    assert.notCalled(organizationRepositoryMock.find);
  });

  it('should process deployment succeeded event', async () => {
    const body = {
      type: 'deployment.succeeded',
      payload: {
        team: { id: 'team-id' },
        project: { id: 'project-id' },
        deployment: { url: 'test.vercel.app' },
        target: 'production',
      },
    };

    const hmac = crypto
      .createHmac('sha1', process.env.VERCEL_CLIENT_SECRET ?? '')
      .update(JSON.stringify(body))
      .digest('hex');

    const result = await processVercelWebhook.execute({
      body,
      signatureHeader: hmac,
    });

    expect(result).to.equal(true);

    assert.calledWith(organizationRepositoryMock.find, {
      'partnerConfigurations.teamId': 'team-id',
      'partnerConfigurations.projectIds': 'project-id',
    });

    assert.calledWith(environmentRepositoryMock.findOne, {
      _organizationId: 'test-org-id',
      name: 'Production',
    });

    assert.calledWith(memberRepositoryMock.getOrganizationOwnerAccount, 'test-org-id');

    assert.calledWith(communityUserRepositoryMock.findOne, {
      externalId: 'test-user-id',
    });

    assert.calledWith(syncUsecaseMock.execute, {
      organizationId: 'test-org-id',
      userId: 'test-internal-user-id',
      environmentId: 'test-env-id',
      bridgeUrl: 'https://test.vercel.app/api/novu',
      source: 'vercel',
    });
  });

  it('should throw error for invalid signature', async () => {
    const body = {
      type: 'deployment.succeeded',
      payload: {
        team: { id: 'team-id' },
        project: { id: 'project-id' },
        deployment: { url: 'test.vercel.app' },
        target: 'production',
      },
    };

    try {
      await processVercelWebhook.execute({
        body,
        signatureHeader: 'invalid-signature',
      });
      throw new Error('Should not reach here');
    } catch (error) {
      expect(error).to.be.instanceOf(BadRequestException);
      expect(error.message).to.equal('Invalid signature');
      assert.notCalled(organizationRepositoryMock.find);
    }
  });

  it('should throw error for missing signature', async () => {
    const body = {
      type: 'deployment.succeeded',
      payload: {
        team: { id: 'team-id' },
        project: { id: 'project-id' },
        deployment: { url: 'test.vercel.app' },
        target: 'production',
      },
    };

    try {
      await processVercelWebhook.execute({
        body,
        signatureHeader: '',
      });
      throw new Error('Should not reach here');
    } catch (error) {
      expect(error).to.be.instanceOf(BadRequestException);
      expect(error.message).to.equal('Missing signature or secret');
      assert.notCalled(organizationRepositoryMock.find);
    }
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - processVercelWebhook(moduleRef.get<ProcessVercelWebhook>(ProcessVercelWebhook);
  });

  afterEach(())
 - result(await processVercelWebhook.execute({
      body: {
        type: 'other-event',
      },
      signa...)
 - result(await processVercelWebhook.execute({
      body,
      signatureHeader: hmac,
    });

    expect(re...)
 - body({
      type: 'deployment.succeeded',
      payload: {
        team: { id: 'team-id' },
        proj...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/partner-integrations/usecases/process-vercel-webhook/process-vercel-webhook.usecase.ts
Tamaño: 3942 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import crypto from 'node:crypto';
import { BadRequestException, Injectable } from '@nestjs/common';
import { PinoLogger } from '@novu/application-generic';
import {
  CommunityOrganizationRepository,
  CommunityUserRepository,
  EnvironmentEntity,
  EnvironmentRepository,
  MemberRepository,
} from '@novu/dal';
import { Sync } from '../../../bridge/usecases/sync';
import { ProcessVercelWebhookCommand } from './process-vercel-webhook.command';

@Injectable()
export class ProcessVercelWebhook {
  constructor(
    private organizationRepository: CommunityOrganizationRepository,
    private environmentRepository: EnvironmentRepository,
    private syncUsecase: Sync,
    private memberRepository: MemberRepository,
    private communityUserRepository: CommunityUserRepository,
    private logger: PinoLogger
  ) {
    this.logger.setContext(this.constructor.name);
  }

  async execute(command: ProcessVercelWebhookCommand) {
    const eventType = command.body.type;
    if (eventType !== 'deployment.succeeded') {
      this.logger.info(`Skipping processing Vercel webhook event: ${eventType}`);

      return true;
    }

    const teamId = command.body.payload.team.id;
    const projectId = command.body.payload.project.id;
    const deploymentUrl = command.body.payload.deployment.url;
    const vercelEnvironment = command.body.payload.target || 'preview';

    this.logger.info(
      {
        teamId,
        projectId,
        vercelEnvironment,
        deploymentUrl,
      },
      `Processing vercel webhook for ${vercelEnvironment}`
    );

    this.verifySignature(command.signatureHeader, command.body);

    const organizations = await this.organizationRepository.find(
      {
        'partnerConfigurations.teamId': teamId,
        'partnerConfigurations.projectIds': projectId,
      },
      { 'partnerConfigurations.$': 1 }
    );

    if (!organizations || organizations.length === 0) {
      this.logger.error({ teamId, projectId }, 'Organization not found for vercel webhook integration');

      throw new BadRequestException('Organization not found');
    }

    for (const organization of organizations) {
      let environment: EnvironmentEntity | null;

      // TODO: we should think about how to handle different Vercel environments that are not production or development
      if (vercelEnvironment === 'production') {
        environment = await this.environmentRepository.findOne({
          _organizationId: organization._id,
          name: 'Production',
        });
      } else {
        environment = await this.environmentRepository.findOne({
          _organizationId: organization._id,
          name: 'Development',
        });
      }

      if (!environment) {
        throw new BadRequestException('Environment Not Found');
      }

      const orgOwner = await this.memberRepository.getOrganizationOwnerAccount(environment._organizationId);
      if (!orgOwner) {
        throw new BadRequestException('Organization owner not found');
      }

      const internalUser = await this.communityUserRepository.findOne({ externalId: orgOwner?._userId });

      if (!internalUser) {
        throw new BadRequestException('User not found');
      }

      await this.syncUsecase.execute({
        organizationId: environment._organizationId,
        userId: internalUser?._id as string,
        environmentId: environment._id,
        bridgeUrl: `https://${deploymentUrl}/api/novu`,
        source: 'vercel',
      });
    }

    return true;
  }

  private verifySignature(signature: string, body: any): void {
    const secret = process.env.VERCEL_CLIENT_SECRET;

    if (!signature || !secret) {
      throw new BadRequestException('Missing signature or secret');
    }

    const computedSignature = crypto.createHmac('sha1', secret).update(JSON.stringify(body)).digest('hex');

    if (signature !== computedSignature) {
      throw new BadRequestException('Invalid signature');
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ProcessVercelWebhook

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/partner-integrations/usecases/update-vercel-integration/update-vercel-integration.command.ts
Tamaño: 232 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EnvironmentWithUserCommand } from '../../../shared/commands/project.command';

export class UpdateVercelIntegrationCommand extends EnvironmentWithUserCommand {
  data: Record<string, string[]>;
  configurationId: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpdateVercelIntegrationCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/partner-integrations/usecases/update-vercel-integration/update-vercel-integration.spec.ts
Tamaño: 14206 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { HttpService } from '@nestjs/axios';
import { BadRequestException } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { AnalyticsService, PinoLogger } from '@novu/application-generic';
import { CommunityUserRepository, EnvironmentRepository, MemberRepository, OrganizationRepository } from '@novu/dal';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import { of } from 'rxjs';
import { assert, restore, stub } from 'sinon';
import { Sync } from '../../../bridge/usecases/sync';
import { UpdateVercelIntegration } from './update-vercel-integration.usecase';

describe('UpdateVercelIntegration', () => {
  let updateVercelIntegration: UpdateVercelIntegration;
  let session: UserSession;
  let httpServiceMock;
  let environmentRepositoryMock;
  let organizationRepositoryMock;
  let analyticsServiceMock;
  let syncMock;
  let memberRepositoryMock;
  let communityUserRepositoryMock;
  let loggerMock;

  beforeEach(async () => {
    // @ts-ignore
    process.env.VERCEL_BASE_URL = 'https://api.vercel.com';

    httpServiceMock = {
      get: stub().callsFake((url, config) => {
        if (url.includes('/v4/projects') && url.includes('teamId=test-team-id')) {
          return of({
            data: {
              projects: [
                {
                  id: 'project-1',
                  env: [
                    { id: 'env-1', key: 'NEXT_PUBLIC_NOVU_CLIENT_APP_ID', target: ['production'] },
                    { id: 'env-2', key: 'NOVU_CLIENT_APP_ID', target: ['production'] },
                    { id: 'env-3', key: 'NOVU_SECRET_KEY', target: ['production'] },
                    { id: 'env-4', key: 'NEXT_PUBLIC_NOVU_APPLICATION_IDENTIFIER', target: ['production'] },
                  ],
                },
              ],
            },
          });
        } else if (url.includes('/v9/projects/project-1') && url.includes('teamId=test-team-id')) {
          return of({
            data: {
              targets: {
                production: {
                  alias: ['prod-alias.vercel.app'],
                },
                development: {
                  alias: ['dev-alias.vercel.app'],
                },
              },
            },
          });
        }

        // Default response for any other URLs
        return of({ data: {} });
      }),
      post: stub().returns(of({ data: { success: true } })),
      delete: stub().returns(of({ data: { success: true } })),
    };

    organizationRepositoryMock = {
      findByPartnerConfigurationId: stub().resolves([
        {
          partnerConfigurations: [
            {
              configurationId: 'test-config-id',
              accessToken: 'test-token',
              teamId: 'test-team-id',
              projectIds: ['project-1'],
            },
          ],
        },
      ]),
      bulkUpdatePartnerConfiguration: stub().resolves(true),
    };

    analyticsServiceMock = {
      track: stub().resolves(),
    };

    syncMock = {
      execute: stub().resolves(),
    };

    environmentRepositoryMock = {
      find: stub().resolves([
        {
          _id: 'env-id',
          name: 'Production',
          identifier: 'prod',
          _organizationId: 'org-id',
          apiKeys: [{ key: 'encrypted-key' }],
        },
        {
          _id: 'env-id-2',
          name: 'Development',
          identifier: 'dev',
          _organizationId: 'org-id',
          apiKeys: [{ key: 'encrypted-key-2' }],
        },
      ]),
    };

    memberRepositoryMock = {
      getOrganizationOwnerAccount: stub().resolves({ _userId: 'admin-id' }),
    };

    communityUserRepositoryMock = {
      findOne: stub().resolves({ _id: 'internal-user-id' }),
    };

    loggerMock = {
      log: stub(),
      error: stub(),
      warn: stub(),
      debug: stub(),
      info: stub(),
      trace: stub(),
      setContext: stub(),
    };

    const moduleRef = await Test.createTestingModule({
      providers: [
        UpdateVercelIntegration,
        { provide: HttpService, useValue: httpServiceMock },
        { provide: EnvironmentRepository, useValue: environmentRepositoryMock },
        { provide: OrganizationRepository, useValue: organizationRepositoryMock },
        { provide: AnalyticsService, useValue: analyticsServiceMock },
        { provide: Sync, useValue: syncMock },
        { provide: MemberRepository, useValue: memberRepositoryMock },
        { provide: CommunityUserRepository, useValue: communityUserRepositoryMock },
        { provide: PinoLogger, useValue: loggerMock },
      ],
    }).compile();

    session = new UserSession();
    await session.initialize();
    updateVercelIntegration = moduleRef.get<UpdateVercelIntegration>(UpdateVercelIntegration);
  });

  afterEach(() => {
    restore();
  });

  it('should update vercel configuration successfully', async () => {
    const command = {
      userId: session.user._id,
      organizationId: session.organization._id,
      environmentId: session.environment._id,
      configurationId: 'test-config-id',
      data: {
        'org-id': ['project-1'],
      },
    };

    const result = await updateVercelIntegration.execute(command);

    expect(result.success).to.equal(true);

    // Verify existing projects lookup
    assert.calledWith(organizationRepositoryMock.findByPartnerConfigurationId, {
      userId: command.userId,
      configurationId: command.configurationId,
    });

    // Verify project environment variables lookup
    assert.calledWith(httpServiceMock.get, `${process.env.VERCEL_BASE_URL}/v4/projects?teamId=test-team-id`, {
      headers: {
        Authorization: 'Bearer test-token',
      },
    });

    // Verify environment variable deletion calls
    assert.calledWith(
      httpServiceMock.delete,
      `${process.env.VERCEL_BASE_URL}/v9/projects/project-1/env/env-1?teamId=test-team-id`,
      {
        headers: {
          Authorization: 'Bearer test-token',
        },
      }
    );
    assert.calledWith(
      httpServiceMock.delete,
      `${process.env.VERCEL_BASE_URL}/v9/projects/project-1/env/env-2?teamId=test-team-id`,
      {
        headers: {
          Authorization: 'Bearer test-token',
        },
      }
    );
    assert.calledWith(
      httpServiceMock.delete,
      `${process.env.VERCEL_BASE_URL}/v9/projects/project-1/env/env-3?teamId=test-team-id`,
      {
        headers: {
          Authorization: 'Bearer test-token',
        },
      }
    );
    assert.calledWith(
      httpServiceMock.delete,
      `${process.env.VERCEL_BASE_URL}/v9/projects/project-1/env/env-4?teamId=test-team-id`,
      {
        headers: {
          Authorization: 'Bearer test-token',
        },
      }
    );

    assert.calledWith(organizationRepositoryMock.bulkUpdatePartnerConfiguration, {
      userId: command.userId,
      data: command.data,
      configuration: {
        configurationId: 'test-config-id',
        accessToken: 'test-token',
        teamId: 'test-team-id',
        projectIds: ['project-1'],
      },
    });

    // Verify environment repository calls
    assert.calledWith(environmentRepositoryMock.find, {
      _organizationId: { $in: ['org-id'] },
    });

    // Verify environment variables setup
    assert.calledWith(
      httpServiceMock.post,
      'https://api.vercel.com/v10/projects/project-1/env?upsert=true&teamId=test-team-id',
      [
        {
          target: ['production'],
          type: 'encrypted',
          value: 'prod',
          key: 'NEXT_PUBLIC_NOVU_APPLICATION_IDENTIFIER',
        },
      ],
      {
        headers: {
          Authorization: 'Bearer test-token',
          'Content-Type': 'application/json',
        },
      }
    );

    // Verify bridge URL update
    assert.calledWith(httpServiceMock.get, 'https://api.vercel.com/v9/projects/project-1?teamId=test-team-id', {
      headers: {
        Authorization: 'Bearer test-token',
        'Content-Type': 'application/json',
      },
    });

    // Verify sync execution
    assert.calledWith(syncMock.execute, {
      organizationId: 'org-id',
      userId: 'internal-user-id',
      environmentId: 'env-id',
      bridgeUrl: 'https://prod-alias.vercel.app/api/novu',
      source: 'vercel',
    });

    // Verify analytics
    assert.calledWith(
      analyticsServiceMock.track,
      'Update Vercel Integration - [Partner Integrations]',
      command.userId,
      { _organization: command.organizationId }
    );
  });

  it('should handle projects with no environment variables', async () => {
    // Reset the stub before creating a new behavior
    httpServiceMock.get.reset();
    httpServiceMock.get.callsFake((url) => {
      if (url.includes('/v4/projects')) {
        return of({
          data: {
            projects: [
              {
                id: 'project-1',
                env: [], // Empty env array
              },
            ],
          },
        });
      }

      return of({ data: {} });
    });

    const command = {
      userId: session.user._id,
      organizationId: session.organization._id,
      environmentId: session.environment._id,
      configurationId: 'test-config-id',
      data: {
        'org-id': ['project-1'],
      },
    };

    const result = await updateVercelIntegration.execute(command);

    expect(result.success).to.equal(true);
    assert.notCalled(httpServiceMock.delete);
  });

  it('should handle projects with missing Novu environment variables', async () => {
    // Reset the stub before creating a new behavior
    httpServiceMock.get.reset();
    httpServiceMock.get.callsFake((url) => {
      if (url.includes('/v4/projects')) {
        return of({
          data: {
            projects: [
              {
                id: 'project-1',
                env: [{ id: 'env-1', key: 'OTHER_ENV_VAR' }], // Only non-Novu env var
              },
            ],
          },
        });
      }

      return of({ data: {} });
    });

    const command = {
      userId: session.user._id,
      organizationId: session.organization._id,
      environmentId: session.environment._id,
      configurationId: 'test-config-id',
      data: {
        'org-id': ['project-1'],
      },
    };

    const result = await updateVercelIntegration.execute(command);

    expect(result.success).to.equal(true);
    assert.notCalled(httpServiceMock.delete);
  });

  it('should throw BadRequestException when configuration not found', async () => {
    organizationRepositoryMock.findByPartnerConfigurationId.resolves([]);

    try {
      await updateVercelIntegration.execute({
        userId: session.user._id,
        organizationId: session.organization._id,
        environmentId: session.environment._id,
        configurationId: 'test-config-id',
        data: {},
      });
      throw new Error('Should not reach here');
    } catch (error) {
      expect(error).to.be.instanceOf(BadRequestException);
      expect(error.message).to.equal('No partner configuration found.');
      assert.notCalled(httpServiceMock.get);
      assert.notCalled(httpServiceMock.delete);
    }
  });

  it('should handle errors during project fetch', async () => {
    httpServiceMock.get.throws(new Error('HTTP Error'));

    try {
      await updateVercelIntegration.execute({
        userId: session.user._id,
        organizationId: session.organization._id,
        environmentId: session.environment._id,
        configurationId: 'test-config-id',
        data: {
          'org-id': ['project-1'],
        },
      });
      throw new Error('Should not reach here');
    } catch (error) {
      expect(error).to.be.instanceOf(BadRequestException);
      expect(error.message).to.equal('HTTP Error');
      assert.notCalled(httpServiceMock.delete);
    }
  });

  it('should handle errors during environment variable deletion', async () => {
    httpServiceMock.delete.onCall(0).throws(new Error('Delete Error'));

    try {
      await updateVercelIntegration.execute({
        userId: session.user._id,
        organizationId: session.organization._id,
        environmentId: session.environment._id,
        configurationId: 'test-config-id',
        data: {
          'org-id': ['project-1'],
        },
      });
      throw new Error('Should not reach here');
    } catch (error) {
      expect(error).to.be.instanceOf(BadRequestException);
      expect(error.message).to.equal('Delete Error');
      assert.called(httpServiceMock.get);
      assert.called(httpServiceMock.delete);
    }
  });

  it('should handle multiple projects with environment variables', async () => {
    // Reset the stub before creating a new behavior
    httpServiceMock.get.reset();
    httpServiceMock.get.callsFake((url) => {
      if (url.includes('/v4/projects')) {
        return of({
          data: {
            projects: [
              {
                id: 'project-1',
                env: [{ id: 'env-1', key: 'NEXT_PUBLIC_NOVU_CLIENT_APP_ID', target: ['production'] }],
              },
              {
                id: 'project-2',
                env: [{ id: 'env-2', key: 'NOVU_SECRET_KEY', target: ['production'] }],
              },
            ],
          },
        });
      } else if (url.includes('/v9/projects/')) {
        return of({
          data: {
            targets: {
              production: {
                alias: ['prod-alias.vercel.app'],
              },
              development: {
                alias: ['dev-alias.vercel.app'],
              },
            },
          },
        });
      }

      return of({ data: {} });
    });

    organizationRepositoryMock.findByPartnerConfigurationId.resolves([
      {
        partnerConfigurations: [{ configurationId: 'test-config-id', projectIds: ['project-1', 'project-2'] }],
      },
    ]);

    const command = {
      userId: session.user._id,
      organizationId: session.organization._id,
      environmentId: session.environment._id,
      configurationId: 'test-config-id',
      data: {
        'org-id': ['project-1', 'project-2'],
      },
    };

    const result = await updateVercelIntegration.execute(command);

    expect(result.success).to.equal(true);
    assert.calledTwice(httpServiceMock.delete);
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - httpServiceMock({
      get: stub().callsFake((url, config))
 - updateVercelIntegration(moduleRef.get<UpdateVercelIntegration>(UpdateVercelIntegration);
  });

  afterEach(())
 - teamId(test-team-id', {
      headers: {
        Authorization: 'Bearer test-token',
        'Content-Type'...)
 - result(await updateVercelIntegration.execute(command);

    expect(result.success).to.equal(true);
    asse...)
 - result(await updateVercelIntegration.execute(command);

    expect(result.success).to.equal(true);
    asse...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/partner-integrations/usecases/update-vercel-integration/update-vercel-integration.usecase.ts
Tamaño: 11874 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { HttpService } from '@nestjs/axios';
import { BadRequestException, Injectable } from '@nestjs/common';
import { AnalyticsService, decryptApiKey, PinoLogger } from '@novu/application-generic';
import {
  CommunityUserRepository,
  EnvironmentEntity,
  EnvironmentRepository,
  MemberRepository,
  OrganizationRepository,
} from '@novu/dal';
import { lastValueFrom } from 'rxjs';
import { Sync } from '../../../bridge/usecases/sync';
import { UpdateVercelIntegrationCommand } from './update-vercel-integration.command';

interface ISetEnvironment {
  name: string;
  token: string;
  projectIds: string[];
  teamId: string | null;
  applicationIdentifier: string;
  privateKey: string;
}

interface IRemoveEnvironment {
  token: string;
  teamId: string | null;
  userId: string;
  configurationId: string;
}

type ProjectDetails = {
  projectId: string;
  clientAppIdEnv?: string;
  secretKeyEnv?: string;
  nextClientAppIdEnv?: string;
  nextApplicationIdentifierEnv?: string;
};

@Injectable()
export class UpdateVercelIntegration {
  constructor(
    private httpService: HttpService,
    private organizationRepository: OrganizationRepository,
    private memberRepository: MemberRepository,
    private communityUserRepository: CommunityUserRepository,
    private environmentRepository: EnvironmentRepository,
    private syncUsecase: Sync,
    private analyticsService: AnalyticsService,
    private logger: PinoLogger
  ) {
    this.logger.setContext(this.constructor.name);
  }

  async execute(command: UpdateVercelIntegrationCommand): Promise<{ success: boolean }> {
    try {
      const { userId, organizationId, configurationId, data: orgIdsToProjectIds } = command;

      const configuration = await this.getCurrentOrgPartnerConfiguration({
        userId,
        configurationId,
      });

      await this.removeEnvVariablesFromProjects({
        teamId: configuration.teamId,
        token: configuration.accessToken,
        userId,
        configurationId,
      });

      await this.organizationRepository.bulkUpdatePartnerConfiguration({
        userId,
        data: orgIdsToProjectIds,
        configuration,
      });

      const organizationIds = Object.keys(orgIdsToProjectIds);
      const environments = await this.getEnvironments(organizationIds);

      for (const env of environments) {
        const projectIds = orgIdsToProjectIds[env._organizationId];
        await this.setEnvVariablesOnProjects({
          name: env.name,
          applicationIdentifier: env.identifier,
          privateKey: decryptApiKey(env.apiKeys[0].key),
          projectIds,
          teamId: configuration.teamId,
          token: configuration.accessToken,
        });

        try {
          await this.updateBridgeUrl(
            env._id,
            env.name,
            projectIds[0],
            configuration.accessToken,
            configuration.teamId,
            env._organizationId
          );
        } catch (error) {
          this.logger.error({ err: error }, 'Error updating bridge url');
        }
      }

      this.analyticsService.track('Update Vercel Integration - [Partner Integrations]', userId, {
        _organization: organizationId,
      });

      return { success: true };
    } catch (error) {
      throw new BadRequestException(error.message);
    }
  }

  private async updateBridgeUrl(
    environmentId: string,
    environmentName: string,
    projectId: string,
    accessToken: string,
    teamId: string,
    organizationId: string
  ) {
    try {
      const getDomainsResponse = await lastValueFrom(
        this.httpService.get(`${process.env.VERCEL_BASE_URL}/v9/projects/${projectId}?teamId=${teamId}`, {
          headers: {
            Authorization: `Bearer ${accessToken}`,
            'Content-Type': 'application/json',
          },
        })
      );

      const vercelAvailableTargets = getDomainsResponse.data?.targets;
      let vercelTarget;
      if (environmentName.toLowerCase() === 'production') {
        vercelTarget = vercelAvailableTargets?.production;
      } else {
        vercelTarget = vercelAvailableTargets?.development;
      }

      const alias = vercelTarget?.alias?.sort((a, b) => a.length - b.length)[0];
      const bridgeAlias = alias || vercelTarget?.meta?.branchAlias || vercelTarget?.automaticAliases[0];
      if (!bridgeAlias) {
        return;
      }

      const orgOwner = await this.memberRepository.getOrganizationOwnerAccount(organizationId);
      if (!orgOwner) {
        throw new BadRequestException('Organization owner not found');
      }

      const internalUser = await this.communityUserRepository.findOne({ externalId: orgOwner?._userId });
      if (!internalUser) {
        throw new BadRequestException('User not found');
      }

      await this.syncUsecase.execute({
        organizationId,
        userId: internalUser?._id as string,
        environmentId,
        bridgeUrl: `https://${bridgeAlias}/api/novu`,
        source: 'vercel',
      });
    } catch (error) {
      this.logger.error({ err: error }, 'Error updating bridge url');
    }
  }

  private async getEnvironments(organizationIds: string[]): Promise<EnvironmentEntity[]> {
    return await this.environmentRepository.find(
      {
        _organizationId: { $in: organizationIds },
      },
      'apiKeys identifier name _organizationId _id'
    );
  }

  private async setEnvVariablesOnProjects({
    name,
    applicationIdentifier,
    projectIds,
    privateKey,
    teamId,
    token,
  }: ISetEnvironment): Promise<void> {
    const target = name?.toLowerCase() === 'production' ? ['production'] : ['preview', 'development'];
    const type = 'encrypted';

    const environmentVariables = [
      {
        target,
        type,
        value: applicationIdentifier,
        key: 'NEXT_PUBLIC_NOVU_CLIENT_APP_ID',
        legacy: true,
      },
      {
        target,
        type,
        value: applicationIdentifier,
        key: 'NOVU_CLIENT_APP_ID',
        legacy: true,
      },
      {
        target,
        type,
        value: applicationIdentifier,
        key: 'NEXT_PUBLIC_NOVU_APPLICATION_IDENTIFIER',
      },
      {
        target,
        type,
        value: privateKey,
        key: 'NOVU_SECRET_KEY',
      },
    ];

    const headers = {
      Authorization: `Bearer ${token}`,
      'Content-Type': 'application/json',
    };

    const setEnvVariable = async (projectId: string, variable: (typeof environmentVariables)[0]) => {
      if (variable.legacy) {
        return;
      }

      try {
        const queryParams = new URLSearchParams();
        queryParams.set('upsert', 'true');

        if (teamId) {
          queryParams.set('teamId', teamId);
        }

        await lastValueFrom(
          this.httpService.post(
            `${process.env.VERCEL_BASE_URL}/v10/projects/${projectId}/env?${queryParams.toString()}`,
            [variable],
            { headers }
          )
        );
      } catch (error) {
        throw new BadRequestException(error.response?.data?.error || error.response?.data);
      }
    };

    await Promise.all(
      projectIds.flatMap((projectId) => environmentVariables.map((variable) => setEnvVariable(projectId, variable)))
    );
  }

  async getCurrentOrgPartnerConfiguration({ userId, configurationId }: { userId: string; configurationId: string }) {
    const orgsWithIntegration = await this.organizationRepository.findByPartnerConfigurationId({
      userId,
      configurationId,
    });

    if (orgsWithIntegration.length === 0) {
      throw new BadRequestException({
        message: 'No partner configuration found.',
        type: 'vercel',
      });
    }

    const firstOrg = orgsWithIntegration[0];
    const configuration = firstOrg.partnerConfigurations?.find((config) => config.configurationId === configurationId);
    if (!firstOrg.partnerConfigurations?.length || !configuration) {
      throw new BadRequestException({
        message: 'No partner configuration found.',
        type: 'vercel',
      });
    }

    return configuration;
  }

  private async getVercelLinkedProjects(
    accessToken: string,
    teamId: string | null,
    projectIds: string[]
  ): Promise<ProjectDetails[]> {
    const response = await lastValueFrom(
      this.httpService.get(`${process.env.VERCEL_BASE_URL}/v4/projects${teamId ? `?teamId=${teamId}` : ''}`, {
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      })
    );
    const vercelProjects = response.data.projects as any[];
    const filteredVercelProjects = vercelProjects.filter((project) => projectIds.includes(project.id));

    return ['production', 'development'].flatMap((vercelEnvironment) =>
      filteredVercelProjects.map<ProjectDetails>((project) => {
        const { id } = project;
        const vercelEnvs = project?.env;
        const nextApplicationIdentifierEnv = vercelEnvs?.find(
          (e) => e.key === 'NEXT_PUBLIC_NOVU_APPLICATION_IDENTIFIER' && e.target.includes(vercelEnvironment)
        );
        // Legacy env variable for existing Vercel integrations
        const nextClientAppIdEnv = vercelEnvs?.find(
          (e) => e.key === 'NEXT_PUBLIC_NOVU_CLIENT_APP_ID' && e.target.includes(vercelEnvironment)
        );
        // Legacy env variable for existing Vercel integrations
        const clientAppIdEnv = vercelEnvs?.find(
          (e) => e.key === 'NOVU_CLIENT_APP_ID' && e.target.includes(vercelEnvironment)
        );
        const secretKeyEnv = vercelEnvs?.find(
          (e) => e.key === 'NOVU_SECRET_KEY' && e.target.includes(vercelEnvironment)
        );

        return {
          projectId: id,
          clientAppIdEnv: clientAppIdEnv?.id,
          secretKeyEnv: secretKeyEnv?.id,
          nextClientAppIdEnv: nextClientAppIdEnv?.id,
          nextApplicationIdentifierEnv: nextApplicationIdentifierEnv?.id,
        };
      })
    );
  }

  private async removeEnvVariablesFromProjects({
    teamId,
    token,
    userId,
    configurationId,
  }: IRemoveEnvironment): Promise<void> {
    const orgsWithIntegration = await this.organizationRepository.findByPartnerConfigurationId({
      userId,
      configurationId,
    });

    const allOldProjectIds = [
      ...new Set(
        orgsWithIntegration.reduce<string[]>((acc, org) => {
          return acc.concat(org.partnerConfigurations?.[0].projectIds || []);
        }, [])
      ),
    ];

    if (allOldProjectIds.length === 0) {
      return;
    }

    const vercelLinkedProjects = await this.getVercelLinkedProjects(token, teamId, allOldProjectIds);

    const projectApiUrl = `${process.env.VERCEL_BASE_URL}/v9/projects`;

    await Promise.all(
      vercelLinkedProjects.map((detail) => {
        const urls: string[] = [];
        if (detail.nextApplicationIdentifierEnv) {
          urls.push(
            `${projectApiUrl}/${detail.projectId}/env/${detail.nextApplicationIdentifierEnv}${teamId ? `?teamId=${teamId}` : ''}`
          );
        }

        if (detail.nextClientAppIdEnv) {
          urls.push(
            `${projectApiUrl}/${detail.projectId}/env/${detail.nextClientAppIdEnv}${teamId ? `?teamId=${teamId}` : ''}`
          );
        }

        if (detail.clientAppIdEnv) {
          urls.push(
            `${projectApiUrl}/${detail.projectId}/env/${detail.clientAppIdEnv}${teamId ? `?teamId=${teamId}` : ''}`
          );
        }

        if (detail.secretKeyEnv) {
          urls.push(
            `${projectApiUrl}/${detail.projectId}/env/${detail.secretKeyEnv}${teamId ? `?teamId=${teamId}` : ''}`
          );
        }

        const requests = urls.map((url) =>
          lastValueFrom(
            this.httpService.delete(url, {
              headers: {
                Authorization: `Bearer ${token}`,
              },
            })
          )
        );

        return Promise.all(requests);
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - alias(vercelTarget?.alias?.sort((a, b))
 - setEnvVariable(async (projectId: string, variable: (typeof environmentVariables)[0]))
 - queryParams(new URLSearchParams();
        queryParams.set('upsert', 'true');

        if (teamId) {
          q...)
 - configuration(firstOrg.partnerConfigurations?.find((config))
 - filteredVercelProjects(vercelProjects.filter((project))
 - nextApplicationIdentifierEnv(vercelEnvs?.find(
          (e))
 - nextClientAppIdEnv(vercelEnvs?.find(
          (e))
 - clientAppIdEnv(vercelEnvs?.find(
          (e))
 - secretKeyEnv(vercelEnvs?.find(
          (e))
 - allOldProjectIds([
      ...new Set(
        orgsWithIntegration.reduce<string[]>((acc, org))
 - projectApiUrl(`${process.env.VERCEL_BASE_URL}/v9/projects`;

    await Promise.all(
      vercelLinkedProjects.map...)
 - requests(urls.map((url))
Declaraciones 'export' encontradas:
- export class UpdateVercelIntegration

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/pipes/zod-validation-pipe.ts
Tamaño: 518 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ArgumentMetadata, Injectable, PipeTransform } from '@nestjs/common';
import { ZodError, ZodSchema } from 'zod';

@Injectable()
export class ZodValidationPipe implements PipeTransform {
  constructor(private readonly schema: ZodSchema) {}

  transform(value: unknown, metadata: ArgumentMetadata) {
    if (metadata.type === 'body') {
      const result = this.schema.safeParse(value);
      if (!result.success) {
        throw new ZodError(result.error.errors);
      }

      return result.data;
    }
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class ZodValidationPipe

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/preferences/index.ts
Tamaño: 58 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export { PreferencesModule } from './preferences.module';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/preferences/preferences.controller.ts
Tamaño: 2217 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import {
  Body,
  ClassSerializerInterceptor,
  Controller,
  Delete,
  Get,
  Post,
  Query,
  UseInterceptors,
} from '@nestjs/common';
import { ApiExcludeController } from '@nestjs/swagger';
import {
  DeletePreferencesCommand,
  DeletePreferencesUseCase,
  GetPreferences,
  GetPreferencesCommand,
  UpsertPreferences,
  UpsertUserWorkflowPreferencesCommand,
  UserSession,
} from '@novu/application-generic';
import { PreferencesTypeEnum, UserSessionData } from '@novu/shared';
import { RequireAuthentication } from '../auth/framework/auth.decorator';
import { UpsertPreferencesDto } from './dtos/upsert-preferences.dto';

/**
 * @deprecated - set workflow preferences using the `/workflows` endpoint instead
 */
@Controller('/preferences')
@UseInterceptors(ClassSerializerInterceptor)
@RequireAuthentication()
@ApiExcludeController()
export class PreferencesController {
  constructor(
    private upsertPreferences: UpsertPreferences,
    private getPreferences: GetPreferences,
    private deletePreferences: DeletePreferencesUseCase
  ) {}

  @Get('/')
  async get(@UserSession() user: UserSessionData, @Query('workflowId') workflowId: string) {
    return this.getPreferences.execute(
      GetPreferencesCommand.create({
        templateId: workflowId,
        environmentId: user.environmentId,
        organizationId: user.organizationId,
      })
    );
  }

  @Post('/')
  async upsert(@Body() data: UpsertPreferencesDto, @UserSession() user: UserSessionData) {
    return this.upsertPreferences.upsertUserWorkflowPreferences(
      UpsertUserWorkflowPreferencesCommand.create({
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
        preferences: data.preferences,
        templateId: data.workflowId,
      })
    );
  }

  @Delete('/')
  async delete(@UserSession() user: UserSessionData, @Query('workflowId') workflowId: string) {
    return this.deletePreferences.execute(
      DeletePreferencesCommand.create({
        templateId: workflowId,
        environmentId: user.environmentId,
        organizationId: user.organizationId,
        userId: user._id,
        type: PreferencesTypeEnum.USER_WORKFLOW,
      })
    );
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class PreferencesController

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/preferences/preferences.module.ts
Tamaño: 702 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { MiddlewareConsumer, Module, NestModule } from '@nestjs/common';
import { DeletePreferencesUseCase, GetPreferences, UpsertPreferences } from '@novu/application-generic';
import { PreferencesRepository } from '@novu/dal';
import { SharedModule } from '../shared/shared.module';
import { PreferencesController } from './preferences.controller';

const PROVIDERS = [PreferencesRepository, UpsertPreferences, GetPreferences, DeletePreferencesUseCase];

@Module({
  imports: [SharedModule],
  providers: [...PROVIDERS],
  controllers: [PreferencesController],
  exports: [...PROVIDERS],
})
export class PreferencesModule implements NestModule {
  public configure(consumer: MiddlewareConsumer) {}
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class PreferencesModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/preferences/preferences.spec.ts
Tamaño: 25556 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Test } from '@nestjs/testing';
import {
  GetPreferences,
  UpsertPreferences,
  UpsertSubscriberGlobalPreferencesCommand,
  UpsertSubscriberWorkflowPreferencesCommand,
  UpsertUserWorkflowPreferencesCommand,
  UpsertWorkflowPreferencesCommand,
} from '@novu/application-generic';
import { PreferencesRepository, SubscriberRepository } from '@novu/dal';
import { FeatureFlagsKeysEnum, PreferencesTypeEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

import { AuthModule } from '../auth/auth.module';
import { PreferencesModule } from './preferences.module';

describe('Preferences', () => {
  let getPreferences: GetPreferences;
  const subscriberId = SubscriberRepository.createObjectId();
  const workflowId = PreferencesRepository.createObjectId();
  let upsertPreferences: UpsertPreferences;
  let session: UserSession;

  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [PreferencesModule, AuthModule],
      providers: [],
    }).compile();

    session = new UserSession();
    await session.initialize();

    getPreferences = moduleRef.get<GetPreferences>(GetPreferences);
    upsertPreferences = moduleRef.get<UpsertPreferences>(UpsertPreferences);
  });

  describe('Upsert preferences', () => {
    it('should create workflow preferences', async () => {
      const workflowPreferences = await upsertPreferences.upsertWorkflowPreferences(
        UpsertWorkflowPreferencesCommand.create({
          preferences: {
            all: {
              enabled: false,
              readOnly: false,
            },
            channels: {
              in_app: {
                enabled: false,
              },
              sms: {
                enabled: false,
              },
              email: {
                enabled: false,
              },
              push: {
                enabled: false,
              },
              chat: {
                enabled: false,
              },
            },
          },
          environmentId: session.environment._id,
          organizationId: session.organization._id,
          templateId: workflowId,
        })
      );

      expect(workflowPreferences._environmentId).to.equal(session.environment._id);
      expect(workflowPreferences._organizationId).to.equal(session.organization._id);
      expect(workflowPreferences._templateId).to.equal(workflowId);
      expect(workflowPreferences._userId).to.be.undefined;
      expect(workflowPreferences._subscriberId).to.be.undefined;
      expect(workflowPreferences.type).to.equal(PreferencesTypeEnum.WORKFLOW_RESOURCE);
    });

    it('should create user workflow preferences', async () => {
      const userPreferences = await upsertPreferences.upsertUserWorkflowPreferences(
        UpsertUserWorkflowPreferencesCommand.create({
          preferences: {
            all: {
              enabled: false,
              readOnly: false,
            },
            channels: {
              in_app: {
                enabled: false,
              },
              sms: {
                enabled: false,
              },
              email: {
                enabled: false,
              },
              push: {
                enabled: false,
              },
              chat: {
                enabled: false,
              },
            },
          },
          environmentId: session.environment._id,
          organizationId: session.organization._id,
          templateId: workflowId,
          userId: session.user._id,
        })
      );

      expect(userPreferences._environmentId).to.equal(session.environment._id);
      expect(userPreferences._organizationId).to.equal(session.organization._id);
      expect(userPreferences._templateId).to.equal(workflowId);
      expect(userPreferences._userId).to.equal(session.user._id);
      expect(userPreferences._subscriberId).to.be.undefined;
      expect(userPreferences.type).to.equal(PreferencesTypeEnum.USER_WORKFLOW);
    });

    it('should create global subscriber preferences', async () => {
      const subscriberGlobalPreferences = await upsertPreferences.upsertSubscriberGlobalPreferences(
        UpsertSubscriberGlobalPreferencesCommand.create({
          preferences: {
            all: {
              enabled: false,
              readOnly: false,
            },
            channels: {
              in_app: {
                enabled: false,
              },
              sms: {
                enabled: false,
              },
              email: {
                enabled: false,
              },
              push: {
                enabled: false,
              },
              chat: {
                enabled: false,
              },
            },
          },
          environmentId: session.environment._id,
          organizationId: session.organization._id,
          _subscriberId: subscriberId,
        })
      );

      expect(subscriberGlobalPreferences._environmentId).to.equal(session.environment._id);
      expect(subscriberGlobalPreferences._organizationId).to.equal(session.organization._id);
      expect(subscriberGlobalPreferences._templateId).to.be.undefined;
      expect(subscriberGlobalPreferences._userId).to.be.undefined;
      expect(subscriberGlobalPreferences._subscriberId).to.equal(subscriberId);
      expect(subscriberGlobalPreferences.type).to.equal(PreferencesTypeEnum.SUBSCRIBER_GLOBAL);
    });

    it('should create subscriber workflow preferences', async () => {
      const subscriberWorkflowPreferences = await upsertPreferences.upsertSubscriberWorkflowPreferences(
        UpsertSubscriberWorkflowPreferencesCommand.create({
          preferences: {
            all: {
              enabled: false,
              readOnly: false,
            },
            channels: {
              in_app: {
                enabled: false,
              },
              sms: {
                enabled: false,
              },
              email: {
                enabled: false,
              },
              push: {
                enabled: false,
              },
              chat: {
                enabled: false,
              },
            },
          },
          environmentId: session.environment._id,
          organizationId: session.organization._id,
          templateId: workflowId,
          _subscriberId: subscriberId,
        })
      );

      expect(subscriberWorkflowPreferences._environmentId).to.equal(session.environment._id);
      expect(subscriberWorkflowPreferences._organizationId).to.equal(session.organization._id);
      expect(subscriberWorkflowPreferences._templateId).to.equal(workflowId);
      expect(subscriberWorkflowPreferences._userId).to.be.undefined;
      expect(subscriberWorkflowPreferences._subscriberId).to.equal(subscriberId);
      expect(subscriberWorkflowPreferences.type).to.equal(PreferencesTypeEnum.SUBSCRIBER_WORKFLOW);
    });

    it('should update preferences', async () => {
      let workflowPreferences = await upsertPreferences.upsertWorkflowPreferences(
        UpsertWorkflowPreferencesCommand.create({
          preferences: {
            all: {
              enabled: false,
              readOnly: false,
            },
            channels: {
              in_app: {
                enabled: false,
              },
              sms: {
                enabled: false,
              },
              email: {
                enabled: false,
              },
              push: {
                enabled: false,
              },
              chat: {
                enabled: false,
              },
            },
          },
          environmentId: session.environment._id,
          organizationId: session.organization._id,
          templateId: workflowId,
        })
      );

      expect(workflowPreferences._environmentId).to.equal(session.environment._id);
      expect(workflowPreferences._organizationId).to.equal(session.organization._id);
      expect(workflowPreferences._templateId).to.equal(workflowId);
      expect(workflowPreferences._userId).to.be.undefined;
      expect(workflowPreferences._subscriberId).to.be.undefined;
      expect(workflowPreferences.type).to.equal(PreferencesTypeEnum.WORKFLOW_RESOURCE);

      workflowPreferences = await upsertPreferences.upsertWorkflowPreferences(
        UpsertWorkflowPreferencesCommand.create({
          preferences: {
            all: {
              enabled: false,
              readOnly: true,
            },
            channels: {
              in_app: {
                enabled: false,
              },
              sms: {
                enabled: false,
              },
              email: {
                enabled: false,
              },
              push: {
                enabled: false,
              },
              chat: {
                enabled: false,
              },
            },
          },
          environmentId: session.environment._id,
          organizationId: session.organization._id,
          templateId: workflowId,
        })
      );

      expect(workflowPreferences.preferences.all.readOnly).to.be.true;
    });
  });

  describe('Get preferences', () => {
    it('should merge preferences when get preferences', async () => {
      // Workflow preferences
      await upsertPreferences.upsertWorkflowPreferences(
        UpsertWorkflowPreferencesCommand.create({
          preferences: {
            all: {
              enabled: false,
              readOnly: false,
            },
            channels: {
              in_app: {
                enabled: false,
              },
              sms: {
                enabled: false,
              },
              email: {
                enabled: false,
              },
              push: {
                enabled: false,
              },
              chat: {
                enabled: false,
              },
            },
          },
          environmentId: session.environment._id,
          organizationId: session.organization._id,
          templateId: workflowId,
        })
      );

      let preferences = await getPreferences.execute({
        environmentId: session.environment._id,
        organizationId: session.organization._id,
        templateId: workflowId,
      });

      expect(preferences).to.deep.equal({
        preferences: {
          all: {
            enabled: false,
            readOnly: false,
          },
          channels: {
            in_app: {
              enabled: false,
            },
            sms: {
              enabled: false,
            },
            email: {
              enabled: false,
            },
            push: {
              enabled: false,
            },
            chat: {
              enabled: false,
            },
          },
        },
        schedule: undefined,
        type: PreferencesTypeEnum.WORKFLOW_RESOURCE,
        source: {
          [PreferencesTypeEnum.WORKFLOW_RESOURCE]: {
            all: {
              enabled: false,
              readOnly: false,
            },
            channels: {
              in_app: {
                enabled: false,
              },
              sms: {
                enabled: false,
              },
              email: {
                enabled: false,
              },
              push: {
                enabled: false,
              },
              chat: {
                enabled: false,
              },
            },
          },
          [PreferencesTypeEnum.USER_WORKFLOW]: null,
          [PreferencesTypeEnum.SUBSCRIBER_GLOBAL]: null,
          [PreferencesTypeEnum.SUBSCRIBER_WORKFLOW]: null,
        },
      });

      // User Workflow preferences
      await upsertPreferences.upsertUserWorkflowPreferences(
        UpsertUserWorkflowPreferencesCommand.create({
          preferences: {
            all: {
              enabled: false,
              readOnly: true,
            },
            channels: {
              in_app: {
                enabled: false,
              },
              sms: {
                enabled: false,
              },
              email: {
                enabled: false,
              },
              push: {
                enabled: false,
              },
              chat: {
                enabled: false,
              },
            },
          },
          environmentId: session.environment._id,
          organizationId: session.organization._id,
          templateId: workflowId,
          userId: session.user._id,
        })
      );

      preferences = await getPreferences.execute({
        environmentId: session.environment._id,
        organizationId: session.organization._id,
        templateId: workflowId,
      });

      expect(preferences).to.deep.equal({
        preferences: {
          all: {
            enabled: false,
            readOnly: true,
          },
          channels: {
            in_app: {
              enabled: false,
            },
            sms: {
              enabled: false,
            },
            email: {
              enabled: false,
            },
            push: {
              enabled: false,
            },
            chat: {
              enabled: false,
            },
          },
        },
        schedule: undefined,
        type: PreferencesTypeEnum.USER_WORKFLOW,
        source: {
          [PreferencesTypeEnum.WORKFLOW_RESOURCE]: {
            all: {
              enabled: false,
              readOnly: false,
            },
            channels: {
              in_app: {
                enabled: false,
              },
              sms: {
                enabled: false,
              },
              email: {
                enabled: false,
              },
              push: {
                enabled: false,
              },
              chat: {
                enabled: false,
              },
            },
          },
          [PreferencesTypeEnum.USER_WORKFLOW]: {
            all: {
              enabled: false,
              readOnly: true,
            },
            channels: {
              in_app: {
                enabled: false,
              },
              sms: {
                enabled: false,
              },
              email: {
                enabled: false,
              },
              push: {
                enabled: false,
              },
              chat: {
                enabled: false,
              },
            },
          },
          [PreferencesTypeEnum.SUBSCRIBER_GLOBAL]: null,
          [PreferencesTypeEnum.SUBSCRIBER_WORKFLOW]: null,
        },
      });

      // Subscriber global preferences
      await upsertPreferences.upsertSubscriberGlobalPreferences(
        UpsertSubscriberGlobalPreferencesCommand.create({
          preferences: {
            all: {
              enabled: false,
              readOnly: true,
            },
            channels: {
              in_app: {
                enabled: false,
              },
              sms: {
                enabled: false,
              },
              email: {
                enabled: false,
              },
              push: {
                enabled: false,
              },
              chat: {
                enabled: false,
              },
            },
          },
          environmentId: session.environment._id,
          organizationId: session.organization._id,
          _subscriberId: subscriberId,
        })
      );

      preferences = await getPreferences.execute({
        environmentId: session.environment._id,
        organizationId: session.organization._id,
        templateId: workflowId,
        subscriberId,
      });

      expect(preferences).to.deep.equal({
        preferences: {
          all: {
            enabled: false,
            readOnly: true,
          },
          channels: {
            in_app: {
              enabled: false,
            },
            sms: {
              enabled: false,
            },
            email: {
              enabled: false,
            },
            push: {
              enabled: false,
            },
            chat: {
              enabled: false,
            },
          },
        },
        schedule: undefined,
        type: PreferencesTypeEnum.USER_WORKFLOW,
        source: {
          [PreferencesTypeEnum.WORKFLOW_RESOURCE]: {
            all: {
              enabled: false,
              readOnly: false,
            },
            channels: {
              in_app: {
                enabled: false,
              },
              sms: {
                enabled: false,
              },
              email: {
                enabled: false,
              },
              push: {
                enabled: false,
              },
              chat: {
                enabled: false,
              },
            },
          },
          [PreferencesTypeEnum.USER_WORKFLOW]: {
            all: {
              enabled: false,
              readOnly: true,
            },
            channels: {
              in_app: {
                enabled: false,
              },
              sms: {
                enabled: false,
              },
              email: {
                enabled: false,
              },
              push: {
                enabled: false,
              },
              chat: {
                enabled: false,
              },
            },
          },
          [PreferencesTypeEnum.SUBSCRIBER_GLOBAL]: {
            all: {
              enabled: false,
              readOnly: true,
            },
            channels: {
              in_app: {
                enabled: false,
              },
              sms: {
                enabled: false,
              },
              email: {
                enabled: false,
              },
              push: {
                enabled: false,
              },
              chat: {
                enabled: false,
              },
            },
          },
          [PreferencesTypeEnum.SUBSCRIBER_WORKFLOW]: null,
        },
      });

      // Subscriber Workflow preferences
      await upsertPreferences.upsertSubscriberWorkflowPreferences(
        UpsertSubscriberWorkflowPreferencesCommand.create({
          preferences: {
            all: {
              enabled: false,
              readOnly: true,
            },
            channels: {
              in_app: {
                enabled: false,
              },
              sms: {
                enabled: false,
              },
              email: {
                enabled: false,
              },
              push: {
                enabled: false,
              },
              chat: {
                enabled: false,
              },
            },
          },
          environmentId: session.environment._id,
          organizationId: session.organization._id,
          templateId: workflowId,
          _subscriberId: subscriberId,
        })
      );

      preferences = await getPreferences.execute({
        environmentId: session.environment._id,
        organizationId: session.organization._id,
        templateId: workflowId,
        subscriberId,
      });

      expect(preferences).to.deep.equal({
        preferences: {
          all: {
            enabled: false,
            readOnly: true,
          },
          channels: {
            in_app: {
              enabled: false,
            },
            sms: {
              enabled: false,
            },
            email: {
              enabled: false,
            },
            push: {
              enabled: false,
            },
            chat: {
              enabled: false,
            },
          },
        },
        schedule: undefined,
        type: PreferencesTypeEnum.USER_WORKFLOW,
        source: {
          [PreferencesTypeEnum.WORKFLOW_RESOURCE]: {
            all: {
              enabled: false,
              readOnly: false,
            },
            channels: {
              in_app: {
                enabled: false,
              },
              sms: {
                enabled: false,
              },
              email: {
                enabled: false,
              },
              push: {
                enabled: false,
              },
              chat: {
                enabled: false,
              },
            },
          },
          [PreferencesTypeEnum.USER_WORKFLOW]: {
            all: {
              enabled: false,
              readOnly: true,
            },
            channels: {
              in_app: {
                enabled: false,
              },
              sms: {
                enabled: false,
              },
              email: {
                enabled: false,
              },
              push: {
                enabled: false,
              },
              chat: {
                enabled: false,
              },
            },
          },
          [PreferencesTypeEnum.SUBSCRIBER_GLOBAL]: {
            all: {
              enabled: false,
              readOnly: true,
            },
            channels: {
              in_app: {
                enabled: false,
              },
              sms: {
                enabled: false,
              },
              email: {
                enabled: false,
              },
              push: {
                enabled: false,
              },
              chat: {
                enabled: false,
              },
            },
          },
          [PreferencesTypeEnum.SUBSCRIBER_WORKFLOW]: {
            all: {
              enabled: false,
              readOnly: true,
            },
            channels: {
              in_app: {
                enabled: false,
              },
              sms: {
                enabled: false,
              },
              email: {
                enabled: false,
              },
              push: {
                enabled: false,
              },
              chat: {
                enabled: false,
              },
            },
          },
        },
      });
    });
  });

  describe('Preferences endpoints', () => {
    it('should get preferences', async () => {
      const useCase: UpsertPreferences = session.testServer?.getService(UpsertPreferences);

      await useCase.upsertWorkflowPreferences(
        UpsertWorkflowPreferencesCommand.create({
          preferences: {
            all: {
              enabled: false,
              readOnly: false,
            },
            channels: {
              in_app: {
                enabled: false,
              },
              sms: {
                enabled: false,
              },
              email: {
                enabled: false,
              },
              push: {
                enabled: false,
              },
              chat: {
                enabled: false,
              },
            },
          },
          environmentId: session.environment._id,
          organizationId: session.organization._id,
          templateId: workflowId,
        })
      );

      const { body } = await session.testAgent.get(`/v1/preferences?workflowId=${workflowId}`).send();

      expect(body.data).to.deep.equal({
        preferences: {
          all: {
            enabled: false,
            readOnly: false,
          },
          channels: {
            in_app: {
              enabled: false,
            },
            sms: {
              enabled: false,
            },
            email: {
              enabled: false,
            },
            push: {
              enabled: false,
            },
            chat: {
              enabled: false,
            },
          },
        },
        type: PreferencesTypeEnum.WORKFLOW_RESOURCE,
        source: {
          [PreferencesTypeEnum.WORKFLOW_RESOURCE]: {
            all: {
              enabled: false,
              readOnly: false,
            },
            channels: {
              in_app: {
                enabled: false,
              },
              sms: {
                enabled: false,
              },
              email: {
                enabled: false,
              },
              push: {
                enabled: false,
              },
              chat: {
                enabled: false,
              },
            },
          },
          [PreferencesTypeEnum.USER_WORKFLOW]: null,
          [PreferencesTypeEnum.SUBSCRIBER_GLOBAL]: null,
          [PreferencesTypeEnum.SUBSCRIBER_WORKFLOW]: null,
        },
      });
    });

    it('should upsert preferences', async () => {
      const { body } = await session.testAgent.post('/v1/preferences').send({
        workflowId,
        preferences: {
          all: {
            enabled: false,
            readOnly: false,
          },
          channels: {
            in_app: {
              enabled: false,
            },
            sms: {
              enabled: false,
            },
            email: {
              enabled: false,
            },
            push: {
              enabled: false,
            },
            chat: {
              enabled: false,
            },
          },
        },
      });

      expect(body.data.preferences).to.deep.equal({
        all: {
          enabled: false,
          readOnly: false,
        },
        channels: {
          in_app: {
            enabled: false,
          },
          sms: {
            enabled: false,
          },
          email: {
            enabled: false,
          },
          push: {
            enabled: false,
          },
          chat: {
            enabled: false,
          },
        },
      });
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - workflowId(PreferencesRepository.createObjectId();
  let upsertPreferences: UpsertPreferences;
  let session: U...)
 - upsertPreferences(moduleRef.get<UpsertPreferences>(UpsertPreferences);
  });

  describe('Upsert preferences', ())
 - workflowPreferences(await upsertPreferences.upsertWorkflowPreferences(
        UpsertWorkflowPreferencesCommand.create({...)
 - userPreferences(await upsertPreferences.upsertUserWorkflowPreferences(
        UpsertUserWorkflowPreferencesCommand....)
 - subscriberGlobalPreferences(await upsertPreferences.upsertSubscriberGlobalPreferences(
        UpsertSubscriberGlobalPreferences...)
 - subscriberWorkflowPreferences(await upsertPreferences.upsertSubscriberWorkflowPreferences(
        UpsertSubscriberWorkflowPrefere...)
 - workflowPreferences(await upsertPreferences.upsertWorkflowPreferences(
        UpsertWorkflowPreferencesCommand.create({...)
 - preferences(await getPreferences.execute({
        environmentId: session.environment._id,
        organizationI...)
 - workflowId(${workflowId}`).send();

      expect(body.data).to.deep.equal({
        preferences: {
          al...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/preferences/dtos/preferences.dto.ts
Tamaño: 2547 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { ChannelTypeEnum } from '@novu/shared';
import { Type } from 'class-transformer';
import { IsBoolean, ValidateNested } from 'class-validator';

/**
 * @deprecated Use an updated preference structure.
 * This class will be removed in future versions.
 */
export class WorkflowPreference {
  /**
   * @deprecated Use alternative enablement mechanism.
   */
  @IsBoolean()
  enabled: boolean;

  /**
   * @deprecated Read-only flag is no longer supported.
   */
  @IsBoolean()
  readOnly: boolean;
}

/**
 * @deprecated Use an updated channel preference structure.
 * Will be removed in future versions.
 */
export class ChannelPreference {
  /**
   * @deprecated Use alternative channel enablement method.
   */
  @IsBoolean()
  enabled: boolean;
}

/**
 * @deprecated Channels configuration is being restructured.
 * Use the new channel management approach.
 */
export class Channels {
  /**
   * @deprecated In-app channel preference is deprecated.
   */
  @ValidateNested({ each: true })
  @Type(() => ChannelPreference)
  [ChannelTypeEnum.IN_APP]: ChannelPreference;

  /**
   * @deprecated Email channel preference is deprecated.
   */
  @ValidateNested({ each: true })
  @Type(() => ChannelPreference)
  [ChannelTypeEnum.EMAIL]: ChannelPreference;

  /**
   * @deprecated SMS channel preference is deprecated.
   */
  @ValidateNested({ each: true })
  @Type(() => ChannelPreference)
  [ChannelTypeEnum.SMS]: ChannelPreference;

  /**
   * @deprecated Chat channel preference is deprecated.
   */
  @ValidateNested({ each: true })
  @Type(() => ChannelPreference)
  [ChannelTypeEnum.CHAT]: ChannelPreference;

  /**
   * @deprecated Push channel preference is deprecated.
   */
  @ValidateNested({ each: true })
  @Type(() => ChannelPreference)
  [ChannelTypeEnum.PUSH]: ChannelPreference;
}

/**
 * @deprecated Preferences DTO is being replaced.
 * Use the new preferences management approach.
 */
export class PreferencesDto {
  /**
   * @deprecated Global workflow preference is no longer used.
   */
  @ValidateNested({ each: true })
  @Type(() => WorkflowPreference)
  all: WorkflowPreference;

  /**
   * @deprecated Channels configuration is deprecated.
   */
  @ValidateNested({ each: true })
  @Type(() => Channels)
  channels: Channels;
}

// Optional: Runtime deprecation warning
if (process.env.NODE_ENV !== 'production') {
  console.warn(
    'DEPRECATION WARNING: PreferencesDto and related classes are deprecated ' +
      'and will be removed in future versions. Please migrate to the new preferences structure.'
  );
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class WorkflowPreference
- export class ChannelPreference
- export class Channels
- export class PreferencesDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/preferences/dtos/upsert-preferences.dto.ts
Tamaño: 616 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Type } from 'class-transformer';
import { IsString, ValidateNested } from 'class-validator';
import { PreferencesDto } from './preferences.dto';

/**
 * @deprecated This DTO is no longer recommended for use.
 * Consider using an alternative implementation or updated data transfer object.
 */
export class UpsertPreferencesDto {
  /**
   * @deprecated Use an alternative workflow identification method.
   */
  @IsString()
  workflowId: string;

  /**
   * @deprecated Preferences structure is outdated.
   */
  @ValidateNested({ each: true })
  @Type(() => PreferencesDto)
  preferences: PreferencesDto;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class UpsertPreferencesDto

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/rate-limiting/rate-limiting.module.ts
Tamaño: 728 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Module } from '@nestjs/common';
import { ThrottlerModule } from '@nestjs/throttler';
import { CommunityOrganizationRepository } from '@novu/dal';
import { SharedModule } from '../shared/shared.module';
import { ApiRateLimitInterceptor } from './guards';
import { USE_CASES } from './usecases';

@Module({
  imports: [
    SharedModule,
    ThrottlerModule.forRoot([
      // The following configuration is required for the NestJS ThrottlerModule to work. It has no effect.
      {
        ttl: 60000,
        limit: 10,
      },
    ]),
  ],
  providers: [...USE_CASES, ApiRateLimitInterceptor, CommunityOrganizationRepository],
  exports: [...USE_CASES, ApiRateLimitInterceptor],
})
export class RateLimitingModule {}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class RateLimitingModule

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/rate-limiting/e2e/throttler.guard.e2e.ts
Tamaño: 15124 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { HttpResponseHeaderKeysEnum } from '@novu/application-generic';
import { ApiRateLimitCategoryEnum, ApiRateLimitCostEnum, ApiServiceLevelEnum } from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';

const mockSingleCost = 1;
const mockBulkCost = 5;
const mockWindowDuration = 5;
const mockBurstAllowance = 1;
const mockMaximumFreeTrigger = 5;
const mockMaximumFreeGlobal = 3;
const mockMaximumUnlimitedTrigger = 10;
const mockMaximumUnlimitedGlobal = 5;

process.env.API_RATE_LIMIT_COST_SINGLE = `${mockSingleCost}`;
process.env.API_RATE_LIMIT_COST_BULK = `${mockBulkCost}`;
process.env.API_RATE_LIMIT_ALGORITHM_WINDOW_DURATION = `${mockWindowDuration}`;
process.env.API_RATE_LIMIT_ALGORITHM_BURST_ALLOWANCE = `${mockBurstAllowance}`;
process.env.API_RATE_LIMIT_MAXIMUM_FREE_TRIGGER = `${mockMaximumFreeTrigger}`;
process.env.API_RATE_LIMIT_MAXIMUM_FREE_GLOBAL = `${mockMaximumFreeGlobal}`;
process.env.API_RATE_LIMIT_MAXIMUM_UNLIMITED_TRIGGER = `${mockMaximumUnlimitedTrigger}`;
process.env.API_RATE_LIMIT_MAXIMUM_UNLIMITED_GLOBAL = `${mockMaximumUnlimitedGlobal}`;

// Disable Launch Darkly to allow test to define FF state
// @ts-expect-error
process.env.LAUNCH_DARKLY_SDK_KEY = '';

describe('API Rate Limiting #novu-v2', () => {
  let session: UserSession;
  const pathPrefix = '/v1/rate-limiting';

  let request: (
    path: string,
    authHeader?: string
  ) => Promise<Awaited<ReturnType<typeof UserSession.prototype.testAgent.get>>>;

  describe('Guard logic', () => {
    beforeEach(async () => {
      // @ts-expect-error
      process.env.IS_API_RATE_LIMITING_ENABLED = 'true';

      session = new UserSession();
      await session.initialize();
      await session.updateOrganizationServiceLevel(ApiServiceLevelEnum.UNLIMITED);

      request = (path: string, authHeader = `ApiKey ${session.apiKey}`) =>
        session.testAgent.get(path).set('authorization', authHeader);
    });

    describe('Feature Flag', () => {
      it('should set rate limit headers when the Feature Flag is enabled', async () => {
        // @ts-expect-error
        process.env.IS_API_RATE_LIMITING_ENABLED = 'true';
        const response = await request(`${pathPrefix}/no-category-no-cost`);

        expect(response.headers[HttpResponseHeaderKeysEnum.RATELIMIT_LIMIT.toLowerCase()]).to.exist;
      });

      it('should NOT set rate limit headers when the Feature Flag is disabled', async () => {
        // @ts-expect-error
        process.env.IS_API_RATE_LIMITING_ENABLED = 'false';
        const response = await request(`${pathPrefix}/no-category-no-cost`);

        expect(response.headers[HttpResponseHeaderKeysEnum.RATELIMIT_LIMIT.toLowerCase()]).not.to.exist;
      });
    });

    describe('Allowed Authentication Security Schemes', () => {
      it('should set rate limit headers when ApiKey security scheme is used to authenticate', async () => {
        const response = await request(`${pathPrefix}/no-category-no-cost`, `ApiKey ${session.apiKey}`);

        expect(response.headers[HttpResponseHeaderKeysEnum.RATELIMIT_LIMIT.toLowerCase()]).to.exist;
      });

      it('should NOT set rate limit headers when a Bearer security scheme is used to authenticate', async () => {
        const response = await request(`${pathPrefix}/no-category-no-cost`, session.token);

        expect(response.headers[HttpResponseHeaderKeysEnum.RATELIMIT_LIMIT.toLowerCase()]).not.to.exist;
      });

      it('should NOT set rate limit headers when NO authorization header is present', async () => {
        const response = await request(`${pathPrefix}/no-category-no-cost`, '');

        expect(response.headers[HttpResponseHeaderKeysEnum.RATELIMIT_LIMIT.toLowerCase()]).not.to.exist;
      });
    });

    describe('RateLimit-Policy', () => {
      const testParams: Array<{ name: string; expectedRegex: string }> = [
        { name: 'limit', expectedRegex: `${mockMaximumUnlimitedGlobal * mockWindowDuration}` },
        { name: 'w', expectedRegex: `w=${mockWindowDuration}` },
        {
          name: 'burst',
          expectedRegex: `burst=${mockMaximumUnlimitedGlobal * (1 + mockBurstAllowance) * mockWindowDuration}`,
        },
        { name: 'comment', expectedRegex: `comment="[a-zA-Z ]*"` },
        { name: 'category', expectedRegex: `category="(${Object.values(ApiRateLimitCategoryEnum).join('|')})"` },
        { name: 'cost', expectedRegex: `cost="(${Object.values(ApiRateLimitCostEnum).join('|')})"` },
        {
          name: 'serviceLevel',
          expectedRegex: `serviceLevel="[a-zA-Z]*"`,
        },
      ];

      testParams.forEach(({ name, expectedRegex }) => {
        it(`should include the ${name} parameter`, async () => {
          const response = await request(`${pathPrefix}/no-category-no-cost`);
          const policyHeader = response.headers[HttpResponseHeaderKeysEnum.RATELIMIT_POLICY.toLowerCase()];

          expect(policyHeader).to.match(new RegExp(expectedRegex));
        });
      });

      it('should separate the params with a semicolon', async () => {
        const response = await request(`${pathPrefix}/no-category-no-cost`);
        const policyHeader = response.headers[HttpResponseHeaderKeysEnum.RATELIMIT_POLICY.toLowerCase()];

        expect(policyHeader.split(';')).to.have.lengthOf(testParams.length);
      });
    });

    describe('Rate Limit Decorators', () => {
      describe('Controller WITHOUT Decorators', () => {
        const controllerPathPrefix = '/v1/rate-limiting';

        it('should use the global category for an endpoint WITHOUT category decorator', async () => {
          const response = await request(`${controllerPathPrefix}/no-category-no-cost`);
          const policyHeader = response.headers[HttpResponseHeaderKeysEnum.RATELIMIT_POLICY.toLowerCase()];

          expect(policyHeader).to.contain(`category="${ApiRateLimitCategoryEnum.GLOBAL}"`);
        });

        it('should use the single cost for an endpoint WITHOUT cost decorator', async () => {
          const response = await request(`${controllerPathPrefix}/no-category-no-cost`);
          const policyHeader = response.headers[HttpResponseHeaderKeysEnum.RATELIMIT_POLICY.toLowerCase()];

          expect(policyHeader).to.contain(`cost="${ApiRateLimitCostEnum.SINGLE}"`);
        });
      });

      describe('Controller WITH Decorators', () => {
        const controllerPathPrefix = '/v1/rate-limiting-trigger-bulk';

        it('should use the category decorator defined on the controller for an endpoint WITHOUT category decorator', async () => {
          const response = await request(`${controllerPathPrefix}/no-category-no-cost-override`);
          const policyHeader = response.headers[HttpResponseHeaderKeysEnum.RATELIMIT_POLICY.toLowerCase()];

          expect(policyHeader).to.contain(`category="${ApiRateLimitCategoryEnum.TRIGGER}"`);
        });

        it('should use the cost decorator defined on the controller for an endpoint WITHOUT cost decorator', async () => {
          const response = await request(`${controllerPathPrefix}/no-category-no-cost-override`);
          const policyHeader = response.headers[HttpResponseHeaderKeysEnum.RATELIMIT_POLICY.toLowerCase()];

          expect(policyHeader).to.contain(`cost="${ApiRateLimitCostEnum.BULK}"`);
        });

        it('should override the cost decorator defined on the controller for an endpoint WITH cost decorator', async () => {
          const response = await request(`${controllerPathPrefix}/no-category-single-cost-override`);
          const policyHeader = response.headers[HttpResponseHeaderKeysEnum.RATELIMIT_POLICY.toLowerCase()];

          expect(policyHeader).to.contain(`cost="${ApiRateLimitCostEnum.SINGLE}"`);
        });

        it('should override the category decorator defined on the controller for an endpoint WITH category decorator', async () => {
          const response = await request(`${controllerPathPrefix}/global-category-no-cost-override`);
          const policyHeader = response.headers[HttpResponseHeaderKeysEnum.RATELIMIT_POLICY.toLowerCase()];

          expect(policyHeader).to.contain(`category="${ApiRateLimitCategoryEnum.GLOBAL}"`);
        });
      });
    });
  });

  describe('Scenarios', () => {
    type TestCase = {
      name: string;
      requests: { path: string; count: number }[];
      expectedStatus: number;
      expectedLimit: number;
      expectedCost: number;
      expectedReset: number;
      expectedRetryAfter?: number;
      expectedThrottledRequests: number;
      setupTest?: (userSession: UserSession) => Promise<void>;
    };

    const testCases: TestCase[] = [
      {
        name: 'single trigger endpoint request',
        requests: [{ path: '/trigger-category-single-cost', count: 1 }],
        expectedStatus: 200,
        expectedLimit: mockMaximumUnlimitedTrigger,
        expectedCost: mockSingleCost * 1,
        expectedReset: 1,
        expectedThrottledRequests: 0,
        async setupTest(userSession) {
          await userSession.updateOrganizationServiceLevel(ApiServiceLevelEnum.UNLIMITED);
        },
      },
      {
        name: 'no category no cost endpoint request',
        requests: [{ path: '/no-category-no-cost', count: 1 }],
        expectedStatus: 200,
        expectedLimit: mockMaximumUnlimitedGlobal,
        expectedCost: mockSingleCost * 1,
        expectedReset: 1,
        expectedThrottledRequests: 0,
        async setupTest(userSession) {
          await userSession.updateOrganizationServiceLevel(ApiServiceLevelEnum.UNLIMITED);
        },
      },
      {
        name: 'single trigger request with service level specified on organization ',
        requests: [{ path: '/trigger-category-single-cost', count: 1 }],
        expectedStatus: 200,
        expectedLimit: mockMaximumFreeTrigger,
        expectedCost: mockSingleCost * 1,
        expectedReset: 1,
        expectedThrottledRequests: 0,
        async setupTest(userSession) {
          await userSession.updateOrganizationServiceLevel(ApiServiceLevelEnum.FREE);
        },
      },
      {
        name: 'single trigger request with maximum rate limit specified on environment',
        requests: [{ path: '/trigger-category-single-cost', count: 1 }],
        expectedStatus: 200,
        expectedLimit: 60,
        expectedCost: mockSingleCost * 1,
        expectedReset: 1,
        expectedThrottledRequests: 0,
        async setupTest(userSession) {
          await userSession.updateOrganizationServiceLevel(ApiServiceLevelEnum.UNLIMITED);
          await userSession.updateEnvironmentApiRateLimits({ [ApiRateLimitCategoryEnum.TRIGGER]: 60 });
        },
      },
      {
        name: 'combination of single trigger and single global endpoint request',
        requests: [
          { path: '/trigger-category-single-cost', count: 20 },
          { path: '/global-category-single-cost', count: 100 },
        ],
        expectedStatus: 429,
        expectedLimit: mockMaximumUnlimitedGlobal,
        expectedCost: mockSingleCost * 100,
        expectedReset: 1,
        expectedRetryAfter: 1,
        expectedThrottledRequests: 50,
        async setupTest(userSession) {
          await userSession.updateOrganizationServiceLevel(ApiServiceLevelEnum.UNLIMITED);
        },
      },
    ];

    testCases
      .map(
        ({
          name,
          requests,
          expectedStatus,
          expectedLimit,
          expectedCost,
          expectedReset,
          expectedRetryAfter,
          expectedThrottledRequests,
          setupTest,
        }) => {
          return () => {
            describe(`${expectedStatus === 429 ? 'Throttled' : 'Allowed'} ${name}`, () => {
              let lastResponse;
              let throttledResponseCount = 0;
              const throttledResponseCountTolerance = 0.5;
              const expectedWindowLimit = expectedLimit * mockWindowDuration;
              const expectedBurstLimit = expectedWindowLimit * (1 + mockBurstAllowance);
              const expectedRemaining = Math.max(0, expectedBurstLimit - expectedCost);

              before(async () => {
                // @ts-expect-error
                process.env.IS_API_RATE_LIMITING_ENABLED = 'true';

                session = new UserSession();
                await session.initialize();

                request = (path: string, authHeader = `ApiKey ${session.apiKey}`) =>
                  session.testAgent.get(path).set('authorization', authHeader);

                setupTest && (await setupTest(session));
                for (const { path, count } of requests) {
                  for (let index = 0; index < count; index += 1) {
                    const response = await request(pathPrefix + path);
                    lastResponse = response;

                    if (response.statusCode === 429) {
                      throttledResponseCount += 1;
                    }
                  }
                }
              });

              it(`should return a ${expectedStatus} status code`, async () => {
                expect(lastResponse.statusCode).to.equal(expectedStatus);
              });

              it(`should return a ${HttpResponseHeaderKeysEnum.RATELIMIT_LIMIT} header of ${expectedWindowLimit}`, async () => {
                expect(lastResponse.headers[HttpResponseHeaderKeysEnum.RATELIMIT_LIMIT.toLowerCase()]).to.equal(
                  `${expectedWindowLimit}`
                );
              });

              it(`should return a ${HttpResponseHeaderKeysEnum.RATELIMIT_REMAINING} header of ${expectedRemaining}`, async () => {
                expect(lastResponse.headers[HttpResponseHeaderKeysEnum.RATELIMIT_REMAINING.toLowerCase()]).to.equal(
                  `${expectedRemaining}`
                );
              });

              it(`should return a ${HttpResponseHeaderKeysEnum.RATELIMIT_RESET} header of ${expectedReset}`, async () => {
                expect(lastResponse.headers[HttpResponseHeaderKeysEnum.RATELIMIT_RESET.toLowerCase()]).to.equal(
                  `${expectedReset}`
                );
              });

              it(`should return a ${HttpResponseHeaderKeysEnum.RETRY_AFTER} header of ${expectedRetryAfter}`, async () => {
                expect(lastResponse.headers[HttpResponseHeaderKeysEnum.RETRY_AFTER.toLowerCase()]).to.equal(
                  expectedRetryAfter && `${expectedRetryAfter}`
                );
              });

              const expectedMinThrottled = Math.floor(
                expectedThrottledRequests * (1 - throttledResponseCountTolerance)
              );
              const expectedMaxThrottled = Math.ceil(expectedThrottledRequests * (1 + throttledResponseCountTolerance));
              it(`should have between ${expectedMinThrottled} and ${expectedMaxThrottled} requests throttled`, async () => {
                expect(throttledResponseCount).to.be.greaterThanOrEqual(expectedMinThrottled);
                expect(throttledResponseCount).to.be.lessThanOrEqual(expectedMaxThrottled);
              });
            });
          };
        }
      )
      .forEach((testCase) => {
        testCase();
      });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - LAUNCH_DARKLY_SDK_KEY('';

describe('API Rate Limiting #novu-v2', ())
 - pathPrefix('/v1/rate-limiting';

  let request: (
    path: string,
    authHeader?: string
  ))
 - authHeader(`ApiKey ${session.apiKey}`))
 - response(await request(`${pathPrefix}/no-category-no-cost`);

        expect(response.headers[HttpResponseHea...)
 - response(await request(`${pathPrefix}/no-category-no-cost`);

        expect(response.headers[HttpResponseHea...)
 - response(await request(`${pathPrefix}/no-category-no-cost`, `ApiKey ${session.apiKey}`);

        expect(resp...)
 - response(await request(`${pathPrefix}/no-category-no-cost`, session.token);

        expect(response.headers[...)
 - response(await request(`${pathPrefix}/no-category-no-cost`, '');

        expect(response.headers[HttpRespons...)
 - serviceLevel("[a-zA-Z]*"`,
        },
      ];

      testParams.forEach(({ name, expectedRegex }))
 - policyHeader(response.headers[HttpResponseHeaderKeysEnum.RATELIMIT_POLICY.toLowerCase()];

          expect(polic...)
 - policyHeader(response.headers[HttpResponseHeaderKeysEnum.RATELIMIT_POLICY.toLowerCase()];

        expect(policyH...)
 - controllerPathPrefix('/v1/rate-limiting';

        it('should use the global category for an endpoint WITHOUT category de...)
 - category("${ApiRateLimitCategoryEnum.GLOBAL}"`);
        });

        it('should use the single cost for an e...)
 - cost("${ApiRateLimitCostEnum.SINGLE}"`);
        });
      });

      describe('Controller WITH Decorator...)
 - controllerPathPrefix('/v1/rate-limiting-trigger-bulk';

        it('should use the category decorator defined on the cont...)
 - category("${ApiRateLimitCategoryEnum.TRIGGER}"`);
        });

        it('should use the cost decorator defi...)
 - cost("${ApiRateLimitCostEnum.BULK}"`);
        });

        it('should override the cost decorator define...)
 - cost("${ApiRateLimitCostEnum.SINGLE}"`);
        });

        it('should override the category decorator ...)
 - category("${ApiRateLimitCategoryEnum.GLOBAL}"`);
        });
      });
    });
  });

  describe('Scenarios',...)
 - TestCase({
      name: string;
      requests: { path: string; count: number }[];
      expectedStatus: numbe...)
 - expectedRemaining(Math.max(0, expectedBurstLimit - expectedCost);

              before(async ())
 - authHeader(`ApiKey ${session.apiKey}`))
 - expectedMaxThrottled(Math.ceil(expectedThrottledRequests * (1 + throttledResponseCountTolerance));
              it(`shou...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/rate-limiting/guards/index.ts
Tamaño: 74 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './throttler.decorator';
export * from './throttler.guard';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/rate-limiting/guards/throttler.decorator.ts
Tamaño: 291 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Reflector } from '@nestjs/core';
import { ApiRateLimitCategoryEnum, ApiRateLimitCostEnum } from '@novu/shared';

export const ThrottlerCategory = Reflector.createDecorator<ApiRateLimitCategoryEnum>();

export const ThrottlerCost = Reflector.createDecorator<ApiRateLimitCostEnum>();


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/rate-limiting/guards/throttler.guard.ts
Tamaño: 10802 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { CallHandler, ExecutionContext, Injectable, NestInterceptor } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import {
  InjectThrottlerOptions,
  InjectThrottlerStorage,
  ThrottlerException,
  ThrottlerGuard,
  ThrottlerModuleOptions,
  ThrottlerRequest,
  ThrottlerStorage,
} from '@nestjs/throttler';
import {
  FeatureFlagsService,
  HttpRequestHeaderKeysEnum,
  HttpResponseHeaderKeysEnum,
  Instrument,
  PinoLogger,
} from '@novu/application-generic';
import { EnvironmentEntity, OrganizationEntity, UserEntity } from '@novu/dal';
import {
  ApiAuthSchemeEnum,
  ApiRateLimitCategoryEnum,
  ApiRateLimitCostEnum,
  FeatureFlagsKeysEnum,
  UserSessionData,
} from '@novu/shared';
import { getClientIp } from 'request-ip';
import { checkIsKeylessHeader } from '../../shared/utils/auth.utils';
import { EvaluateApiRateLimit, EvaluateApiRateLimitCommand } from '../usecases/evaluate-api-rate-limit';
import { ThrottlerCategory, ThrottlerCost } from './throttler.decorator';

export const THROTTLED_EXCEPTION_MESSAGE = 'API rate limit exceeded';
export const ALLOWED_AUTH_SCHEMES = [ApiAuthSchemeEnum.API_KEY, ApiAuthSchemeEnum.KEYLESS];

const defaultApiRateLimitCategory = ApiRateLimitCategoryEnum.GLOBAL;
const defaultApiRateLimitCost = ApiRateLimitCostEnum.SINGLE;

/**
 * An interceptor is used instead of a guard to ensure that Auth context is available.
 * This is currently necessary because we do not currently have a global guard configured for Auth,
 * therefore the Auth context is not guaranteed to be available in the guard.
 */
@Injectable()
export class ApiRateLimitInterceptor extends ThrottlerGuard implements NestInterceptor {
  constructor(
    @InjectThrottlerOptions() protected readonly options: ThrottlerModuleOptions,
    @InjectThrottlerStorage() protected readonly storageService: ThrottlerStorage,
    reflector: Reflector,
    private evaluateApiRateLimit: EvaluateApiRateLimit,
    private featureFlagService: FeatureFlagsService,
    private logger: PinoLogger
  ) {
    super(options, storageService, reflector);
    this.logger.setContext(this.constructor.name);
  }

  /**
   * Thin wrapper around the ThrottlerGuard's canActivate method.
   */
  async intercept(context: ExecutionContext, next: CallHandler) {
    await this.canActivate(context);

    return next.handle();
  }

  @Instrument()
  canActivate(context: ExecutionContext): Promise<boolean> {
    return super.canActivate(context);
  }

  protected async shouldSkip(context: ExecutionContext): Promise<boolean> {
    const req = context.switchToHttp().getRequest();
    const isAllowedAuthScheme = this.isAllowedAuthScheme(context);
    const isAllowedEnvironment = this.isAllowedEnvironment(context);
    const isAllowedRoute = this.isAllowedRoute(context);

    if (!isAllowedAuthScheme && !isAllowedEnvironment && !isAllowedRoute) {
      this.logger.debug({
        message: 'Rate limiting skipped - request criteria not met',
        _event: {
          path: req.path,
          authScheme: req.authScheme,
        },
      });

      return true;
    }

    const user = this.getReqUser(context);

    // Indicates whether the request originates from a Inbox session initialization
    if (!user) {
      return false;
    }

    const { organizationId, environmentId, _id } = user;

    const isEnabled = await this.featureFlagService.getFlag({
      key: FeatureFlagsKeysEnum.IS_API_RATE_LIMITING_ENABLED,
      defaultValue: false,
      environment: { _id: environmentId } as EnvironmentEntity,
      organization: { _id: organizationId } as OrganizationEntity,
      user: { _id } as UserEntity,
    });

    if (!isEnabled) {
      this.logger.debug({
        message: 'Rate limiting skipped - feature flag disabled',
        _event: {
          organizationId,
          environmentId,
        },
      });
    }

    return !isEnabled;
  }

  /**
   * Throttles incoming HTTP requests.
   * All the outgoing requests will contain RFC-compatible RateLimit headers.
   * @see https://datatracker.ietf.org/doc/draft-ietf-httpapi-ratelimit-headers/
   * @throws {ThrottlerException}
   */
  protected async handleRequest({ context, throttler }: ThrottlerRequest): Promise<boolean> {
    const { req, res } = this.getRequestResponse(context);
    const clientIp = getClientIp(req) || undefined;

    const ignoreUserAgents = throttler.ignoreUserAgents ?? this.commonOptions.ignoreUserAgents;
    // Return early if the current user agent should be ignored.
    if (Array.isArray(ignoreUserAgents)) {
      for (const pattern of ignoreUserAgents) {
        if (pattern.test(req.headers[HttpRequestHeaderKeysEnum.USER_AGENT.toLowerCase()])) {
          return true;
        }
      }
    }

    const handler = context.getHandler();
    const classRef = context.getClass();

    const isKeylessHeader =
      checkIsKeylessHeader(req.headers.authorization) ||
      checkIsKeylessHeader(req.headers['novu-application-identifier']);
    const isKeylessRequest = isKeylessHeader || this.isKeylessRoute(context);
    const apiRateLimitCategory =
      this.reflector.getAllAndOverride(ThrottlerCategory, [handler, classRef]) || defaultApiRateLimitCategory;

    const user = this.getReqUser(context);
    const organizationId = user?.organizationId;
    const _id = user?._id;
    const environmentId = user?.environmentId || req.headers['novu-application-identifier'];

    const apiRateLimitCost = isKeylessRequest
      ? getKeylessCost()
      : this.reflector.getAllAndOverride(ThrottlerCost, [handler, classRef]) || defaultApiRateLimitCost;

    const evaluateCommand = EvaluateApiRateLimitCommand.create({
      organizationId,
      environmentId,
      apiRateLimitCategory,
      apiRateLimitCost,
      ip: isKeylessRequest ? clientIp : undefined,
    });

    const { success, limit, remaining, reset, windowDuration, burstLimit, algorithm, apiServiceLevel } =
      await this.evaluateApiRateLimit.execute(evaluateCommand);

    const secondsToReset = Math.max(Math.ceil((reset - Date.now()) / 1e3), 0);

    this.logger.debug({
      message: 'Rate limit evaluated',
      _event: {
        success,
        limit,
        remaining,
        category: apiRateLimitCategory,
        cost: apiRateLimitCost,
        isKeyless: isKeylessRequest,
        organizationId,
        environmentId,
        ip: clientIp,
      },
    });

    /**
     * The purpose of the dry run is to allow us to observe how
     * the rate limiting would behave without actually enforcing it.
     */
    const isDryRun = await this.featureFlagService.getFlag({
      environment: { _id: environmentId } as EnvironmentEntity,
      organization: { _id: organizationId } as OrganizationEntity,
      user: { _id } as UserEntity,
      key: FeatureFlagsKeysEnum.IS_API_RATE_LIMITING_DRY_RUN_ENABLED,
      defaultValue: false,
    });

    const isKeylessDryRunFlag = await this.featureFlagService.getFlag({
      environment: { _id: environmentId } as EnvironmentEntity,
      organization: { _id: organizationId } as OrganizationEntity,
      user: { _id, email: user?.email } as UserEntity,
      key: FeatureFlagsKeysEnum.IS_API_RATE_LIMITING_KEYLESS_DRY_RUN_ENABLED,
      defaultValue: false,
    });
    const isKeylessDryRun = isKeylessRequest && isKeylessDryRunFlag;

    res.header(HttpResponseHeaderKeysEnum.RATELIMIT_REMAINING, remaining);
    res.header(HttpResponseHeaderKeysEnum.RATELIMIT_LIMIT, limit);
    res.header(HttpResponseHeaderKeysEnum.RATELIMIT_RESET, secondsToReset);
    res.header(
      HttpResponseHeaderKeysEnum.RATELIMIT_POLICY,
      this.createPolicyHeader(
        limit,
        windowDuration,
        burstLimit,
        algorithm,
        apiRateLimitCategory,
        apiRateLimitCost,
        apiServiceLevel
      )
    );

    res.rateLimitPolicy = {
      limit,
      windowDuration,
      burstLimit,
      algorithm,
      apiRateLimitCategory,
      apiRateLimitCost,
      apiServiceLevel,
    };

    if (isDryRun || isKeylessDryRun) {
      if (!success) {
        this.logger.warn({
          message: `${isKeylessRequest ? '[Dry run] [Keyless]' : '[Dry run]'} Rate limit would be exceeded`,
          _event: {
            limit,
            remaining,
            organizationId,
            environmentId,
            ip: clientIp,
          },
        });
      }

      return true;
    }

    if (success) {
      return true;
    } else {
      res.header(HttpResponseHeaderKeysEnum.RETRY_AFTER, secondsToReset);

      this.logger.debug({
        message: 'Rate limit exceeded',
        _event: {
          limit,
          remaining,
          retryAfter: secondsToReset,
          category: apiRateLimitCategory,
          organizationId,
          environmentId,
          ip: clientIp,
          isKeyless: isKeylessRequest,
        },
      });

      throw new ThrottlerException(THROTTLED_EXCEPTION_MESSAGE);
    }
  }

  private createPolicyHeader(
    limit: number,
    windowDuration: number,
    burstLimit: number,
    algorithm: string,
    apiRateLimitCategory: ApiRateLimitCategoryEnum,
    apiRateLimitCost: ApiRateLimitCostEnum,
    apiServiceLevel: string
  ): string {
    const policyMap = {
      w: windowDuration,
      burst: burstLimit,
      comment: `"${algorithm}"`,
      category: `"${apiRateLimitCategory}"`,
      cost: `"${apiRateLimitCost}"`,
      serviceLevel: `"${apiServiceLevel}"`,
    };
    const policy = Object.entries(policyMap).reduce((acc, [key, value]) => {
      return `${acc};${key}=${value}`;
    }, `${limit}`);

    return policy;
  }

  private isAllowedAuthScheme(context: ExecutionContext): boolean {
    const { authScheme } = context.switchToHttp().getRequest();

    return ALLOWED_AUTH_SCHEMES.some((scheme) => authScheme === scheme);
  }

  private isAllowedEnvironment(context: ExecutionContext): boolean {
    const req = context.switchToHttp().getRequest();
    const applicationIdentifier = req.headers['novu-application-identifier'];

    if (!applicationIdentifier) {
      return false;
    }

    return applicationIdentifier.startsWith('pk_keyless_');
  }

  private isAllowedRoute(context: ExecutionContext): boolean {
    return this.isKeylessRoute(context);
  }

  private isKeylessRoute(context: ExecutionContext): boolean {
    const req = context.switchToHttp().getRequest();

    return req.path === '/v1/inbox/session' && req.method === 'POST';
  }

  private getReqUser(context: ExecutionContext): UserSessionData | undefined {
    const req = context.switchToHttp().getRequest();

    return req.user;
  }
}

function getKeylessCost() {
  // For test environment, we use a higher cost to ensure tests can run without rate limiting issues
  return process.env.NODE_ENV === 'test' ? defaultApiRateLimitCost : ApiRateLimitCostEnum.KEYLESS;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - getKeylessCost()
Asignaciones con arrow functions encontradas (posibles funciones):
 - policy(Object.entries(policyMap).reduce((acc, [key, value]))
Declaraciones 'export' encontradas:
- export  const
- export  const
- export class ApiRateLimitInterceptor

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/rate-limiting/usecases/index.ts
Tamaño: 567 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { EvaluateApiRateLimit } from './evaluate-api-rate-limit';
import { EvaluateTokenBucketRateLimit } from './evaluate-token-bucket-rate-limit';
import { GetApiRateLimitAlgorithmConfig } from './get-api-rate-limit-algorithm-config';
import { GetApiRateLimitCostConfig } from './get-api-rate-limit-cost-config';
import { GetApiRateLimitMaximum } from './get-api-rate-limit-maximum';

export const USE_CASES = [
  //
  GetApiRateLimitMaximum,
  GetApiRateLimitAlgorithmConfig,
  GetApiRateLimitCostConfig,
  EvaluateApiRateLimit,
  EvaluateTokenBucketRateLimit,
];


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  const

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/rate-limiting/usecases/evaluate-api-rate-limit/evaluate-api-rate-limit.command.ts
Tamaño: 659 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BaseCommand } from '@novu/application-generic';
import { ApiRateLimitCategoryEnum, ApiRateLimitCostEnum } from '@novu/shared';
import { IsDefined, IsEnum, IsNotEmpty, IsOptional, IsString } from 'class-validator';

export class EvaluateApiRateLimitCommand extends BaseCommand {
  @IsOptional()
  @IsString()
  readonly environmentId?: string;

  @IsOptional()
  @IsString()
  readonly organizationId?: string;

  @IsDefined()
  @IsEnum(ApiRateLimitCategoryEnum)
  apiRateLimitCategory: ApiRateLimitCategoryEnum;

  @IsDefined()
  @IsEnum(ApiRateLimitCostEnum)
  apiRateLimitCost: ApiRateLimitCostEnum;

  @IsOptional()
  @IsString()
  ip?: string;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class EvaluateApiRateLimitCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/rate-limiting/usecases/evaluate-api-rate-limit/evaluate-api-rate-limit.spec.ts
Tamaño: 7978 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Test } from '@nestjs/testing';
import {
  ApiRateLimitAlgorithmEnum,
  ApiRateLimitCategoryEnum,
  ApiRateLimitCostEnum,
  ApiServiceLevelEnum,
  IApiRateLimitAlgorithm,
  IApiRateLimitCost,
} from '@novu/shared';
import { UserSession } from '@novu/testing';
import { expect } from 'chai';
import sinon from 'sinon';
import { SharedModule } from '../../../shared/shared.module';
import { RateLimitingModule } from '../../rate-limiting.module';
import { EvaluateTokenBucketRateLimit } from '../evaluate-token-bucket-rate-limit';
import { GetApiRateLimitAlgorithmConfig } from '../get-api-rate-limit-algorithm-config';
import { GetApiRateLimitCostConfig } from '../get-api-rate-limit-cost-config';
import { GetApiRateLimitMaximum } from '../get-api-rate-limit-maximum';
import { EvaluateApiRateLimit, EvaluateApiRateLimitCommand } from './index';

const mockApiRateLimitAlgorithm: IApiRateLimitAlgorithm = {
  [ApiRateLimitAlgorithmEnum.BURST_ALLOWANCE]: 0.2,
  [ApiRateLimitAlgorithmEnum.WINDOW_DURATION]: 2,
};
const mockApiRateLimitCost = ApiRateLimitCostEnum.SINGLE;
const mockApiServiceLevel = ApiServiceLevelEnum.FREE;
const mockCost = 1;
const mockApiRateLimitCostConfig: Partial<IApiRateLimitCost> = {
  [mockApiRateLimitCost]: mockCost,
};

const mockMaxLimit = 10;
const mockRemaining = 9;
const mockReset = 1;
const mockApiRateLimitCategory = ApiRateLimitCategoryEnum.GLOBAL;

describe('EvaluateApiRateLimit', async () => {
  let useCase: EvaluateApiRateLimit;
  let session: UserSession;
  let getApiRateLimitMaximum: GetApiRateLimitMaximum;
  let getApiRateLimitAlgorithmConfig: GetApiRateLimitAlgorithmConfig;
  let getApiRateLimitCostConfig: GetApiRateLimitCostConfig;
  let evaluateTokenBucketRateLimit: EvaluateTokenBucketRateLimit;

  let getApiRateLimitMaximumStub: sinon.SinonStub;
  let getApiRateLimitAlgorithmConfigStub: sinon.SinonStub;
  let getApiRateLimitCostConfigStub: sinon.SinonStub;
  let evaluateTokenBucketRateLimitStub: sinon.SinonStub;

  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [SharedModule, RateLimitingModule],
    }).compile();

    session = new UserSession();
    await session.initialize();

    useCase = moduleRef.get<EvaluateApiRateLimit>(EvaluateApiRateLimit);
    getApiRateLimitMaximum = moduleRef.get<GetApiRateLimitMaximum>(GetApiRateLimitMaximum);
    getApiRateLimitAlgorithmConfig = moduleRef.get<GetApiRateLimitAlgorithmConfig>(GetApiRateLimitAlgorithmConfig);
    getApiRateLimitCostConfig = moduleRef.get<GetApiRateLimitCostConfig>(GetApiRateLimitCostConfig);
    evaluateTokenBucketRateLimit = moduleRef.get<EvaluateTokenBucketRateLimit>(EvaluateTokenBucketRateLimit);

    getApiRateLimitMaximumStub = sinon
      .stub(getApiRateLimitMaximum, 'execute')
      .resolves([mockMaxLimit, mockApiServiceLevel]);
    getApiRateLimitAlgorithmConfigStub = sinon
      .stub(getApiRateLimitAlgorithmConfig, 'default')
      .value(mockApiRateLimitAlgorithm);
    getApiRateLimitCostConfigStub = sinon.stub(getApiRateLimitCostConfig, 'default').value(mockApiRateLimitCostConfig);
    evaluateTokenBucketRateLimitStub = sinon.stub(evaluateTokenBucketRateLimit, 'execute').resolves({
      success: true,
      limit: mockMaxLimit,
      remaining: mockRemaining,
      reset: mockReset,
    });
  });

  afterEach(() => {
    getApiRateLimitMaximumStub.restore();
    getApiRateLimitAlgorithmConfigStub.restore();
    getApiRateLimitCostConfigStub.restore();
  });

  describe('Evaluation Values', () => {
    it('should return a boolean success value', async () => {
      const result = await useCase.execute(
        EvaluateApiRateLimitCommand.create({
          organizationId: session.organization._id,
          environmentId: session.environment._id,
          apiRateLimitCategory: mockApiRateLimitCategory,
          apiRateLimitCost: mockApiRateLimitCost,
        })
      );

      expect(typeof result.success).to.equal('boolean');
    });

    it('should return a positive limit', async () => {
      const result = await useCase.execute(
        EvaluateApiRateLimitCommand.create({
          organizationId: session.organization._id,
          environmentId: session.environment._id,
          apiRateLimitCategory: mockApiRateLimitCategory,
          apiRateLimitCost: mockApiRateLimitCost,
        })
      );

      expect(result.limit).to.be.greaterThan(0);
    });

    it('should return a positive remaining tokens ', async () => {
      const result = await useCase.execute(
        EvaluateApiRateLimitCommand.create({
          organizationId: session.organization._id,
          environmentId: session.environment._id,
          apiRateLimitCategory: mockApiRateLimitCategory,
          apiRateLimitCost: mockApiRateLimitCost,
        })
      );

      expect(result.remaining).to.be.greaterThan(0);
    });

    it('should return a positive reset', async () => {
      const result = await useCase.execute(
        EvaluateApiRateLimitCommand.create({
          organizationId: session.organization._id,
          environmentId: session.environment._id,
          apiRateLimitCategory: mockApiRateLimitCategory,
          apiRateLimitCost: mockApiRateLimitCost,
        })
      );

      expect(result.reset).to.be.greaterThan(0);
    });
  });

  describe('Static Values', () => {
    it('should return a string type algorithm value', async () => {
      const result = await useCase.execute(
        EvaluateApiRateLimitCommand.create({
          organizationId: session.organization._id,
          environmentId: session.environment._id,
          apiRateLimitCategory: mockApiRateLimitCategory,
          apiRateLimitCost: mockApiRateLimitCost,
        })
      );

      expect(typeof result.algorithm).to.equal('string');
    });

    it('should return the correct window duration', async () => {
      const result = await useCase.execute(
        EvaluateApiRateLimitCommand.create({
          organizationId: session.organization._id,
          environmentId: session.environment._id,
          apiRateLimitCategory: mockApiRateLimitCategory,
          apiRateLimitCost: mockApiRateLimitCost,
        })
      );

      expect(result.windowDuration).to.equal(mockApiRateLimitAlgorithm[ApiRateLimitAlgorithmEnum.WINDOW_DURATION]);
    });
  });

  describe('Computed Values', () => {
    it('should return the correct cost', async () => {
      const result = await useCase.execute(
        EvaluateApiRateLimitCommand.create({
          organizationId: session.organization._id,
          environmentId: session.environment._id,
          apiRateLimitCategory: mockApiRateLimitCategory,
          apiRateLimitCost: mockApiRateLimitCost,
        })
      );

      expect(result.cost).to.equal(mockApiRateLimitCostConfig[mockApiRateLimitCost]);
    });

    it('should return the correct refill rate', async () => {
      const result = await useCase.execute(
        EvaluateApiRateLimitCommand.create({
          organizationId: session.organization._id,
          environmentId: session.environment._id,
          apiRateLimitCategory: mockApiRateLimitCategory,
          apiRateLimitCost: mockApiRateLimitCost,
        })
      );

      expect(result.refillRate).to.equal(
        mockMaxLimit * mockApiRateLimitAlgorithm[ApiRateLimitAlgorithmEnum.WINDOW_DURATION]
      );
    });

    it('should return the correct burst limit', async () => {
      const result = await useCase.execute(
        EvaluateApiRateLimitCommand.create({
          organizationId: session.organization._id,
          environmentId: session.environment._id,
          apiRateLimitCategory: mockApiRateLimitCategory,
          apiRateLimitCost: mockApiRateLimitCost,
        })
      );

      expect(result.burstLimit).to.equal(
        mockMaxLimit *
          mockApiRateLimitAlgorithm[ApiRateLimitAlgorithmEnum.WINDOW_DURATION] *
          (1 + mockApiRateLimitAlgorithm[ApiRateLimitAlgorithmEnum.BURST_ALLOWANCE])
      );
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - mockApiRateLimitCategory(ApiRateLimitCategoryEnum.GLOBAL;

describe('EvaluateApiRateLimit', async ())
 - evaluateTokenBucketRateLimitStub(sinon.stub(evaluateTokenBucketRateLimit, 'execute').resolves({
      success: true,
      limit: moc...)
 - result(await useCase.execute(
        EvaluateApiRateLimitCommand.create({
          organizationId: sessio...)
 - result(await useCase.execute(
        EvaluateApiRateLimitCommand.create({
          organizationId: sessio...)
 - result(await useCase.execute(
        EvaluateApiRateLimitCommand.create({
          organizationId: sessio...)
 - result(await useCase.execute(
        EvaluateApiRateLimitCommand.create({
          organizationId: sessio...)
 - result(await useCase.execute(
        EvaluateApiRateLimitCommand.create({
          organizationId: sessio...)
 - result(await useCase.execute(
        EvaluateApiRateLimitCommand.create({
          organizationId: sessio...)
 - result(await useCase.execute(
        EvaluateApiRateLimitCommand.create({
          organizationId: sessio...)
 - result(await useCase.execute(
        EvaluateApiRateLimitCommand.create({
          organizationId: sessio...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/rate-limiting/usecases/evaluate-api-rate-limit/evaluate-api-rate-limit.types.ts
Tamaño: 989 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export type EvaluateApiRateLimitResponseDto = {
  /**
   * Whether the request may pass(true) or exceeded the limit(false)
   */
  success: boolean;
  /**
   * Maximum number of requests allowed within a window.
   */
  limit: number;
  /**
   * How many requests the client has left within the current window.
   */
  remaining: number;
  /**
   * Unix timestamp in milliseconds when the limits are reset.
   */
  reset: number;
  /**
   * The duration of the window in seconds.
   */
  windowDuration: number;
  /**
   * The maximum number of requests allowed within a window, including the burst allowance.
   */
  burstLimit: number;
  /**
   * The number of requests that will be refilled per window.
   */
  refillRate: number;
  /**
   * The name of the algorithm used to calculate the rate limit.
   */
  algorithm: string;
  /**
   * The cost of the request.
   */
  cost: number;
  /**
   * The API service level used to evaluate the request.
   */
  apiServiceLevel: string;
};


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/rate-limiting/usecases/evaluate-api-rate-limit/evaluate-api-rate-limit.usecase.ts
Tamaño: 4220 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable } from '@nestjs/common';
import { buildEvaluateApiRateLimitKey, InstrumentUsecase } from '@novu/application-generic';
import {
  ApiRateLimitAlgorithmEnum,
  ApiServiceLevelEnum,
  FeatureNameEnum,
  getFeatureForTierAsNumber,
} from '@novu/shared';
import { EvaluateTokenBucketRateLimitCommand } from '../evaluate-token-bucket-rate-limit/evaluate-token-bucket-rate-limit.command';
import { EvaluateTokenBucketRateLimit } from '../evaluate-token-bucket-rate-limit/evaluate-token-bucket-rate-limit.usecase';
import { GetApiRateLimitAlgorithmConfig } from '../get-api-rate-limit-algorithm-config';
import { GetApiRateLimitCostConfig } from '../get-api-rate-limit-cost-config';
import { GetApiRateLimitMaximum, GetApiRateLimitMaximumCommand } from '../get-api-rate-limit-maximum';
import type { ApiServiceLevel } from '../get-api-rate-limit-maximum/get-api-rate-limit-maximum.dto';
import { EvaluateApiRateLimitCommand } from './evaluate-api-rate-limit.command';
import { EvaluateApiRateLimitResponseDto } from './evaluate-api-rate-limit.types';

@Injectable()
export class EvaluateApiRateLimit {
  constructor(
    private getApiRateLimitMaximum: GetApiRateLimitMaximum,
    private getApiRateLimitAlgorithmConfig: GetApiRateLimitAlgorithmConfig,
    private getApiRateLimitCostConfig: GetApiRateLimitCostConfig,
    private evaluateTokenBucketRateLimit: EvaluateTokenBucketRateLimit
  ) {}

  @InstrumentUsecase()
  async execute(command: EvaluateApiRateLimitCommand): Promise<EvaluateApiRateLimitResponseDto> {
    let maxLimitPerSecond: number;
    let apiServiceLevel: ApiServiceLevel;

    // For keyless environments, we implement strict rate limiting to prevent abuse:
    if (!command.organizationId || !command.environmentId) {
      maxLimitPerSecond = 3000;
      apiServiceLevel = ApiServiceLevelEnum.ENTERPRISE;
    } else {
      [maxLimitPerSecond, apiServiceLevel] = await this.getApiRateLimitMaximum.execute(
        GetApiRateLimitMaximumCommand.create({
          apiRateLimitCategory: command.apiRateLimitCategory,
          environmentId: command.environmentId,
          organizationId: command.organizationId,
        })
      );
    }

    const windowDuration = this.getApiRateLimitAlgorithmConfig.default[ApiRateLimitAlgorithmEnum.WINDOW_DURATION];
    const burstAllowance = this.getApiRateLimitAlgorithmConfig.default[ApiRateLimitAlgorithmEnum.BURST_ALLOWANCE];
    const cost = this.getApiRateLimitCostConfig.default[command.apiRateLimitCost];
    const maxTokensPerWindow = this.getMaxTokensPerWindow(maxLimitPerSecond, windowDuration);
    const refillRate = this.getRefillRate(maxLimitPerSecond, windowDuration);
    const burstLimit = this.getBurstLimit(maxTokensPerWindow, burstAllowance);

    // For keyless authentication, we'll use both environment and IP-based rate limiting
    const identifier = buildEvaluateApiRateLimitKey({
      _environmentId: command.environmentId || 'keyless_env',
      apiRateLimitCategory: command.ip
        ? `${command.apiRateLimitCategory}:ip=${command.ip}`
        : command.apiRateLimitCategory,
    });

    const { success, remaining, reset } = await this.evaluateTokenBucketRateLimit.execute(
      EvaluateTokenBucketRateLimitCommand.create({
        identifier,
        maxTokens: burstLimit,
        windowDuration,
        cost,
        refillRate,
      })
    );

    return {
      success,
      limit: maxTokensPerWindow,
      remaining,
      reset,
      windowDuration,
      burstLimit,
      refillRate,
      algorithm: this.evaluateTokenBucketRateLimit.algorithm,
      cost,
      apiServiceLevel,
    };
  }

  private getMaxTokensPerWindow(maxLimit: number, windowDuration: number): number {
    return maxLimit * windowDuration;
  }

  private getRefillRate(maxLimit: number, windowDuration: number): number {
    /*
     * Refill rate is currently set to the max tokens per window.
     * This can be changed to a different value to implement adaptive rate limiting.
     */
    return this.getMaxTokensPerWindow(maxLimit, windowDuration);
  }

  private getBurstLimit(maxTokensPerWindow: number, burstAllowance: number): number {
    return Math.floor(maxTokensPerWindow * (1 + burstAllowance));
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class EvaluateApiRateLimit

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/rate-limiting/usecases/evaluate-api-rate-limit/index.ts
Tamaño: 151 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './evaluate-api-rate-limit.command';
export * from './evaluate-api-rate-limit.types';
export * from './evaluate-api-rate-limit.usecase';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/rate-limiting/usecases/evaluate-token-bucket-rate-limit/evaluate-token-bucket-rate-limit.command.ts
Tamaño: 452 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { BaseCommand } from '@novu/application-generic';
import { IsDefined, IsNumber, IsString } from 'class-validator';

export class EvaluateTokenBucketRateLimitCommand extends BaseCommand {
  @IsDefined()
  @IsString()
  identifier: string;

  @IsDefined()
  @IsNumber()
  maxTokens: number;

  @IsDefined()
  @IsNumber()
  windowDuration: number;

  @IsDefined()
  @IsNumber()
  cost: number;

  @IsDefined()
  @IsNumber()
  refillRate: number;
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export class EvaluateTokenBucketRateLimitCommand

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/rate-limiting/usecases/evaluate-token-bucket-rate-limit/evaluate-token-bucket-rate-limit.spec.ts
Tamaño: 19694 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Test } from '@nestjs/testing';
import { CacheService, cacheService as inMemoryCacheService } from '@novu/application-generic';
import { expect } from 'chai';
import sinon from 'sinon';
import { v4 as uuid } from 'uuid';
import { SharedModule } from '../../../shared/shared.module';
import { RateLimitingModule } from '../../rate-limiting.module';
import { EvaluateTokenBucketRateLimitCommand } from './evaluate-token-bucket-rate-limit.command';
import { EvaluateTokenBucketRateLimit } from './evaluate-token-bucket-rate-limit.usecase';

describe('EvaluateTokenBucketRateLimit', () => {
  let useCase: EvaluateTokenBucketRateLimit;
  let cacheService: CacheService;

  const mockCommand = EvaluateTokenBucketRateLimitCommand.create({
    identifier: 'test',
    maxTokens: 10,
    windowDuration: 1,
    cost: 1,
    refillRate: 1,
  });

  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [SharedModule, RateLimitingModule],
    }).compile();

    useCase = moduleRef.get<EvaluateTokenBucketRateLimit>(EvaluateTokenBucketRateLimit);
    cacheService = moduleRef.get<CacheService>(CacheService);
  });

  describe('Static values', () => {
    it('should have a static algorithm value', () => {
      expect(useCase.algorithm).to.equal('token bucket');
    });
  });

  describe('Cache invocation', () => {
    let cacheServiceEvalStub: sinon.SinonStub;
    let cacheServiceSaddStub: sinon.SinonStub;
    let cacheServiceIsEnabledStub: sinon.SinonStub;

    beforeEach(async () => {
      cacheServiceEvalStub = sinon.stub(cacheService, 'eval');
      cacheServiceSaddStub = sinon.stub(cacheService, 'sadd');
      cacheServiceIsEnabledStub = sinon.stub(cacheService, 'cacheEnabled').returns(true);
    });

    afterEach(() => {
      cacheServiceEvalStub.restore();
      cacheServiceSaddStub.restore();
      cacheServiceIsEnabledStub.restore();
    });

    describe('Cache Errors', () => {
      it('should throw error when a cache operation fails', async () => {
        cacheServiceEvalStub.resolves(new Error());

        try {
          await useCase.execute(mockCommand);
          throw new Error('Should not reach here');
        } catch (e) {
          expect(e.message).to.equal('Failed to evaluate rate limit');
        }
      });

      it('should throw error when cache is not enabled', async () => {
        cacheServiceIsEnabledStub.returns(false);

        try {
          await useCase.execute(mockCommand);
          throw new Error('Should not reach here');
        } catch (e) {
          expect(e.message).to.equal('Rate limiting cache service is not available');
        }
      });
    });

    describe('Cache Service Adapter', () => {
      it('should invoke the SADD method with members casted to string', async () => {
        const cacheClient = EvaluateTokenBucketRateLimit.getCacheClient(cacheService);
        const key = 'testKey';
        const members = [1, 2];

        await cacheClient.sadd(key, ...members);

        expect(cacheServiceSaddStub.calledWith(key, ...['1', '2'])).to.equal(true);
      });

      it('should invoke the EVAL function with args casted to string', async () => {
        const cacheClient = EvaluateTokenBucketRateLimit.getCacheClient(cacheService);
        const script = 'return 1';
        const keys = ['key1', 'key2'];
        const args = [1, 2];

        await cacheClient.eval(script, keys, args);

        expect(cacheServiceEvalStub.calledWith(script, keys, ['1', '2'])).to.equal(true);
      });
    });

    describe.skip('Redis EVAL script benchmarks', () => {
      type TestCase = {
        /**
         * Test scenario description
         */
        description: string;
        /**
         * Total number of requests to simulate
         */
        totalRequests: number;
        /**
         * Proportion of requests that have a unique identifier
         */
        proportionUniqueIds: number;
        /**
         * Proportion of requests that are throttled
         */
        proportionThrottled: number;
        /**
         * Proportion of requests that are high cost
         */
        proportionHighCost: number;
        /**
         * The proportion of the window duration to jitter the request duration by.
         * Low value to simulate burst request patterns.
         * High value to simulate sustained request patterns.
         */
        proportionJitter: number;
        /**
         * Expected maximum total evaluation duration in milliseconds
         */
        expectedTotalTimeMs: number;
        /**
         * Expected average evaluation duration in milliseconds
         */
        expectedAverageTimeMs: number;
        /**
         * Expected nth percentile evaluation duration in milliseconds
         */
        expectedNthPercentileTimeMs: number;
      };

      const testCases: TestCase[] = [
        {
          description: 'Low Load - 0% Throttled - Sustained Single Window',
          totalRequests: 5000,
          proportionUniqueIds: 0.5,
          proportionThrottled: 0,
          proportionHighCost: 0,
          proportionJitter: 0.8,
          expectedTotalTimeMs: 1000,
          expectedAverageTimeMs: 10,
          expectedNthPercentileTimeMs: 30,
        },
        {
          description: 'Medium Load - 0% Throttled - Sustained Single Window',
          totalRequests: 10000,
          proportionUniqueIds: 0.5,
          proportionThrottled: 0,
          proportionHighCost: 0,
          proportionJitter: 0.8,
          expectedTotalTimeMs: 1000,
          expectedAverageTimeMs: 20,
          expectedNthPercentileTimeMs: 50,
        },
        {
          description: 'High Load - 0% Throttled - Sustained Single Window',
          totalRequests: 20000,
          proportionUniqueIds: 0.5,
          proportionThrottled: 0,
          proportionHighCost: 0,
          proportionJitter: 0.8,
          expectedTotalTimeMs: 1000,
          expectedAverageTimeMs: 200,
          expectedNthPercentileTimeMs: 500,
        },
        {
          description: 'Extreme Load - 0% Throttled - Sustained Single Window',
          totalRequests: 40000,
          proportionUniqueIds: 0.5,
          proportionThrottled: 0,
          proportionHighCost: 0,
          proportionJitter: 0.8,
          expectedTotalTimeMs: 2000,
          expectedAverageTimeMs: 500,
          expectedNthPercentileTimeMs: 2000,
        },
        {
          description: 'High Load - 0% Throttled - Burst Single Window',
          totalRequests: 20000,
          proportionUniqueIds: 0.5,
          proportionThrottled: 0,
          proportionHighCost: 0,
          proportionJitter: 0.2,
          expectedTotalTimeMs: 1000,
          expectedAverageTimeMs: 500,
          expectedNthPercentileTimeMs: 1000,
        },
        {
          description: 'Extreme Load - 0% Throttled - Burst Single Window',
          totalRequests: 40000,
          proportionUniqueIds: 0.5,
          proportionThrottled: 0,
          proportionHighCost: 0,
          proportionJitter: 0.2,
          expectedTotalTimeMs: 3000,
          expectedAverageTimeMs: 1500,
          expectedNthPercentileTimeMs: 2000,
        },
        {
          description: 'High Load - 50% Throttled - Burst Single Window',
          totalRequests: 20000,
          proportionUniqueIds: 0.5,
          proportionThrottled: 0.5,
          proportionHighCost: 0,
          proportionJitter: 0.2,
          expectedTotalTimeMs: 1000,
          expectedAverageTimeMs: 500,
          expectedNthPercentileTimeMs: 1000,
        },
        {
          description: 'High Load - 50% Throttled - Sustained Single Window',
          totalRequests: 20000,
          proportionUniqueIds: 0.5,
          proportionThrottled: 0.5,
          proportionHighCost: 0,
          proportionJitter: 0.8,
          expectedTotalTimeMs: 1000,
          expectedAverageTimeMs: 500,
          expectedNthPercentileTimeMs: 500,
        },
        {
          description: 'High Load - 50% Throttled & 50% High-Cost - Sustained Multiple Windows',
          totalRequests: 40000,
          proportionUniqueIds: 0.5,
          proportionThrottled: 0.5,
          proportionHighCost: 0.5,
          proportionJitter: 2.2,
          expectedTotalTimeMs: 3000,
          expectedAverageTimeMs: 30,
          expectedNthPercentileTimeMs: 100,
        },
        {
          description: 'Extreme Load - 50% Throttled & 50% High-Cost - Sustained Multiple Windows',
          totalRequests: 80000,
          proportionUniqueIds: 0.5,
          proportionThrottled: 0.5,
          proportionHighCost: 0.5,
          proportionJitter: 2.2,
          expectedTotalTimeMs: 4000,
          expectedAverageTimeMs: 1000,
          expectedNthPercentileTimeMs: 1500,
        },
        {
          description: 'High Load - 50% Throttled & 90% High-Cost - Sustained Multiple Windows',
          totalRequests: 40000,
          proportionUniqueIds: 0.5,
          proportionThrottled: 0.5,
          proportionHighCost: 0.9,
          proportionJitter: 2.2,
          expectedTotalTimeMs: 3000,
          expectedAverageTimeMs: 50,
          expectedNthPercentileTimeMs: 200,
        },
        {
          description: 'High Load - 50% Throttled & 0% Unique - Sustained Multiple Windows',
          totalRequests: 40000,
          proportionUniqueIds: 0,
          proportionThrottled: 0.5,
          proportionHighCost: 0,
          proportionJitter: 2.2,
          expectedTotalTimeMs: 3000,
          expectedAverageTimeMs: 30,
          expectedNthPercentileTimeMs: 200,
        },
        {
          description: 'High Load - 50% Throttled & 100% Unique - Sustained Multiple Windows',
          totalRequests: 40000,
          proportionUniqueIds: 1,
          proportionThrottled: 0.5,
          proportionHighCost: 0,
          proportionJitter: 2.2,
          expectedTotalTimeMs: 3000,
          expectedAverageTimeMs: 30,
          expectedNthPercentileTimeMs: 100,
        },
      ];
      const mockLowCost = 1;
      const mockHighCost = 10;
      const mockWindowDuration = 1;
      const mockWindowDurationMs = mockWindowDuration * 1000;
      const mockProportionRefill = 0.5;

      const testThrottledCountErrorTolerance = 0.2;
      const testPercentile = 0.95;

      function printHistogram(results) {
        // Define the number of bins for the histogram
        const bins = 10;

        // Find the maximum duration to scale the histogram
        const maxDuration = Math.max(...results.map((result) => result.duration));

        // Initialize an array for the histogram bins
        const histogram = Array(bins).fill(0);

        // Populate the histogram bins
        results.forEach((result) => {
          const index = Math.floor((result.duration / maxDuration) * bins);
          histogram[index < bins ? index : bins - 1] += 1;
        });

        // Find the maximum bin count to scale the histogram height
        const maxCount = Math.max(...histogram);

        // Print the histogram
        console.log(`\t  Request Time (ms)`);
        histogram.forEach((count, i) => {
          const bar = '*'.repeat((count / maxCount) * 50); // Scale to a max width of 50 "*"
          console.log(`\t  ${(((i + 1) / bins) * maxDuration).toFixed(2).padStart(7)}: ${bar}`);
        });
      }

      testCases
        .map(
          ({
            description,
            totalRequests,
            proportionUniqueIds,
            proportionThrottled,
            proportionHighCost,
            proportionJitter,
            expectedAverageTimeMs,
            expectedNthPercentileTimeMs,
            expectedTotalTimeMs,
          }) => {
            return () => {
              describe(description, () => {
                let testContext;
                let results: Array<{ duration: number; success: boolean }>;
                let totalTime: number;
                let averageTime: number;
                let successCount: number;
                let throttledCount: number;
                let variance: number;
                let stdev: number;
                let nthPercentile: number;

                const maxTokens = Math.ceil(totalRequests * (1 - proportionThrottled));
                const uniqueIdRequests = Math.max(1, Math.floor(totalRequests * proportionUniqueIds));
                const uniqueIds = Array.from({ length: uniqueIdRequests }).map(() => uuid());
                const mockRepeatId = uuid();
                const maxJitterMs = mockWindowDurationMs * proportionJitter;

                const refillPerWindow = (maxTokens * mockProportionRefill) / mockWindowDuration;

                before(async () => {
                  const cacheServiceInitialized = await inMemoryCacheService.useFactory();
                  testContext = {
                    redis: EvaluateTokenBucketRateLimit.getCacheClient(cacheServiceInitialized),
                  };

                  const proms = Array.from({ length: totalRequests }).map(async (_val, index) => {
                    const cost = Math.random() < proportionHighCost ? mockHighCost : mockLowCost;
                    /**
                     * Distribute unique ids with request allocation skewed left.
                     * matching an expected distribution of requests per unique API client, where:
                     * - the majority of clients make a small number of requests
                     * - a small number of clients make a large number of requests
                     *
                     * Number of Requests per Unique Id
                     * ID Requests
                     *  1 *
                     *  2 **
                     *  3 ****
                     *  4 ******
                     *  5 *********
                     *  6 *************
                     *  7 *****************
                     *  8 ***********************
                     *  9 ********************************
                     * 10 *******************************************
                     */
                    const id =
                      Math.random() < proportionUniqueIds
                        ? uniqueIds[Math.floor((index / totalRequests) * uniqueIds.length)]
                        : mockRepeatId;

                    const jitter = Math.floor(Math.random() * maxJitterMs);
                    await new Promise((resolve) => {
                      setTimeout(resolve, jitter);
                    });
                    const start = Date.now();
                    const limit = EvaluateTokenBucketRateLimit.tokenBucketLimiter(
                      refillPerWindow,
                      mockWindowDuration,
                      maxTokens,
                      cost
                    );
                    const { success } = await limit(testContext, id);
                    const end = Date.now();
                    const duration = end - start;

                    return {
                      duration,
                      success,
                    };
                  });

                  const startAll = Date.now();
                  results = await Promise.all(proms);
                  const endAll = Date.now();

                  totalTime = endAll - startAll;
                  averageTime = results.reduce((acc, val) => acc + val.duration, 0) / results.length;
                  variance = results.reduce((acc, val) => acc + (val.duration - averageTime) ** 2, 0) / results.length;
                  stdev = Math.sqrt(variance);
                  nthPercentile = results.sort((a, b) => a.duration - b.duration)[
                    Math.floor(results.length * testPercentile)
                  ].duration;
                  successCount = results.filter(({ success }) => success).length;
                  throttledCount = totalRequests - successCount;

                  console.log(
                    `\t  Params:  Total Req: ${totalRequests.toLocaleString()}\tUsers: ${uniqueIdRequests.toLocaleString()}\tThrottled: ${
                      proportionThrottled * 100
                    }%\tHigh Cost: ${proportionHighCost * 100}%\tJitter: ${maxJitterMs}ms`
                  );
                  console.log(
                    `\t  Stats:   Total Time: ${totalTime.toLocaleString()}ms\tAvg: ${averageTime.toFixed(
                      1
                    )}ms\tStdev: ${stdev.toFixed(1)}\tp(${
                      testPercentile * 100
                    }): ${nthPercentile}\tThrottled: ${throttledCount.toLocaleString()}`
                  );
                  printHistogram(results);
                });

                describe('Script Performance', () => {
                  it(`should be able to process ${totalRequests.toLocaleString()} evaluations in less than ${expectedTotalTimeMs}ms`, async () => {
                    expect(totalTime).to.be.lessThan(expectedTotalTimeMs);
                  });

                  it(`should have average evaluation duration less than ${expectedAverageTimeMs}ms`, async () => {
                    expect(averageTime).to.be.lessThan(expectedAverageTimeMs);
                  });

                  it(`should have ${
                    testPercentile * 100
                  }th percentile evaluation duration less than ${expectedNthPercentileTimeMs}ms`, async () => {
                    expect(nthPercentile).to.be.lessThan(expectedNthPercentileTimeMs);
                  });
                });

                describe('Script Throttle Evaluation', () => {
                  const proportionRequestsPerWindow =
                    maxJitterMs > mockWindowDurationMs ? mockWindowDurationMs / maxJitterMs : 1;
                  const totalRequestsPerWindow = Math.floor(totalRequests * proportionRequestsPerWindow);
                  const uniqueRequestsPerWindow = Math.floor(totalRequestsPerWindow * (1 - proportionThrottled));
                  const expectedPerRequestCost =
                    (1 - proportionHighCost) * mockLowCost + proportionHighCost * mockHighCost;

                  const expectedWindowCost = uniqueRequestsPerWindow * expectedPerRequestCost;
                  const firstWindowThrottledRequests =
                    expectedWindowCost > maxTokens ? (expectedWindowCost - maxTokens) / expectedPerRequestCost : 0;
                  const secondWindowMaxTokens = Math.max(
                    maxTokens,
                    maxTokens - firstWindowThrottledRequests + refillPerWindow
                  );
                  const secondWindowThrottledRequests =
                    expectedWindowCost > secondWindowMaxTokens
                      ? (expectedWindowCost - secondWindowMaxTokens) / expectedPerRequestCost
                      : 0;

                  const expectedThrottledCount = firstWindowThrottledRequests + secondWindowThrottledRequests;
                  const expectedThrottledCountMin = Math.floor(
                    expectedThrottledCount * (1 - testThrottledCountErrorTolerance)
                  );
                  const expectedThrottledCountMax = Math.floor(
                    expectedThrottledCount * (1 + testThrottledCountErrorTolerance)
                  );

                  it(`should throttle between ${expectedThrottledCountMin} and ${expectedThrottledCountMax} requests`, async () => {
                    expect(throttledCount).to.be.greaterThanOrEqual(expectedThrottledCountMin);
                    expect(throttledCount).to.be.lessThanOrEqual(expectedThrottledCountMax);
                  });
                });
              });
            };
          }
        )
        .forEach((testCase) => {
          testCase();
        });
    });
  });
});


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Funciones 'function' encontradas:
 - printHistogram(results)
Asignaciones con arrow functions encontradas (posibles funciones):
 - mockCommand(EvaluateTokenBucketRateLimitCommand.create({
    identifier: 'test',
    maxTokens: 10,
    windowDu...)
 - cacheService(moduleRef.get<CacheService>(CacheService);
  });

  describe('Static values', ())
 - cacheServiceIsEnabledStub(sinon.stub(cacheService, 'cacheEnabled').returns(true);
    });

    afterEach(())
 - members([1, 2];

        await cacheClient.sadd(key, ...members);

        expect(cacheServiceSaddStub.calle...)
 - args([1, 2];

        await cacheClient.eval(script, keys, args);

        expect(cacheServiceEvalStub.ca...)
 - maxDuration(Math.max(...results.map((result))
 - histogram(Array(bins).fill(0);

        // Populate the histogram bins
        results.forEach((result))
 - maxCount(Math.max(...histogram);

        // Print the histogram
        console.log(`\t  Request Time (ms)`)...)
 - bar('*'.repeat((count / maxCount) * 50); // Scale to a max width of 50 "*"
          console.log(`\t  ${...)
 - uniqueIds(Array.from({ length: uniqueIdRequests }).map(())
 - refillPerWindow(maxTokens * mockProportionRefill) / mockWindowDuration;

                before(async ())
 - proms(Array.from({ length: totalRequests }).map(async (_val, index))
 - jitter(Math.floor(Math.random() * maxJitterMs);
                    await new Promise((resolve))
 - averageTime(results.reduce((acc, val))
 - variance(results.reduce((acc, val))
 - nthPercentile(results.sort((a, b))
 - successCount(results.filter(({ success }))
 - throttledCount(totalRequests - successCount;

                  console.log(
                    `\t  Params:  Tota...)
 - expectedThrottledCountMax(Math.floor(
                    expectedThrottledCount * (1 + testThrottledCountErrorTolerance)
    ...)

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/rate-limiting/usecases/evaluate-token-bucket-rate-limit/evaluate-token-bucket-rate-limit.types.ts
Tamaño: 1659 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Ratelimit } from '@upstash/ratelimit';

export type UpstashRedisClient = ConstructorParameters<typeof Ratelimit>[0]['redis'];

export type EvaluateTokenBucketRateLimitResponseDto = {
  /**
   * Whether the request may pass(true) or exceeded the limit(false)
   */
  success: boolean;
  /**
   * Maximum number of requests allowed within a window.
   */
  limit: number;
  /**
   * How many requests the client has left within the current window.
   */
  remaining: number;
  /**
   * Unix timestamp in milliseconds when the limits are reset.
   */
  reset: number;
};

export type RegionLimiter = ReturnType<typeof Ratelimit.tokenBucket>;

/**
 * You have a bucket filled with `{maxTokens}` tokens that refills constantly
 * at `{refillRate}` per `{interval}`.
 * Every request will remove `{cost}` token(s) from the bucket and if there is no
 * token to take, the request is rejected.
 *
 * **Pro:**
 *
 * - Bursts of requests are smoothed out and you can process them at a constant
 * rate.
 * - Allows to set a higher initial burst limit by setting `maxTokens` higher
 * than `refillRate`
 */
export type CostLimiter = (
  /**
   * How many tokens are refilled per `interval`
   *
   * An interval of `10s` and refillRate of 5 will cause a new token to be added every 2 seconds.
   */
  refillRate: number,
  /**
   * The interval in seconds for the `refillRate`
   */
  interval: number,
  /**
   * Maximum number of tokens.
   * A newly created bucket starts with this many tokens.
   * Useful to allow higher burst limits.
   */
  maxTokens: number,
  /**
   * The number of tokens used in the request.
   */
  cost: number
) => RegionLimiter;


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - CostLimiter(/**
   * How many tokens are refilled per `interval`
   *
   * An interval of `10s` and refillRate o...)
Declaraciones 'export' encontradas:
- export  type
- export  type
- export  type
- export  type

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/rate-limiting/usecases/evaluate-token-bucket-rate-limit/evaluate-token-bucket-rate-limit.usecase.ts
Tamaño: 6696 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Injectable, ServiceUnavailableException } from '@nestjs/common';
import { CacheService, InstrumentUsecase, PinoLogger } from '@novu/application-generic';
import { Ratelimit } from '@upstash/ratelimit';
import { EvaluateTokenBucketRateLimitCommand } from './evaluate-token-bucket-rate-limit.command';
import {
  EvaluateTokenBucketRateLimitResponseDto,
  RegionLimiter,
  UpstashRedisClient,
} from './evaluate-token-bucket-rate-limit.types';

const LOG_CONTEXT = 'EvaluateTokenBucketRateLimit';

@Injectable()
export class EvaluateTokenBucketRateLimit {
  private ephemeralCache = new Map<string, number>();
  public algorithm = 'token bucket';

  constructor(
    private cacheService: CacheService,
    private logger: PinoLogger
  ) {
    this.logger.setContext(this.constructor.name);
  }

  @InstrumentUsecase()
  async execute(command: EvaluateTokenBucketRateLimitCommand): Promise<EvaluateTokenBucketRateLimitResponseDto> {
    if (!this.cacheService.cacheEnabled()) {
      const message = 'Rate limiting cache service is not available';
      this.logger.error(message);
      throw new ServiceUnavailableException(message);
    }

    const cacheClient = EvaluateTokenBucketRateLimit.getCacheClient(this.cacheService);

    const ratelimit = new Ratelimit({
      redis: cacheClient,
      limiter: EvaluateTokenBucketRateLimit.tokenBucketLimiter(
        command.refillRate,
        command.windowDuration,
        command.maxTokens,
        command.cost
      ),
      prefix: '', // Empty cache key prefix to give us full control over the key format
      ephemeralCache: this.ephemeralCache,
    });
    try {
      const { success, limit, remaining, reset } = await ratelimit.limit(command.identifier);

      return {
        success,
        limit,
        remaining,
        reset,
      };
    } catch (error) {
      const apiMessage = 'Failed to evaluate rate limit';
      const logMessage = `${apiMessage} for identifier: "${command.identifier}". Error: "${error}"`;
      this.logger.error(logMessage);
      throw new ServiceUnavailableException(apiMessage);
    }
  }

  public static getCacheClient(cacheService: CacheService): UpstashRedisClient {
    // Adapter for the @upstash/redis client -> cache client
    return {
      sadd: async (key, ...members) => cacheService.sadd(key, ...members.map((member) => String(member))),
      eval: async (script, keys, args) =>
        cacheService.eval(
          script,
          keys,
          args.map((arg) => String(arg))
        ),
    };
  }

  /**
   * Token Bucket algorithm with variable cost. Adapted from @upstash/ratelimit and modified to support variable cost.
   * Also influenced by Krakend's token bucket implementation to delay refills until bucket is empty.
   *
   * @see https://github.com/upstash/ratelimit/blob/3a8cfb00e827188734ac347965cb743a75fcb98a/src/single.ts#L292
   * @see https://github.com/krakend/krakend-ratelimit/blob/369f0be9b51a4fb8ab7d43e4833d076b461a4374/rate.go#L85
   */
  public static tokenBucketLimiter(
    refillRate: number,
    interval: number,
    maxTokens: number,
    cost: number
  ): RegionLimiter {
    const script = /* Lua */ `
    local key          = KEYS[1]           -- current interval identifier including prefixes
    local maxTokens    = tonumber(ARGV[1]) -- maximum number of tokens
    local interval     = tonumber(ARGV[2]) -- size of the window in milliseconds
    local fillInterval = tonumber(ARGV[3]) -- time between refills in milliseconds
    local now          = tonumber(ARGV[4]) -- current timestamp in milliseconds
    local cost         = tonumber(ARGV[5]) -- cost of request
    local remaining    = 0 -- remaining number of tokens
    local reset        = 0 -- timestamp when next request of {cost} token(s) can be accepted
    local resetCost    = 0 -- multiplier for the next reset time
    local lastRefill   = 0 -- timestamp of last refill

    local bucket = redis.call("HMGET", key, "lastRefill", "tokens")

    if bucket[1] == false then
      -- The bucket does not exist yet, so we create it and add a ttl.
      lastRefill = now
      remaining = maxTokens - cost
      resetCost = (remaining < cost) and (cost - remaining) or cost
      redis.call("HMSET", key, "lastRefill", lastRefill, "tokens", remaining)
      redis.call("PEXPIRE", key, interval * 2)
    else
      -- The current bucket does exist
      lastRefill = tonumber(bucket[1])
      local tokens = tonumber(bucket[2])

      if tokens >= cost then
        -- Delay refill until bucket is empty
        remaining = tokens - cost
        resetCost = (remaining < cost) and (cost - remaining) or cost
        redis.call("HMSET", key, "tokens", remaining)
      else
        local elapsed = now - lastRefill
        local tokensToAdd = math.floor(elapsed / fillInterval)
        local newTokens = math.min(maxTokens, tokens + tokensToAdd)
        remaining = newTokens - cost

        if remaining >= 0 then
          -- Update the time of the last refill depending on how many tokens we added
          lastRefill = lastRefill + tokensToAdd * fillInterval
          resetCost = (remaining < cost) and (cost - remaining) or cost
          redis.call("HMSET", key, "lastRefill", lastRefill, "tokens", remaining)
          redis.call("PEXPIRE", key, interval * 2)
        else
          resetCost = cost - tokens
        end
      end
    end
    
    reset = lastRefill + resetCost * fillInterval
    return {remaining, reset}
`;

    const intervalDurationMs = interval * 1e3;
    const fillInterval = intervalDurationMs / refillRate;

    return async (ctx, identifier) => {
      // Cost needs to be included in local cache identifier to ensure lower cost requests are not blocked
      const localCacheIdentifier = `${identifier}:${cost}`;

      if (ctx.cache) {
        const { blocked, reset } = ctx.cache.isBlocked(localCacheIdentifier);
        if (blocked) {
          return {
            success: false,
            limit: refillRate,
            remaining: 0,
            reset,
            pending: Promise.resolve(),
          };
        }
      }

      const now = Date.now();

      const [remaining, reset] = (await ctx.redis.eval(
        script,
        [identifier],
        [maxTokens, intervalDurationMs, fillInterval, now, cost]
      )) as [number, number];

      const success = remaining >= 0;
      const nonNegativeRemaining = Math.max(0, remaining);
      if (ctx.cache && !success) {
        ctx.cache.blockUntil(localCacheIdentifier, reset);
      }

      return {
        success,
        limit: refillRate,
        remaining: nonNegativeRemaining,
        reset,
        pending: Promise.resolve(),
      };
    };
  }
}


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Asignaciones con arrow functions encontradas (posibles funciones):
 - logMessage(`${apiMessage} for identifier: "${command.identifier}". Error: "${error}"`;
      this.logger.error(...)
 - fillInterval(intervalDurationMs / refillRate;

    return async (ctx, identifier))
Declaraciones 'export' encontradas:
- export class EvaluateTokenBucketRateLimit

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/rate-limiting/usecases/evaluate-token-bucket-rate-limit/index.ts
Tamaño: 178 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

export * from './evaluate-token-bucket-rate-limit.command';
export * from './evaluate-token-bucket-rate-limit.types';
export * from './evaluate-token-bucket-rate-limit.usecase';


### ANALISIS AUTOMATICO (ESPAÑOL) ###

Declaraciones 'export' encontradas:
- export
- export
- export

### SUGERENCIAS PARA CREAR TU PROPIA VERSIÓN ###

- Revisa package.json para dependencias y scripts.
- Usa módulos (import/export) y prueba con node o bundler.
- Añade un README con pasos de instalación (npm install, npm start).



################################################################################
Archivo: novu-next/apps/api/src/app/rate-limiting/usecases/get-api-rate-limit-algorithm-config/get-api-rate-limit-algorithm-config.spec.ts
Tamaño: 1633 bytes
Lenguaje detectado: TypeScript

### CONTENIDO ORIGINAL ###

import { Test } from '@nestjs/testing';
import {
  ApiRateLimitAlgorithmEnum,
  ApiRateLimitAlgorithmEnvVarFormat,
  DEFAULT_API_RATE_LIMIT_ALGORITHM_CONFIG,
} from '@novu/shared';
import { expect } from 'chai';
import { GetApiRateLimitAlgorithmConfig } from './get-api-rate-limit-algorithm-config.usecase';

describe('GetApiRateLimitAlgorithmConfig', () => {
  let useCase: GetApiRateLimitAlgorithmConfig;

  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      providers: [GetApiRateLimitAlgorithmConfig],
    }).compile();

    useCase = moduleRef.get<GetApiRateLimitAlgorithmConfig>(GetApiRateLimitAlgorithmConfig);
  });

  it('should use the default rate limit algorithm config when no environment variables are set', () => {
    expect(useCase.default).to.deep.equal(DEFAULT_API_RATE_LIMIT_ALGORITHM_CONFIG);
  });

  it('should override default rate limit algorithm config with environment variables', () => {
    const mockOverrideBurstAllowance = 0.2;
    const mockApiRateLimitConfigurationKey = ApiRateLimitAlgorithmEnum.BURST_ALLOWANCE;

    const envVarName: ApiRateLimitAlgorithmEnvVarFormat = `API_RATE_LIMIT_ALGORITHM_${
      mockApiRateLimitConfigurationKey.toUpperCase() as Uppercase<ApiRateLimitAlgorithmEnum>
    }`;
    process.env[envVarName] = `${mockOverrideBurstAllowance}`;

    // Re-initialize the defaultApiRateLimits after setting the environment variable
    useCase.loadDefault();
    const result = useCase.default;

    expect(result[mockApiRateLimitConfigurationKey]).to.equal(mockOverrideBurstAllowance);
    delete process.env[envVarName]; // cleanup
  });
});
